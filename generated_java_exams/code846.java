/*
 * Exam Question #846
 * Generated on: 2025-05-12 16:49:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Task Management System for a small processing unit. The system should allow users to add new tasks, process the next task in a queue, view pending tasks, and view completed tasks. Each task has a name and a type. The system must handle user interaction, manage task flow, and provide robust error handling.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `name` (String) and `type` (String). Include a constructor and public getter methods for these fields.
 * 2.  **Task Management Logic:** Create a `TaskProcessor` class that manages the tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   It must use a `java.util.List<Task>` (specifically instantiated as a `java.util.ArrayList<Task>`) to store tasks that have been completed.
 *     *   It must use a `java.util.Scanner` to read user input from the console.
 *     *   Implement methods for:
 *         *   Adding a new task to the pending queue. This method should prompt the user for the task name and type.
 *         *   Processing the next task: Remove the task from the front of the pending queue and add it to the completed list. Handle the case where the pending queue is empty.
 *         *   Viewing all pending tasks.
 *         *   Viewing all completed tasks.
 *         *   A main loop that presents a menu to the user and processes their commands.
 * 3.  **User Interface:**
 *     *   Present a clear menu of options to the user (e.g., Add Task, Process Next, View Pending, View Completed, Exit).
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 * 4.  **Input Handling and Validation:**
 *     *   Use `Scanner` to read user input for menu choices and task details.
 *     *   Validate user input for adding tasks: ensure name and type are not empty strings. Use `System.err` to report validation errors.
 * 5.  **Flow Control:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main processing loop of the `TaskProcessor`. This block should catch potential runtime exceptions and print an error message using `System.err`.
 *     *   Handle the specific case of trying to process a task when the queue is empty with a user-friendly message using `System.out`.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining key parts of the code.
 *     *   Ensure proper encapsulation in the `Task` class.
 *     *   Close the `Scanner` resource when the application exits.
 * 
 * **Task Types:** For simplicity, assume task types can be any string, but the user input validation should still apply.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interaction might look like:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task name: Task A
 * Enter task type: CPU
 * Task 'Task A' (CPU) added to pending queue.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task name: Task B
 * Enter task type: IO
 * Task 'Task B' (IO) added to pending queue.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task: Task A (Type: CPU)
 * Task: Task B (Type: IO)
 * ---------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task A (Type: CPU)
 * Task 'Task A' processed and moved to completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task: Task A (Type: CPU)
 * -----------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task B (Type: IO)
 * Task 'Task B' processed and moved to completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * No tasks pending.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation and usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Correct implementation of task management logic (adding, processing, viewing).
 * *   Effective user interaction and clear output.
 * *   Robust input validation and error handling.
 * *   Code quality (naming, comments, structure).
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the `name` and `type` fields as `private`, providing public `getter` methods. This adheres to the principle of encapsulation. The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **TaskProcessor Class:** This is the core class managing the system logic.
 *     *   **`Queue<Task> pendingTasks`**: A `java.util.Queue` (specifically using `java.util.LinkedList` as an implementation) is used to store tasks waiting to be processed. The `Queue` interface provides methods like `offer()` (to add to the end) and `poll()` (to remove from the front), which are ideal for a First-In, First-Out (FIFO) processing order.
 *     *   **`List<Task> completedTasks`**: A `java.util.List` (specifically instantiated as a `java.util.ArrayList`) is used to store tasks once they are processed. Using the `List` interface type for the variable (`List<Task>`) while instantiating with a concrete class (`new ArrayList<>()`) demonstrates polymorphism and good practice. `ArrayList` is suitable here for storing a dynamic collection of completed tasks.
 *     *   **`Scanner scanner`**: A `java.util.Scanner` is used to read user input from `System.in`. It's initialized in the constructor and closed in a `finally` block to ensure resource cleanup.
 *     *   **Methods (`displayMenu`, `addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `closeScanner`, `run`)**: These methods encapsulate the system's functionality, making the code modular and readable.
 *         *   `addTask` uses `scanner.nextLine()` to read entire lines, preventing issues with spaces in names/types and handling the newline character correctly for subsequent reads. It includes basic input validation for empty strings, reporting errors using `System.err`.
 *         *   `processNextTask` uses `pendingTasks.poll()` to get and remove the next task. It checks if the queue is empty before attempting to poll.
 *         *   `viewPendingTasks` and `viewCompletedTasks` iterate through their respective collections to display contents using `System.out`.
 *         *   `closeScanner` ensures the scanner is closed.
 *         *   `run` contains the main application loop.
 * 
 * 3.  **User Interface (`System.out`, `System.err`)**: `System.out.println` and `System.out.print` are used for all standard output, including the menu, prompts, and successful operation messages. `System.err.println` is specifically used for reporting errors, such as invalid input or unexpected exceptions, directing these messages to the standard error stream.
 * 
 * 4.  **Input Handling and Flow Control (`Scanner`, `switch`)**: The `run` method uses `scanner.nextLine()` to get the user's menu choice. A `try-catch` block specifically handles `NumberFormatException` if the user enters non-integer input for the menu choice. A `switch` statement then directs the program flow based on the validated integer choice, calling the appropriate methods. The `default` case in the `switch` handles valid integer inputs that do not correspond to a menu option.
 * 
 * 5.  **Exception Handling (`try-catch`)**:
 *     *   A `try-catch(NumberFormatException e)` block is used around `Integer.parseInt(input)` to handle cases where the user enters non-numeric input for the menu choice.
 *     *   A broader `try-catch(Exception e)` block wraps the main `while` loop in the `run` method. This serves as a class-wide or top-level handler for any other unexpected runtime exceptions that might occur during the execution of the loop's body (e.g., null pointer exceptions if logic errors existed, although the current implementation is designed to avoid common ones). This catch block prints a generic error message using `System.err`.
 *     *   A `finally` block is associated with the main `try-catch` to ensure that `closeScanner()` is always called, regardless of whether the loop finishes normally or an exception occurs.
 * 
 * 6.  **Best Practices**:
 *     *   Meaningful names like `pendingTasks`, `completedTasks`, `addTask`, `processNextTask` are used.
 *     *   Comments explain the purpose of classes and key methods/variables.
 *     *   Encapsulation is applied in the `Task` class.
 *     *   Input validation is performed for task details.
 *     *   Error handling distinguishes between user input errors (`System.err` with specific messages) and unexpected system errors (`System.err` in the main catch).
 *     *   The code is structured into logical methods within the `TaskProcessor` class.
 * 
 * This solution effectively combines the required Java components to create a functional, albeit simple, task management system that demonstrates core programming concepts and best practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// Represents a single task with a name and type
class Task {
    private String name;
    private String type;

    // Constructor
    public Task(String name, String type) {
        this.name = name;
        this.type = type;
    }

    // Getter for task name
    public String getName() {
        return name;
    }

    // Getter for task type
    public String getType() {
        return type;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Task: " + name + " (Type: " + type + ")";
    }
}

// Manages the queue of pending tasks and list of completed tasks
class TaskProcessor {
    // Queue to hold tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed. Using List interface type.
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    // Constructor initializes the data structures and scanner
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // ArrayList implements the List interface
        this.scanner = new Scanner(System.in);
    }

    // Displays the main menu to the user
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new task to the pending queue based on user input
    private void addTask() {
        System.out.print("Enter task name: ");
        String name = scanner.nextLine().trim(); // Read full line and trim whitespace
        System.out.print("Enter task type: ");
        String type = scanner.nextLine().trim();

        // Input validation
        if (name.isEmpty() || type.isEmpty()) {
            System.err.println("Error: Task name and type cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(name, type);
        pendingTasks.offer(newTask); // offer is preferred over add in queues as it doesn't throw exception on failure
        System.out.println("Task '" + name + "' (" + type + ") added to pending queue.");
    }

    // Processes the next task in the pending queue
    private void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head of the queue
            if (nextTask != null) { // poll returns null if queue is empty, though we checked isEmpty
                System.out.println("Processing task: " + nextTask);
                completedTasks.add(nextTask); // Add to the list of completed tasks
                System.out.println("Task '" + nextTask.getName() + "' processed and moved to completed.");
            }
        }
    }

    // Displays all tasks currently in the pending queue
    private void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
            System.out.println("---------------------");
        }
    }

    // Displays all tasks that have been completed
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
            // Iterate through the list of completed tasks
            for (Task task : completedTasks) {
                System.out.println(task);
            }
            System.out.println("-----------------------");
        }
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    // Main method to run the task processor
    public void run() {
        int choice = -1; // Initialize choice to a value that won't exit immediately

        // Class-wide exception handling around the main loop
        try {
            while (choice != 5) {
                displayMenu();
                String input = scanner.nextLine(); // Read choice as string first

                try {
                    // Attempt to parse the input as an integer
                    choice = Integer.parseInt(input);

                    // Use switch for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Management System.");
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    choice = -1; // Reset choice to continue loop
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging
            // e.printStackTrace(System.err);
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or if an exception occurs
            closeScanner();
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
