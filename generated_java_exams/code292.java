/*
 * Exam Question #292
 * Generated on: 2025-05-11 22:50:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Production Line Simulation
 * 
 * **Objective:** Design and implement a simplified simulation of a production line that processes tasks. This task requires you to demonstrate proficiency in using core Java collections, input handling, control flow, and exception handling within a well-structured, object-oriented program.
 * 
 * **Scenario:** You are building a system to manage tasks on a simple production line. Tasks are added to a waiting queue. When the line is ready, the next task from the queue is processed and moved to a list of completed tasks. The system should allow users to add new tasks, process the next task, and view the current waiting and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **`ProductionTask` Class:**
 *     *   Create a class named `ProductionTask` to represent a single task.
 *     *   It must have `private` fields for `taskId` (an integer, unique), `description` (a String), and `status` (a String, e.g., "Waiting", "Completed").
 *     *   Include a constructor `ProductionTask(int taskId, String description)` that initializes the task with the given ID and description, setting the initial status to "Waiting".
 *     *   Provide `public` getter methods for all fields (`getTaskId`, `getDescription`, `getStatus`).
 *     *   Provide a `public` method `setStatus(String status)` to update the task's status.
 *     *   Override the `toString()` method to provide a clear string representation of the task (e.g., `[ID: 1] Description: Build Widget, Status: Waiting`).
 *     *   Include appropriate Javadoc comments for the class and its methods.
 * 
 * 2.  **`ProductionLineSimulator` Class:**
 *     *   Create a class named `ProductionLineSimulator` which contains the `main` method and the simulation logic.
 *     *   It must manage two collections:
 *         *   A `Queue<ProductionTask>` to hold tasks that are waiting to be processed. Use an implementation like `LinkedList`.
 *         *   A `List<ProductionTask>` to hold tasks that have been completed. Use `ArrayList`.
 *     *   Declare these collections as `private` fields within the `ProductionLineSimulator` class.
 *     *   Include a `private` integer field `nextTaskId` initialized to 1, used to assign unique IDs to new tasks.
 *     *   Include a `private` `Scanner` field for handling user input.
 *     *   Implement a `public void run()` method that contains the main simulation loop. This method should display a menu, read user input, and perform actions based on the user's choice.
 *     *   The `run()` method must use a `switch` statement to handle the different menu options.
 *     *   The simulation loop should continue until the user chooses to exit.
 *     *   Implement the following functionalities as separate `private` methods called from the `switch` statement:
 *         *   `addTask(Scanner scanner)`: Prompts the user for a task description, creates a new `ProductionTask` with the next available `taskId`, adds it to the waiting queue, and increments `nextTaskId`. Include input validation to ensure the description is not empty.
 *         *   `processNextTask()`: Removes the next task from the waiting queue. If a task is retrieved, update its status to "Completed" and add it to the completed tasks list. If the queue is empty, display an appropriate error message.
 *         *   `viewTasks(Scanner scanner)`: Prompts the user to choose whether to view "Waiting" or "Completed" tasks. Based on the choice, iterate through the appropriate collection and print the details of each task using its `toString()` method. Handle invalid viewing choices.
 * 
 * 3.  **Error Handling and Input Validation:**
 *     *   The `run()` method must use a class-wide `try-catch` block to handle potential exceptions during the main loop, particularly `InputMismatchException` if the user enters non-integer input for the menu choice. Print error messages to `System.err` and handle the invalid input gracefully (e.g., clear the scanner buffer and continue the loop).
 *     *   Use `System.err` for all error messages (e.g., invalid input, queue empty).
 *     *   Use `System.out` for menu display, prompts, task listings, and success messages.
 *     *   Ensure input validation is performed where necessary (e.g., non-empty task description, valid menu/viewing choices).
 * 
 * 4.  **Best Practices:**
 *     *   Follow proper encapsulation principles (private fields, public methods for interaction).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include comments and Javadoc as specified.
 *     *   Ensure the `Scanner` is properly closed when the program exits (e.g., using try-with-resources or in the `main` method).
 * 
 * **Execution:** The program should start by displaying the menu. The user interacts with the system by entering numbers corresponding to menu options.
 * 
 * **Expected Output Structure (Example):**
 * 
 * ```
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Build Prototype
 * Task added: [ID: 1] Description: Build Prototype, Status: Waiting
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Test Software
 * Task added: [ID: 2] Description: Test Software, Status: Waiting
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 2
 * Processing next task...
 * Task processed: [ID: 1] Description: Build Prototype, Status: Completed
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 3
 * View Tasks Menu:
 * 1. Waiting Tasks
 * 2. Completed Tasks
 * Enter your choice: 1
 * --- Waiting Tasks ---
 * [ID: 2] Description: Test Software, Status: Waiting
 * ---------------------
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 3
 * View Tasks Menu:
 * 1. Waiting Tasks
 * 2. Completed Tasks
 * Enter your choice: 2
 * --- Completed Tasks ---
 * [ID: 1] Description: Build Prototype, Status: Completed
 * -----------------------
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 5
 * System.err: Invalid choice. Please enter a number between 1 and 4.
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 2
 * Processing next task...
 * Task processed: [ID: 2] Description: Test Software, Status: Completed
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 2
 * Processing next task...
 * System.err: No tasks in the waiting queue to process.
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: exit
 * System.err: Invalid input. Please enter a number.
 * 
 * Production Line Simulation Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Tasks
 * 4. Exit
 * Enter your choice: 4
 * Exiting Production Line Simulation.
 * ```
 * 
 * **Constraint:** Your solution must use **ALL** the required Java components mentioned above in a meaningful way.
 *
 * EXPLANATION:
 * The provided solution implements a `ProductionLineSimulator` that manages production tasks using a queue for waiting tasks and a list for completed tasks, fulfilling all the requirements of the exam question.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`ProductionTask` Class:** Encapsulates the data (`taskId`, `description`, `status`) and behavior (`setStatus`, `toString`) related to a single task. Private fields and public getters/setters demonstrate encapsulation. The `toString()` method provides a convenient way to represent task objects.
 * 
 * 2.  **`ProductionLineSimulator` Class:**
 *     *   **Collections:** Uses `java.util.Queue` (implemented by `LinkedList`) for `waitingTasks` to manage tasks in a FIFO (First-In, First-Out) order, which is typical for a processing queue. It uses `java.util.List` (implemented by `ArrayList`) for `completedTasks` to store processed tasks, allowing easy iteration and storage without strict order requirements beyond insertion. Both are declared as the interface type (`Queue`, `List`), promoting good practice.
 *     *   **`Scanner`:** An instance of `java.util.Scanner` is used to read user input from the console. It's initialized within a try-with-resources block in the `run()` method to ensure it's automatically closed when the program finishes or an exception occurs, preventing resource leaks.
 *     *   **`switch` Statement:** The `run()` method uses a `switch` statement based on the user's menu choice to direct program flow to the appropriate action (`addTask`, `processNextTask`, `viewTasks`, or exit). A nested `switch` is used within `viewTasks` to handle the user's choice between viewing waiting or completed tasks.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for normal program output, such as displaying the menu, prompts, success messages, and task listings. `System.err.println()` is used specifically for displaying error messages, such as invalid input, empty queue conditions, or unexpected exceptions, clearly separating error output.
 *     *   **`try-catch` Blocks:**
 *         *   A class-wide `try-catch` block is wrapped around the main loop within the `run()` method. This block catches `InputMismatchException` specifically when the user enters non-integer input for the main menu choice. It prints an error to `System.err` and calls `scanner.nextLine()` to clear the invalid input from the buffer, allowing the loop to continue gracefully.
 *         *   A general `catch (Exception e)` is included in the `run()` method's `try` block to catch any other unexpected runtime errors, printing an error message and stack trace to `System.err` for debugging.
 *         *   A specific `try-catch` for `InputMismatchException` is also used within the `viewTasks` method to handle non-integer input when choosing the view type (waiting or completed).
 *     *   **Input Validation:** The `addTask` method checks if the entered description is empty. The `switch` statements handle default cases for invalid numeric choices. The `processNextTask` method checks if the queue is empty before attempting to process.
 *     *   **Method Structure:** The simulation logic is broken down into smaller, private methods (`displayMenu`, `addTask`, `processNextTask`, `viewTasks`) called from the main `run` loop, improving code organization and readability.
 * 
 * **How Requirements Are Met:**
 * 
 * *   All specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used.
 * *   The problem simulates a practical scenario (production line).
 * *   Best practices are followed: `ProductionTask` uses encapsulation; meaningful names are used throughout; comments and Javadoc are included; input validation and error handling are implemented using `try-catch` and checks; the code is structured into classes and methods.
 * *   The complexity is appropriate for demonstrating understanding of these combined concepts within a reasonable timeframe.
 * 
 * This solution provides a robust framework for the production line simulation, demonstrating effective use of fundamental Java data structures, control flow mechanisms, and error handling techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the production line.
 */
class ProductionTask {
    private int taskId;
    private String description;
    private String status; // e.g., "Waiting", "Completed"

    /**
     * Constructs a new ProductionTask.
     *
     * @param taskId The unique ID for the task.
     * @param description A description of the task.
     */
    public ProductionTask(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Waiting"; // Initial status
    }

    /**
     * Gets the task ID.
     *
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     *
     * @return The task status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "[ID: " + taskId + "] Description: " + description + ", Status: " + status;
    }
}

/**
 * Simulates a production line managing waiting and completed tasks.
 */
public class ProductionLineSimulator {

    private Queue<ProductionTask> waitingTasks;
    private List<ProductionTask> completedTasks;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a ProductionLineSimulator, initializing collections and ID counter.
     */
    public ProductionLineSimulator() {
        this.waitingTasks = new LinkedList<>(); // Queue implementation
        this.completedTasks = new ArrayList<>(); // List implementation
        this.nextTaskId = 1;
        // Scanner is initialized in the run method using try-with-resources
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nProduction Line Simulation Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     *
     * @param scanner The Scanner object for reading input.
     */
    private void addTask(Scanner scanner) {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        ProductionTask newTask = new ProductionTask(nextTaskId++, description);
        waitingTasks.offer(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the waiting queue.
     */
    private void processNextTask() {
        System.out.println("Processing next task...");
        ProductionTask taskToProcess = waitingTasks.poll(); // Retrieve and remove head

        if (taskToProcess != null) {
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess); // Add to completed list
            System.out.println("Task processed: " + taskToProcess);
        } else {
            System.err.println("No tasks in the waiting queue to process.");
        }
    }

    /**
     * Allows the user to view waiting or completed tasks.
     *
     * @param scanner The Scanner object for reading input.
     */
    private void viewTasks(Scanner scanner) {
        System.out.println("View Tasks Menu:");
        System.out.println("1. Waiting Tasks");
        System.out.println("2. Completed Tasks");
        System.out.print("Enter your choice: ");

        try {
            int viewChoice = scanner.nextInt();
            // Consume the newline character
            scanner.nextLine();

            switch (viewChoice) {
                case 1:
                    System.out.println("--- Waiting Tasks ---");
                    if (waitingTasks.isEmpty()) {
                        System.out.println("No tasks waiting.");
                    } else {
                        // Iterating through the queue without removing elements
                        for (ProductionTask task : waitingTasks) {
                            System.out.println(task);
                        }
                    }
                    System.out.println("---------------------");
                    break;
                case 2:
                    System.out.println("--- Completed Tasks ---");
                    if (completedTasks.isEmpty()) {
                        System.out.println("No tasks completed yet.");
                    } else {
                        // Iterating through the list
                        for (ProductionTask task : completedTasks) {
                            System.out.println(task);
                        }
                    }
                    System.out.println("-----------------------");
                    break;
                default:
                    System.err.println("Invalid viewing choice. Please enter 1 or 2.");
            }
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number (1 or 2).");
            scanner.nextLine(); // Clear the invalid input from the scanner buffer
        }
    }

    /**
     * Runs the main simulation loop.
     * Handles user input and directs program flow.
     */
    public void run() {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            this.scanner = scanner; // Assign to class field

            boolean running = true;
            while (running) {
                displayMenu();
                try {
                    int choice = scanner.nextInt();

                    switch (choice) {
                        case 1:
                            addTask(scanner);
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewTasks(scanner);
                            break;
                        case 4:
                            System.out.println("Exiting Production Line Simulation.");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Clear the invalid input from the scanner buffer
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to stderr
                }
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.run();
    }
}
