/*
 * Exam Question #613
 * Generated on: 2025-05-12 16:14:48
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Project Task Management System
 * 
 * **Objective:** Design and implement a simplified command-line task management system for a project. The system should allow users to add tasks, process the next high-priority task, mark any task as completed by its ID, and view tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a task. Each task must have:
 *     *   A unique integer ID.
 *     *   A description (String).
 *     *   A priority (`HIGH`, `MEDIUM`, `LOW`). Use an `enum` for priority.
 *     *   A status (`PENDING`, `COMPLETED`). Use an `enum` for status.
 *     *   Implement appropriate methods (constructor, getters, `toString()`).
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class that manages the tasks. It must maintain:
 *     *   A collection of *all* tasks. Use a `java.util.List` (specifically `java.util.ArrayList` for implementation) to store all tasks.
 *     *   A queue of *high-priority* tasks awaiting processing. Use a `java.util.Queue` (specifically `java.util.LinkedList` which implements `Queue`) for high-priority tasks.
 *     *   A mechanism to generate unique task IDs (a simple counter is sufficient).
 * 
 * 3.  **TaskManager Functionality:** The `TaskManager` class must provide the following public methods:
 *     *   `addTask(String description, Priority priority)`: Adds a new task with a unique ID, the given description, and priority. The initial status is `PENDING`. If the priority is `HIGH`, the task should also be added to the high-priority queue. Returns the ID of the newly added task.
 *     *   `processNextTask()`: Retrieves and removes the next task from the high-priority queue. If the queue is not empty, it marks the retrieved task as `COMPLETED` in the main list of all tasks. Prints a message indicating which task was processed or that the queue is empty.
 *     *   `markTaskCompleted(int taskId)`: Finds the task with the given ID in the main list and marks its status as `COMPLETED`. If the task was `HIGH` priority and still in the high-priority queue, it must also be removed from the queue. Prints a success message or an error if the task ID is not found or already completed.
 *     *   `viewAllTasks()`: Prints details of all tasks managed by the system.
 *     *   `viewTasksByStatus(Status status)`: Prints details of tasks matching the specified status.
 * 
 * 4.  **User Interface:** Create a main application class (`TaskManagementApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   Present a menu to the user with options:
 *         1. Add Task
 *         2. Process Next High Priority Task
 *         3. Mark Task Completed by ID
 *         4. View All Tasks
 *         5. View Tasks by Status
 *         6. Exit
 *     *   Read user input using `Scanner`.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for user inputs (e.g., ensuring priority is valid, task ID is an integer).
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, task not found, invalid priority input).
 *     *   Use `System.out` for normal output (menu, prompts, task lists, success messages).
 *     *   Implement class-wide exception handling in the `main` method using `try-catch` blocks to catch potential runtime errors (like `InputMismatchException` or `NumberFormatException` during input reading/parsing) and provide graceful termination or recovery.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * The program should run interactively, displaying a menu, accepting user input, performing the requested operations, and printing relevant output or error messages until the user chooses to exit.
 * 
 * *Example Interaction Snippet:*
 * ```
 * Task Management Menu:
 * 1. Add Task
 * 2. Process Next High Priority Task
 * 3. Mark Task Completed by ID
 * 4. View All Tasks
 * 5. View Tasks by Status
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added with ID: 2
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Processing next high priority task...
 * Processed Task [ID: 1, Description: Write report, Priority: HIGH, Status: COMPLETED]
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * All Tasks:
 * Task [ID: 1, Description: Write report, Priority: HIGH, Status: COMPLETED]
 * Task [ID: 2, Description: Schedule meeting, Priority: MEDIUM, Status: PENDING]
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a command-line Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   Represents a single task with `id`, `description`, `priority`, and `status`.
 *     *   Uses `enum` for `Priority` and `Status` for type safety and readability.
 *     *   Includes a constructor, getters, and a `markCompleted()` method.
 *     *   The `toString()` method provides a user-friendly representation of the task.
 *     *   Crucially, `equals()` and `hashCode()` are overridden based on the task `id`. This is essential for the `highPriorityTasks.remove(taskToComplete)` operation in `TaskManager.markTaskCompleted`, allowing `LinkedList` (which implements `Queue`) to correctly find and remove the task object from the queue based on its ID, even if it's a different reference than the one found in `allTasks` (though in this specific solution, they are the same references, overriding `equals` is good practice when removing objects from collections).
 * 
 * 2.  **TaskManager Class:**
 *     *   Acts as the central hub for managing tasks.
 *     *   Uses a `List<Task> allTasks` (implemented by `ArrayList`) to keep track of every task created. `ArrayList` provides efficient random access, useful for viewing or finding tasks by ID.
 *     *   Uses a `Queue<Task> highPriorityTasks` (implemented by `LinkedList`) to manage the order of high-priority tasks waiting for processing. `Queue`'s `offer()` (add) and `poll()` (retrieve and remove) methods are ideal for First-In, First-Out processing.
 *     *   `nextTaskId` is a simple counter ensuring unique IDs.
 *     *   `addTask()`: Creates a `Task` object, adds it to `allTasks`, and if it's high priority, also adds the *same object reference* to `highPriorityTasks`.
 *     *   `processNextTask()`: Uses `highPriorityTasks.poll()` to get the head of the queue. If a task is retrieved, it finds the corresponding task in `allTasks` (by object reference) and calls `markCompleted()`.
 *     *   `markTaskCompleted(int taskId)`: Iterates through `allTasks` to find the task by ID. If found and not already completed, it calls `markCompleted()` on the task object. If the task was high priority, it then attempts to remove the *same task object* from `highPriorityTasks` using `remove()`, which relies on the overridden `equals()` method.
 *     *   `viewAllTasks()` and `viewTasksByStatus()`: Iterate through `allTasks` and print task details based on criteria.
 *     *   `findTaskById()`: A helper method to locate a task within the `allTasks` list.
 * 
 * 3.  **TaskManagementApp Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes `Scanner` and `TaskManager`.
 *     *   The main logic runs inside a `while(running)` loop controlled by user input.
 *     *   `printMenu()` displays the options using `System.out`.
 *     *   User input is read using `scanner.nextInt()` for the menu choice and `scanner.nextLine()` for string inputs (like description, priority, status).
 *     *   A `switch` statement effectively handles the different menu options, directing control to the appropriate `TaskManager` methods or exit logic.
 *     *   **Error Handling:**
 *         *   A large `try-catch(Exception e)` block wraps the main `while` loop. This provides a "class-wide" or application-level catch-all for unexpected errors during the execution flow, printing the error to `System.err` and terminating gracefully (or allowing the loop to continue if the error is non-fatal).
 *         *   Specific `try-catch(InputMismatchException)` blocks are used around `scanner.nextInt()` calls to handle cases where the user enters non-integer input when a number is expected. These catches print an error to `System.err` and consume the invalid input using `scanner.nextLine()` before continuing the loop.
 *         *   Input validation loops are used for priority and status strings, using `try-catch(IllegalArgumentException)` around `Priority.valueOf()` and `Status.valueOf()` to catch invalid enum names and prompt the user again, printing errors to `System.err`.
 *         *   `TaskManager` methods like `markTaskCompleted` print specific error messages to `System.err` if a task is not found.
 *     *   `System.out` is used for all standard program output (menu, prompts, success messages, task lists).
 *     *   A `finally` block ensures the `Scanner` is closed when the application exits, regardless of whether an exception occurred.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, object-oriented design following best practices like encapsulation, meaningful names, and input validation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     * @param id The unique task ID.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // Tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = Status.COMPLETED;
    }

    @Override
    public String toString() {
        return "Task [ID: " + id + ", Description: " + description + ", Priority: " + priority + ", Status: " + status + "]";
    }

    // Necessary for Queue.remove(Object) to work correctly based on ID
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

// Manages the collection and processing of tasks
class TaskManager {
    // Stores all tasks
    private List<Task> allTasks;
    // Queue for high priority tasks awaiting processing
    private Queue<Task> highPriorityTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        allTasks = new ArrayList<>();
        highPriorityTasks = new LinkedList<>(); // LinkedList implements Queue
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * @param description The task description.
     * @param priority The task priority.
     * @return The ID of the newly added task.
     */
    public int addTask(String description, Priority priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask);

        // If high priority, add to the queue as well
        if (priority == Priority.HIGH) {
            highPriorityTasks.offer(newTask); // offer is preferred over add for queues
        }

        return newTask.getId();
    }

    /**
     * Processes the next task in the high priority queue.
     * Marks the task as completed in the main list.
     */
    public void processNextTask() {
        System.out.println("Processing next high priority task...");
        Task taskToProcess = highPriorityTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess == null) {
            System.out.println("No high priority tasks in the queue to process.");
        } else {
            // Find the task in the allTasks list and mark it completed
            // Since allTasks and highPriorityTasks store references to the same Task objects,
            // we can directly call markCompleted on the retrieved object.
            taskToProcess.markCompleted();
            System.out.println("Processed " + taskToProcess);
        }
    }

    /**
     * Marks a task as completed by its ID.
     * Also removes it from the high priority queue if it was there.
     * @param taskId The ID of the task to mark completed.
     */
    public void markTaskCompleted(int taskId) {
        Task taskToComplete = findTaskById(taskId);

        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        if (taskToComplete.getStatus() == Status.COMPLETED) {
            System.out.println("Task with ID " + taskId + " is already completed.");
            return;
        }

        taskToComplete.markCompleted();
        System.out.println("Task with ID " + taskId + " marked as COMPLETED.");

        // If it was a high priority task, remove it from the queue as well
        if (taskToComplete.getPriority() == Priority.HIGH) {
            // The equals() method in Task class ensures this works based on ID
             boolean removedFromQueue = highPriorityTasks.remove(taskToComplete);
             if(removedFromQueue){
                 // System.out.println("(Removed from high priority queue)"); // Optional confirmation
             }
        }
    }

    /**
     * Finds a task by its ID in the list of all tasks.
     * @param taskId The ID to search for.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Prints details of all tasks.
     */
    public void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks available.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Prints details of tasks with a specific status.
     * @param status The status to filter by.
     */
    public void viewTasksByStatus(Status status) {
        System.out.println("\n--- Tasks with status: " + status + " ---");
        boolean found = false;
        for (Task task : allTasks) {
            if (task.getStatus() == status) {
                System.out.println(task);
                found = true;
            }
        }
        if (!found) {
            System.out.println("No tasks found with status: " + status);
        }
        System.out.println("---------------------------------");
    }
}

// Main application class for user interaction
public class TaskManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide try-catch block to handle unexpected errors during execution
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        Priority priority = null;
                        while (priority == null) {
                            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                            String priorityString = scanner.nextLine().trim().toUpperCase();
                            try {
                                priority = Priority.valueOf(priorityString);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
                            }
                        }
                        int newTaskId = taskManager.addTask(description, priority);
                        System.out.println("Task added with ID: " + newTaskId);
                        break;

                    case 2: // Process Next High Priority Task
                        taskManager.processNextTask();
                        break;

                    case 3: // Mark Task Completed by ID
                        int taskIdToComplete = -1;
                        try {
                            System.out.print("Enter task ID to mark completed: ");
                            taskIdToComplete = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.markTaskCompleted(taskIdToComplete);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid task ID (number).");
                            scanner.nextLine(); // Consume the invalid input
                        }
                        break;

                    case 4: // View All Tasks
                        taskManager.viewAllTasks();
                        break;

                    case 5: // View Tasks by Status
                        Status statusToView = null;
                        while (statusToView == null) {
                            System.out.print("Enter status to view (PENDING, COMPLETED): ");
                            String statusString = scanner.nextLine().trim().toUpperCase();
                            try {
                                statusToView = Status.valueOf(statusString);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Invalid status. Please enter PENDING or COMPLETED.");
                            }
                        }
                        taskManager.viewTasksByStatus(statusToView);
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next High Priority Task");
        System.out.println("3. Mark Task Completed by ID");
        System.out.println("4. View All Tasks");
        System.out.println("5. View Tasks by Status");
        System.out.println("6. Exit");
        System.out.println("----------------------------");
    }
}
