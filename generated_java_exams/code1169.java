/*
 * Exam Question #1169
 * Generated on: 2025-05-12 17:34:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Clinic Patient Queue Management**
 * 
 * **Scenario:**
 * A small clinic needs a simple system to manage patients waiting for a specific consultation room. Patients arrive and are added to a waiting queue. When the consultation room becomes available, the next patient in the queue is called. The system should also keep a record of patients who have been called.
 * 
 * **Your Task:**
 * Develop a Java console application that simulates this process. The application should present a menu of options to the user and perform actions based on their choice.
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Representation:** Create a `Patient` class with the following private attributes:
 *     *   `patientId` (String)
 *     *   `name` (String)
 *     *   `age` (int)
 *     *   Provide a constructor to initialize these attributes.
 *     *   Provide public getter methods for all attributes.
 *     *   Override the `toString()` method to provide a user-friendly string representation of a Patient (e.g., "ID: P123, Name: John Doe, Age: 30").
 * 
 * 2.  **Clinic Management Class:** Create a main class (e.g., `ClinicQueueManager`) that contains the core logic. This class must use:
 *     *   A `java.util.Queue` (specifically a `LinkedList` or `ArrayDeque` implementation) to store patients currently waiting.
 *     *   A `java.util.List` (specifically an `java.util.ArrayList` implementation) to store patients who have been called/processed.
 *     *   A `java.util.Scanner` to read user input from the console.
 * 
 * 3.  **Functionality:** Implement the following operations via a menu:
 *     *   **1. Add Patient to Queue:** Prompt the user for patient details (ID, Name, Age). Validate that the age is a positive integer. Create a `Patient` object and add it to the waiting queue.
 *     *   **2. Call Next Patient:** If the waiting queue is not empty, remove the patient at the front of the queue and add them to the list of processed patients. Report which patient was called. If the queue is empty, report an error.
 *     *   **3. View Waiting Queue:** Display the details of all patients currently in the waiting queue, in order. If the queue is empty, report that.
 *     *   **4. View Processed Patients:** Display the details of all patients who have been processed. If the list is empty, report that.
 *     *   **5. Exit:** Terminate the application.
 * 
 * 4.  **Control Flow and Input/Output:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out.println()` for displaying the menu, prompts, successful actions, and lists.
 *     *   Use `System.err.println()` to report invalid input (e.g., non-positive age, non-integer input for choice/age) or errors (e.g., attempting to call a patient when the queue is empty).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation for patient age (must be > 0).
 *     *   Handle potential `java.util.InputMismatchException` when reading integer input (menu choice, age) using a `try-catch` block. This try-catch should ideally wrap the input reading part within the main loop to allow the program to continue after an invalid input.
 *     *   Handle the case where the user tries to "Call Next Patient" from an empty queue.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation in the `Patient` class.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Structure the code logically within the `ClinicQueueManager` class (e.g., separate methods for each menu option).
 * 
 * **Expected Output:**
 * The application should display a menu, prompt for input, and display results or errors based on user actions.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Clinic Patient Queue Management
 * 1. Add Patient to Queue
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Processed Patients
 * 5. Exit
 * Enter your choice: 1
 * Enter Patient ID: P101
 * Enter Patient Name: Alice
 * Enter Patient Age: 25
 * Patient Alice (ID: P101) added to the queue.
 * 
 * Enter your choice: 1
 * Enter Patient ID: P102
 * Enter Patient Name: Bob
 * Enter Patient Age: 30
 * Patient Bob (ID: P102) added to the queue.
 * 
 * Enter your choice: 3
 * --- Waiting Queue ---
 * ID: P101, Name: Alice, Age: 25
 * ID: P102, Name: Bob, Age: 30
 * ---------------------
 * 
 * Enter your choice: 2
 * Calling next patient...
 * Patient ID: P101, Name: Alice, Age: 25 has been called.
 * 
 * Enter your choice: 3
 * --- Waiting Queue ---
 * ID: P102, Name: Bob, Age: 30
 * ---------------------
 * 
 * Enter your choice: 4
 * --- Processed Patients ---
 * ID: P101, Name: Alice, Age: 25
 * --------------------------
 * 
 * Enter your choice: 2
 * Calling next patient...
 * Patient ID: P102, Name: Bob, Age: 30 has been called.
 * 
 * Enter your choice: 2
 * Calling next patient...
 * System.err: Error: The waiting queue is empty. No patient to call.
 * 
 * Enter your choice: 4
 * --- Processed Patients ---
 * ID: P101, Name: Alice, Age: 25
 * ID: P102, Name: Bob, Age: 30
 * --------------------------
 * 
 * Enter your choice: 5
 * Exiting Clinic Queue Management.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple clinic patient queue management system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Patient Class:**
 *     *   The `Patient` class encapsulates patient data (`patientId`, `name`, `age`) as private fields.
 *     *   Public getter methods (`getPatientId`, `getName`, `getAge`) provide controlled access to these fields.
 *     *   The constructor initializes the patient object.
 *     *   The `toString()` method is overridden to provide a clear string representation, useful for printing patient details.
 * 
 * 2.  **ClinicQueueManager Class:**
 *     *   This class holds the core logic and data structures.
 *     *   `private Queue<Patient> waitingQueue;`: Declared using the `Queue` interface and instantiated with `LinkedList`. `LinkedList` is a common implementation for `Queue` due to its efficient additions/removals from ends. It correctly models a waiting line where patients join the back and are served from the front.
 *     *   `private List<Patient> processedPatients;`: Declared using the `List` interface and instantiated with `ArrayList`. `ArrayList` is suitable for storing the history of processed patients, allowing easy iteration and storage of processed items in the order they were processed.
 *     *   `private Scanner scanner;`: Used to read input from `System.in`. Initialized in the constructor and closed when the application exits.
 *     *   `displayMenu()`: A helper method to print the interactive menu.
 *     *   `addPatient()`: Prompts for patient details, performs basic validation for age (must be positive), creates a `Patient` object, and adds it to the `waitingQueue` using `offer()`. `offer()` is used as it's the standard way to add to a queue, returning `true` on success and `false` if the queue is full (though `LinkedList` is unbounded). Includes a loop and `try-catch` specifically for the age input to handle `InputMismatchException` and re-prompt until valid input is received.
 *     *   `callNextPatient()`: Uses `waitingQueue.poll()` to retrieve and remove the patient at the front of the queue. `poll()` is used because it returns `null` if the queue is empty, allowing graceful handling of this case. If a patient is retrieved, they are added to the `processedPatients` list. If the queue is empty, an error message is printed to `System.err`.
 *     *   `viewWaitingQueue()`: Iterates through the `waitingQueue` using a for-each loop (which uses the queue's iterator) to display its contents without removing elements. Checks if the queue is empty first.
 *     *   `viewProcessedPatients()`: Iterates through the `processedPatients` `ArrayList` to display its contents. Checks if the list is empty first.
 *     *   `run()`: This is the main application loop. It repeatedly displays the menu, reads the user's choice, and uses a `switch` statement to call the appropriate method.
 *     *   **Class-wide Exception Handling (`try-catch` in `run`):** A `try-catch` block wraps the input reading (`scanner.nextInt()`) and the `switch` statement within the `run` method. This is a common pattern to catch `InputMismatchException` if the user enters non-integer input for the menu choice. Catching `Exception` provides a fallback for any other unexpected runtime errors, printing an error to `System.err` and the stack trace. After catching `InputMismatchException`, `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop, and the choice is reset to `-1` to re-display the menu.
 *     *   `main()`: The entry point of the application, which creates an instance of `ClinicQueueManager` and calls its `run()` method.
 * 
 * 3.  **Input/Output and Error Reporting:**
 *     *   `System.out.println()` is used for all standard messages, prompts, menu display, and successful output.
 *     *   `System.err.println()` is used specifically for error conditions: invalid menu choice, non-positive age input, non-integer input for age/choice, and attempting to call a patient from an empty queue.
 * 
 * 4.  **Best Practices:**
 *     *   Meaningful names (`waitingQueue`, `processedPatients`, `addPatient`, `callNextPatient`, etc.).
 *     *   Encapsulation in the `Patient` class.
 *     *   Comments explain the purpose of classes and methods.
 *     *   Input validation for age.
 *     *   Specific error handling for an empty queue and invalid input types.
 *     *   Clean separation of concerns into methods.
 *     *   Using interfaces (`Queue`, `List`) for variable types promotes flexibility.
 *     *   Closing the `Scanner` resource.
 * 
 * This solution effectively integrates all the required Java components to solve a practical problem, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the clinic.
 */
class Patient {
    private String patientId;
    private String name;
    private int age;

    /**
     * Constructs a new Patient object.
     *
     * @param patientId The unique ID of the patient.
     * @param name      The name of the patient.
     * @param age       The age of the patient.
     */
    public Patient(String patientId, String name, int age) {
        this.patientId = patientId;
        this.name = name;
        this.age = age;
    }

    /**
     * Gets the patient's ID.
     *
     * @return The patient ID.
     */
    public String getPatientId() {
        return patientId;
    }

    /**
     * Gets the patient's name.
     *
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the patient's age.
     *
     * @return The patient age.
     */
    public int getAge() {
        return age;
    }

    /**
     * Provides a string representation of the Patient object.
     *
     * @return Formatted string with patient details.
     */
    @Override
    public String toString() {
        return "ID: " + patientId + ", Name: " + name + ", Age: " + age;
    }
}

/**
 * Manages the patient waiting queue and processed patients list for a clinic.
 */
public class ClinicQueueManager {

    private Queue<Patient> waitingQueue;
    private List<Patient> processedPatients;
    private Scanner scanner;

    /**
     * Constructs a ClinicQueueManager, initializing the queue, list, and scanner.
     */
    public ClinicQueueManager() {
        waitingQueue = new LinkedList<>(); // Using LinkedList as a Queue implementation
        processedPatients = new ArrayList<>(); // Using ArrayList as a List implementation
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nClinic Patient Queue Management");
        System.out.println("1. Add Patient to Queue");
        System.out.println("2. Call Next Patient");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Processed Patients");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the waiting queue based on user input.
     * Handles input validation for age.
     */
    private void addPatient() {
        System.out.print("Enter Patient ID: ");
        String id = scanner.nextLine();

        System.out.print("Enter Patient Name: ");
        String name = scanner.nextLine();

        int age = -1; // Use -1 as an initial invalid state
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter Patient Age: ");
            try {
                age = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over
                if (age <= 0) {
                    System.err.println("Error: Age must be a positive integer.");
                } else {
                    validInput = true;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for age.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            }
        }

        Patient newPatient = new Patient(id, name, age);
        waitingQueue.offer(newPatient); // offer is generally preferred over add for queues
        System.out.println("Patient " + name + " (ID: " + id + ") added to the queue.");
    }

    /**
     * Calls the next patient from the waiting queue and moves them to the processed list.
     * Handles the case where the queue is empty.
     */
    private void callNextPatient() {
        System.out.println("Calling next patient...");
        Patient nextPatient = waitingQueue.poll(); // poll returns null if queue is empty

        if (nextPatient != null) {
            processedPatients.add(nextPatient);
            System.out.println("Patient " + nextPatient.toString() + " has been called.");
        } else {
            System.err.println("Error: The waiting queue is empty. No patient to call.");
        }
    }

    /**
     * Displays the current list of patients waiting in the queue.
     */
    private void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is currently empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Patient patient : waitingQueue) {
                System.out.println(patient);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the list of patients who have been processed/called.
     */
    private void viewProcessedPatients() {
        System.out.println("--- Processed Patients ---");
        if (processedPatients.isEmpty()) {
            System.out.println("No patients have been processed yet.");
        } else {
            for (Patient patient : processedPatients) {
                System.out.println(patient);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Runs the main application loop, displaying the menu and processing user choices.
     * Includes class-wide exception handling for input.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        addPatient();
                        break;
                    case 2:
                        callNextPatient();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewProcessedPatients();
                        break;
                    case 5:
                        System.out.println("Exiting Clinic Queue Management.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ClinicQueueManager manager = new ClinicQueueManager();
        manager.run();
    }
}
