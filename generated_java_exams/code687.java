/*
 * Exam Question #687
 * Generated on: 2025-05-12 16:25:57
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: System Maintenance Task Scheduler**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage a queue of system maintenance tasks. The application should allow users to add new tasks, process the next pending task, view the list of pending tasks, and view the history of completed tasks. This system simulates a basic maintenance queue where tasks are processed in the order they are added (First-In, First-Out).
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a maintenance task. Each task should have a description (String) and a status (completed/pending).
 * 2.  **Task Scheduler:** Create a `TaskScheduler` class that manages the tasks. It should use:
 *     *   A `Queue<Task>` to hold tasks that are pending processing.
 *     *   A `List<Task>` (specifically, an `ArrayList`) to store tasks that have been completed. Use the `List` interface type for declaration.
 * 3.  **Functionality:** The application should provide a menu-driven interface with the following options:
 *     *   **1. Add New Task:** Prompt the user for a task description and add it to the queue of pending tasks.
 *     *   **2. Process Next Task:** Take the oldest pending task from the queue, mark it as completed, and move it to the list of completed tasks. Handle the case where there are no pending tasks.
 *     *   **3. View Pending Tasks:** Display all tasks currently in the pending queue, in their processing order.
 *     *   **4. View Completed Tasks:** Display all tasks that have been processed and completed.
 *     *   **5. Exit:** Terminate the application.
 * 4.  **User Input:** Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process when the queue is empty).
 * 7.  **Exception Handling:** Implement robust exception handling using `try-catch` blocks.
 *     *   Handle potential input errors (e.g., non-integer input for menu choice).
 *     *   Handle the scenario where the user tries to process a task but the pending queue is empty. This should be handled gracefully, reporting the error to `System.err`.
 *     *   Include a general `try-catch` block in your main application loop to catch any unexpected exceptions and provide a fallback error message, demonstrating class-wide exception handling.
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Validate user input where necessary (e.g., task description not empty).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output Structure:**
 * 
 * The application should repeatedly display the menu, prompt for input, and perform the requested action, printing relevant information or error messages.
 * 
 * ```
 * --- System Maintenance Scheduler ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * [User Input]
 * [System Output/Error based on action]
 * ... (menu repeats)
 * ```
 * 
 * If processing an empty queue:
 * `Error: No pending tasks to process.` (to System.err)
 * 
 * If invalid menu choice:
 * `Error: Invalid choice. Please enter a number between 1 and 5.` (to System.err)
 * 
 * If invalid task description:
 * `Error: Task description cannot be empty.` (to System.err)
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective and correct exception handling (`try-catch`).
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code clarity, readability, and adherence to best practices (naming, comments, input validation).
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the System Maintenance Task Scheduler application as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This simple class encapsulates the data for a task: `description` and `completed` status. It has a constructor, getter methods, a `markCompleted` method, and overrides `toString()` for easy printing. Fields are `private` for encapsulation.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   It uses a `Queue<Task>` named `pendingTasks` (implemented by `LinkedList`) to maintain the order of tasks to be processed (FIFO).
 *     *   It uses a `List<Task>` named `completedTasks` (implemented by `ArrayList`) to store tasks after they have been processed. The use of the `List` interface type for the variable `completedTasks` demonstrates polymorphism.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. It includes input validation for the description and throws `IllegalArgumentException` if invalid, which is caught in the main application.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. If `poll()` returns `null` (meaning the queue is empty), it throws an `IllegalStateException`, fulfilling the requirement to handle the empty queue scenario. Otherwise, it marks the retrieved task as completed and adds it to the `completedTasks` list.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: Provide access to the lists of tasks. `getPendingTasks()` returns a new `ArrayList` created from the `pendingTasks` queue to avoid exposing the internal `Queue` structure directly, although for simplicity in an exam, returning the list directly might be acceptable depending on strictness. `getCompletedTasks()` returns the internal `ArrayList`.
 *     *   `getPendingCount()` and `getCompletedCount()`: Simple methods to return the size of the respective collections.
 * 
 * 3.  **`SchedulerApp` Class (Main Application):**
 *     *   The `main` method is the entry point.
 *     *   It uses a `try-with-resources` block to ensure the `Scanner` is properly closed, preventing resource leaks.
 *     *   It instantiates `TaskScheduler`.
 *     *   The core logic runs within a `while(running)` loop.
 *     *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This serves as a general fallback to catch any unhandled exceptions that might occur within the application loop, printing an error to `System.err` and demonstrating class-wide handling.
 *     *   **Menu and Input:** The `printMenu` helper method displays options. User input is read using `scanner.nextLine()`.
 *     *   **Input Validation (`NumberFormatException`):** A nested `try-catch` block handles the potential `NumberFormatException` that can occur when parsing the user's input string into an integer using `Integer.parseInt()`. Error messages go to `System.err`.
 *     *   **`switch` Statement:** The parsed integer choice controls the program flow via a `switch` statement, directing execution to the correct case for each menu option.
 *     *   **Case Implementations:**
 *         *   Case 1 (`Add Task`): Prompts for description, calls `scheduler.addTask()`, and catches `IllegalArgumentException` thrown by `addTask` for empty descriptions, printing the error to `System.err`.
 *         *   Case 2 (`Process Next`): Calls `scheduler.processNextTask()` and catches `IllegalStateException` thrown by `processNextTask` when the queue is empty, printing the error to `System.err`.
 *         *   Case 3 (`View Pending`): Retrieves the pending tasks list and iterates through it, printing each task.
 *         *   Case 4 (`View Completed`): Retrieves the completed tasks list and iterates through it, printing each task.
 *         *   Case 5 (`Exit`): Sets `running` to `false` to exit the loop.
 *         *   `default`: Handles invalid integer choices, printing an error to `System.err`.
 *     *   `System.out` is used for normal user interaction and output, while `System.err` is strictly used for error messages as required.
 * 
 * This solution effectively integrates all the specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated, and well-structured application, fulfilling the requirements of the challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single maintenance task
class Task {
    private String description;
    private boolean completed;

    /**
     * Constructs a new Task with the given description.
     * Initially, a task is not completed.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.completed = false;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return completed;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.completed = true;
    }

    /**
     * Provides a string representation of the task.
     * @return A string showing the task description and its status.
     */
    @Override
    public String toString() {
        return "[" + (completed ? "Completed" : "Pending") + "] " + description;
    }
}

// Manages the queue of pending tasks and list of completed tasks
class TaskScheduler {
    // Use Queue for FIFO processing of pending tasks
    private Queue<Task> pendingTasks;
    // Use List (specifically ArrayList) to store completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskScheduler, initializing the task queues and lists.
     */
    public TaskScheduler() {
        // LinkedList implements Queue, suitable for FIFO
        this.pendingTasks = new LinkedList<>();
        // ArrayList implements List, suitable for storing completed items
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task to add.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add in Queue
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed.
     * @return The task that was processed.
     * @throws IllegalStateException if there are no pending tasks.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head
        if (nextTask == null) {
            throw new IllegalStateException("No pending tasks to process.");
        }
        nextTask.markCompleted();
        completedTasks.add(nextTask);
        System.out.println("Task processed: " + nextTask.getDescription());
        return nextTask;
    }

    /**
     * Gets the list of currently pending tasks.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new list to prevent external modification of the internal queue,
        // or just return the queue converted to a list. For simplicity in exam,
        // let's convert to list. Iterating over the queue is also an option.
        // Let's just iterate and print in the main app for simplicity.
        // Returning the queue directly is not ideal encapsulation, so let's return a copy or list view.
        // Simple approach: iterate and print in main. More complex but better: return List.
        // Let's return a copy converted to ArrayList.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets the list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Returning the internal list directly for simplicity in exam
    }

    /**
     * Gets the number of pending tasks.
     * @return The count of pending tasks.
     */
    public int getPendingCount() {
        return pendingTasks.size();
    }

    /**
     * Gets the number of completed tasks.
     * @return The count of completed tasks.
     */
    public int getCompletedCount() {
        return completedTasks.size();
    }
}

// Main application class to run the scheduler
public class SchedulerApp {

    public static void main(String[] args) {
        // Use try-with-resources to ensure the scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskScheduler scheduler = new TaskScheduler();
            boolean running = true;

            // Class-wide exception handling wrapper for the main loop
            try {
                while (running) {
                    printMenu();
                    int choice = -1;

                    // Input validation for menu choice
                    try {
                        System.out.print("Enter your choice: ");
                        String inputLine = scanner.nextLine();
                        choice = Integer.parseInt(inputLine);
                    } catch (NumberFormatException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        continue; // Skip to the next loop iteration
                    }

                    // Use switch statement for flow control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            try {
                                scheduler.addTask(description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 2:
                            try {
                                scheduler.processNextTask();
                            } catch (IllegalStateException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3:
                            List<Task> pending = scheduler.getPendingTasks();
                            if (pending.isEmpty()) {
                                System.out.println("No pending tasks.");
                            } else {
                                System.out.println("--- Pending Tasks (" + pending.size() + ") ---");
                                // Iterate through the pending tasks (Queue order)
                                // Note: Iterating a Queue gives elements in order, but doesn't remove them.
                                // Converting to list first for easier indexing/display.
                                for (int i = 0; i < pending.size(); i++) {
                                    System.out.println((i + 1) + ". " + pending.get(i));
                                }
                                System.out.println("-----------------------------");
                            }
                            break;
                        case 4:
                            List<Task> completed = scheduler.getCompletedTasks();
                            if (completed.isEmpty()) {
                                System.out.println("No completed tasks yet.");
                            } else {
                                System.out.println("--- Completed Tasks (" + completed.size() + ") ---");
                                for (int i = 0; i < completed.size(); i++) {
                                     System.out.println((i + 1) + ". " + completed.get(i));
                                }
                                System.out.println("-----------------------------");
                            }
                            break;
                        case 5:
                            System.out.println("Exiting System Maintenance Scheduler. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                    System.out.println(); // Add a newline for better readability between operations
                }
            } catch (Exception e) {
                // General catch block for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to stderr for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
        System.out.println("Application terminated.");
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- System Maintenance Scheduler ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
