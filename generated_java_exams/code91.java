/*
 * Exam Question #91
 * Generated on: 2025-05-11 22:12:36
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Help Desk Ticket Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application to simulate a basic Help Desk Ticket Management System. The system should allow users (simulating support agents) to manage incoming support tickets. Tickets arrive and are processed in the order they are received (First-In, First-Out). Completed tickets are archived.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a class `Ticket` with private fields for a unique integer `id` and a `String description`. Include a constructor and public getter methods for these fields. Override the `toString()` method for easy display of ticket information.
 * 2.  **System Core:** Create a class `HelpDeskSystem` that manages the tickets.
 *     *   It must contain a private field `pendingTickets` of type `java.util.Queue<Ticket>` to store tickets awaiting processing. Use a suitable implementation of `Queue` (e.g., `java.util.LinkedList`).
 *     *   It must contain a private field `completedTickets` declared as `java.util.List<Ticket>` (using `java.util.ArrayList` as the concrete implementation) to store tickets that have been processed.
 *     *   It should maintain a counter for the next available ticket ID.
 *     *   It must contain a `java.util.Scanner` instance for reading user input within its operational loop.
 * 3.  **Functionality (Methods in `HelpDeskSystem`):**
 *     *   A constructor to initialize the collections and the ticket ID counter.
 *     *   `void addTicket()`: Prompts the user for a ticket description, creates a new `Ticket` object with a unique ID, and adds it to the `pendingTickets` queue. Must validate that the description is not empty.
 *     *   `void processNextTicket()`: Retrieves and removes the next ticket from the `pendingTickets` queue (if any), moves it to the `completedTickets` list, and prints a confirmation message. If the queue is empty, it should inform the user.
 *     *   `void viewPendingTickets()`: Displays all tickets currently in the `pendingTickets` queue without removing them. If the queue is empty, it should indicate so.
 *     *   `void viewCompletedTickets()`: Displays all tickets in the `completedTickets` list. If the list is empty, it should indicate so.
 *     *   `void run()`: This method should contain the main application loop. It displays a menu of options (Add Ticket, Process Next, View Pending, View Completed, Exit), reads the user's choice using the `Scanner`, and uses a `switch` statement to call the appropriate method. The loop should continue until the user chooses to exit. Handle potential `InputMismatchException` if the user enters non-numeric input for the menu choice.
 * 4.  **Main Application Class:** Create a separate class (e.g., `HelpDeskApp`) with a `main` method. The `main` method should create an instance of `HelpDeskSystem` and call its `run()` method.
 * 5.  **Input/Output & Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and ticket lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty ticket description, issues reading input).
 *     *   Implement exception handling:
 *         *   Catch `InputMismatchException` specifically within the `run()` method's loop if the user enters non-numeric input for the menu choice. Print an error message to `System.err` and consume the invalid input.
 *         *   Implement a broader `try-catch` block in the `main` method of `HelpDeskApp` wrapping the call to `system.run()` to catch any unexpected exceptions that might propagate up, printing an error message and stack trace to `System.err`.
 * 6.  **Best Practices:** Adhere to best practices including encapsulation (private fields, public/private methods), meaningful variable and method names, basic comments where necessary, and clean code structure. Ensure the `Scanner` is properly closed when the application exits.
 * 
 * **Expected Output Structure:**
 * 
 * The application should present a clear menu, respond to user input, display ticket information, and handle errors gracefully using the specified output streams.
 * 
 * ```
 * Starting Help Desk System...
 * --- Help Desk Menu ---
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Completed Tickets
 * 5. Exit
 * ----------------------
 * Enter your choice: <user input>
 * ... (System output based on choice, e.g., prompt for description, ticket added/processed messages, lists)
 * Enter your choice: <user input>
 * ...
 * Enter your choice: 5
 * Exiting Help Desk System. Goodbye!
 * Application finished.
 * 
 * (Error messages like "Invalid choice..." or "Ticket description cannot be empty." should go to System.err)
 * (Errors from InputMismatchException or unexpected exceptions should go to System.err)
 * ```
 * 
 * Your solution must demonstrate the correct usage of **Queue, ArrayList, List, Scanner, switch, System.err, System.out, and class-wide try-catch blocks** in a cohesive application.
 *
 * EXPLANATION:
 * This solution implements the Help Desk Ticket Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Ticket` Class:** This simple class encapsulates the data for a single ticket (`id` and `description`). It follows encapsulation by making fields private and providing public getters. The `toString()` method provides a convenient way to print ticket details.
 * 
 * 2.  **`HelpDeskSystem` Class:** This is the core class managing the system's state and logic.
 *     *   **`Queue<Ticket> pendingTickets`:** A `LinkedList` is used as the concrete implementation of the `Queue` interface. This correctly models the FIFO nature of incoming tickets, where `offer()` adds to the tail and `poll()` removes from the head.
 *     *   **`List<Ticket> completedTickets`:** An `ArrayList` is used as the concrete implementation of the `List` interface. This stores processed tickets, allowing easy iteration and access (though direct access by index isn't strictly needed in this problem, `ArrayList` is a common and suitable `List` implementation). The variable is declared using the `List` interface type, which is good practice as it allows for potential future changes to the underlying list implementation without affecting code that uses only the `List` interface methods.
 *     *   **`nextTicketId`:** A simple counter to ensure each ticket gets a unique ID.
 *     *   **`Scanner scanner`:** An instance to read input from `System.in`. It's initialized in the constructor and closed in a `finally` block within the `run()` method to ensure resource cleanup.
 *     *   **`run()` Method:** This method contains the main application loop. It repeatedly displays a menu, reads user input, and processes the command.
 *         *   **`Scanner` and Input:** `scanner.nextInt()` is used to read the menu choice, followed by `scanner.nextLine()` to consume the leftover newline character, which is crucial to prevent issues with subsequent `scanner.nextLine()` calls in `addTicket()`.
 *         *   **`switch` Statement:** The `switch` statement efficiently handles the different menu options, directing execution to the appropriate private method (`addTicket`, `processNextTicket`, etc.).
 *         *   **`System.out` and `System.err`:** `System.out` is used for standard messages like the menu, prompts, successful actions, and listing tickets. `System.err` is specifically used for error conditions, such as invalid menu choices or empty descriptions.
 *         *   **Input Validation:** The `addTicket()` method validates that the description provided by the user is not empty using `trim().isEmpty()`.
 *         *   **Error Handling (within `run`)**: A `try-catch` block surrounds the core command processing logic inside the `while` loop.
 *             *   It specifically catches `InputMismatchException` if the user enters non-numeric input for the menu choice, prints an error to `System.err`, and consumes the invalid input from the scanner to recover.
 *             *   A general `catch (Exception e)` is included as a safeguard to catch any other unexpected exceptions that might occur during the execution of a specific command method (like `addTicket`, `processNextTicket`, etc.) within the loop. It prints an error message and stack trace to `System.err`.
 *     *   **Functional Methods (`addTicket`, `processNextTicket`, `viewPendingTickets`, `viewCompletedTickets`):** These private methods implement the core logic for each menu option, interacting with the `pendingTickets` queue and `completedTickets` list as required. `processNextTicket` checks if the queue is empty before calling `poll()`, avoiding potential errors and providing a user-friendly message. `viewPendingTickets` and `viewCompletedTickets` iterate over the collections to display their contents.
 * 
 * 3.  **`HelpDeskApp` Class:** This is the entry point of the application. Its `main` method creates an instance of `HelpDeskSystem` and calls its `run()` method.
 *     *   **Class-wide Exception Handling:** A broad `try-catch(Exception e)` block is wrapped around the call to `system.run()`. This serves as the top-level, "class-wide" or application-level exception handler. It catches any exceptions that are not handled internally within `HelpDeskSystem.run()` and propagate up to `main`, preventing the application from crashing abruptly and providing a final error message and stack trace to `System.err`.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional, menu-driven application that simulates a real-world scenario, while adhering to good programming practices like encapsulation, meaningful names, input validation, and structured error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single help desk ticket
class Ticket {
    private int id;
    private String description;

    /**
     * Constructs a new Ticket.
     * @param id The unique identifier for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a user-friendly string representation of the ticket.
     * @return String representation of the ticket.
     */
    @Override
    public String toString() {
        return "Ticket #" + id + ": " + description;
    }
}

// Manages the collection of pending and completed tickets
class HelpDeskSystem {
    // Queue for tickets awaiting processing (FIFO)
    private Queue<Ticket> pendingTickets;
    // List for tickets that have been processed (using List interface)
    private List<Ticket> completedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new HelpDeskSystem, initializing collections and scanner.
     */
    public HelpDeskSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.completedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in); // Initialize scanner for system input
    }

    /**
     * Runs the main application loop, displaying menu and processing user commands.
     * Includes exception handling for user input.
     */
    public void run() {
        int choice = -1; // Variable to store user's menu choice

        // Display menu once before the loop starts
        displayMenu();

        // Main loop continues until user chooses to exit (option 5)
        while (choice != 5) {
            System.out.print("Enter your choice: ");
            try {
                // Attempt to read integer input for choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addTicket(); // Call method to add a new ticket
                        break;
                    case 2:
                        processNextTicket(); // Call method to process the next pending ticket
                        break;
                    case 3:
                        viewPendingTickets(); // Call method to display pending tickets
                        break;
                    case 4:
                        viewCompletedTickets(); // Call method to display completed tickets
                        break;
                    case 5:
                        System.out.println("Exiting Help Desk System. Goodbye!"); // Exit message
                        break;
                    default:
                        // Handle invalid numeric input (outside 1-5 range)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-numeric input gracefully
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to an invalid value to continue the loop
            } catch (Exception e) {
                // Catch any other unexpected exception during command processing
                System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream for debugging
                // The loop continues, allowing the user to try again or exit
            }
            System.out.println(); // Add a blank line for better readability between actions

            // Display menu again if not exiting
            if (choice != 5) {
                displayMenu();
            }
        }

        // Ensure the scanner is closed when the application loop finishes
        if (scanner != null) {
            scanner.close();
            // System.out.println("Scanner closed."); // Optional: for debugging
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("--- Help Desk Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Completed Tickets");
        System.out.println("5. Exit");
        System.out.println("----------------------");
    }

    /**
     * Prompts user for ticket details, validates input, and adds a new ticket
     * to the pending queue.
     */
    private void addTicket() {
        System.out.print("Enter ticket description: ");
        // Read the full line for the description
        String description = scanner.nextLine().trim(); // Use trim() to remove leading/trailing whitespace

        // Validate that the description is not empty
        if (description.isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit the method if validation fails
        }

        // Create a new ticket with the next available ID
        Ticket newTicket = new Ticket(nextTicketId++, description);
        // Add the new ticket to the pending queue
        pendingTickets.offer(newTicket); // offer() is the preferred way to add to a Queue

        System.out.println("Success: " + newTicket + " added to pending queue.");
    }

    /**
     * Processes the next ticket in the pending queue, moving it to the
     * completed list. Handles the case where the queue is empty.
     */
    private void processNextTicket() {
        // Retrieve and remove the head of the queue
        Ticket ticketToProcess = pendingTickets.poll(); // poll() returns null if queue is empty

        if (ticketToProcess == null) {
            // Inform the user if there are no tickets to process
            System.out.println("Info: No pending tickets to process.");
            return;
        }

        // Add the processed ticket to the completed list
        completedTickets.add(ticketToProcess);

        System.out.println("Success: Processed " + ticketToProcess + " and moved to completed.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    private void viewPendingTickets() {
        if (pendingTickets.isEmpty()) {
            System.out.println("Info: No pending tickets.");
            return;
        }

        System.out.println("--- Pending Tickets ---");
        // Iterate through the queue without removing elements
        int count = 0;
        for (Ticket ticket : pendingTickets) {
            System.out.println(ticket);
            count++;
        }
        System.out.println("Total pending: " + count);
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been moved to the completed list.
     */
    private void viewCompletedTickets() {
        if (completedTickets.isEmpty()) {
            System.out.println("Info: No completed tickets.");
            return;
        }

        System.out.println("--- Completed Tickets ---");
        // Iterate through the list
        for (Ticket ticket : completedTickets) {
            System.out.println(ticket);
        }
        System.out.println("Total completed: " + completedTickets.size());
        System.out.println("-------------------------");
    }
}

// Main application class to start the Help Desk System
public class HelpDeskApp {
    /**
     * The main entry point of the application.
     * Creates the HelpDeskSystem and runs it within a try-catch block
     * for overall application-level exception handling.
     */
    public static void main(String[] args) {
        System.out.println("Starting Help Desk System...");
        try {
            // Create an instance of the HelpDeskSystem
            HelpDeskSystem system = new HelpDeskSystem();
            // Run the system's main loop
            system.run();
        } catch (Exception e) {
            // Catch any unhandled exceptions that escape the HelpDeskSystem.run() method
            System.err.println("\nFATAL ERROR: The application encountered an unexpected error.");
            e.printStackTrace(System.err); // Print the stack trace to the error stream
        } finally {
             // This block ensures resources are cleaned up even if an error occurs,
             // although the Scanner is closed within HelpDeskSystem.run()'s finally.
             // A message here just indicates the main try-catch finished.
             // System.out.println("Main application try-catch finished."); // Optional
        }
        System.out.println("Application finished.");
    }
}
