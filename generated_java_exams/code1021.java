/*
 * Exam Question #1021
 * Generated on: 2025-05-12 17:13:52
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Check-in Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage the check-in process for an event. The event has a list of pre-registered attendees. As attendees arrive, they join a check-in queue. The system operator processes attendees one by one from the front of the queue, marking them as checked in.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this Event Check-in Management System. Your solution must include the following:
 * 
 * 1.  A class named `Attendee` to represent an attendee.
 * 2.  A class named `EventManager` to manage the list of registered attendees and the check-in queue.
 * 3.  A simple command-line interface for interacting with the system.
 * 
 * **Requirements:**
 * 
 * Your solution must strictly adhere to the following requirements:
 * 
 * *   **Data Structures:** Use `java.util.List` (specifically `java.util.ArrayList`) to store the initial list of registered attendees and `java.util.Queue` (specifically `java.util.LinkedList`) to manage the check-in queue.
 * *   **User Input:** Use `java.util.Scanner` to read user commands and attendee IDs from the console.
 * *   **Control Flow:** Use a `switch` statement to handle different user menu options.
 * *   **Output:** Use `System.out` for normal information messages (menu, successful operations, queue status) and `System.err` for displaying error messages.
 * *   **Exception Handling:** Implement class-wide exception handling using `try-catch` blocks within the main operational loop of your `EventManager` class to gracefully handle potential issues like invalid input, attendees not found, or attempting to process an empty queue.
 * *   **Attendee Class:**
 *     *   Must have private fields for `id` (String), `name` (String), `isRegistered` (boolean, initialized to `true`), and `isCheckedIn` (boolean, initialized to `false`).
 *     *   Provide a constructor `Attendee(String id, String name)`.
 *     *   Include public getter methods for `id`, `name`, `isRegistered`, and `isCheckedIn`.
 *     *   Include a public setter method `setCheckedIn(boolean checkedIn)`.
 *     *   Override the `toString()` method to provide a useful string representation (e.g., "ID: [id], Name: [name], Checked In: [isCheckedIn]").
 * *   **EventManager Class:**
 *     *   Must have private fields: `registeredAttendees` (a `List<Attendee>`) and `checkInQueue` (a `Queue<Attendee>`).
 *     *   The constructor should initialize these data structures and populate `registeredAttendees` with a few sample attendees (e.g., A001, A002, A003).
 *     *   Implement a private helper method `findAttendee(String id)` that searches `registeredAttendees` by ID and returns the `Attendee` object or `null` if not found.
 *     *   Implement a public method `addToCheckInQueue(String attendeeId)`:
 *         *   Find the attendee using `findAttendee`.
 *         *   If the attendee is not found, throw an `IllegalArgumentException` with a descriptive message.
 *         *   If the attendee is already checked in (`isCheckedIn` is true), throw an `IllegalStateException` with a descriptive message.
 *         *   Otherwise, add the attendee to the `checkInQueue`.
 *     *   Implement a public method `processNextInQueue()`:
 *         *   If the `checkInQueue` is empty, throw an `IllegalStateException` with a descriptive message.
 *         *   Otherwise, remove the next attendee from the queue, set their `isCheckedIn` status to `true`, and print a success message including the attendee's details.
 *     *   Implement a public method `viewCheckInQueue()`:
 *         *   Print the current status of the check-in queue, listing the attendees currently waiting. Indicate if the queue is empty.
 *     *   Implement a public method `run()` that contains the main application loop:
 *         *   Display a menu of options: 1. Add to Queue, 2. Process Next, 3. View Queue, 0. Exit.
 *         *   Use `Scanner` to read the user's choice.
 *         *   Use a `switch` statement to call the appropriate `EventManager` method based on the choice.
 *         *   Wrap the core logic inside the loop (reading choice, switch statement) within a `try-catch` block to handle `IllegalArgumentException`, `IllegalStateException`, and `java.util.InputMismatchException` (for invalid input types) gracefully, printing error messages using `System.err`.
 *         *   The loop should continue until the user chooses to exit (option 0).
 *         *   Ensure the `Scanner` is properly closed when the application exits.
 * *   **Main Method:** Provide a `main` method (either in `EventManager` or a separate class) that creates an `EventManager` instance and calls its `run()` method.
 * *   **Best Practices:** Follow good coding practices including meaningful variable names, appropriate comments, and proper encapsulation (private fields, public methods).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Examples of expected output snippets:
 * 
 * *   **Menu:**
 *     ```
 *     Event Check-in System
 *     Menu:
 *     1. Add Attendee to Check-in Queue
 *     2. Process Next Attendee from Queue
 *     3. View Check-in Queue
 *     0. Exit
 *     ```
 * *   **Successful Add to Queue:**
 *     ```
 *     Enter Attendee ID to add to queue: A001
 *     Attendee A001 added to queue.
 *     ```
 * *   **Error - Attendee Not Found:**
 *     ```
 *     Enter Attendee ID to add to queue: A999
 *     Operation failed: Attendee with ID A999 not found.
 *     ```
 * *   **Error - Already Checked In:**
 *     ```
 *     Enter Attendee ID to add to queue: A001
 *     Operation failed: Attendee ID A001 is already checked in.
 *     ```
 * *   **Successful Process Next:**
 *     ```
 *     Processing next attendee...
 *     Successfully checked in: ID: A001, Name: Alice, Checked In: true
 *     ```
 * *   **Error - Queue Empty:**
 *     ```
 *     Processing next attendee...
 *     Operation failed: The check-in queue is currently empty.
 *     ```
 * *   **View Queue (Non-empty):**
 *     ```
 *     Current Check-in Queue:
 *     ID: A002, Name: Bob, Checked In: false
 *     ID: A003, Name: Charlie, Checked In: false
 *     ```
 * *   **View Queue (Empty):**
 *     ```
 *     Current Check-in Queue is empty.
 *     ```
 * *   **Invalid Input Type:**
 *     ```
 *     Enter choice: abc
 *     Invalid input. Please enter a number.
 *     ```
 * *   **Invalid Choice Number:**
 *     ```
 *     Enter choice: 5
 *     Invalid choice. Please enter a number from the menu.
 *     ```
 * *   **Exit:**
 *     ```
 *     Enter choice: 0
 *     Exiting system.
 *     ```
 * 
 * You should provide the complete Java code for the `Attendee` and `EventManager` classes.
 *
 * EXPLANATION:
 * This solution implements the Event Check-in Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Attendee` Class:** This class serves as a simple Plain Old Java Object (POJO) representing an attendee. It encapsulates attendee data (`id`, `name`, `isRegistered`, `isCheckedIn`) using private fields and provides public getter/setter methods for controlled access. The `toString()` method is overridden for easy printing of attendee details.
 * 
 * 2.  **`EventManager` Class:** This is the core class managing the system state and logic.
 *     *   **Data Structures:** It uses an `ArrayList` (assigned to a `List` reference) `registeredAttendees` to hold the initial static list of attendees and a `LinkedList` (assigned to a `Queue` reference) `checkInQueue` to manage attendees waiting for check-in in a FIFO (First-In, First-Out) manner.
 *     *   **Constructor:** Initializes the list and queue and populates `registeredAttendees` with sample data.
 *     *   **`findAttendee(String id)`:** A private helper method demonstrating list traversal to find an object based on an attribute. It returns `null` if the attendee is not in the registered list.
 *     *   **`addToCheckInQueue(String attendeeId)`:** This method implements the business logic for adding an attendee to the queue. It uses `findAttendee` to validate the ID and checks the `isCheckedIn` status. Crucially, it throws `IllegalArgumentException` if the ID is invalid (attendee not found) and `IllegalStateException` if the attendee is already checked in. Using specific exceptions for different error conditions is a good practice. It uses `queue.offer()` to add the element.
 *     *   **`processNextInQueue()`:** This method handles checking in the next person. It uses `queue.poll()` which retrieves and removes the head of the queue, returning `null` if the queue is empty. This avoids a `NoSuchElementException` that `queue.remove()` would throw on an empty queue. If `poll()` returns `null`, it throws an `IllegalStateException` to indicate the queue is empty. Otherwise, it updates the attendee's `isCheckedIn` status.
 *     *   **`viewCheckInQueue()`:** Iterates through the `checkInQueue` (without removing elements, as iteration on `Queue` often works like a `Collection`) to display the current queue contents or indicates if it's empty.
 *     *   **`printMenu()`:** A simple helper to display the user options.
 *     *   **`run()`:** This is the heart of the interactive application.
 *         *   It uses a `try-with-resources` block for the `Scanner` to ensure it's automatically closed when the block is exited (either normally or due to an exception).
 *         *   A `while` loop keeps the application running until the user chooses option 0.
 *         *   Inside the loop, it prompts the user and reads input.
 *         *   It uses `scanner.hasNextInt()` to check if the input is an integer *before* reading it with `scanner.nextInt()`. This is a robust way to handle `InputMismatchException` gracefully without the program crashing.
 *         *   A `switch` statement dispatches the call to the appropriate method (`addToCheckInQueue`, `processNextInQueue`, `viewCheckInQueue`).
 *         *   The entire core logic block (reading input and the `switch`) is wrapped in a `try-catch` block. This demonstrates class-wide exception handling for the operational part of the class. It specifically catches `InputMismatchException` (though handled by `hasNextInt`, this adds another layer), `IllegalArgumentException`, and `IllegalStateException` thrown by the business logic methods, printing informative error messages using `System.err`. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors.
 *     *   **`main(String[] args)`:** The standard entry point that creates an `EventManager` instance and starts the `run()` method.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structure Usage:** Practical application of `List` (`ArrayList`) for static data storage and `Queue` (`LinkedList`) for dynamic, ordered processing.
 * *   **Input Handling:** Using `Scanner` for command-line input, including validation (`hasNextInt`) and consuming the newline character after `nextInt()`.
 * *   **Control Flow:** Effective use of `switch` for menu-driven navigation and a `while` loop for continuous operation.
 * *   **Object-Oriented Programming:** Encapsulation in the `Attendee` class and managing state and behavior within the `EventManager` class.
 * *   **Error Handling:**
 *     *   Using `try-catch` blocks for runtime errors, including specific exceptions (`IllegalArgumentException`, `IllegalStateException`, `InputMismatchException`).
 *     *   Throwing exceptions from methods (`addToCheckInQueue`, `processNextInQueue`) to signal specific error conditions to the calling code (`run` method).
 *     *   Using `System.err` for displaying error messages distinctly from normal output (`System.out`).
 *     *   Graceful handling of empty queue (`poll()` and `IllegalStateException`).
 *     *   Robust input type validation (`hasNextInt`).
 * *   **Resource Management:** Using `try-with-resources` for the `Scanner` to ensure it's closed properly.
 * *   **Code Structure:** Organizing code into separate classes with meaningful methods and private helper methods (`findAttendee`, `printMenu`).
 * 
 * This solution provides a comprehensive example of integrating these core Java concepts into a functional, albeit simple, application, fulfilling all the requirements of the challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an attendee for an event.
 */
class Attendee {
    private String id;
    private String name;
    private boolean isRegistered; // Always true for attendees in the initial list
    private boolean isCheckedIn;

    /**
     * Constructs a new Attendee.
     *
     * @param id   The unique attendee ID.
     * @param name The attendee's name.
     */
    public Attendee(String id, String name) {
        this.id = id;
        this.name = name;
        this.isRegistered = true; // Assume attendees created are registered
        this.isCheckedIn = false; // Initially not checked in
    }

    // --- Getters ---
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isRegistered() {
        return isRegistered;
    }

    public boolean isCheckedIn() {
        return isCheckedIn;
    }

    // --- Setter ---
    public void setCheckedIn(boolean checkedIn) {
        isCheckedIn = checkedIn;
    }

    /**
     * Provides a string representation of the Attendee.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Checked In: " + isCheckedIn;
    }
}

/**
 * Manages attendees and the check-in process for an event.
 */
public class EventManager { // Changed to public for main method access

    private List<Attendee> registeredAttendees; // Using ArrayList for registered list
    private Queue<Attendee> checkInQueue;      // Using LinkedList for the queue

    /**
     * Constructs an EventManager and initializes with sample attendees.
     */
    public EventManager() {
        registeredAttendees = new ArrayList<>();
        checkInQueue = new LinkedList<>();

        // Add some sample registered attendees
        registeredAttendees.add(new Attendee("A001", "Alice"));
        registeredAttendees.add(new Attendee("A002", "Bob"));
        registeredAttendees.add(new Attendee("A003", "Charlie"));

        System.out.println("Event Check-in System Initialized.");
        System.out.println("Registered Attendees (for reference): A001, A002, A003");
    }

    /**
     * Finds an attendee in the registered list by ID.
     * @param id The ID to search for.
     * @return The Attendee object if found, null otherwise.
     */
    private Attendee findAttendee(String id) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId().equalsIgnoreCase(id.trim())) {
                return attendee;
            }
        }
        return null; // Attendee not found
    }

    /**
     * Adds a registered attendee to the check-in queue.
     * @param attendeeId The ID of the attendee to add.
     * @throws IllegalArgumentException if attendee ID is not found.
     * @throws IllegalStateException if attendee is already checked in.
     */
    public void addToCheckInQueue(String attendeeId) throws IllegalArgumentException, IllegalStateException {
        Attendee attendee = findAttendee(attendeeId);

        if (attendee == null) {
            throw new IllegalArgumentException("Attendee with ID " + attendeeId + " not found.");
        }

        if (attendee.isCheckedIn()) {
            throw new IllegalStateException("Attendee ID " + attendeeId + " is already checked in.");
        }

        // Add to queue if found and not checked in
        checkInQueue.offer(attendee); // offer is safer than add in bounded queues, though LinkedList is unbounded
    }

    /**
     * Processes the next attendee from the check-in queue.
     * @throws IllegalStateException if the check-in queue is empty.
     */
    public void processNextInQueue() throws IllegalStateException {
        Attendee nextAttendee = checkInQueue.poll(); // poll returns null if queue is empty

        if (nextAttendee == null) {
            throw new IllegalStateException("The check-in queue is currently empty.");
        }

        nextAttendee.setCheckedIn(true);
        System.out.println("Successfully checked in: " + nextAttendee);
    }

    /**
     * Displays the current attendees waiting in the check-in queue.
     */
    public void viewCheckInQueue() {
        if (checkInQueue.isEmpty()) {
            System.out.println("Current Check-in Queue is empty.");
        } else {
            System.out.println("Current Check-in Queue:");
            // Iterating through the queue without removing elements
            for (Attendee attendee : checkInQueue) {
                System.out.println(attendee);
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nMenu:");
        System.out.println("1. Add Attendee to Check-in Queue");
        System.out.println("2. Process Next Attendee from Queue");
        System.out.println("3. View Check-in Queue");
        System.out.println("0. Exit");
    }

    /**
     * Runs the main application loop, handling user interaction and exceptions.
     */
    public void run() {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;

            while (choice != 0) {
                printMenu();
                System.out.print("Enter choice: ");

                try {
                    // Check if the next input is an integer
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                        scanner.nextLine(); // Consume the newline character left by nextInt()

                        switch (choice) {
                            case 1: // Add to Queue
                                System.out.print("Enter Attendee ID to add to queue: ");
                                String idToAdd = scanner.nextLine();
                                addToCheckInQueue(idToAdd); // This method throws exceptions
                                System.out.println("Attendee " + idToAdd + " added to queue.");
                                break;
                            case 2: // Process Next
                                System.out.println("Processing next attendee...");
                                processNextInQueue(); // This method throws exceptions
                                break;
                            case 3: // View Queue
                                viewCheckInQueue();
                                break;
                            case 0: // Exit
                                System.out.println("Exiting system.");
                                break;
                            default:
                                // Handle choices outside the defined range
                                System.err.println("Invalid choice. Please enter a number from the menu.");
                                break; // Added break for clarity
                        }
                    } else {
                        // Handle non-integer input for choice
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid token to prevent infinite loop
                    }
                } catch (InputMismatchException e) {
                    // This catch block is technically redundant due to hasNextInt() check
                    // but included for robustness if input handling logic changes.
                    System.err.println("Invalid input type. Please enter a number for the menu choice.");
                    scanner.next(); // Consume the invalid token
                } catch (IllegalArgumentException | IllegalStateException e) {
                    // Catch specific exceptions thrown by our methods (not found, already checked in, queue empty)
                    System.err.println("Operation failed: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace during development: e.printStackTrace();
                }
                System.out.println(); // Add a newline for better readability between interactions
            }
        } // Scanner is automatically closed here by try-with-resources
        System.out.println("System shut down.");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
