/*
 * Exam Question #1059
 * Generated on: 2025-05-12 17:19:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Production Line Task Manager**
 * 
 * **Scenario:**
 * You are tasked with developing a simple simulation of a production line task manager. Tasks arrive and are placed in a queue to be processed in the order they arrived. Once a task is processed, it is moved to a history log. The system should allow adding new tasks, processing the next task in the queue, viewing the current tasks waiting in the queue, viewing the history of processed tasks, and exiting the application.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. It should have a private field for the task description (String) and appropriate public methods (constructor, getter, `toString`).
 * 2.  **Manager Class:** Create a class named `ProductionLineManager` that will manage the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks waiting to be processed.
 *     *   It must use a `java.util.List<Task>` (specifically an `ArrayList`) to store tasks that have been processed. Use the `List` interface type for the field declaration.
 *     *   Implement methods for:
 *         *   `addTask(String description)`: Adds a new task to the queue. Input validation: the description cannot be null or empty.
 *         *   `processNextTask()`: Removes the next task from the queue and adds it to the processed history list. Handle the case where the queue is empty.
 *         *   `viewTaskQueue()`: Displays the descriptions of all tasks currently in the queue without removing them. Handle the case where the queue is empty.
 *         *   `viewProcessedHistory()`: Displays the descriptions of all tasks in the history list. Handle the case where the history is empty.
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of `ProductionLineManager` using `java.util.Scanner` to interact with the user.
 *     *   Display a menu of options: Add Task, Process Next Task, View Queue, View History, Exit.
 *     *   Read user input (a single character or number corresponding to the menu option).
 *     *   Use a `switch` statement to handle the different user commands.
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and lists of tasks/history.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process an empty queue, adding a task with an empty description).
 *     *   Implement exception handling using `try-catch` blocks. Include a general `try-catch` around the main command processing loop to catch unexpected errors. Also, specifically handle input validation errors within the relevant methods (`addTask`, and potentially in `main` if reading input fails).
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc for clarity.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Examples of expected output include:
 * 
 * *   Menu display upon startup and after each operation.
 * *   Prompts for task descriptions.
 * *   Success messages (e.g., "Task added: ...", "Task processed: ...").
 * *   Display of queue contents (e.g., "Current Queue: [Task1, Task2]").
 * *   Display of history contents (e.g., "Processed History: [TaskA, TaskB]").
 * *   Error messages printed to `System.err` (e.g., "Error: Task description cannot be empty.", "Error: Task queue is empty. Nothing to process.", "Error: Invalid command.").
 * *   A general error message from the `try-catch` if an unexpected exception occurs.
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the `ProductionLineManager` as requested, demonstrating the use of all specified Java components in a cohesive manner.
 * 
 * 1.  **`Task` Class:** A simple POJO (Plain Old Java Object) representing a task with a `description`. It follows encapsulation principles with a private field and public getter. The `toString()` method is overridden for easy printing.
 * 
 * 2.  **`ProductionLineManager` Class:**
 *     *   **Fields:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a processing queue.
 *         *   `processedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is a common and efficient implementation of the `List` interface for storing elements in a sequence, suitable for maintaining a history log. Programming to the `List` interface is a good practice.
 *     *   **Methods:**
 *         *   `addTask`: Takes a description, validates it (not null or empty), creates a `Task` object, and adds it to the `taskQueue` using `offer()`. `offer()` is generally preferred over `add()` in Queue contexts as it's designed for capacity-constrained queues (though `LinkedList` is not capacity-constrained, it's good practice). Includes `System.out` for success and `IllegalArgumentException` for validation failure, which is caught and reported via `System.err` in `main`.
 *         *   `processNextTask`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, which is used to check for the empty queue condition. If a task is retrieved, it's added to the `processedTasks` list. `System.out` is used for success, and `System.err` for the empty queue error.
 *         *   `viewTaskQueue`: Iterates through the `taskQueue` using an enhanced for loop (which doesn't remove elements) to display current tasks. Checks for emptiness and uses `System.out`.
 *         *   `viewProcessedHistory`: Iterates through the `processedTasks` list to display completed tasks. Checks for emptiness and uses `System.out`.
 *         *   `displayMenu`: A helper private method to print the menu options to `System.out`.
 * 
 * 3.  **`main` Method:**
 *     *   Initializes `ProductionLineManager` and `Scanner`.
 *     *   Enters a `while` loop that continues until `running` is set to `false`.
 *     *   **`try-catch` Block (Outer):** A general `try-catch(Exception e)` block wraps the main loop. This demonstrates catching unexpected runtime exceptions that might occur anywhere within the loop, printing an error to `System.err`, and providing a stack trace for debugging.
 *     *   **`try-catch` Block (Inner):** A specific `try-catch(InputMismatchException e)` is used inside the loop when reading the user's menu choice. This handles cases where the user enters non-integer input, prints an error to `System.err`, and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   **`switch` Statement:** Reads the integer choice and uses a `switch` statement to direct execution to the appropriate method (`addTask`, `processNextTask`, etc.).
 *     *   **Input Handling:** `scanner.nextInt()` reads the number, and `scanner.nextLine()` is crucial after `nextInt()` to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls (used for reading the task description).
 *     *   **`addTask` Error Handling:** The call to `manager.addTask()` is wrapped in a `try-catch(IllegalArgumentException e)` to catch the specific validation error thrown by the `addTask` method and report it using `System.err`.
 *     *   **Exit:** Case '5' sets `running` to `false`, terminating the loop.
 *     *   **`finally` Block:** Ensures `scanner.close()` is called when the outer `try` block is exited (either normally or due to an exception), releasing system resources and printing a confirmation message.
 * 
 * This solution effectively integrates the required components, demonstrates basic object-oriented design, handles user input, manages different states (empty queue/history), and incorporates error handling and best practices, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the production line.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task with the given description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return The task description string.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages the production line tasks, using a queue for pending tasks
 * and a list for processed tasks.
 */
public class ProductionLineManager {

    private Queue<Task> taskQueue;
    private List<Task> processedTasks; // Using List interface type

    /**
     * Constructs a ProductionLineManager with empty task queue and history.
     */
    public ProductionLineManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the end of the task queue.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // offer is preferred over add in queues as it returns false if failed (though LinkedList doesn't fail)
        System.out.println("Task added to queue: " + newTask);
    }

    /**
     * Processes the next task from the front of the queue, moving it
     * to the processed history.
     */
    public void processNextTask() {
        Task nextTask = taskQueue.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTask != null) {
            processedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask);
        } else {
            System.err.println("Error: Task queue is empty. Nothing to process.");
        }
    }

    /**
     * Displays all tasks currently waiting in the queue.
     */
    public void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all tasks that have been processed.
     */
    public void viewProcessedHistory() {
        System.out.println("\n--- Processed Task History ---");
        if (processedTasks.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            int index = 1;
            for (Task task : processedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("------------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nProduction Line Manager Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main method to run the Production Line Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineManager manager = new ProductionLineManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Welcome to the Production Line Task Manager!");

        // Use a try-catch block for overall robustness, especially around user input loop
        try {
            while (running) {
                manager.displayMenu();

                // Inner try-catch for handling potential input issues specifically
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int

                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            try {
                                manager.addTask(description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                            break;
                        case 2:
                            manager.processNextTask();
                            break;
                        case 3:
                            manager.viewTaskQueue();
                            break;
                        case 4:
                            manager.viewProcessedHistory();
                            break;
                        case 5:
                            System.out.println("Exiting Production Line Manager. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                // Add a small pause or prompt to continue if desired, but not strictly required by prompt.
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or exceptions occur
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}
