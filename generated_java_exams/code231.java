/*
 * Exam Question #231
 * Generated on: 2025-05-11 22:36:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Hospital Patient Flow Management System**
 * 
 * You are tasked with developing a simplified system for managing patient flow in a hospital clinic. The system should handle scheduled appointments and a waiting list for patients who have checked in.
 * 
 * Your program must meet the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of scheduled appointments using a `List<Patient>`. The concrete implementation should be an `ArrayList`.
 *     *   Maintain a waiting list for checked-in patients using a `Queue<Patient>`. The concrete implementation should be a `LinkedList` (which implements `Queue`).
 * 
 * 2.  **Patient Class:**
 *     *   Create a `Patient` class with private fields: `patientId` (String), `name` (String), and `scheduledTime` (String - assume "HH:MM" format for simplicity).
 *     *   Include a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Implement a `toString()` method to provide a clear representation of a patient.
 * 
 * 3.  **System Functionality:**
 *     *   The system should present a menu to the user with the following options:
 *         *   1. Add Scheduled Appointment
 *         *   2. Patient Check-in
 *         *   3. Call Next Patient (from waiting list)
 *         *   4. View Waiting List
 *         *   5. View All Scheduled Appointments
 *         *   6. Exit
 *     *   Use a `Scanner` to read user input for menu choices and patient details.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Operation Details:**
 *     *   **Add Scheduled Appointment:** Prompt for patient ID, name, and scheduled time. Create a `Patient` object and add it to the `List` of scheduled appointments.
 *     *   **Patient Check-in:** Prompt for a patient ID. Search the `List` of scheduled appointments for a patient with the matching ID.
 *         *   If found: Remove the patient from the scheduled list and add them to the `Queue` waiting list. Print a success message using `System.out`.
 *         *   If not found: Print an error message to `System.err`.
 *         *   *Self-correction/Enhancement:* If the patient is already in the waiting list, handle this case (e.g., print a message to `System.err` indicating they are already checked in). You might need to iterate through the queue to check, or add a flag/status to the `Patient` object (optional, but adds complexity). For this task, simply checking if they exist in the scheduled list is sufficient, assuming a patient is only added to the queue *from* the scheduled list.
 *     *   **Call Next Patient:** If the `Queue` is not empty, remove the patient at the front of the queue using `poll()`. Print a message using `System.out` indicating which patient is being called.
 *         *   If the `Queue` is empty: Print a message using `System.out` indicating the waiting list is empty.
 *     *   **View Waiting List:** Iterate through and print the details of each patient currently in the `Queue`.
 *     *   **View All Scheduled Appointments:** Iterate through and print the details of each patient currently in the `List` of scheduled appointments.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential issues like `InputMismatchException` when reading integer menu choices. The main application loop should be enclosed in a `try-catch` to handle unexpected errors gracefully.
 *     *   Use `System.err` specifically for error messages (e.g., invalid input, patient not found during check-in).
 *     *   Use `System.out` for all normal output (menu, success messages, list contents, patient called).
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., checking if patient ID exists).
 *     *   Structure the code logically into classes and methods.
 * 
 * **Expected Output:**
 * The program should repeatedly display the menu, accept user input, perform the requested action, and print appropriate output to `System.out` or `System.err`. Example interaction might look like:
 * 
 * ```
 * Hospital Patient Flow Management System
 * Menu:
 * 1. Add Scheduled Appointment
 * 2. Patient Check-in
 * 3. Call Next Patient (from waiting list)
 * 4. View Waiting List
 * 5. View All Scheduled Appointments
 * 6. Exit
 * Enter choice: 1
 * Enter patient ID: P101
 * Enter patient name: Alice Smith
 * Enter scheduled time (HH:MM): 10:00
 * Scheduled appointment added for P101.
 * 
 * Menu:
 * ...
 * Enter choice: 5
 * --- All Scheduled Appointments ---
 * Patient ID: P101, Name: Alice Smith, Scheduled: 10:00
 * ----------------------------------
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Enter patient ID to check-in: P101
 * Patient P101 (Alice Smith) checked in and added to waiting list.
 * 
 * Menu:
 * ...
 * Enter choice: 5
 * --- All Scheduled Appointments ---
 * (List should now be empty or not contain P101 if removed)
 * ----------------------------------
 * 
 * Menu:
 * ...
 * Enter choice: 4
 * --- Waiting List ---
 * Patient ID: P101, Name: Alice Smith, Scheduled: 10:00
 * --------------------
 * 
 * Menu:
 * ...
 * Enter choice: 3
 * Calling next patient: Patient ID: P101, Name: Alice Smith, Scheduled: 10:00
 * 
 * Menu:
 * ...
 * Enter choice: 4
 * --- Waiting List ---
 * (List should now be empty)
 * --------------------
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Enter patient ID to check-in: P999
 * Error: Patient with ID P999 not found in scheduled appointments.
 * 
 * Menu:
 * ...
 * Enter choice: 7
 * Error: Invalid menu choice. Please enter a number between 1 and 6.
 * 
 * Menu:
 * ...
 * Enter choice: exit (or non-integer)
 * Error: Invalid input. Please enter a number.
 * 
 * Menu:
 * ...
 * Enter choice: 6
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a `HospitalPatientFlowManager` system as described in the problem, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Patient` Class:** A simple POJO (Plain Old Java Object) representing a patient. It uses `private` fields (`patientId`, `name`, `scheduledTime`) for encapsulation and provides `public` getter methods. The `toString()` method provides a convenient way to display patient information.
 * 
 * 2.  **`HospitalPatientFlowManager` Class:** This is the main class managing the system's state and operations.
 *     *   **Data Structures:**
 *         *   `List<Patient> scheduledAppointments = new ArrayList<>();`: An `ArrayList` is used to store scheduled appointments. `ArrayList` is a concrete implementation of the `List` interface. It's suitable here as we need to store and potentially remove elements by object reference or by iterating. Using the `List` interface type promotes flexibility.
 *         *   `Queue<Patient> waitingList = new LinkedList<>();`: A `LinkedList` is used as the implementation for the `Queue`. `LinkedList` efficiently supports adding and removing elements from both ends, making it a good choice for a queue (FIFO - First-In, First-Out) where patients are added to the end (`offer`) and removed from the front (`poll`). Using the `Queue` interface type is crucial for programming to interfaces.
 *     *   **`Scanner scanner = new Scanner(System.in);`**: A `Scanner` is initialized to read input from the standard input stream (`System.in`).
 *     *   **Constructor:** Initializes the `ArrayList`, `LinkedList`, and `Scanner`. Includes optional dummy data for testing.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addScheduledAppointment()`:** Reads patient details using the `Scanner` and creates a `Patient` object, adding it to the `scheduledAppointments List`. Includes a basic check for duplicate IDs (printing to `System.err`).
 *     *   **`patientCheckIn()`:** Prompts for an ID, iterates through the `scheduledAppointments List` to find the patient. If found, it removes the patient from the `List` and adds them to the `waitingList Queue` using `offer()`. Success messages go to `System.out`. If the patient is not found, an error message is sent to `System.err`. An optional check is included to see if the patient is already in the waiting list.
 *     *   **`callNextPatient()`:** Uses `waitingList.poll()` to retrieve and remove the patient at the head of the `Queue`. If the queue is empty, `poll()` returns `null`, which is handled gracefully with a message to `System.out`. Otherwise, the called patient's details are printed to `System.out`.
 *     *   **`viewWaitingList()`:** Iterates through the `waitingList Queue` (without removing elements) and prints each patient's details to `System.out`.
 *     *   **`viewAllScheduledAppointments()`:** Iterates through the `scheduledAppointments List` and prints each patient's details to `System.out`.
 *     *   **`run()`:** This method contains the main application loop (`while (choice != 6)`).
 *         *   It calls `displayMenu()`.
 *         *   It uses a `try-catch` block around the input reading and `switch` statement.
 *         *   **Input Validation & Error Handling (Menu Choice):** It checks if the input is an integer using `scanner.hasNextInt()`. If not, it prints an error to `System.err`, consumes the invalid input using `scanner.next()`, and loops again. If it is an integer, it reads it using `scanner.nextInt()`, consumes the remaining newline, and proceeds to the `switch`. This pattern is more robust than just `try-catch` for `InputMismatchException` as it explicitly handles consuming the bad input.
 *         *   **`switch (choice)`:** Directs execution based on the validated integer input. Each case calls the corresponding method. The `default` case handles valid integer inputs that are outside the expected range (1-6), printing an error to `System.err`.
 *         *   **Class-wide `try-catch (Exception e)`:** A general `catch` block is included to handle any other unexpected runtime exceptions that might occur within the loop, printing the error message and stack trace to `System.err` before potentially continuing the loop.
 *         *   The `Scanner` is closed when the loop exits.
 *     *   **`main()`:** The entry point of the program, creating an instance of `HospitalPatientFlowManager` and calling its `run()` method.
 * 
 * This solution effectively uses all the required components in a practical scenario, demonstrates proper data structure usage, implements menu-driven flow control with `switch`, handles input and logical errors using `System.err` and `System.out`, and incorporates class-wide exception handling and best coding practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient with an ID, name, and scheduled appointment time.
 */
class Patient {
    private String patientId;
    private String name;
    private String scheduledTime;

    /**
     * Constructs a new Patient object.
     * @param patientId The unique identifier for the patient.
     * @param name The name of the patient.
     * @param scheduledTime The scheduled time of the appointment (HH:MM format).
     */
    public Patient(String patientId, String name, String scheduledTime) {
        this.patientId = patientId;
        this.name = name;
        this.scheduledTime = scheduledTime;
    }

    /**
     * Gets the patient ID.
     * @return The patient ID.
     */
    public String getPatientId() {
        return patientId;
    }

    /**
     * Gets the patient name.
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the scheduled time.
     * @return The scheduled time.
     */
    public String getScheduledTime() {
        return scheduledTime;
    }

    /**
     * Returns a string representation of the Patient object.
     * @return A formatted string including patient ID, name, and scheduled time.
     */
    @Override
    public String toString() {
        return "Patient ID: " + patientId + ", Name: " + name + ", Scheduled: " + scheduledTime;
    }
}

/**
 * Manages the flow of patients in a hospital clinic, including scheduled
 * appointments and a waiting list.
 */
public class HospitalPatientFlowManager {

    private List<Patient> scheduledAppointments;
    private Queue<Patient> waitingList;
    private Scanner scanner;

    /**
     * Constructs a new HospitalPatientFlowManager.
     * Initializes the scheduled appointments list, waiting list, and scanner.
     */
    public HospitalPatientFlowManager() {
        // Use ArrayList for scheduled appointments as required by the problem,
        // accessing by index or iterating is common here, and removal might occur.
        this.scheduledAppointments = new ArrayList<>();
        // Use LinkedList as a Queue implementation for the waiting list,
        // as FIFO (First-In, First-Out) is the required behavior.
        this.waitingList = new LinkedList<>();
        this.scanner = new Scanner(System.in);

        // Optional: Add some initial dummy data for easier testing
        scheduledAppointments.add(new Patient("P101", "Alice Smith", "10:00"));
        scheduledAppointments.add(new Patient("P102", "Bob Johnson", "10:15"));
        scheduledAppointments.add(new Patient("P103", "Charlie Brown", "10:30"));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nHospital Patient Flow Management System");
        System.out.println("Menu:");
        System.out.println("1. Add Scheduled Appointment");
        System.out.println("2. Patient Check-in");
        System.out.println("3. Call Next Patient (from waiting list)");
        System.out.println("4. View Waiting List");
        System.out.println("5. View All Scheduled Appointments");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a new scheduled appointment based on user input.
     */
    private void addScheduledAppointment() {
        System.out.print("Enter patient ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        System.out.print("Enter scheduled time (HH:MM): ");
        String time = scanner.nextLine();

        // Basic validation: Check if ID already exists (optional but good practice)
        boolean idExists = scheduledAppointments.stream().anyMatch(p -> p.getPatientId().equals(id));
        if (idExists) {
            System.err.println("Error: Patient with ID " + id + " already exists in scheduled appointments.");
            return;
        }
        // Could also check if patient is in waiting list, but problem implies check-in moves them.

        Patient newPatient = new Patient(id, name, time);
        scheduledAppointments.add(newPatient);
        System.out.println("Scheduled appointment added for " + id + ".");
    }

    /**
     * Handles patient check-in. Finds the patient in the scheduled list
     * and moves them to the waiting list.
     */
    private void patientCheckIn() {
        System.out.print("Enter patient ID to check-in: ");
        String id = scanner.nextLine();

        Patient patientToFind = null;
        // Find the patient in the scheduled appointments list
        for (Patient p : scheduledAppointments) {
            if (p.getPatientId().equals(id)) {
                patientToFind = p;
                break;
            }
        }

        if (patientToFind != null) {
            // Check if the patient is already in the waiting list (optional check)
             boolean alreadyInQueue = waitingList.stream().anyMatch(p -> p.getPatientId().equals(id));
             if (alreadyInQueue) {
                 System.err.println("Error: Patient with ID " + id + " is already checked in and in the waiting list.");
                 return;
             }

            scheduledAppointments.remove(patientToFind); // Remove from scheduled
            waitingList.offer(patientToFind); // Add to the end of the waiting list
            System.out.println("Patient " + id + " (" + patientToFind.getName() + ") checked in and added to waiting list.");
        } else {
            System.err.println("Error: Patient with ID " + id + " not found in scheduled appointments.");
        }
    }

    /**
     * Calls the next patient from the front of the waiting list.
     */
    private void callNextPatient() {
        Patient nextPatient = waitingList.poll(); // Retrieves and removes the head of the queue
        if (nextPatient != null) {
            System.out.println("Calling next patient: " + nextPatient);
        } else {
            System.out.println("Waiting list is currently empty.");
        }
    }

    /**
     * Displays all patients currently in the waiting list.
     */
    private void viewWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterating through a Queue using a for-each loop or iterator
            // does NOT remove elements, which is what we want here.
            for (Patient patient : waitingList) {
                System.out.println(patient);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all currently scheduled appointments.
     */
    private void viewAllScheduledAppointments() {
        System.out.println("\n--- All Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No scheduled appointments.");
        } else {
            for (Patient patient : scheduledAppointments) {
                System.out.println(patient);
            }
        }
        System.out.println("----------------------------------");
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            displayMenu();
            try {
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input line to prevent infinite loop
                    String invalidInput = scanner.next();
                    System.err.println("Error: Invalid input '" + invalidInput + "'. Please enter a number.");
                    choice = 0; // Set choice to 0 or any value not in the switch cases to re-display menu
                }
                scanner.nextLine(); // Consume the rest of the newline character after reading int

                // Use switch statement for flow control based on valid integer input
                switch (choice) {
                    case 1:
                        addScheduledAppointment();
                        break;
                    case 2:
                        patientCheckIn();
                        break;
                    case 3:
                        callNextPatient();
                        break;
                    case 4:
                        viewWaitingList();
                        break;
                    case 5:
                        viewAllScheduledAppointments();
                        break;
                    case 6:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handles integer inputs outside the 1-6 range
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (InputMismatchException e) {
                 // This specific catch block is technically redundant if hasNextInt() check is used,
                 // but kept to demonstrate catching InputMismatchException explicitly if needed,
                 // and as a fallback. The hasNextInt() + next() approach is more robust
                 // for consuming invalid input without crashing.
                 System.err.println("Error: Invalid input. Please enter a number.");
                 scanner.nextLine(); // Consume the invalid input
                 choice = 0; // Reset choice to loop again
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the process
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
                // Optionally, decide if you want to exit or continue after a severe error
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the Hospital Patient Flow Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalPatientFlowManager manager = new HospitalPatientFlowManager();
        manager.run();
    }
}
