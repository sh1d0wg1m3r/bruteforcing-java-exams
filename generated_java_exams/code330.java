/*
 * Exam Question #330
 * Generated on: 2025-05-11 22:56:12
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:** You are tasked with developing a basic console-based Task Management System for a single user. The system should allow the user to add new tasks, view tasks awaiting completion, view tasks already completed, and mark the next pending task as completed. The system should be robust enough to handle common input errors and system state issues gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each task must have:
 *     *   A unique integer ID.
 *     *   A string description.
 *     *   A string priority (e.g., "High", "Medium", "Low").
 *     *   Implement proper encapsulation (private fields, public getters).
 *     *   Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` that will manage the collection of tasks. This class must use the following data structures and components:
 *     *   A `java.util.Queue<Task>` to store tasks that are currently pending or waiting for completion. Tasks should be processed in the order they were added (FIFO - First-In, First-Out).
 *     *   A `java.util.List<Task>` variable, implemented using `java.util.ArrayList`, to store tasks that have been marked as completed.
 *     *   A `java.util.Scanner` to read user input from the console.
 *     *   A `switch` statement within the main application loop to handle different user menu selections.
 *     *   `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   `System.err` for displaying all error messages (e.g., invalid input, trying to complete a task when none are pending).
 * 
 * 3.  **Functionality:** The `TaskManager` class must provide the following operations via a main menu loop:
 *     *   **Add New Task:** Prompt the user for a task description and priority, create a `Task` object with a unique ID, and add it to the pending tasks queue. Implement basic input validation (e.g., check if description is empty).
 *     *   **View Pending Tasks:** Display all tasks currently in the pending tasks queue without removing them.
 *     *   **View Completed Tasks:** Display all tasks currently in the completed tasks list.
 *     *   **Complete Next Task:** Remove the next task from the front of the pending tasks queue and add it to the completed tasks list. If the pending queue is empty, display an error message using `System.err`.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to manage potential runtime errors. Specifically, handle `InputMismatchException` when reading integer menu choices, and include a general catch block for any other unexpected exceptions during the main loop execution. All error messages *must* be printed to `System.err`.
 *     *   Ensure the `Scanner` resource is properly closed when the application exits or in case of unexpected termination.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Follow Java coding conventions.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a menu. Based on the user's integer input, it should perform the corresponding action.
 * - Adding a task should prompt for details and confirm addition.
 * - Viewing tasks should list the tasks in the respective collections.
 * - Completing a task should either confirm completion or report an error if no tasks are pending.
 * - Invalid menu input (non-integer or out of range) should result in an error message on `System.err` and the menu being displayed again.
 * - Exiting should print a goodbye message and terminate.
 * 
 * Example interaction flow (user input shown in `bold`):
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **1**
 * 
 * --- Add New Task ---
 * Enter task description: **Learn Java**
 * Enter task priority (e.g., High, Medium, Low): **High**
 * Task added: Task [ID=1, Description='Learn Java', Priority='High']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **1**
 * 
 * --- Add New Task ---
 * Enter task description: **Practice Coding**
 * Enter task priority (e.g., High, Medium, Low): **Medium**
 * Task added: Task [ID=2, Description='Practice Coding', Priority='Medium']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **2**
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Description='Learn Java', Priority='High']
 * Task [ID=2, Description='Practice Coding', Priority='Medium']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **4**
 * 
 * --- Completing Next Task ---
 * Completed task: Task [ID=1, Description='Learn Java', Priority='High']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **2**
 * 
 * --- Pending Tasks ---
 * Task [ID=2, Description='Practice Coding', Priority='Medium']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **3**
 * 
 * --- Completed Tasks ---
 * Task [ID=1, Description='Learn Java', Priority='High']
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **6**
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **abc**
 * Invalid input. Please enter a number.
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: **5**
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing the `Task` and `TaskManager` classes, including the `main` method to start the application.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System as requested, demonstrating the use of various core Java concepts and libraries.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the task's `id`, `description`, and `priority` as private fields, accessible only through public getter methods (`getId`, `getDescription`, `getPriority`), adhering to the principle of encapsulation. The `toString()` method is overridden to provide a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class orchestrates the entire system logic.
 *     *   **`java.util.Queue<Task>`:** The `pendingTasks` field is declared as a `Queue<Task>` and initialized with `java.util.ArrayDeque`. A `Queue` is used here because tasks are expected to be processed in a First-In, First-Out (FIFO) manner â€“ the task added earliest is the next one to be completed. The `offer()` method is used to add tasks to the end of the queue, and `poll()` is used to remove and return the task from the front (head) of the queue when it's completed. `forEach` is used to iterate through pending tasks for viewing without removing them.
 *     *   **`java.util.List<Task>` / `java.util.ArrayList`:** The `completedTasks` field is declared as a `List<Task>` and initialized with `java.util.ArrayList`. A `List` is suitable for storing completed tasks as a historical record where the order of completion is maintained, and elements are simply added to the end using the `add()` method. `forEach` is used to iterate through completed tasks for viewing.
 *     *   **`java.util.Scanner`:** An instance of `Scanner` is used to read user input from `System.in`. It's initialized once in the constructor and used throughout the `run` method and the `addTask` method to capture menu choices, task descriptions, and priorities. It is crucial to handle the newline character left by `nextInt()` when mixing `nextInt()` and `nextLine()`. The `scanner.nextLine()` call after `scanner.nextInt()` serves this purpose. The `Scanner` is closed in the `finally` block to release the system resource.
 *     *   **`switch` statement:** Located in the `run()` method, the `switch` statement is used to direct the program flow based on the integer input received for the main menu choice. Each `case` corresponds to a menu option (Add, View Pending, View Completed, Complete, Exit), calling the appropriate method. The `default` case handles invalid integer inputs (out of the 1-5 range).
 *     *   **`System.out` and `System.err`:** `System.out` is used for standard output, including displaying the menu, prompts for input, confirmation messages, and the lists of tasks. `System.err` is specifically used for printing error messages, such as invalid user input, attempting to complete a task when the queue is empty, or unexpected system errors. This distinction helps users and logging systems differentiate between normal program output and critical errors.
 *     *   **`try-catch` blocks:** Exception handling is implemented using `try-catch`. A general `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method, providing "class-wide" handling for any unexpected runtime errors that might occur during the execution of the loop's body. Additionally, a specific `try-catch(InputMismatchException e)` is nested inside the loop to gracefully handle cases where the user enters non-integer input when prompted for a menu choice. The `finally` block is used with the outer `try-catch` to ensure the `Scanner` is closed regardless of whether the loop finishes normally or an exception occurs. Error messages from catch blocks are directed to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in both `Task` and `TaskManager` are private, accessed via public methods where necessary.
 * *   **Meaningful Names:** Variable names like `pendingTasks`, `completedTasks`, `nextTaskId`, `addTask`, `completeNextTask` clearly indicate their purpose.
 * *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic points (like handling the newline after `nextInt`).
 * *   **Input Validation:** Basic validation is performed in `addTask` to ensure the description is not empty. The `try-catch(InputMismatchException)` handles non-integer input for menu selection.
 * *   **Proper Error Handling:** Distinct error messages are provided via `System.err` for different error scenarios (invalid input type, invalid menu number, empty queue, unexpected exception). The stack trace is printed to `System.err` for unexpected exceptions to aid debugging.
 * *   **Clean Code Structure:** The logic is separated into a `Task` class for data representation and a `TaskManager` class for application logic. Methods are kept focused on single responsibilities (e.g., `addTask`, `viewPendingTasks`, `displayMenu`).
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a practical scenario while demonstrating robust error handling and adherence to best coding practices.
 */

import java.util.Queue;
import java.util.ArrayDeque; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task with ID, description, and priority.
class Task {
    private int id;
    private String description;
    private String priority;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task (e.g., High, Medium, Low).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task object.
     * @return A formatted string containing task details.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Priority='" + priority + "']";
    }
}

// Manages the collection of tasks using a Queue for pending and a List for completed tasks.
public class TaskManager {

    // Queue to hold tasks that are pending completion (FIFO).
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed.
    private List<Task> completedTasks;
    // Counter for generating unique task IDs.
    private int nextTaskId;
    // Scanner for reading user input.
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // Initialize pending tasks queue using ArrayDeque
        this.pendingTasks = new ArrayDeque<>();
        // Initialize completed tasks list using ArrayList
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task based on user input.
     * Prompts for description and priority and adds the task to the pending queue.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        // Use nextLine() to read the whole line including spaces
        String description = scanner.nextLine();

        // Basic input validation: description cannot be empty or just whitespace.
        if (description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }

        System.out.print("Enter task priority (e.g., High, Medium, Low): ");
        String priority = scanner.nextLine();

        // Create a new Task object with a unique ID
        Task newTask = new Task(nextTaskId++, description, priority);
        // Add the new task to the end of the pending tasks queue
        pendingTasks.offer(newTask);
        System.out.println("Task added successfully: " + newTask);
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            // Iterate and print tasks in the queue order without removing them
            pendingTasks.forEach(System.out::println);
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate and print tasks in the completed list
            completedTasks.forEach(System.out::println);
        }
    }

    /**
     * Completes the next task in the pending queue (FIFO).
     * Removes the task from the front of the queue and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void completeNextTask() {
        System.out.println("\n--- Completing Next Task ---");
        // Check if the pending queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No tasks are pending to be completed.");
        } else {
            // Remove the task from the front of the queue
            Task completedTask = pendingTasks.poll();
            // Add the completed task to the completed tasks list
            completedTasks.add(completedTask);
            System.out.println("Completed task: " + completedTask);
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and menu selection.
     * Includes exception handling for robust execution.
     */
    public void run() {
        int choice = -1;
        boolean running = true;

        // Class-wide exception handling wrapping the main operational loop.
        try {
            while (running) {
                displayMenu();

                // Inner try-catch specifically for handling input reading errors
                try {
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle cases where the input is not an integer
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input token to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use a switch statement to handle valid menu choices
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        viewCompletedTasks();
                        break;
                    case 4:
                        completeNextTask();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle cases where the integer input is out of the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure the scanner resource is closed in all cases (normal exit or exception)
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation
            }
        }
    }

    /**
     * The main method, entry point of the application.
     * Creates a TaskManager instance and starts the application loop.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
