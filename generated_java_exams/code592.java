/*
 * Exam Question #592
 * Generated on: 2025-05-12 16:11:45
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Develop a Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line Task Management System. This system should allow users to add different types of tasks to a processing queue, process tasks one by one, and view lists of pending and completed tasks.
 * 
 * The system must handle two types of tasks:
 * 1.  **Simple Task:** Has a description and a unique ID.
 * 2.  **Priority Task:** Extends Simple Task, adds a priority level (an integer).
 * 
 * The system will manage tasks using a queue for pending tasks and a list for completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create an abstract base class or interface `Task` with a description and a unique integer ID.
 *     *   Implement `SimpleTask` extending/implementing `Task`.
 *     *   Implement `PriorityTask` extending/implementing `Task`, adding a `priorityLevel` integer field.
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Override `toString()` in task classes for easy printing.
 * 2.  **Task Management System Class:**
 *     *   Create a class `TaskProcessingSystem` to manage the tasks.
 *     *   This class must contain:
 *         *   A `Queue<Task>` to hold tasks waiting to be processed.
 *         *   A `List<Task>` to hold tasks that have been completed.
 *         *   A mechanism to generate unique task IDs (e.g., a counter).
 *     *   Implement methods for:
 *         *   `addTask(Task task)`: Adds a task to the queue.
 *         *   `processNextTask()`: Removes the next task from the queue, "processes" it (e.g., prints a processing message), and moves it to the completed list. Handle the case where the queue is empty.
 *         *   `viewPendingTasks()`: Prints the contents of the pending task queue.
 *         *   `viewCompletedTasks()`: Prints the contents of the completed tasks list.
 * 3.  **User Interface:**
 *     *   Implement a command-line interface using `java.util.Scanner` to interact with the user.
 *     *   Present a menu with the following options:
 *         *   1. Add Simple Task
 *         *   2. Add Priority Task
 *         *   3. Process Next Task
 *         *   4. View Pending Tasks
 *         *   5. View Completed Tasks
 *         *   6. Exit
 *     *   Use a `switch` statement to handle the menu selections.
 *     *   Prompt the user for necessary details (description, priority level) when adding tasks.
 *     *   Implement input validation for menu choices and task details (e.g., ensuring priority is an integer).
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `InputMismatchException` when reading user input and handling an empty queue during processing.
 *     *   Use `System.err` to output error messages.
 *     *   Use `System.out` for all normal output (menu, prompts, task details, success messages).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure resources like `Scanner` are properly closed (e.g., using try-with-resources).
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept user input, perform the requested operations, and print relevant information or error messages to the console (`System.out` or `System.err`). Example flow:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add Simple Task
 * 2. Add Priority Task
 * 3. Process Next Task
 * 4. View Pending Tasks
 * 5. View Completed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter simple task description: Write report
 * Simple task added: Task ID: 1, Description: Write report
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Enter priority task description: Fix critical bug
 * Enter priority level (integer): 1
 * Priority task added: Task ID: 2, Description: Fix critical bug, Priority: 1
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tasks ---
 * Task ID: 1, Description: Write report
 * Task ID: 2, Description: Fix critical bug, Priority: 1
 * ---------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Processing Task ID: 1 - Write report
 * Task ID 1 completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Completed Tasks ---
 * Task ID: 1, Description: Write report
 * -----------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Processing Task ID: 2 - Fix critical bug, Priority: 1
 * Task ID 2 completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Error: No tasks in the queue to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The solution implements a Task Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Hierarchy:**
 *     *   An `abstract class Task` is defined with common attributes (`taskId`, `description`) and a static counter `nextId` to generate unique IDs. It includes an abstract method `processTask()` which concrete subclasses must implement. The constructor validates the description.
 *     *   `SimpleTask` extends `Task` and provides a basic implementation of `processTask()`.
 *     *   `PriorityTask` extends `Task`, adds a `priorityLevel` field, and provides its own `processTask()` implementation.
 *     *   `toString()` methods are overridden in each class for clear representation. Encapsulation is used by making fields private and providing public getters.
 * 
 * 2.  **TaskProcessingSystem Class:**
 *     *   This class orchestrates the system.
 *     *   `taskQueue`: Declared as `Queue<Task>` and initialized with a `LinkedList`. `Queue` is used to manage tasks in a FIFO (First-In, First-Out) manner, which is suitable for a processing queue where tasks are handled in the order they are added (unless priority sorting was implemented, which wasn't explicitly required but `LinkedList` supports `Queue` operations like `offer` and `poll`).
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with an `ArrayList`. `List` is used to store completed tasks, allowing ordered storage and easy iteration. `ArrayList` provides dynamic resizing.
 *     *   `addTask(Task task)`: Uses `taskQueue.offer(task)` to add a task. `offer` is the standard way to add to a queue, returning `false` if the queue is full (though `LinkedList` is unbounded). Includes null check for the task.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. `poll()` is preferred over `remove()` as it returns `null` if the queue is empty, allowing graceful handling of this case. The processed task is then added to the `completedTasks` list using `completedTasks.add()`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections and print task details using enhanced for loops or streams (`forEach`).
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   The `run()` method contains the main application loop.
 *     *   `Scanner`: Used to read user input from `System.in`. A `try-with-resources` block ensures the `Scanner` is automatically closed when the `run` method finishes.
 *     *   `printMenu()`: A helper method to display the menu options using `System.out`.
 *     *   `switch` statement: Used inside the loop to execute the appropriate action based on the user's integer choice.
 * 
 * 4.  **Error Handling:**
 *     *   `try-catch (InputMismatchException e)`: Placed around `scanner.nextInt()` calls to catch non-integer input when an integer is expected (menu choice, priority level). An error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input and prevent an infinite loop.
 *     *   `System.err.println()`: Used consistently for reporting errors (invalid input, empty queue, issues adding tasks).
 *     *   Null checks and checks for empty collections are performed where necessary (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`).
 *     *   A general `try-catch (Exception e)` is included in the main loop's `try` block to catch any other unexpected runtime exceptions that might occur during the processing of a menu choice, printing an error to `System.err` and the stack trace for debugging.
 *     *   The `Task` constructor includes input validation for the description, throwing `IllegalArgumentException` which is caught in the `run` method when adding tasks.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names are used for classes, methods, and variables (`taskQueue`, `completedTasks`, `processNextTask`, `priorityLevel`).
 *     *   Comments and Javadoc are included to explain the purpose of classes, methods, and significant parts of the code.
 *     *   `try-with-resources` is used for the `Scanner`.
 *     *   The code is structured into logical classes with distinct responsibilities.
 *     *   Using `List` interface for `completedTasks` demonstrates coding to interfaces.
 * 
 * This solution effectively uses all the required Java components in a cohesive, practical scenario, including robust error handling and adherence to good programming practices, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Abstract base class for tasks
abstract class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int taskId;
    private String description;

    /**
     * Constructs a Task with a description and assigns a unique ID.
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.taskId = nextId++;
        this.description = description.trim();
    }

    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Abstract method to represent processing the task.
     * Concrete subclasses must implement this.
     */
    public abstract void processTask();

    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description;
    }
}

// Concrete class for simple tasks
class SimpleTask extends Task {

    /**
     * Constructs a SimpleTask.
     * @param description The description of the simple task.
     */
    public SimpleTask(String description) {
        super(description);
    }

    @Override
    public void processTask() {
        // Simulate processing
        System.out.println("Processing Simple Task: " + getDescription());
        // In a real system, this would do actual work
    }

    @Override
    public String toString() {
        return super.toString();
    }
}

// Concrete class for priority tasks
class PriorityTask extends Task {
    private int priorityLevel;

    /**
     * Constructs a PriorityTask.
     * @param description The description of the priority task.
     * @param priorityLevel The priority level (lower number usually means higher priority).
     */
    public PriorityTask(String description, int priorityLevel) {
        super(description);
        this.priorityLevel = priorityLevel;
    }

    public int getPriorityLevel() {
        return priorityLevel;
    }

    @Override
    public void processTask() {
        // Simulate processing
        System.out.println("Processing Priority Task: " + getDescription() + " with priority " + priorityLevel);
        // In a real system, this would do actual work
    }

    @Override
    public String toString() {
        return super.toString() + ", Priority: " + priorityLevel;
    }
}

// Main class managing the task processing system
public class TaskProcessingSystem {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new TaskProcessingSystem.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            taskQueue.offer(task); // offer is generally preferred over add for queues
            System.out.println("Task added: " + task);
        } else {
            System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task from the queue.
     * Moves the task to the completed list after processing.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll returns null if queue is empty
        if (taskToProcess != null) {
            System.out.println("Processing " + taskToProcess.toString().split(",")[0] + " - " + taskToProcess.getDescription());
            try {
                taskToProcess.processTask(); // Call the task's specific processing logic
                completedTasks.add(taskToProcess);
                System.out.println("Task ID " + taskToProcess.getTaskId() + " completed.");
            } catch (Exception e) {
                // Catch any unexpected exception during task processing
                System.err.println("Error processing Task ID " + taskToProcess.getTaskId() + ": " + e.getMessage());
                // Decide whether to add to completed or an error list
                // For this example, we'll just log the error.
            }
        } else {
            System.err.println("Error: No tasks in the queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate over the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main interactive menu loop.
     */
    public void run() {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;
            while (choice != 6) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                    switch (choice) {
                        case 1: // Add Simple Task
                            System.out.print("Enter simple task description: ");
                            String simpleDesc = scanner.nextLine();
                            try {
                                addTask(new SimpleTask(simpleDesc));
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                            break;

                        case 2: // Add Priority Task
                            System.out.print("Enter priority task description: ");
                            String priorityDesc = scanner.nextLine();
                            int priority = -1;
                            try {
                                System.out.print("Enter priority level (integer): ");
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                addTask(new PriorityTask(priorityDesc, priority));
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid input. Please enter an integer for priority level.");
                                scanner.nextLine(); // Consume the invalid input
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                            break;

                        case 3: // Process Next Task
                            processNextTask();
                            break;

                        case 4: // View Pending Tasks
                            viewPendingTasks();
                            break;

                        case 5: // View Completed Tasks
                            viewCompletedTasks();
                            break;

                        case 6: // Exit
                            System.out.println("Exiting Task Management System.");
                            break;

                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to prevent exiting loop prematurely
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during menu processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                }
                System.out.println(); // Add a newline for better readability
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add Simple Task");
        System.out.println("2. Add Priority Task");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Completed Tasks");
        System.out.println("6. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
