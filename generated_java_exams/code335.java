/*
 * Exam Question #335
 * Generated on: 2025-05-11 22:56:49
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Resource Allocation and Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing resources and processing tasks in a simulated environment. The system has a fixed pool of processing resources. Incoming tasks are placed in a queue. When a resource becomes available, the next task from the queue is assigned to it for processing. The system should allow adding new tasks, processing tasks, and viewing the status of tasks and resources.
 * 
 * **System Components:**
 * 
 * 1.  **Resources:** A fixed number of abstract processing units, identified by integer IDs (e.g., 1, 2, 3...). Initially, all resources are available.
 * 2.  **Pending Tasks:** A queue holding tasks that are waiting for a resource to become available. Tasks are processed in the order they are added (FIFO).
 * 3.  **Completed Tasks:** A list holding tasks that have been successfully processed.
 * 
 * **Task Definition:**
 * 
 * A `Task` is a simple object with:
 * *   A unique integer ID.
 * *   A String description.
 * 
 * **Functionality:**
 * 
 * The system should provide a command-line interface with the following options:
 * 
 * 1.  **Add Task:** Prompts the user for a task ID and description, creates a `Task` object, and adds it to the pending tasks queue. Validate that the task ID is a positive integer.
 * 2.  **Process Next Task:** Attempts to process the next task from the pending queue.
 *     *   If the queue is not empty AND there are available resources:
 *         *   Dequeue the next task.
 *         *   Allocate an available resource (remove one from the available resources).
 *         *   Simulate processing (e.g., print a message indicating which task is being processed by which resource).
 *         *   Add the task to the completed tasks list.
 *     *   If the queue is empty, print a message indicating no pending tasks.
 *     *   If the queue is not empty but no resources are available, print a message indicating resources are busy.
 * 3.  **List Pending Tasks:** Displays all tasks currently in the pending queue in their current order.
 * 4.  **List Completed Tasks:** Displays all tasks that have been processed.
 * 5.  **List Available Resources:** Displays the IDs of all resources that are currently available.
 * 6.  **Exit:** Terminates the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must use **ALL** of the following Java components:
 * 
 * *   `java.util.Queue` for managing pending tasks.
 * *   `java.util.ArrayList` for managing available resources.
 * *   `java.util.List` interface (e.g., for the completed tasks collection or method parameters/return types).
 * *   `java.util.Scanner` for handling user input from the console.
 * *   `switch` statement for handling the different command options.
 * *   `System.err` for printing error messages (e.g., invalid input, system errors).
 * *   `System.out` for printing normal output (prompts, status messages, lists).
 * *   Class-wide exception handling using `try-catch` blocks to manage potential issues like invalid input format, attempting to process when queues/resources are empty (you might define custom exceptions for clarity).
 * 
 * **Best Practices:**
 * 
 * *   Employ proper encapsulation (private fields, public methods).
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * *   Implement robust input validation.
 * *   Handle errors gracefully using exceptions and `try-catch`.
 * *   Structure your code cleanly.
 * 
 * **Initial State:**
 * 
 * The system should start with a predefined number of available resources (e.g., 3 resources with IDs 1, 2, 3). The pending and completed task collections should be empty.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and respond to user commands. Output should be clear, using `System.out` for informational messages and lists, and `System.err` for error conditions.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Resource Allocation System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. List Available Resources
 * 6. Exit
 * Enter command: 1
 * Enter Task ID: 101
 * Enter Task Description: Data Processing Job
 * Task 101 added to the queue.
 * Enter command: 1
 * Enter Task ID: 102
 * Enter Task Description: Report Generation
 * Task 102 added to the queue.
 * Enter command: 3
 * Pending Tasks:
 * Task ID: 101, Description: Data Processing Job
 * Task ID: 102, Description: Report Generation
 * Enter command: 5
 * Available Resources: [1, 2, 3]
 * Enter command: 2
 * Processing Task ID 101 using Resource 1.
 * Enter command: 5
 * Available Resources: [2, 3]
 * Enter command: 3
 * Pending Tasks:
 * Task ID: 102, Description: Report Generation
 * Enter command: 2
 * Processing Task ID 102 using Resource 2.
 * Enter command: 5
 * Available Resources: [3]
 * Enter command: 4
 * Completed Tasks:
 * Task ID: 101, Description: Data Processing Job
 * Task ID: 102, Description: Report Generation
 * Enter command: 2
 * No resources available to process task.
 * Enter command: 6
 * Exiting System.
 * ```
 * 
 * Your solution should be a single Java file containing the necessary classes and the `main` method.
 *
 * EXPLANATION:
 * This solution implements the `ResourceAllocationSystem` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Task` class: A simple class encapsulating task data (`id`, `description`) with a constructor, getters, and a `toString()` method for easy printing. Input validation for the ID is included in the constructor.
 *     *   `NoResourceAvailableException` and `NoPendingTasksException`: Custom exceptions are defined to provide specific error information when processing fails due to lack of resources or tasks.
 *     *   `ResourceAllocationSystem` class: This is the main class managing the system state. It holds the collections for pending tasks, completed tasks, and available resources.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `Queue`: `pendingTasks` is declared as `Queue<Task>` and initialized with `LinkedList<Task>`, which implements the `Queue` interface. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove tasks in FIFO order.
 *     *   `ArrayList`: `availableResources` is declared and initialized as `ArrayList<Integer>`. It's used to store the IDs of available resources. Resources are removed using `remove(0)` when allocated.
 *     *   `List interface`: `completedTasks` is declared as `List<Task>` and initialized with `ArrayList<Task>`. This demonstrates programming to the interface.
 *     *   `Scanner`: Used in the `main` method to read user input from `System.in`.
 *     *   `switch` statement: Used in the `main` loop to direct program flow based on the user's command.
 *     *   `System.err`: Used for printing error messages, such as invalid input formats or unexpected exceptions.
 *     *   `System.out`: Used for printing the menu, prompts, informational messages (task added, processing message), and listing the contents of the collections.
 *     *   Class-wide exception handling (`try-catch`): The `main` method has a large `try-catch-finally` block wrapping the main loop to catch any uncaught exceptions that might occur. Additionally, inner `try-catch` blocks are used around specific operations (reading command, adding task, processing task) to handle expected exceptions like `InputMismatchException` (for non-numeric input) and the custom exceptions (`NoPendingTasksException`, `NoResourceAvailableException`), providing more granular error handling.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `ResourceAllocationSystem` are `private`, accessed via public methods.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `listAvailableResources`).
 *     *   **Comments/Documentation:** Javadoc comments are provided for classes and methods explaining their purpose, parameters, and return values or exceptions.
 *     *   **Input Validation:** Input for Task ID is validated in the `Task` constructor (must be positive) and in the `main` method (must be an integer). The number of resources in the constructor is also validated.
 *     *   **Error Handling:** `try-catch` blocks are used extensively. Custom exceptions make the `processNextTask` method's potential outcomes clear. Error messages are printed to `System.err`. Informational messages about conditions like "No pending tasks" are printed to `System.out`.
 *     *   **Clean Code:** The code is structured into classes and methods with clear responsibilities. The `main` method handles the user interaction loop and delegates core logic to methods within `ResourceAllocationSystem`.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `addTask`: Uses `queue.offer()`.
 *     *   `processNextTask`: Checks queue and resource availability, throws custom exceptions if conditions aren't met. Uses `queue.poll()` and `ArrayList.remove(0)`. Adds to `completedTasks` list.
 *     *   `listPendingTasks`: Iterates through the `Queue` (using enhanced for loop, which is safe for iteration without removal).
 *     *   `listCompletedTasks`: Iterates through the `List`.
 *     *   `listAvailableResources`: Prints the `ArrayList` directly (its `toString()` is suitable).
 *     *   Menu and loop: Handled in `main` using `Scanner` and `switch`.
 * 
 * This solution effectively integrates the required Java components into a practical scenario, demonstrating proper object-oriented design, error handling, and input management suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.ArrayList;
import java.util.List; // Used for completed tasks and interface declaration
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task to be processed by the system.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        if (id <= 0) {
            throw new IllegalArgumentException("Task ID must be positive.");
        }
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description;
    }
}

/**
 * Custom exception indicating no resources are available.
 */
class NoResourceAvailableException extends Exception {
    public NoResourceAvailableException(String message) {
        super(message);
    }
}

/**
 * Custom exception indicating no pending tasks in the queue.
 */
class NoPendingTasksException extends Exception {
    public NoPendingTasksException(String message) {
        super(message);
    }
}

/**
 * The main system class for managing resources and tasks.
 */
public class ResourceAllocationSystem {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Using List interface
    private ArrayList<Integer> availableResources; // Using ArrayList

    /**
     * Constructs the ResourceAllocationSystem with a specified number of resources.
     * @param numberOfResources The initial number of available resources.
     */
    public ResourceAllocationSystem(int numberOfResources) {
        if (numberOfResources <= 0) {
            throw new IllegalArgumentException("Number of resources must be positive.");
        }
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.availableResources = new ArrayList<>();
        // Initialize resources with IDs 1 to numberOfResources
        for (int i = 1; i <= numberOfResources; i++) {
            this.availableResources.add(i);
        }
        System.out.println("System initialized with " + numberOfResources + " resources.");
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        this.pendingTasks.offer(task); // offer is preferred over add for queues
        System.out.println("Task " + task.getId() + " added to the queue.");
    }

    /**
     * Attempts to process the next task from the queue.
     * @throws NoPendingTasksException if the pending queue is empty.
     * @throws NoResourceAvailableException if no resources are available.
     */
    public void processNextTask() throws NoPendingTasksException, NoResourceAvailableException {
        if (pendingTasks.isEmpty()) {
            throw new NoPendingTasksException("No pending tasks to process.");
        }
        if (availableResources.isEmpty()) {
            throw new NoResourceAvailableException("No resources available to process task.");
        }

        // Dequeue the task
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head

        // Allocate a resource
        // We'll just take the first available resource ID for simplicity
        int resourceId = availableResources.remove(0); // remove from ArrayList

        // Simulate processing
        System.out.println("Processing " + taskToProcess + " using Resource " + resourceId + ".");

        // Add to completed tasks
        completedTasks.add(taskToProcess);
        // In a real system, the resource would be returned here after processing is done.
        // For this exam, we simulate allocation without return to keep it simpler.
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all tasks that have been completed.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Lists all resources that are currently available.
     */
    public void listAvailableResources() {
        System.out.println("--- Available Resources ---");
        if (availableResources.isEmpty()) {
            System.out.println("All resources are currently busy.");
        } else {
            System.out.println("Available Resources: " + availableResources);
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the main menu options.
     */
    private static void printMenu() {
        System.out.println("\nResource Allocation System Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. List Available Resources");
        System.out.println("6. Exit");
        System.out.print("Enter command: ");
    }

    /**
     * Main method to run the Resource Allocation System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ResourceAllocationSystem system = new ResourceAllocationSystem(3); // Initialize with 3 resources
        boolean running = true;

        // Class-wide try-catch block for handling potential exceptions during the main loop
        try {
            while (running) {
                printMenu();

                int command = -1;
                // Inner try-catch for reading command input specifically
                try {
                    command = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                // Switch statement for command processing
                switch (command) {
                    case 1: // Add Task
                        // Inner try-catch for Add Task input
                        try {
                            System.out.print("Enter Task ID: ");
                            int taskId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            System.out.print("Enter Task Description: ");
                            String taskDescription = scanner.nextLine();

                            Task newTask = new Task(taskId, taskDescription);
                            system.addTask(newTask);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for Task ID. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during task creation/addition
                            System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        // Try-catch for processing logic, using custom exceptions
                        try {
                            system.processNextTask();
                        } catch (NoPendingTasksException e) {
                            System.out.println(e.getMessage()); // Use System.out for informational messages
                        } catch (NoResourceAvailableException e) {
                            System.out.println(e.getMessage()); // Use System.out for informational messages
                        } catch (Exception e) {
                             // Catch any other unexpected errors during processing
                            System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
                        }
                        break;

                    case 3: // List Pending Tasks
                        system.listPendingTasks();
                        break;

                    case 4: // List Completed Tasks
                        system.listCompletedTasks();
                        break;

                    case 5: // List Available Resources
                        system.listAvailableResources();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting System.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid command. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // This catch block handles any unexpected exceptions that escape the inner blocks
            System.err.println("A critical error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
