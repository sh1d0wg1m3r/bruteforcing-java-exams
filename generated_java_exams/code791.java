/*
 * Exam Question #791
 * Generated on: 2025-05-12 16:41:16
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Processing System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple, console-based Task Processing System. This system should allow users to add tasks, view tasks waiting for processing, process the next task in line, and view tasks that have been completed. Each task has a description and a priority level (High, Medium, Low). The system should process tasks in a First-In, First-Out (FIFO) manner from the waiting queue, regardless of priority, but the priority should be recorded and displayed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String). Include a constructor and public getter methods. Override the `toString()` method for easy printing.
 * 2.  **System Core:** Create a `TaskProcessingSystem` class containing the main application logic.
 *     *   Maintain a collection of tasks waiting to be processed using a `Queue<Task>`.
 *     *   Maintain a collection of completed tasks using a `List<Task>` variable, instantiated as an `ArrayList<Task>`.
 *     *   Use a `Scanner` for all user input.
 * 3.  **Functionality:** Implement the following operations via a main menu:
 *     *   **Add Task:** Prompt the user for a task description and priority (High, Medium, or Low). Validate the priority input. Create a `Task` object and add it to the waiting queue.
 *     *   **Process Next Task:** Remove the next task from the waiting queue and add it to the completed tasks list. If the queue is empty, display an appropriate message using `System.err`.
 *     *   **View Task Queue:** Display all tasks currently in the waiting queue in their current order.
 *     *   **View Completed Tasks:** Display all tasks that have been processed.
 *     *   **Exit:** Terminate the application.
 * 4.  **Control Flow:** Use a `switch` statement to handle the main menu selections.
 * 5.  **Error Handling:**
 *     *   Implement input validation for menu choices (must be an integer) and task priority (must be "High", "Medium", or "Low", case-insensitive). Use `System.err` for invalid input messages.
 *     *   Use `try-catch` blocks for potential exceptions, such as handling non-integer input for menu selection or attempting to process a task when the queue is empty. A class-wide `try-catch` in the `main` method is recommended to catch unexpected errors, in addition to specific checks within methods.
 * 6.  **Output:**
 *     *   Use `System.out` for menu display, prompts, and displaying task lists.
 *     *   Use `System.err` exclusively for error messages (invalid input, queue empty errors, etc.).
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for classes/methods, inline comments for complex logic).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output Structure:**
 * 
 * The system should present a menu like this:
 * 
 * ```
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the user's choice, the system should perform the corresponding action, printing relevant information or error messages.
 * 
 * Example interaction (user input shown in bold):
 * 
 * ```
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **1**
 * Enter task description: **Implement login feature**
 * Enter priority (High, Medium, Low): **High**
 * Task added to queue.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **3**
 * --- Current Task Queue ---
 * [Description: Implement login feature, Priority: High]
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **2**
 * Processed task: [Description: Implement login feature, Priority: High]
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **4**
 * --- Completed Tasks ---
 * [Description: Implement login feature, Priority: High]
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **2**
 * Error: Task queue is empty. No task to process.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **6**
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **exit**
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: **5**
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should be a single Java file containing both classes.
 *
 * EXPLANATION:
 * This solution implements a console-based Task Processing System demonstrating the required Java concepts and best practices.
 * 
 * **Class Design:**
 * 
 * 1.  **`Task` Class:** A simple Plain Old Java Object (POJO) representing a task. It encapsulates the `description` and `priority` as private fields with public getter methods, adhering to encapsulation principles. The `toString()` method is overridden for convenient printing of task details.
 * 2.  **`TaskProcessingSystem` Class:** This is the main class containing the application logic. It holds the core data structures (`taskQueue` and `completedTasks`) and the `Scanner` for input.
 * 
 * **Data Structures:**
 * 
 * *   `Queue<Task> taskQueue`: A `Queue` is used to store tasks waiting to be processed. The `LinkedList` class is chosen as the concrete implementation because it implements the `Queue` interface and provides efficient FIFO operations (`offer` to add to the end, `poll` to remove from the front).
 * *   `List<Task> completedTasks`: A `List` is used to store tasks once they are processed. The variable is declared using the `List` interface type, and an `ArrayList` is used as the concrete implementation. This demonstrates coding to the interface (`List`) while using a specific implementation (`ArrayList`), a common best practice. `ArrayList` is suitable here as completed tasks are typically added to the end and iterated through.
 * 
 * **Required Component Usage:**
 * 
 * *   `Queue` (`java.util.Queue`): Used for `taskQueue` via `LinkedList`. `offer()` is used for adding tasks, and `poll()` is used for removing tasks in FIFO order.
 * *   `ArrayList` (`java.util.ArrayList`): Used as the concrete implementation for the `completedTasks` `List`.
 * *   `List interface` (`java.util.List`): The `completedTasks` variable is declared as `List<Task>`, demonstrating the use of the interface.
 * *   `Scanner` (`java.util.Scanner`): Used in the `TaskProcessingSystem` constructor and methods (`run`, `addTask`, `getPriorityInput`) to read user input from `System.in`. It is closed in the `finally` block to release system resources.
 * *   `Switch statement`: Used in the `run` method to handle the main menu selections, directing the program flow based on the user's integer input.
 * *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, invalid priority input, empty task description, or attempting to process a task from an empty queue.
 * *   `System.out`: Used for all normal output, including displaying the menu, prompts, confirmation messages, and listing the contents of the queue and completed tasks list.
 * *   Class-wide exception handling (`try-catch`): A broad `try-catch` block is placed around the main `while` loop in the `run` method to catch any unexpected runtime exceptions that might occur during the program's execution. Additionally, specific `try-catch` blocks (e.g., for `NumberFormatException` during menu input parsing) and checks (e.g., checking the result of `queue.poll()`) are used for anticipated issues.
 * 
 * **Input Validation and Error Handling:**
 * 
 * *   **Menu Input:** The code reads the entire line using `scanner.nextLine()` and then attempts to parse it as an integer using `Integer.parseInt()`. A `try-catch (NumberFormatException)` block handles cases where the input is not a valid integer, printing an error to `System.err`. An additional check handles valid integers that are outside the expected menu range (1-5).
 * *   **Task Description:** Checks if the entered description is empty after trimming whitespace. If so, an error is printed to `System.err`, and the task is not added.
 * *   **Task Priority:** The `getPriorityInput` helper method reads the priority input, converts it to lowercase, and uses a `switch` statement to validate it against "high", "medium", and "low". If the input is invalid, an error is printed to `System.err`, and the method returns `null`, preventing the task from being created and added.
 * *   **Processing Empty Queue:** The `processNextTask` method uses `taskQueue.poll()`. `poll()` returns `null` if the queue is empty, which is explicitly checked. If `null` is returned, an error message is printed to `System.err` instead of attempting to process a non-existent task, avoiding potential exceptions like `NoSuchElementException` that `remove()` would throw.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** `Task` fields are private with public getters. `TaskProcessingSystem` fields are private.
 * *   **Naming:** Variable and method names are descriptive (e.g., `taskQueue`, `completedTasks`, `processNextTask`, `viewCompletedTasks`).
 * *   **Comments:** Javadoc comments are included for classes and methods, explaining their purpose. Inline comments clarify specific logic points.
 * *   **Resource Management:** The `Scanner` is explicitly closed in a `finally` block within the `run` method to ensure it's always closed, even if exceptions occur.
 * *   **Readability:** Using `forEach` loops and method references (`System.out::println`) where appropriate makes the code concise and readable. Using `poll()` instead of `remove()` for queue processing makes the empty queue handling cleaner.
 * 
 * This solution effectively integrates all the required Java components into a functional, well-structured, and robust application, suitable for assessing advanced Java programming skills.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive comparison

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority; // "High", "Medium", "Low"

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority level ("High", "Medium", or "Low").
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The task priority.
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string formatted as "[Description: ..., Priority: ...]".
     */
    @Override
    public String toString() {
        return "[Description: " + description + ", Priority: " + priority + "]";
    }
}

/**
 * A system for managing and processing tasks using a queue.
 */
public class TaskProcessingSystem {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queue, completed tasks list, and scanner.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as an implementation of Queue
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     */
    public void run() {
        int choice = -1; // Initialize with a value that won't match any case

        // Use a try-catch block around the main loop for class-wide exception handling
        try {
            while (choice != 5) {
                displayMenu();
                String inputLine = scanner.nextLine(); // Read the whole line

                try {
                    choice = Integer.parseInt(inputLine); // Attempt to parse as integer
                    // Use switch statement for control flow
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewTaskQueue();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Processing System.");
                            break;
                        default:
                            // Handle invalid integer input outside the expected range
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Error: Invalid menu choice. Please enter a number.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prompts the user for task details and adds a new task to the queue.
     * Includes input validation for priority.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read description

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if description is empty
        }

        String priority = getPriorityInput(); // Get and validate priority

        if (priority != null) { // getPriorityInput returns null on invalid input
            Task newTask = new Task(description, priority);
            taskQueue.offer(newTask); // Use offer() which is safe and returns boolean
            System.out.println("Task added to queue.");
        }
        // Error message for invalid priority is handled within getPriorityInput()
    }

    /**
     * Helper method to get and validate priority input from the user.
     * @return Validated priority string ("High", "Medium", "Low") or null if input is invalid.
     */
    private String getPriorityInput() {
        System.out.print("Enter priority (High, Medium, Low): ");
        String priorityInput = scanner.nextLine().trim();

        // Validate priority input (case-insensitive)
        switch (priorityInput.toLowerCase(Locale.US)) { // Use Locale.US for case conversion
            case "high":
                return "High";
            case "medium":
                return "Medium";
            case "low":
                return "Low";
            default:
                System.err.println("Error: Invalid priority. Please enter High, Medium, or Low.");
                return null; // Indicate invalid input
        }
    }

    /**
     * Processes the next task in the queue (FIFO).
     * Removes the task from the queue and adds it to the completed list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        // Use poll() which returns null if the queue is empty
        Task nextTask = taskQueue.poll();

        if (nextTask != null) {
            completedTasks.add(nextTask); // Add to completed list
            System.out.println("Processed task: " + nextTask);
        } else {
            // Use System.err for error message when queue is empty
            System.err.println("Error: Task queue is empty. No task to process.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    private void viewTaskQueue() {
        System.out.println("--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println); // Using lambda and method reference
            // Alternative using enhanced for loop:
            // for (Task task : taskQueue) {
            //     System.out.println(task);
            // }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list
            completedTasks.forEach(System.out::println); // Using lambda and method reference
            // Alternative using enhanced for loop:
            // for (Task task : completedTasks) {
            //     System.out.println(task);
            // }
        }
    }

    /**
     * Main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
