/*
 * Exam Question #939
 * Generated on: 2025-05-12 17:02:37
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Workflow Simulation System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple Workflow Simulation System in Java. This system will manage a queue of pending tasks and maintain a history of processed tasks. Users will interact with the system via a command-line interface to add tasks, process the next available task, view the current queue, and view the history of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are waiting to be processed.
 *     *   Use a `java.util.ArrayList` (referenced by the `java.util.List` interface) to store tasks that have been successfully processed.
 * 2.  **Task Representation:** Create a `Task` class with appropriate fields (e.g., `description`, `status`) and methods (e.g., constructor, getters, `toString`).
 * 3.  **System Core:** Create a `WorkflowProcessor` class that encapsulates the task queue and processed task list. This class should have methods for:
 *     *   Adding a new task to the queue.
 *     *   Processing the next task from the queue (removing it from the queue and adding it to the processed list).
 *     *   Retrieving the list of pending tasks.
 *     *   Retrieving the list of processed tasks.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands and task details from the standard input.
 *     *   Implement a command loop that presents options to the user.
 *     *   Use a `switch` statement to handle different user commands (e.g., "add", "process", "view_pending", "view_processed", "exit").
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, attempting to process an empty queue, invalid input for task details).
 * 6.  **Error Handling:**
 *     *   Implement input validation for user commands and task details.
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `WorkflowProcessor` class methods or the main application loop to handle potential issues (e.g., attempting to process when the queue is empty, unexpected errors during input).
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods) in the `Task` and `WorkflowProcessor` classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Structure the code into logical classes.
 * 
 * **Commands:**
 * 
 * *   `add <description>`: Adds a new task with the given description to the pending queue.
 * *   `process`: Processes the next task from the pending queue and moves it to the processed list.
 * *   `view_pending`: Displays all tasks currently in the pending queue.
 * *   `view_processed`: Displays all tasks that have been processed.
 * *   `exit`: Terminates the application.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Workflow Simulation System ---
 * Commands: add <description>, process, view_pending, view_processed, exit
 * Enter command: add Task 1: Write report
 * Task added: Task 1: Write report
 * Enter command: add Task 2: Review code
 * Task added: Task 2: Review code
 * Enter command: view_pending
 * Pending Tasks:
 * [1] Task 1: Write report
 * [2] Task 2: Review code
 * Enter command: process
 * Processing task: Task 1: Write report
 * Enter command: process
 * Processing task: Task 2: Review code
 * Enter command: process
 * Error: No tasks in the pending queue to process.
 * Enter command: view_processed
 * Processed Tasks:
 * [1] Task 1: Write report
 * [2] Task 2: Review code
 * Enter command: view_pending
 * Pending Tasks:
 * Queue is empty.
 * Enter command: invalid_command
 * Error: Unknown command 'invalid_command'.
 * Enter command: add
 * Error: Task description cannot be empty. Usage: add <description>
 * Enter command: exit
 * Exiting Workflow Simulation System.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`.
 * *   Proper implementation of the `Task` and `WorkflowProcessor` classes.
 * *   Accurate handling of user commands and workflow logic.
 * *   Robust error handling and input validation.
 * *   Adherence to Java best practices (encapsulation, naming, comments, structure).
 *
 * EXPLANATION:
 * The solution implements a simple Workflow Simulation System as requested, demonstrating the use of the required Java components and adhering to best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** Represents the data model for a single task. It uses `private` fields (`id`, `description`, `status`) and public getter methods, enforcing encapsulation. It also includes basic validation in the constructor to ensure a description is provided and uses a static `AtomicInteger` for simple unique ID generation. The `toString()` method provides a convenient string representation for display.
 * 2.  **`WorkflowProcessor` Class:** This is the core class managing the workflow state.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to store tasks waiting processing. `LinkedList` is a common choice for implementing `Queue`. The `offer()` method is used for adding, and `poll()` for removing from the head, which are standard Queue operations.
 *     *   It uses a `java.util.List<Task>` (`processedTasks`) implemented by `java.util.ArrayList` to store completed tasks. `ArrayList` is suitable here as we primarily add to the end and iterate through the list.
 *     *   Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewProcessedTasks` encapsulate the logic for manipulating these data structures.
 *     *   **Class-wide Exception Handling:** The `addTask` and `processNextTask` methods include `try-catch` blocks. `addTask` catches `IllegalArgumentException` from the `Task` constructor and a general `Exception`. `processNextTask` uses an `if` check for `null` returned by `poll()` to handle the empty queue scenario gracefully with a `System.err` message, and also includes a general `try-catch` for other potential issues during processing. This demonstrates handling exceptions within the methods of the class.
 * 3.  **`WorkflowSimulationSystem` Class (Main Application):**
 *     *   Contains the `main` method, which serves as the entry point and the command-line interface handler.
 *     *   **`Scanner`:** A `java.util.Scanner` is used to read user input line by line from `System.in`.
 *     *   **Command Loop:** A `while(running)` loop continuously prompts the user for input until the "exit" command is entered.
 *     *   **`switch` Statement:** A `switch` statement is used to dispatch logic based on the first word of the user's input command. This effectively controls the flow of the application based on user actions.
 *     *   **Input Validation:** Basic validation is performed for the "add" command to ensure a description is provided.
 *     *   **Error Output (`System.err`):** `System.err.println()` is used specifically for printing error messages, such as unknown commands, missing task descriptions, or attempting to process an empty queue.
 *     *   **Normal Output (`System.out`):** `System.out.println()` is used for displaying the menu, prompts, success messages, and task lists.
 *     *   **General Exception Handling:** A `try-catch` block wraps the core logic inside the main loop's switch. This catches `IllegalArgumentException` that might be thrown by `addTask` and any other unexpected `Exception` that might occur during command processing, preventing the application from crashing and providing an error message.
 *     *   **Resource Management:** The `Scanner` is closed when the application exits to release system resources.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `WorkflowProcessor` are `private`, accessed via `public` methods.
 * *   **Meaningful Names:** Classes (`Task`, `WorkflowProcessor`), methods (`addTask`, `processNextTask`, `viewPendingTasks`), and variables (`pendingTasks`, `processedTasks`, `description`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 * *   **Clean Code Structure:** The code is organized into logical classes (`Task` for data, `WorkflowProcessor` for logic, `WorkflowSimulationSystem` for UI).
 * *   **Error Handling:** Includes specific checks (like `pendingTasks.poll() == null`) and general `try-catch` blocks for robustness.
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating an understanding of data structures, object-oriented programming, user input handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // To generate unique task IDs

/**
 * Represents a single task in the workflow system.
 */
class Task {
    private static final AtomicInteger idCounter = new AtomicInteger(0);
    private final int id;
    private final String description;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = idCounter.incrementAndGet();
        this.description = description.trim();
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[" + id + "] " + description;
    }
}

/**
 * Manages the queue of pending tasks and the list of processed tasks.
 */
class WorkflowProcessor {
    private Queue<Task> pendingTasks;
    private List<Task> processedTasks;

    /**
     * Constructs a new WorkflowProcessor.
     */
    public WorkflowProcessor() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.processedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description for the new task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            pendingTasks.offer(newTask); // offer is preferred over add for queues (returns false instead of throwing exception)
            System.out.println("Task added: " + newTask.getDescription());
        } catch (IllegalArgumentException e) {
            // Re-throw or handle specifically if needed, here we let the caller handle
            throw e;
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
            // Log the exception for debugging in a real application
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and adds it to the processed list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        try {
            Task taskToProcess = pendingTasks.poll(); // poll returns null if queue is empty
            if (taskToProcess != null) {
                taskToProcess.setStatus("Processed");
                processedTasks.add(taskToProcess);
                System.out.println("Processing task: " + taskToProcess.getDescription());
            } else {
                System.err.println("Error: No tasks in the pending queue to process.");
            }
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while processing task: " + e.getMessage());
             // Log the exception
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("Pending Tasks:");
        if (pendingTasks.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            pendingTasks.forEach(System.out::println);
        }
    }

    /**
     * Displays all tasks that have been processed.
     */
    public void viewProcessedTasks() {
        System.out.println("Processed Tasks:");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list
            processedTasks.forEach(System.out::println);
        }
    }
}

/**
 * Main application class for the Workflow Simulation System.
 * Handles user interaction and command processing.
 */
public class WorkflowSimulationSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        WorkflowProcessor processor = new WorkflowProcessor();
        boolean running = true;

        System.out.println("--- Workflow Simulation System ---");
        System.out.println("Commands: add <description>, process, view_pending, view_processed, exit");

        while (running) {
            System.out.print("Enter command: ");
            String commandLine = scanner.nextLine().trim();

            try {
                // Basic command parsing
                String[] parts = commandLine.split(" ", 2);
                String command = parts[0].toLowerCase();
                String argument = parts.length > 1 ? parts[1].trim() : "";

                switch (command) {
                    case "add":
                        if (argument.isEmpty()) {
                            System.err.println("Error: Task description cannot be empty. Usage: add <description>");
                        } else {
                            processor.addTask(argument);
                        }
                        break;
                    case "process":
                        processor.processNextTask();
                        break;
                    case "view_pending":
                        processor.viewPendingTasks();
                        break;
                    case "view_processed":
                        processor.viewProcessedTasks();
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Workflow Simulation System.");
                        break;
                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            } catch (IllegalArgumentException e) {
                 // Catch specific exceptions from Task or WorkflowProcessor
                 System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a newline for readability
        }

        scanner.close(); // Close the scanner when exiting
    }
}
