/*
 * Exam Question #1156
 * Generated on: 2025-05-12 17:32:45
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment & Waiting List Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified console-based system for managing appointments and a waiting list at a small clinic. The system needs to handle patient registration, doctor registration, scheduling appointments, managing a waiting list for patients who cannot be scheduled immediately, cancelling appointments, and viewing various lists.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of registered patients.
 *     *   Maintain a list of registered doctors.
 *     *   Maintain a list of scheduled appointments.
 *     *   Maintain a waiting list of patients who are waiting for an appointment slot.
 * 
 * 2.  **Functionality (Menu-Driven):** The program should present a menu of options to the user:
 *     *   Add New Patient
 *     *   Add New Doctor
 *     *   Schedule Appointment:
 *         *   Prompt for patient ID and doctor ID.
 *         *   Attempt to schedule the appointment.
 *         *   **Crucially:** If the selected doctor is currently "busy" (for this simplified model, a doctor is "busy" if they have any scheduled appointment), the patient should be added to the waiting list instead of scheduling the appointment directly.
 *         *   If the doctor is available, schedule the appointment and remove the patient from the waiting list if they were on it.
 *     *   Process Waiting List:
 *         *   Attempt to schedule the next patient from the waiting list with an available doctor (you can simplify this by just attempting with a specific doctor or the first available one).
 *         *   Remove the patient from the waiting list if successfully scheduled.
 *     *   Cancel Appointment:
 *         *   Prompt for an appointment ID.
 *         *   Remove the appointment from the scheduled list.
 *     *   View All Patients
 *     *   View All Doctors
 *     *   View All Scheduled Appointments
 *     *   View Waiting List
 *     *   Exit
 * 
 * 3.  **Java Components:** Your solution *must* utilize all of the following Java components:
 *     *   `java.util.Queue` (for the waiting list)
 *     *   `java.util.ArrayList` (for storing patients, doctors, appointments)
 *     *   `java.util.List` interface (use `List` for declaring your collection variables, e.g., `List<Patient> patients;`)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling the main menu options)
 *     *   `System.err` (for printing error messages, e.g., invalid input, patient/doctor not found, scheduling errors)
 *     *   `System.out` (for printing normal output, e.g., menu, lists, success messages)
 *     *   Class-wide exception handling with `try-catch` blocks (wrap the main program loop or critical sections to catch unexpected errors gracefully).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation for your data classes (Patient, Doctor, Appointment).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments or Javadoc where necessary to explain complex logic.
 *     *   Perform basic input validation (e.g., check if IDs exist before scheduling/cancelling).
 *     *   Handle errors gracefully using `System.err` and `try-catch`.
 *     *   Structure your code cleanly (e.g., separate classes for data entities, a main class for the system logic).
 * 
 * **Data Classes (Suggested Structure):**
 * 
 * *   `Patient` class: `id` (int), `name` (String)
 * *   `Doctor` class: `id` (int), `name` (String), `specialty` (String)
 * *   `Appointment` class: `id` (int), `patient` (Patient object), `doctor` (Doctor object), `status` (String - e.g., "Scheduled")
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, prompting for input based on the selected option, and printing results or error messages to the console (`System.out` or `System.err`).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Hospital Management Menu ---
 * 1. Add Patient
 * 2. Add Doctor
 * 3. Schedule Appointment
 * 4. Process Waiting List
 * 5. Cancel Appointment
 * 6. View Patients
 * 7. View Doctors
 * 8. View Scheduled Appointments
 * 9. View Waiting List
 * 0. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Patient added with ID: 1
 * 
 * Enter your choice: 2
 * Enter doctor name: Dr. Smith
 * Enter doctor specialty: Cardiology
 * Doctor added with ID: 101
 * 
 * Enter your choice: 3
 * Enter patient ID: 1
 * Enter doctor ID: 101
 * Appointment scheduled successfully with ID: 1001
 * 
 * Enter your choice: 3
 * Enter patient ID: 1
 * Enter doctor ID: 101
 * Doctor is busy. Patient added to waiting list.
 * 
 * Enter your choice: 9
 * Waiting List:
 * Patient ID: 1, Name: Alice
 * 
 * Enter your choice: 4
 * Attempting to schedule patient from waiting list...
 * No available doctor found for patient ID 1. Patient remains on waiting list.
 * 
 * Enter your choice: 5
 * Enter appointment ID to cancel: 1001
 * Appointment 1001 cancelled successfully.
 * 
 * Enter your choice: 4
 * Attempting to schedule patient from waiting list...
 * Patient ID 1 scheduled successfully with Doctor ID 101. Appointment ID: 1002
 * Waiting list is now empty.
 * 
 * Enter your choice: 0
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correctness and completeness of the implementation based on the requirements.
 * *   Proper usage of all required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Clear and logical code structure.
 *
 * EXPLANATION:
 * This solution implements a simplified Hospital Appointment and Waiting List Management system as described in the exam question. It demonstrates the practical application of various core and advanced Java concepts.
 * 
 * **Code Structure:**
 * 
 * The solution is organized into four classes:
 * 1.  `Patient`, `Doctor`, and `Appointment`: These are simple Plain Old Java Objects (POJOs) representing the data entities in the system. They use private fields and public getter methods, demonstrating **encapsulation**. Static counters are used to generate unique IDs.
 * 2.  `HospitalSystem`: This is the main class that contains the system logic, data structures, and the main application loop.
 * 
 * **Required Java Components Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `waitingList` is declared as a `Queue<Patient>` and instantiated with `java.util.LinkedList`. This correctly uses the `Queue` interface to manage patients waiting for an appointment in a First-In, First-Out (FIFO) manner. `offer()` is used to add patients to the end of the queue, and `poll()` is used to remove patients from the front when processing the waiting list. `peek()` is used to view the next patient without removing them.
 * 2.  **`java.util.ArrayList`**: The collections `patients`, `doctors`, and `appointments` are instantiated using `new ArrayList<>()`. `ArrayList` is suitable here because we need dynamic lists where we can add, remove (conceptually, though appointments are marked cancelled), and iterate through elements efficiently.
 * 3.  **`java.util.List` interface**: The collection variables (`patients`, `doctors`, `appointments`) are declared using the `List` interface (`private List<Patient> patients;`). This promotes good practice by programming to the interface rather than the concrete implementation (`ArrayList`), allowing for easier changes to the underlying list type if needed in the future.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used to read user input from `System.in` for menu choices and data entry (patient name, doctor details, IDs). A helper method `readIntInput()` is included to handle basic non-integer input errors specifically for reading numbers.
 * 5.  **`switch` statement**: The `run()` method uses a `switch` statement to direct the program flow based on the user's menu choice, executing the corresponding method for each option.
 * 6.  **`System.err`**: `System.err.println()` is used to print error messages, such as when a patient or doctor ID is not found, when input is invalid, or when a requested action cannot be performed (e.g., cancelling a non-existent appointment). This distinguishes error output from normal program output.
 * 7.  **`System.out`**: `System.out.println()` is used for all normal program output, including displaying the menu, prompts for input, success messages (e.g., "Patient added"), and listing the contents of the collections.
 * 8.  **Class-wide exception handling with `try-catch`**: A large `try-catch` block is wrapped around the main `do-while` loop in the `run()` method. This provides a form of class-wide exception handling, catching any unexpected `Exception` that might occur during the execution of the menu-driven operations and preventing the program from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Functionality and Logic:**
 * 
 * *   **Adding Entities:** `addPatient()` and `addDoctor()` create new objects, assign unique IDs using static counters, and add them to their respective `ArrayLists`.
 * *   **Scheduling:** `scheduleAppointment()` finds the specified patient and doctor. It then checks if the doctor is "busy" by iterating through the `appointments` list and checking if any scheduled appointment is linked to that doctor. If busy, the patient is added to the `waitingList` (Queue) using `offer()`. If not busy, a new `Appointment` is created and added to the `appointments` list (ArrayList). It also checks if the patient was on the waiting list and removes them using `remove()` if they were.
 * *   **Processing Waiting List:** `processWaitingList()` checks if the `waitingList` (Queue) is empty. If not, it peeks at the next patient using `peek()`. It then searches for an available doctor (one with no currently scheduled appointments). If a doctor is found, the patient is removed from the queue using `poll()`, and a new appointment is scheduled and added to the `appointments` list.
 * *   **Cancelling:** `cancelAppointment()` finds the appointment by ID. Instead of removing from the `ArrayList` (which can be complex with indices and iteration), it simply changes the `status` field of the `Appointment` object to "Cancelled", demonstrating a common pattern in state management.
 * *   **Viewing Lists:** The `view*()` methods iterate through the respective `List` or `Queue` and print the details of each object. Iterating directly over the `Queue` (e.g., `for (Patient p : waitingList)`) allows viewing its contents without removing elements.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Private fields and public getters/setters (where needed, like `setStatus`) are used in the data classes.
 * *   **Meaningful Names:** Variable names (e.g., `waitingList`, `availableDoctor`), method names (e.g., `scheduleAppointment`, `processWaitingList`), and class names are descriptive.
 * *   **Comments/Documentation:** Basic comments explain the purpose of methods or key logic sections.
 * *   **Input Validation:** The `readIntInput()` method handles non-integer input, and methods like `scheduleAppointment` and `cancelAppointment` check if the provided IDs correspond to existing entities before proceeding. Error messages are printed to `System.err`.
 * *   **Error Handling:** The `try-catch` block in `run()` catches unexpected errors, and specific error conditions (like entity not found) are handled with `System.err` messages.
 * *   **Clean Code Structure:** The separation into data classes and a system logic class, along with dedicated methods for each menu option, results in a well-organized and readable structure.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user input handling, and error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration

// Data class for Patient
class Patient {
    private int id;
    private String name;
    private static int nextId = 1;

    public Patient(String name) {
        this.id = nextId++;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient ID: " + id + ", Name: " + name;
    }
}

// Data class for Doctor
class Doctor {
    private int id;
    private String name;
    private String specialty;
    private static int nextId = 101; // Start Doctor IDs from a different range

    public Doctor(String name, String specialty) {
        this.id = nextId++;
        this.name = name;
        this.specialty = specialty;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSpecialty() {
        return specialty;
    }

    @Override
    public String toString() {
        return "Doctor ID: " + id + ", Name: " + name + ", Specialty: " + specialty;
    }
}

// Data class for Appointment
class Appointment {
    private int id;
    private Patient patient;
    private Doctor doctor;
    private String status; // e.g., "Scheduled", "Cancelled"
    private static int nextId = 1001; // Start Appointment IDs from a different range

    public Appointment(Patient patient, Doctor doctor) {
        this.id = nextId++;
        this.patient = patient;
        this.doctor = doctor;
        this.status = "Scheduled";
    }

    public int getId() {
        return id;
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Appointment ID: " + id + ", Patient: " + patient.getName() + " (ID: " + patient.getId() + "), Doctor: " + doctor.getName() + " (ID: " + doctor.getId() + "), Status: " + status;
    }
}

// Main class for the Hospital Management System logic
public class HospitalSystem {

    // Use List interface, instantiate with ArrayList
    private List<Patient> patients;
    private List<Doctor> doctors;
    private List<Appointment> appointments;

    // Use Queue interface, instantiate with LinkedList
    private Queue<Patient> waitingList;

    private Scanner scanner;

    public HospitalSystem() {
        this.patients = new ArrayList<>();
        this.doctors = new ArrayList<>();
        this.appointments = new ArrayList<>();
        this.waitingList = new LinkedList<>(); // LinkedList implements Queue
        this.scanner = new Scanner(System.in);
    }

    // --- Helper Methods to Find Entities ---
    private Patient findPatientById(int id) {
        for (Patient p : patients) {
            if (p.getId() == id) {
                return p;
            }
        }
        return null; // Not found
    }

    private Doctor findDoctorById(int id) {
        for (Doctor d : doctors) {
            if (d.getId() == id) {
                return d;
            }
        }
        return null; // Not found
    }

    private Appointment findAppointmentById(int id) {
        for (Appointment a : appointments) {
            if (a.getId() == id) {
                return a;
            }
        }
        return null; // Not found
    }

    // --- Functionality Methods ---

    public void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        Patient newPatient = new Patient(name);
        patients.add(newPatient);
        System.out.println("Patient added with ID: " + newPatient.getId());
    }

    public void addDoctor() {
        System.out.print("Enter doctor name: ");
        String name = scanner.nextLine();
        System.out.print("Enter doctor specialty: ");
        String specialty = scanner.nextLine();
        Doctor newDoctor = new Doctor(name, specialty);
        doctors.add(newDoctor);
        System.out.println("Doctor added with ID: " + newDoctor.getId());
    }

    public void scheduleAppointment() {
        System.out.print("Enter patient ID: ");
        int patientId = readIntInput();
        System.out.print("Enter doctor ID: ");
        int doctorId = readIntInput();

        Patient patient = findPatientById(patientId);
        Doctor doctor = findDoctorById(doctorId);

        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return;
        }
        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        // Check if the doctor is busy (simplified: has any scheduled appointment)
        boolean isDoctorBusy = false;
        for (Appointment appt : appointments) {
            // Consider only currently scheduled appointments
            if (appt.getDoctor().getId() == doctorId && appt.getStatus().equals("Scheduled")) {
                isDoctorBusy = true;
                break;
            }
        }

        if (isDoctorBusy) {
            System.out.println("Doctor is busy. Patient added to waiting list.");
            // Check if patient is already on waiting list to avoid duplicates (optional but good practice)
            if (!waitingList.contains(patient)) {
                 waitingList.offer(patient); // Add to the end of the queue
            } else {
                 System.out.println("Patient is already on the waiting list.");
            }

        } else {
            Appointment newAppointment = new Appointment(patient, doctor);
            appointments.add(newAppointment);
            System.out.println("Appointment scheduled successfully with ID: " + newAppointment.getId());

            // If the patient was on the waiting list, remove them
            if (waitingList.contains(patient)) {
                waitingList.remove(patient); // Remove the specific patient object
                System.out.println("Patient removed from waiting list.");
            }
        }
    }

    public void processWaitingList() {
        System.out.println("Attempting to schedule patient from waiting list...");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
            return;
        }

        // Peek at the next patient without removing them yet
        Patient nextPatient = waitingList.peek();
        System.out.println("Next patient on waiting list: " + nextPatient.getName() + " (ID: " + nextPatient.getId() + ")");

        // Find an available doctor (simplified: just find the first doctor who isn't busy)
        Doctor availableDoctor = null;
        for (Doctor d : doctors) {
            boolean isBusy = false;
            for (Appointment appt : appointments) {
                if (appt.getDoctor().getId() == d.getId() && appt.getStatus().equals("Scheduled")) {
                    isBusy = true;
                    break;
                }
            }
            if (!isBusy) {
                availableDoctor = d;
                break; // Found an available doctor
            }
        }

        if (availableDoctor != null) {
            // Remove the patient from the waiting list now that we can schedule them
            Patient scheduledPatient = waitingList.poll(); // Remove from the front of the queue
            Appointment newAppointment = new Appointment(scheduledPatient, availableDoctor);
            appointments.add(newAppointment);
            System.out.println("Patient ID " + scheduledPatient.getId() + " scheduled successfully with Doctor ID " + availableDoctor.getId() + ". Appointment ID: " + newAppointment.getId());
        } else {
            System.out.println("No available doctor found for patient ID " + nextPatient.getId() + ". Patient remains on waiting list.");
        }
    }

    public void cancelAppointment() {
        System.out.print("Enter appointment ID to cancel: ");
        int appointmentId = readIntInput();

        Appointment appointmentToCancel = findAppointmentById(appointmentId);

        if (appointmentToCancel == null) {
            System.err.println("Error: Appointment with ID " + appointmentId + " not found.");
            return;
        }

        if (appointmentToCancel.getStatus().equals("Cancelled")) {
             System.out.println("Appointment " + appointmentId + " is already cancelled.");
             return;
        }

        // Simply mark as cancelled instead of removing from the list
        appointmentToCancel.setStatus("Cancelled");
        System.out.println("Appointment " + appointmentId + " cancelled successfully.");

        // Optional: Could add the patient back to the waiting list here if desired,
        // but the requirements don't explicitly state this.
    }

    public void viewPatients() {
        System.out.println("\n--- All Patients ---");
        if (patients.isEmpty()) {
            System.out.println("No patients registered.");
        } else {
            for (Patient p : patients) {
                System.out.println(p);
            }
        }
        System.out.println("--------------------\n");
    }

    public void viewDoctors() {
        System.out.println("\n--- All Doctors ---");
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered.");
        } else {
            for (Doctor d : doctors) {
                System.out.println(d);
            }
        }
        System.out.println("-------------------\n");
    }

    public void viewAppointments() {
        System.out.println("\n--- Scheduled Appointments ---");
        if (appointments.isEmpty()) {
            System.out.println("No appointments scheduled.");
        } else {
            for (Appointment a : appointments) {
                System.out.println(a);
            }
        }
        System.out.println("----------------------------\n");
    }

    public void viewWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Patient p : waitingList) {
                System.out.println(p);
            }
        }
        System.out.println("--------------------\n");
    }

    // Helper method for reading integer input with basic error handling
    private int readIntInput() {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            System.out.print("Enter value: "); // Re-prompt
        }
        int input = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return input;
    }

    // Main method to run the system
    public void run() {
        int choice;
        // Class-wide exception handling around the main loop
        try {
            do {
                printMenu();
                System.out.print("Enter your choice: ");
                choice = readIntInput();

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        addPatient();
                        break;
                    case 2:
                        addDoctor();
                        break;
                    case 3:
                        scheduleAppointment();
                        break;
                    case 4:
                        processWaitingList();
                        break;
                    case 5:
                        cancelAppointment();
                        break;
                    case 6:
                        viewPatients();
                        break;
                    case 7:
                        viewDoctors();
                        break;
                    case 8:
                        viewAppointments();
                        break;
                    case 9:
                        viewWaitingList();
                        break;
                    case 0:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please try again.");
                }
            } while (choice != 0);
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    private void printMenu() {
        System.out.println("--- Hospital Management Menu ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Add Doctor");
        System.out.println("3. Schedule Appointment");
        System.out.println("4. Process Waiting List");
        System.out.println("5. Cancel Appointment");
        System.out.println("6. View Patients");
        System.out.println("7. View Doctors");
        System.out.println("8. View Scheduled Appointments");
        System.out.println("9. View Waiting List");
        System.out.println("0. Exit");
        System.out.println("------------------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.run();
    }
}
