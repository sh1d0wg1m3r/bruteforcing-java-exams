/*
 * Exam Question #261
 * Generated on: 2025-05-11 22:46:21
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple simulation of a system that manages and processes tasks. The system should allow users to add tasks to a queue, process the next task in the queue, view pending tasks, view completed tasks, and clear the pending task queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are waiting to be processed. Choose an appropriate implementation (e.g., `LinkedList`).
 *     *   Use a `java.util.ArrayList` declared using the `java.util.List` interface to store tasks that have been processed.
 * 
 * 2.  **Task Representation:**
 *     *   Create a `Task` class with appropriate private fields (e.g., `taskId` (int), `description` (String), `taskType` (String), `status` (String)).
 *     *   Include a constructor to initialize a task.
 *     *   Include public getter methods for the fields.
 *     *   Override the `toString()` method to provide a clear string representation of a task.
 * 
 * 3.  **Task Processing System Class:**
 *     *   Create a class (e.g., `TaskProcessingSystem`) that encapsulates the `Queue` and the `List`.
 *     *   Implement the following public methods:
 *         *   `addTask(String taskType, String description)`: Adds a new task to the queue. Assign a unique ID (a simple counter is sufficient). Set the initial status to "Pending".
 *         *   `processNextTask()`: Removes the task at the front of the queue, changes its status to "Completed", and adds it to the processed tasks list. Should return the processed task or `null` if the queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` (or a copy of the queue's elements) of tasks currently in the queue. Do *not* remove tasks from the queue.
 *         *   `getProcessedTasks()`: Returns the `List` of processed tasks.
 *         *   `clearPendingQueue()`: Removes all tasks from the pending queue.
 *         *   Include private fields for the queue, processed list, and task ID counter.
 * 
 * 4.  **User Interface (Main Class):**
 *     *   Create a main class (e.g., `TaskSystemApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Task
 *         2.  Process Next Task
 *         3.  List Pending Tasks
 *         4.  List Processed Tasks
 *         5.  Clear Pending Queue
 *         6.  Exit
 *     *   Use a `switch` statement based on the user's menu choice (or command string) to control the program flow.
 *     *   Implement input validation:
 *         *   For the "Add Task" option, prompt for task type and description. Validate that the task type is one of the allowed types (e.g., "DATA_PROCESSING", "REPORT_GENERATION", "SYSTEM_CLEANUP"). If invalid, show an error.
 *         *   Handle cases where the user enters non-integer input for menu choices or invalid commands.
 *     *   Use `System.out` for normal output (menu, task details, success messages).
 *     *   Use `System.err` for error messages (invalid input, queue empty when processing).
 * 
 * 5.  **Exception Handling:**
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main program loop in the `main` method. This block should catch general `Exception` or specific exceptions like `NumberFormatException` for input parsing and print an error message using `System.err`.
 *     *   Handle specific conditions like trying to process a task when the queue is empty within the `processNextTask` method or the calling code, potentially returning `null` and printing an appropriate message.
 * 
 * 6.  **Best Practices:**
 *     *   Follow Java naming conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Add basic documentation comments (Javadoc) for classes and public methods.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Users enter commands or menu numbers. The system responds by performing the action, printing status, task details, or error messages. Example interaction might look like:
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Processed Tasks
 * 5. Clear Pending Queue
 * 6. Exit
 * Enter choice: 1
 * Enter task type (DATA_PROCESSING, REPORT_GENERATION, SYSTEM_CLEANUP): DATA_PROCESSING
 * Enter task description: Analyze monthly sales data
 * Task added: Task [ID=1, Type=DATA_PROCESSING, Description=Analyze monthly sales data, Status=Pending]
 * Enter choice: 1
 * Enter task type (DATA_PROCESSING, REPORT_GENERATION, SYSTEM_CLEANUP): REPORT_GENERATION
 * Enter task description: Generate quarterly financial report
 * Task added: Task [ID=2, Type=REPORT_GENERATION, Description=Generate quarterly financial report, Status=Pending]
 * Enter choice: 3
 * Pending Tasks:
 * Task [ID=1, Type=DATA_PROCESSING, Description=Analyze monthly sales data, Status=Pending]
 * Task [ID=2, Type=REPORT_GENERATION, Description=Generate quarterly financial report, Status=Pending]
 * Enter choice: 2
 * Processing task: Task [ID=1, Type=DATA_PROCESSING, Description=Analyze monthly sales data, Status=Pending]
 * Task completed: Task [ID=1, Type=DATA_PROCESSING, Description=Analyze monthly sales data, Status=Completed]
 * Enter choice: 3
 * Pending Tasks:
 * Task [ID=2, Type=REPORT_GENERATION, Description=Generate quarterly financial report, Status=Pending]
 * Enter choice: 4
 * Processed Tasks:
 * Task [ID=1, Type=DATA_PROCESSING, Description=Analyze monthly sales data, Status=Completed]
 * Enter choice: 5
 * Pending queue cleared.
 * Enter choice: 3
 * Pending Tasks:
 * (Queue is empty)
 * Enter choice: 6
 * Exiting Task Processing System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `Task Processing System` simulating task management using core Java collections and control structures.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, `taskType`, and `status`.
 *     *   Fields are `private` ensuring encapsulation.
 *     *   Public getter methods (`getTaskId`, `getDescription`, `getTaskType`, `getStatus`) provide read access.
 *     *   A `setStatus` method allows controlled modification of the task's status.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   Manages the system's state using two private fields:
 *         *   `taskQueue`: A `java.util.Queue` (implemented as `LinkedList`) to hold tasks waiting to be processed. The `Queue` interface's `offer()` and `poll()` methods are used for adding and removing tasks from the front, respectively.
 *         *   `processedTasksHistory`: A `java.util.List` (implemented as `ArrayList`) to store tasks after they have been processed. `ArrayList` is suitable here for storing a history of completed items.
 *     *   `taskIdCounter`: A private integer to generate unique IDs for new tasks.
 *     *   `VALID_TASK_TYPES`: A private `List` used for validating task types entered by the user.
 *     *   **`addTask(String taskType, String description)`:** Validates the task type, increments the ID counter, creates a new `Task` object with "Pending" status, and adds it to the `taskQueue` using `offer()`. Returns `null` if the type is invalid, printing an error to `System.err`.
 *     *   **`processNextTask()`:** Uses `taskQueue.poll()` to get and remove the next task. If a task is retrieved (`poll()` returns non-null), its status is updated to "Completed", and it's added to the `processedTasksHistory` list. It prints messages to `System.out` indicating processing and completion, or informs the user if the queue is empty.
 *     *   **`getPendingTasks()`:** Returns a *new* `ArrayList` populated with the current elements of the `taskQueue`. This is a good practice to avoid exposing the internal queue object directly, preventing external code from modifying the queue unexpectedly. It demonstrates retrieving elements from the queue without removing them.
 *     *   **`getProcessedTasks()`:** Returns the `processedTasksHistory` `List`.
 *     *   **`clearPendingQueue()`:** Uses `taskQueue.clear()` to remove all elements from the pending queue.
 * 
 * 3.  **`TaskSystemApp` Class (Main Application):**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   A `java.util.Scanner` is used to read input from `System.in`.
 *     *   The `TaskProcessingSystem` object is instantiated.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the entire `while` loop. This demonstrates catching unexpected runtime errors that might occur anywhere within the main execution flow. Error messages and stack traces are printed to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   Inside the loop, the menu is printed using `System.out`.
 *     *   User input is read using `scanner.nextLine()` to handle potential non-numeric input gracefully.
 *     *   A nested `try-catch(NumberFormatException)` is used specifically for parsing the menu choice string into an integer. Invalid number format is caught, an error message is printed to `System.err`, and the loop continues.
 *     *   A `switch` statement is used to direct the program flow based on the user's valid integer choice. This demonstrates using `switch` for menu-driven control.
 *     *   Each case in the `switch` calls the appropriate method on the `TaskProcessingSystem` object.
 *     *   Input validation for task types is performed within the `addTask` method, and the result is checked in the `main` method.
 *     *   Output messages for successful operations, task details, and empty lists are printed to `System.out`.
 * 
 * This solution effectively combines `Queue` for managing a processing pipeline, `List` for maintaining a history, `Scanner` for user interaction, `switch` for command dispatch, `System.out` and `System.err` for differentiated output, and `try-catch` for robust error handling, all within a well-structured, encapsulated object-oriented design.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // To easily check valid task types

/**
 * Represents a single task in the system.
 */
class Task {
    private final int taskId;
    private final String description;
    private final String taskType;
    private String status; // Status can change

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param taskType The type of the task (e.g., DATA_PROCESSING).
     * @param description A brief description of the task.
     * @param status The initial status of the task.
     */
    public Task(int taskId, String taskType, String description, String status) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.description = description;
        this.status = status;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getTaskType() {
        return taskType;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (controlled mutability) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Type=" + taskType + ", Description=" + description + ", Status=" + status + "]";
    }
}

/**
 * Manages the queue of pending tasks and a list of processed tasks.
 */
class TaskProcessingSystem {
    private Queue<Task> taskQueue;
    private List<Task> processedTasksHistory;
    private int taskIdCounter; // Counter for unique task IDs
    private final List<String> VALID_TASK_TYPES = Arrays.asList("DATA_PROCESSING", "REPORT_GENERATION", "SYSTEM_CLEANUP");

    /**
     * Constructs a new TaskProcessingSystem.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedTasksHistory = new ArrayList<>(); // ArrayList for history
        this.taskIdCounter = 0; // Start ID counter
    }

    /**
     * Adds a new task to the pending queue.
     * @param taskType The type of the task.
     * @param description The description of the task.
     * @return The added Task object, or null if task type is invalid.
     */
    public Task addTask(String taskType, String description) {
        if (!VALID_TASK_TYPES.contains(taskType.toUpperCase())) {
            System.err.println("Error: Invalid task type '" + taskType + "'. Valid types are: " + VALID_TASK_TYPES);
            return null;
        }
        taskIdCounter++; // Increment counter for next task
        Task newTask = new Task(taskIdCounter, taskType.toUpperCase(), description, "Pending");
        taskQueue.offer(newTask); // offer is preferred over add for capacity-constrained queues, though LinkedList is not capacity-constrained
        return newTask;
    }

    /**
     * Processes the next task from the queue.
     * @return The completed Task object, or null if the queue is empty.
     */
    public Task processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll retrieves and removes the head of the queue, returns null if empty
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed"); // Change status
            processedTasksHistory.add(taskToProcess); // Add to history list
            return taskToProcess;
        } else {
            System.out.println("No tasks in the queue to process.");
            return null;
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This avoids exposing the internal queue structure directly and allows iteration
        // without modifying the original queue.
        return new ArrayList<>(taskQueue);
    }

    /**
     * Returns the list of tasks that have been processed.
     * @return A List of processed tasks.
     */
    public List<Task> getProcessedTasks() {
        // Returning the direct list reference is acceptable here as it's a history/report
        // If we wanted to prevent external modification, we'd return Collections.unmodifiableList(processedTasksHistory);
        return processedTasksHistory;
    }

    /**
     * Clears all tasks from the pending queue.
     */
    public void clearPendingQueue() {
        taskQueue.clear();
        System.out.println("Pending queue cleared.");
    }
}

/**
 * Main application class for the Task Processing System.
 * Handles user interaction and coordinates with the TaskProcessingSystem.
 */
public class TaskSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        // Class-wide exception handling wrapping the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");
                String choiceStr = scanner.nextLine(); // Read choice as string to handle non-numeric input easily

                // Use a switch statement based on parsed integer or command string
                // Let's parse to int for the switch for simplicity based on menu numbers
                int choice = -1; // Default invalid choice
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number from the menu.");
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task type (DATA_PROCESSING, REPORT_GENERATION, SYSTEM_CLEANUP): ");
                        String type = scanner.nextLine().trim();
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        Task addedTask = system.addTask(type, description);
                        if (addedTask != null) {
                            System.out.println("Task added: " + addedTask);
                        }
                        break;

                    case 2: // Process Next Task
                        Task processedTask = system.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Task completed: " + processedTask);
                        }
                        // Message for empty queue is handled inside processNextTask
                        break;

                    case 3: // List Pending Tasks
                        List<Task> pending = system.getPendingTasks();
                        System.out.println("Pending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("(Queue is empty)");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // List Processed Tasks
                        List<Task> processed = system.getProcessedTasks();
                        System.out.println("Processed Tasks:");
                        if (processed.isEmpty()) {
                            System.out.println("(No tasks processed yet)");
                        } else {
                            for (Task task : processed) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 5: // Clear Pending Queue
                        system.clearPendingQueue();
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Processed Tasks");
        System.out.println("5. Clear Pending Queue");
        System.out.println("6. Exit");
    }
}
