/*
 * Exam Question #579
 * Generated on: 2025-05-12 16:09:52
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Team Task Management System
 * 
 * **Problem Description:**
 * 
 * Develop a command-line based Task Management System designed for a small team. This system will allow users to manage tasks by adding new tasks, processing the next task waiting, and viewing lists of tasks that are pending or already completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent individual tasks. Each task should have a `description` (String) and a `priority` (String, limited to "HIGH", "MEDIUM", or "LOW").
 * 2.  **Task Management:** Create a class `TaskManager` that encapsulates the logic for managing tasks.
 * 3.  **Pending Tasks:** The `TaskManager` must use a `java.util.Queue` to store tasks that are currently pending. Tasks should be processed in a First-In, First-Out (FIFO) manner from this queue. You should instantiate the `Queue` using `java.util.LinkedList`.
 * 4.  **Completed Tasks:** The `TaskManager` must use a `java.util.List` to store tasks that have been processed. You should instantiate the `List` using `java.util.ArrayList`.
 * 5.  **User Interaction:** Implement a command-line interface using `java.util.Scanner` to interact with the user.
 * 6.  **Command Handling:** Use a `switch` statement within the main application loop to handle user selections from a menu of operations.
 * 7.  **Output Streams:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, attempting an operation on an empty collection).
 * 8.  **Exception Handling:** Implement class-wide exception handling by wrapping the main application loop within a `try-catch` block to catch and report unexpected runtime exceptions to `System.err`. Additionally, handle specific operational errors gracefully (like processing an empty queue).
 * 9.  **Best Practices:**
 *     *   Employ proper encapsulation by using `private` fields and `public` methods where appropriate.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain key parts of the code.
 *     *   Validate user input (e.g., ensuring priority is one of the allowed values, description is not empty).
 *     *   Handle potential errors gracefully (e.g., processing an empty queue).
 * 
 * **Commands:**
 * 
 * The system should support the following commands via a numbered menu:
 * 1.  **Add Task:** Prompt the user for the task description and priority. Validate the input. If valid, add the task to the pending queue.
 * 2.  **Process Next Task:** Take the task at the front of the pending queue and move it to the completed tasks list. Report which task was processed or indicate if there are no pending tasks.
 * 3.  **View Pending Tasks:** List all tasks currently in the pending queue in their current order.
 * 4.  **View Completed Tasks:** List all tasks that have been processed and are in the completed list.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and print appropriate messages or task lists based on the user's choice. Error messages (invalid input, empty queue operations, unexpected errors) must be printed to `System.err`.
 * 
 * **Constraint:** Your solution must demonstrate the use of ALL specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a cohesive manner within the `TaskManager` application.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic class encapsulating task data (`description` and `priority`). It includes a constructor and getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to print task details.
 * 2.  **`TaskManager` Class:** This is the core class managing the task workflow.
 *     *   **Data Structures:** It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` for FIFO processing of tasks and a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store tasks after they are processed. This satisfies the requirement to use `Queue`, `List`, and `ArrayList`.
 *     *   **`Scanner`:** An instance of `Scanner` is used as a class member to read user input throughout the application's runtime.
 *     *   **`addTask()`:** Prompts the user for task details, performs input validation (checking for empty description and valid priority), and adds a valid `Task` object to the `pendingTasks` queue using the `offer()` method (a safe way to add to a queue). Error messages for invalid input are printed to `System.err`.
 *     *   **`processNextTask()`:** Retrieves and removes the next task from the `pendingTasks` queue using the `poll()` method. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling of this case, rather than `remove()` which would throw an exception. If a task is retrieved, it's added to the `completedTasks` list. An error message is printed to `System.err` if the queue is empty.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`:** These methods iterate through the respective collections (`Queue` and `List`) and print the tasks. They check if the collections are empty and print a message if they are. `viewPendingTasks` iterates the queue without removing elements.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`run()`:** This method contains the main application loop.
 *         *   It continuously displays the menu and reads the user's choice using `scanner.nextLine()`.
 *         *   A `switch` statement is used to direct the program flow based on the user's `choice` string. This fulfills the `switch` statement requirement.
 *         *   Valid choices trigger calls to the appropriate methods (`addTask`, `processNextTask`, etc.).
 *         *   An invalid choice results in an error message printed to `System.err`.
 *         *   The loop runs until the user chooses option '5', setting the `running` flag to `false`.
 *         *   **Exception Handling:** The entire `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This provides class-wide handling for any unexpected runtime exceptions that might occur during the execution of the application logic, printing an error message and the stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed when the `run` method exits, releasing the system resource. This satisfies the `try-catch` and `System.err` requirements for unexpected errors.
 *     *   **`main()`:** The entry point of the application, which creates a `TaskManager` instance and calls its `run()` method.
 * 
 * The solution effectively integrates all specified components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, while adhering to best practices like encapsulation, meaningful naming, and input validation/error handling. The use of `poll()` for queue processing and checking for `null` is a standard and safe practice for handling potentially empty queues.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task with description and priority.
class Task {
    private String description;
    private String priority; // Using String for simplicity based on Scanner input

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (e.g., HIGH, MEDIUM, LOW).
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the task description.
     * @return The description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The priority.
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string showing priority and description.
     */
    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

/**
 * Manages a collection of tasks, allowing adding, processing, and viewing.
 */
public class TaskManager {

    // Queue to hold tasks that are pending processing.
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed.
    private List<Task> completedTasks;
    // Scanner for reading user input from the console.
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing task collections and scanner.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task based on user input.
     * Validates description and priority.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        // Input validation: description cannot be empty
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method without adding task
        }

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priority = scanner.nextLine().trim().toUpperCase(); // Convert to uppercase for case-insensitivity

        // Input validation: priority must be one of the allowed values
        if (!priority.equals("HIGH") && !priority.equals("MEDIUM") && !priority.equals("LOW")) {
            System.err.println("Error: Invalid priority. Please use HIGH, MEDIUM, or LOW.");
            return; // Exit method without adding task
        }

        // Create and add the new task to the pending queue
        Task newTask = new Task(description, priority);
        if (pendingTasks.offer(newTask)) { // offer() is safer than add(), returns false on failure
            System.out.println("Task added successfully: " + newTask);
        } else {
            // This case is rare for LinkedList unless resources are exhausted
            System.err.println("Error: Failed to add task to the queue.");
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list. Handles empty queue case.
     */
    public void processNextTask() {
        System.out.println("\n--- Process Next Task ---");
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task nextTask = pendingTasks.poll();

        if (nextTask != null) {
            completedTasks.add(nextTask); // Add the processed task to the completed list
            System.out.println("Processed task: " + nextTask);
        } else {
            // Error handling for empty queue
            System.err.println("No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the completed list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and dispatching commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                String choice = scanner.nextLine().trim(); // Read choice as a string

                // Use a switch statement to handle different commands
                switch (choice) {
                    case "1":
                        addTask();
                        break;
                    case "2":
                        processNextTask();
                        break;
                    case "3":
                        viewPendingTasks();
                        break;
                    case "4":
                        viewCompletedTasks();
                        break;
                    case "5":
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the loop
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print the stack trace to stderr for debugging
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Management application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
