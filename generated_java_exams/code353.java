/*
 * Exam Question #353
 * Generated on: 2025-05-11 22:59:26
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam - Advanced Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple, console-based Task Management System. This system should allow users to add new tasks with different priority levels, view pending tasks, process the highest-priority pending task, and view completed tasks.
 * 
 * The system should prioritize tasks based on an integer priority level, where a *lower* integer value indicates a *higher* priority (e.g., 1 is High, 5 is Low). When processing tasks, the system must always select the pending task with the highest priority (lowest priority number). If multiple tasks have the same highest priority, the task that was added earliest (first in the queue among those with the same highest priority) should be processed first.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `taskId` (int), `description` (String), and `priority` (int). Include a constructor and public getter methods for these fields. Provide a meaningful `toString()` method.
 * 2.  **Task Processing Logic:** Create a `TaskProcessor` class.
 *     *   It must have two private fields: one representing pending tasks using the `java.util.Queue` interface and another representing completed tasks using the `java.util.List` interface. Use concrete implementations like `LinkedList` for the Queue and `ArrayList` for the List.
 *     *   Implement a public method `addTask(Task task)` that adds a task to the collection of pending tasks.
 *     *   Implement a public method `processNextTask()` that:
 *         *   Finds the pending task with the highest priority (lowest integer value).
 *         *   If multiple tasks have the same highest priority, selects the one added earliest to the queue.
 *         *   Removes the selected task from the pending tasks.
 *         *   Adds the removed task to the completed tasks.
 *         *   Returns the processed `Task` object, or `null` if there are no pending tasks.
 *     *   Implement public methods `getPendingTasks()` and `getCompletedTasks()` that return a `List` view of the respective task collections. (Hint: You might need to copy elements from the Queue to a List for `getPendingTasks()`).
 * 3.  **User Interface:** Implement a console-based interface in a main class (e.g., `TaskProcessorApp`).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  Process Next Task
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Prompt the user for necessary details (task ID, description, priority) when adding a task.
 *     *   Display appropriate messages for successful operations (e.g., "Task added," "Task processed").
 *     *   Display task details when viewing pending or completed tasks.
 * 4.  **Error Handling:**
 *     *   Implement robust input validation for menu choices and task details (e.g., ensure priority is an integer within a reasonable range, handle non-integer input).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly around input processing.
 *     *   Use `System.err.println()` to display error messages (e.g., invalid input, error during processing, trying to process when no tasks are pending).
 *     *   Use `System.out.println()` for all normal output (menu, prompts, task details, success messages).
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure clean code structure.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Description: Write report
 * Enter Priority (1=High, 5=Low): 2
 * Task added successfully!
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter Task ID: 102
 * Enter Description: Schedule meeting
 * Enter Priority (1=High, 5=Low): 1
 * Task added successfully!
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter Task ID: 103
 * Enter Description: Review code
 * Enter Priority (1=High, 5=Low): 2
 * Task added successfully!
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Pending Tasks:
 * Task ID: 101, Description: Write report, Priority: 2
 * Task ID: 102, Description: Schedule meeting, Priority: 1
 * Task ID: 103, Description: Review code, Priority: 2
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Processing task: Task ID: 102, Description: Schedule meeting, Priority: 1
 * Task processed successfully!
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Processing task: Task ID: 101, Description: Write report, Priority: 2
 * Task processed successfully!
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task ID: 102, Description: Schedule meeting, Priority: 1
 * Task ID: 101, Description: Write report, Priority: 2
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Error: No pending tasks to process.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number between 1 and 5.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation of all requirements.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Robustness of input validation and error handling.
 * *   Correct logic for prioritizing and processing tasks.
 * 
 * **Expected Output:**
 * 
 * The output should follow the example interaction, displaying the menu, prompts, task details, success messages, and error messages correctly using `System.out` and `System.err` as specified.
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`taskId`, `description`, `priority`), a constructor, and public getters, adhering to encapsulation. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskProcessor Class:**
 *     *   It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to store tasks waiting to be processed. The `Queue` interface provides methods like `add()`, `isEmpty()`, and allows iteration.
 *     *   It uses a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store tasks after they are processed. The `List` interface provides methods for adding and iterating elements.
 *     *   `addTask(Task task)`: Simply adds the provided `Task` object to the `pendingTasks` queue using `queue.add()`.
 *     *   `processNextTask()`: This is the core logic. It first checks if the queue is empty. If not, it iterates through the queue *once* to find the minimum priority value (highest priority). It then uses an `Iterator` to traverse the queue *again*. When it encounters the *first* task that matches the determined highest priority, it uses `iterator.remove()` to safely remove the element during iteration and breaks the loop. This removed task is then added to the `completedTasks` list. Using `iterator.remove()` is crucial when removing elements while iterating a collection.
 *     *   `getPendingTasks()`: Returns a *new* `ArrayList` populated with elements from the `pendingTasks` queue. This prevents external code from directly manipulating the internal queue structure, maintaining encapsulation.
 *     *   `getCompletedTasks()`: Returns the internal `completedTasks` `ArrayList`. Since tasks are only added to this list and not removed by the user interface, returning the direct reference is acceptable here.
 * 
 * 3.  **TaskProcessorApp Class:**
 *     *   Contains the `main` method, which is the application entry point.
 *     *   Uses a `Scanner` object (`scanner`) to read input from `System.in`. The scanner is managed as a static field and closed in a `finally` block to ensure resource cleanup.
 *     *   A `TaskProcessor` instance (`processor`) manages the tasks.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `try-catch` block around the `while` loop provides class-wide exception handling, catching any unexpected errors during the main execution flow. Specific `try-catch` blocks are also used within methods like `getUserChoice` and `addNewTask` for more targeted handling of expected issues like `NumberFormatException`.
 *     *   `printMenu()` displays the user options using `System.out`.
 *     *   `getUserChoice()` reads the user's input line, attempts to parse it as an integer using `Integer.parseInt()`, and handles `NumberFormatException` if the input is not a valid number, returning -1 to indicate an error.
 *     *   A `switch` statement processes the integer choice returned by `getUserChoice()`. Each case calls a corresponding method (`addNewTask`, `viewPendingTasks`, `processNextTask`, `viewCompletedTasks`) or sets the `running` flag to `false` for exiting. The `default` case handles invalid integer choices.
 *     *   `addNewTask()` prompts for task details, includes a loop for priority validation to ensure it's an integer within a specified range (1-10 in this case), handles `NumberFormatException` for priority input, and creates/adds a new `Task`. A simple `nextTaskId` counter ensures unique IDs.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()` retrieve the respective lists from the `TaskProcessor` and iterate through them, printing each task using its `toString()` method. They handle the case where the lists are empty.
 *     *   `processNextTask()` calls the `processor.processNextTask()` method and prints a success message if a task was processed or an error message using `System.err` if there were no pending tasks.
 * 
 * 4.  **Error Handling & Output:**
 *     *   `System.err.println()` is used specifically for error conditions: invalid menu input, invalid priority input, and attempting to process when no tasks are pending.
 *     *   `System.out.println()` is used for all normal output: menu, prompts, success messages, and displaying task details.
 *     *   `try-catch` blocks are used to gracefully handle `NumberFormatException` during input parsing and a general `Exception` in the main loop.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrates priority-based processing logic using queue iteration, and follows best practices for structure, encapsulation, and error handling, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator;

// Represents a task with an ID, description, and priority.
class Task {
    private int taskId;
    private String description;
    private int priority; // Lower number = Higher priority

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (lower is higher).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Priority: " + priority;
    }
}

// Manages pending and completed tasks, processing based on priority.
class TaskProcessor {
    // Queue to hold tasks waiting to be processed (FIFO order of submission among same priority)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been processed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessor, initializing task collections.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a task to the pending tasks queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasks.add(task);
        }
    }

    /**
     * Finds and processes the pending task with the highest priority (lowest priority number).
     * If multiple tasks have the same highest priority, the one added earliest is processed.
     * @return The processed Task, or null if no pending tasks exist.
     */
    public Task processNextTask() {
        if (pendingTasks.isEmpty()) {
            return null; // No tasks to process
        }

        // Find the highest priority (lowest priority number) among pending tasks
        int highestPriority = Integer.MAX_VALUE;
        for (Task task : pendingTasks) {
            if (task.getPriority() < highestPriority) {
                highestPriority = task.getPriority();
            }
        }

        // Find the first task in the queue with the highest priority
        Task taskToProcess = null;
        Iterator<Task> iterator = pendingTasks.iterator();
        while (iterator.hasNext()) {
            Task currentTask = iterator.next();
            if (currentTask.getPriority() == highestPriority) {
                taskToProcess = currentTask;
                iterator.remove(); // Remove the task using the iterator
                break; // Found and removed the first highest-priority task
            }
        }

        // Add the processed task to the completed list
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
        }

        return taskToProcess;
    }

    /**
     * Returns a list of all pending tasks.
     * Note: Creates a new list to avoid exposing the internal queue directly.
     * @return A List containing all pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     * @return A List containing all completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return the list directly as it's already a List and completed tasks aren't removed
        return completedTasks;
    }
}

// Main application class for the Task Management System.
public class TaskProcessorApp {

    private static Scanner scanner = new Scanner(System.in);
    private static TaskProcessor processor = new TaskProcessor();
    private static int nextTaskId = 1; // Simple counter for unique task IDs

    public static void main(String[] args) {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Switch statement for flow control based on user input
                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Use System.err for invalid input messages
                        System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's integer menu choice.
     * Handles non-integer input.
     * @return The valid menu choice.
     */
    private static int getUserChoice() {
        int choice = -1;
        try {
            // Use Scanner to read the next integer line
            choice = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            // If input is not an integer, return an invalid choice indicator
            choice = -1;
        }
        return choice;
    }

    /**
     * Prompts the user for task details and adds a new task.
     * Includes input validation for priority.
     */
    private static void addNewTask() {
        System.out.print("Enter Description: ");
        String description = scanner.nextLine();

        int priority = -1;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter Priority (1=High, 5=Low, 1-10 range recommended): ");
            try {
                priority = Integer.parseInt(scanner.nextLine());
                // Basic validation for priority range
                if (priority >= 1 && priority <= 10) {
                    validPriority = true;
                } else {
                    System.err.println("Error: Priority must be an integer between 1 and 10.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid priority input. Please enter an integer.");
            }
        }

        // Using a simple counter for task ID
        Task newTask = new Task(nextTaskId++, description, priority);
        processor.addTask(newTask);
        System.out.println("Task added successfully!");
    }

    /**
     * Retrieves and displays all pending tasks.
     */
    private static void viewPendingTasks() {
        List<Task> pending = processor.getPendingTasks();
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            System.out.println("Pending Tasks:");
            for (Task task : pending) {
                System.out.println(task); // Uses Task's toString()
            }
        }
    }

    /**
     * Processes the next highest-priority task and displays the result.
     */
    private static void processNextTask() {
        System.out.println("Attempting to process next task...");
        Task processedTask = processor.processNextTask();

        if (processedTask != null) {
            System.out.println("Processing task: " + processedTask);
            System.out.println("Task processed successfully!");
        } else {
            // Use System.err for this specific "no tasks" condition as it's an action failure
            System.err.println("Error: No pending tasks to process.");
        }
    }

    /**
     * Retrieves and displays all completed tasks.
     */
    private static void viewCompletedTasks() {
        List<Task> completed = processor.getCompletedTasks();
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            System.out.println("Completed Tasks:");
            for (Task task : completed) {
                System.out.println(task); // Uses Task's toString()
            }
        }
    }
}
