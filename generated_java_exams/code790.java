/*
 * Exam Question #790
 * Generated on: 2025-05-12 16:41:07
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Support Ticket Management System**
 * 
 * You are tasked with developing a simplified Support Ticket Management System for a small IT department. The system needs to handle incoming support tickets, prioritize high-urgency issues, and track the status of all tickets.
 * 
 * **System Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following attributes:
 *     *   `ticketId` (an integer, automatically assigned sequentially starting from 1)
 *     *   `description` (a String describing the issue)
 *     *   `priority` (an enum: `HIGH` or `REGULAR`)
 *     *   `status` (an enum: `PENDING`, `IN_PROGRESS`, `RESOLVED`)
 *     The `Ticket` class should have appropriate encapsulation (private fields, public getters/setters where necessary) and a `toString()` method for easy display.
 * 
 * 2.  **Ticket Management Logic:** Create a `TicketManager` class responsible for managing the tickets. This class should internally use the following data structures:
 *     *   A `java.util.Queue` to hold `Ticket` objects that have `HIGH` priority and are currently `PENDING`. These are the tickets waiting to be processed urgently (First-In, First-Out). Use `LinkedList` as the concrete implementation for the `Queue`.
 *     *   A `java.util.List` (specifically implemented using `java.util.ArrayList`) to maintain a record of *all* tickets created in the system, regardless of their priority or current status. This list helps in viewing all tickets by their creation order (or ID).
 *     *   A separate `java.util.List` (also implemented using `java.util.ArrayList`) to store `Ticket` objects once their status becomes `RESOLVED`.
 * 
 * 3.  **User Interface:** Implement a simple text-based menu interface in a `main` method within a separate class (e.g., `TicketSystem`). The menu should offer the following options:
 *     *   **1. Add New Ticket:** Prompt the user for a description and priority (HIGH/REGULAR). Create a new `Ticket` object, assign it the next available ID, set its status to `PENDING`. Add the ticket to the `allTickets` list. If the priority is `HIGH`, also add it to the `highPriorityQueue`.
 *     *   **2. Process Next High Priority Ticket:** Remove the next ticket from the `highPriorityQueue`. If the queue is empty, report an error. If a ticket is retrieved, update its status to `RESOLVED` (the object in the queue is the same instance as in `allTickets`) and add it to the `resolvedTickets` list. Report which ticket was processed.
 *     *   **3. View All Tickets:** Display all tickets currently in the `allTickets` list, showing their ID, description, priority, and status.
 *     *   **4. View High Priority Queue:** Display the tickets currently waiting in the `highPriorityQueue`.
 *     *   **5. View Resolved Tickets:** Display all tickets in the `resolvedTickets` list.
 *     *   **6. Exit:** Terminate the application.
 * 
 * 4.  **Required Java Components:** Your solution MUST explicitly use ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu flow control
 *     *   `System.err` for printing error messages
 *     *   `System.out` for printing normal output (menu, prompts, ticket details)
 *     *   Class-wide exception handling using `try-catch` blocks (at least around the main application loop).
 * 
 * 5.  **Best Practices:** Your code should adhere to the following best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining key logic or design choices.
 *     *   Input validation (e.g., for priority input, handling non-integer menu input).
 *     *   Proper error handling for expected issues (e.g., processing an empty queue) using `System.err`.
 *     *   Clean code structure (separate classes for concerns).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept integer choices, and perform the corresponding actions.
 * - Valid operations and viewing requests should print output to `System.out`.
 * - Invalid menu input, invalid priority input, or attempts to process from an empty queue should print specific error messages to `System.err`.
 * - Any unexpected runtime errors should be caught by a high-level `try-catch` and reported to `System.err`.
 * 
 * You should provide the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * The solution implements a simple Support Ticket Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is organized into three classes:
 *     *   `Ticket`: Represents a single support ticket with properties like ID, description, priority, and status. Enums (`Priority`, `Status`) are used for type-safe representation of these attributes. Encapsulation is achieved by making fields private and providing public getter methods and a specific setter for status. A `toString()` method provides a convenient way to display ticket information.
 *     *   `TicketManager`: Manages the collection of tickets. It holds the `highPriorityQueue` (implemented using `LinkedList` to fulfill the `Queue` requirement), `allTickets` (implemented using `ArrayList` to fulfill the `List` and `ArrayList` requirements), and `resolvedTickets` (also an `ArrayList` implementing `List`). It contains methods for adding tickets, processing high-priority tickets, and viewing the different ticket collections. This class encapsulates the core business logic and data structures.
 *     *   `TicketSystem`: Contains the `main` method, which serves as the application entry point and user interface loop. It creates instances of `Scanner` and `TicketManager` and presents the menu to the user.
 * 
 * 2.  **Data Structure Usage:**
 *     *   `Queue<Ticket> highPriorityQueue`: Used to store `HIGH` priority tickets that are in `PENDING` status. The `offer()` method is used to add tickets, and `poll()` is used to retrieve and remove the next ticket to be processed (FIFO order).
 *     *   `List<Ticket> allTickets`: An `ArrayList` is used to implement this `List`. It acts as a master list containing every ticket created. This allows viewing all tickets regardless of their current state or priority queue status.
 *     *   `List<Ticket> resolvedTickets`: Another `ArrayList` implementing `List`, used specifically to store tickets once their status is updated to `RESOLVED`.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `java.util.Scanner`: An instance is created and used to read user input for menu choices, ticket descriptions, and priorities. It's important to handle the newline character after reading integers (`nextInt()`) before reading lines (`nextLine()`).
 *     *   `switch` statement: Used in the `main` method to direct program flow based on the user's menu choice, calling the appropriate methods in the `TicketManager`.
 * 
 * 4.  **Output Streams:**
 *     *   `System.out`: Used for displaying the menu, prompts for input, confirmations of successful operations (like adding or processing a ticket), and listing ticket details when viewing collections.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, invalid priority input, attempting to process from an empty queue, or unexpected runtime errors.
 * 
 * 5.  **Exception Handling:**
 *     *   Input Validation: The code includes checks for valid priority input using `Priority.valueOf()` within a `try-catch(IllegalArgumentException)`. It also handles non-integer input for the menu choice using a `try-catch(InputMismatchException)` block, consuming the invalid input to prevent an infinite loop.
 *     *   Specific Error Conditions: The `processNextHighPriorityTicket` method checks if `highPriorityQueue.poll()` returns `null` (indicating an empty queue) and prints an error message to `System.err`.
 *     *   Class-wide `try-catch`: The main application loop in the `TicketSystem.main` method is wrapped in a `try-catch(Exception e)`. This block catches any unhandled exceptions that might occur during the execution of the program's core logic, printing an error message and the stack trace to `System.err`, thus fulfilling the requirement for high-level error handling within the main class's execution flow. A `finally` block ensures the `Scanner` is closed.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation: Fields in `Ticket` and `TicketManager` are private.
 *     *   Meaningful Names: Variables (`highPriorityQueue`, `nextTicketId`), methods (`addTicket`, `processNextHighPriorityTicket`), and enums (`HIGH`, `PENDING`) have names reflecting their purpose.
 *     *   Comments: Basic comments are included to explain key parts like data structure choices and exception handling.
 *     *   Clean Structure: Logic is separated into distinct classes based on responsibility.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of collections, object-oriented design, user interaction, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Ticket Priority
enum Priority {
    HIGH, REGULAR
}

// Enum for Ticket Status
enum Status {
    PENDING, IN_PROGRESS, RESOLVED
}

/**
 * Represents a support ticket in the system.
 * Demonstrates encapsulation.
 */
class Ticket {
    private int ticketId;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Ticket.
     * @param ticketId The unique ID for the ticket.
     * @param description A brief description of the issue.
     * @param priority The priority level (HIGH or REGULAR).
     */
    public Ticket(int ticketId, String description, Priority priority) {
        this.ticketId = ticketId;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // Default status when created
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter for status (needed when processing) ---
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + ticketId + ", Desc='" + description + "', Priority=" + priority + ", Status=" + status + "]";
    }
}

/**
 * Manages the collection of tickets using Queue and List.
 * Demonstrates usage of different collection types and core logic.
 */
class TicketManager {
    // Queue for high priority tickets waiting for processing (FIFO)
    private Queue<Ticket> highPriorityQueue;
    // List to hold ALL tickets created in the system (for viewing/tracking)
    private List<Ticket> allTickets;
    // List to hold tickets that have been resolved
    private List<Ticket> resolvedTickets;
    // Counter for assigning unique ticket IDs
    private int nextTicketId;
    // Scanner instance for reading user input
    private Scanner scanner;

    /**
     * Constructs a TicketManager.
     * @param scanner The Scanner instance to use for input.
     */
    public TicketManager(Scanner scanner) {
        // Using LinkedList as the implementation for Queue
        this.highPriorityQueue = new LinkedList<>();
        // Using ArrayList as the implementation for List
        this.allTickets = new ArrayList<>();
        // Using ArrayList as the implementation for List
        this.resolvedTickets = new ArrayList<>();
        this.nextTicketId = 1;
        this.scanner = scanner;
    }

    /**
     * Adds a new ticket based on user input.
     */
    public void addTicket() {
        System.out.println("\n--- Add New Ticket ---");
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        // Input validation loop for priority
        while (priority == null) {
            System.out.print("Enter priority (HIGH/REGULAR): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityInput);
            } catch (IllegalArgumentException e) {
                // Use System.err for invalid input messages
                System.err.println("Invalid priority. Please enter HIGH or REGULAR.");
            }
        }

        // Create new ticket with next available ID and PENDING status
        Ticket newTicket = new Ticket(nextTicketId++, description, priority);
        allTickets.add(newTicket); // Add to the master list of all tickets

        if (priority == Priority.HIGH) {
            highPriorityQueue.offer(newTicket); // Add high priority ticket to the queue
            System.out.println("High priority ticket added to queue: " + newTicket); // Use System.out for success message
        } else {
            // Regular tickets are just added to the allTickets list initially
            System.out.println("Regular ticket added: " + newTicket); // Use System.out for success message
        }
    }

    /**
     * Processes the next ticket from the high priority queue.
     * Removes from queue, updates status, and adds to resolved list.
     */
    public void processNextHighPriorityTicket() {
        System.out.println("\n--- Processing High Priority Ticket ---");
        // Use poll() to retrieve and remove the head of the queue. Returns null if queue is empty.
        Ticket ticketToProcess = highPriorityQueue.poll();

        if (ticketToProcess == null) {
            // Use System.err for error message when queue is empty
            System.err.println("No high priority tickets in the queue to process.");
        } else {
            // The object from the queue is the same instance as in allTickets
            ticketToProcess.setStatus(Status.RESOLVED); // Update status directly
            resolvedTickets.add(ticketToProcess); // Add to the list of resolved tickets
            System.out.println("Processed and resolved: " + ticketToProcess); // Use System.out for success message
        }
    }

    /**
     * Displays all tickets currently in the system.
     * Iterates over the allTickets List.
     */
    public void viewAllTickets() {
        System.out.println("\n--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets available."); // Use System.out for informational messages
            return;
        }
        // Iterate using the List interface
        for (Ticket ticket : allTickets) {
            System.out.println(ticket); // Use System.out to display ticket details
        }
    }

    /**
     * Displays tickets currently waiting in the high priority queue.
     * Iterates over the highPriorityQueue Queue.
     */
    public void viewHighPriorityQueue() {
        System.out.println("\n--- High Priority Queue ---");
        if (highPriorityQueue.isEmpty()) {
            System.out.println("High priority queue is empty."); // Use System.out for informational messages
            return;
        }
        // Iterate using the Queue interface (elements are not removed)
        for (Ticket ticket : highPriorityQueue) {
             System.out.println(ticket); // Use System.out to display ticket details
        }
    }

    /**
     * Displays all tickets that have been resolved.
     * Iterates over the resolvedTickets List.
     */
    public void viewResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
         if (resolvedTickets.isEmpty()) {
            System.out.println("No tickets have been resolved yet."); // Use System.out for informational messages
            return;
        }
        // Iterate using the List interface
        for (Ticket ticket : resolvedTickets) {
            System.out.println(ticket); // Use System.out to display ticket details
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    public void displayMenu() {
        System.out.println("\n--- Ticket Management System ---"); // Use System.out for menu
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next High Priority Ticket");
        System.out.println("3. View All Tickets");
        System.out.println("4. View High Priority Queue");
        System.out.println("5. View Resolved Tickets");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: "); // Use System.out for prompt
    }
}

/**
 * Main class to run the Support Ticket Management System application.
 * Contains the main loop and class-wide exception handling.
 */
public class TicketSystem {

    public static void main(String[] args) {
        // Scanner for reading input from the console
        Scanner scanner = new Scanner(System.in);
        // Instantiate the TicketManager
        TicketManager manager = new TicketManager(scanner);

        boolean running = true;

        // Class-wide exception handling for the main application loop
        // This catches any unexpected exceptions during execution
        try {
            while (running) {
                manager.displayMenu();

                int choice = -1;
                // Specific try-catch for handling non-integer input for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Use System.err for invalid input errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                     // Consume the newline character left by scanner.nextInt()
                     // This is crucial before the next scanner.nextLine() call
                     scanner.nextLine();
                }

                // Use switch statement to handle menu choices
                switch (choice) {
                    case 1:
                        manager.addTicket();
                        break;
                    case 2:
                        manager.processNextHighPriorityTicket();
                        break;
                    case 3:
                        manager.viewAllTickets();
                        break;
                    case 4:
                        manager.viewHighPriorityQueue();
                        break;
                    case 5:
                         manager.viewResolvedTickets();
                         break;
                    case 6:
                        System.out.println("Exiting Ticket Management System. Goodbye!"); // Use System.out for exit message
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Use System.err for invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            // Use System.err for reporting unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated."); // Use System.out for final message
        }
    }
}
