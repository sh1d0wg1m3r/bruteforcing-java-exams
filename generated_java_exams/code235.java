/*
 * Exam Question #235
 * Generated on: 2025-05-11 22:36:57
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Print Job Management System
 * 
 * **Objective:** Design and implement a simple console-based Print Job Management System. The system should allow users to add print jobs to a queue, process the next job in the queue, view pending jobs, and view a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Print Job Representation:** Create a class `PrintJob` to represent a print job. Each job should have:
 *     *   A unique integer `id`.
 *     *   A `String` `fileName`.
 *     *   Implement necessary methods (constructor, getters, `toString`). Ensure proper encapsulation.
 * 
 * 2.  **Print Manager Class:** Create a class `PrintManager` that manages the print jobs. It must contain:
 *     *   A `Queue<PrintJob>` to hold jobs waiting to be printed (pending jobs).
 *     *   A `List<PrintJob>` to store jobs that have been processed (completed jobs history).
 *     *   A mechanism to generate unique job IDs (e.g., a counter).
 * 
 * 3.  **Functionality:** The `PrintManager` class must provide the following methods, accessible via a user menu:
 *     *   **Add Job:** Prompt the user for a file name, create a new `PrintJob` with a unique ID, and add it to the pending jobs queue. Validate that the file name is not empty.
 *     *   **Process Next Job:** Remove the job at the front of the pending queue, simulate processing (print a message), and add it to the completed jobs list. Handle the case where the queue is empty.
 *     *   **View Pending Jobs:** Display all jobs currently in the pending queue in their current order.
 *     *   **View Completed Jobs:** Display all jobs in the completed jobs history.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input (menu choice and file names).
 *     *   Display a clear menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for normal output (menu, confirmations, job lists).
 *     *   Use `System.err` for error messages (e.g., invalid input, trying to process an empty queue, empty file name).
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation for user choices and file names.
 *     *   Use `try-catch` blocks to handle potential runtime errors, especially related to scanner input (e.g., `InputMismatchException`). The main input loop should be wrapped in a `try-catch` to gracefully handle unexpected issues and prevent the program from crashing.
 *     *   Handle specific scenario errors (e.g., attempting to process a job when the queue is empty).
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to Java coding conventions (naming, formatting).
 *     *   Include appropriate comments and documentation (Javadoc is a plus).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on user input, the system should perform the requested action, printing confirmations, lists of jobs, or error messages appropriately using `System.out` or `System.err`.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: report.pdf
 * Job added: Job ID: 1, File: report.pdf
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: image.png
 * Job added: Job ID: 2, File: image.png
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Jobs ---
 * Job ID: 1, File: report.pdf
 * Job ID: 2, File: image.png
 * --------------------
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Processing job: Job ID: 1, File: report.pdf
 * Job 1 completed.
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job ID: 1, File: report.pdf
 * --------------------
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Processing job: Job ID: 2, File: image.png
 * Job 2 completed.
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Error: No jobs in the pending queue to process.
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Print Job Management System
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 5
 * Exiting Print Job Management System.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a console-based Print Job Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:** This simple class encapsulates the data for a single print job: a unique integer `id` and a `String` `fileName`. It follows encapsulation principles with private fields and public getter methods. The `toString()` method is overridden for convenient display of job details.
 * 
 * 2.  **`PrintManager` Class:** This is the core class managing the system.
 *     *   `private Queue<PrintJob> pendingJobs;`: A `LinkedList` is used here to implement the `Queue` interface. This is suitable for a queue because `LinkedList` provides efficient `offer()` (add to end) and `poll()` (remove from front) operations, which are characteristic of a First-In, First-Out (FIFO) structure like a print queue.
 *     *   `private List<PrintJob> completedJobs;`: An `ArrayList` is used here to implement the `List` interface. This is suitable for storing a history of completed jobs where elements are added sequentially and can be iterated over or accessed by index (though we only iterate here). `ArrayList` provides efficient add operations at the end.
 *     *   `private int jobCounter;`: An integer counter is used to assign unique IDs to new print jobs, starting from 1.
 *     *   `private Scanner scanner;`: An instance of `Scanner` is used to read user input from the console (`System.in`).
 * 
 * 3.  **Functionality Methods:**
 *     *   `displayMenu()`: A helper method to print the available options to `System.out`.
 *     *   `addJob()`: Prompts for a file name using `scanner.nextLine()`. It includes input validation to ensure the file name is not empty. A new `PrintJob` is created with the next available `jobCounter` ID, and `jobCounter` is incremented. The new job is added to the `pendingJobs` queue using `offer()`. Success messages are printed to `System.out`, and validation errors to `System.err`.
 *     *   `processNextJob()`: Checks if the `pendingJobs` queue is empty using `isEmpty()`. If empty, an error message is printed to `System.err`. Otherwise, `poll()` is used to remove and retrieve the job at the head of the queue. This job is then added to the `completedJobs` list using `add()`. Progress and completion messages are printed to `System.out`.
 *     *   `viewPendingJobs()`: Checks if the `pendingJobs` queue is empty. If not, it iterates through the queue using an enhanced for loop and prints each `PrintJob`'s `toString()` representation to `System.out`. Iterating a `Queue` does *not* remove elements, which is the correct behavior for viewing.
 *     *   `viewCompletedJobs()`: Checks if the `completedJobs` list is empty. If not, it iterates through the list using an enhanced for loop and prints each `PrintJob`'s `toString()` representation to `System.out`.
 * 
 * 4.  **User Interaction and Control Flow:**
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   Inside the loop, `displayMenu()` is called.
 *     *   User input for the menu choice is read using `scanner.nextInt()`.
 *     *   Crucially, `scanner.nextLine()` is called immediately after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls in `addJob()`.
 *     *   A `switch` statement is used to direct execution based on the user's integer choice, calling the appropriate management method.
 *     *   A `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   Choosing option 5 sets the `running` flag to `false`, terminating the loop and exiting the program.
 * 
 * 5.  **Exception Handling:**
 *     *   The main logic within the `run()` loop (reading input and processing choice) is wrapped in a `try-catch` block.
 *     *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It prints an informative error to `System.err` and calls `scanner.nextLine()` *within the catch block* to clear the invalid input from the scanner buffer, preventing an infinite error loop.
 *     *   `catch (Exception e)` is a general catch block to capture any other unexpected exceptions that might occur, printing an error message to `System.err`.
 *     *   Specific error conditions like processing an empty queue or adding a job with an empty file name are handled with `if` checks and `System.err` messages within the respective methods (`processNextJob`, `addJob`).
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in `PrintJob`.
 *     *   Meaningful names are used for variables and methods (`pendingJobs`, `processNextJob`, `fileName`, etc.).
 *     *   Basic Javadoc-style comments are included for classes and methods.
 *     *   Input validation (empty file name, valid menu choice type) is performed.
 *     *   Error messages are directed to `System.err`.
 *     *   The `Scanner` resource is closed using `scanner.close()` after the main loop finishes, releasing system resources.
 *     *   The code is structured into a separate `PrintJob` class and a `PrintManager` class with distinct methods for each function. The `main` method simply creates and runs the manager.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures (`Queue`, `List`), user interaction (`Scanner`, `System.out`, `System.err`), control flow (`switch`, loops), encapsulation, input validation, and robust exception handling (`try-catch`).
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with an ID and file name.
 */
class PrintJob {
    private int id;
    private String fileName;

    /**
     * Constructs a new PrintJob.
     * @param id The unique ID for the job.
     * @param fileName The name of the file to be printed.
     */
    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
    }

    /**
     * Gets the job ID.
     * @return The job ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the file name.
     * @return The file name.
     */
    public String getFileName() {
        return fileName;
    }

    /**
     * Returns a string representation of the PrintJob.
     * @return A string formatted as "Job ID: [id], File: [fileName]".
     */
    @Override
    public String toString() {
        return "Job ID: " + id + ", File: " + fileName;
    }
}

/**
 * Manages the queue of pending print jobs and a history of completed jobs.
 */
public class PrintManager {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs;
    private int jobCounter; // To generate unique job IDs
    private Scanner scanner;

    /**
     * Constructs a new PrintManager.
     */
    public PrintManager() {
        // Use LinkedList as an implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedJobs = new ArrayList<>();
        this.jobCounter = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nPrint Job Management System");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new print job to the pending queue.
     * Prompts the user for the file name.
     */
    private void addJob() {
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine().trim(); // Read line and remove leading/trailing whitespace

        if (fileName.isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }

        PrintJob newJob = new PrintJob(jobCounter++, fileName);
        pendingJobs.offer(newJob); // offer() is preferred over add() in queues as it doesn't throw exception on capacity limits (though LinkedList doesn't have capacity limits)
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the pending queue.
     * Moves the job from pending to completed list.
     */
    private void processNextJob() {
        if (pendingJobs.isEmpty()) {
            System.err.println("Error: No jobs in the pending queue to process.");
            return;
        }

        PrintJob processedJob = pendingJobs.poll(); // poll() removes and returns the head, or null if empty
        System.out.println("Processing job: " + processedJob);
        // Simulate processing...
        completedJobs.add(processedJob);
        System.out.println("Job " + processedJob.getId() + " completed.");
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    private void viewPendingJobs() {
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs in the pending queue.");
            return;
        }

        System.out.println("--- Pending Jobs ---");
        // Iterating over a Queue does not remove elements
        for (PrintJob job : pendingJobs) {
            System.out.println(job);
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all jobs in the completed jobs history.
     */
    private void viewCompletedJobs() {
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs in the completed history.");
            return;
        }

        System.out.println("--- Completed Jobs ---");
        for (PrintJob job : completedJobs) {
            System.out.println(job);
        }
        System.out.println("----------------------");
    }

    /**
     * Runs the main application loop, handling user input and actions.
     * Includes main try-catch block for exception handling.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline left-over after reading int

                switch (choice) {
                    case 1:
                        addJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewPendingJobs();
                        break;
                    case 4:
                        viewCompletedJobs();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Print Job Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
            }
        }
        scanner.close(); // Close the scanner when exiting the loop
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run();
    }
}
