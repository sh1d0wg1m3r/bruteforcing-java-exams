/*
 * Exam Question #1006
 * Generated on: 2025-05-12 17:11:53
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage print jobs for a shared network printer. The system should handle incoming print requests, process them in the order they were received, and keep a record of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a queue of pending print jobs. Jobs should be processed in First-In, First-Out (FIFO) order.
 *     *   Maintain a list of completed print jobs.
 * 
 * 2.  **Functionality:**
 *     *   **Add New Job:** Allow the user to add a new print job by specifying a file name and the number of pages. The job should be added to the end of the pending queue.
 *     *   **Process Next Job:** Process the next job from the front of the pending queue. If the queue is empty, report an error. The processed job should be moved to the list of completed jobs.
 *     *   **View Pending Jobs:** Display all jobs currently in the pending queue, showing their job ID, file name, and pages.
 *     *   **View Completed Jobs:** Display all jobs currently in the completed list, showing their job ID, file name, and pages.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **User Interface:**
 *     *   Present a menu of options to the user (Add Job, Process Job, View Pending, View Completed, Exit).
 *     *   Use `java.util.Scanner` to read user input for menu choices and job details.
 * 
 * 4.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue` (used for pending jobs)
 *     *   `java.util.ArrayList` (used as the concrete implementation for the completed jobs list)
 *     *   `java.util.List` (used as the interface type for the completed jobs list variable)
 *     *   `java.util.Scanner`
 *     *   `switch` statement (for menu handling)
 *     *   `System.err` (for error messages, e.g., empty queue, invalid input)
 *     *   `System.out` (for normal output, e.g., menu, prompts, job details)
 * 
 * 5.  **Best Practices & Error Handling:**
 *     *   Implement proper encapsulation (private fields, public methods) for relevant classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and public methods).
 *     *   Implement input validation:
 *         *   Ensure the number of pages for a print job is a positive integer.
 *         *   Handle cases where the user enters non-numeric input for menu choices or page counts.
 *     *   Implement proper error handling using `try-catch` blocks. This should include handling potential exceptions during input reading and operations on empty collections where applicable. Demonstrate class-wide exception handling principles by placing `try-catch` blocks around code that might throw exceptions, particularly user input processing and collection operations.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested actions, and display appropriate messages (normal output via `System.out`, errors via `System.err`). Example interaction might look like:
 * 
 * ```
 * --- Print Job Manager Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * Enter your choice: 1
 * --- Add New Print Job ---
 * Enter file name: document.pdf
 * Enter number of pages: 10
 * Print job added: Job ID: 1, File: document.pdf, Pages: 10
 * 
 * --- Print Job Manager Menu ---
 * 1. Add New Print Job
 * ...
 * Enter your choice: 2
 * --- Process Next Print Job ---
 * Processing job: Job ID: 1, File: document.pdf, Pages: 10
 * Job completed and moved to completed list.
 * 
 * --- Print Job Manager Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Print Job ---
 * Error: No pending jobs to process.
 * 
 * --- Print Job Manager Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Print Jobs ---
 * 1. Job ID: 1, File: document.pdf, Pages: 10
 * 
 * --- Print Job Manager Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Print Job Manager. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing the necessary classes.
 *
 * EXPLANATION:
 * The solution implements a `PrintJobManager` class that simulates a print job queue and a completed jobs list.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   This simple class encapsulates the data for a single print job: `jobId`, `fileName`, and `pages`.
 *     *   It uses a `static` variable `nextJobId` to automatically generate unique IDs for each new job, demonstrating a common pattern for ID generation.
 *     *   Private fields and public getter methods (`getJobId`, `getFileName`, `getPages`) enforce encapsulation.
 *     *   The `toString()` method provides a convenient way to display job information.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   **Data Structures:**
 *         *   `private Queue<PrintJob> pendingJobs = new LinkedList<>();`: A `Queue` is used for pending jobs because print jobs are processed in the order they are received (FIFO). `LinkedList` is a common concrete implementation of the `Queue` interface. The variable is declared using the `Queue` interface type, adhering to the requirement to use `java.util.Queue`.
 *         *   `private List<PrintJob> completedJobs = new ArrayList<>();`: A `List` is used for completed jobs. While a `Queue` might not be suitable here (we don't necessarily process completed jobs in FIFO order), a `List` provides a simple way to store them. `ArrayList` is used as the concrete implementation, fulfilling the requirement to use `java.util.ArrayList`. The variable is declared using the `List` interface type, fulfilling the requirement to use `java.util.List`.
 *     *   **Scanner:** `private Scanner scanner = new Scanner(System.in);` is initialized to read input from the console (`System.in`), meeting the `Scanner` requirement.
 *     *   **Encapsulation:** Both `pendingJobs`, `completedJobs`, and `scanner` are private fields, accessible only through the class's public methods.
 *     *   **Methods:**
 *         *   `addJob()`: Prompts the user for file name and pages. It includes input validation for the number of pages using a `while` loop and a `try-catch` block to handle non-integer input (`InputMismatchException`). It uses `scanner.nextLine()` after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls. A valid `PrintJob` object is created and added to the `pendingJobs` queue using `offer()`.
 *         *   `processNextJob()`: Uses `pendingJobs.poll()` to retrieve and remove the head of the queue. `poll()` is suitable as it returns `null` if the queue is empty, which is explicitly checked to provide an error message via `System.err`. If a job is processed, it's added to the `completedJobs` list using `add()`.
 *         *   `viewPendingJobs()`: Iterates through the `pendingJobs` queue (without removing elements) and prints each job using `System.out`. Checks if the queue is empty first.
 *         *   `viewCompletedJobs()`: Iterates through the `completedJobs` list and prints each job using `System.out`. Checks if the list is empty first.
 *         *   `printMenu()`: A private helper method to display the menu options using `System.out`.
 *         *   `run()`: This method contains the main application loop. It repeatedly displays the menu, reads the user's choice using `scanner.nextInt()`, and uses a `switch` statement to call the appropriate method based on the choice. This fulfills the `switch` statement requirement.
 *     *   **Exception Handling (`try-catch`):**
 *         *   The `addJob` method uses a `try-catch (InputMismatchException e)` block within a loop to robustly handle invalid (non-integer) input for the number of pages. It prints the error using `System.err`.
 *         *   The `run` method uses a `try-catch (InputMismatchException e)` block around the menu input reading (`scanner.nextInt()`) to handle cases where the user enters non-numeric input for the menu choice. It prints the error using `System.err`. A general `catch (Exception e)` is also included in `run` as a broader safety net, demonstrating a form of class-wide handling for unexpected issues during the main loop execution.
 *     *   **System Output:** `System.out.println()` is used for menu display, prompts, successful action messages, and displaying job details. `System.err.println()` is specifically used for error messages (invalid input, empty queue).
 *     *   **Resource Management:** The `scanner.close()` call in the `run()` method ensures the `Scanner` resource is released when the application exits.
 *     *   **`main` Method:** Creates an instance of `PrintManager` and calls the `run()` method to start the application.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating proper data structure usage, flow control, user interaction, encapsulation, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with a unique ID, file name, and page count.
 */
class PrintJob {
    private static int nextJobId = 1; // Static counter to generate unique IDs

    private int jobId;
    private String fileName;
    private int pages;

    /**
     * Constructs a new PrintJob.
     *
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the file.
     */
    public PrintJob(String fileName, int pages) {
        this.jobId = nextJobId++; // Assign unique ID and increment counter
        this.fileName = fileName;
        this.pages = pages;
    }

    /**
     * Gets the unique ID of the print job.
     *
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the file name of the print job.
     *
     * @return The file name.
     */
    public String getFileName() {
        return fileName;
    }

    /**
     * Gets the number of pages in the print job.
     *
     * @return The number of pages.
     */
    public int getPages() {
        return pages;
    }

    /**
     * Returns a string representation of the print job.
     *
     * @return A formatted string including job ID, file name, and pages.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages;
    }
}

/**
 * Manages the print job queue and completed job list.
 * Provides methods for adding, processing, and viewing print jobs.
 */
public class PrintManager {
    // Queue to hold pending print jobs (FIFO)
    private Queue<PrintJob> pendingJobs;
    // List to hold completed print jobs (can be accessed by index if needed, here just for storage)
    private List<PrintJob> completedJobs;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing the job queues and scanner.
     */
    public PrintManager() {
        // LinkedList is a common implementation for Queue
        pendingJobs = new LinkedList<>();
        // ArrayList is a common implementation for List
        completedJobs = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the pending queue based on user input.
     * Includes input validation for the number of pages.
     */
    public void addJob() {
        System.out.println("\n--- Add New Print Job ---");
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine(); // Read the file name

        int pages = 0;
        boolean validInput = false;
        // Loop until valid integer input (> 0) is received for pages
        while (!validInput) {
            System.out.print("Enter number of pages: ");
            try {
                pages = scanner.nextInt(); // Attempt to read integer
                scanner.nextLine(); // Consume the rest of the line (the newline character)
                if (pages <= 0) {
                    System.err.println("Error: Number of pages must be positive.");
                } else {
                    validInput = true; // Input is valid
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a number for pages.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            }
        }

        PrintJob newJob = new PrintJob(fileName, pages);
        pendingJobs.offer(newJob); // Add the new job to the end of the queue (offer is preferred over add for capacity-constrained queues, though LinkedList is not)
        System.out.println("Print job added: " + newJob);
    }

    /**
     * Processes the next print job from the pending queue.
     * Removes the job from the queue and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextJob() {
        System.out.println("\n--- Process Next Print Job ---");
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        PrintJob nextJob = pendingJobs.poll();

        if (nextJob == null) {
            System.err.println("Error: No pending jobs to process.");
        } else {
            System.out.println("Processing job: " + nextJob);
            completedJobs.add(nextJob); // Add the processed job to the completed list
            System.out.println("Job completed and moved to completed list.");
        }
    }

    /**
     * Displays all print jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Print Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending print jobs.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PrintJob job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Displays all print jobs currently in the completed list.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Print Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No completed print jobs.");
        } else {
            // Iterate through the list
            int index = 1;
            for (PrintJob job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Print Job Manager Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("0. Exit");
    }

    /**
     * Runs the main application loop, displaying the menu and processing user choices.
     * Includes exception handling for the main menu input.
     */
    public void run() {
        int choice = -1;
        // Loop until the user chooses to exit (choice 0)
        while (choice != 0) {
            printMenu(); // Display the menu
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read the user's menu choice
                scanner.nextLine(); // Consume the rest of the line (the newline character)

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addJob(); // Call method to add a job
                        break;
                    case 2:
                        processNextJob(); // Call method to process the next job
                        break;
                    case 3:
                        viewPendingJobs(); // Call method to view pending jobs
                        break;
                    case 4:
                        viewCompletedJobs(); // Call method to view completed jobs
                        break;
                    case 0:
                        System.out.println("Exiting Print Job Manager. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 0 and 4.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure the loop continues
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // Optionally print stack trace for debugging in an exam scenario
                 // e.printStackTrace();
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * The main method to start the Print Job Management System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run(); // Start the main application loop
    }
}
