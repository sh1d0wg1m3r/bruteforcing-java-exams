/*
 * Exam Question #395
 * Generated on: 2025-05-11 23:04:43
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming - Data Structures, Control Flow, and Error Handling
 * 
 * **Task:** Design and implement a simplified IT Support Ticket Processing System. The system should manage incoming support requests (tickets) in the order they are received, process them one by one, and maintain a record of completed tickets. The system will interact with the user via the console.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts, data structures, control flow, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending support tickets. Tickets should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` to store completed support tickets.
 *     *   Declare the completed tickets list using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and input from the console.
 *     *   The system should present a menu of options to the user.
 * 
 * 3.  **Functionality:** Implement the following commands:
 *     *   `add <description>`: Adds a new support ticket with the given description to the end of the pending queue. Assign a unique, sequential ID to each ticket starting from 1.
 *     *   `process`: Processes the next ticket from the front of the pending queue. If the queue is not empty, the ticket is removed from the queue, its status is marked as completed, and it is added to the list of completed tickets.
 *     *   `view_queue`: Displays all tickets currently in the pending queue, showing their ID and description.
 *     *   `view_completed`: Displays all tickets in the completed list, showing their ID, description, and status.
 *     *   `exit`: Terminates the program.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands entered via the console.
 *     *   Use a loop to keep the system running until the user explicitly enters the `exit` command.
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, trying to process an empty queue, invalid input format).
 *     *   Implement input validation (e.g., check if the `add` command has a description).
 *     *   Implement a class-wide `try-catch` block to gracefully handle potential runtime exceptions that might occur during the main program execution loop (e.g., unexpected input issues).
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for all normal output (prompts, menu, ticket details, success messages).
 *     *   Clearly format the output for viewing tickets.
 * 
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure the code logically (e.g., separate `Ticket` class, main system class).
 * 
 * **Expected Output Structure (Examples):**
 * 
 * ```
 * IT Support Ticket System Menu:
 * add <description> - Add a new ticket
 * process           - Process next ticket
 * view_queue        - View pending queue
 * view_completed    - View completed tickets
 * exit              - Exit the system
 * 
 * Enter command: add Printer not working in room 301
 * Ticket #1 added to queue.
 * 
 * Enter command: add Network issue in lab 105
 * Ticket #2 added to queue.
 * 
 * Enter command: view_queue
 * --- Pending Tickets ---
 * ID: 1, Description: Printer not working in room 301
 * ID: 2, Description: Network issue in lab 105
 * -----------------------
 * 
 * Enter command: process
 * Processing ticket #1: Printer not working in room 301
 * Ticket #1 marked as completed.
 * 
 * Enter command: view_completed
 * --- Completed Tickets ---
 * ID: 1, Description: Printer not working in room 301, Status: Completed
 * -------------------------
 * 
 * Enter command: process
 * Processing ticket #2: Network issue in lab 105
 * Ticket #2 marked as completed.
 * 
 * Enter command: process
 * System.err: Error: No tickets in the pending queue to process.
 * 
 * Enter command: view_queue
 * --- Pending Tickets ---
 * Queue is empty.
 * -----------------------
 * 
 * Enter command: exit
 * Exiting system.
 * ```
 * 
 * Your solution should be provided as a single executable Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple IT Support Ticket Processing System as required, demonstrating the use of various Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   This class encapsulates the data for a single support ticket: `id`, `description`, and `status`.
 *     *   It uses private fields and public getter/setter methods, adhering to proper encapsulation.
 *     *   The `toString()` method provides a convenient way to represent ticket information as a string for printing.
 *     *   The `id` is generated sequentially by the `ITSupportSystem`.
 * 
 * 2.  **`ITSupportSystem` Class:**
 *     *   This is the main class containing the application logic and data structures.
 *     *   **Data Structures:**
 *         *   `pendingTickets`: Declared as `Queue<Ticket>` and instantiated as `LinkedList<Ticket>`. `LinkedList` is a common implementation for `Queue` in Java, providing efficient additions to the tail (`offer`) and removals from the head (`poll`), which is exactly what's needed for a FIFO queue of pending tasks.
 *         *   `completedTickets`: Declared as `List<Ticket>` and instantiated as `ArrayList<Ticket>`. `ArrayList` is suitable for storing completed tasks where access by index or simple iteration is common, and the size might grow dynamically. Using the `List` interface for the declaration promotes flexibility if a different `List` implementation were needed later.
 *     *   **`nextTicketId`:** A private integer counter ensures each new ticket gets a unique ID.
 *     *   **Methods:**
 *         *   `ITSupportSystem()`: The constructor initializes the two data structures and the ID counter.
 *         *   `displayMenu()`: Prints the available commands to the console using `System.out`.
 *         *   `addTicket(String description)`: Takes a description, creates a new `Ticket` with the next ID, validates the description (using `System.err` for the error), and adds it to the `pendingTickets` queue using `offer()`. `offer()` is used because it's the standard `Queue` method for adding elements, returning `false` if the queue is full (though `LinkedList` is unbounded).
 *         *   `processNextTicket()`: Removes the head of the `pendingTickets` queue using `poll()`. `poll()` returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a ticket is retrieved, its status is updated, and it's added to the `completedTickets` list.
 *         *   `viewPendingQueue()`: Iterates through the `pendingTickets` queue (without removing elements) and prints each ticket's details using `System.out`. It checks if the queue is empty first.
 *         *   `viewCompletedTickets()`: Iterates through the `completedTickets` list and prints each completed ticket's details using `System.out`. It checks if the list is empty first.
 *     *   **`main` Method:**
 *         *   This is the entry point of the application.
 *         *   It creates an instance of `ITSupportSystem`.
 *         *   A `boolean running` flag controls the main loop.
 *         *   A `Scanner` is used for reading user input. `try-with-resources` is used to ensure the `Scanner` is automatically closed when the block is exited.
 *         *   **Class-wide `try-catch`:** The main `while` loop that handles user interaction is wrapped in a `try-catch(Exception e)` block. This provides a top-level safety net to catch any unexpected runtime exceptions that might escape specific method-level handling, preventing the program from crashing abruptly and printing a generic error message to `System.err`.
 *         *   Inside the loop, the menu is displayed, input is read, trimmed, and split into command and arguments.
 *         *   **`switch` Statement:** A `switch` statement is used to dispatch the appropriate method call based on the user's command (`add`, `process`, `view_queue`, `view_completed`, `exit`).
 *         *   The `default` case in the `switch` handles unknown commands, printing an error to `System.err`.
 *         *   The loop continues until the `exit` command sets `running` to `false`.
 * 
 * This solution effectively uses the required data structures (`Queue`, `ArrayList`, `List`), control flow mechanisms (`switch`, loop), input handling (`Scanner`), and error reporting (`System.err`, `System.out`, `try-catch`) within a structured, encapsulated, and well-commented program, simulating a practical scenario.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// Represents a single IT support ticket
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the ticket.
     * @return Formatted string of ticket details.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the IT support ticket processing system
public class ITSupportSystem {

    // Using LinkedList as a concrete implementation of Queue
    private Queue<Ticket> pendingTickets;
    // Using ArrayList as a concrete implementation of List
    private List<Ticket> completedTickets;
    private int nextTicketId; // Counter for unique ticket IDs

    /**
     * Constructs a new ITSupportSystem.
     * Initializes the queues and the ticket ID counter.
     */
    public ITSupportSystem() {
        pendingTickets = new LinkedList<>(); // Queue for FIFO processing
        completedTickets = new ArrayList<>(); // List for storing completed tickets
        nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nIT Support Ticket System Menu:");
        System.out.println("add <description> - Add a new ticket");
        System.out.println("process           - Process next ticket");
        System.out.println("view_queue        - View pending queue");
        System.out.println("view_completed    - View completed tickets");
        System.out.println("exit              - Exit the system");
        System.out.print("\nEnter command: ");
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the ticket.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer is generally preferred over add for queues
        System.out.println("Ticket #" + newTicket.getId() + " added to queue.");
    }

    /**
     * Processes the next ticket from the pending queue.
     * Moves the ticket to the completed list.
     */
    public void processNextTicket() {
        Ticket ticketToProcess = pendingTickets.poll(); // Retrieves and removes the head of the queue
        if (ticketToProcess == null) {
            System.err.println("Error: No tickets in the pending queue to process.");
        } else {
            System.out.println("Processing ticket #" + ticketToProcess.getId() + ": " + ticketToProcess.getDescription());
            ticketToProcess.setStatus("Completed");
            completedTickets.add(ticketToProcess);
            System.out.println("Ticket #" + ticketToProcess.getId() + " marked as completed.");
        }
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingQueue() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                // Note: Queue iteration order depends on implementation, but for LinkedList it's insertion order
                System.out.println(ticket.toString()); // Status will be "Pending"
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets in the completed list.
     */
    public void viewCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---");
        if (completedTickets.isEmpty()) {
            System.out.println("No tickets have been completed yet.");
        } else {
            for (Ticket ticket : completedTickets) {
                System.out.println(ticket.toString()); // Status will be "Completed"
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Main method to run the IT Support System.
     * Handles user input loop and command dispatch.
     */
    public static void main(String[] args) {
        ITSupportSystem system = new ITSupportSystem();
        boolean running = true;

        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            // Class-wide try-catch block for the main execution loop
            try {
                while (running) {
                    system.displayMenu();
                    String inputLine = scanner.nextLine().trim();

                    if (inputLine.isEmpty()) {
                        System.err.println("Error: No command entered.");
                        continue; // Ask for input again
                    }

                    // Split command and arguments
                    String[] parts = inputLine.split(" ", 2);
                    String command = parts[0].toLowerCase();
                    String argument = parts.length > 1 ? parts[1] : "";

                    switch (command) {
                        case "add":
                            system.addTicket(argument);
                            break;
                        case "process":
                            system.processNextTicket();
                            break;
                        case "view_queue":
                            system.viewPendingQueue();
                            break;
                        case "view_completed":
                            system.viewCompletedTickets();
                            break;
                        case "exit":
                            running = false;
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Error: Unknown command '" + command + "'. Please try again.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development,
                // but often omitted or logged in production systems.
                // e.printStackTrace(System.err);
            }
        } // Scanner is automatically closed here

    }
}
