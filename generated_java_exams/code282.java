/*
 * Exam Question #282
 * Generated on: 2025-05-11 22:49:13
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Assembly Line Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a manufacturing assembly line. Parts arrive at the beginning of the line and are placed in a queue. A worker processes parts one by one from the front of the queue. The processing step depends on the type of the part. Successfully processed parts are moved to a list of completed items. The system should allow adding parts to the queue, processing the next part, viewing the status of the line (queue size, completed items), and handling potential errors during input or processing.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this assembly line using the following requirements and constraints:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the assembly line queue where parts are waiting.
 *     *   Use a `java.util.ArrayList` to store parts that have been successfully processed.
 *     *   Declare the variable holding the completed parts using the `java.util.List` interface type (`List<ProductPart> completedItems = new ArrayList<>();`).
 * 
 * 2.  **Input and Output:**
 *     *   Use `java.util.Scanner` to take user input for menu choices and part details.
 *     *   Use `System.out` for displaying the main menu, successful operations, and status information (queue size, completed parts list).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, processing failures).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu choices provided by the user.
 *     *   Use another `switch` statement within the processing logic to determine the processing steps based on the `ProductPart`'s type.
 * 
 * 4.  **Object-Oriented Design:**
 *     *   Create a class `ProductPart` with private fields (e.g., `id`, `type`) and public methods (constructor, getters). Consider using an enum for `type` (e.g., `PART_A`, `PART_B`, `PART_C`).
 *     *   Create an `AssemblyLine` class that encapsulates the `Queue` and `List`. This class should have methods like `addPart(ProductPart part)`, `processNextPart()`, and `getCompletedParts()`.
 *     *   Create a main class (e.g., `AssemblyLineSimulator`) containing the `main` method to handle user interaction and orchestrate the simulation.
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensure menu choices are numbers, part IDs are valid).
 *     *   Include class-wide exception handling using `try-catch` blocks to manage potential runtime errors, especially around input operations and the core processing logic. Simulate a potential processing failure for a specific part type within the `processNextPart` method and catch it.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Close the `Scanner` resource properly.
 * 
 * **Simulation Details:**
 * 
 * *   The `ProductPart` should have at least an integer `id` and a `ProductPartType` enum.
 * *   The menu options should include:
 *     *   Add a new part to the queue.
 *     *   Process the next part from the queue.
 *     *   View line status (queue size and completed parts).
 *     *   Exit.
 * *   When adding a part, prompt the user for the part ID and type (e.g., A, B, C). Validate the input.
 * *   When processing, take the part from the head of the queue. Use a `switch` based on the part type:
 *     *   `PART_A`: Simulate "Processing Type A...".
 *     *   `PART_B`: Simulate "Assembling Type B...".
 *     *   `PART_C`: Simulate "Inspecting Type C...".
 *     *   If the queue is empty, report an error.
 * *   Simulate a processing failure: For `PART_B`, there's a chance (e.g., always for simplicity in the exam) it fails processing. Throw a custom or standard exception (like `RuntimeException`) to indicate failure. Catch this exception and report the failure using `System.err`. Failed parts are *not* added to the completed list.
 * *   Successfully processed parts (A and C, and B if it *didn't* fail) are added to the completed items list.
 * *   Viewing status should print the current number of items in the queue and list the IDs and types of completed items.
 * 
 * **Expected Output Structure:**
 * 
 * The program should display a menu, accept user input, and print messages based on the chosen action. Error messages should appear on `System.err`.
 * 
 * ```
 * --- Assembly Line Menu ---
 * 1. Add Part to Queue
 * 2. Process Next Part
 * 3. View Line Status
 * 4. Exit
 * Enter choice: 1
 * Enter Part ID: 101
 * Enter Part Type (A, B, C): A
 * Part 101 (TYPE_A) added to queue.
 * 
 * --- Assembly Line Menu ---
 * 1. Add Part to Queue
 * ...
 * Enter choice: 2
 * Processing part 101 (TYPE_A)...
 * Part 101 (TYPE_A) successfully processed and moved to completed list.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 3
 * Current Queue Size: 0
 * Completed Parts:
 * [ID: 101, Type: TYPE_A]
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 2
 * Error: Queue is empty. Cannot process.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 1
 * Enter Part ID: 102
 * Enter Part Type (A, B, C): B
 * Part 102 (TYPE_B) added to queue.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 2
 * Processing part 102 (TYPE_B)...
 * Error processing part 102 (TYPE_B): Assembly failed!
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 3
 * Current Queue Size: 0
 * Completed Parts:
 * [ID: 101, Type: TYPE_A]
 * ```
 * 
 * Implement the solution in a single Java file.
 *
 * EXPLANATION:
 * The solution implements a simplified assembly line simulation, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Problem Structure:** The problem is broken down into three main classes: `ProductPart` (the data entity), `AssemblyLine` (manages the queue and completed list, contains processing logic), and `AssemblyLineSimulator` (handles user interaction and the main program flow).
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue`: A `LinkedList` is used as the concrete implementation for the `processingQueue` in the `AssemblyLine` class. The `offer()` method adds elements to the tail, and `poll()` retrieves and removes elements from the head, simulating the FIFO (First-In, First-Out) nature of a queue, suitable for an assembly line.
 *     *   `java.util.ArrayList`: Used as the concrete implementation for storing `completedParts`.
 *     *   `java.util.List`: The `completedParts` variable is declared as `List<ProductPart>`, demonstrating programming to the interface rather than the specific implementation (`ArrayList`). This provides flexibility if a different List implementation were needed later.
 * 
 * 3.  **Input and Output:**
 *     *   `java.util.Scanner`: An instance is created in the `AssemblyLineSimulator` class to read user input from the console. Input validation is performed (e.g., checking for `InputMismatchException` when reading numbers, validating part type strings). The `Scanner` is closed in the `finally` block of the `main` method to release system resources.
 *     *   `System.out`: Used for displaying the menu, success messages (part added, part processed), and the status report (queue size, completed parts list).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid user input or processing failures.
 * 
 * 4.  **Control Flow:**
 *     *   The `runSimulation` method in `AssemblyLineSimulator` uses a `do-while` loop to keep the simulation running until the user chooses to exit.
 *     *   A `switch` statement within the `runSimulation` loop handles the user's main menu choice (1, 2, 3, or 4), calling the appropriate helper method (`addPartToQueue`, `processNextPart`, `viewLineStatus`).
 *     *   Another `switch` statement within the `AssemblyLine.processNextPart` method determines the simulated processing logic based on the `ProductPartType` of the part being processed.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   `ProductPart` is a simple POJO (Plain Old Java Object) with private fields (`id`, `type`) and public getters, adhering to encapsulation. An `enum` `ProductPartType` is used for clarity and type safety for the part types.
 *     *   `AssemblyLine` encapsulates the core state (`processingQueue`, `completedParts`) and behavior (`addPart`, `processNextPart`, `getQueueSize`, `getCompletedParts`). This separates the simulation logic from the user interface handling.
 *     *   `AssemblyLineSimulator` acts as the controller, managing user interaction and delegating tasks to the `AssemblyLine` object.
 * 
 * 6.  **Error Handling:**
 *     *   **Input Validation:** The `getUserChoice` method handles `InputMismatchException` if the user enters non-integer input for the menu choice. The `addPartToQueue` method validates the part ID (positive integer) and part type (A, B, or C).
 *     *   **Processing Errors:** The `AssemblyLine.processNextPart` method throws an `IllegalStateException` if called when the queue is empty. It also simulates a processing failure for `PART_B` by throwing a `RuntimeException`.
 *     *   **`try-catch` Blocks:**
 *         *   A `try-catch` block wraps the entire `runSimulation` call in the `main` method. This provides a top-level, "class-wide" handling mechanism for any uncaught exceptions that might propagate up from the simulation logic.
 *         *   Specific `try-catch` blocks are used in `addPartToQueue` and `processNextPart` to catch expected exceptions (like `InputMismatchException`, `IllegalArgumentException` from the `ProductPart` constructor, `IllegalStateException` from the empty queue, and the simulated `RuntimeException` from processing failure). These specific catches allow for more targeted error reporting using `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Meaningful names are used (e.g., `processingQueue`, `completedParts`, `processNextPart`, `addPartToQueue`).
 *     *   Basic Javadoc comments are included for classes and key methods.
 *     *   Fields are private, accessed via public methods (getters).
 *     *   The `Scanner` is closed in a `finally` block.
 *     *   The `getCompletedParts` method returns a new `ArrayList` to prevent external code from modifying the internal `completedParts` list directly, promoting data integrity.
 * 
 * The solution effectively integrates all required components into a functional simulation, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in Java.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for part types
enum ProductPartType {
    PART_A,
    PART_B,
    PART_C,
    UNKNOWN; // For handling invalid input gracefully
}

// Class representing a product part
class ProductPart {
    private int id;
    private ProductPartType type;

    /**
     * Constructs a ProductPart.
     * @param id The unique identifier for the part.
     * @param type The type of the part.
     */
    public ProductPart(int id, ProductPartType type) {
        if (id <= 0) {
            throw new IllegalArgumentException("Part ID must be positive.");
        }
        if (type == null || type == ProductPartType.UNKNOWN) {
            throw new IllegalArgumentException("Part type cannot be null or UNKNOWN.");
        }
        this.id = id;
        this.type = type;
    }

    // Getters
    public int getId() {
        return id;
    }

    public ProductPartType getType() {
        return type;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Type: " + type + "]";
    }
}

// Class representing the assembly line
class AssemblyLine {
    private Queue<ProductPart> processingQueue;
    private List<ProductPart> completedParts;

    /**
     * Constructs an AssemblyLine.
     */
    public AssemblyLine() {
        // Use LinkedList as a Queue implementation
        this.processingQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedParts = new ArrayList<>();
    }

    /**
     * Adds a part to the end of the processing queue.
     * @param part The part to add.
     */
    public void addPart(ProductPart part) {
        processingQueue.offer(part); // offer is preferred over add in queues
        System.out.println("Part " + part.getId() + " (" + part.getType() + ") added to queue.");
    }

    /**
     * Processes the next part from the front of the queue.
     * @throws IllegalStateException if the queue is empty.
     * @throws RuntimeException if processing of a specific part type fails.
     */
    public void processNextPart() {
        ProductPart partToProcess = processingQueue.poll(); // poll retrieves and removes the head

        if (partToProcess == null) {
            throw new IllegalStateException("Queue is empty. Cannot process.");
        }

        System.out.println("Processing part " + partToProcess.getId() + " (" + partToProcess.getType() + ")...");

        // Use switch for different processing steps based on part type
        switch (partToProcess.getType()) {
            case PART_A:
                // Simulate successful processing for PART_A
                System.out.println("Processing Type A step completed.");
                completedParts.add(partToProcess);
                System.out.println("Part " + partToProcess.getId() + " successfully processed and moved to completed list.");
                break;
            case PART_B:
                // Simulate processing failure for PART_B
                System.out.println("Assembling Type B step...");
                // In a real scenario, this might be conditional. For the exam, simulate failure.
                throw new RuntimeException("Assembly failed!"); // Simulate a processing error

            case PART_C:
                // Simulate successful processing for PART_C
                System.out.println("Inspecting Type C step completed.");
                completedParts.add(partToProcess);
                System.out.println("Part " + partToProcess.getId() + " successfully processed and moved to completed list.");
                break;
            default:
                // This case should ideally not be reached if parts are created correctly
                System.err.println("Error: Unknown part type encountered: " + partToProcess.getType());
                // Do not add to completed list
                break;
        }
    }

    /**
     * Gets the current size of the processing queue.
     * @return The number of parts in the queue.
     */
    public int getQueueSize() {
        return processingQueue.size();
    }

    /**
     * Gets an unmodifiable list of completed parts.
     * @return A list of parts that have been successfully processed.
     */
    public List<ProductPart> getCompletedParts() {
        // Return a new ArrayList to prevent external modification of the internal list
        return new ArrayList<>(completedParts);
    }
}

// Main class to run the simulation
public class AssemblyLineSimulator {

    private static AssemblyLine assemblyLine = new AssemblyLine();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        // Class-wide exception handling around the main simulation loop
        try {
            runSimulation();
        } catch (Exception e) {
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Simulation ended.");
        }
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     */
    private static void runSimulation() {
        int choice;
        do {
            printMenu();
            choice = getUserChoice();

            // Use switch statement for menu control
            switch (choice) {
                case 1:
                    addPartToQueue();
                    break;
                case 2:
                    processNextPart();
                    break;
                case 3:
                    viewLineStatus();
                    break;
                case 4:
                    System.out.println("Exiting simulation.");
                    break;
                default:
                    System.err.println("Invalid choice. Please enter a number between 1 and 4.");
            }
            System.out.println(); // Add a newline for better readability

        } while (choice != 4);
    }

    /**
     * Prints the main menu to the console.
     */
    private static void printMenu() {
        System.out.println("--- Assembly Line Menu ---");
        System.out.println("1. Add Part to Queue");
        System.out.println("2. Process Next Part");
        System.out.println("3. View Line Status");
        System.out.println("4. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * @return The validated integer choice.
     */
    private static int getUserChoice() {
        try {
            return scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            return -1; // Return -1 to indicate an invalid choice
        } finally {
             scanner.nextLine(); // Consume the rest of the line after reading the integer
        }
    }

    /**
     * Handles the logic for adding a part based on user input.
     */
    private static void addPartToQueue() {
        try {
            System.out.print("Enter Part ID: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            System.out.print("Enter Part Type (A, B, C): ");
            String typeString = scanner.nextLine().trim().toUpperCase();
            ProductPartType type;

            // Validate part type input
            switch (typeString) {
                case "A":
                    type = ProductPartType.PART_A;
                    break;
                case "B":
                    type = ProductPartType.PART_B;
                    break;
                case "C":
                    type = ProductPartType.PART_C;
                    break;
                default:
                    System.err.println("Invalid part type entered. Please use A, B, or C.");
                    return; // Exit the method if type is invalid
            }

            // Create and add the part
            ProductPart newPart = new ProductPart(id, type);
            assemblyLine.addPart(newPart);

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid number for Part ID.");
            scanner.nextLine(); // Consume the invalid input
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating part: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding part: " + e.getMessage());
        }
    }

    /**
     * Handles the logic for processing the next part from the queue.
     */
    private static void processNextPart() {
        try {
            assemblyLine.processNextPart();
        } catch (IllegalStateException e) {
            System.err.println("Error: " + e.getMessage());
        } catch (RuntimeException e) { // Catch the simulated processing failure
            System.err.println("Error processing part: " + e.getMessage());
            // The failed part was already removed from the queue by poll()
            // and not added to completedParts. Nothing more needed here.
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while processing part: " + e.getMessage());
        }
    }

    /**
     * Displays the current status of the assembly line.
     */
    private static void viewLineStatus() {
        System.out.println("Current Queue Size: " + assemblyLine.getQueueSize());
        System.out.println("Completed Parts:");
        List<ProductPart> completed = assemblyLine.getCompletedParts();
        if (completed.isEmpty()) {
            System.out.println("  None");
        } else {
            for (ProductPart part : completed) {
                System.out.println("  " + part);
            }
        }
    }
}
