/*
 * Exam Question #935
 * Generated on: 2025-05-12 17:02:07
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Automated Job Processing System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line application for managing and processing jobs in an automated system. The system should allow users to submit new jobs, view jobs waiting to be processed, process the next job in the queue, and view completed jobs.
 * 
 * Your solution must demonstrate proficiency in core Java data structures, control flow, input/output, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Job Representation:** Create a `Job` class with the following attributes:
 *     *   `jobId` (int): A unique identifier for the job.
 *     *   `description` (String): A brief description of the job.
 *     *   Include appropriate getters and a constructor. Ensure proper encapsulation.
 * 
 * 2.  **Job Processing System:** Create a `JobProcessingSystem` class that manages the jobs. It must use:
 *     *   A `java.util.Queue<Job>` to store jobs waiting to be processed (the pending queue).
 *     *   A `java.util.List<Job>` (specifically using `java.util.ArrayList`) to store completed jobs.
 *     *   Provide public methods for the following operations:
 *         *   `submitJob(String description)`: Creates a new `Job` with a unique ID and adds it to the pending queue. Validate that the description is not null or empty.
 *         *   `viewPendingJobs()`: Displays the details of all jobs currently in the pending queue without removing them.
 *         *   `processNextJob()`: Removes the next job from the pending queue and adds it to the completed jobs list. Handles the case where the pending queue is empty.
 *         *   `viewCompletedJobs()`: Displays the details of all completed jobs. Handles the case where the completed list is empty.
 * 
 * 3.  **User Interface:** Implement a command-line interface in a `main` method (e.g., in a separate `JobSystemApp` class) using `java.util.Scanner`.
 *     *   Present a menu of options to the user:
 *         1.  Submit New Job
 *         2.  View Pending Jobs
 *         3.  Process Next Job
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Read the user's choice using `Scanner`.
 *     *   Use a `switch` statement to handle the user's selection and call the appropriate method in the `JobProcessingSystem`.
 *     *   The application should loop until the user chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., for invalid menu choices, invalid job descriptions, attempting to process an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `main` method to catch potential runtime errors during user interaction or processing.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper input validation where necessary (e.g., menu choice, job description).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Example interaction might look like:
 * 
 * ```
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Process report data
 * Job submitted with ID: 1
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Generate summary file
 * Job submitted with ID: 2
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Jobs ---
 * ID: 1, Description: Process report data
 * ID: 2, Description: Generate summary file
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * Processing job with ID: 1
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Jobs ---
 * ID: 2, Description: Generate summary file
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Jobs ---
 * ID: 1, Description: Process report data
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * Processing job with ID: 2
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * System.err: No jobs in the pending queue to process.
 * 
 * --- Job Processing System Menu ---
 * 1. Submit New Job
 * 2. View Pending Jobs
 * 3. Process Next Job
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 5
 * Exiting Job Processing System.
 * ```
 * 
 * Your solution should be a complete, runnable Java program.
 *
 * EXPLANATION:
 * The solution implements an Automated Job Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`Job` Class:** A simple class representing a job with `jobId` and `description`. It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print job details.
 * 
 * 2.  **`JobProcessingSystem` Class:**
 *     *   It uses a `Queue<Job>` (`pendingJobsQueue`) implemented by `LinkedList` to store jobs waiting to be processed. The `Queue` interface is ideal here because jobs are processed in the order they are submitted (First-In, First-Out).
 *     *   It uses a `List<Job>` (`completedJobsList`) implemented by `ArrayList` to store jobs that have been completed. An `ArrayList` is suitable as we might need to iterate through completed jobs or potentially access them by index (though not explicitly required by the problem, `List` is the requirement).
 *     *   `nextJobId` is a simple counter to ensure unique IDs for submitted jobs.
 *     *   `submitJob`: Takes a description, creates a `Job` object, and adds it to the `pendingJobsQueue` using `offer()`. It includes basic input validation for the description.
 *     *   `viewPendingJobs`: Iterates through the `pendingJobsQueue` using an `Iterator` (as required to view elements without removing them) and prints each job.
 *     *   `processNextJob`: Uses `pendingJobsQueue.poll()` to get and remove the next job. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it adds the removed job to the `completedJobsList`.
 *     *   `viewCompletedJobs`: Iterates through the `completedJobsList` using a for-each loop and prints each completed job.
 * 
 * 3.  **`JobSystemApp` Class (Main Application):**
 *     *   The `main` method contains the core application logic.
 *     *   A `Scanner` is initialized to read user input from `System.in`.
 *     *   A `JobProcessingSystem` instance is created.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop:
 *         *   `displayMenu()` shows the options.
 *         *   Input is read using `scanner.nextInt()`. Input validation checks if the input is an integer; if not, an error is printed to `System.err`, the invalid input is consumed, and the loop continues. `scanner.nextLine()` is called after `nextInt()` to consume the leftover newline character.
 *         *   A `switch` statement handles the user's numeric choice, calling the appropriate method on the `JobProcessingSystem` instance.
 *         *   Case 1 (`submitJob`) includes a nested `try-catch` to specifically handle the `IllegalArgumentException` thrown by the `submitJob` method for invalid descriptions, printing the error to `System.err`.
 *         *   Case 3 (`processNextJob`) implicitly handles the empty queue case via the logic within the `processNextJob` method itself, which prints to `System.err`.
 *         *   Case 5 sets the `running` flag to `false` to exit the loop.
 *         *   The `default` case of the `switch` handles invalid menu numbers, printing an error to `System.err`.
 * 
 * 4.  **Error Handling and I/O:**
 *     *   `System.out` is used for the menu, prompts, and normal output (job submissions, processing confirmations, job lists).
 *     *   `System.err` is used specifically for error messages (invalid input, empty queue processing, invalid description).
 *     *   A large `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This demonstrates class-wide exception handling, catching any *unexpected* runtime exceptions that might occur during the program's execution and printing an error message and stack trace.
 *     *   A `finally` block ensures that the `Scanner` is closed when the application exits, regardless of whether an exception occurred or the user exited normally.
 * 
 * 5.  **Best Practices:**
 *     *   Variable names (`pendingJobsQueue`, `completedJobsList`, `nextJobId`, `description`, `choice`) are descriptive.
 *     *   Method names (`submitJob`, `viewPendingJobs`, `processNextJob`, `viewCompletedJobs`, `displayMenu`) clearly indicate their purpose.
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation is performed for both the menu choice (checking if it's an integer and within range) and the job description (checking for null or empty).
 * 
 * This solution effectively integrates all the required Java components into a cohesive, practical application, demonstrating advanced understanding of data structures, control flow, error handling, and object-oriented design principles.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // To iterate over Queue

/**
 * Represents a single job in the processing system.
 */
class Job {
    private int jobId;
    private String description;

    /**
     * Constructs a new Job.
     * @param jobId The unique identifier for the job.
     * @param description A brief description of the job.
     */
    public Job(int jobId, String description) {
        this.jobId = jobId;
        this.description = description;
    }

    /**
     * Gets the job ID.
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the job description.
     * @return The job description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "ID: " + jobId + ", Description: " + description;
    }
}

/**
 * Manages the queue of pending jobs and a list of completed jobs.
 */
class JobProcessingSystem {
    private Queue<Job> pendingJobsQueue;
    private List<Job> completedJobsList;
    private int nextJobId; // Counter for unique job IDs

    /**
     * Constructs a new JobProcessingSystem.
     */
    public JobProcessingSystem() {
        // Use LinkedList as an implementation of Queue
        this.pendingJobsQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedJobsList = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new job to the pending queue.
     * @param description The description of the job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void submitJob(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        Job newJob = new Job(nextJobId++, description.trim());
        pendingJobsQueue.offer(newJob); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. Good practice.
        System.out.println("Job submitted with " + newJob);
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("--- Pending Jobs ---");
        if (pendingJobsQueue.isEmpty()) {
            System.out.println("No jobs in the pending queue.");
        } else {
            // Iterate over the queue without removing elements
            Iterator<Job> iterator = pendingJobsQueue.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        }
    }

    /**
     * Processes the next job from the pending queue, moving it to the completed list.
     */
    public void processNextJob() {
        Job jobToProcess = pendingJobsQueue.poll(); // poll() retrieves and removes the head, returns null if empty
        if (jobToProcess != null) {
            System.out.println("Processing job with " + jobToProcess);
            completedJobsList.add(jobToProcess);
        } else {
            // Use System.err for error message as required
            System.err.println("No jobs in the pending queue to process.");
        }
    }

    /**
     * Displays all jobs currently in the completed list.
     */
    public void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobsList.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate over the list
            for (Job job : completedJobsList) {
                System.out.println(job);
            }
        }
    }
}

/**
 * Main application class for the Job Processing System.
 */
public class JobSystemApp {

    /**
     * Displays the main menu options.
     */
    private static void displayMenu() {
        System.out.println("\n--- Job Processing System Menu ---");
        System.out.println("1. Submit New Job");
        System.out.println("2. View Pending Jobs");
        System.out.println("3. Process Next Job");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Job Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        JobProcessingSystem system = new JobProcessingSystem();
        boolean running = true;

        // Class-wide exception handling using try-catch
        try {
            while (running) {
                displayMenu();

                // Validate input is an integer
                int choice = -1;
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input to prevent infinite loop
                    String invalidInput = scanner.next();
                    System.err.println("Invalid input: '" + invalidInput + "'. Please enter a number.");
                    continue; // Skip to next loop iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        try {
                            system.submitJob(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error submitting job: " + e.getMessage());
                        }
                        break;
                    case 2:
                        system.viewPendingJobs();
                        break;
                    case 3:
                        system.processNextJob();
                        break;
                    case 4:
                        system.viewCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Job Processing System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application finished.");
        }
    }
}
