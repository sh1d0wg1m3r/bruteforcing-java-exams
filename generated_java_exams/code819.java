/*
 * Exam Question #819
 * Generated on: 2025-05-12 16:45:48
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Package Delivery Hub Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a package delivery hub's processing system. Packages arrive and are placed in a queue to await processing. The system allows hub workers to process the next available package, view packages currently waiting, or view a history of all packages received.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your program must meet the following requirements:
 * 
 * 1.  **Package Representation:** Create a class (can be an inner class or separate) to represent a `Package`. It should have the following private attributes:
 *     *   `packageId` (String, unique identifier)
 *     *   `packageType` (Enum, e.g., STANDARD, EXPRESS, FRAGILE)
 *     *   `destinationAddress` (String)
 *     *   `status` (Enum, e.g., WAITING, PROCESSED, ERROR)
 *     *   Include a constructor and appropriate public getter methods.
 * 
 * 2.  **Hub Management:** Create a main class (e.g., `DeliveryHubSimulation`) that manages the package flow. It must contain:
 *     *   A `Queue<Package>` to hold packages waiting for processing. Use `LinkedList` as the concrete implementation.
 *     *   A `List<Package>` (using `ArrayList`) to store a history of *all* packages that have entered the system (both waiting and processed). Use the `List` interface type for declaration.
 *     *   A method to add a new package to both the queue and the history list.
 *     *   A method to process the next package from the queue. This method should remove the package from the queue, update its status to `PROCESSED` in the history list, and print details to `System.out`. If the queue is empty, it should print an error message to `System.err`.
 *     *   A method to view all packages currently in the waiting queue (without removing them).
 *     *   A method to view the history of all packages received (from the list).
 * 
 * 3.  **User Interface:**
 *     *   Use `Scanner` to get user input from the console.
 *     *   Present a menu with options: Add Package, Process Next Package, View Pending Packages, View All Packages, Exit.
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation for user choices (e.g., menu option must be a valid number). Handle potential `InputMismatchException`.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, successful operations, and package details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. A single `try-catch` block around the main application loop that catches `Exception` is acceptable for demonstrating this requirement, though more specific catches within methods are also encouraged for robustness.
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Execution Flow:**
 * 
 * 1.  The program starts and displays the menu.
 * 2.  The user selects an option.
 * 3.  Based on the selection, the corresponding action is performed.
 * 4.  Input validation and error handling are applied.
 * 5.  The menu is displayed again until the user chooses to exit.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * --- Delivery Hub Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View All Packages History
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG123
 * Enter Package Type (STANDARD, EXPRESS, FRAGILE): EXPRESS
 * Enter Destination Address: 123 Main St
 * Package PKG123 added.
 * 
 * --- Delivery Hub Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View All Packages History
 * 5. Exit
 * Enter your choice: 2
 * Processing package PKG123 (EXPRESS) to 123 Main St. Status: PROCESSED.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 2
 * Error: No packages currently waiting in the queue.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 9
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * ```
 * 
 * Your solution must be a single `.java` file containing all necessary classes (main class, Package class, etc.).
 *
 * EXPLANATION:
 * This solution implements a `DeliveryHubSimulation` that manages packages using a `Queue` for pending items and a `List` for historical tracking.
 * 
 * 1.  **Package Class:**
 *     *   The `Package` class encapsulates package data (`packageId`, `packageType`, `destinationAddress`, `status`).
 *     *   It uses `enum`s (`PackageType`, `PackageStatus`) for type safety and readability, which is a good practice.
 *     *   Fields are `private`, and public getter methods are provided, demonstrating encapsulation.
 *     *   A `toString()` method is included for easy printing of package details.
 * 
 * 2.  **DeliveryHubSimulation Class:**
 *     *   This is the main class containing the program logic.
 *     *   It declares a `Queue<Package> packageQueue` initialized with `new LinkedList<>()`. This uses the `List` implementation `LinkedList` to provide `Queue` functionality (FIFO).
 *     *   It declares a `List<Package> allPackagesHistory` initialized with `new ArrayList<>()`. This demonstrates using the `List` interface type with a concrete `ArrayList` implementation for storing all packages received.
 *     *   A `Scanner` is used for reading user input.
 *     *   `packageCounter` is a simple way to generate unique IDs.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: `packageQueue` is used to store packages waiting to be processed. `offer()` adds to the queue, and `poll()` removes from the head (FIFO).
 *     *   `ArrayList`: `allPackagesHistory` is an `ArrayList` used to keep a record of every package added to the system.
 *     *   `List`: `allPackagesHistory` is declared using the `List` interface type. `viewPendingPackages` also creates a temporary `ArrayList` from the queue, demonstrating `ArrayList` usage and iteration over a collection.
 *     *   `Scanner`: Used in the `run()` method to read the user's menu choice and in `addNewPackage()` to read package details.
 *     *   `Switch statement`: The `switch (choice)` block in the `run()` method handles the different menu options selected by the user, directing execution flow.
 *     *   `System.err`: Used in the `processNextPackage()` method when the queue is empty and in the `run()` method for invalid menu choices or input errors.
 *     *   `System.out`: Used for displaying the menu, confirmation messages, and package details in `addNewPackage()`, `processNextPackage()`, `viewPendingPackages()`, and `viewAllPackagesHistory()`.
 *     *   `try-catch`:
 *         *   A main `try-catch(Exception e)` block wraps the core `while` loop in the `run()` method, demonstrating class-wide exception handling for unexpected errors.
 *         *   A nested `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice.
 *         *   A `try-catch(IllegalArgumentException e)` is used in `addNewPackage()` to validate the package type input.
 *         *   The `processNextPackage` method uses `poll()` which safely returns `null` if the queue is empty, avoiding a `NoSuchElementException` that `remove()` would throw, simplifying the error handling within that method.
 * 
 * 4.  **Functionality:**
 *     *   `displayMenu()`: Prints the options.
 *     *   `addNewPackage()`: Prompts for details, creates a `Package` object, adds it to both `packageQueue` and `allPackagesHistory`. Includes basic validation for package type and destination.
 *     *   `processNextPackage()`: Uses `packageQueue.poll()` to get the next package. If `poll()` returns `null`, it indicates an empty queue, and an error is printed to `System.err`. Otherwise, it updates the status of the processed package (the same object reference exists in both the queue and the history list) and prints details to `System.out`.
 *     *   `viewPendingPackages()`: Iterates over the `packageQueue` (by creating a temporary copy) and prints details of packages still waiting. It does *not* remove them from the queue.
 *     *   `viewAllPackagesHistory()`: Iterates over the `allPackagesHistory` `List` and prints details of all packages ever added.
 *     *   `run()`: Contains the main loop, displays the menu, reads input, uses the `switch` statement, and includes exception handling.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Package` class.
 *     *   Variable names (`packageQueue`, `allPackagesHistory`, `packageToProcess`) and method names (`addNewPackage`, `processNextPackage`) are descriptive.
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   Input validation is present for package type and menu choices.
 *     *   Error handling uses both `System.err` and `try-catch` blocks, including a top-level catch for demonstrating class-wide handling.
 *     *   The code is structured into methods for clarity and modularity.
 * 
 * This solution effectively demonstrates the required Java components within a practical simulation, incorporating best practices and error handling.
 */

import java.util.*; // Using * for brevity in exam context, normally import specific classes

/**
 * Represents a package managed by the delivery hub.
 */
class Package {
    private String packageId;
    private PackageType packageType;
    private String destinationAddress;
    private PackageStatus status;

    /**
     * Enum for different package types.
     */
    public enum PackageType {
        STANDARD, EXPRESS, FRAGILE
    }

    /**
     * Enum for package status.
     */
    public enum PackageStatus {
        WAITING, PROCESSED, ERROR // ERROR status could be used for failed processing, but not strictly required by prompt
    }

    /**
     * Constructs a new Package object.
     *
     * @param packageId The unique ID of the package.
     * @param packageType The type of the package.
     * @param destinationAddress The destination address.
     */
    public Package(String packageId, PackageType packageType, String destinationAddress) {
        this.packageId = packageId;
        this.packageType = packageType;
        this.destinationAddress = destinationAddress;
        this.status = PackageStatus.WAITING; // New packages start as WAITING
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public PackageType getPackageType() {
        return packageType;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public PackageStatus getStatus() {
        return status;
    }

    // --- Setters (only for status, as other fields are immutable after creation) ---
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Package ID: %s, Type: %s, Destination: %s, Status: %s",
                             packageId, packageType, destinationAddress, status);
    }
}

/**
 * Simulates a package delivery hub managing packages.
 */
public class DeliveryHubSimulation {

    private Queue<Package> packageQueue;
    private List<Package> allPackagesHistory;
    private Scanner scanner;
    private int packageCounter = 0; // Simple counter for unique IDs

    /**
     * Constructs a DeliveryHubSimulation.
     */
    public DeliveryHubSimulation() {
        // Use LinkedList as a Queue implementation
        packageQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        allPackagesHistory = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Delivery Hub Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Pending Packages");
        System.out.println("4. View All Packages History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package based on user input.
     */
    private void addNewPackage() {
        System.out.print("Enter Package Type (STANDARD, EXPRESS, FRAGILE): ");
        String typeInput = scanner.nextLine().trim().toUpperCase();
        Package.PackageType packageType;
        try {
            packageType = Package.PackageType.valueOf(typeInput);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: Invalid package type entered.");
            return; // Exit method if type is invalid
        }

        System.out.print("Enter Destination Address: ");
        String destination = scanner.nextLine().trim();
        if (destination.isEmpty()) {
            System.err.println("Error: Destination address cannot be empty.");
            return;
        }

        // Generate a simple unique ID
        String packageId = "PKG" + (++packageCounter);

        Package newPackage = new Package(packageId, packageType, destination);

        // Add to both queue and history
        packageQueue.offer(newPackage); // offer() is preferred over add() for capacity-constrained queues, but safe here.
        allPackagesHistory.add(newPackage);

        System.out.println("Package " + packageId + " added.");
    }

    /**
     * Processes the next package from the queue.
     */
    private void processNextPackage() {
        // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        Package packageToProcess = packageQueue.poll();

        if (packageToProcess == null) {
            System.err.println("Error: No packages currently waiting in the queue.");
        } else {
            // Find the package in the history list and update its status
            // Using its ID assuming IDs are unique and packages in history are the same objects or equivalent
            for (Package p : allPackagesHistory) {
                if (p.getPackageId().equals(packageToProcess.getPackageId())) {
                    p.setStatus(Package.PackageStatus.PROCESSED);
                    break; // Found and updated
                }
            }
            // Alternatively, if the object references are the same (which they are in this design):
            // packageToProcess.setStatus(Package.PackageStatus.PROCESSED);
            // No need to search allPackagesHistory if we know the dequeued object is also in the list.
            packageToProcess.setStatus(Package.PackageStatus.PROCESSED);


            System.out.println("Processing package " + packageToProcess.getPackageId() +
                               " (" + packageToProcess.getPackageType() + ")" +
                               " to " + packageToProcess.getDestinationAddress() +
                               ". Status: " + packageToProcess.getStatus() + ".");
        }
    }

    /**
     * Displays packages currently waiting in the queue.
     */
    private void viewPendingPackages() {
        System.out.println("\n--- Pending Packages ---");
        if (packageQueue.isEmpty()) {
            System.out.println("No packages currently waiting.");
        } else {
            // Iterate through the queue without removing elements
            // Converting to a List for easy iteration is one way, or use an Iterator
            // List is easier for simple iteration and printing
            List<Package> pendingList = new ArrayList<>(packageQueue);
            for (int i = 0; i < pendingList.size(); i++) {
                System.out.println((i + 1) + ". " + pendingList.get(i));
            }
        }
    }

    /**
     * Displays the history of all packages received.
     */
    private void viewAllPackagesHistory() {
        System.out.println("\n--- All Packages History ---");
        if (allPackagesHistory.isEmpty()) {
            System.out.println("No packages have been received yet.");
        } else {
            for (int i = 0; i < allPackagesHistory.size(); i++) {
                System.out.println((i + 1) + ". " + allPackagesHistory.get(i));
            }
        }
    }

    /**
     * Runs the main simulation loop.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for flow control
                    switch (choice) {
                        case 1:
                            addNewPackage();
                            break;
                        case 2:
                            processNextPackage();
                            break;
                        case 3:
                            viewPendingPackages();
                            break;
                        case 4:
                            viewAllPackagesHistory();
                            break;
                        case 5:
                            System.out.println("Exiting Delivery Hub Simulation. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
            }
        } catch (Exception e) {
            // Generic catch for any unexpected errors during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to stderr for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliveryHubSimulation simulation = new DeliveryHubSimulation();
        simulation.run();
    }
}
