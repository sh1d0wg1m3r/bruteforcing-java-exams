/*
 * Exam Question #527
 * Generated on: 2025-05-11 23:24:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Print Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Print Queue Management System. This system should allow users to submit print jobs, view the current queue, check the status of any job, cancel pending jobs, and simulate processing the next job in the queue. The system needs to handle multiple jobs and manage their states.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Print Job Representation:** Create a class `PrintJob` to represent a print job. It should have:
 *     *   A unique integer `jobId`.
 *     *   A `String` for the `userName` who submitted the job.
 *     *   A `String` for the `fileName` to be printed.
 *     *   A status indicating its current state. Use an `enum` called `PrintJobStatus` with states like `PENDING`, `PRINTING` (or `COMPLETED` for simplicity in this simulation), and `CANCELLED`.
 *     *   Appropriate private fields and public getter methods.
 *     *   A method to update the job status (e.g., `setStatus(PrintJobStatus status)`).
 *     *   A `toString()` method for easy display of job details.
 * 
 * 2.  **Queue Management:** Create a class `PrintQueueManager` that manages the print jobs. It must use:
 *     *   A `java.util.Queue<PrintJob>` to store jobs that are currently waiting to be printed (`PENDING`).
 *     *   A `java.util.List<PrintJob>` (using `java.util.ArrayList`) to store a history of *all* submitted jobs, regardless of their current status. This list is used for looking up job status by ID and listing all jobs.
 *     *   A mechanism to generate unique job IDs (e.g., a simple counter).
 * 
 * 3.  **Functionality (via Menu):** The `PrintQueueManager` should provide methods for the following operations, and the main program should provide a text-based menu interface using `java.util.Scanner` and a `switch` statement:
 *     *   **1. Submit New Job:** Prompt the user for user name and file name, create a `PrintJob`, add it to both the pending queue and the history list.
 *     *   **2. View Pending Queue:** Display the details of all jobs currently in the pending queue, in the order they will be processed.
 *     *   **3. View All Jobs (History):** Display the details of all jobs ever submitted, including their current status.
 *     *   **4. View Job Status by ID:** Prompt the user for a job ID, find the job in the history list, and display its details and status. If the job is not found, report an error.
 *     *   **5. Cancel Job by ID:** Prompt the user for a job ID. Find the job in the history list. If found and its status is `PENDING`, change its status to `CANCELLED`. If the job is not found or is not `PENDING`, report an error. Note: You don't need to *remove* the job from the `Queue` immediately; the `processNextJob` method will handle skipping cancelled jobs when they reach the front.
 *     *   **6. Process Next Job:** Take the next job from the pending queue. If the queue is not empty and the polled job's status is `PENDING`, change its status to `COMPLETED` (simulating printing) and report which job was processed. If the queue is empty, report that. If the polled job's status is `CANCELLED`, report that it was skipped.
 *     *   **7. Exit:** Terminate the program.
 * 
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, especially around user input (e.g., non-integer input when an integer is expected).
 *     *   Use `System.err.println()` to display error messages (e.g., "Invalid input.", "Job not found.", "Cannot cancel job.").
 *     *   Use `System.out.println()` for normal output (menu, job details, success messages).
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain key parts of the code.
 *     *   Validate user input where necessary (e.g., ensuring job ID is a number).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, and providing feedback based on the operations performed. Error messages should go to standard error, and normal output to standard output.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Print Queue Menu ---
 * 1. Submit New Job
 * 2. View Pending Queue
 * 3. View All Jobs (History)
 * 4. View Job Status by ID
 * 5. Cancel Job by ID
 * 6. Process Next Job
 * 7. Exit
 * Enter your choice: 1
 * Enter user name: alice
 * Enter file name: document.pdf
 * Job 1 submitted for alice (document.pdf).
 * 
 * --- Print Queue Menu ---
 * 1. Submit New Job
 * ...
 * Enter your choice: 1
 * Enter user name: bob
 * Enter file name: image.png
 * Job 2 submitted for bob (image.png).
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 2
 * --- Pending Queue ---
 * [Job 1] alice - document.pdf [PENDING]
 * [Job 2] bob - image.png [PENDING]
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 6
 * Processing job 1 for alice (document.pdf)... Status set to COMPLETED.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 2
 * --- Pending Queue ---
 * [Job 2] bob - image.png [PENDING]
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 5
 * Enter Job ID to cancel: 2
 * Job 2 cancelled by bob (image.png). Status set to CANCELLED.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 6
 * Skipping job 2 for bob (image.png) - Status is CANCELLED.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 3
 * --- All Jobs History ---
 * [Job 1] alice - document.pdf [COMPLETED]
 * [Job 2] bob - image.png [CANCELLED]
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 7
 * Exiting Print Queue System.
 * ```
 * 
 * **Note:** The exact output formatting for lists can vary, but should clearly show the job ID, user, file, and status.
 *
 * EXPLANATION:
 * This solution implements a simplified Print Queue Management System using the required Java components and demonstrating several advanced concepts and best practices.
 * 
 * 1.  **PrintJob Class:**
 *     *   Represents the data structure for a print job.
 *     *   Uses private fields (`jobId`, `userName`, `fileName`, `status`) for encapsulation.
 *     *   Provides public getter methods to access the data.
 *     *   Includes a `setStatus` method to allow controlled modification of the job's state.
 *     *   Uses an `enum` (`PrintJobStatus`) for clear and type-safe representation of job states (`PENDING`, `COMPLETED`, `CANCELLED`).
 *     *   Overrides `toString()` for convenient printing of job details.
 * 
 * 2.  **PrintQueueManager Class:**
 *     *   This is the core class managing the system's state.
 *     *   **`java.util.Queue<PrintJob> pendingJobsQueue`**: A `Queue` (specifically implemented using `LinkedList`) is used to store jobs waiting to be processed. The `Queue` interface provides methods like `offer()` (add to end), `peek()` (view head), and `poll()` (remove head), which are ideal for managing a waiting line of tasks in FIFO (First-In, First-Out) order.
 *     *   **`java.util.List<PrintJob> allJobsHistory`**: A `List` (specifically implemented using `ArrayList`) is used to keep track of *all* jobs ever submitted. This allows looking up jobs by ID regardless of whether they are pending, completed, or cancelled. Using the `List` interface for the variable type is good practice, allowing flexibility to change the implementation later if needed.
 *     *   **Encapsulation:** Both the queue and the history list are private fields, accessed and modified only through the manager's public methods.
 *     *   **Methods:** Each public method (`submitJob`, `viewPendingQueue`, etc.) performs a specific operation, interacting with the queue and history list as needed.
 *     *   **`findJobById`**: A private helper method demonstrates searching within the `ArrayList` history.
 * 
 * 3.  **Main Class (`PrintQueueSystem`):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   **`java.util.Scanner`**: Used to read user input from the console.
 *     *   **`switch` statement**: Controls the flow of the program based on the user's menu choice, directing execution to the appropriate `PrintQueueManager` method.
 *     *   **Menu Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   **`try-catch` blocks**: Used extensively, particularly around `scanner.nextInt()` calls, to catch `InputMismatchException` if the user enters non-integer input when a number is expected (like the menu choice or a job ID).
 *     *   **Class-wide `try-catch`**: The main `while` loop is wrapped in a large `try-catch` block. This demonstrates catching any unexpected exceptions that might occur during the program's execution, preventing the program from crashing abruptly and providing a basic error message and stack trace for debugging.
 *     *   **Specific Error Checks:** Inside manager methods (e.g., `viewJobStatus`, `cancelJob`, `processNextJob`), explicit checks are made for conditions like "job not found," "queue is empty," or "job status not eligible for cancellation."
 *     *   **`System.err`**: Error messages generated by invalid user actions or system errors are printed to `System.err`, distinguishing them from normal program output which goes to `System.out`.
 * 
 * 5.  **Best Practices Demonstrated:**
 *     *   **Encapsulation:** Achieved by making class fields private and providing public methods for interaction.
 *     *   **Meaningful Names:** Variables (`pendingJobsQueue`, `allJobsHistory`, `nextJobId`), methods (`submitJob`, `processNextJob`, `cancelJob`), and classes (`PrintJob`, `PrintQueueManager`) are named clearly.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** The code checks if user input for numbers is valid using `try-catch` and prompts the user again if invalid.
 *     *   **Clean Structure:** The code is organized into separate classes with distinct responsibilities (`PrintJob` for data, `PrintQueueManager` for logic, `PrintQueueSystem` for the user interface). The `printMenu` method is separated for clarity.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to release the underlying system resource.
 * 
 * This solution effectively uses the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating good object-oriented design, error handling, and fundamental data structure manipulation. The interaction between the `Queue` (for processing order) and the `List` (for overall history lookup) is a key aspect of the design. The handling of job cancellation by changing status rather than immediate queue removal simplifies the queue logic while still achieving the desired behavior when the job is eventually polled.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Print Job Status
enum PrintJobStatus {
    PENDING,
    COMPLETED, // Simplified: Directly to COMPLETED instead of PRINTING then COMPLETED
    CANCELLED
}

// Represents a single Print Job
class PrintJob {
    private int jobId;
    private String userName;
    private String fileName;
    private PrintJobStatus status;

    public PrintJob(int jobId, String userName, String fileName) {
        this.jobId = jobId;
        this.userName = userName;
        this.fileName = fileName;
        this.status = PrintJobStatus.PENDING; // New jobs start as PENDING
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getUserName() {
        return userName;
    }

    public String getFileName() {
        return fileName;
    }

    public PrintJobStatus getStatus() {
        return status;
    }

    // Method to update status
    public void setStatus(PrintJobStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[Job " + jobId + "] " + userName + " - " + fileName + " [" + status + "]";
    }
}

// Manages the Print Queue and Job History
class PrintQueueManager {
    private Queue<PrintJob> pendingJobsQueue;
    private List<PrintJob> allJobsHistory; // Using List interface, implemented by ArrayList
    private int nextJobId;

    public PrintQueueManager() {
        this.pendingJobsQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allJobsHistory = new ArrayList<>(); // ArrayList implements List
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new print job.
     * Adds the job to both the pending queue and the history.
     * @param userName The user submitting the job.
     * @param fileName The name of the file to print.
     */
    public void submitJob(String userName, String fileName) {
        PrintJob newJob = new PrintJob(nextJobId++, userName, fileName);
        pendingJobsQueue.offer(newJob); // Add to the end of the queue
        allJobsHistory.add(newJob);    // Add to the history list
        System.out.println("Job " + newJob.getJobId() + " submitted for " + userName + " (" + fileName + ").");
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingQueue() {
        if (pendingJobsQueue.isEmpty()) {
            System.out.println("The pending queue is empty.");
            return;
        }
        System.out.println("--- Pending Queue ---");
        // Iterate through the queue without removing elements
        for (PrintJob job : pendingJobsQueue) {
            System.out.println(job);
        }
    }

    /**
     * Displays all jobs ever submitted (history).
     */
    public void viewAllJobs() {
        if (allJobsHistory.isEmpty()) {
            System.out.println("No jobs have been submitted yet.");
            return;
        }
        System.out.println("--- All Jobs History ---");
        for (PrintJob job : allJobsHistory) {
            System.out.println(job);
        }
    }

    /**
     * Finds and displays the status of a job by its ID.
     * @param jobId The ID of the job to find.
     */
    public void viewJobStatus(int jobId) {
        PrintJob job = findJobById(jobId);
        if (job == null) {
            System.err.println("Error: Job with ID " + jobId + " not found.");
        } else {
            System.out.println("Job Status: " + job);
        }
    }

    /**
     * Cancels a pending job by its ID.
     * A job can only be cancelled if its status is PENDING.
     * @param jobId The ID of the job to cancel.
     */
    public void cancelJob(int jobId) {
        PrintJob job = findJobById(jobId);
        if (job == null) {
            System.err.println("Error: Job with ID " + jobId + " not found.");
            return;
        }

        if (job.getStatus() == PrintJobStatus.PENDING) {
            job.setStatus(PrintJobStatus.CANCELLED);
            System.out.println("Job " + jobId + " cancelled by " + job.getUserName() + " (" + job.getFileName() + "). Status set to CANCELLED.");
            // Note: The job remains in the queue but will be skipped by processNextJob
        } else {
            System.err.println("Error: Job " + jobId + " cannot be cancelled. Current status is " + job.getStatus() + ".");
        }
    }

    /**
     * Simulates processing the next job in the queue.
     * Polls the next job, checks its status, and updates it if PENDING.
     */
    public void processNextJob() {
        PrintJob nextJob = pendingJobsQueue.peek(); // Look at the head without removing
        if (nextJob == null) {
            System.out.println("The pending queue is empty. Nothing to process.");
            return;
        }

        // Now poll (remove) from the queue
        nextJob = pendingJobsQueue.poll();

        // Check the status of the polled job
        if (nextJob.getStatus() == PrintJobStatus.PENDING) {
            nextJob.setStatus(PrintJobStatus.COMPLETED);
            System.out.println("Processing job " + nextJob.getJobId() + " for " + nextJob.getUserName() + " (" + nextJob.getFileName() + ")... Status set to COMPLETED.");
        } else if (nextJob.getStatus() == PrintJobStatus.CANCELLED) {
            System.out.println("Skipping job " + nextJob.getJobId() + " for " + nextJob.getUserName() + " (" + nextJob.getFileName() + ") - Status is CANCELLED.");
            // Job was cancelled while in queue, just discard it from the queue
        }
        // Note: Jobs with status COMPLETED shouldn't be in the pending queue,
        // so no need to handle that case here.
    }

    /**
     * Helper method to find a job by its ID in the history list.
     * @param jobId The ID to search for.
     * @return The PrintJob object if found, otherwise null.
     */
    private PrintJob findJobById(int jobId) {
        for (PrintJob job : allJobsHistory) {
            if (job.getJobId() == jobId) {
                return job;
            }
        }
        return null; // Job not found
    }
}

// Main class to run the application with a menu
public class PrintQueueSystem {

    public static void main(String[] args) {
        PrintQueueManager manager = new PrintQueueManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter user name: ");
                        String userName = scanner.nextLine();
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        manager.submitJob(userName, fileName);
                        break;
                    case 2:
                        manager.viewPendingQueue();
                        break;
                    case 3:
                        manager.viewAllJobs();
                        break;
                    case 4:
                        try {
                            System.out.print("Enter Job ID to view status: ");
                            int viewJobId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            manager.viewJobStatus(viewJobId);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid Job ID (number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 5:
                        try {
                            System.out.print("Enter Job ID to cancel: ");
                            int cancelJobId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            manager.cancelJob(cancelJobId);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid Job ID (number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 6:
                        manager.processNextJob();
                        break;
                    case 7:
                        running = false;
                        System.out.println("Exiting Print Queue System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Ensure the scanner is closed
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Print Queue Menu ---");
        System.out.println("1. Submit New Job");
        System.out.println("2. View Pending Queue");
        System.out.println("3. View All Jobs (History)");
        System.out.println("4. View Job Status by ID");
        System.out.println("5. Cancel Job by ID");
        System.out.println("6. Process Next Job");
        System.out.println("7. Exit");
    }
}
