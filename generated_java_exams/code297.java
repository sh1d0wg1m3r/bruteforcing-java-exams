/*
 * Exam Question #297
 * Generated on: 2025-05-11 22:51:17
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Scheduler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a basic task scheduler. The scheduler manages two types of tasks: CPU-bound ('C') and I/O-bound ('I'). Users can submit new tasks, process the next task waiting, view tasks currently pending, or view tasks that have been completed.
 * 
 * **Task Requirements:**
 * 
 * 1.  **`Task` Class:** Create a class named `Task` with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `type` (char): Represents the task type ('C' for CPU-bound, 'I' for I/O-bound).
 *     *   Provide a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task.
 * 
 * 2.  **`TaskSchedulerApp` Class:** Create a main class named `TaskSchedulerApp` that contains the `main` method and the core application logic.
 *     *   Maintain a collection of tasks waiting to be processed using a `Queue<Task>`. Tasks should be processed in the order they were submitted (FIFO).
 *     *   Maintain a collection of completed tasks using a `List<Task>`. This list should store tasks after they have been processed. Use `ArrayList` as the concrete implementation for this list, but declare the variable using the `List` interface type.
 *     *   Use a `Scanner` object to read user input from the console for menu choices and task details.
 *     *   Implement a main application loop that presents a menu to the user with the following options:
 *         1.  Submit New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         0.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   **Submit New Task:**
 *         *   Prompt the user for the task description and type ('C' or 'I').
 *         *   Automatically assign a unique `taskId` (e.g., starting from 1 and incrementing for each new task).
 *         *   Validate that the task description is not empty and the type is either 'C' or 'I' (case-insensitive). If validation fails, print an error message and do not create/add the task.
 *         *   Create a new `Task` object and add it to the pending tasks `Queue`.
 *         *   Print a confirmation message including the task details.
 *     *   **Process Next Task:**
 *         *   Attempt to retrieve the next task from the pending tasks `Queue`.
 *         *   If the queue is empty, print a message indicating no pending tasks.
 *         *   If a task is retrieved, simulate processing:
 *             *   Print a message indicating which task is being processed.
 *             *   Simulate processing time using `Thread.sleep()`. Simulate a longer time (e.g., 1500 ms) for 'C' tasks and a shorter time (e.g., 500 ms) for 'I' tasks. Handle potential `InterruptedException`.
 *             *   After simulation, remove the task from the pending queue (this is done by `poll()`).
 *             *   Add the completed task to the completed tasks `List`.
 *             *   Print a message indicating the task is completed.
 *     *   **View Pending Tasks:**
 *         *   Print a list of all tasks currently in the pending queue. If the queue is empty, print a message indicating that. Do not remove tasks from the queue when viewing.
 *     *   **View Completed Tasks:**
 *         *   Print a list of all tasks in the completed tasks list. If the list is empty, print a message indicating that.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid task input, processing errors).
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential exceptions during the application's execution, including handling non-integer input for menu choices and exceptions during task processing simulation. Ensure the `Scanner` is closed properly using a `finally` block or try-with-resources (though a single `finally` at the top level is sufficient for the class-wide requirement).
 * 
 * 4.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods where needed).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain key parts of the code.
 *     *   Follow consistent code formatting.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying the menu and responding to choices. Error messages should appear on the standard error stream.
 * 
 * ```
 * --- Simple Task Scheduler ---
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 1
 * --- Submit New Task ---
 * Assigning Task ID: 1
 * Enter task description: Perform complex calculation
 * Enter task type (C for CPU, I for I/O): C
 * Task submitted successfully: Task [ID=1, Desc='Perform complex calculation', Type=C]
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 1
 * --- Submit New Task ---
 * Assigning Task ID: 2
 * Enter task description: Read data from file
 * Enter task type (C for CPU, I for I/O): I
 * Task submitted successfully: Task [ID=2, Desc='Read data from file', Type=I]
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Pending tasks (2):
 * 1. Task [ID=1, Desc='Perform complex calculation', Type=C]
 * 2. Task [ID=2, Desc='Read data from file', Type=I]
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 2
 * --- Processing Next Task ---
 * Processing: Task [ID=1, Desc='Perform complex calculation', Type=C]
 * Simulating CPU-bound task...
 * Task completed: 1
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 2
 * --- Processing Next Task ---
 * Processing: Task [ID=2, Desc='Read data from file', Type=I]
 * Simulating I/O-bound task...
 * Task completed: 2
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * No tasks currently pending.
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Completed tasks (2):
 * 1. Task [ID=1, Desc='Perform complex calculation', Type=C]
 * 2. Task [ID=2, Desc='Read data from file', Type=I]
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 99
 * Invalid choice. Please enter a number between 0 and 4.
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Scheduler Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 0
 * Exiting Task Scheduler. Goodbye!
 * Scanner closed.
 * ```
 * 
 * This task requires integrating several core Java concepts and standard library components in a practical, interactive application, demonstrating understanding of data structures, control flow, I/O, and error handling.
 *
 * EXPLANATION:
 * The provided solution implements a simple task scheduler simulation, demonstrating the required Java concepts and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It uses private fields (`taskId`, `description`, `type`) to enforce encapsulation.
 *     *   Public getter methods provide controlled access to the task's attributes.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskSchedulerApp` Class:**
 *     *   This is the main application class containing the `main` method.
 *     *   **`pendingTasks` (`Queue<Task>`):** A `LinkedList` is used here because it implements the `Queue` interface, providing FIFO behavior suitable for a waiting queue. Tasks are added using `offer()` and removed using `poll()`.
 *     *   **`completedTasks` (`List<Task>`):** An `ArrayList` is used as the concrete implementation, but the variable is declared as the `List` interface type (`List<Task> completedTasks = new ArrayList<>();`). This demonstrates programming to an interface, which is a good practice for flexibility. Completed tasks are simply added to this list.
 *     *   **`scanner` (`Scanner`):** Used to read input from `System.in`. It's initialized once and closed in the `finally` block. Reading input as `nextLine()` and then parsing (`Integer.parseInt`) is used to avoid common issues when mixing `nextInt()`, `nextLine()`, etc.
 *     *   **`nextTaskId`:** A simple counter to ensure unique IDs for submitted tasks.
 *     *   **`run()` Method:** This method contains the main application loop.
 *         *   It uses a `while` loop to keep the application running until the user chooses to exit.
 *         *   A `displayMenu()` method is called to show options.
 *         *   User input is read and parsed.
 *         *   A `switch` statement effectively directs the program flow based on the user's integer choice, calling the appropriate handler methods (`submitTask`, `processNextTask`, etc.).
 *         *   The `default` case in the `switch` handles invalid numeric choices.
 *     *   **`submitTask()`:** Handles user input for creating a new task. It includes input validation for description (not empty) and type ('C' or 'I'), printing errors to `System.err` if validation fails. It creates a `Task` object and adds it to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask()`:** Retrieves the next task from the queue using `poll()`. `poll()` is crucial as it returns `null` if the queue is empty, preventing a `NoSuchElementException` that `remove()` would throw. It simulates processing time using `Thread.sleep()`, demonstrating handling of `InterruptedException`. After processing simulation, the task is added to the `completedTasks` list.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`:** These methods iterate through the respective collections and print task details. `viewPendingTasks` iterates without removing elements from the queue.
 *     *   **Exception Handling:**
 *         *   A `try-catch` block wraps the main `while` loop in `run()`. This serves as the "class-wide" or application-level exception handling, catching any unexpected errors that might occur during the main execution flow.
 *         *   An inner `try-catch` block within the `run()` loop specifically handles `NumberFormatException` for menu input, ensuring the program doesn't crash on non-integer input. It also catches a general `Exception` for errors occurring during the execution of the selected menu action. Error messages are printed to `System.err`.
 *         *   The `processNextTask()` method has a `try-catch` specifically for `InterruptedException` caused by `Thread.sleep()`.
 *         *   A `finally` block in `run()` ensures that the `Scanner` resource is always closed when the application exits or terminates due to an exception, preventing resource leaks.
 *     *   **System.out vs. System.err:** Correctly used throughout the application to distinguish between normal informational output and error messages.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design (encapsulation), input validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Although poll() returns null, good to be aware

/**
 * Represents a single task with an ID, description, and type.
 */
class Task {
    private int taskId;
    private String description;
    private char type; // 'C' for CPU, 'I' for I/O

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param type The type of task ('C' or 'I').
     */
    public Task(int taskId, String description, char type) {
        this.taskId = taskId;
        this.description = description;
        this.type = type;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public char getType() {
        return type;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Type=" + type + "]";
    }
}

/**
 * Main application class for the Simple Task Scheduler.
 * Manages pending and completed tasks using Queue and List.
 */
public class TaskSchedulerApp {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;
    // Counter for assigning unique task IDs
    private int nextTaskId = 1;

    /**
     * Constructs a new TaskSchedulerApp, initializing data structures and scanner.
     */
    public TaskSchedulerApp() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskSchedulerApp app = new TaskSchedulerApp();
        app.run();
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Simple Task Scheduler ---");
        try { // Class-wide try block for handling potential exceptions during main execution
            int choice = -1;
            // Continue loop until user chooses to exit (choice 0)
            while (choice != 0) {
                displayMenu();
                System.out.print("Enter your choice: ");

                try { // Try block for handling exceptions within the menu loop (e.g., bad input)
                    // Read the entire line to avoid issues with nextInt() followed by nextLine()
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine); // Attempt to parse as integer

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            submitTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 0:
                            System.out.println("Exiting Task Scheduler. Goodbye!");
                            break;
                        default:
                            // Invalid number outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                    }
                } catch (NumberFormatException e) {
                    // Handles cases where input is not a valid integer
                    System.err.println("Invalid input. Please enter a number.");
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during a menu action
                    System.err.println("An error occurred during operation: " + e.getMessage());
                    // Optional: e.printStackTrace(); // Uncomment for detailed debugging info
                }
                System.out.println(); // Add a newline for better readability between menu interactions
            }
        } catch (Exception mainLoopException) {
            // Catch any critical exceptions that escape the inner handling
            System.err.println("A critical error occurred during application execution: " + mainLoopException.getMessage());
            // Optional: mainLoopException.printStackTrace();
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner closed."); // Optional confirmation message
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("Scheduler Menu:");
        System.out.println("1. Submit New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("0. Exit");
    }

    /**
     * Handles the submission of a new task based on user input.
     */
    private void submitTask() {
        System.out.println("--- Submit New Task ---");
        String description = "";
        char type = ' ';

        // Assign the next available task ID
        int currentTaskId = nextTaskId++;
        System.out.println("Assigning Task ID: " + currentTaskId);

        // Get task description
        System.out.print("Enter task description: ");
        description = scanner.nextLine();

        // Validate description
        if (description.trim().isEmpty()) {
             System.err.println("Task description cannot be empty. Task submission failed.");
             nextTaskId--; // Revert the task ID increment if submission fails
             return; // Exit the method
        }

        // Get and validate task type
        while (true) { // Loop until valid input is received
            System.out.print("Enter task type (C for CPU, I for I/O): ");
            String typeInput = scanner.nextLine().trim().toUpperCase(); // Read, trim whitespace, convert to uppercase
            if (typeInput.length() == 1 && (typeInput.charAt(0) == 'C' || typeInput.charAt(0) == 'I')) {
                type = typeInput.charAt(0);
                break; // Valid input received, exit validation loop
            } else {
                System.err.println("Invalid task type. Please enter 'C' or 'I'.");
            }
        }

        // Create the new Task object
        Task newTask = new Task(currentTaskId, description, type);
        // Add the new task to the pending tasks queue
        pendingTasks.offer(newTask); // offer() is the preferred method for adding to queues

        System.out.println("Task submitted successfully: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     */
    private void processNextTask() {
        System.out.println("--- Processing Next Task ---");
        // Retrieve and remove the head of the queue. poll() returns null if the queue is empty.
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            System.out.println("No pending tasks to process.");
        } else {
            System.out.println("Processing: " + taskToProcess);
            try {
                // Simulate processing time based on task type
                if (taskToProcess.getType() == 'C') {
                    System.out.println("Simulating CPU-bound task (1500ms)...");
                    Thread.sleep(1500); // Simulate 1.5 seconds for CPU tasks
                } else { // Type 'I'
                    System.out.println("Simulating I/O-bound task (500ms)...");
                    Thread.sleep(500); // Simulate 0.5 seconds for I/O tasks
                }
                System.out.println("Task completed: " + taskToProcess.getTaskId());
                // Add the processed task to the completed tasks list
                completedTasks.add(taskToProcess);
            } catch (InterruptedException e) {
                // Handle interruption during sleep
                System.err.println("Task processing interrupted for task ID " + taskToProcess.getTaskId() + ": " + e.getMessage());
                // In a real system, you might decide to re-queue the task or log the interruption.
                // For this simulation, we just report it and the task is not added to completed.
            } catch (Exception e) {
                 // Catch any other unexpected errors during the processing simulation
                 System.err.println("An error occurred during processing simulation for task ID " + taskToProcess.getTaskId() + ": " + e.getMessage());
                 // Decide how to handle: discard, requeue? For simplicity, we discard.
            }
        }
    }

    /**
     * Displays all tasks currently waiting in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            System.out.println("Pending tasks (" + pendingTasks.size() + "):");
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("Completed tasks (" + completedTasks.size() + "):");
            // Iterate through the completed tasks list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }
}
