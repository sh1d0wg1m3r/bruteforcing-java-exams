/*
 * Exam Question #237
 * Generated on: 2025-05-11 22:37:18
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Processing System
 * 
 * **Objective:**
 * 
 * Design and implement a console-based application that simulates a simple document processing workflow. The system should allow users to add documents to a processing queue, process the next document in the queue, and view the history of processed documents. This task requires you to demonstrate proficiency in using core Java collections, user input handling, control flow, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:**
 *     *   Create a class named `Document`.
 *     *   It must have private fields: `documentId` (int), `documentName` (String), and `status`.
 *     *   Use an enum `DocumentStatus` with values `PENDING` and `PROCESSED` for the status.
 *     *   Include a constructor to initialize `documentId` and `documentName`, setting the initial status to `PENDING`.
 *     *   Provide public getter methods for all fields.
 *     *   Implement a public method `process()` that changes the document's status to `PROCESSED`.
 *     *   Override the `toString()` method to provide a clear string representation of the document (including ID, Name, and Status).
 * 
 * 2.  **System Core:**
 *     *   Create a main class (e.g., `DocumentProcessingSystem`) that contains the application logic.
 *     *   Inside this class, declare a private field to represent the processing queue. This field **must** be declared as `java.util.Queue<Document>` and initialized using `java.util.LinkedList`.
 *     *   Declare a private field to store processed documents. This field **must** be declared as `java.util.List<Document>` and initialized using `java.util.ArrayList`.
 *     *   Maintain a private counter (`nextDocumentId`) to generate unique IDs for new documents, starting from 1.
 *     *   Include a constructor to initialize the queue, list, and ID counter.
 * 
 * 3.  **Functionality:** Implement the following operations as public methods within the main system class:
 *     *   `addDocument(String name)`: Creates a new `Document` object with the next available ID and `PENDING` status, and adds it to the processing queue. Include validation to prevent adding documents with empty names.
 *     *   `processNext()`: Removes the document at the head of the processing queue, calls its `process()` method, and adds it to the processed history list. If the queue is empty, print a message indicating that there are no documents to process.
 *     *   `viewQueue()`: Iterates through and prints the details of all documents currently in the processing queue using `System.out`. Indicate if the queue is empty.
 *     *   `viewHistory()`: Iterates through and prints the details of all documents in the processed history list using `System.out`. Indicate if the history is empty.
 *     *   `run()`: This method should contain the main application loop. It should repeatedly display a menu, read user input, and execute the corresponding action.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`). Ensure the `Scanner` resource is properly managed (e.g., using try-with-resources).
 *     *   Display a clear, numbered menu of options using `System.out` within the `run()` method's loop. The options should correspond to the functionality requirements (Add Document, Process Next, View Queue, View History, Exit).
 *     *   Use a `switch` statement based on the user's menu choice to direct program flow.
 * 
 * 5.  **Error Handling & Validation:**
 *     *   Validate user input for the menu choice to ensure it's an integer within the valid range of menu options.
 *     *   Use `System.err` to print error messages for invalid user input (e.g., non-numeric input for menu choice, invalid menu number) and validation failures (e.g., trying to add an empty document name).
 *     *   Use `System.out` for all normal messages, prompts, and output (menu display, success messages, document lists).
 *     *   Implement **class-wide exception handling**: Wrap the main application loop (the core logic within the `run()` method) in a `try-catch` block to catch and handle any unexpected runtime exceptions gracefully, printing an error message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation by making fields private and providing public methods for access/modification where appropriate.
 *     *   Use meaningful and descriptive variable, method, and class names.
 *     *   Include appropriate comments (including Javadoc for classes and methods) to explain the code's purpose and logic.
 *     *   Ensure code is well-formatted and easy to read.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and perform actions based on the input. Output should clearly distinguish between normal information (`System.out`) and error messages (`System.err`). The format of document display should be consistent (e.g., using the `toString()` method).
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Document Processing Menu ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * ------------------------------
 * Enter your choice: 1
 * Enter document name: MyReport
 * Added document: MyReport (ID: 1) to the queue.
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: 3
 * --- Current Processing Queue ---
 * 1. Document [ID=1, Name='MyReport', Status=PENDING]
 * -----------------------------
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: 2
 * Processed document: MyReport (ID: 1). Moved to history.
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: 4
 * --- Processed Documents History ---
 * 1. Document [ID=1, Name='MyReport', Status=PROCESSED]
 * ---------------------------------
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processing Menu ---
 * ...menu options...
 * Enter your choice: 5
 * Exiting Document Processing System. Goodbye!
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes and the `main` method to start the application.
 *
 * EXPLANATION:
 * This solution implements the `DocumentProcessingSystem` as required, demonstrating the use of all specified Java components in a practical scenario.
 * 
 * 1.  **`Document` Class and `DocumentStatus` Enum:**
 *     *   The `Document` class encapsulates the data for each document (`documentId`, `documentName`, `status`).
 *     *   The `DocumentStatus` enum provides a clear, type-safe way to represent the two possible states of a document (`PENDING`, `PROCESSED`).
 *     *   The `process()` method provides a simple way to update the status, adhering to encapsulation.
 *     *   `toString()` is overridden for easy printing of document details.
 * 
 * 2.  **`DocumentProcessingSystem` Class:**
 *     *   This class acts as the controller for the system.
 *     *   `processingQueue`: Declared as `Queue<Document>` and initialized with `LinkedList`. This correctly uses the interface and a common implementation for queues, suitable for FIFO (First-In, First-Out) processing. Documents are added to the end and processed from the front.
 *     *   `processedHistory`: Declared as `List<Document>` and initialized with `ArrayList`. This correctly uses the interface and a common implementation for dynamic lists, suitable for storing the history in the order items were processed.
 *     *   `nextDocumentId`: A simple counter to ensure each document gets a unique ID.
 *     *   The constructor initializes these collections and the counter.
 * 
 * 3.  **Functionality Methods (`addDocument`, `processNext`, `viewQueue`, `viewHistory`):**
 *     *   `addDocument`: Creates a new `Document` instance and uses `processingQueue.offer()` to add it. `offer` is generally preferred for queues as it returns `false` on failure (though a `LinkedList` queue will rarely fail to add unless memory is exhausted), unlike `add` which throws an exception. Includes basic validation for the document name.
 *     *   `processNext`: Uses `processingQueue.poll()` to retrieve and remove the head of the queue. `poll()` is suitable here as it returns `null` if the queue is empty, which is checked beforehand. The processed document is then added to the `processedHistory` list using `processedHistory.add()`.
 *     *   `viewQueue` and `viewHistory`: These methods iterate through their respective collections (`processingQueue` and `processedHistory`) using enhanced for loops to display the contents. They check for emptiness first. Note that iterating a `Queue` typically doesn't remove elements, which is the desired behavior for viewing.
 * 
 * 4.  **User Interface (`run`, `printMenu`):**
 *     *   `printMenu`: A private helper method to display the menu options clearly using `System.out`.
 *     *   `run`: Contains the main application loop (`while (choice != 5)`).
 *     *   `Scanner`: Used within a `try-with-resources` block (`try (Scanner scanner = new Scanner(System.in))`) in the `run` method. This ensures the scanner is automatically closed when the block is exited, preventing resource leaks.
 *     *   `switch` statement: Used directly on the user's integer `choice` to execute the corresponding functionality method or exit the loop.
 * 
 * 5.  **Error Handling & Validation:**
 *     *   Input Validation: Before reading the integer choice, `scanner.hasNextInt()` is used. If it's false, `System.err.println("Invalid input. Please enter a number.")` is used, and `scanner.next()` consumes the invalid token to prevent an infinite loop. If `hasNextInt()` is true, the integer is read, and then the choice is checked in the `switch` statement for being within the valid range (1-5), printing an error to `System.err` for invalid numbers. Empty document names are also validated in `addDocument` using `System.err`.
 *     *   `System.err`: Used specifically for printing error messages related to invalid input or validation failures, distinguishing them from normal program output.
 *     *   `System.out`: Used for all standard output, including the menu, prompts, success messages, and lists of documents.
 *     *   Class-wide Exception Handling: A `try { ... } catch (Exception e) { ... }` block wraps the entire `while` loop within the `run()` method. This demonstrates a top-level catch for any unexpected runtime exceptions that might occur during the execution of the menu loop or the called methods, providing a basic level of robustness and preventing the program from crashing abruptly due to unforeseen errors. An error message is printed to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is applied in both `Document` and `DocumentProcessingSystem` by making fields private.
 *     *   Variable and method names (e.g., `processingQueue`, `processNext`, `documentName`) are descriptive.
 *     *   Javadoc comments are included for classes and public methods, explaining their purpose.
 *     *   The code is structured logically with separate methods for different functionalities.
 * 
 * This solution effectively integrates all required components, simulates a practical scenario, and incorporates essential programming practices like input validation, error handling using `System.err` and `System.out`, and general exception handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Implements Queue
import java.util.List;
import java.util.ArrayList; // Implements List
import java.util.Scanner;
import java.util.InputMismatchException; // For Scanner validation

/**
 * Represents the status of a document in the processing system.
 */
enum DocumentStatus {
    PENDING, PROCESSED
}

/**
 * Represents a document in the processing system.
 */
class Document {
    private int documentId;
    private String documentName;
    private DocumentStatus status;

    /**
     * Constructs a new Document with a given ID and name.
     * Initially, the status is set to PENDING.
     * @param documentId The unique identifier for the document.
     * @param documentName The name of the document.
     */
    public Document(int documentId, String documentName) {
        this.documentId = documentId;
        this.documentName = documentName;
        this.status = DocumentStatus.PENDING;
    }

    // --- Getters ---
    public int getDocumentId() {
        return documentId;
    }

    public String getDocumentName() {
        return documentName;
    }

    public DocumentStatus getStatus() {
        return status;
    }

    /**
     * Marks the document as PROCESSED.
     */
    public void process() {
        this.status = DocumentStatus.PROCESSED;
    }

    /**
     * Provides a string representation of the Document.
     * @return A formatted string including document ID, name, and status.
     */
    @Override
    public String toString() {
        return "Document [ID=" + documentId + ", Name='" + documentName + "', Status=" + status + "]";
    }
}

/**
 * The main system class for managing the document processing workflow.
 * Handles adding documents to a queue, processing them, and storing history.
 */
public class DocumentProcessingSystem {

    // Queue to hold documents waiting to be processed
    private Queue<Document> processingQueue;
    // List to store documents that have been processed
    private List<Document> processedHistory; // Declared as List interface
    // Counter for generating unique document IDs
    private int nextDocumentId;

    /**
     * Constructs a new DocumentProcessingSystem.
     * Initializes the queue, history list, and document ID counter.
     */
    public DocumentProcessingSystem() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedHistory = new ArrayList<>(); // ArrayList implements List
        this.nextDocumentId = 1; // Start IDs from 1
    }

    /**
     * Adds a new document to the processing queue.
     * Validates that the document name is not empty.
     * @param name The name of the document to add.
     */
    public void addDocument(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Document name cannot be empty. Document not added.");
            return;
        }
        Document newDoc = new Document(nextDocumentId++, name.trim());
        processingQueue.offer(newDoc); // offer is a safe way to add to a queue
        System.out.println("Added document: '" + newDoc.getDocumentName() + "' (ID: " + newDoc.getDocumentId() + ") to the queue.");
    }

    /**
     * Processes the next document from the queue.
     * Removes it from the queue, marks it as processed, and adds it to history.
     */
    public void processNext() {
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty. No documents to process.");
        } else {
            Document docToProcess = processingQueue.poll(); // poll retrieves and removes the head, returns null if empty
            if (docToProcess != null) { // Check null just in case, though isEmpty check should prevent this
                docToProcess.process(); // Change status to PROCESSED
                processedHistory.add(docToProcess); // Add to the history list
                System.out.println("Processed document: '" + docToProcess.getDocumentName() + "' (ID: " + docToProcess.getDocumentId() + "). Moved to history.");
            }
        }
    }

    /**
     * Displays the current documents waiting in the processing queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Document doc : processingQueue) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays the history of documents that have been processed.
     */
    public void viewHistory() {
        System.out.println("\n--- Processed Documents History ---");
        if (processedHistory.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            // Iterate through the history list
            int index = 1;
            for (Document doc : processedHistory) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("---------------------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Document Processing Menu ---");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.println("------------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction via the console.
     * Includes input validation and class-wide exception handling.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed automatically
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;

            // Class-wide try-catch block wrapping the main operational loop
            try {
                while (choice != 5) {
                    printMenu(); // Display the menu

                    System.out.print("Enter your choice: ");

                    // Input validation: Check if the next input is an integer
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                        scanner.nextLine(); // Consume the leftover newline character

                        // Use switch statement for menu options
                        switch (choice) {
                            case 1:
                                System.out.print("Enter document name: ");
                                String docName = scanner.nextLine();
                                addDocument(docName); // Call method to add document
                                break;
                            case 2:
                                processNext(); // Call method to process next document
                                break;
                            case 3:
                                viewQueue(); // Call method to view queue
                                break;
                            case 4:
                                viewHistory(); // Call method to view history
                                break;
                            case 5:
                                System.out.println("Exiting Document Processing System. Goodbye!");
                                break;
                            default:
                                // Handle choices outside the valid range (1-5)
                                System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                                break;
                        }
                    } else {
                        // Handle non-integer input for the menu choice
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input to prevent infinite loop
                        choice = -1; // Reset choice to ensure loop continues
                    }
                }
            } catch (Exception e) {
                // Class-wide catch for any unexpected runtime exceptions
                System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
                System.err.println("System encountered a critical issue. Please restart.");
                // e.printStackTrace(); // Uncomment for detailed debugging information
            }

        } // Scanner is automatically closed here by the try-with-resources block
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DocumentProcessingSystem system = new DocumentProcessingSystem();
        system.run(); // Start the application
    }
}
