/*
 * Exam Question #184
 * Generated on: 2025-05-11 22:27:43
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Dispatcher Simulation
 * 
 * **Objective:** Design and implement a simple Task Dispatcher system that manages tasks waiting for processing. This system should allow users to add new tasks, process the next available task, and view all tasks in the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with:
 *     *   A unique integer ID (automatically assigned).
 *     *   A `String` description.
 *     *   A boolean flag `isCompleted` (defaulting to `false`).
 *     *   Appropriate constructor, getters, and a method `markCompleted()`.
 *     *   An overridden `toString()` method to display task details including its status (Pending/Completed).
 * 
 * 2.  **Task Dispatcher Logic:** Create a `TaskDispatcher` class that manages tasks using two collections:
 *     *   A `Queue<Task>` to hold tasks that are pending processing (FIFO order).
 *     *   A `List<Task>` to maintain a history of *all* tasks ever added to the system. Use an `ArrayList` implementation for this list, but declare the variable as `List<Task>`.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object, adds it to both the pending queue and the history list. Validate that the description is not empty.
 *         *   `processNextTask()`: Removes the task from the front of the pending queue, marks it as completed, and prints a message indicating which task was processed. Handle the case where the queue is empty.
 *         *   `listAllTasks()`: Iterates through the history list (`List<Task>`) and prints the details of every task using its `toString()` method. Indicate if the list is empty.
 * 
 * 3.  **User Interface:** Implement a simple command-line interface in the `main` method:
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu with options: 1. Add New Task, 2. Process Next Task, 3. List All Tasks, 4. Exit.
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   The program should run in a loop until the user chooses to exit.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, task details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, invalid task description, input type mismatch).
 *     *   Implement input validation for menu choices (ensure it's an integer within the valid range) and task descriptions (must not be empty).
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main program loop to catch unexpected errors. Also include specific handling for `InputMismatchException` when reading the menu choice. Use a `finally` block to close the `Scanner`.
 * 
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Follow clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and provide feedback using `System.out` or `System.err`. Example interaction:
 * 
 * ```
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task ID: 1, Description: "Write report", Status: Pending
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Review code
 * Task added: Task ID: 2, Description: "Review code", Status: Pending
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 3
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: "Write report", Status: Pending
 * Task ID: 2, Description: "Review code", Status: Pending
 * -----------------
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 2
 * Processing task: Write report (ID: 1)
 * Task ID 1 completed.
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 3
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: "Write report", Status: Completed
 * Task ID: 2, Description: "Review code", Status: Pending
 * -----------------
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * ----------------------------
 * Enter your choice: 4
 * Exiting Task Dispatcher. 1 tasks remaining.
 * Application terminated.
 * ```
 * 
 * Combine all classes into a single `.java` file for submission.
 *
 * EXPLANATION:
 * The solution implements a simple Task Dispatcher application demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   Encapsulates task data (id, description, status).
 *     *   Uses a `static` field `nextId` to automatically generate unique IDs for each task instance, demonstrating a common pattern for object identification.
 *     *   Provides public getter methods and a `markCompleted()` method for controlled access and modification.
 *     *   The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **TaskDispatcher Class:**
 *     *   Acts as the core logic handler.
 *     *   Uses a `Queue<Task>` (`LinkedList` implementation) for `pendingTasks`. The `offer()` method adds tasks to the end, and `poll()` retrieves and removes tasks from the front, adhering to the FIFO principle required for a simple queue.
 *     *   Uses a `List<Task>` (`ArrayList` implementation) for `allTasks`. Declaring it as `List<Task>` demonstrates programming to the interface, making the code more flexible if a different `List` implementation were needed later. `ArrayList` is suitable here for storing and iterating through all tasks.
 *     *   `addTask()`: Adds a new task to both collections. Includes basic input validation for the description.
 *     *   `processNextTask()`: Uses `poll()` to get the next task. If a task is retrieved, it calls `markCompleted()` on the task object. Since the same `Task` object reference exists in both the queue (temporarily) and the list (`allTasks`), modifying the object via `markCompleted()` is reflected when listing all tasks.
 *     *   `listAllTasks()`: Iterates through the `allTasks` `List` using an enhanced for loop and prints each task's details using its `toString()` method.
 * 
 * 3.  **TaskDispatcherApp (Main Class):**
 *     *   Contains the `main` method, which is the application entry point.
 *     *   Creates instances of `TaskDispatcher` and `Scanner`.
 *     *   Implements the main application loop using a `while(running)` structure.
 *     *   `printMenu()`: A helper method to display the user options using `System.out`.
 *     *   **Scanner and Input:** Reads user input using `Scanner`. `scanner.nextInt()` is used for the menu choice, followed by `scanner.nextLine()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls for the task description.
 *     *   **Switch Statement:** Controls the program flow based on the user's integer input, directing execution to the appropriate `TaskDispatcher` method or the exit logic.
 *     *   **Error Handling (`try-catch`, `System.err`):**
 *         *   An inner `try-catch` block specifically handles `InputMismatchException` when reading the menu choice. This prevents the program from crashing if the user enters non-integer input, prints an error to `System.err`, consumes the invalid input, and continues the loop.
 *         *   The `addTask` method includes validation for an empty description, printing an error to `System.err`.
 *         *   A larger, outer `try-catch` block wraps the entire `while` loop. This provides "class-wide" or application-level exception handling, catching any unexpected `Exception` that might occur during execution, printing an error message and stack trace to `System.err`, and allowing the `finally` block to execute.
 *     *   **Finally Block:** Ensures that the `Scanner` resource is always closed properly when the application loop finishes or an exception occurs, preventing resource leaks.
 *     *   **System.out:** Used for all successful operations, prompts, and menu display.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating key Java concepts like object-oriented design (classes, encapsulation), collection usage (`Queue`, `List`, `ArrayList`, `LinkedList`), input handling, control flow (`switch`, loops), and robust error handling (`try-catch`, `System.err`).
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task with an ID, description, and completion status.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task with a description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.isCompleted = false; // Task starts as not completed
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return True if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Returns a string representation of the task including its status.
     * @return Formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\", Status: " + (isCompleted ? "Completed" : "Pending");
    }
}

/**
 * Manages a queue of pending tasks and a history list of all tasks.
 */
class TaskDispatcher {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to keep track of all tasks ever added (history)
    private List<Task> allTasks; // Declared as List interface

    /**
     * Constructs a new TaskDispatcher, initializing the task collections.
     */
    public TaskDispatcher() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the dispatcher.
     * The task is added to both the pending queue and the history list.
     * @param description The description of the task. Must not be null or empty.
     */
    public void addTask(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // Add to the end of the pending queue
        allTasks.add(newTask);       // Add to the list of all tasks
        System.out.println("Task added: " + newTask.toString());
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue and marks it as completed in the history list.
     * Handles the case where there are no pending tasks.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");
            // Since the Task object in allTasks is the same reference,
            // marking it completed here updates the status in the list as well.
            taskToProcess.markCompleted();
            System.out.println("Task ID " + taskToProcess.getId() + " completed.");
        } else {
            System.out.println("No tasks pending.");
        }
    }

    /**
     * Lists all tasks ever added to the system, including their current status.
     * Iterates through the history list (`allTasks`).
     */
    public void listAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
            return;
        }

        System.out.println("\n--- All Tasks ---");
        // Iterate through the List of all tasks
        for (Task task : allTasks) {
            System.out.println(task.toString());
        }
        System.out.println("-----------------");
    }

    /**
     * Gets the number of tasks currently in the pending queue.
     * @return The count of pending tasks.
     */
    public int getPendingTaskCount() {
        return pendingTasks.size();
    }
}

/**
 * Main application class for the Task Dispatcher.
 * Handles user interaction and application flow.
 */
public class TaskDispatcherApp {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Dispatcher Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Main method to run the Task Dispatcher application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskDispatcher dispatcher = new TaskDispatcher();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        dispatcher.addTask(description); // addTask handles its own validation
                        break;
                    case 2:
                        dispatcher.processNextTask();
                        break;
                    case 3:
                        dispatcher.listAllTasks();
                        break;
                    case 4:
                        System.out.println("Exiting Task Dispatcher. " + dispatcher.getPendingTaskCount() + " tasks remaining in queue.");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }
}
