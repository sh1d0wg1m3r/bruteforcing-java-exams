/*
 * Exam Question #303
 * Generated on: 2025-05-11 22:52:16
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Problem Title:** Simple Task Management System
 * 
 * **Description:**
 * You are tasked with developing a command-line application to manage a simple list of tasks for a small team. The system should allow users to add new tasks, view tasks that are pending completion, view tasks that have been completed, and mark a pending task as completed by its unique ID.
 * 
 * **System Requirements:**
 * 1. Maintain two primary collections of tasks: one for tasks that are currently pending and waiting to be worked on, and another for tasks that have been successfully completed.
 * 2. Each task must be uniquely identified by an integer ID and have a descriptive string.
 * 3. The system must interact with the user through a simple command-line menu.
 * 4. The application should run continuously, presenting the menu after each operation, until the user explicitly chooses to exit.
 * 
 * **Implementation Requirements:**
 * Your Java solution must demonstrate advanced understanding by strictly adhering to the following requirements:
 * 1.  Use `java.util.Queue` (specifically, a concrete implementation like `LinkedList`) to store the **pending tasks**. While a queue typically represents FIFO, the requirement to remove a task by ID means you will need to iterate and find the task, then remove it from the queue structure. This demonstrates handling collections in a non-standard way when requirements dictate.
 * 2.  Use `java.util.ArrayList` to store the **completed tasks**. This list must be declared using the `java.util.List` interface type.
 * 3.  Utilize `java.util.Scanner` to read user input from the standard input stream (`System.in`).
 * 4.  Implement the main menu navigation logic using a `switch` statement based on the user's integer choice.
 * 5.  All standard application output (menu, task lists, success messages) must be directed to `System.out.println()`.
 * 6.  All error messages (invalid input, task not found, etc.) must be directed to `System.err.println()`.
 * 7.  Implement robust class-wide exception handling using `try-catch` blocks within the main application loop. You must handle potential `java.util.InputMismatchException` when expecting integer input, and you must define and handle a custom exception (e.g., `TaskNotFoundException`) specifically for the case where a user attempts to mark a non-existent task ID as completed.
 * 8.  Design the solution using object-oriented principles:
 *     *   Create a `Task` class with private fields (`id`, `description`) and public getter methods. Override `equals()` and `hashCode()` in `Task` based on the ID to facilitate removal from collections.
 *     *   Create a main class (e.g., `TaskProcessor`) that encapsulates the collections and manages all user interaction and task processing logic.
 *     *   Use meaningful variable and method names that clearly indicate their purpose.
 *     *   Include appropriate comments and documentation (JavaDocs for classes and methods).
 *     *   Implement basic input validation (e.g., checking for empty task description, ensuring integer input where expected).
 * 
 * **Menu Options:**
 * The application should present the following options:
 * 1.  Add New Task
 * 2.  View Pending Tasks
 * 3.  View Completed Tasks
 * 4.  Mark Task Completed
 * 5.  Exit
 * 
 * **Expected Interaction (Example Flow):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Task added with ID: 1
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement user interface
 * Task added with ID: 2
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * ID: 1, Description: Design database schema
 * ID: 2, Description: Implement user interface
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 4
 * Enter ID of task to mark completed: 1
 * Task with ID 1 marked as completed.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * ID: 2, Description: Implement user interface
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 3
 * --- Completed Tasks ---
 * ID: 1, Description: Design database schema
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 4
 * Enter ID of task to mark completed: 99
 * Error: Task with ID 99 not found in pending tasks.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task Completed
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * Provide the complete Java code for the solution, including all necessary classes, and a brief explanation of your approach.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System as required.
 * 
 * 1.  **`Task` Class:** A basic Plain Old Java Object (POJO) representing a task with `id` and `description`. It includes getter methods and overrides `toString()` for easy printing. Crucially, `equals()` and `hashCode()` are overridden based on the task ID. This is essential because the `markTaskCompleted` method needs to find and remove a specific `Task` object from the `pendingQueue` using `queue.remove(object)`. The `remove(object)` method relies on the `equals()` method to find the correct object.
 * 
 * 2.  **`TaskNotFoundException` Class:** A custom exception class extending `Exception`. This is used to signal a specific error condition: when a user attempts to mark a task as complete, but the provided ID does not correspond to any task currently in the pending queue.
 * 
 * 3.  **`TaskProcessor` Class:** This is the main class containing the application logic.
 *     *   It holds the two primary collections: `pendingQueue` (declared as `Queue<Task>`, implemented as `LinkedList<Task>` as required) and `completedList` (declared as `List<Task>`, implemented as `ArrayList<Task>` as required). `LinkedList` is chosen for the queue implementation because, unlike a standard `Queue` interface which doesn't guarantee `remove(Object)`, `LinkedList` provides this method, which is necessary for removing an arbitrary task by ID from the pending list without changing its structure significantly during iteration.
 *     *   A `Scanner` instance is used to read input from `System.in`.
 *     *   `nextTaskId` is a simple counter to ensure unique IDs for new tasks.
 *     *   The `run()` method contains the main application loop. It repeatedly displays the menu and processes user input.
 *     *   A `switch` statement is used within the `run()` loop to direct execution based on the user's menu choice.
 *     *   Methods like `addTask`, `viewPendingTasks`, `viewCompletedTasks`, and `markTaskCompleted` encapsulate the specific functionalities.
 *     *   `System.out.println()` is used for normal output like menus, prompts, task lists, and success messages.
 *     *   `System.err.println()` is used exclusively for error messages, fulfilling a specific requirement.
 * 
 * 4.  **Exception Handling (`try-catch`):** The `run()` method employs a comprehensive `try-catch` block around the input reading and `switch` statement.
 *     *   `InputMismatchException` is caught to handle non-integer input for the menu choice, preventing the program from crashing and informing the user via `System.err`. A `scanner.nextLine()` is called in the catch block to consume the invalid input line, preventing an infinite loop.
 *     *   `markTaskCompleted` is designed to throw `IllegalArgumentException` if the task ID input format is incorrect (caught by `InputMismatchException` internally and re-thrown) and `TaskNotFoundException` if the ID is not found in the pending queue. These are caught in the `run()` method's `try-catch` block, and appropriate error messages are printed to `System.err`.
 *     *   A general `Exception` catch block is included as a fallback for any other unexpected runtime errors, printing details to `System.err`.
 * 
 * 5.  **`markTaskCompleted` Logic:** This method demonstrates handling a `Queue` when removal by arbitrary element (by ID) is needed, deviating from strict FIFO `poll()`. It iterates through the `pendingQueue` using an `Iterator`. When the task with the matching ID is found, `iterator.remove()` is called. This is the correct and safe way to remove an element from a collection while iterating it, avoiding `ConcurrentModificationException`. The removed task is then added to the `completedList`. If the loop finishes without finding the task, the custom `TaskNotFoundException` is thrown.
 * 
 * 6.  **Best Practices:** The solution follows best practices by using private fields with public getters (encapsulation), meaningful names, JavaDocs and comments, input validation (basic checks for empty description and integer format), and proper resource management (closing the `Scanner`).
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch` with custom exceptions) into a practical, albeit simple, application scenario, demonstrating advanced Java programming concepts like collection manipulation, object-oriented design, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator;
import java.util.InputMismatchException; // Specific import for clarity

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string of task details.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description;
    }

    /**
     * Checks if two Task objects are equal based on their ID.
     * This is crucial for methods like Queue.remove(Object).
     * @param o The object to compare with.
     * @return true if the objects are equal (same ID), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    /**
     * Generates a hash code for the Task based on its ID.
     * Must be consistent with the equals method.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return id;
    }
}

/**
 * Custom exception for when a task is not found.
 */
class TaskNotFoundException extends Exception {
    /**
     * Constructs a new TaskNotFoundException with the specified detail message.
     * @param message The detail message.
     */
    public TaskNotFoundException(String message) {
        super(message);
    }
}

/**
 * Manages the collection of pending and completed tasks and handles user interaction.
 */
public class TaskProcessor {
    // Requirement: Use Queue for pending tasks (LinkedList concrete implementation)
    private Queue<Task> pendingQueue;
    // Requirement: Use List for completed tasks (ArrayList concrete implementation)
    private List<Task> completedList;
    private int nextTaskId; // To generate unique IDs
    // Requirement: Use Scanner for user input
    private Scanner scanner;

    /**
     * Constructs a TaskProcessor, initializing collections and scanner.
     */
    public TaskProcessor() {
        this.pendingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedList = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the console.
     * Uses System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Mark Task Completed");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts the user for a task description and adds a new task
     * to the pending queue with a generated ID.
     * Uses System.out for prompts and success messages.
     * Uses System.err for validation errors.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        pendingQueue.offer(newTask); // offer is the standard way to add to a queue
        System.out.println("Task added with ID: " + newTask.getId()); // Requirement: Use System.out
    }

    /**
     * Displays all tasks currently in the pending queue without removing them.
     * Uses System.out for output.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---"); // Requirement: Use System.out
        if (pendingQueue.isEmpty()) {
            System.out.println("No pending tasks."); // Requirement: Use System.out
        } else {
            // Iterate over the queue elements
            for (Task task : pendingQueue) {
                System.out.println(task); // Task.toString() is used here
            }
        }
        System.out.println("---------------------"); // Requirement: Use System.out
    }

    /**
     * Displays all tasks currently in the completed list.
     * Uses System.out for output.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---"); // Requirement: Use System.out
        if (completedList.isEmpty()) {
            System.out.println("No completed tasks."); // Requirement: Use System.out
        } else {
            // Iterate over the list elements
            for (Task task : completedList) {
                System.out.println(task); // Task.toString() is used here
            }
        }
        System.out.println("---------------------"); // Requirement: Use System.out
    }

    /**
     * Prompts the user for a task ID, finds the task in the pending queue,
     * removes it, and adds it to the completed list.
     * Uses System.out for prompts and success messages.
     * Throws TaskNotFoundException if the ID is not found.
     * Throws IllegalArgumentException for invalid ID input format.
     */
    private void markTaskCompleted() throws TaskNotFoundException, IllegalArgumentException {
        System.out.print("Enter ID of task to mark completed: "); // Requirement: Use System.out
        int taskIdToComplete;
        try {
            taskIdToComplete = scanner.nextInt();
        } catch (InputMismatchException e) {
            scanner.nextLine(); // Consume the invalid input
            // Throw a standard exception for input format errors
            throw new IllegalArgumentException("Invalid input. Please enter a valid integer ID.");
        }
        // Consume the newline character left after reading the integer ID
        scanner.nextLine();

        Task taskToMove = null;
        // Iterate through the pending queue to find the task by ID
        // Using an Iterator allows safe removal during iteration
        Iterator<Task> iterator = pendingQueue.iterator();
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskIdToComplete) {
                taskToMove = task;
                iterator.remove(); // Safely remove the task from the queue
                break; // Task found and removed, exit loop
            }
        }

        if (taskToMove != null) {
            completedList.add(taskToMove); // Add the task to the completed list
            System.out.println("Task with ID " + taskIdToComplete + " marked as completed."); // Requirement: Use System.out
        } else {
            // Task was not found in the pending queue
            // Requirement: Throw custom exception
            throw new TaskNotFoundException("Task with ID " + taskIdToComplete + " not found in pending tasks.");
        }
    }

    /**
     * Runs the main application loop, displaying the menu, reading user choice,
     * and calling the appropriate methods. Handles exceptions.
     * Requirement: Class-wide exception handling with try-catch.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                // Read the user's menu choice
                int choice = scanner.nextInt();

                // Requirement: Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        viewCompletedTasks();
                        break;
                    case 4:
                        markTaskCompleted(); // This method can throw exceptions
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System."); // Requirement: Use System.out
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Requirement: Use System.err
                        // No need to consume line here, nextInt() failed and InputMismatchException will be caught
                        break;
                }
            } catch (InputMismatchException e) {
                // Requirement: Handle InputMismatchException
                // Handle cases where the input is not an integer
                System.err.println("Error: Invalid input. Please enter a number."); // Requirement: Use System.err
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (TaskNotFoundException e) {
                // Requirement: Handle custom TaskNotFoundException
                System.err.println("Error: " + e.getMessage()); // Requirement: Use System.err
            } catch (IllegalArgumentException e) {
                 // Handle specific argument errors like invalid ID format caught in markTaskCompleted
                 System.err.println("Error: " + e.getMessage()); // Requirement: Use System.err
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Requirement: Use System.err
                e.printStackTrace(System.err); // Print stack trace for debugging to System.err
            }
        }

        // Close the scanner resource when the application loop finishes
        scanner.close();
    }

    /**
     * The main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
