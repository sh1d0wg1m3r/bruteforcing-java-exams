/*
 * Exam Question #1005
 * Generated on: 2025-05-12 17:11:48
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Task Management System
 * 
 * **Objective:** Design and implement a console-based application simulating an Advanced Task Management System. This system will allow users to add new tasks, process the next available task, view pending tasks, and view completed tasks. The system must prioritize tasks based on their arrival order (First-In, First-Out) for processing and maintain a history of completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts, data structures, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. It should encapsulate the task's description and its current status (e.g., "Pending", "Completed"). Use appropriate access modifiers to enforce encapsulation.
 * 2.  **Task Management:** Create a class named `TaskScheduler` responsible for managing the collection of tasks.
 *     *   It must use a `java.util.Queue` to store tasks that are pending processing. The processing order must be FIFO.
 *     *   It must use a `java.util.List` to store tasks that have been completed.
 *     *   Declare variables using the `Queue` and `List` interfaces where appropriate, rather than concrete implementation classes like `LinkedList` or `ArrayList` (though you will use implementations during instantiation).
 *     *   Provide methods to:
 *         *   Add a new task to the pending queue.
 *         *   Process the next task (remove from pending, mark as completed, add to completed list).
 *         *   Retrieve a list of pending task descriptions (without removing from the queue).
 *         *   Retrieve a list of completed task descriptions.
 * 3.  **User Interface:** Implement a console-based user interface in a main application class (e.g., `AdvancedTaskSchedulerApp`).
 *     *   Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 *     *   Present a menu of options to the user: Add Task, Process Next Task, View Pending Tasks, View Completed Tasks, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Implement input validation for task descriptions (e.g., prevent adding empty tasks). Use exceptions (e.g., `IllegalArgumentException`) within the `Task` or `TaskScheduler` classes for validation failures.
 *     *   Handle potential runtime errors during user input (e.g., non-integer input for menu choice) using `try-catch` blocks.
 *     *   Handle the case where the user tries to process a task when the pending queue is empty.
 *     *   Implement **class-wide exception handling** in your main application loop using a `try-catch` block to catch any unexpected exceptions that might occur during the program's execution.
 *     *   Use `System.out` for normal program output (menu, prompts, success messages, task lists).
 *     *   Use `System.err` to display error messages (invalid input, failed operations, exceptions).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (like Javadoc for classes/methods).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Mandatory Java Components to Use:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` block
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and provide feedback using `System.out` or `System.err`. Examples:
 * 
 * ```
 * --- Advanced Task Scheduler ---
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Complete exam question
 * 
 * Task added successfully.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 1
 * Enter task description: Review solution
 * 
 * Task added successfully.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Complete exam question
 * 2. Review solution
 * ---------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 2
 * Processed task: "Complete exam question"
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Review solution
 * ---------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Complete exam question
 * -----------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 2
 * Processed task: "Review solution"
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 1
 * Enter task description:
 * Error adding task: Task description cannot be empty.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 5
 * Exiting Task Scheduler. Goodbye!
 * ```
 * 
 * Your solution should be provided as a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements an Advanced Task Scheduler application demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Representation (`Task` class):**
 *     *   The `Task` class encapsulates the `description` and `status` (private fields) of a task.
 *     *   The constructor validates that the description is not empty, throwing an `IllegalArgumentException` if it is. This promotes data integrity.
 *     *   Public getter methods (`getDescription`, `getStatus`) provide controlled access to the data.
 *     *   `markAsCompleted` is a public method to change the status.
 *     *   `toString` provides a convenient string representation.
 * 
 * 2.  **Task Management (`TaskScheduler` class):**
 *     *   It uses a `Queue<Task>` (`pendingTasksQueue`) implemented by `LinkedList` to maintain tasks in FIFO order, suitable for processing tasks as they arrive.
 *     *   It uses a `List<Task>` (`completedTasksList`) implemented by `ArrayList` to store completed tasks, allowing easy retrieval and iteration.
 *     *   Variables are declared using the `Queue` and `List` interfaces (`private Queue<Task>`, `private List<Task>`) adhering to the principle of programming to interfaces.
 *     *   `addTask(String description)` creates a new `Task` (triggering its validation) and adds it to the `pendingTasksQueue` using `offer()`.
 *     *   `processNextTask()` uses `poll()` to retrieve and remove the head of the `pendingTasksQueue`. It checks if the result is `null` (queue empty) and handles accordingly. If a task is retrieved, its status is updated, and it's added to the `completedTasksList`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()` iterate over the respective collections and return a `List<String>` containing only the task descriptions. This prevents external code from directly modifying the internal state (`Queue` or `List` of `Task` objects) of the `TaskScheduler`.
 * 
 * 3.  **User Interface (`AdvancedTaskSchedulerApp` class):**
 *     *   The `main` method drives the application.
 *     *   A `Scanner` is used for console input.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   `printMenu()` displays the options using `System.out`.
 *     *   Input reading (`scanner.nextInt()`) is wrapped in a `try-catch(InputMismatchException)` block to gracefully handle cases where the user enters non-integer input, preventing the program from crashing. The invalid input is consumed, and the loop continues.
 *     *   A `switch` statement handles the different integer choices, directing the flow to the corresponding logic within the `TaskScheduler` instance.
 *     *   `System.out` is used for informational messages and displaying lists.
 *     *   `System.err` is used for error messages, such as invalid input or validation failures reported by the `TaskScheduler`.
 * 
 * 4.  **Error Handling:**
 *     *   `IllegalArgumentException` is used in the `Task` constructor for validation and caught in the `addTask` case of the `switch` statement, reporting the specific error message to `System.err`.
 *     *   The `processNextTask` method returns `null` if the queue is empty, and the calling code in `main` checks for this `null` value to print an appropriate message to `System.out`.
 *     *   A `try-catch(InputMismatchException)` is specifically used around the `scanner.nextInt()` call.
 *     *   A **class-wide `try-catch(Exception e)`** block wraps the entire `while` loop in the `main` method. This serves as a safety net to catch any other unhandled exceptions that might occur during execution, printing an error message to `System.err` and the stack trace before the program potentially terminates.
 *     *   The `default` case in the `switch` handles valid integer inputs that don't match any menu option, printing an error to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names like `pendingTasksQueue`, `processNextTask`, `viewPendingTasks` are used.
 *     *   Constants (`ADD_TASK`, `PROCESS_TASK`, etc.) improve code readability and maintainability in the `switch` statement.
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   The `Scanner` is closed in a `finally` block to ensure resource cleanup regardless of how the application loop terminates (normal exit or unexpected exception).
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrating key object-oriented principles, data structure usage, and robust error handling crucial for advanced Java programming.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation for List
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner input

/**
 * Represents a single task with a description and status.
 * Encapsulates task details and status.
 */
class Task {
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * Validates the description upon creation.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation: ensure description is not null or empty
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.status = "Pending"; // Initial status
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     * @return The task status ("Pending" or "Completed").
     */
    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the task.
     * @return A string formatted as "description [status]".
     */
    @Override
    public String toString() {
        return description + " [" + status + "]";
    }
}

/**
 * Manages pending and completed tasks using a Queue and a List.
 * Acts as the core logic handler for the task management system.
 */
class TaskScheduler {
    // Use Queue interface, implementation is LinkedList for FIFO behavior
    private Queue<Task> pendingTasksQueue;
    // Use List interface, implementation is ArrayList for easy storage and retrieval
    private List<Task> completedTasksList;

    /**
     * Constructs a new TaskScheduler.
     * Initializes the pending task queue and completed task list.
     */
    public TaskScheduler() {
        // Instantiate with concrete classes that implement the interfaces
        this.pendingTasksQueue = new LinkedList<>();
        this.completedTasksList = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task to add.
     * @return true if the task was successfully added, false otherwise.
     * @throws IllegalArgumentException if the description is invalid (delegated to Task constructor).
     */
    public boolean addTask(String description) {
        // Task constructor handles description validation and throws IllegalArgumentException
        Task newTask = new Task(description);
        // offer() is generally preferred over add() for queues as it doesn't throw an exception if capacity is limited,
        // although LinkedList is not capacity-constrained. It's good practice.
        return pendingTasksQueue.offer(newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue, marks it as completed, and moves it to the completed list.
     * @return The task that was processed, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of this queue, or returns null if the queue is empty.
        Task taskToProcess = pendingTasksQueue.poll();
        if (taskToProcess != null) {
            taskToProcess.markAsCompleted(); // Update status
            completedTasksList.add(taskToProcess); // Add to completed list
            return taskToProcess;
        }
        return null; // No tasks in the queue
    }

    /**
     * Gets a list of descriptions of tasks currently in the pending queue.
     * Does not remove tasks from the queue. Provides a snapshot.
     * @return A List of strings, where each string is the description of a pending task.
     */
    public List<String> viewPendingTasks() {
        List<String> pendingDescriptions = new ArrayList<>();
        // Iterate over the queue without removing elements (peek() or iterator)
        // Using iterator is common to traverse all elements
        for (Task task : pendingTasksQueue) {
            pendingDescriptions.add(task.getDescription());
        }
        return pendingDescriptions; // Return a new list containing descriptions
    }

    /**
     * Gets a list of descriptions of tasks that have been completed.
     * @return A List of strings, where each string is the description of a completed task.
     */
    public List<String> viewCompletedTasks() {
        List<String> completedDescriptions = new ArrayList<>();
        // Iterate over the completed list
        for (Task task : completedTasksList) {
            completedDescriptions.add(task.getDescription());
        }
        return completedDescriptions; // Return a new list containing descriptions
    }

    /**
     * Gets the number of tasks currently in the pending queue.
     * @return The number of pending tasks.
     */
    public int getPendingTaskCount() {
        return pendingTasksQueue.size();
    }
}

/**
 * Main application class for the Advanced Task Scheduler.
 * Handles user interaction, menu display, and orchestrates the TaskScheduler.
 * Contains the main application loop and class-wide exception handling.
 */
public class AdvancedTaskSchedulerApp {

    // Constants for menu options for better readability
    private static final int ADD_TASK = 1;
    private static final int PROCESS_TASK = 2;
    private static final int VIEW_PENDING = 3;
    private static final int VIEW_COMPLETED = 4;
    private static final int EXIT = 5;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskScheduler scheduler = new TaskScheduler();
        boolean running = true;

        System.out.println("--- Advanced Task Scheduler ---");

        // Class-wide exception handling for the main application loop.
        // Catches any unhandled exceptions that bubble up from the loop.
        try {
            while (running) {
                printMenu(); // Display menu options
                int choice = -1; // Default value indicating no valid choice yet

                // Try-catch block specifically for reading integer input and handling MismatchException
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline character after reading the integer

                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
                    continue; // Skip the rest of the loop and show the menu again
                }

                // Switch statement to process the user's valid integer choice
                switch (choice) {
                    case ADD_TASK:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            // Call scheduler method, which might throw IllegalArgumentException
                            if (scheduler.addTask(description)) {
                                System.out.println("Task added successfully.");
                            } else {
                                // This case is unlikely with LinkedList Queue unless memory is full,
                                // but included for completeness based on Queue.offer() return value.
                                System.err.println("Failed to add task.");
                            }
                        } catch (IllegalArgumentException e) {
                            // Catch and report validation errors from Task constructor/addTask method
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case PROCESS_TASK:
                        Task processedTask = scheduler.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processed task: \"" + processedTask.getDescription() + "\"");
                        } else {
                            // Handle case where queue is empty
                            System.out.println("No pending tasks to process.");
                        }
                        break;

                    case VIEW_PENDING:
                        List<String> pending = scheduler.viewPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            System.out.println("--- Pending Tasks ---");
                            // Iterate and print pending tasks with numbering
                            for (int i = 0; i < pending.size(); i++) {
                                System.out.println((i + 1) + ". " + pending.get(i));
                            }
                            System.out.println("---------------------");
                        }
                        break;

                    case VIEW_COMPLETED:
                        List<String> completed = scheduler.viewCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks yet.");
                        } else {
                            System.out.println("--- Completed Tasks ---");
                            // Iterate and print completed tasks with numbering
                            for (int i = 0; i < completed.size(); i++) {
                                System.out.println((i + 1) + ". " + completed.get(i));
                            }
                            System.out.println("-----------------------");
                        }
                        break;

                    case EXIT:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        break;

                    default:
                        // Handle choices that are integers but not within the valid range
                        System.err.println("Invalid choice. Please enter a number between " + ADD_TASK + " and " + EXIT + ".");
                        break;
                }
                System.out.println(); // Add a newline for better separation between menu interactions
            }
        } catch (Exception e) {
            // This catch block handles any other unexpected exceptions that were not caught
            // by more specific handlers (like InputMismatchException).
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print the stack trace for debugging purposes
        } finally {
            // The finally block ensures that the scanner is closed, regardless of whether
            // an exception occurred or the loop exited normally.
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation message
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Select an option:");
        System.out.println(ADD_TASK + ". Add New Task");
        System.out.println(PROCESS_TASK + ". Process Next Task");
        System.out.println(VIEW_PENDING + ". View Pending Tasks");
        System.out.println(VIEW_COMPLETED + ". View Completed Tasks");
        System.out.println(EXIT + ". Exit");
    }
}
