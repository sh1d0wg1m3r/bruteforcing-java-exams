/*
 * Exam Question #841
 * Generated on: 2025-05-12 16:49:04
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Task Queue Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple console-based Task Queue Management System. This system should allow users to add new tasks to a queue, process the next task from the queue, view the list of pending tasks, and view the list of completed tasks. The system should handle basic user interaction and errors gracefully.
 * 
 * **System Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with a private field for the task description (String) and a public getter method.
 * 2.  **Task Management:** Create a class `TaskQueueManager` that will manage the tasks. This class must contain:
 *     *   A private `Queue<Task>` to hold tasks that are pending processing.
 *     *   A private `List<Task>` (declared as `List`, instantiated as `ArrayList`) to store tasks once they are completed.
 *     *   A public method `addTask(String description)` that creates a new `Task` object and adds it to the pending queue. It should validate that the description is not null or empty.
 *     *   A public method `processNextTask()` that retrieves and removes the next task from the pending queue and adds it to the completed list. It should return the processed task or `null` if the queue is empty.
 *     *   A public method `getPendingTasks()` that returns a `List` view of the current pending tasks (without removing them from the queue).
 *     *   A public method `getCompletedTasks()` that returns the list of completed tasks.
 * 3.  **User Interface:**
 *     *   Implement a `main` method in a separate class (e.g., `TaskQueueApp`).
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   The system should accept the following commands (case-insensitive):
 *         *   `add <description>`: Adds a new task with the given description to the queue.
 *         *   `process`: Processes the next task in the queue.
 *         *   `view pending`: Displays all tasks currently in the pending queue.
 *         *   `view completed`: Displays all tasks that have been processed.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to handle the different commands.
 *     *   Use `System.out` for normal output (messages, task lists).
 *     *   Use `System.err` to display error messages (e.g., invalid command, empty description for add, no tasks to process).
 * 4.  **Error Handling:**
 *     *   Implement input validation for the `add` command (empty description).
 *     *   Handle the case where the `process` command is issued when the pending queue is empty.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command processing loop to catch any unexpected runtime errors and print a generic error message to `System.err` before exiting or continuing (your choice, but catching and reporting is required).
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   When adding a task: `Task added: <description>`
 * *   When adding a task with empty description: Error message to `System.err`.
 * *   When processing a task: `Processed task: <description>`
 * *   When processing an empty queue: Error message to `System.err`.
 * *   When viewing pending tasks: List tasks with numbers, e.g., `Pending Tasks (2):`, `1. <description1>`, `2. <description2>` or `No pending tasks.`
 * *   When viewing completed tasks: List tasks with numbers, e.g., `Completed Tasks (3):`, `1. <description1>`, `2. <description2>`, `3. <description3>` or `No completed tasks.`
 * *   When an invalid command is entered: Error message to `System.err`.
 * *   Upon encountering an unexpected exception: Generic error message to `System.err`.
 * *   Upon exiting: `Exiting Task Queue System. Goodbye!`
 * 
 * **Constraints:**
 * 
 * *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, and `try-catch`.
 * *   The solution should be contained within the required classes (`Task`, `TaskQueueManager`, `TaskQueueApp`).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation according to requirements.
 * *   Proper usage of all required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, clean code).
 * *   Robustness in handling valid and invalid inputs, and unexpected errors.
 *
 * EXPLANATION:
 * 
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable list view

/**
 * Represents a single task in the system.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class TaskQueueManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskQueueManager.
     */
    public TaskQueueManager() {
        // Queue for FIFO processing
        this.pendingTasks = new LinkedList<>();
        // List to store completed tasks history
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task to add.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        Task newTask = new Task(description); // Validation happens in Task constructor
        pendingTasks.offer(newTask); // offer is preferred over add for capacity-constrained queues, good practice
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Processes the next task from the pending queue.
     * @return The processed task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll returns null if queue is empty
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask.getDescription());
            return nextTask;
        } else {
            System.err.println("No pending tasks to process.");
            return null;
        }
    }

    /**
     * Gets an unmodifiable view of the pending tasks.
     * Note: This returns a List view but does not remove elements from the Queue.
     * @return An unmodifiable List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Convert Queue to List for display purposes
        List<Task> pendingList = new ArrayList<>(pendingTasks);
        // Return an unmodifiable list to prevent external modification of the internal queue state
        return Collections.unmodifiableList(pendingList);
    }

    /**
     * Gets an unmodifiable view of the completed tasks.
     * @return An unmodifiable List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return an unmodifiable list to prevent external modification
        return Collections.unmodifiableList(completedTasks);
    }
}

/**
 * Main application class for the Task Queue Management System.
 * Handles user interaction via the console.
 */
public class TaskQueueApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskQueueManager manager = new TaskQueueManager();
        boolean running = true;

        System.out.println("--- Task Queue Management System ---");
        System.out.println("Commands: add <description>, process, view pending, view completed, exit");

        // Class-wide exception handling around the main command loop
        try {
            while (running) {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Ignore empty input
                }

                // Split command and arguments
                String[] parts = inputLine.split(" ", 2);
                String command = parts[0].toLowerCase(); // Case-insensitive command

                // Use switch statement for command handling
                switch (command) {
                    case "add":
                        if (parts.length < 2 || parts[1].trim().isEmpty()) {
                            System.err.println("Error: 'add' command requires a task description.");
                        } else {
                            try {
                                manager.addTask(parts[1].trim());
                            } catch (IllegalArgumentException e) {
                                // Catch validation error from Task constructor
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                        }
                        break;

                    case "process":
                        manager.processNextTask(); // Handles empty queue internally
                        break;

                    case "view":
                        if (parts.length < 2) {
                            System.err.println("Error: 'view' command requires 'pending' or 'completed'.");
                        } else {
                            String viewType = parts[1].toLowerCase();
                            switch (viewType) {
                                case "pending":
                                    List<Task> pending = manager.getPendingTasks();
                                    if (pending.isEmpty()) {
                                        System.out.println("No pending tasks.");
                                    } else {
                                        System.out.println("Pending Tasks (" + pending.size() + "):");
                                        for (int i = 0; i < pending.size(); i++) {
                                            System.out.println((i + 1) + ". " + pending.get(i).getDescription());
                                        }
                                    }
                                    break;
                                case "completed":
                                    List<Task> completed = manager.getCompletedTasks();
                                    if (completed.isEmpty()) {
                                        System.out.println("No completed tasks.");
                                    } else {
                                        System.out.println("Completed Tasks (" + completed.size() + "):");
                                        for (int i = 0; i < completed.size(); i++) {
                                            System.out.println((i + 1) + ". " + completed.get(i).getDescription());
                                        }
                                    }
                                    break;
                                default:
                                    System.err.println("Error: Unknown view type. Use 'pending' or 'completed'.");
                                    break;
                            }
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Queue System. Goodbye!");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally, print stack trace for debugging during development/testing
            // e.printStackTrace(System.err);
        } finally {
            // Close the scanner to release system resources
            scanner.close();
        }
    }
}
