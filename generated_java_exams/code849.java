/*
 * Exam Question #849
 * Generated on: 2025-05-12 16:50:12
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Objective:** Implement a simple command-line task management system for a team. The system should allow users to add tasks to a pending queue, process the next task, and list tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for `description` (String) and `priority` (String - "HIGH", "MEDIUM", or "LOW"). Include a constructor and a `toString()` method.
 * 2.  **Task Manager:** Create a class `TaskManager` that manages tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are pending processing (FIFO order for processing among tasks of same conceptual priority level, though the Queue itself doesn't enforce priority).
 *     *   It must use a `java.util.List<Task>` (specifically, instantiate using `java.util.ArrayList`) to keep a record of *all* tasks that have ever been added to the system.
 *     *   Implement methods:
 *         *   `addTask(String description, String priority)`: Validates the priority string. If valid, creates a `Task` object and adds it to both the pending queue and the list of all tasks. Throws `IllegalArgumentException` if the description is empty or priority is invalid.
 *         *   `processNextTask()`: Removes and returns the next task from the pending queue. If the queue is empty, it should indicate that there are no tasks to process.
 *         *   `listAllTasks()`: Prints all tasks stored in the list.
 *         *   `listPendingTasks()`: Prints all tasks currently in the pending queue without removing them.
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of a separate class (or within `TaskManager` if preferred, but keep logic separate).
 *     *   Use `java.util.Scanner` to read user input from `System.in`.
 *     *   Support the following commands (case-insensitive for command, case-sensitive for priority values "HIGH", "MEDIUM", "LOW"):
 *         *   `add <priority> <description>`: Adds a new task. `<priority>` must be "HIGH", "MEDIUM", or "LOW". `<description>` is the rest of the line.
 *         *   `process`: Processes the next task from the pending queue.
 *         *   `list all`: Lists all tasks ever added.
 *         *   `list pending`: Lists tasks currently in the pending queue.
 *         *   `exit`: Terminates the program.
 *     *   Use a `switch` statement to handle the different commands.
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, invalid priority, empty queue for processing).
 *     *   Use `System.out` for normal output (prompts, success messages, task lists).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. This should wrap the main command processing loop to catch unexpected errors and also handle specific exceptions like the `IllegalArgumentException` thrown by `addTask`.
 *     *   Validate user input format for commands (`add`, `list`).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Examples:
 * 
 * ```
 * Task Management System
 * Commands: add <priority> <description>, process, list all, list pending, exit
 * > add HIGH Write report
 * Task added.
 * > add LOW Clean desk
 * Task added.
 * > list pending
 * --- Pending Tasks ---
 * 1. [Priority: HIGH] Write report
 * 2. [Priority: LOW] Clean desk
 * ---------------------
 * > process
 * Processing task: [Priority: HIGH] Write report
 * > process
 * Processing task: [Priority: LOW] Clean desk
 * > process
 * No pending tasks to process.
 * > add MEDIUM Plan meeting
 * Task added.
 * > list all
 * --- All Tasks ---
 * 1. [Priority: HIGH] Write report
 * 2. [Priority: LOW] Clean desk
 * 3. [Priority: MEDIUM] Plan meeting
 * -----------------
 * > list pending
 * --- Pending Tasks ---
 * 1. [Priority: MEDIUM] Plan meeting
 * ---------------------
 * > add URGENT Fix bug
 * Error: Invalid priority: URGENT. Valid priorities are: [HIGH, MEDIUM, LOW]
 * > add HIGH
 * Error: Add command requires priority and description.
 * > list
 * Error: List command requires 'all' or 'pending'.
 * > unknown command
 * Error: Unknown command.
 * > exit
 * Exiting.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of `Task` and `TaskManager` classes.
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Effective use of `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Proper implementation of `try-catch` for exception handling, including validation exceptions.
 * *   Adherence to best practices (encapsulation, naming, comments, input validation).
 * *   Program logic correctly reflects task adding, processing, and listing.
 * 
 * **Note:** You may put all classes in a single file for submission convenience if allowed by your environment, but maintain class boundaries conceptually.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic POJO (Plain Old Java Object) representing a task with `description` and `priority`. It includes a constructor and overrides `toString()` for easy printing. Fields are `private` ensuring encapsulation.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the core logic. It holds two collections: `pendingTasks` (a `Queue`) and `allTasks` (a `List`/`ArrayList`).
 *     *   `pendingTasks` is declared as `Queue<Task>` and instantiated as `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for processing tasks in the order they were added (within the context of this simple system).
 *     *   `allTasks` is declared as `List<Task>` and instantiated as `new ArrayList<>()`. This list keeps a historical record of every task added, allowing the `list all` command.
 *     *   `addTask`: Takes description and priority, validates them (checking for empty description and valid priority string). If validation fails, it throws an `IllegalArgumentException`. If valid, it creates a `Task` object and adds it to *both* the `pendingTasks` queue (`offer` method) and the `allTasks` list (`add` method).
 *     *   `processNextTask`: Uses `pendingTasks.poll()`. `poll()` retrieves and removes the head of the queue, returning `null` if the queue is empty. This handles the case where there are no tasks to process gracefully.
 *     *   `listAllTasks`: Iterates through the `allTasks` `ArrayList` using a traditional `for` loop with an index to display task numbers.
 *     *   `listPendingTasks`: Iterates through the `pendingTasks` `Queue` using an enhanced `for` loop. Iterating over a `Queue` does not remove elements, fulfilling the requirement to list without processing.
 * 
 * 3.  **`TaskSystemCLI` Class (`main` method):**
 *     *   This class contains the `main` method, serving as the command-line interface.
 *     *   A `Scanner` is used to read input lines from `System.in`.
 *     *   The core logic is wrapped in a `try-catch(Exception e)` block. This fulfills the "class-wide exception handling" requirement by providing a top-level handler for any unexpected exceptions that might occur during the execution of the command loop.
 *     *   Inside the `try` block, a `while(true)` loop runs until the `exit` command is given.
 *     *   Input lines are read, trimmed, and split into a command and arguments using `split("\\s+", 2)`. The `2` limit ensures only the first whitespace separates the command from the rest of the line, making argument parsing easier.
 *     *   A `switch` statement dispatches logic based on the command (converted to lowercase).
 *     *   **Command Handling:**
 *         *   `add`: Further splits the arguments part (`parts[1]`) to get the priority and description. It includes checks (`parts.length`, `addArgs.length`) to ensure the correct number of arguments are provided. It then calls `taskManager.addTask()`. A nested `try-catch(IllegalArgumentException e)` specifically catches validation errors thrown by `addTask` and prints them to `System.err`.
 *         *   `process`: Calls `taskManager.processNextTask()`. Includes a check for extra arguments.
 *         *   `list`: Checks for the required argument (`all` or `pending`) and uses a nested `switch` statement to call the appropriate `TaskManager` listing method. Includes a check for invalid list types.
 *         *   `exit`: Prints an exit message, closes the `Scanner` resource, and uses `return` to terminate the `main` method and thus the program. Includes a check for extra arguments.
 *         *   `default`: Handles any unrecognized commands, printing an error to `System.err`.
 *     *   **Error Output:** `System.err` is used consistently for all error messages (invalid command format, invalid priority, unknown command, unexpected exceptions).
 *     *   **Normal Output:** `System.out` is used for prompts, success messages ("Task added."), and listing tasks.
 *     *   **Resource Management:** The `Scanner` is explicitly closed when the `exit` command is processed. The `finally` block in the main `try-catch` is included as a best practice to ensure cleanup (like closing the scanner) even if an unexpected exception occurs, although in this specific case, closing on `exit` is sufficient and safer for `System.in`.
 * 
 * This solution effectively combines the required data structures (`Queue`, `List`/`ArrayList`), control flow (`Scanner`, `switch`), and error handling mechanisms (`System.out`, `System.err`, `try-catch`, `IllegalArgumentException`) within a practical, encapsulated, and well-structured program, meeting the advanced requirements of the exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays;

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority; // e.g., "HIGH", "MEDIUM", "LOW"

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task ("HIGH", "MEDIUM", "LOW").
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    // Getters are good practice, though not strictly required by this problem's output format
    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     *
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        return "[Priority: " + priority + "] " + description;
    }
}

/**
 * Manages a collection of tasks, including a pending queue and a history list.
 */
class TaskManager {
    // Use Queue for pending tasks (FIFO processing order)
    private Queue<Task> pendingTasks;
    // Use List/ArrayList to keep a record of all tasks ever added
    private List<Task> allTasks;

    private static final List<String> VALID_PRIORITIES = Arrays.asList("HIGH", "MEDIUM", "LOW");

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.allTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the system.
     * Validates input and adds the task to both the pending queue and the all tasks list.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task ("HIGH", "MEDIUM", "LOW").
     * @throws IllegalArgumentException if description is empty or priority is invalid.
     */
    public void addTask(String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        String upperPriority = priority.toUpperCase();
        if (!VALID_PRIORITIES.contains(upperPriority)) {
            throw new IllegalArgumentException("Invalid priority: " + priority + ". Valid priorities are: " + VALID_PRIORITIES);
        }

        Task newTask = new Task(description.trim(), upperPriority);
        this.pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but works here too
        this.allTasks.add(newTask);
        // Output message handled by the caller (main method)
    }

    /**
     * Processes (removes and prints) the next task from the pending queue.
     * If the queue is empty, prints a message indicating so.
     */
    public void processNextTask() {
        Task taskToProcess = this.pendingTasks.poll(); // poll() retrieves and removes, returns null if empty
        if (taskToProcess == null) {
            System.out.println("No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            // In a real system, actual processing logic would go here.
        }
    }

    /**
     * Lists all tasks that have ever been added to the system.
     */
    public void listAllTasks() {
        if (this.allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            System.out.println("--- All Tasks ---");
            // Iterate through the List and print each task with an index
            for (int i = 0; i < this.allTasks.size(); i++) {
                System.out.println((i + 1) + ". " + this.allTasks.get(i));
            }
            System.out.println("-----------------");
        }
    }

    /**
     * Lists all tasks currently in the pending queue without removing them.
     */
    public void listPendingTasks() {
        if (this.pendingTasks.isEmpty()) {
            System.out.println("No tasks are pending.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate through the Queue (e.g., using enhanced for loop)
            // Note: Iterating over a Queue does NOT remove elements
            int count = 0;
            for (Task task : this.pendingTasks) {
                 System.out.println((count + 1) + ". " + task);
                 count++;
            }
            System.out.println("---------------------");
        }
    }
}

/**
 * Main class to run the Task Management System command-line interface.
 * Demonstrates Scanner, switch, System.out/err, and class-wide try-catch.
 */
public class TaskSystemCLI {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Task Management System");
        System.out.println("Commands: add <priority> <description>, process, list all, list pending, exit");

        // Class-wide exception handling wrapping the main operational loop
        try {
            while (true) {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim(); // Read the whole line and trim whitespace

                if (inputLine.isEmpty()) {
                    continue; // Skip empty input lines
                }

                // Split the input line into command and arguments (at most 2 parts)
                String[] parts = inputLine.split("\\s+", 2);
                String command = parts[0].toLowerCase(); // Get the command part

                // Use switch statement for command dispatch
                switch (command) {
                    case "add":
                        // Expected format: add <priority> <description>
                        if (parts.length < 2) {
                            System.err.println("Error: Add command requires priority and description.");
                            break; // Exit switch case
                        }
                        // Split the arguments part into priority and description (at most 2 parts)
                        String[] addArgs = parts[1].split("\\s+", 2);
                        if (addArgs.length < 2) {
                             System.err.println("Error: Add command requires priority and description.");
                             break; // Exit switch case
                        }
                        String priority = addArgs[0];
                        String description = addArgs[1];

                        try {
                            // Call task manager method; it handles validation internally
                            taskManager.addTask(description, priority);
                            System.out.println("Task added."); // Success message
                        } catch (IllegalArgumentException e) {
                            // Catch specific validation errors from addTask
                            System.err.println("Error: " + e.getMessage());
                        }
                        break; // Exit switch case for "add"

                    case "process":
                        // Expected format: process
                        if (parts.length > 1) {
                             System.err.println("Error: Process command does not take arguments.");
                             break;
                        }
                        taskManager.processNextTask();
                        break; // Exit switch case for "process"

                    case "list":
                        // Expected format: list <type> (where type is 'all' or 'pending')
                        if (parts.length < 2) {
                            System.err.println("Error: List command requires 'all' or 'pending'.");
                            break; // Exit switch case
                        }
                        String listType = parts[1].toLowerCase();
                        // Use nested switch for list type
                        switch (listType) {
                            case "all":
                                taskManager.listAllTasks();
                                break;
                            case "pending":
                                taskManager.listPendingTasks();
                                break;
                            default:
                                System.err.println("Error: Invalid list type. Use 'all' or 'pending'.");
                                break; // Exit nested switch
                        }
                        break; // Exit switch case for "list"

                    case "exit":
                        // Expected format: exit
                         if (parts.length > 1) {
                             System.err.println("Error: Exit command does not take arguments.");
                             break;
                        }
                        System.out.println("Exiting.");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method, terminating the program

                    default:
                        // Handle unknown commands
                        System.err.println("Error: Unknown command.");
                        break; // Exit switch case for default
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure scanner is closed if the loop is exited by an exception
            // Note: If 'exit' command is used, scanner is already closed.
            // This ensures cleanup if an unexpected error terminates the loop.
            // However, closing System.in can have side effects if other parts of the application
            // (not relevant in this simple example) rely on it. Closing on 'exit' is safer.
            // If the loop terminates due to an exception, the program is likely ending anyway,
            // so closing here is acceptable for resource management demonstration.
             if (scanner != null) {
                 // scanner.close(); // Already closed on 'exit', closing again is fine.
                                    // If exception happens before 'exit', this line ensures close.
             }
        }
    }
}
