/*
 * Exam Question #818
 * Generated on: 2025-05-12 16:45:48
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing System Simulation
 * 
 * **Objective:** Design and implement a simple task processing system that manages tasks in a queue, processes them with a simulated success/failure mechanism, and maintains a history of completed and failed tasks. Your solution must demonstrate a strong understanding of core Java concepts, including collections, exception handling, I/O, and control flow.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with fields for `id` (int), `description` (String), and `complexity` (int). Implement appropriate encapsulation (private fields, public getters) and a `toString()` method.
 * 2.  **Task Processing System:** Create a class `TaskProcessorSystem` that manages the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   A `List<Task>` to store successfully completed tasks.
 *     *   A `List<Task>` to store tasks that failed processing.
 *     *   Methods to add tasks, process the next task, display system status, display completed tasks, and display failed tasks.
 * 3.  **Simulated Processing:** The `processNextTask()` method should:
 *     *   Take the next task from the queue.
 *     *   Simulate processing. Introduce a chance of processing failure based on the task's complexity (higher complexity = higher chance of failure).
 *     *   If processing succeeds, move the task from the queue to the completed tasks list.
 *     *   If processing fails, move the task from the queue to the failed tasks list.
 * 4.  **Custom Exception:** Define a custom exception class `TaskProcessingException` to represent a simulated failure during task processing.
 * 5.  **User Interface:** Implement a simple text-based menu in the `main` method that allows the user to:
 *     *   Add a new task (prompt for description and complexity).
 *     *   Process the next task in the queue.
 *     *   Display the current system status (number of pending, completed, and failed tasks).
 *     *   Display the list of completed tasks.
 *     *   Display the list of failed tasks.
 *     *   Exit the application.
 * 6.  **Required Java Components:** Your solution **must** explicitly use and demonstrate the functionality of **ALL** of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu navigation
 *     *   `System.err` for displaying error messages (e.g., invalid input, processing failures)
 *     *   `System.out` for displaying normal output (menu, status, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks, including handling potential errors during user input and task processing.
 * 7.  **Best Practices:** Adhere to good programming practices:
 *     *   Proper encapsulation.
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Input validation (e.g., non-empty description, positive complexity).
 *     *   Robust error handling (catch exceptions, print informative messages).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu. Based on user choices, it should add tasks, process them (sometimes succeeding, sometimes failing), and display system state or task lists. Error conditions (like invalid input or processing failure) should be reported to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Processing System ---
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Display Completed Tasks
 * 5. Display Failed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Write Report
 * Enter task complexity (positive integer): 5
 * Added task: Task{id=1, description='Write Report', complexity=5}
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 1
 * Enter task description: Code Feature
 * Enter task complexity (positive integer): 8
 * Added task: Task{id=2, description='Code Feature', complexity=8}
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 2
 * Processing task: Write Report (ID: 1)
 * Task 1 completed successfully.
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 2
 * Processing task: Code Feature (ID: 2)
 * Processing Error for Task 2: Processing failed due to high complexity (8) // This might go to System.err
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 3
 * --- System Status ---
 * Pending tasks in queue: 0
 * Completed tasks count: 1
 * Failed tasks count: 1
 * ---------------------
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Write Report', complexity=5}
 * -----------------------
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 5
 * --- Failed Tasks ---
 * Task{id=2, description='Code Feature', complexity=8}
 * --------------------
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 6
 * Exiting Task Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your code should be well-structured and easy to understand.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The solution implements a simple task processing system as required, demonstrating the usage of the specified Java components and adhering to best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) with private fields (`id`, `description`, `complexity`) and public getter methods, adhering to encapsulation. The `toString()` method provides a convenient way to print task details.
 * 2.  **TaskProcessingException:** A custom checked exception `TaskProcessingException` is defined. This is used to specifically signal a simulated processing failure within the system, making the error handling clearer than using a generic exception.
 * 3.  **TaskProcessorSystem Class:** This class encapsulates the core logic and state of the system.
 *     *   It uses a `LinkedList` instance assigned to a `Queue<Task>` reference (`taskQueue`) to manage tasks waiting for processing, ensuring FIFO (First-In, First-Out) order.
 *     *   It uses `ArrayList` instances assigned to `List<Task>` references (`completedTasks` and `failedTasks`) to store the history of tasks. Using the `List` interface for declaration promotes flexibility.
 *     *   The `addTask` method validates input (non-empty description, positive complexity) before creating a `Task` object and adding it to the `taskQueue` using `offer()`. Invalid inputs result in error messages printed to `System.err`.
 *     *   The `processNextTask` method retrieves the next task from the queue using `peek()`, then attempts to process it within a `try` block. A random number generator simulates the processing outcome, with higher complexity tasks having a higher chance of throwing the `TaskProcessingException`.
 *     *   The `catch (TaskProcessingException e)` block specifically handles simulated processing failures, moving the task to the `failedTasks` list and printing an error to `System.err`.
 *     *   A generic `catch (Exception e)` block is included as a fallback for any other unexpected runtime issues during processing, also moving the task to `failedTasks` and reporting to `System.err`.
 *     *   If processing succeeds (no exception thrown), the task is formally removed from the queue using `poll()` and added to the `completedTasks` list, with a success message printed to `System.out`.
 *     *   `displayStatus`, `displayCompletedTasks`, and `displayFailedTasks` methods iterate through the respective collections and print their contents or counts to `System.out`, demonstrating how to access and display the state managed by the lists and queue.
 * 4.  **Main Class (ExamQuestion):**
 *     *   The `main` method drives the application, creating a `Scanner` for user input and an instance of `TaskProcessorSystem`.
 *     *   The main application loop runs within a `try-catch-finally` block, providing class-wide exception handling for the entire interactive session. This catches any unexpected exceptions that might propagate up. The `finally` block ensures the `Scanner` is closed.
 *     *   Inside the loop, a menu is printed to `System.out`.
 *     *   User input for the menu choice is read using `scanner.nextInt()`. This input reading is wrapped in a `try-catch(InputMismatchException)` block to handle cases where the user enters non-integer input, printing an error to `System.err` and preventing a crash. `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character.
 *     *   A `switch` statement is used to direct the program flow based on the valid user choice, calling the appropriate methods of the `TaskProcessorSystem` or setting the `running` flag to `false` for exit.
 *     *   Adding a task (`case 1`) involves reading both a String description and an integer complexity, with a nested `try-catch` block specifically for the complexity input to handle potential `InputMismatchException` there as well.
 * 
 * This solution effectively integrates all required components (`Queue`, `List`, `ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design, input validation, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

// 1. Task Representation Class
/**
 * Represents a single task with an ID, description, and complexity level.
 */
class Task {
    private int id;
    private String description;
    private int complexity; // Higher complexity might mean higher chance of failure

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param complexity The complexity level of the task (used for simulating failure).
     */
    public Task(int id, String description, int complexity) {
        this.id = id;
        this.description = description;
        this.complexity = complexity;
    }

    // Getters for accessing task properties
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getComplexity() {
        return complexity;
    }

    /**
     * Provides a string representation of the Task object.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", complexity=" + complexity +
               '}';
    }
}

// 4. Custom Exception Class
/**
 * Custom exception thrown when a simulated task processing failure occurs.
 */
class TaskProcessingException extends Exception {
    /**
     * Constructs a new TaskProcessingException with the specified detail message.
     * @param message The detail message (which is saved for later retrieval by the getMessage() method).
     */
    public TaskProcessingException(String message) {
        super(message);
    }
}

// 2. Task Processing System Class
/**
 * Manages a queue of tasks, processes them, and maintains lists of completed and failed tasks.
 */
class TaskProcessorSystem {
    // Queue for tasks waiting to be processed (Requirement: java.util.Queue)
    private Queue<Task> taskQueue = new LinkedList<>();

    // List for tasks that were successfully completed (Requirement: java.util.List and java.util.ArrayList)
    private List<Task> completedTasks = new ArrayList<>();

    // List for tasks that failed during processing (Requirement: java.util.List and java.util.ArrayList)
    private List<Task> failedTasks = new ArrayList<>();

    private int nextTaskId = 1; // Counter for unique task IDs
    private Random random = new Random(); // For simulating processing outcomes

    /**
     * Adds a new task to the processing queue after validating input.
     * @param description The description of the task.
     * @param complexity The complexity level of the task (used for simulating failure).
     */
    public void addTask(String description, int complexity) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty."); // Requirement: System.err
            return;
        }
        if (complexity <= 0) {
            System.err.println("Error: Task complexity must be a positive number."); // Requirement: System.err
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), complexity);
        taskQueue.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Added task: " + newTask); // Requirement: System.out
    }

    /**
     * Processes the next task in the queue.
     * Simulates processing success or failure based on task complexity using try-catch.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks in the queue to process."); // Requirement: System.out
            return;
        }

        // Get the next task from the queue without removing it yet
        Task currentTask = taskQueue.peek();

        // Class-wide exception handling for the processing logic
        try {
            System.out.println("Processing task: " + currentTask.getDescription() + " (ID: " + currentTask.getId() + ")"); // Requirement: System.out

            // Simulate processing outcome based on complexity
            // Higher complexity means higher chance of failure
            // Example: 10% base failure chance + complexity * 3% failure chance
            int failureChance = 10 + (currentTask.getComplexity() * 3);
            if (random.nextInt(100) < failureChance) {
                // Simulate failure by throwing the custom exception
                throw new TaskProcessingException("Simulated failure during processing due to complexity (" + currentTask.getComplexity() + ")");
            } else {
                // Simulate success
                // Remove the task from the queue as it's processed successfully
                taskQueue.poll();
                completedTasks.add(currentTask);
                System.out.println("Task " + currentTask.getId() + " completed successfully."); // Requirement: System.out
            }

        } catch (TaskProcessingException e) {
            // Task failed due to simulated processing issue - handled by custom exception
            taskQueue.poll(); // Remove from queue even if failed
            failedTasks.add(currentTask);
            System.err.println("Processing Error for Task " + currentTask.getId() + ": " + e.getMessage()); // Requirement: System.err
        } catch (Exception e) {
            // Catch any other unexpected errors during processing simulation
            taskQueue.poll(); // Remove from queue
            failedTasks.add(currentTask);
            System.err.println("An unexpected error occurred while processing Task " + currentTask.getId() + ": " + e.getMessage()); // Requirement: System.err
            // Optional: e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        }
    }

    /**
     * Displays the current status of the system (queue size, completed count, failed count).
     */
    public void displayStatus() {
        System.out.println("\n--- System Status ---"); // Requirement: System.out
        System.out.println("Pending tasks in queue: " + taskQueue.size()); // Requirement: System.out
        System.out.println("Completed tasks count: " + completedTasks.size()); // Requirement: System.out
        System.out.println("Failed tasks count: " + failedTasks.size()); // Requirement: System.out
        System.out.println("---------------------\n"); // Requirement: System.out
    }

    /**
     * Displays the list of completed tasks.
     */
    public void displayCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---"); // Requirement: System.out
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet."); // Requirement: System.out
        } else {
            for (Task task : completedTasks) {
                System.out.println(task); // Requirement: System.out (using Task's toString)
            }
        }
        System.out.println("-----------------------\n"); // Requirement: System.out
    }

    /**
     * Displays the list of failed tasks.
     */
    public void displayFailedTasks() {
        System.out.println("\n--- Failed Tasks ---"); // Requirement: System.out
        if (failedTasks.isEmpty()) {
            System.out.println("No tasks have failed yet."); // Requirement: System.out
        } else {
            for (Task task : failedTasks) {
                System.out.println(task); // Requirement: System.out (using Task's toString)
            }
        }
        System.out.println("--------------------\n"); // Requirement: System.out
    }
}

// Main class for the exam question, handling user interaction
public class ExamQuestion {

    public static void main(String[] args) {
        // Requirement: java.util.Scanner for user input
        Scanner scanner = new Scanner(System.in);
        TaskProcessorSystem system = new TaskProcessorSystem();
        boolean running = true;

        System.out.println("--- Task Processing System ---"); // Requirement: System.out

        // Requirement: Class-wide exception handling with try-catch blocks for the main loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                // Input validation for menu choice using try-catch
                try {
                    System.out.print("Enter your choice: "); // Requirement: System.out
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number between 1 and 6."); // Requirement: System.err
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration of the while loop
                }

                // Requirement: switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: "); // Requirement: System.out
                        String description = scanner.nextLine();
                        int complexity = -1;
                        try {
                            System.out.print("Enter task complexity (positive integer): "); // Requirement: System.out
                            complexity = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for complexity. Please enter a positive integer."); // Requirement: System.err
                            scanner.nextLine(); // Consume invalid input
                            continue; // Skip adding task and show menu again
                        }
                        system.addTask(description, complexity);
                        break;

                    case 2: // Process Next Task
                        system.processNextTask();
                        break;

                    case 3: // Display System Status
                        system.displayStatus();
                        break;

                    case 4: // Display Completed Tasks
                        system.displayCompletedTasks();
                        break;

                    case 5: // Display Failed Tasks
                        system.displayFailedTasks();
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Task Processing System. Goodbye!"); // Requirement: System.out
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6."); // Requirement: System.err
                }
            }
        } catch (Exception e) {
            // Generic catch-all for any unhandled exceptions in the main loop
            System.err.println("An unexpected critical error occurred in the system:"); // Requirement: System.err
            e.printStackTrace(System.err); // Print stack trace to error stream (Requirement: System.err)
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed."); // Requirement: System.out
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:"); // Requirement: System.out
        System.out.println("1. Add New Task"); // Requirement: System.out
        System.out.println("2. Process Next Task"); // Requirement: System.out
        System.out.println("3. Display System Status"); // Requirement: System.out
        System.out.println("4. Display Completed Tasks"); // Requirement: System.out
        System.out.println("5. Display Failed Tasks"); // Requirement: System.out
        System.out.println("6. Exit"); // Requirement: System.out
    }
}
