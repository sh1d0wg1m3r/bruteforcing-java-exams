/*
 * Exam Question #824
 * Generated on: 2025-05-12 16:46:44
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Support Ticket Processing System
 * 
 * **Difficulty:** Advanced
 * 
 * **Time Allotment:** 45-60 minutes
 * 
 * **Description:**
 * 
 * Design and implement a simplified system for managing support tickets. This system should simulate the flow of tickets from arrival to resolution, allowing users to interact via a command-line interface. The core functionality involves adding new tickets, processing the next available ticket, resolving the ticket currently being processed, and viewing the status of tickets in different stages.
 * 
 * **Requirements:**
 * 
 * 1.  **SupportTicket Class:**
 *     *   Create a class named `SupportTicket`.
 *     *   It must have private fields for `id` (int), `description` (String), and `status` (String, e.g., "New", "In Progress", "Resolved").
 *     *   Implement a constructor that takes an ID and description, initializes the status to "New". Include basic validation (e.g., description cannot be empty).
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for `status` with basic validation.
 *     *   Override the `toString()` method to provide a user-friendly representation of the ticket.
 *     *   Adhere to proper encapsulation principles.
 * 
 * 2.  **TicketProcessingSystem Class:**
 *     *   Create a class named `TicketProcessingSystem`.
 *     *   It must contain a `java.util.Queue<SupportTicket>` to hold tickets with status "New" (pending).
 *     *   It must contain a `java.util.List<SupportTicket>` (specifically using `java.util.ArrayList`) to store tickets with status "Resolved" (history).
 *     *   Maintain a private field to hold the `SupportTicket` currently being processed (status "In Progress"). Only one ticket can be in this state at a time.
 *     *   Implement a constructor to initialize the collections and any necessary counters (e.g., for generating unique ticket IDs).
 *     *   Implement methods for the following operations:
 *         *   `addTicket(String description)`: Creates a new `SupportTicket` with a unique ID and "New" status, and adds it to the pending queue.
 *         *   `processNextTicket()`: Removes the next ticket from the pending queue, sets its status to "In Progress", and assigns it to the currently processing field. If the queue is empty or a ticket is already being processed, display an error message using `System.err`.
 *         *   `resolveCurrentTicket()`: Sets the status of the currently processing ticket to "Resolved", adds it to the processed history list, and clears the currently processing field. If no ticket is currently being processed, display an error message using `System.err`.
 *         *   `viewPendingTickets()`: Iterates through and displays details of all tickets in the pending queue using `System.out`.
 *         *   `viewProcessedTicketsHistory()`: Iterates through and displays details of all tickets in the processed history list using `System.out`.
 *         *   `viewCurrentlyProcessing()`: Displays details of the ticket currently being processed using `System.out`.
 *     *   Implement a `run()` method (or similar) that contains the main application loop.
 *     *   Inside the `run()` method:
 *         *   Use `java.util.Scanner` to get user input for menu choices and ticket descriptions.
 *         *   Display a menu of options (Add Ticket, Process Next, Resolve, View Pending, View Processed, Exit) using `System.out`.
 *         *   Use a `switch` statement to handle the user's menu choice.
 *         *   Implement input validation for the menu choice (ensure it's an integer within the valid range).
 *         *   Implement class-wide exception handling using `try-catch` blocks around the main loop's operations. Specifically catch `java.util.InputMismatchException` for invalid integer input and a general `Exception` for any other unexpected errors, reporting them using `System.err`.
 *         *   Use `System.out` for all normal output (menu, successful actions, ticket details).
 *         *   Use `System.err` for all error messages (invalid input, operational errors like empty queue, etc.).
 *         *   The loop should continue until the user selects the Exit option.
 *         *   Ensure the `Scanner` is closed when the program exits.
 * 
 * 3.  **Main Method:**
 *     *   Create a `main` method in `TicketProcessingSystem` or a separate class to create an instance of `TicketProcessingSystem` and call its `run()` method to start the application.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a menu. Based on user input, it should perform the requested ticket operations, printing information to `System.out` for successful actions and ticket details, and printing error messages to `System.err` for failures or invalid input. The system should handle errors gracefully and continue running until the user chooses to exit.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Ticket Processing Menu ---
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. Resolve Current Ticket
 * 4. View Pending Tickets
 * 5. View Processed Tickets History
 * 6. Exit
 * ------------------------------
 * Enter your choice: 1
 * Enter ticket description: Internet connection issue
 * Ticket added successfully.
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tickets ---
 * Ticket [ID=1, Status=New, Description='Internet connection issue']
 * Total pending: 1
 * -----------------------
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 2
 * Started processing ticket ID: 1
 * Description: Internet connection issue
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tickets ---
 * No pending tickets.
 * Total pending: 0
 * -----------------------
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 2
 * Cannot process a new ticket. Another ticket (ID: 1) is currently being processed. (This message goes to System.err)
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 3
 * Ticket ID: 1 resolved and moved to history.
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 5
 * --- Processed Tickets History ---
 * Ticket [ID=1, Status=Resolved, Description='Internet connection issue']
 * Total processed: 1
 * -------------------------------
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6. (This message goes to System.err)
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number. (This message goes to System.err)
 * 
 * --- Ticket Processing Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Ticket Processing System.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simplified Support Ticket Processing System as required by the exam task. It demonstrates the use of several core Java concepts and collections in a practical scenario.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Models the fundamental entity in the system, encapsulating its state (`id`, `description`, `status`).
 *     *   Uses private fields and public getters/setters, adhering to **encapsulation**.
 *     *   The constructor includes basic **input validation** for the description, throwing `IllegalArgumentException` if invalid, showcasing how objects can enforce their own invariants.
 *     *   The `toString()` method provides a clear string representation, useful for displaying ticket information.
 * 
 * 2.  **`TicketProcessingSystem` Class:**
 *     *   Acts as the controller or manager for the system.
 *     *   **`java.util.Queue` (`pendingTickets`):** A `LinkedList` is used to implement the `Queue` interface, representing tickets waiting to be processed. The FIFO (First-In, First-Out) nature of the queue is naturally suited for a waiting line of tasks. `offer()` is used for adding (preferred over `add()` in queues as it handles capacity-constrained queues gracefully, though not strictly necessary here) and `poll()` for removing from the head (returns `null` if empty, avoiding exceptions).
 *     *   **`java.util.List` (`processedTickets`):** An `ArrayList` is used to implement the `List` interface, storing tickets once they are resolved. `ArrayList` provides dynamic resizing and efficient element access by index (though not heavily used here, it's a common List implementation). The `List` interface itself is used for the field declaration, promoting coding to interfaces.
 *     *   **State Management (`currentlyProcessing`):** A simple field is used to track the single ticket that is currently being processed, demonstrating how system state can be managed.
 *     *   **Methods:** Separate public methods (`addTicket`, `processNextTicket`, `resolveCurrentTicket`, `viewPendingTickets`, `viewProcessedTicketsHistory`, `viewCurrentlyProcessing`) break down the functionality, improving code organization and readability. Private helper methods (`printMenu`) are used for internal tasks.
 *     *   **Unique ID Generation:** A simple counter (`nextTicketId`) is used to generate unique IDs for new tickets.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   **`java.util.Scanner`:** Used to read input from the console, enabling user interaction with the menu.
 *     *   **`switch` Statement:** Effectively handles the dispatching of actions based on the user's numeric menu choice. The `default` case catches invalid integer inputs within the allowed range.
 *     *   **Main Loop:** The `while (choice != 7)` loop keeps the application running until the user explicitly chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   **`System.err`:** Used consistently to output error messages, distinguishing them from normal program output (`System.out`). This is a standard practice for reporting non-fatal errors or warnings.
 *     *   **Operational Error Checks:** Methods like `processNextTicket` and `resolveCurrentTicket` explicitly check for invalid states (e.g., queue empty, no ticket processing) and report errors via `System.err`, preventing operations from being attempted when conditions aren't met.
 *     *   **`try-catch` Blocks:**
 *         *   A `try-catch(InputMismatchException e)` block is used around `scanner.nextInt()` to catch non-integer input for the menu choice. This prevents the program from crashing and prompts the user to try again.
 *         *   A general `try-catch(Exception e)` block is used around the core `switch` logic within the loop. This provides a safety net to catch any other unexpected runtime exceptions that might occur during the execution of an operation, preventing the entire application from terminating abruptly. It reports the error message and allows the loop to continue for the next menu interaction.
 *         *   `IllegalArgumentException` is caught during ticket creation (`addTicket`) and resolution (`resolveCurrentTicket`), demonstrating handling of exceptions thrown by other objects (`SupportTicket` constructor/setter).
 * 
 * 5.  **Best Practices:**
 *     *   **Meaningful Names:** Classes, methods, and variables have descriptive names reflecting their purpose (e.g., `pendingTickets`, `processNextTicket`, `currentlyProcessing`).
 *     *   **Comments and Documentation:** Javadoc-style comments are used for classes and methods, explaining their purpose, parameters, and potential exceptions. Inline comments clarify specific code sections.
 *     *   **Clean Code Structure:** Functionality is divided into logical methods and classes. The main loop in `run()` delegates tasks to specific methods, keeping the loop body clean.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, structured, and well-handled application simulation, demonstrating a solid understanding of intermediate to advanced Java programming concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single support ticket in the system.
 */
class SupportTicket {
    private int id;
    private String description;
    private String status; // e.g., "New", "In Progress", "Resolved"

    /**
     * Constructs a new SupportTicket.
     *
     * @param id The unique identifier for the ticket.
     * @param description A brief description of the issue.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public SupportTicket(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = "New"; // Initial status
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---

    /**
     * Sets the status of the ticket.
     * Basic validation is performed.
     *
     * @param status The new status for the ticket.
     * @throws IllegalArgumentException if the status is null or empty.
     */
    public void setStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
            throw new IllegalArgumentException("Status cannot be null or empty.");
        }
        // Could add more complex validation here to ensure valid status transitions
        this.status = status.trim();
    }

    // --- toString ---

    /**
     * Provides a string representation of the ticket.
     *
     * @return A formatted string representing the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the flow and processing of support tickets.
 */
public class TicketProcessingSystem {
    private Queue<SupportTicket> pendingTickets;
    private List<SupportTicket> processedTickets;
    private SupportTicket currentlyProcessing; // Ticket currently being worked on
    private int nextTicketId; // Counter for generating unique IDs

    /**
     * Constructs a new TicketProcessingSystem, initializing collections and ID counter.
     */
    public TicketProcessingSystem() {
        // Use LinkedList as a common implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as a common implementation of List
        this.processedTickets = new ArrayList<>();
        this.currentlyProcessing = null; // No ticket being processed initially
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue.
     *
     * @param description The description for the new ticket.
     */
    public void addTicket(String description) {
        try {
            SupportTicket newTicket = new SupportTicket(nextTicketId++, description);
            pendingTickets.offer(newTicket); // offer() is preferred over add() for queues
            System.out.println("Ticket added successfully. ID: " + newTicket.getId());
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding ticket: " + e.getMessage());
            // Do not increment nextTicketId if ticket creation failed
        }
    }

    /**
     * Starts processing the next ticket from the pending queue.
     */
    public void processNextTicket() {
        if (currentlyProcessing != null) {
            System.err.println("Cannot process a new ticket. Another ticket (ID: " + currentlyProcessing.getId() + ") is currently being processed.");
            return; // Exit method if already processing
        }

        SupportTicket nextTicket = pendingTickets.poll(); // Retrieves and removes the head of the queue, or returns null if queue is empty
        if (nextTicket == null) {
            System.err.println("No pending tickets to process.");
        } else {
            currentlyProcessing = nextTicket;
            currentlyProcessing.setStatus("In Progress");
            System.out.println("Started processing ticket ID: " + currentlyProcessing.getId());
            System.out.println("Description: " + currentlyProcessing.getDescription());
        }
    }

    /**
     * Resolves the ticket currently being processed.
     */
    public void resolveCurrentTicket() {
        if (currentlyProcessing == null) {
            System.err.println("No ticket is currently being processed to resolve.");
            return; // Exit method if nothing is processing
        }

        try {
            currentlyProcessing.setStatus("Resolved");
            processedTickets.add(currentlyProcessing);
            System.out.println("Ticket ID: " + currentlyProcessing.getId() + " resolved and moved to history.");
            currentlyProcessing = null; // Clear the currently processing slot
        } catch (IllegalArgumentException e) {
             // This catch is unlikely given our simple status setter, but good practice
            System.err.println("Error resolving ticket ID " + currentlyProcessing.getId() + ": " + e.getMessage());
        }
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            int count = 0;
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket); // Uses Ticket's toString()
                count++;
            }
            System.out.println("Total pending: " + count);
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the ticket currently being processed.
     */
    public void viewCurrentlyProcessing() {
         System.out.println("\n--- Currently Processing ---");
         if (currentlyProcessing == null) {
             System.out.println("No ticket is currently being processed.");
         } else {
             System.out.println(currentlyProcessing); // Uses Ticket's toString()
         }
         System.out.println("----------------------------");
    }


    /**
     * Displays all tickets in the processed history list.
     */
    public void viewProcessedTicketsHistory() {
        System.out.println("\n--- Processed Tickets History ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No processed tickets in history.");
        } else {
            for (SupportTicket ticket : processedTickets) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
            System.out.println("Total processed: " + processedTickets.size());
        }
        System.out.println("-------------------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Ticket Processing Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. Resolve Current Ticket");
        System.out.println("4. View Pending Tickets");
        System.out.println("5. View Processed Tickets History");
        System.out.println("6. View Currently Processing Ticket"); // Added for clarity
        System.out.println("7. Exit"); // Adjusted exit option
        System.out.println("------------------------------");
    }

    /**
     * Runs the main application loop, handling user input and operations.
     * Includes robust error handling for input and operations.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize outside the loop

        // Loop until the user chooses to exit (option 7)
        while (choice != 7) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                // Read the integer choice
                choice = scanner.nextInt();
                // Consume the rest of the line (including the newline character)
                scanner.nextLine();

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        addTicket(description);
                        break;
                    case 2: // Process Next Ticket
                        processNextTicket();
                        break;
                    case 3: // Resolve Current Ticket
                        resolveCurrentTicket();
                        break;
                    case 4: // View Pending Tickets
                        viewPendingTickets();
                        break;
                    case 5: // View Processed Tickets
                        viewProcessedTicketsHistory();
                        break;
                    case 6: // View Currently Processing
                         viewCurrentlyProcessing();
                         break;
                    case 7: // Exit
                        System.out.println("Exiting Ticket Processing System.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to an invalid value to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during operation execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging
                // e.printStackTrace(System.err);
            }
            // Add a blank line for better readability between menu iterations
            System.out.println();
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Main method to start the Ticket Processing System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TicketProcessingSystem system = new TicketProcessingSystem();
        system.run(); // Start the main application loop
    }
}
