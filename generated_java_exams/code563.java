/*
 * Exam Question #563
 * Generated on: 2025-05-11 23:29:55
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for a document processing workflow. Documents arrive and are placed in a queue awaiting processing. A user can trigger the processing of the next document in the queue. Once processed, the document is moved to an archive. The system should allow users to add new documents, process the next document, view the current processing queue, and view the archived documents.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the processing queue (First-In, First-Out).
 *     *   Use a `java.util.List` interface type, instantiated with `java.util.ArrayList`, to store the archived documents.
 *     *   Create a simple `Document` class to hold document information (e.g., an ID and a title).
 * 
 * 2.  **Core Functionality:**
 *     *   **Add Document:** Allow the user to add a new document by providing a title. Assign a unique ID to each document (starting from 1). Add the new document to the processing queue.
 *     *   **Process Document:** Remove the next document from the processing queue and move it to the archived documents list.
 *     *   **View Queue:** Display the documents currently in the processing queue without removing them.
 *     *   **View Archive:** Display the documents currently in the archived documents list.
 *     *   **Exit:** Allow the user to exit the application.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console for menu choices and document details.
 *     *   Implement a menu-driven interface using a `switch` statement to handle different user commands.
 *     *   Print normal application output (menu, prompts, success messages, list contents) to `System.out`.
 *     *   Print error messages (invalid input, queue empty, etc.) to `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential issues.
 *     *   Specifically handle `java.util.InputMismatchException` if the user enters non-numeric input for a menu choice.
 *     *   Handle the case where the user attempts to process a document when the processing queue is empty. Use a `Queue` method that throws an exception (`remove()`) in this case and catch the appropriate exception (`java.util.NoSuchElementException`).
 *     *   Handle other potential exceptions or edge cases appropriately (e.g., adding a document with an empty title).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation: Keep data fields private and provide public methods for interaction.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Perform basic input validation where necessary (e.g., for document title).
 *     *   Structure your code clearly with separate classes for `Document`, the processing logic (e.g., `DocumentProcessor`), and the main application entry point (`Main`).
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, accept user input, perform the requested actions, print results to `System.out`, and print errors to `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Document Processing System ---
 * Select an action:
 * 1. Add New Document to Queue
 * 2. Process Next Document from Queue
 * 3. View Processing Queue
 * 4. View Archived Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document title: Report A
 * Added document 1: 'Report A' to the queue.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter document title: Presentation B
 * Added document 2: 'Presentation B' to the queue.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 3
 * --- Processing Queue ---
 * 1. Document 1: 'Report A'
 * 2. Document 2: 'Presentation B'
 * ------------------------
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Processing document 1: 'Report A'...
 * Document 1 processed and moved to archive.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 3
 * --- Processing Queue ---
 * 1. Document 2: 'Presentation B'
 * ------------------------
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 4
 * --- Archived Documents ---
 * 1. Document 1: 'Report A'
 * --------------------------
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Processing document 2: 'Presentation B'...
 * Document 2 processed and moved to archive.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Error: Processing queue is empty. No document to process.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an action:
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should include the code for all necessary classes (`Document`, `DocumentProcessor`, `Main`, etc.) in a single block.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accurate implementation of the document processing logic (add, process, view).
 * *   Robust error handling for invalid input and empty queue conditions.
 * *   Adherence to best practices (encapsulation, naming, comments, validation).
 * *   Overall code structure and readability.
 *
 * EXPLANATION:
 * The solution implements a simple document processing system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Document` Class:** A basic POJO (Plain Old Java Object) representing a document with a unique `id` and a `title`. Fields are `private` and accessed via `public` getter methods, adhering to encapsulation.
 * 
 * 2.  **`DocumentProcessor` Class:** This class encapsulates the core logic of the system.
 *     *   It holds the `processingQueue` (typed as `Queue<Document>`, implemented with `LinkedList`) and `archivedDocuments` (typed as `List<Document>`, implemented with `ArrayList`) as `private` fields. This demonstrates interface-based programming (`List`) and encapsulation.
 *     *   `nextDocumentId` is a `private` counter used to assign unique IDs, another example of encapsulation.
 *     *   Public methods (`addDocument`, `processNextDocument`, `viewProcessingQueue`, `viewArchivedDocuments`) provide the interface for interacting with the processor's state.
 *     *   `addDocument` uses `queue.offer()` to add elements to the queue and includes basic input validation for the title.
 *     *   `processNextDocument` uses `queue.remove()`. This method is chosen specifically because it throws `NoSuchElementException` if the queue is empty, allowing demonstration of catching this specific exception in the calling code (`Main`).
 *     *   `viewProcessingQueue` and `viewArchivedDocuments` iterate over the collections to display their contents using `System.out`.
 * 
 * 3.  **`Main` Class:** This is the application's entry point and handles the user interface and overall flow.
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   A `DocumentProcessor` object is created to manage the documents.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is displayed using `System.out`.
 *     *   **`try-catch` Block:** The core logic within the loop (reading input and the `switch` statement) is wrapped in a `try-catch` block. This provides class-wide exception handling for potential issues during user interaction or processing.
 *         *   `InputMismatchException` is caught specifically if `scanner.nextInt()` fails because the user entered non-numeric input. An error message is printed to `System.err`, and `scanner.nextLine()` is called to clear the invalid input from the buffer, preventing an infinite loop.
 *         *   `NoSuchElementException` is caught specifically. This exception is thrown by `processor.processNextDocument()` when the `processingQueue` is empty, and the error is reported to `System.err`.
 *         *   A general `Exception` catch block is included as a fallback for any other unexpected runtime errors, printing the error message to `System.err`.
 *     *   **`switch` Statement:** The user's valid integer choice is processed using a `switch` statement, directing control to the appropriate `DocumentProcessor` method or the exit logic.
 *     *   Normal output (menu, prompts, success messages) is directed to `System.out`.
 *     *   Error messages (validation failures, exceptions) are directed to `System.err`.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, adheres to object-oriented principles like encapsulation, and demonstrates robust error handling and input validation, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a document in the system.
 */
class Document {
    private final int id;
    private final String title;

    /**
     * Constructs a new Document.
     *
     * @param id    The unique identifier for the document.
     * @param title The title or name of the document.
     */
    public Document(int id, String title) {
        this.id = id;
        this.title = title;
    }

    /**
     * Gets the document ID.
     * @return The ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the document title.
     * @return The title.
     */
    public String getTitle() {
        return title;
    }

    /**
     * Returns a string representation of the Document.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Document{" +
               "id=" + id +
               ", title='" + title + '\'' +
               '}';
    }
}

/**
 * Manages the lifecycle of documents through a processing queue and an archive.
 */
class DocumentProcessor {
    private Queue<Document> processingQueue;
    private List<Document> archivedDocuments;
    private int nextDocumentId; // To generate unique IDs

    /**
     * Constructs a new DocumentProcessor.
     */
    public DocumentProcessor() {
        // Use LinkedList as a common implementation for Queue
        this.processingQueue = new LinkedList<>();
        // Use ArrayList as a common implementation for List
        this.archivedDocuments = new ArrayList<>();
        this.nextDocumentId = 1;
    }

    /**
     * Adds a new document to the processing queue.
     *
     * @param title The title of the document. Must not be null or empty.
     */
    public void addDocument(String title) {
        if (title == null || title.trim().isEmpty()) {
            System.err.println("Error: Document title cannot be empty.");
            return; // Input validation
        }
        Document newDoc = new Document(nextDocumentId++, title.trim());
        processingQueue.offer(newDoc); // offer() is generally preferred over add() for queues
        System.out.println("Added document " + newDoc.getId() + ": '" + newDoc.getTitle() + "' to the queue.");
    }

    /**
     * Processes the next document from the queue, moving it to the archive.
     * Throws NoSuchElementException if the queue is empty, which is handled by the caller.
     */
    public void processNextDocument() throws NoSuchElementException {
        // Using remove() to explicitly demonstrate catching NoSuchElementException
        Document processedDoc = processingQueue.remove(); // Throws NoSuchElementException if queue is empty

        // If remove() succeeds, process and archive
        System.out.println("Processing document " + processedDoc.getId() + ": '" + processedDoc.getTitle() + "'...");
        // Simulate processing time/work...
        archivedDocuments.add(processedDoc);
        System.out.println("Document " + processedDoc.getId() + " processed and moved to archive.");
    }

    /**
     * Displays the documents currently in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate without removing elements
            int i = 1;
            for (Document doc : processingQueue) {
                System.out.println(i++ + ". Document " + doc.getId() + ": '" + doc.getTitle() + "'");
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Displays the documents currently in the archive.
     */
    public void viewArchivedDocuments() {
        System.out.println("--- Archived Documents ---");
        if (archivedDocuments.isEmpty()) {
            System.out.println("The archive is empty.");
        } else {
            for (int i = 0; i < archivedDocuments.size(); i++) {
                Document doc = archivedDocuments.get(i);
                System.out.println((i + 1) + ". Document " + doc.getId() + ": '" + doc.getTitle() + "'");
            }
        }
        System.out.println("--------------------------");
    }
}

/**
 * Main class for the Document Processing System application.
 * Handles user interaction and delegates tasks to DocumentProcessor.
 */
public class Main {
    private static Scanner scanner = new Scanner(System.in);
    private static DocumentProcessor processor = new DocumentProcessor();

    /**
     * Entry point of the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        boolean running = true;

        System.out.println("--- Document Processing System ---");

        // Main application loop with class-wide exception handling
        while (running) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                // Read integer input - can throw InputMismatchException
                int choice = scanner.nextInt();
                // Consume the rest of the line after the integer
                scanner.nextLine();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter document title: ");
                        String title = scanner.nextLine();
                        processor.addDocument(title);
                        break;
                    case 2:
                        // processNextDocument can throw NoSuchElementException
                        processor.processNextDocument();
                        break;
                    case 3:
                        processor.viewProcessingQueue();
                        break;
                    case 4:
                        processor.viewArchivedDocuments();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input specifically
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input to prevent infinite loop
                scanner.nextLine();
            } catch (NoSuchElementException e) {
                // Handle attempting to process from an empty queue
                System.err.println("Error: Processing queue is empty. No document to process.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development
                // e.printStackTrace(System.err);
            }
            System.out.println(); // Add a newline for better readability between cycles
        }

        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("Select an action:");
        System.out.println("1. Add New Document to Queue");
        System.out.println("2. Process Next Document from Queue");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Archived Documents");
        System.out.println("5. Exit");
    }
}
