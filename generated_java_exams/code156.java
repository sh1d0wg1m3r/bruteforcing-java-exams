/*
 * Exam Question #156
 * Generated on: 2025-05-11 22:22:53
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Process Scheduler Simulation
 * 
 * **Objective:** Design and implement a simple process scheduler simulation in Java. This system will manage a queue of processes waiting to be executed and a list of processes that have completed or failed.
 * 
 * **Scenario:** You are building a simplified model of an operating system's process scheduler. Processes arrive and are placed in a ready queue. The scheduler picks the next process from the queue and attempts to "execute" it. After execution (simulated), the process is moved to a list of finished processes, categorized by its final status.
 * 
 * **Requirements:**
 * 
 * 1.  **Process Representation:** Create a `Process` class with the following private attributes:
 *     *   `String name`: The name of the process.
 *     *   `int id`: A unique identifier for the process.
 *     *   `int priority`: An integer representing the process's priority.
 *     *   `String status`: The current status of the process (e.g., "Ready", "Running", "Completed", "Failed").
 *     *   Include a constructor, appropriate getters, and a setter for the status.
 *     *   Override the `toString()` method to provide a clear representation of the process (e.g., "Process [ID: X, Name: Y, Priority: Z, Status: W]").
 * 
 * 2.  **Scheduler Logic:** Create a `ProcessScheduler` class to manage the simulation. This class should have:
 *     *   A private `Queue<Process>` to store processes waiting to be executed (the "Ready Queue").
 *     *   A private `List<Process>` to store processes that have finished execution (the "Finished Processes"). Declare this using the `List` interface but instantiate it as an `ArrayList`.
 *     *   A private counter for assigning unique process IDs.
 *     *   A constructor to initialize the queue, list, and ID counter.
 *     *   A public method `addProcess(String name, int priority)`: Creates a new `Process` object with a unique ID, sets its status to "Ready", and adds it to the ready queue.
 *     *   A public method `executeNextProcess()`:
 *         *   Checks if the ready queue is empty. If so, print a message to `System.out`.
 *         *   If not empty, remove the process from the front of the queue.
 *         *   Simulate process execution. This simulation should have a chance of failure (e.g., using `Math.random()`).
 *         *   If simulation succeeds: Set the process status to "Completed" and add it to the finished processes list. Print a success message to `System.out`.
 *         *   If simulation fails (either due to the random chance or a simulated exception): Set the process status to "Failed" and add it to the finished processes list. Print an error message to `System.err`.
 *         *   Include a `try-catch` block within this method to handle potential issues during simulation (e.g., a simulated `RuntimeException` or `InterruptedException` if you add a sleep).
 *     *   Public methods `viewReadyQueue()` and `viewFinishedProcesses()`: Print the contents of the respective data structures to `System.out`.
 * 
 * 3.  **User Interface:** Implement a main loop in the `ProcessScheduler` class (or a separate main class that uses `ProcessScheduler`) that interacts with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Display a menu with the following options:
 *         1.  Add New Process
 *         2.  Execute Next Process
 *         3.  View Ready Queue
 *         4.  View Finished Processes
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   For "Add New Process", prompt the user for the process name and priority. Validate that the priority is a valid integer.
 *     *   Handle invalid menu choices.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.err` for all error messages (e.g., invalid input, process execution failure, unexpected exceptions).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, queue/list contents).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. This should cover potential issues during user input reading (`Scanner` methods) and during the main loop execution. A single large `try-catch` block around the main interaction loop is one way to satisfy this, catching general `Exception`. You may also need specific catches for input validation.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus).
 *     *   Perform input validation (e.g., ensuring numeric input where expected).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output:** The program should run interactively, allowing the user to perform operations and view the state of the scheduler. Error messages should be clearly distinguishable using `System.err`.
 * 
 * **Time Estimate:** 45-60 minutes.
 * 
 * ```
 * Example Interaction (Illustrative):
 * 
 * --- Process Scheduler Menu ---
 * 1. Add New Process
 * 2. Execute Next Process
 * 3. View Ready Queue
 * 4. View Finished Processes
 * 5. Exit
 * Enter your choice: 1
 * Enter process name: TaskA
 * Enter process priority: 5
 * Process 'TaskA' added to the ready queue.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 1
 * Enter process name: TaskB
 * Enter process priority: 10
 * Process 'TaskB' added to the ready queue.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Ready Queue:
 * Process [ID: 1, Name: TaskA, Priority: 5, Status: Ready]
 * Process [ID: 2, Name: TaskB, Priority: 10, Status: Ready]
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Executing process ID: 1 (TaskA)...
 * Process ID: 1 (TaskA) completed successfully.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Executing process ID: 2 (TaskB)...
 * Error executing process ID: 2 (TaskB). Reason: Simulated failure.
 * (This error message should go to System.err)
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * Finished Processes:
 * Process [ID: 1, Name: TaskA, Priority: 5, Status: Completed]
 * Process [ID: 2, Name: TaskB, Priority: 10, Status: Failed]
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * (This error message should go to System.err)
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * **Submission:** Provide the complete Java code for the `Process` and `ProcessScheduler` classes (and a main class if needed) in a single file or clearly separated sections.
 *
 * EXPLANATION:
 * The provided solution implements a basic process scheduler simulation based on the requirements.
 * 
 * **1. Process Class:**
 * - The `Process` class encapsulates the data for each process (`name`, `id`, `priority`, `status`).
 * - It uses private fields and public getters for encapsulation.
 * - A setter `setStatus` is provided to change the process's state.
 * - The `toString()` method is overridden for easy printing of process details.
 * 
 * **2. ProcessScheduler Class:**
 * - This class manages the core logic and data structures.
 * - `readyQueue`: A `java.util.Queue` (implemented using `LinkedList`) is used to store processes waiting for execution. `Queue` is appropriate because processes are processed in the order they are added (FIFO - First-In, First-Out, or similar scheduling like priority queue could be used, but basic FIFO is sufficient for this problem's queue requirement). `poll()` is used to retrieve and remove the head of the queue.
 * - `finishedProcesses`: A `java.util.List` (implemented using `ArrayList`) stores processes after they have been executed. `ArrayList` is suitable for storing a dynamic list of finished items.
 * - `nextProcessId`: A simple counter ensures each process gets a unique ID.
 * - `scanner`: An instance of `java.util.Scanner` is used for all console input. It's a class member so it can be managed and closed properly.
 * - `random`: An instance of `java.util.Random` is used to simulate the random chance of process execution failure.
 * - `addProcess()`: Creates a new `Process` object and adds it to the `readyQueue`.
 * - `executeNextProcess()`:
 *     - Checks if the queue is empty using `isEmpty()`.
 *     - Uses `poll()` to get the next process from the queue.
 *     - Simulates execution success or failure using `random.nextDouble()`.
 *     - A `try-catch(Exception e)` block is placed *inside* this method to handle the simulated `RuntimeException` or any other unexpected error during the "execution" phase for *that specific process*. This demonstrates localized error handling for an operation.
 *     - Based on success or failure, the process's status is updated, and it's added to the `finishedProcesses` list.
 *     - Success messages go to `System.out`, error messages to `System.err`.
 * - `viewReadyQueue()` and `viewFinishedProcesses()`: Iterate and print the contents of the respective collections to `System.out`. `forEach` loop is used for conciseness.
 * 
 * **3. User Interface and Main Loop:**
 * - The `run()` method contains the main application loop (`while(running)`).
 * - `displayMenu()` prints the options to `System.out`.
 * - User input is read using the `scanner`.
 * - **Input Validation:** Before reading an integer (`scanner.nextInt()`), `scanner.hasNextInt()` is used to check if the next token is actually an integer. If not, an error is printed to `System.err`, the invalid token is consumed, and the loop continues, prompting the user again. Similar validation is done for process priority.
 * - **Switch Statement:** A `switch` statement is used to direct the program flow based on the valid integer input received from the user, calling the appropriate methods (`addProcess`, `executeNextProcess`, etc.).
 * - Invalid integer choices fall into the `default` case of the `switch`, printing an error to `System.err`.
 * 
 * **4. Exception Handling:**
 * - **Class-wide Exception Handling:** A large `try-catch(Exception mainException)` block surrounds the entire `while` loop in the `run()` method. This fulfills the requirement for class-wide handling by catching any `Exception` that might occur within the main execution flow of the scheduler's interactive loop, providing a final fallback for unexpected errors and allowing for graceful (though perhaps abrupt for critical errors) termination or error reporting.
 * - **Specific Input Handling:** A `try-catch(InputMismatchException e)` is included (though partially covered by `hasNextInt` checks) to specifically handle cases where `nextInt()` or `nextDouble()` might fail if validation isn't perfect or other input stream issues occur.
 * - **Operation-Specific Handling:** The `try-catch` block inside `executeNextProcess()` handles errors related to that specific operation (simulated execution failure).
 * 
 * **5. Best Practices:**
 * - Encapsulation is used in the `Process` class.
 * - Variable and method names are descriptive (e.g., `readyQueue`, `executeNextProcess`, `nextProcessId`).
 * - Comments explain the purpose of classes, methods, and key code sections.
 * - Input validation is implemented for menu choices and process priority.
 * - Error messages are directed to `System.err`.
 * - `System.out` is used for standard output.
 * - The `Scanner` is closed in a `finally` block within `run()` to ensure resource cleanup when the loop terminates (either by user exit or critical error).
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a cohesive, practical scenario while adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

/**
 * Represents a single process in the scheduler simulation.
 */
class Process {
    private String name;
    private int id;
    private int priority;
    private String status; // e.g., "Ready", "Running", "Completed", "Failed"

    /**
     * Constructs a new Process.
     *
     * @param name     The name of the process.
     * @param id       The unique ID of the process.
     * @param priority The priority of the process.
     */
    public Process(String name, int id, int priority) {
        this.name = name;
        this.id = id;
        this.priority = priority;
        this.status = "Ready"; // Initial status
    }

    // Getters
    public String getName() {
        return name;
    }

    public int getId() {
        return id;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Process.
     *
     * @return A formatted string describing the process.
     */
    @Override
    public String toString() {
        return String.format("Process [ID: %d, Name: %s, Priority: %d, Status: %s]",
                             id, name, priority, status);
    }
}

/**
 * Simulates a basic process scheduler.
 * Manages a ready queue and a list of finished processes.
 */
public class ProcessScheduler { // Renamed to ProcessScheduler for clarity

    private Queue<Process> readyQueue;
    private List<Process> finishedProcesses; // Declared as List, instantiated as ArrayList
    private int nextProcessId;
    private Scanner scanner;
    private Random random; // For simulating execution failure

    /**
     * Constructs a ProcessScheduler.
     * Initializes the ready queue, finished processes list, and ID counter.
     */
    public ProcessScheduler() {
        this.readyQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.finishedProcesses = new ArrayList<>();
        this.nextProcessId = 1;
        this.scanner = new Scanner(System.in);
        this.random = new Random();
    }

    /**
     * Adds a new process to the ready queue.
     *
     * @param name     The name of the process.
     * @param priority The priority of the process.
     */
    public void addProcess(String name, int priority) {
        Process newProcess = new Process(name, nextProcessId++, priority);
        readyQueue.add(newProcess);
        System.out.println("Process '" + name + "' added to the ready queue with ID " + newProcess.getId() + ".");
    }

    /**
     * Simulates the execution of the next process in the ready queue.
     * Moves the process to the finished list upon completion or failure.
     */
    public void executeNextProcess() {
        if (readyQueue.isEmpty()) {
            System.out.println("Ready queue is empty. No processes to execute.");
            return;
        }

        Process currentProcess = readyQueue.poll(); // Get and remove the head of the queue
        System.out.println("Executing process ID: " + currentProcess.getId() + " (" + currentProcess.getName() + ")...");

        try {
            // Simulate execution time (optional, but adds realism)
            // Thread.sleep(500);

            // Simulate a chance of failure (e.g., 20% chance)
            if (random.nextDouble() < 0.2) {
                throw new RuntimeException("Simulated execution failure.");
            }

            // If simulation reaches here, it's successful
            currentProcess.setStatus("Completed");
            finishedProcesses.add(currentProcess);
            System.out.println("Process ID: " + currentProcess.getId() + " (" + currentProcess.getName() + ") completed successfully.");

        } catch (Exception e) { // Catch simulated exceptions or other errors
            currentProcess.setStatus("Failed");
            finishedProcesses.add(currentProcess);
            System.err.println("Error executing process ID: " + currentProcess.getId() + " (" + currentProcess.getName() + "). Reason: " + e.getMessage());
        }
    }

    /**
     * Displays the contents of the ready queue.
     */
    public void viewReadyQueue() {
        System.out.println("\n--- Ready Queue ---");
        if (readyQueue.isEmpty()) {
            System.out.println("The ready queue is empty.");
        } else {
            // Iterate without removing elements
            readyQueue.forEach(System.out::println);
        }
        System.out.println("-------------------");
    }

    /**
     * Displays the contents of the finished processes list.
     */
    public void viewFinishedProcesses() {
        System.out.println("\n--- Finished Processes ---");
        if (finishedProcesses.isEmpty()) {
            System.out.println("No processes have finished yet.");
        } else {
            finishedProcesses.forEach(System.out::println);
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Process Scheduler Menu ---");
        System.out.println("1. Add New Process");
        System.out.println("2. Execute Next Process");
        System.out.println("3. View Ready Queue");
        System.out.println("4. View Finished Processes");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main process scheduler simulation loop.
     * Handles user input and menu navigation.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                try {
                    // Validate if the next input is an integer
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                    } else {
                        // Consume the invalid input token
                        String invalidInput = scanner.next();
                        System.err.println("Error: Invalid input '" + invalidInput + "'. Please enter a number.");
                        continue; // Skip to the next iteration
                    }
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use switch for menu flow control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter process name: ");
                            String name = scanner.nextLine();
                            int priority = -1;
                            System.out.print("Enter process priority: ");
                            // Validate priority input
                            if (scanner.hasNextInt()) {
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                if (priority >= 0) { // Simple positive priority check
                                    addProcess(name, priority);
                                } else {
                                    System.err.println("Error: Priority must be a non-negative integer.");
                                }
                            } else {
                                String invalidPriorityInput = scanner.next();
                                System.err.println("Error: Invalid priority input '" + invalidPriorityInput + "'. Please enter an integer.");
                                scanner.nextLine(); // Consume rest of line if any
                            }
                            break;
                        case 2:
                            executeNextProcess();
                            break;
                        case 3:
                            viewReadyQueue();
                            break;
                        case 4:
                            viewFinishedProcesses();
                            break;
                        case 5:
                            System.out.println("Exiting scheduler.");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // This catch block is technically redundant if hasNextInt check is used correctly before nextInt
                    // but kept here as a fallback or for other potential scanner issues.
                    System.err.println("Error reading input. Please try again.");
                    scanner.nextLine(); // Consume the invalid input
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } catch (Exception mainException) {
            // This outer catch handles exceptions that might escape the inner try-catch,
            // potentially indicating a more critical issue with the main loop or scheduler state.
            System.err.println("\n--- CRITICAL SYSTEM ERROR ---");
            System.err.println("The scheduler encountered a critical error and must shut down.");
            System.err.println("Error details: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
            System.err.println("-----------------------------");
        } finally {
            // Ensure scanner is closed when the application exits the loop
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the Process Scheduler application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProcessScheduler scheduler = new ProcessScheduler();
        scheduler.run();
    }
}
