/*
 * Exam Question #69
 * Generated on: 2025-05-11 22:08:34
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified task management system for a small project team. The system should allow users to add tasks, process the next task in a queue, cancel tasks by referencing their position in a full list, and view lists of tasks. This exercise requires demonstrating proficiency in using core Java collections and control flow structures while adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. It should have:
 *     *   A private `String` field for the task description.
 *     *   A private `boolean` field to indicate if the task is completed.
 *     *   A constructor that takes the description and initializes the task as not completed.
 *     *   Public getter methods for description and completion status.
 *     *   A public setter method `markCompleted()` to set the completion status to true.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (including its status).
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` to manage the collection of tasks. It must use the following:
 *     *   A private `java.util.Queue<Task>` to store tasks that are currently pending and waiting to be processed (processed in FIFO order).
 *     *   A private `java.util.List<Task>` (specifically using `java.util.ArrayList` as the implementation) to maintain a complete history and current state of *all* tasks ever added to the system (both pending and completed).
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object, adds it to both the pending `Queue` and the all-tasks `List`.
 *         *   `completeNextTask()`: Retrieves and removes the task at the head of the pending `Queue`. If successful, it finds the *same* task object in the all-tasks `List` and marks it as completed. This method should return `true` if a task was completed, `false` otherwise (e.g., if the queue was empty).
 *         *   `cancelTask(int taskIndex)`: This method takes an integer index as input, which corresponds to the index of the task in the *all-tasks List*. It should:
 *             *   Validate if the index is within the bounds of the all-tasks list. Use `System.err` for invalid index errors.
 *             *   If the index is valid, retrieve the `Task` object from the all-tasks list.
 *             *   If the task retrieved is currently pending (check its completion status), remove it from the pending `Queue`.
 *             *   Remove the task from the all-tasks `List` using its index.
 *             *   Return `true` if a task was successfully found and cancelled, `false` otherwise (e.g., invalid index).
 *         *   `getAllTasks()`: Returns the `List<Task>` containing all tasks.
 *         *   `getPendingTasks()`: Returns a new `List<Task>` containing only the tasks currently present in the pending `Queue` (do not modify the queue itself when returning).
 * 
 * 3.  **User Interface:** Create a main application class named `TaskManagementApp` with a `main` method.
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Present a menu of options to the user: `add`, `complete`, `cancel`, `view_all`, `view_pending`, `exit`.
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Call the appropriate methods of the `TaskManager` based on user input.
 *     *   Display results and information using `System.out`.
 *     *   Display error messages for invalid commands, invalid input (e.g., non-integer index for cancel), or operational errors (e.g., trying to complete a task when none are pending) using `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during the program execution (e.g., wrap the main command processing loop).
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc or inline comments) explaining complex parts.
 *     *   Perform input validation where necessary (e.g., for the cancel index).
 *     *   Implement proper error handling using `System.err` and `try-catch`.
 *     *   Ensure a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, prompting the user for commands. It should correctly perform the requested task management operations, display task lists with their status and indices (for the all-tasks list), and report errors appropriately using `System.err`.
 * 
 * ```
 * Task Management Menu:
 * add          - Add a new task
 * complete     - Complete the next pending task
 * cancel       - Cancel a task by its index in the all-tasks list
 * view_all     - View all tasks
 * view_pending - View only pending tasks
 * exit         - Exit the application
 * Enter command: add
 * Enter task description: Write report
 * Task added.
 * Enter command: add
 * Enter task description: Schedule meeting
 * Task added.
 * Enter command: view_all
 * All Tasks:
 * 0: [PENDING] Write report
 * 1: [PENDING] Schedule meeting
 * Enter command: complete
 * Completed task: Write report
 * Enter command: view_all
 * All Tasks:
 * 0: [COMPLETED] Write report
 * 1: [PENDING] Schedule meeting
 * Enter command: view_pending
 * Pending Tasks:
 * [PENDING] Schedule meeting
 * Enter command: cancel
 * Enter index of task to cancel: 1
 * Task at index 1 cancelled.
 * Enter command: view_all
 * All Tasks:
 * 0: [COMPLETED] Write report
 * Enter command: complete
 * Completed task: (None - Queue was empty)
 * Enter command: cancel
 * Enter index of task to cancel: 5
 * Error: Invalid task index.
 * Enter command: exit
 * Exiting Task Management System.
 * ```
 * 
 * *(Note: The exact output format for lists can vary slightly, but should clearly show tasks and their status. The `cancelTask` index refers to the index in the `view_all` list.)*
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation and usage of `Queue`, `ArrayList` (via `List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Correct logic for task operations (add, complete, cancel) and their interaction with both collections.
 * *   Robustness of input validation and error handling.
 * *   Adherence to object-oriented principles (encapsulation) and coding best practices.
 * *   Clarity and readability of the code.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The solution implements a simple task management system as required, demonstrating the use of various core Java features and collections.
 * 
 * 1.  **`Task` Class:**
 *     *   This is a simple Plain Old Java Object (POJO) representing a task with a `description` and a `isCompleted` status.
 *     *   It includes a constructor, getters, a `markCompleted` setter, and overrides `toString()` for easy printing.
 *     *   Crucially, it overrides `equals()` and `hashCode()`. This is necessary because the `cancelTask` method needs to remove a specific `Task` *object* from the `pendingTasks` `Queue` using `pendingTasks.remove(taskToCancel)`. The default `equals` (object identity `==`) would work if the *exact same object reference* was always used, but overriding allows for logical equality based on task description if needed (though in this specific solution, the same object reference *is* maintained, so default `equals` would technically work, but overriding based on content is generally better practice if task identity isn't strictly tied to the object instance). The provided solution uses `==` in `completeNextTask` but relies on `equals` for `Queue.remove()`, so overriding `equals` and `hashCode` based on description is included for robustness.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This class encapsulates the core logic and data structures.
 *     *   It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` for managing tasks waiting for processing. `offer()` is used for adding (non-blocking add), and `poll()` for retrieving and removing the head (returns null if empty).
 *     *   It uses a `List<Task>` (`allTasks`) implemented by `ArrayList` to keep a record of all tasks added. This list serves as the source for viewing all tasks and for referencing tasks by index for the `cancel` operation.
 *     *   `addTask`: Adds the *same* `Task` object instance to both collections. This is key for `completeNextTask` and `cancelTask` to find the correct task object in the `allTasks` list or remove it from the `pendingTasks` queue.
 *     *   `completeNextTask`: Demonstrates `poll()` from the `Queue`. It then iterates through the `allTasks` list to find the corresponding task object (using object identity `==` since it's the same instance) and updates its status.
 *     *   `cancelTask`: Demonstrates interaction between the `List` and `Queue`. It validates the index for the `allTasks` list. It retrieves the task object from the `List` using `get()`. If the task is pending, it removes it from the `pendingTasks` `Queue` using `remove(Object)`. Finally, it removes the task from the `allTasks` `List` using `remove(index)`. Error messages for invalid indices are printed to `System.err`.
 *     *   `getAllTasks` and `getPendingTasks`: Provide access to the task lists. `getPendingTasks` creates a *new* `ArrayList` from the queue's contents to avoid exposing the internal queue reference directly and allowing external modification of the queue.
 * 
 * 3.  **`TaskManagementApp` Class:**
 *     *   Contains the `main` method, which is the entry point and handles the user interface.
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to `exit`.
 *     *   A `switch` statement dispatches control based on the user's command string. This is a clear way to handle multiple distinct commands.
 *     *   `System.out` is used for the menu, success messages, and task listings.
 *     *   `System.err` is used for all error conditions, such as unknown commands, invalid numeric input for cancellation, invalid task indices, or errors reported by the `TaskManager` (like empty queue on completion attempt, though the `TaskManager` handles that output itself).
 *     *   A `try-catch(Exception e)` block wraps the main command processing loop. This serves as a class-wide exception handler, catching any unhandled exceptions that might occur during command execution and printing an error message to `System.err` before the program potentially terminates or continues, depending on the exception. Specific error handling (like `NumberFormatException` for cancel index) is also included for better user feedback.
 *     *   Resource management is shown by closing the `Scanner` in a `finally` block.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Collections:** Practical usage of `Queue` (FIFO processing) and `List`/`ArrayList` (ordered storage, access by index).
 * *   **Object Interaction:** Managing the same `Task` objects across different collections (`pendingTasks` and `allTasks`) and ensuring state consistency (marking completed in `allTasks` when polled from `pendingTasks`).
 * *   **Encapsulation:** The `TaskManager` class hides the internal collection implementations and provides a clean public API for operations. The `Task` class encapsulates task data.
 * *   **Control Flow:** Effective use of `switch` for command handling and `while` for the application loop.
 * *   **Input/Output:** Using `Scanner` for input, `System.out` for normal output, and `System.err` for errors.
 * *   **Error Handling:** Implementing input validation (index bounds, number format) and using `try-catch` for both specific anticipated errors and general unexpected exceptions.
 * *   **Best Practices:** Meaningful names, comments, basic input validation, and clear structure contribute to code readability and maintainability. Overriding `equals` and `hashCode` demonstrates understanding of object identity and equality in collections.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, application, demonstrating a solid understanding of fundamental and intermediate Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // Needed to safely remove from Queue while iterating if required, but not strictly for this problem's cancel logic.

// Requirement 1: Task class
class Task {
    private String description;
    private boolean isCompleted;

    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    public void markCompleted() {
        this.isCompleted = true;
    }

    @Override
    public String toString() {
        return "[" + (isCompleted ? "COMPLETED" : "PENDING") + "] " + description;
    }

    // Needed for Queue.remove(Object) in cancel logic to work correctly
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return description.equals(task.description); // Simplified equality check by description
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }
}

// Requirement 2: TaskManager class
class TaskManager {
    // Using LinkedList as a common Queue implementation
    private Queue<Task> pendingTasks; // Requirement: Queue
    private List<Task> allTasks;     // Requirement: List (using ArrayList)

    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // Initialize Queue
        this.allTasks = new ArrayList<>();     // Initialize ArrayList via List interface
    }

    /**
     * Adds a new task to the system.
     * Adds to both the pending queue and the all-tasks list.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            pendingTasks.offer(newTask); // Add to the end of the queue
            allTasks.add(newTask);       // Add to the end of the list
            System.out.println("Task added.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage()); // Requirement: System.err for errors
        }
    }

    /**
     * Completes the next task in the pending queue.
     * Removes from queue, marks as completed in the all-tasks list.
     * @return true if a task was completed, false if the queue was empty.
     */
    public boolean completeNextTask() {
        Task nextTask = pendingTasks.poll(); // Retrieve and remove head of the queue
        if (nextTask != null) {
            // Find the same task object in the allTasks list and mark it completed
            // Since we added the same object reference to both, we can find it.
            for (Task task : allTasks) {
                if (task == nextTask) { // Check for object identity
                    task.markCompleted();
                    break; // Found and updated
                }
            }
            System.out.println("Completed task: " + nextTask.getDescription());
            return true;
        } else {
            System.out.println("Completed task: (None - Queue was empty)");
            return false;
        }
    }

    /**
     * Cancels a task by its index in the all-tasks list.
     * Removes from both the all-tasks list and the pending queue (if pending).
     * @param taskIndex The index of the task in the all-tasks list.
     * @return true if a task was successfully cancelled, false otherwise.
     */
    public boolean cancelTask(int taskIndex) {
        // Requirement: Input validation for index
        if (taskIndex < 0 || taskIndex >= allTasks.size()) {
            System.err.println("Error: Invalid task index."); // Requirement: System.err for errors
            return false;
        }

        try {
            Task taskToCancel = allTasks.get(taskIndex);

            // If the task is pending, remove it from the pending queue
            if (!taskToCancel.isCompleted()) {
                // Queue.remove(Object) removes the first occurrence of the specified element.
                // This works because we added the same Task object to both collections.
                pendingTasks.remove(taskToCancel);
            }

            // Remove from the all-tasks list by index
            allTasks.remove(taskIndex);

            System.out.println("Task at index " + taskIndex + " cancelled.");
            return true;
        } catch (IndexOutOfBoundsException e) {
             // This catch is technically redundant due to the check above,
             // but demonstrates handling potential List access issues.
            System.err.println("Error cancelling task: Invalid index."); // Requirement: System.err for errors
            return false;
        } catch (Exception e) {
            // Catch any other unexpected errors during cancellation
            System.err.println("An unexpected error occurred during cancellation: " + e.getMessage()); // Requirement: System.err for errors
            return false;
        }
    }

    /**
     * Returns the list of all tasks.
     * @return A List containing all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks; // Returning the internal list reference
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Creates a new list to avoid modifying the queue.
     * @return A List containing only pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new list from the queue elements for viewing
        return new ArrayList<>(pendingTasks);
    }
}

// Requirement 3: Main application class
public class TaskManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Requirement: Scanner
        TaskManager taskManager = new TaskManager();

        System.out.println("Welcome to the Task Management System!");

        boolean running = true;
        // Requirement: Class-wide exception handling using try-catch
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Requirement: Switch statement for flow control
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description); // Handles its own error reporting
                        break;

                    case "complete":
                        taskManager.completeNextTask(); // Handles its own output
                        break;

                    case "cancel":
                        System.out.print("Enter index of task to cancel: ");
                        try {
                            int indexToCancel = Integer.parseInt(scanner.nextLine());
                            taskManager.cancelTask(indexToCancel); // Handles its own output and errors
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid input. Please enter a number for the index."); // Requirement: System.err
                        }
                        break;

                    case "view_all":
                        List<Task> all = taskManager.getAllTasks();
                        System.out.println("All Tasks:");
                        if (all.isEmpty()) {
                            System.out.println("(No tasks added yet)");
                        } else {
                            // Requirement: System.out for normal output
                            for (int i = 0; i < all.size(); i++) {
                                System.out.println(i + ": " + all.get(i));
                            }
                        }
                        break;

                    case "view_pending":
                        List<Task> pending = taskManager.getPendingTasks();
                        System.out.println("Pending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("(No pending tasks)");
                        } else {
                            // Requirement: System.out for normal output
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please try again."); // Requirement: System.err
                        break;
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Requirement: Class-wide exception handling catch block
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            e.printStackTrace(); // Optional: Print stack trace for debugging in exam
        } finally {
            scanner.close(); // Close the scanner resource
        }
    }

    private static void printMenu() {
        System.out.println("Task Management Menu:");
        System.out.println("add          - Add a new task");
        System.out.println("complete     - Complete the next pending task");
        System.out.println("cancel       - Cancel a task by its index in the all-tasks list");
        System.out.println("view_all     - View all tasks");
        System.out.println("view_pending - View only pending tasks");
        System.out.println("exit         - Exit the application");
    }
}
