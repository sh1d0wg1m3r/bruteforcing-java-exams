/*
 * Exam Question #825
 * Generated on: 2025-05-12 16:46:46
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Topic:** Data Structures, Control Flow, and Exception Handling
 * **Task:** Hospital Appointment Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line application for managing patient appointments in a small clinic. The system should allow adding new patients, scheduling appointments for existing patients, viewing the waiting list for appointments, and processing the next appointment in the queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of all registered patients.
 *     *   Maintain a queue of scheduled appointments waiting to be seen by a doctor.
 * 2.  **Functionality:**
 *     *   **Add Patient:** Allow users to add a new patient by providing a name. The system should automatically assign a unique patient ID.
 *     *   **Schedule Appointment:** Allow users to schedule an appointment for an *existing* patient. The user must provide the patient's ID, the doctor's name, and the appointment time. If the patient ID is not found, display an error.
 *     *   **View Waiting List:** Display all appointments currently in the waiting queue without removing them.
 *     *   **Process Next Appointment:** Remove the next appointment from the waiting queue, simulate processing it (e.g., print a message), and display the processed appointment details. If the queue is empty, display an appropriate message.
 *     *   **Exit:** Terminate the application.
 * 3.  **User Interface:**
 *     *   Present a menu of options to the user.
 *     *   Use `Scanner` to read user input for menu selection and data entry.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use `System.out` for displaying the menu, successful operations, and data output.
 *     *   Use `System.err` to display error messages (e.g., invalid input, patient not found, empty queue operation).
 * 4.  **Error Handling:**
 *     *   Implement robust input validation for numerical inputs (e.g., patient ID, menu choice).
 *     *   Handle cases where a patient ID is not found when scheduling an appointment.
 *     *   Handle attempts to process an appointment when the waiting queue is empty.
 *     *   Include class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during the main application loop.
 * 5.  **Code Structure and Best Practices:**
 *     *   Create separate classes for `Patient`, `Appointment`, and `AppointmentManager`.
 *     *   Use proper encapsulation (private fields with public getters/setters where necessary, or direct access via methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Add comments to explain complex logic or important sections.
 *     *   Declare collections using appropriate interfaces (e.g., `List` for `ArrayList`).
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting a menu. User interactions and system responses should be clear, using `System.out` for normal output and `System.err` for errors.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice Smith
 * Patient added with ID: 1
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Bob Johnson
 * Patient added with ID: 2
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 2
 * Enter patient ID: 1
 * Enter doctor name: Dr. Adams
 * Enter appointment time: 10:00 AM
 * Appointment scheduled for patient ID 1 with Dr. Adams at 10:00 AM.
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 2
 * Enter patient ID: 99
 * Enter doctor name: Dr. Baker
 * Enter appointment time: 11:00 AM
 * Error: Patient with ID 99 not found.
 * (Output to System.err)
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting List ---
 * Appointment [Patient ID: 1, Doctor: Dr. Adams, Time: 10:00 AM, Status: Scheduled]
 * --------------------
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 4
 * Processing appointment: Appointment [Patient ID: 1, Doctor: Dr. Adams, Time: 10:00 AM, Status: Scheduled]
 * Appointment for patient 1 processed.
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 4
 * Waiting list is empty. No appointments to process.
 * (Output to System.err)
 * 
 * --- Appointment Management Menu ---
 * 1. Add Patient
 * 2. Schedule Appointment
 * 3. View Waiting List
 * 4. Process Next Appointment
 * 5. Exit
 * Enter your choice: 5
 * Exiting Appointment Management System.
 * ```
 * 
 * **Grading Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for exception handling.
 * *   Adherence to best practices (encapsulation, naming, comments, validation).
 * *   Clean and readable code structure.
 *
 * EXPLANATION:
 * This solution implements the Hospital Appointment Management System using the required Java components and follows best practices.
 * 
 * 1.  **Class Structure:** The problem is broken down into three classes: `Patient`, `Appointment`, and `AppointmentManager`. This promotes modularity and encapsulation.
 *     *   `Patient`: Holds patient data (`id`, `name`) and provides getters.
 *     *   `Appointment`: Holds appointment data (`patientId`, `doctor`, `time`, `status`) and provides getters/setters.
 *     *   `AppointmentManager`: Contains the core logic and data structures (`patients` list, `waitingList` queue). It handles user interaction and orchestrates operations.
 * 
 * 2.  **Data Structures:**
 *     *   `List<Patient> patients = new ArrayList<>();`: An `ArrayList` is used to store `Patient` objects. It's declared using the `List` interface, demonstrating good practice by programming to the interface. `ArrayList` is suitable here as we need to store a collection of patients and potentially search through them (though `findPatientById` is a simple linear search).
 *     *   `Queue<Appointment> waitingList = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface. `Queue` is the ideal data structure for the waiting list because appointments are processed in a First-In, First-Out (FIFO) manner. `offer()` is used to add to the end, and `poll()` is used to remove from the front.
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     *   A `Scanner` object reads user input from `System.in`.
 *     *   The `run()` method contains the main application loop.
 *     *   `displayMenu()` shows the available options.
 *     *   A `switch` statement within the loop directs the program flow based on the user's integer choice, calling the appropriate private methods (`addPatient`, `scheduleAppointment`, etc.).
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful operation messages, and the contents of the waiting list.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid input, patient not found, or attempting to process from an empty queue. This distinguishes error output from normal program output.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A main `try-catch` block wraps the entire `while` loop in the `run()` method. This serves as the "class-wide" exception handling mechanism, ensuring that if any unhandled exception occurs within the main application flow, the program doesn't crash abruptly but prints an error message (though the inner `try-catch` handles most expected issues).
 *     *   An inner `try-catch` block specifically handles `NumberFormatException` when parsing the user's menu choice or patient ID input. This prevents the program from crashing if the user enters non-integer text.
 *     *   Specific checks are performed before operations that might fail (e.g., checking if `findPatientById` returns `null`, checking if `waitingList.poll()` returns `null`) to provide user-friendly error messages via `System.err` rather than relying solely on exceptions for these expected scenarios.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Class fields are `private`. Access and modification are done through public methods (`addPatient`, `scheduleAppointment`, getters).
 *     *   **Meaningful Names:** Class names (`Patient`, `Appointment`, `AppointmentManager`), variable names (`patients`, `waitingList`, `nextPatientId`), and method names (`addPatient`, `scheduleAppointment`, `viewWaitingList`, `processNextAppointment`, `findPatientById`, `run`, `displayMenu`) are descriptive and reflect their purpose.
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods. Inline comments explain specific logic points.
 *     *   **Input Validation:** The code checks for empty patient names, doctor names, and times. It specifically handles `NumberFormatException` for integer inputs. It also validates if a patient ID exists before scheduling an appointment.
 *     *   **Clean Code:** The code is structured logically with methods performing specific tasks. The `run()` method orchestrates the overall flow. The use of `nextLine()` after parsing integers helps avoid common `Scanner` pitfalls. The `finally` block ensures the `Scanner` resource is closed.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical scenario, including the appropriate use of collections (`List`, `Queue`), control flow (`switch`, loops), user interaction (`Scanner`), and robust error handling (`try-catch`, `System.err`).
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // For non-integer input

// --- Patient Class ---
/**
 * Represents a patient in the system.
 */
class Patient {
    private int id;
    private String name;

    /**
     * Constructs a new Patient.
     * @param id The unique ID of the patient.
     * @param name The name of the patient.
     */
    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [ID: " + id + ", Name: " + name + "]";
    }
}

// --- Appointment Class ---
/**
 * Represents an appointment.
 */
class Appointment {
    private int patientId;
    private String doctor;
    private String time;
    private String status; // e.g., Scheduled, Completed, Cancelled

    /**
     * Constructs a new Appointment.
     * @param patientId The ID of the patient the appointment is for.
     * @param doctor The name of the doctor.
     * @param time The time of the appointment.
     */
    public Appointment(int patientId, String doctor, String time) {
        this.patientId = patientId;
        this.doctor = doctor;
        this.time = time;
        this.status = "Scheduled"; // Default status
    }

    // --- Getters ---
    public int getPatientId() {
        return patientId;
    }

    public String getDoctor() {
        return doctor;
    }

    public String getTime() {
        return time;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter (if needed, e.g., to update status) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Appointment [Patient ID: " + patientId + ", Doctor: " + doctor + ", Time: " + time + ", Status: " + status + "]";
    }
}

// --- AppointmentManager Class ---
/**
 * Manages patients and appointments.
 */
public class AppointmentManager {
    // Using List interface for flexibility, implemented by ArrayList
    private List<Patient> patients;
    // Using Queue interface, implemented by LinkedList for FIFO
    private Queue<Appointment> waitingList;
    private Scanner scanner;
    private int nextPatientId; // Counter for unique patient IDs

    /**
     * Constructs an AppointmentManager.
     */
    public AppointmentManager() {
        patients = new ArrayList<>(); // Initialize ArrayList
        waitingList = new LinkedList<>(); // Initialize LinkedList as Queue
        scanner = new Scanner(System.in);
        nextPatientId = 1; // Start patient IDs from 1
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Appointment Management Menu ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. View Waiting List");
        System.out.println("4. Process Next Appointment");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the system.
     */
    private void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        Patient newPatient = new Patient(nextPatientId++, name.trim());
        patients.add(newPatient);
        System.out.println("Patient added with ID: " + newPatient.getId());
    }

    /**
     * Schedules an appointment for an existing patient.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient ID: ");
        int patientId;
        try {
            patientId = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid patient ID format. Please enter a number.");
            return;
        }

        Patient patient = findPatientById(patientId);
        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return;
        }

        System.out.print("Enter doctor name: ");
        String doctor = scanner.nextLine();

        System.out.print("Enter appointment time: ");
        String time = scanner.nextLine();

        if (doctor == null || doctor.trim().isEmpty() || time == null || time.trim().isEmpty()) {
             System.err.println("Error: Doctor name and appointment time cannot be empty.");
             return;
        }


        Appointment newAppointment = new Appointment(patientId, doctor.trim(), time.trim());
        waitingList.offer(newAppointment); // Use offer() for queue insertion
        System.out.println("Appointment scheduled for patient ID " + patientId + " with " + doctor.trim() + " at " + time.trim() + ".");
    }

    /**
     * Finds a patient by their ID.
     * @param id The ID of the patient to find.
     * @return The Patient object if found, null otherwise.
     */
    private Patient findPatientById(int id) {
        for (Patient patient : patients) {
            if (patient.getId() == id) {
                return patient;
            }
        }
        return null; // Patient not found
    }

    /**
     * Views all appointments currently in the waiting list queue.
     */
    private void viewWaitingList() {
        System.out.println("--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate without removing elements
            for (Appointment appointment : waitingList) {
                System.out.println(appointment);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Processes the next appointment in the waiting list queue.
     */
    private void processNextAppointment() {
        Appointment nextAppointment = waitingList.poll(); // Use poll() to retrieve and remove
        if (nextAppointment == null) {
            System.err.println("Waiting list is empty. No appointments to process.");
        } else {
            // Simulate processing
            System.out.println("Processing appointment: " + nextAppointment);
            // In a real system, you might update the appointment status or move it
            // nextAppointment.setStatus("Completed"); // Example
            System.out.println("Appointment for patient " + nextAppointment.getPatientId() + " processed.");
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1; // Initialize with a value that won't exit immediately

        // Class-wide try-catch for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    // Read the entire line and parse as integer to avoid issues with nextLine() after nextInt()
                    choice = Integer.parseInt(scanner.nextLine());

                    // Use switch statement for control flow based on user choice
                    switch (choice) {
                        case 1:
                            addPatient();
                            break;
                        case 2:
                            scheduleAppointment();
                            break;
                        case 3:
                            viewWaitingList();
                            break;
                        case 4:
                            processNextAppointment();
                            break;
                        case 5:
                            System.out.println("Exiting Appointment Management System.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Error: Invalid input. Please enter a number corresponding to the menu option.");
                } catch (Exception e) {
                     // Catch any other unexpected exceptions during a menu action
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } catch (Exception e) {
            // This catch block handles exceptions that might occur outside the inner loop's try-catch,
            // though less likely with this structure. It serves as the 'class-wide' handler.
            System.err.println("A fatal error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AppointmentManager manager = new AppointmentManager();
        manager.run();
    }
}
