/*
 * Exam Question #194
 * Generated on: 2025-05-11 22:29:50
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Customer Service Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Customer Service Ticket Management System. The system should allow users to add new support tickets, assign the next pending ticket to an available agent, view the list of pending tickets, and view the status of all agents.
 * 
 * The system must simulate a real-world scenario where tickets arrive and are processed in a First-In, First-Out (FIFO) manner by agents who become busy once assigned a ticket.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending support tickets. Tickets should be processed in the order they are added.
 *     *   Use a `java.util.List` (specifically an `ArrayList`) to maintain a list of support agents.
 * 
 * 2.  **Classes:**
 *     *   Create a `Ticket` class with private fields for `id` (int), `description` (String), `status` (String, e.g., "Open", "Assigned"), and `assignedAgentId` (Integer, can be null). Include a constructor and public getter methods. Add a method `assignToAgent(int agentId)` to update status and agent ID. Override `toString()` for easy display.
 *     *   Create an `Agent` class with private fields for `id` (int), `name` (String), and `isAvailable` (boolean). Include a constructor, public getter methods, and a setter for `isAvailable`. Override `toString()` for easy display.
 *     *   Create a main class (e.g., `TicketSystem`) that contains the `main` method and manages the `Queue` of tickets and the `List` of agents.
 * 
 * 3.  **System Functionality (within the main class):**
 *     *   Initialize the system with a predefined list of at least 3 agents.
 *     *   Implement a command-line interface using `java.util.Scanner` for user interaction.
 *     *   Present a menu to the user with the following options:
 *         1.  Add New Ticket
 *         2.  Assign Next Ticket to Agent
 *         3.  View Pending Tickets
 *         4.  View Agents Status
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   **Option 1 (Add New Ticket):** Prompt the user for a ticket description, create a new `Ticket` object with a unique ID, and add it to the ticket `Queue`. Print a success message using `System.out`.
 *     *   **Option 2 (Assign Next Ticket):**
 *         *   Check if the ticket `Queue` is empty. If so, print an error message to `System.err`.
 *         *   If the queue is not empty, prompt the user for the ID of the agent they want to assign the ticket to.
 *         *   Validate that the input for agent ID is an integer. Use `try-catch` to handle `InputMismatchException`. If input is invalid, print an error to `System.err` and discard the invalid input.
 *         *   Find the agent in the `List` by their ID.
 *         *   If the agent is not found or is not currently available (`isAvailable` is false), print an error message to `System.err`.
 *         *   If an available agent is found, dequeue the next ticket from the `Queue`, update the ticket's status and assigned agent ID, set the agent's `isAvailable` status to false, and print a success message using `System.out`.
 *     *   **Option 3 (View Pending Tickets):** Iterate through the ticket `Queue` (without removing elements) and print the details of each pending ticket using `System.out`. Handle the case where the queue is empty.
 *     *   **Option 4 (View Agents Status):** Iterate through the agent `List` and print the details and availability status of each agent using `System.out`. Handle the case where the list is empty (though it starts with agents).
 *     *   **Option 5 (Exit):** Terminate the program.
 * 
 * 4.  **Error Handling & Best Practices:**
 *     *   Implement robust error handling using `try-catch` blocks, specifically for handling invalid user input (e.g., non-integer where an integer is expected).
 *     *   Use `System.err` for all error messages and `System.out` for all normal output (menu, prompts, success messages, list displays).
 *     *   Ensure proper encapsulation in `Ticket` and `Agent` classes (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for methods).
 *     *   Perform necessary input validation before processing user requests (e.g., checking if queue is empty, if agent exists and is available).
 *     *   Structure the code cleanly into separate classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a welcome message and the main menu. It should then repeatedly display the menu and process user input until the 'Exit' option is chosen. Error messages should be clearly distinguishable using `System.err`. Success messages and list displays should use `System.out`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Customer Service Ticket System ---
 * Please choose an option:
 * 1. Add New Ticket
 * 2. Assign Next Ticket to Agent
 * 3. View Pending Tickets
 * 4. View Agents Status
 * 5. Exit
 * ------------------------------
 * Enter choice: 1
 * Enter ticket description: My internet is down.
 * Ticket added: Ticket [ID=1, Description='My internet is down.', Status='Open']
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 1
 * Enter ticket description: Cannot log in to my account.
 * Ticket added: Ticket [ID=2, Description='Cannot log in to my account.', Status='Open']
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 3
 * --- Pending Tickets ---
 * Ticket [ID=1, Description='My internet is down.', Status='Open']
 * Ticket [ID=2, Description='Cannot log in to my account.', Status='Open']
 * -----------------------
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 4
 * --- Agent Status ---
 * Agent [ID=101, Name='Alice', Status=Available]
 * Agent [ID=102, Name='Bob', Status=Available]
 * Agent [ID=103, Name='Charlie', Status=Available]
 * --------------------
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 2
 * Enter agent ID to assign ticket: 101
 * Successfully assigned Ticket [ID=1, Description='My internet is down.', Status='Assigned', Assigned Agent ID=101] to Alice (ID 101).
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 4
 * --- Agent Status ---
 * Agent [ID=101, Name='Alice', Status=Busy]
 * Agent [ID=102, Name='Bob', Status=Available]
 * Agent [ID=103, Name='Charlie', Status=Available]
 * --------------------
 * 
 * Please choose an option:
 * ... menu ...
 * Enter choice: 2
 * Enter agent ID to assign ticket: 101
 * Error: Agent Bob (ID 101) is currently busy.  <-- Example of System.err
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a basic Customer Service Ticket Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `java.util.Queue<Ticket> ticketQueue = new LinkedList<>();`: A `Queue` is used to store `Ticket` objects. `LinkedList` is a common implementation that provides FIFO behavior suitable for a ticket queue where tickets are processed in the order they are received. `offer()` is used to add tickets (at the tail), and `poll()` is used to retrieve and remove tickets (from the head). Iteration using a for-each loop (`viewPendingTickets`) allows viewing the queue contents without removing elements.
 *     *   `List<Agent> agentList = new ArrayList<>();`: A `List` is used to store `Agent` objects. `ArrayList` provides dynamic resizing and efficient random access, which is useful for iterating through agents or finding an agent by ID. The variable is declared using the `List` interface, promoting good practice by coding to the interface rather than the specific implementation where possible.
 * 
 * 2.  **Classes (`Ticket`, `Agent`, `TicketSystem`):**
 *     *   The `Ticket` class encapsulates ticket data (`id`, `description`, `status`, `assignedAgentId`) with private fields and public getter methods, adhering to encapsulation principles. The `assignToAgent` method provides controlled modification of the ticket's state.
 *     *   The `Agent` class encapsulates agent data (`id`, `name`, `isAvailable`) with private fields and public methods, including a setter for availability.
 *     *   The `TicketSystem` class acts as the controller, managing the `ticketQueue` and `agentList`. It contains methods for the system's operations (`addTicket`, `assignNextTicketToAgent`, `viewPendingTickets`, `viewAgentsStatus`) and the main application loop (`run`).
 * 
 * 3.  **System Functionality:**
 *     *   The `TicketSystem` constructor initializes the collections and populates the `agentList` with sample agents.
 *     *   The `main` method creates a `TicketSystem` instance and calls its `run` method to start the interactive loop.
 *     *   The `run` method contains a `while(running)` loop that continuously displays the menu and prompts the user for input.
 *     *   `java.util.Scanner` is used to read user input from `System.in`. `scanner.nextLine()` is used appropriately after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   A `switch` statement handles the integer menu choice, directing execution to the corresponding method (`addTicket`, `assignNextTicketToAgent`, `viewPendingTickets`, `viewAgentsStatus`) or exiting the loop.
 *     *   `addTicket`: Creates a new ticket, assigns a unique ID using `nextTicketId++`, and adds it to the `ticketQueue` using `offer()`.
 *     *   `assignNextTicketToAgent`: Contains logic to check if the queue is empty, find the specified agent in the `agentList` using the helper method `findAgentById`, check agent availability, and if all conditions are met, it `poll()`s the next ticket from the queue, updates its state, and updates the agent's state.
 *     *   `viewPendingTickets`: Iterates through the `ticketQueue` using a for-each loop to display tickets without removing them.
 *     *   `viewAgentsStatus`: Iterates through the `agentList` to display agent details and availability.
 * 
 * 4.  **Error Handling & Best Practices:**
 *     *   **`try-catch`:** The main `run` loop includes a `try-catch(InputMismatchException e)` block to gracefully handle cases where the user enters non-integer input for the main menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop. An inner `try-catch` is used specifically for reading the agent ID in option 2, providing a more specific error message for that input. A general `catch(Exception e)` is included to catch any other unexpected runtime errors and print a stack trace for debugging.
 *     *   **`System.err` vs `System.out`:** Error messages (invalid input, queue empty, agent not found/busy) are directed to `System.err`, while standard output (menu, prompts, success messages, list displays) goes to `System.out`, fulfilling the requirement to distinguish between them.
 *     *   **Encapsulation:** Demonstrated by making fields private and providing public methods for access and modification in `Ticket` and `Agent`.
 *     *   **Meaningful Names:** Variables like `ticketQueue`, `agentList`, `nextTicketId`, methods like `addTicket`, `assignNextTicketToAgent`, `findAgentById`, and classes like `Ticket`, `Agent`, `TicketSystem` are named descriptively.
 *     *   **Comments/Documentation:** Javadoc-style comments are used to explain the purpose of classes, methods, and parameters. Inline comments explain specific logic points.
 *     *   **Input Validation:** Checks are performed before attempting operations (e.g., `ticketQueue.isEmpty()`, `findAgentById(agentId) == null`, `!agentToAssign.isAvailable()`). `try-catch` handles format validation for integer inputs.
 *     *   **Clean Code Structure:** The code is organized into separate classes based on responsibility (`Ticket` for data, `Agent` for data, `TicketSystem` for logic and control). Methods are kept relatively short and focused on a single task. The `main` method is concise, primarily setting up and running the system. The `Scanner` resource is properly closed when the application exits.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating advanced concepts like collection usage, object-oriented design, user interaction, and robust error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a customer support ticket.
 */
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "Open", "Assigned"
    private Integer assignedAgentId; // null if not assigned

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Open";
        this.assignedAgentId = null;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public Integer getAssignedAgentId() {
        return assignedAgentId;
    }

    /**
     * Assigns this ticket to an agent and updates its status.
     * @param agentId The ID of the agent it's assigned to.
     */
    public void assignToAgent(int agentId) {
        this.status = "Assigned";
        this.assignedAgentId = agentId;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return Formatted string with ticket details.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "', Status='" + status + "'" +
               (assignedAgentId != null ? ", Assigned Agent ID=" + assignedAgentId : "") + "]";
    }
}

/**
 * Represents a support agent.
 */
class Agent {
    private int id;
    private String name;
    private boolean isAvailable;

    /**
     * Constructs a new Agent.
     * @param id The unique ID of the agent.
     * @param name The name of the agent.
     */
    public Agent(int id, String name) {
        this.id = id;
        this.name = name;
        this.isAvailable = true; // Agents start as available
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isAvailable() {
        return isAvailable;
    }

    // --- Setters ---
    /**
     * Sets the availability status of the agent.
     * @param available True if the agent is available, false otherwise.
     */
    public void setAvailable(boolean available) {
        isAvailable = available;
    }

    /**
     * Provides a string representation of the Agent.
     * @return Formatted string with agent details and status.
     */
    @Override
    public String toString() {
        return "Agent [ID=" + id + ", Name='" + name + "', Status=" + (isAvailable ? "Available" : "Busy") + "]";
    }
}

/**
 * Manages the Customer Service Ticket System.
 * Contains the main application logic.
 */
public class TicketSystem {

    // Use Queue for FIFO ticket processing
    private Queue<Ticket> ticketQueue;
    // Use List to manage agents
    private List<Agent> agentList;
    private int nextTicketId;
    private Scanner scanner;

    /**
     * Constructs the TicketSystem and initializes agents and collections.
     */
    public TicketSystem() {
        // LinkedList is a common implementation of the Queue interface
        ticketQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        agentList = new ArrayList<>();
        nextTicketId = 1;
        scanner = new Scanner(System.in); // Initialize scanner

        // Initialize with some agents
        agentList.add(new Agent(101, "Alice"));
        agentList.add(new Agent(102, "Bob"));
        agentList.add(new Agent(103, "Charlie"));

        System.out.println("--- Customer Service Ticket System ---");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println(System.lineSeparator() + "Please choose an option:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Assign Next Ticket to Agent");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Agents Status");
        System.out.println("5. Exit");
        System.out.println("------------------------------");
    }

    /**
     * Adds a new ticket to the queue.
     * @param description The description of the issue.
     */
    private void addTicket(String description) {
        Ticket newTicket = new Ticket(nextTicketId++, description);
        // offer() is generally preferred over add() for queues as it handles capacity-constrained queues gracefully
        ticketQueue.offer(newTicket);
        System.out.println(System.lineSeparator() + "Ticket added: " + newTicket.toString());
    }

    /**
     * Assigns the next ticket in the queue to a specified agent if available.
     * @param agentId The ID of the agent to assign the ticket to.
     */
    private void assignNextTicketToAgent(int agentId) {
        if (ticketQueue.isEmpty()) {
            System.err.println("Error: No pending tickets in the queue to assign.");
            return;
        }

        Agent agentToAssign = findAgentById(agentId);

        if (agentToAssign == null) {
            System.err.println("Error: Agent with ID " + agentId + " not found.");
            return;
        }

        if (!agentToAssign.isAvailable()) {
            System.err.println("Error: Agent " + agentToAssign.getName() + " (ID " + agentId + ") is currently busy.");
            return;
        }

        // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        Ticket ticketToAssign = ticketQueue.poll();

        // Assign ticket to agent and update agent status
        ticketToAssign.assignToAgent(agentId);
        agentToAssign.setAvailable(false);

        System.out.println(System.lineSeparator() + "Successfully assigned " + ticketToAssign.toString() + " to " + agentToAssign.getName() + " (ID " + agentId + ").");
    }

    /**
     * Displays all pending tickets currently in the queue.
     */
    private void viewPendingTickets() {
        System.out.println(System.lineSeparator() + "--- Pending Tickets ---");
        if (ticketQueue.isEmpty()) {
            System.out.println("No tickets currently in the queue.");
        } else {
            // Iterate through the queue using a for-each loop.
            // This iterates without removing elements from the queue.
            for (Ticket ticket : ticketQueue) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the status (name, ID, availability) of all agents.
     */
    private void viewAgentsStatus() {
        System.out.println(System.lineSeparator() + "--- Agent Status ---");
        if (agentList.isEmpty()) {
            System.out.println("No agents registered in the system.");
        } else {
            // Iterate through the list of agents
            for (Agent agent : agentList) {
                System.out.println(agent);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Helper method to find an agent by their ID in the agent list.
     * @param agentId The ID of the agent to find.
     * @return The Agent object if found, null otherwise.
     */
    private Agent findAgentById(int agentId) {
        for (Agent agent : agentList) {
            if (agent.getId() == agentId) {
                return agent;
            }
        }
        return null; // Agent not found
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;

        while (running) {
            displayMenu();

            int choice = -1;
            try {
                System.out.print("Enter choice: ");
                // Attempt to read an integer for the menu choice
                choice = scanner.nextInt();
                // Consume the leftover newline character after reading the integer
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        addTicket(description);
                        break;
                    case 2:
                        System.out.print("Enter agent ID to assign ticket: ");
                        // Inner try-catch for agent ID input specifically
                        try {
                            int agentIdToAssign = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            assignNextTicketToAgent(agentIdToAssign);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid integer for Agent ID.");
                            scanner.nextLine(); // Consume the invalid input
                        }
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewAgentsStatus();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        // nextInt() does not consume the newline, so no extra nextLine() needed here after a default case
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for the main menu choice
                System.err.println("Invalid input for menu choice. Please enter a number.");
                // Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Print stack trace for debugging unexpected issues
                e.printStackTrace();
            }
        }

        // Close the scanner resource when the application exits
        scanner.close();
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TicketSystem system = new TicketSystem();
        system.run(); // Start the main application loop
    }
}
