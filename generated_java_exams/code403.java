/*
 * Exam Question #403
 * Generated on: 2025-05-11 23:05:54
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Server Task Queue Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation of a server's task processing system. The system receives tasks, queues them for processing, and moves them to a completed list once processed. Due to limited resources, only one task can be "processed" at a time by user command, and tasks are processed in the order they were received (FIFO - First-In, First-Out).
 * 
 * Your program should allow a user to interact with this system via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. It should have:
 *     *   A unique integer ID.
 *     *   A String description.
 *     *   A String status (e.g., "Pending", "Completed").
 *     *   Use private fields and public getter methods. Include a constructor and a `toString()` method for easy display.
 * 2.  **Task Scheduler:** Create a `TaskScheduler` class to manage the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `List<Task>` to hold tasks that have been completed.
 *     *   A `Scanner` instance to read user input from the console.
 *     *   Use private fields and public methods for interaction.
 * 3.  **User Interaction:** Implement a command-line interface within the `TaskScheduler` using a loop that reads user commands. The supported commands are:
 *     *   `add <id> <description>`: Adds a new task with the given ID and description to the pending queue. The initial status should be "Pending". Validate that the ID is a positive integer.
 *     *   `process`: Takes the next task from the pending queue, changes its status to "Completed", and moves it to the completed tasks list. If the queue is empty, print an error message.
 *     *   `view_pending`: Displays all tasks currently in the pending queue, in the order they will be processed.
 *     *   `view_completed`: Displays all tasks in the completed tasks list.
 *     *   `exit`: Terminates the program.
 *     *   Any other command should result in an "Invalid command" error message.
 * 4.  **Flow Control:** Use a `switch` statement to handle the different user commands.
 * 5.  **Input Handling:** Use `Scanner` to read commands and their arguments. Implement input validation for the `add` command's ID.
 * 6.  **Output:**
 *     *   Use `System.out.println()` for all normal output (prompts, success messages, task listings).
 *     *   Use `System.err.println()` for all error messages (invalid commands, invalid input, attempts to process from an empty queue).
 * 7.  **Exception Handling:** Implement class-wide exception handling using `try-catch` blocks. Specifically:
 *     *   Handle potential `NumberFormatException` or other issues when parsing input (e.g., the task ID).
 *     *   Include a general `catch (Exception e)` block around the main command processing loop to catch any unexpected errors and print an error message to `System.err` before potentially exiting or continuing.
 * 8.  **Best Practices:**
 *     *   Follow Java naming conventions.
 *     *   Include meaningful comments and Javadoc where appropriate.
 *     *   Ensure proper encapsulation.
 *     *   Manage resources (like closing the `Scanner`).
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * add 1 Task A
 * Task 1 added to pending queue.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * add 2 Task B for processing
 * Task 2 added to pending queue.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * view_pending
 * Pending Tasks:
 * ID: 1, Description: Task A, Status: Pending
 * ID: 2, Description: Task B for processing, Status: Pending
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * process
 * Processing task: ID: 1, Description: Task A, Status: Pending
 * Task 1 completed.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * view_pending
 * Pending Tasks:
 * ID: 2, Description: Task B for processing, Status: Pending
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * view_completed
 * Completed Tasks:
 * ID: 1, Description: Task A, Status: Completed
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * process
 * Processing task: ID: 2, Description: Task B for processing, Status: Pending
 * Task 2 completed.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * process
 * System.err: No tasks in the pending queue to process.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * add invalid_id Task C
 * System.err: Invalid command format or Task ID. Please use: add <id> <description> where <id> is a positive integer.
 * Enter command (add <id> <desc>, process, view_pending, view_completed, exit):
 * exit
 * Exiting Task Scheduler.
 * ```
 * 
 * **Note:** The exact formatting of task listings is flexible, but it should clearly show ID, description, and status.
 *
 * EXPLANATION:
 * This solution implements a simple server task queue simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a data structure for a task with `id`, `description`, and `status`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides `public` getter methods to access task data.
 *     *   Includes a constructor to initialize a new task (defaulting status to "Pending").
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   Acts as the core manager of the system.
 *     *   **`Queue<Task> pendingTasks`**: A `Queue` is used here because tasks are processed in the order they are added (FIFO). `LinkedList` is a common implementation of `Queue`. The `offer()` method is used for adding tasks, and `poll()` is used for retrieving and removing the next task, which safely returns `null` if the queue is empty.
 *     *   **`List<Task> completedTasks`**: A `List` is used to store completed tasks. `ArrayList` is chosen for its efficiency in adding and storing elements, and iterating through them to display. Using the `List` interface type demonstrates polymorphism.
 *     *   **`Scanner scanner`**: Used to read user input from `System.in`.
 *     *   **Encapsulation**: All collection fields and the scanner are `private`. Public methods (`addTask`, `processNextTask`, `viewQueue`, `viewCompletedTasks`, `run`) provide the interface for interacting with the scheduler's state.
 *     *   **`addTask(int id, String description)`**: Creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`. Includes basic validation for the task ID.
 *     *   **`processNextTask()`**: Uses `pendingTasks.poll()` to get the head of the queue. If `poll()` returns `null` (queue is empty), an error is printed to `System.err`. Otherwise, the task's status is updated, and it's added to the `completedTasks` list.
 *     *   **`viewQueue()` and `viewCompletedTasks()`**: Iterate through the respective collections and print task details using the `Task` class's `toString()` method. `viewQueue()` iterates directly over the `Queue` which provides elements in FIFO order for viewing without removal.
 *     *   **`run()`**: Contains the main application loop.
 *         *   Reads user input line by line using `scanner.nextLine()`.
 *         *   Splits the input line to identify the command and its arguments.
 *         *   **`switch` statement**: Used to dispatch execution based on the command string. This effectively controls the program's flow based on user input.
 *         *   **Input Validation & Parsing**: Inside the `add` case, it checks if enough arguments are provided and uses `Integer.parseInt()` to convert the ID string to an integer.
 *         *   **`try-catch` for Input**: A specific `try-catch (NumberFormatException e)` is used around `Integer.parseInt()` within the `add` command case to handle non-integer input gracefully, printing an error to `System.err`.
 *         *   **Class-Wide `try-catch`**: The entire `while(running)` loop in the `run()` method is wrapped in a `try-catch` block. This demonstrates catching exceptions that might occur during the execution of commands, including potential `Scanner` issues (`NoSuchElementException`, `IllegalStateException`) or other unforeseen runtime errors (`Exception`). Error messages are printed to `System.err`, and the stack trace is printed for debugging in the general catch block.
 *         *   **`finally` block**: Ensures that the `scanner` resource is closed using `closeScanner()` regardless of whether the loop completes normally or an exception occurs.
 *     *   **`closeScanner()`**: A private helper method to manage closing the `Scanner`, preventing resource leaks.
 * 
 * 3.  **`main` Method:**
 *     *   The entry point of the application.
 *     *   Creates an instance of `TaskScheduler` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, encapsulated class structure, meeting all specified requirements and demonstrating good programming practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Needed for Scanner issues

/**
 * Represents a single task in the server task queue simulation.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     *
     * @param id          The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (if needed, though status change is handled in scheduler) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 * Handles user interaction via the console.
 */
public class TaskScheduler {
    // Using LinkedList as it implements Queue and is efficient for add/remove from ends
    private Queue<Task> pendingTasks;
    // Using List interface type, implemented by ArrayList for easy storage and iteration
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskScheduler, initializing task collections and the scanner.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param id          The task ID.
     * @param description The task description.
     */
    public void addTask(int id, String description) {
        if (id <= 0) {
            System.err.println("Task ID must be a positive integer.");
            return;
        }
        Task newTask = new Task(id, description);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task " + id + " added to pending queue.");
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the completed task to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll returns null if queue is empty

        if (taskToProcess == null) {
            System.err.println("No tasks in the pending queue to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewQueue() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main command processing loop.
     * Handles user input and dispatches commands.
     */
    public void run() {
        System.out.println("Server Task Scheduler Started.");
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                System.out.println("\nEnter command (add <id> <desc>, process, view_pending, view_completed, exit):");
                String inputLine = scanner.nextLine().trim();
                String[] parts = inputLine.split(" ", 3); // Split into max 3 parts: command, id, description

                String command = parts[0].toLowerCase();

                switch (command) {
                    case "add":
                        // Ensure correct number of arguments
                        if (parts.length >= 3) {
                            try {
                                int id = Integer.parseInt(parts[1]);
                                String description = parts[2];
                                addTask(id, description);
                            } catch (NumberFormatException e) {
                                System.err.println("Invalid Task ID format. ID must be an integer.");
                            }
                        } else {
                            System.err.println("Invalid command format. Usage: add <id> <description>");
                        }
                        break;

                    case "process":
                        processNextTask();
                        break;

                    case "view_pending":
                        viewQueue();
                        break;

                    case "view_completed":
                        viewCompletedTasks();
                        break;

                    case "exit":
                        System.out.println("Exiting Task Scheduler.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid command. Please try again.");
                        break;
                }
            }
        } catch (NoSuchElementException e) {
            // Handles potential issues if input stream is closed unexpectedly
            System.err.println("Input stream closed unexpectedly. Exiting.");
        } catch (IllegalStateException e) {
             // Handles potential issues with scanner if it's used after closing
             System.err.println("Scanner is closed or in an invalid state. Exiting.");
        }
        catch (Exception e) {
            // General catch-all for unexpected exceptions during the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed regardless of how the loop ends
            closeScanner();
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            // System.out.println("Scanner closed."); // Optional: confirmation
        }
    }

    /**
     * Main method to start the TaskScheduler.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
