/*
 * Exam Question #1051
 * Generated on: 2025-05-12 17:18:12
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Print Job Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simplified command-line application to manage print jobs in a small office. The system should handle job submission, process jobs one by one in the order they were submitted, and maintain a history of all completed or failed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class `PrintJob` to represent a print job.
 *     *   It should have private fields: `id` (an integer, unique identifier), `fileName` (String), and `status` (use an enum `Status` with values like `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Provide a constructor, public getter methods for all fields, and a public method to update the status (`setStatus`).
 *     *   Implement a `toString()` method for easy display of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Create a class `PrintManager` to manage the print jobs system.
 *     *   It must have private fields:
 *         *   A `Queue<PrintJob>` to hold jobs waiting to be processed (First-In, First-Out).
 *         *   A `List<PrintJob>` (implemented by `ArrayList`) to store jobs that have finished processing (completed or failed).
 *         *   An integer counter for generating unique job IDs.
 *         *   A `Scanner` object for reading user input.
 *     *   Implement the following public methods:
 *         *   A constructor that initializes the queue, list, ID counter, and scanner.
 *         *   `submitJob(String fileName)`: Creates a new `PrintJob` with status `PENDING`, adds it to the job queue, and prints a success message with the job ID.
 *         *   `processNextJob()`: Takes the next job from the queue. If the queue is empty, print an error message. Otherwise, simulate processing (e.g., change status to `PROCESSING`, then randomly or based on some simple logic change it to `COMPLETED` or `FAILED`). Move the processed job from the queue to the history list. Print the result of the processing.
 *         *   `viewJobQueue()`: Displays all jobs currently in the waiting queue with their details. Indicate if the queue is empty.
 *         *   `viewCompletedJobs()`: Displays all jobs in the completed/failed history list with their details. Indicate if the history is empty.
 *         *   `run()`: This method should contain the main application loop. It should repeatedly:
 *             *   Prompt the user for a command.
 *             *   Read the user's input using the `Scanner`.
 *             *   Use a `switch` statement to handle the following commands:
 *                 *   `submit <filename>`: Calls `submitJob`. Needs to parse the filename from the input string. Handle cases where the filename is missing.
 *                 *   `process`: Calls `processNextJob`.
 *                 *   `queue`: Calls `viewJobQueue`.
 *                 *   `history`: Calls `viewCompletedJobs`.
 *                 *   `exit`: Terminates the application loop.
 *                 *   Any other input: Print an "Unknown command" error message.
 *     *   The `PrintManager` class should contain the `main` method to create an instance of `PrintManager` and call its `run()` method.
 * 
 * 3.  **Error Handling and Output:**
 *     *   Use `System.err` for all error messages (e.g., invalid command format, missing filename, queue empty for processing, any unexpected runtime errors).
 *     *   Use `System.out` for all normal output (prompts, success messages, job details display).
 *     *   Implement **class-wide exception handling** within the `run()` method using `try-catch` blocks. This should catch potential runtime exceptions that might occur during input processing or command execution (e.g., `InputMismatchException`, `NoSuchElementException`, or other unexpected errors) and print an informative error message to `System.err` before the loop continues or the program exits (your choice, continuing is better). You should also include specific input validation checks (e.g., for the `submit` command) and handle those errors using `System.err` without necessarily throwing exceptions if a simple check suffices.
 * 
 * 4.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but not strictly required for every method in an exam setting, focus on clarity).
 *     *   Ensure input validation where applicable (e.g., checking if a filename is provided for submit).
 *     *   Structure the code clearly.
 * 
 * **Expected Output Format Examples:**
 * 
 * *   Prompt: `Enter command (submit <file>, process, queue, history, exit): `
 * *   Submit Success: `Job submitted successfully. Job ID: 1, File: report.pdf`
 * *   Submit Error: `ERROR: Invalid submit command. Usage: submit <filename>`
 * *   Process Success (Completed): `Job ID: 1 processed. Status: COMPLETED`
 * *   Process Success (Failed): `Job ID: 2 processed. Status: FAILED`
 * *   Process Error: `ERROR: Print queue is empty. No jobs to process.`
 * *   Queue Empty: `Print queue is empty.`
 * *   Queue Contents:
 *     ```
 *     Print Queue:
 *     [Job ID: 3, File: presentation.pptx, Status: PENDING]
 *     [Job ID: 4, File: image.jpg, Status: PENDING]
 *     ```
 * *   History Empty: `Job history is empty.`
 * *   History Contents:
 *     ```
 *     Job History:
 *     [Job ID: 1, File: report.pdf, Status: COMPLETED]
 *     [Job ID: 2, File: document.docx, Status: FAILED]
 *     ```
 * *   Unknown Command: `ERROR: Unknown command. Type 'exit' to quit.`
 * *   General System Error (caught by try-catch): `ERROR: An unexpected system error occurred: <error details>`
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method.
 *
 * EXPLANATION:
 * This solution implements a simplified command-line print job manager, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`PrintJob` Class:** A simple POJO (Plain Old Java Object) representing a print job with `id`, `fileName`, and `status`. The `Status` is an enum for clarity and type safety. Getters, a status setter, and a `toString()` method are provided following encapsulation principles.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   **State:** It maintains the system's state using a `Queue<PrintJob>` (`jobQueue`) for pending jobs and a `List<PrintJob>` (`completedJobs`) for history. `LinkedList` is used for the queue as it efficiently supports queue operations (`offer`, `poll`, `peek`). `ArrayList` is used for the list as it's a common and flexible list implementation. A counter `nextJobId` ensures unique IDs. A `Scanner` is used for input. All these fields are `private` for encapsulation.
 *     *   **Constructor:** Initializes the collections, the ID counter, and the `Scanner`.
 *     *   **`submitJob(String fileName)`:** Creates a new `PrintJob` instance, assigns the next available ID, sets the initial status to `PENDING`, and adds it to the `jobQueue` using `offer()`. Input validation checks if the filename is provided. Output is directed to `System.out`.
 *     *   **`processNextJob()`:** Checks if the queue is empty. If not, it retrieves and removes the next job using `poll()`. It simulates processing by changing the status and using `Thread.sleep()`. A random outcome determines if the job becomes `COMPLETED` or `FAILED`. The processed job is then added to the `completedJobs` list. Error messages (empty queue, processing failure) go to `System.err`. A `try-catch` block is included *within* this method to handle potential `InterruptedException` during the simulated sleep or other unexpected issues during processing simulation, demonstrating more localized error handling.
 *     *   **`viewJobQueue()`:** Iterates through the `jobQueue` using an enhanced for loop (which doesn't remove elements) and prints each job's details to `System.out`. Checks for emptiness.
 *     *   **`viewCompletedJobs()`:** Iterates through the `completedJobs` list and prints each job's details to `System.out`. Checks for emptiness.
 *     *   **`run()`:** This is the core interaction loop.
 *         *   It uses a `while(running)` loop.
 *         *   **Class-wide Exception Handling:** The *entire* logic inside the loop that reads input and processes commands is wrapped in a `try-catch (Exception e)`. This catches any unexpected `RuntimeException` or other `Exception` that might occur during the command parsing or method calls, printing an error to `System.err` and allowing the loop to potentially continue (or exit gracefully if the error is fatal like `NoSuchElementException`). Specific checks for `NoSuchElementException` and `IllegalStateException` (related to Scanner usage) are included for robustness.
 *         *   Input is read using `scanner.nextLine()`.
 *         *   The input line is split to separate the command from arguments.
 *         *   A `switch` statement is used to dispatch logic based on the command (`submit`, `process`, `queue`, `history`, `exit`).
 *         *   Each case calls the appropriate method or sets the `running` flag to false for `exit`.
 *         *   Input validation for the `submit` command (checking for filename) is done before calling `submitJob`, printing an error to `System.err` if invalid.
 *         *   An empty `default` case in the `switch` handles unknown commands, printing an error to `System.err`.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates an instance of `PrintManager` and calls its `run()` method.
 * 
 * 3.  **Error Handling and Output:** `System.err` is consistently used for all error messages as required, while `System.out` is used for all normal output and prompts. The `try-catch` block around the main loop fulfills the "class-wide exception handling" requirement by providing a safety net for unexpected errors during the main execution flow. Specific error checks (like empty queue, missing filename) are handled with `System.err` messages.
 * 
 * 4.  **Best Practices:** The code uses meaningful names (`jobQueue`, `completedJobs`, `submitJob`, `processNextJob`, etc.), private fields with public methods for encapsulation, and includes basic comments. The structure separates the job data (`PrintJob`) from the management logic (`PrintManager`). Input validation is performed for the `submit` command.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, functional program that simulates a real-world task, while adhering to good programming practices and demonstrating error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although Scanner nextLine might not throw this, good to be aware
import java.util.NoSuchElementException; // Thrown by Scanner when no more input

// Enum for Print Job Status
enum Status {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Class to represent a single Print Job
class PrintJob {
    private int id;
    private String fileName;
    private Status status;

    // Constructor
    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
        this.status = Status.PENDING; // New jobs start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(Status status) {
        this.status = status;
    }

    // toString method for easy display
    @Override
    public String toString() {
        return String.format("[Job ID: %d, File: %s, Status: %s]", id, fileName, status);
    }
}

// Class to manage the Print Jobs system
public class PrintManager { // Changed to public class for main method access

    private Queue<PrintJob> jobQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId;
    private Scanner scanner;

    // Constructor
    public PrintManager() {
        jobQueue = new LinkedList<>(); // LinkedList implements Queue
        completedJobs = new ArrayList<>(); // ArrayList implements List
        nextJobId = 1; // Start job IDs from 1
        scanner = new Scanner(System.in);
    }

    // Method to submit a new job
    public void submitJob(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("ERROR: Filename cannot be empty.");
            return;
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim());
        jobQueue.offer(newJob); // Add job to the end of the queue
        System.out.println("Job submitted successfully. " + newJob);
    }

    // Method to process the next job in the queue
    public void processNextJob() {
        if (jobQueue.isEmpty()) {
            System.err.println("ERROR: Print queue is empty. No jobs to process.");
            return;
        }

        PrintJob jobToProcess = jobQueue.poll(); // Get and remove the head of the queue
        System.out.println("Processing job: " + jobToProcess);
        jobToProcess.setStatus(Status.PROCESSING);

        // Simulate processing time/success/failure (e.g., random outcome)
        try {
            Thread.sleep(500); // Simulate work
            // Simple simulation: 80% chance of success
            if (Math.random() < 0.8) {
                jobToProcess.setStatus(Status.COMPLETED);
                System.out.println("Job ID: " + jobToProcess.getId() + " processed. Status: COMPLETED");
            } else {
                jobToProcess.setStatus(Status.FAILED);
                System.err.println("Job ID: " + jobToProcess.getId() + " processing failed. Status: FAILED");
            }
        } catch (InterruptedException e) {
            // Handle potential interruption during sleep
            jobToProcess.setStatus(Status.FAILED); // Mark as failed if interrupted
            System.err.println("Job ID: " + jobToProcess.getId() + " processing interrupted. Status: FAILED");
            Thread.currentThread().interrupt(); // Restore the interrupted status
        } catch (Exception e) {
             // Catch any other unexpected errors during processing simulation
             jobToProcess.setStatus(Status.FAILED);
             System.err.println("ERROR: An error occurred during processing job ID " + jobToProcess.getId() + ": " + e.getMessage());
             // e.printStackTrace(System.err); // Could print stack trace for debugging
        } finally {
             completedJobs.add(jobToProcess); // Add the processed job to history regardless of outcome
        }
    }

    // Method to view the current job queue
    public void viewJobQueue() {
        if (jobQueue.isEmpty()) {
            System.out.println("Print queue is empty.");
        } else {
            System.out.println("Print Queue:");
            // Iterate through the queue without removing elements
            for (PrintJob job : jobQueue) {
                System.out.println(job);
            }
        }
    }

    // Method to view the completed jobs history
    public void viewCompletedJobs() {
        if (completedJobs.isEmpty()) {
            System.out.println("Job history is empty.");
        } else {
            System.out.println("Job History:");
            // Iterate through the list
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
    }

    // Main application loop
    public void run() {
        boolean running = true;
        System.out.println("Print Job Manager started.");

        while (running) {
            System.out.print("Enter command (submit <file>, process, queue, history, exit): ");

            // Class-wide exception handling for the main loop
            try {
                if (!scanner.hasNextLine()) { // Check if there's input to prevent NoSuchElementException on empty stream
                    running = false; // Exit if input stream is closed
                    break;
                }
                String commandLine = scanner.nextLine().trim();

                if (commandLine.isEmpty()) {
                    continue; // Skip empty lines
                }

                String[] parts = commandLine.split("\\s+", 2); // Split into command and potential argument
                String command = parts[0].toLowerCase(); // Get the command part

                switch (command) {
                    case "submit":
                        if (parts.length < 2) {
                            System.err.println("ERROR: Invalid submit command. Usage: submit <filename>");
                        } else {
                            String fileName = parts[1];
                            submitJob(fileName);
                        }
                        break;
                    case "process":
                        processNextJob();
                        break;
                    case "queue":
                        viewJobQueue();
                        break;
                    case "history":
                        viewCompletedJobs();
                        break;
                    case "exit":
                        System.out.println("Exiting Print Job Manager.");
                        running = false;
                        break;
                    default:
                        System.err.println("ERROR: Unknown command. Type 'exit' to quit.");
                        break;
                }
            } catch (NoSuchElementException e) {
                // This might happen if the input stream is closed unexpectedly (e.g., Ctrl+D)
                System.err.println("ERROR: Input stream closed. Exiting.");
                running = false;
            } catch (IllegalStateException e) {
                 // This might happen if the scanner is used after being closed
                 System.err.println("ERROR: Scanner is closed. Exiting.");
                 running = false;
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions during command processing
                System.err.println("ERROR: An unexpected system error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for detailed debugging
            }
        }

        // Close the scanner when exiting
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run();
    }
}
