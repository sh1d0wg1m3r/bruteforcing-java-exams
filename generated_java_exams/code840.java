/*
 * Exam Question #840
 * Generated on: 2025-05-12 16:48:57
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Document Processing Workflow Simulation**
 * 
 * You are tasked with developing a simple console-based application that simulates a document processing workflow. The system should manage a queue of documents waiting to be processed and maintain a list of documents that have been successfully processed.
 * 
 * Your solution must demonstrate proficiency in using various core Java components and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a class `Document` to represent a document. It should have:
 *     *   A unique integer ID.
 *     *   A String name.
 *     *   A String content (a short description).
 *     *   A boolean flag `isProcessed` initialized to `false`.
 *     *   A constructor to initialize name and content, automatically assigning an ID.
 *     *   Getter methods for all fields.
 *     *   A method `markAsProcessed()` that sets `isProcessed` to `true`.
 *     *   A `toString()` method for easy printing.
 * 
 * 2.  **Processing System:** Create a class `DocumentProcessingSystem` that manages the workflow. It should have:
 *     *   A `Queue<Document>` to hold documents waiting to be processed. Use a suitable concrete implementation like `LinkedList`.
 *     *   A `List<Document>` to hold documents that have been processed. Use `ArrayList` as the concrete implementation but declare the field using the `List` interface.
 *     *   An internal counter to generate unique document IDs.
 *     *   A method `addDocument(String name, String content)`: Creates a new `Document` with a unique ID and adds it to the processing queue. Returns the ID of the added document.
 *     *   A method `processNextDocument()`: Removes the document at the front of the queue, calls its `markAsProcessed()` method, and adds it to the list of processed documents. Returns the processed `Document` object, or `null` if the queue was empty.
 *     *   A method `getProcessingQueue()`: Returns the `Queue` of waiting documents.
 *     *   A method `getProcessedDocuments()`: Returns the `List` of processed documents.
 * 
 * 3.  **Main Application:** Create a class `DocumentProcessorApp` with a `main` method to run the simulation. This class will handle user interaction.
 *     *   Initialize a `DocumentProcessingSystem`.
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         *   1. Add New Document
 *         *   2. Process Next Document
 *         *   3. View Processing Queue
 *         *   4. View Processed Documents
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement the logic for each option by calling methods on the `DocumentProcessingSystem` instance.
 *     *   **Input Validation:** Handle cases where the user enters non-integer input for the menu choice or provides empty strings for document name/content.
 *     *   **Error Handling:**
 *         *   Use `System.err` to display error messages (e.g., invalid menu choice, attempting to process when the queue is empty, invalid input format).
 *         *   Use `System.out` for all normal output (menu, prompts, success messages, listing documents).
 *         *   Implement class-wide exception handling (a `try-catch` block covering the main application loop or core logic) to catch unexpected runtime errors and prevent the program from crashing abruptly.
 *     *   Ensure the `Scanner` resource is closed properly when the application exits.
 * 
 * 4.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments or Javadoc.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and respond according to the user's choice, printing status, documents in queue, or processed documents using `System.out`, and errors using `System.err`.
 * 
 * ```
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document name: Report A
 * Enter document content: Monthly sales figures
 * Document 'Report A' added with ID: 1
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document name: Proposal X
 * Enter document content: Project budget proposal
 * Document 'Proposal X' added with ID: 2
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Queue ---
 * [ID: 1, Name: Report A, Processed: false]
 * [ID: 2, Name: Proposal X, Processed: false]
 * --------------------------
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 2
 * Processing document: [ID: 1, Name: Report A, Processed: true]
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 4
 * --- Processed Documents ---
 * [ID: 1, Name: Report A, Processed: true]
 * ---------------------------
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: process
 * Error: Invalid input. Please enter a number.
 * 
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 5
 * Exiting Document Processing System.
 * ```
 * 
 * *(Note: The exact output format for listing documents can vary slightly, but should clearly show the documents and their details.)*
 *
 * EXPLANATION:
 * The provided solution implements a simple document processing workflow simulation using the required Java components and best practices.
 * 
 * 1.  **`Document` Class:**
 *     *   Represents a single document with an ID, name, content, and a processing status.
 *     *   Uses private fields and public getters, demonstrating encapsulation.
 *     *   The `markAsProcessed()` method modifies the internal state.
 *     *   The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`DocumentProcessingSystem` Class:**
 *     *   Manages the core logic of the system.
 *     *   `processingQueue`: Declared as `Queue<Document>` and instantiated as `new LinkedList<>()`. This demonstrates using the interface type for the variable declaration, promoting flexibility (you could swap `LinkedList` for another `Queue` implementation if needed without changing the variable type). `Queue` is used correctly for FIFO (First-In, First-Out) processing. `offer()` is used for adding, and `poll()` is used for removing and retrieving from the front.
 *     *   `processedDocuments`: Declared as `List<Document>` and instantiated as `new ArrayList<>()`. This again uses the interface type (`List`) for declaration, while `ArrayList` provides the dynamic array implementation. `List` is suitable for storing processed items where order matters (order of processing) and random access or iteration is needed. `add()` is used to append processed documents.
 *     *   `nextDocumentId`: A simple counter to ensure each document gets a unique ID.
 *     *   `addDocument()`: Creates a new `Document` and adds it to the queue. Includes basic input validation for name and content, throwing an `IllegalArgumentException` if they are empty.
 *     *   `processNextDocument()`: Retrieves and removes the next document from the queue using `poll()`. If `poll()` returns `null` (queue empty), it indicates no document was processed. Otherwise, it marks the document as processed and adds it to the `processedDocuments` list.
 * 
 * 3.  **`DocumentProcessorApp` Class:**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   Initializes the `DocumentProcessingSystem` and `Scanner`.
 *     *   The main logic runs within a `while(running)` loop controlled by user input.
 *     *   **`Scanner`:** Used to read user input for menu choices, document names, and content. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   **`Switch` Statement:** Handles the different menu options, directing the program flow based on the user's integer input.
 *     *   **`System.out` & `System.err`:** `System.out.println()` is used for displaying the menu, prompts, success messages, and the contents of the queue and processed list. `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, attempting to process an empty queue, or invalid input format.
 *     *   **Input Validation & Error Handling:**
 *         *   A `try-catch (InputMismatchException e)` block is placed *inside* the main loop but *around* the `scanner.nextInt()` call. This specifically catches non-integer input for the menu choice, prints an error using `System.err`, consumes the invalid input, and uses `continue` to restart the loop, prompting the user again.
 *         *   The `addDocument` method throws `IllegalArgumentException` for empty name/content, which is caught in the `case 1` block and printed using `System.err`.
 *         *   The `processNextDocument` method returns `null` if the queue is empty, which is checked in the `case 2` block, and an error message is printed to `System.err`.
 *     *   **Class-wide `try-catch`:** A large `try-catch (Exception e)` block wraps the entire `while(running)` loop in the `main` method. This fulfills the "class-wide exception handling" requirement by providing a safety net for any *unexpected* exceptions that might occur anywhere within the main application flow, preventing the program from crashing ungracefully. It prints a generic error message to `System.err` and the stack trace for debugging.
 *     *   **Resource Management:** A `finally` block is used to ensure `scanner.close()` is called when the main `try` block exits (either normally or due to an exception), releasing the system resource held by the `Scanner`.
 * 
 * The solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, object-oriented structure, demonstrating good programming practices like encapsulation, meaningful naming, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single document in the processing system.
 */
class Document {
    private int id;
    private String name;
    private String content;
    private boolean isProcessed;

    /**
     * Constructs a new Document.
     *
     * @param id The unique ID for the document.
     * @param name The name of the document.
     * @param content The content/description of the document.
     */
    public Document(int id, String name, String content) {
        this.id = id;
        this.name = name;
        this.content = content;
        this.isProcessed = false; // Documents are initially not processed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getContent() {
        return content;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    /**
     * Marks the document as processed.
     */
    public void markAsProcessed() {
        this.isProcessed = true;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Name: " + name + ", Processed: " + isProcessed + "]";
    }
}

/**
 * Manages the queue and list of documents in the processing workflow.
 */
class DocumentProcessingSystem {
    private Queue<Document> processingQueue;
    private List<Document> processedDocuments; // Declared as List, implemented as ArrayList
    private int nextDocumentId; // Counter for unique IDs

    /**
     * Constructs a new DocumentProcessingSystem.
     */
    public DocumentProcessingSystem() {
        // Using LinkedList as a concrete implementation for Queue
        this.processingQueue = new LinkedList<>();
        // Using ArrayList as a concrete implementation for List
        this.processedDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start ID from 1
    }

    /**
     * Adds a new document to the processing queue.
     *
     * @param name The name of the document. Must not be null or empty.
     * @param content The content/description of the document. Must not be null or empty.
     * @return The ID of the newly added document.
     * @throws IllegalArgumentException if name or content is null or empty.
     */
    public int addDocument(String name, String content) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Document name cannot be empty.");
        }
        if (content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("Document content cannot be empty.");
        }

        int currentId = nextDocumentId++;
        Document newDocument = new Document(currentId, name.trim(), content.trim());
        processingQueue.offer(newDocument); // offer is preferred over add for capacity-constrained queues (though LinkedList isn't)
        return currentId;
    }

    /**
     * Processes the next document from the queue.
     * Removes the document from the queue, marks it as processed, and adds it to the processed list.
     *
     * @return The processed Document object, or null if the processing queue is empty.
     */
    public Document processNextDocument() {
        // poll retrieves and removes the head of the queue, returns null if empty
        Document docToProcess = processingQueue.poll();

        if (docToProcess != null) {
            docToProcess.markAsProcessed();
            processedDocuments.add(docToProcess);
            return docToProcess;
        } else {
            return null; // Queue was empty
        }
    }

    /**
     * Gets the current processing queue.
     *
     * @return The Queue of documents waiting to be processed.
     */
    public Queue<Document> getProcessingQueue() {
        return processingQueue;
    }

    /**
     * Gets the list of documents that have been processed.
     *
     * @return The List of processed documents.
     */
    public List<Document> getProcessedDocuments() {
        return processedDocuments;
    }
}

/**
 * Main application class to run the Document Processing System simulation.
 */
public class DocumentProcessorApp {

    public static void main(String[] args) {
        DocumentProcessingSystem system = new DocumentProcessingSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter document name: ");
                        String name = scanner.nextLine();
                        System.out.print("Enter document content: ");
                        String content = scanner.nextLine();
                        try {
                            int docId = system.addDocument(name, content);
                            System.out.println("Document '" + name + "' added with ID: " + docId);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding document: " + e.getMessage());
                        }
                        break;

                    case 2:
                        Document processedDoc = system.processNextDocument();
                        if (processedDoc != null) {
                            System.out.println("Processing document: " + processedDoc);
                        } else {
                            System.err.println("Error: Processing queue is empty. No documents to process.");
                        }
                        break;

                    case 3:
                        System.out.println("--- Processing Queue ---");
                        Queue<Document> queue = system.getProcessingQueue();
                        if (queue.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            // Iterate over the queue without removing elements (using enhanced for loop)
                            for (Document doc : queue) {
                                System.out.println(doc);
                            }
                        }
                        System.out.println("--------------------------");
                        break;

                    case 4:
                        System.out.println("--- Processed Documents ---");
                        List<Document> processedList = system.getProcessedDocuments();
                        if (processedList.isEmpty()) {
                            System.out.println("No documents have been processed yet.");
                        } else {
                            // Iterate over the list
                            for (Document doc : processedList) {
                                System.out.println(doc);
                            }
                        }
                        System.out.println("---------------------------");
                        break;

                    case 5:
                        running = false;
                        System.out.println("Exiting Document Processing System.");
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed regardless of exceptions
            scanner.close();
            System.out.println("Scanner closed."); // Optional: indicate scanner closure
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Document Processing System ---");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Exit");
    }
}
