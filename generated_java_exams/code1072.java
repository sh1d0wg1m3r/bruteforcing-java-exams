/*
 * Exam Question #1072
 * Generated on: 2025-05-12 17:20:56
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Process Scheduler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple simulation of a process scheduler. The system should manage processes that are waiting to be executed and keep track of processes that have been completed. New processes are added to a queue and executed in a First-In, First-Out (FIFO) manner.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Process Representation:** Create a class `Process` to represent a task. It should have private fields for `id` (integer), `name` (String), and `priority` (String, e.g., "HIGH", "MEDIUM", "LOW"). Include a constructor and public getter methods for these fields. Override the `toString()` method to provide a user-friendly representation of a process.
 * 2.  **Scheduler Logic:** Create a class `ProcessScheduler` that manages the processes.
 *     *   It must use a `java.util.Queue<Process>` (specifically, a `LinkedList` implementation) to store processes waiting for execution.
 *     *   It must use a `java.util.List<Process>` (specifically, an `ArrayList` implementation) to store completed processes.
 *     *   Provide a method `addProcess(Process process)` to add a new process to the waiting queue.
 *     *   Provide a method `executeNextProcess()` that removes the next process from the queue and adds it to the completed list. This method should return the executed `Process`.
 *     *   Provide methods `getPendingProcesses()` and `getCompletedProcesses()` that return a `List<Process>` containing the respective processes. These methods should return copies of the internal collections to prevent external modification.
 * 3.  **User Interface:** Create a main application class (e.g., `SchedulerApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`. The interface should present a menu with the following options:
 *     *   1. Add New Process
 *     *   2. Execute Next Process
 *     *   3. List Pending Processes
 *     *   4. List Completed Processes
 *     *   5. Exit
 * 4.  **Flow Control:** Use a `switch` statement in the main application class to handle the user's menu choice.
 * 5.  **Input Handling and Validation:**
 *     *   Use `Scanner` to read user input for menu choices and process details (ID, name, priority).
 *     *   Validate user input: Ensure process ID is a positive integer, process name is not empty, and priority is one of the expected values ("HIGH", "MEDIUM", "LOW").
 *     *   Handle potential `NumberFormatException` if the user enters non-numeric input where a number is expected (e.g., for menu choice or process ID).
 * 6.  **Error Handling:**
 *     *   Implement a custom exception `EmptyQueueException` that is thrown by `executeNextProcess()` if the pending queue is empty.
 *     *   Use `try-catch` blocks to handle `EmptyQueueException` and input validation errors.
 *     *   Implement class-wide exception handling in the `main` method to catch unexpected errors during the application's execution.
 *     *   Use `System.err` to print all error messages (input validation errors, exceptions, etc.).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, listing processes).
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Structure the code into logical classes and methods.
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively. Users select menu options, provide input, and receive feedback or results. Error messages should be clearly distinguishable using `System.err`. Listing processes should display their details using the `Process.toString()` method.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Simple Process Scheduler ---
 * 
 * Scheduler Menu:
 * 1. Add New Process
 * 2. Execute Next Process
 * 3. List Pending Processes
 * 4. List Completed Processes
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Process ---
 * Enter Process ID (integer > 0): 101
 * Enter Process Name: Data Processing
 * Enter Process Priority (HIGH, MEDIUM, LOW): HIGH
 * Process added successfully: Process [ID=101, Name='Data Processing', Priority='HIGH']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Process ---
 * Enter Process ID (integer > 0): 102
 * Enter Process Name: Report Generation
 * Enter Process Priority (HIGH, MEDIUM, LOW): MEDIUM
 * Process added successfully: Process [ID=102, Name='Report Generation', Priority='MEDIUM']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Processes ---
 * Process [ID=101, Name='Data Processing', Priority='HIGH']
 * Process [ID=102, Name='Report Generation', Priority='MEDIUM']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Execute Next Process ---
 * Executed Process: Process [ID=101, Name='Data Processing', Priority='HIGH']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Processes ---
 * Process [ID=102, Name='Report Generation', Priority='MEDIUM']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Processes ---
 * Process [ID=101, Name='Data Processing', Priority='HIGH']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Execute Next Process ---
 * Executed Process: Process [ID=102, Name='Report Generation', Priority='MEDIUM']
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Execute Next Process ---
 * Operation failed: No processes in the pending queue to execute. // This should go to System.err
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: invalid
 * 
 * Invalid input. Please enter a number for your choice. // This should go to System.err
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Process ---
 * Enter Process ID (integer > 0): -5
 * Error: Process ID must be a positive integer. // This should go to System.err
 * 
 * Scheduler Menu:
 * ...
 * Enter your choice: 5
 * Exiting scheduler.
 * Scheduler application terminated.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`Process`, `ProcessScheduler`, `SchedulerApp`, `EmptyQueueException`).
 *
 * EXPLANATION:
 * This solution implements a simple process scheduler simulation, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Process` Class:** This class is a simple Plain Old Java Object (POJO) representing a task. It encapsulates process details (`id`, `name`, `priority`) with private fields and public getters, adhering to encapsulation principles. The `toString()` method provides a convenient way to display process information.
 * 
 * 2.  **`ProcessScheduler` Class:** This is the core logic class.
 *     *   It uses a `Queue<Process>` (`LinkedList`) for `pendingProcesses`, which is suitable for FIFO operations (adding to the end, removing from the front).
 *     *   It uses a `List<Process>` (`ArrayList`) for `completedProcesses`, suitable for storing a history where iteration is common.
 *     *   `addProcess` uses `queue.offer()` to add elements to the queue.
 *     *   `executeNextProcess` uses `queue.poll()` to remove and return the head of the queue. It throws a custom `EmptyQueueException` if the queue is empty, demonstrating specific error conditions.
 *     *   `getPendingProcesses` and `getCompletedProcesses` return `new ArrayList<>(...)` to provide callers with a copy of the internal state, preventing external code from modifying the scheduler's collections directly, which is a good practice for maintaining data integrity.
 * 
 * 3.  **`SchedulerApp` Class:** This is the main application class responsible for the user interface and overall flow.
 *     *   It uses a `Scanner` to read user input from the console. Reading lines (`scanner.nextLine()`) and then parsing is preferred over methods like `nextInt()` to avoid common newline issues.
 *     *   The `main` method contains a top-level `try-catch-finally` block. This serves as the "class-wide" or application-wide exception handling, catching any unexpected exceptions that might propagate up and ensuring resources like the `Scanner` are closed in the `finally` block.
 *     *   The `runScheduler` method contains the main loop and another `try-catch` block around the `switch` statement. This inner `try-catch` handles exceptions that might occur *during* the execution of a specific menu option, such as the `EmptyQueueException` thrown by `executeNextProcess` or potential errors in other operations.
 *     *   A `switch` statement is used to dispatch actions based on the user's numeric choice, fulfilling requirement 4.
 *     *   Input validation is performed in the `addProcess` method for ID, name, and priority. Invalid input results in an error message printed to `System.err` and the method returning without adding the process.
 *     *   `NumberFormatException` is specifically caught when parsing the user's menu choice and process ID input, providing a user-friendly error message via `System.err`.
 *     *   `System.out` is used for all standard output, including the menu, prompts, and successful operation messages. `System.err` is strictly used for error reporting.
 * 
 * 4.  **`EmptyQueueException` Class:** A simple custom exception class extending `Exception`, used to signal a specific business logic error condition (attempting to execute a process when none are pending). This demonstrates creating and using custom exceptions.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Process`, `ProcessScheduler`, `SchedulerApp`) with encapsulation, constructors, and methods.
 * *   **Collections Framework:** Effective use of `Queue` (via `LinkedList`) for managing a waiting list with FIFO behavior and `List` (via `ArrayList`) for storing completed items. Understanding the appropriate use cases for these interfaces/implementations.
 * *   **Input/Output:** Using `Scanner` for console input, `System.out` for normal output, and `System.err` for error output.
 * *   **Control Flow:** Using `while` loops for the application lifecycle and `switch` statements for menu navigation.
 * *   **Exception Handling:** Implementing `try-catch` blocks for specific exceptions (`NumberFormatException`, `EmptyQueueException`) and general exceptions, including a top-level handler. Creating and throwing a custom exception.
 * *   **Best Practices:** Encapsulation, meaningful names, comments (Javadoc), input validation, defensive copying (returning copies of collections), clean separation of concerns into different classes.
 * 
 * This solution effectively integrates the required components into a functional and well-structured program, demonstrating a solid understanding of intermediate to advanced Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although we read line, good to be aware

/**
 * Custom exception thrown when an operation is attempted on an empty queue.
 */
class EmptyQueueException extends Exception {
    /**
     * Constructs a new EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single process or task in the scheduler.
 */
class Process {
    private final int id;
    private final String name;
    private final String priority; // e.g., HIGH, MEDIUM, LOW

    /**
     * Constructs a new Process.
     * @param id The unique identifier for the process. Must be positive.
     * @param name The name of the process. Must not be empty.
     * @param priority The priority level of the process (e.g., "HIGH", "MEDIUM", "LOW").
     */
    public Process(int id, String name, String priority) {
        // Basic validation could be added here, but relying on caller for simplicity in this context.
        this.id = id;
        this.name = name;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the process.
     * @return A formatted string describing the process.
     */
    @Override
    public String toString() {
        return String.format("Process [ID=%d, Name='%s', Priority='%s']", id, name, priority);
    }

    // Optional: equals() and hashCode() could be added based on ID for uniqueness
}

/**
 * Manages a queue of pending processes and a list of completed processes.
 */
class ProcessScheduler {
    // Use LinkedList as it implements Queue and is efficient for adding/removing from ends
    private final Queue<Process> pendingProcesses;
    // Use ArrayList for storing completed processes, as random access/iteration is common
    private final List<Process> completedProcesses;

    /**
     * Constructs a new ProcessScheduler.
     */
    public ProcessScheduler() {
        this.pendingProcesses = new LinkedList<>();
        this.completedProcesses = new ArrayList<>();
    }

    /**
     * Adds a process to the pending queue.
     * @param process The process to add. Must not be null.
     */
    public void addProcess(Process process) {
        if (process != null) {
            pendingProcesses.offer(process); // offer is generally preferred over add for queues
        }
    }

    /**
     * Executes the next process in the pending queue.
     * Moves the process from the pending queue to the completed list.
     * @return The process that was executed.
     * @throws EmptyQueueException if the pending queue is empty.
     */
    public Process executeNextProcess() throws EmptyQueueException {
        Process nextProcess = pendingProcesses.poll(); // poll returns null if empty

        if (nextProcess == null) {
            throw new EmptyQueueException("No processes in the pending queue to execute.");
        }

        completedProcesses.add(nextProcess);
        return nextProcess;
    }

    /**
     * Gets a list of processes currently in the pending queue.
     * Returns a new ArrayList to prevent external modification of the internal queue.
     * @return A List of pending processes.
     */
    public List<Process> getPendingProcesses() {
        return new ArrayList<>(pendingProcesses); // Return a copy
    }

    /**
     * Gets a list of processes that have been completed.
     * Returns a new ArrayList to prevent external modification of the internal list.
     * @return A List of completed processes.
     */
    public List<Process> getCompletedProcesses() {
        return new ArrayList<>(completedProcesses); // Return a copy
    }

    /**
     * Checks if the pending queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return pendingProcesses.isEmpty();
    }
}

/**
 * Main application class for the Simple Process Scheduler.
 * Provides a command-line interface for interacting with the scheduler.
 */
public class SchedulerApp {

    private static final Scanner scanner = new Scanner(System.in);
    private static final ProcessScheduler scheduler = new ProcessScheduler();

    public static void main(String[] args) {
        System.out.println("--- Simple Process Scheduler ---");

        // Class-wide exception handling for the main application loop
        try {
            runScheduler();
        } catch (Exception e) {
            // Catch any unhandled exceptions that escape the runScheduler loop
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed regardless of how the application exits
            scanner.close();
            System.out.println("Scheduler application terminated.");
        }
    }

    /**
     * Runs the main scheduler interaction loop.
     * Handles user input, menu display, and delegates operations to the scheduler.
     */
    private static void runScheduler() {
        int choice;
        while (true) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                // Read the entire line to avoid issues with nextInt() and newlines
                String input = scanner.nextLine();
                choice = Integer.parseInt(input); // Attempt to parse the input as an integer

                // Use a try-catch block around the switch for operation-specific exceptions
                try {
                    switch (choice) {
                        case 1:
                            addProcess();
                            break;
                        case 2:
                            executeNextProcess();
                            break;
                        case 3:
                            listPendingProcesses();
                            break;
                        case 4:
                            listCompletedProcesses();
                            break;
                        case 5:
                            System.out.println("Exiting scheduler.");
                            return; // Exit the runScheduler method
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (EmptyQueueException e) {
                    // Catch specific exceptions thrown by scheduler operations
                    System.err.println("Operation failed: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions from scheduler methods
                    System.err.println("An error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }

            } catch (NumberFormatException e) {
                // Handle cases where the user input for the choice is not a valid integer
                System.err.println("Invalid input. Please enter a number for your choice.");
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the input reading/parsing phase
                 System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a newline for better readability between operations
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nScheduler Menu:");
        System.out.println("1. Add New Process");
        System.out.println("2. Execute Next Process");
        System.out.println("3. List Pending Processes");
        System.out.println("4. List Completed Processes");
        System.out.println("5. Exit");
    }

    /**
     * Handles user input for adding a new process and delegates to the scheduler.
     * Includes input validation.
     */
    private static void addProcess() {
        System.out.println("\n--- Add New Process ---");
        try {
            System.out.print("Enter Process ID (integer > 0): ");
            String idInput = scanner.nextLine();
            int id = Integer.parseInt(idInput); // May throw NumberFormatException

            if (id <= 0) {
                System.err.println("Error: Process ID must be a positive integer.");
                return; // Stop processing this add request
            }

            System.out.print("Enter Process Name: ");
            String name = scanner.nextLine();
            if (name == null || name.trim().isEmpty()) {
                 System.err.println("Error: Process Name cannot be empty.");
                 return; // Stop processing this add request
            }

            System.out.print("Enter Process Priority (HIGH, MEDIUM, LOW): ");
            String priority = scanner.nextLine().toUpperCase(); // Convert to uppercase for case-insensitivity

            // Basic priority validation
            if (!priority.equals("HIGH") && !priority.equals("MEDIUM") && !priority.equals("LOW")) {
                System.err.println("Error: Invalid priority. Must be HIGH, MEDIUM, or LOW.");
                return; // Stop processing this add request
            }

            Process newProcess = new Process(id, name, priority);
            scheduler.addProcess(newProcess);
            System.out.println("Process added successfully: " + newProcess);

        } catch (NumberFormatException e) {
            // Catch if Integer.parseInt fails for the ID input
            System.err.println("Invalid input for Process ID. Please enter an integer.");
        } catch (Exception e) {
             // Catch any other unexpected errors during the add process flow
             System.err.println("An unexpected error occurred while adding process: " + e.getMessage());
             // e.printStackTrace(); // Uncomment for debugging
        }
    }

    /**
     * Handles executing the next process in the queue and delegates to the scheduler.
     * Expected to throw EmptyQueueException if the queue is empty.
     */
    private static void executeNextProcess() throws EmptyQueueException {
        System.out.println("\n--- Execute Next Process ---");
        // Call scheduler method. EmptyQueueException is expected and handled in runScheduler's try-catch.
        Process executed = scheduler.executeNextProcess();
        System.out.println("Executed Process: " + executed);
    }

    /**
     * Retrieves and lists all processes currently waiting in the pending queue.
     */
    private static void listPendingProcesses() {
        System.out.println("\n--- Pending Processes ---");
        List<Process> pending = scheduler.getPendingProcesses(); // Get a copy
        if (pending.isEmpty()) {
            System.out.println("No processes are currently pending.");
        } else {
            // Iterate and print each process using its toString() method
            pending.forEach(System.out::println);
        }
    }

    /**
     * Retrieves and lists all processes that have been completed.
     */
    private static void listCompletedProcesses() {
        System.out.println("\n--- Completed Processes ---");
        List<Process> completed = scheduler.getCompletedProcesses(); // Get a copy
        if (completed.isEmpty()) {
            System.out.println("No processes have been completed yet.");
        } else {
            // Iterate and print each completed process
            completed.forEach(System.out::println);
        }
    }
}
