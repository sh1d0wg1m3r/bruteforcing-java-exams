/*
 * Exam Question #1149
 * Generated on: 2025-05-12 17:31:35
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Task Management System Implementation**
 * 
 * **Scenario:**
 * You are tasked with developing a simple console-based task management system for a small team. The system should allow users to add new tasks, mark the next pending task as complete, view pending tasks, and view completed tasks. This system simulates a basic workflow where tasks are processed in the order they are received.
 * 
 * **Requirements:**
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with a `description` (String) and an auto-generated unique integer `id`. The constructor must validate that the description is not null or empty.
 * 2.  **Task Management Logic:** Create a `TaskManager` class to manage tasks.
 *     *   Use a `java.util.Queue<Task>` to store pending tasks. Tasks should be processed in a FIFO (First-In, First-Out) manner. Use a concrete implementation like `java.util.LinkedList`.
 *     *   Use a `java.util.List<Task>` (specifically, a `java.util.ArrayList`) to store completed tasks.
 *     *   Implement methods within `TaskManager` for:
 *         *   Adding a new `Task` to the pending queue based on user input for the description. Handle the case where the description is invalid (empty).
 *         *   Completing the next task: remove the task from the front of the pending queue and add it to the completed list. If the pending queue is empty, report an error.
 *         *   Viewing all tasks currently in the pending queue without removing them.
 *         *   Viewing all tasks in the completed list.
 * 3.  **User Interface:**
 *     *   Provide a console-based menu using `java.util.Scanner` for user input.
 *     *   The menu should offer options for: 1. Add New Task, 2. Complete Next Task, 3. View Pending Tasks, 4. View Completed Tasks, 5. Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display normal output (menu, task lists, success messages) using `System.out`.
 *     *   Display error messages (e.g., invalid input, attempting to complete a task when none are pending, invalid task description) using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Include a class-wide `try-catch` block (e.g., surrounding the main menu loop logic) to catch potential exceptions like `java.util.InputMismatchException` for non-integer menu input or other unexpected runtime errors.
 *     *   Handle specific error conditions gracefully:
 *         *   Attempting to complete a task when the pending queue is empty.
 *         *   Attempting to create a task with an invalid description.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) in both `Task` and `TaskManager`.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain the code.
 *     *   Validate user input where necessary (e.g., menu choice range, task description).
 *     *   Ensure a clean code structure (separate classes for `Task` and `TaskManager` logic).
 *     *   Ensure the `Scanner` resource is properly closed when the application exits.
 * 
 * **Expected Output:**
 * The program should display the menu, prompt the user for input, and display relevant information or error messages based on the user's interactions, similar to the example flow below:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: Task [ID=1, Description='Write exam question']
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Grade exams
 * Task added: Task [ID=2, Description='Grade exams']
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Description='Write exam question']
 * Task [ID=2, Description='Grade exams']
 * ---------------------
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: Task [ID=1, Description='Write exam question']
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task [ID=2, Description='Grade exams']
 * ---------------------
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task [ID=1, Description='Write exam question']
 * -----------------------
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: Task [ID=2, Description='Grade exams']
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * No pending tasks to complete.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: 
 * Error adding task: Task description cannot be empty.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a console-based Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   A simple class representing a task with an auto-generated `id` and a `description`.
 *     *   The constructor includes input validation, throwing an `IllegalArgumentException` if the description is invalid. This demonstrates basic object-level validation.
 *     *   Includes a `toString()` method for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the core class holding the application logic and data structures.
 *     *   **`Queue<Task> pendingTasks = new LinkedList<>();`**: A `java.util.Queue` is used to store tasks that need to be done. `LinkedList` is a common implementation of `Queue` that supports FIFO operations efficiently. New tasks are added to the rear, and tasks are removed from the front.
 *     *   **`List<Task> completedTasks = new ArrayList<>();`**: A `java.util.List` is used to store tasks that have been finished. `ArrayList` is a flexible implementation for storing elements in a sequence and is suitable here for keeping a history of completed tasks.
 *     *   **`Scanner scanner = new Scanner(System.in);`**: An instance of `java.util.Scanner` is used to read input from the console (`System.in`). It's initialized once in the constructor and closed when the application exits.
 *     *   **Encapsulation:** Both `pendingTasks`, `completedTasks`, and `scanner` fields are `private`, and interactions are managed through public/private methods (`addTask`, `completeNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `run`).
 *     *   **`addTask()`:** Reads a task description from the user, creates a `Task` object, and adds it to the `pendingTasks` queue using `offer()`. It includes a `try-catch` block to specifically handle the `IllegalArgumentException` thrown by the `Task` constructor if the description is invalid, printing the error to `System.err`.
 *     *   **`completeNextTask()`:** Checks if `pendingTasks` is empty. If not, it removes the head of the queue using `poll()` (which returns `null` if empty, though the `isEmpty()` check prevents this) and adds the removed task to the `completedTasks` list. Error messages for an empty queue are printed to `System.err`.
 *     *   **`viewPendingTasks()` / `viewCompletedTasks()`:** These methods iterate through the respective collections (`Queue` and `List`) and print the tasks using `System.out`. They check if the collections are empty and print appropriate messages.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   **`run()` Method:** Contains the main application loop (`while(running)`).
 *     *   **`displayMenu()`:** Called at the beginning of each loop iteration.
 *     *   **`Scanner` Input:** Reads the user's choice using `scanner.nextInt()`. `scanner.nextLine()` is immediately called after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls (like in `addTask`).
 *     *   **`switch` Statement:** The user's integer `choice` is used in a `switch` statement to direct the program flow to the appropriate method (`addTask`, `completeNextTask`, etc.) or exit the application.
 *     *   **`System.out` / `System.err`:** Used as required, `System.out` for menus, task lists, and success messages, and `System.err` for error messages.
 * 
 * 4.  **Error Handling (`try-catch`):**
 *     *   **Class-wide `try-catch`:** The `run()` method includes a `try-catch` block that wraps the input reading (`scanner.nextInt()`) and the `switch` statement.
 *         *   It specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to recover.
 *         *   It includes a general `catch (Exception e)` block to catch any other unexpected runtime exceptions that might propagate up from the called methods. This provides a safety net for unforeseen issues.
 *     *   **Specific Error Handling:**
 *         *   `addTask()` catches `IllegalArgumentException` from the `Task` constructor.
 *         *   `completeNextTask()` checks `pendingTasks.isEmpty()` before attempting to process, preventing potential `NoSuchElementException` if `remove()` were used on an empty queue (though `poll()` gracefully returns null).
 *     *   Error messages are directed to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names (`pendingTasks`, `completeNextTask`, `InputMismatchException`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation is performed for task descriptions and menu choices.
 *     *   The code is structured into logical classes (`Task`, `TaskManager`).
 *     *   The `Scanner` resource is explicitly closed using `scanner.close()` before the program terminates, preventing resource leaks.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating proper data structure usage, control flow, error handling, and adherence to best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Objects; // For potential use in equals/hashCode if needed, though not strictly required by prompt

/**
 * Represents a single task in the system.
 */
class Task {
    private static int nextId = 1;
    private int id;
    private String description;

    /**
     * Constructs a new Task with a description.
     * Assigns a unique ID automatically.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = nextId++;
        this.description = description.trim();
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including ID and description.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "']";
    }

    // Optional: Implement equals and hashCode if tasks need to be compared or put in sets/maps
    // based on their unique ID. Not strictly necessary for this problem's core logic (queue/list iteration).
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id; // Assuming ID is the unique identifier
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

/**
 * Manages a collection of pending and completed tasks.
 * Uses a Queue for pending tasks (FIFO) and a List for completed tasks.
 */
public class TaskManager {
    // Queue to hold tasks that are pending (waiting to be completed)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input from the console
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // Initialize pendingTasks using LinkedList which implements Queue
        this.pendingTasks = new LinkedList<>();
        // Initialize completedTasks using ArrayList which implements List
        this.completedTasks = new ArrayList<>();
        // Initialize Scanner to read from standard input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue based on user input.
     * Handles input validation for the task description.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Read the entire line of input for the description
        String description = scanner.nextLine();
        try {
            // Attempt to create a new Task object
            Task newTask = new Task(description);
            // Add the new task to the end of the pending queue
            pendingTasks.offer(newTask); // offer() is suitable for queues
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            // Catch the specific exception thrown by Task constructor for invalid description
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Completes the next task in the pending queue.
     * Removes the task from the front of the queue and adds it to the completed list.
     * Reports an error if the pending queue is empty.
     */
    private void completeNextTask() {
        // Check if the pending queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to complete.");
            return; // Exit the method if no tasks are pending
        }

        // Remove and retrieve the task from the front of the queue (FIFO)
        Task completedTask = pendingTasks.poll();
        if (completedTask != null) {
            // Add the completed task to the completed tasks list
            completedTasks.add(completedTask);
            System.out.println("Completed task: " + completedTask);
        } else {
            // This case should ideally not be reached if isEmpty() is checked,
            // but included as a safeguard. poll() returns null if empty.
            System.err.println("An unexpected issue occurred while retrieving the task.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates through the queue without removing elements.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue using forEach or an Iterator
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and menu navigation.
     * Includes class-wide exception handling for input and general errors.
     */
    public void run() {
        boolean running = true;
        // Main application loop
        while (running) {
            displayMenu();
            // Class-wide try-catch block for handling potential errors during input or processing
            try {
                // Read user's menu choice (integer)
                int choice = scanner.nextInt();
                // Consume the newline character left over after nextInt()
                scanner.nextLine();

                // Use a switch statement to perform actions based on user choice
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        completeNextTask(); // Call method to complete next task
                        break;
                    case 3:
                        viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development/testing
                // e.printStackTrace(System.err);
            }
        }
        // Close the scanner resource when the application loop finishes
        scanner.close();
    }

    /**
     * Main method to start the Task Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of TaskManager and run the application
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
