/*
 * Exam Question #644
 * Generated on: 2025-05-12 16:19:10
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Production Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based simulation for a manufacturing production line. The line processes "Work Orders" which specify a type of product and a quantity to produce. Work orders arrive and are placed in a queue. The production line processes one work order at a time from the front of the queue. Once a work order is processed, the resulting "Finished Items" are stored in a collection.
 * 
 * Your program should allow a user to interact with the simulation via commands entered through the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage incoming `WorkOrder` objects waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store `FinishedItem` objects that have been successfully produced.
 *     *   When providing access to the finished items collection (e.g., for viewing), use the `java.util.List` interface type.
 * 2.  **Classes:**
 *     *   Create a `WorkOrder` class with private fields for `productType` (String) and `quantity` (int). Include a constructor and public getter methods. Ensure objects are effectively immutable after creation.
 *     *   Create a `FinishedItem` class with private fields for `productType` (String) and `quantity` (int - representing the quantity produced from one work order). Include a constructor and public getter methods.
 *     *   Create a `ProductionLineSimulator` class that contains the `main` method and manages the queue and list. This class should have methods for the simulation's operations.
 * 3.  **Functionality:**
 *     *   **Add Work Order:** Prompt the user for a product type (String) and quantity (integer). Validate that the quantity is positive. Create a `WorkOrder` object and add it to the queue.
 *     *   **Process Next Order:** Take the next `WorkOrder` from the front of the queue. If the queue is empty, report an error. If successful, simulate processing (e.g., print a message) and create a `FinishedItem` object representing the output of this order. Add the `FinishedItem` to the list of finished items.
 *     *   **View Status:** Display the current number of work orders in the queue and the total number of finished items produced so far (sum of quantities in the finished items list).
 *     *   **View Finished Items:** List all finished items, showing the product type and quantity for each processed order.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands and input.
 *     *   Implement a command loop that continues until the user chooses to exit.
 *     *   Use a `switch` statement to handle different user commands (e.g., 'add', 'process', 'status', 'view', 'exit').
 *     *   Provide clear prompts for user input.
 * 5.  **Error Handling:**
 *     *   Use `System.err.println()` to report errors (e.g., invalid input, processing an empty queue).
 *     *   Implement exception handling (`try-catch`) for potential issues like non-integer input for quantity or attempting to process from an empty queue (handle the `null` return from `poll()` gracefully). Place `try-catch` blocks around the core logic processing user commands or input.
 *     *   Validate user input (e.g., positive quantity).
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for classes/methods, inline comments for complex logic).
 *     *   Ensure clean code structure.
 * 
 * **Commands:**
 * 
 * *   `add` - Add a new work order.
 * *   `process` - Process the next work order in the queue.
 * *   `status` - View current queue and finished items status.
 * *   `view` - View the list of all finished items.
 * *   `exit` - Exit the simulation.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Production Line Simulator
 * Enter command (add, process, status, view, exit): add
 * Enter product type: Widget
 * Enter quantity: 100
 * Work order added: Widget (100)
 * 
 * Enter command (add, process, status, view, exit): add
 * Enter product type: Gadget
 * Enter quantity: -5
 * Error: Quantity must be positive.
 * 
 * Enter command (add, process, status, view, exit): status
 * Queue size: 1
 * Total finished items: 0
 * 
 * Enter command (add, process, status, view, exit): process
 * Processing work order: Widget (100)
 * Finished items produced: Widget (100)
 * 
 * Enter command (add, process, status, view, exit): status
 * Queue size: 0
 * Total finished items: 100
 * 
 * Enter command (add, process, status, view, exit): process
 * Error: Production line queue is empty.
 * 
 * Enter command (add, process, status, view, exit): view
 * --- Finished Items ---
 * Type: Widget, Quantity: 100
 * ----------------------
 * 
 * Enter command (add, process, status, view, exit): exit
 * Exiting simulator.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`.
 * *   Proper implementation of `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective use of `try-catch` for error handling and input validation.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Code readability, naming conventions, and commenting.
 * *   Correct implementation of all required functionalities and commands.
 * 
 * **Note:** Focus on demonstrating the required Java concepts in a functional simulation. Error handling should be robust enough to prevent crashes from expected user input issues (like non-numeric input for quantity or invalid commands).
 *
 * EXPLANATION:
 * This solution implements a console-based production line simulator demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `WorkOrder` and `FinishedItem` classes are simple Plain Old Java Objects (POJOs) with private fields and public getters, demonstrating encapsulation. They represent the core data entities.
 *     *   `ProductionLineSimulator` is the main class orchestrating the simulation logic. It holds instances of the `Queue` and `List` and contains the methods for interacting with them.
 * 
 * 2.  **Data Structures:**
 *     *   `Queue<WorkOrder> workOrderQueue`: A `LinkedList` is used as a concrete implementation of the `Queue` interface. This structure correctly models a waiting line where work orders are added to the end (`offer`) and processed from the front (`poll`).
 *     *   `List<FinishedItem> finishedItems`: An `ArrayList` is used to store `FinishedItem` objects. It allows dynamic resizing and easy iteration. The `getFinishedItems()` method returns this collection using the `List` interface type, adhering to the requirement and promoting good practice (coding to interfaces).
 * 
 * 3.  **User Interaction (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   `Scanner` is used to read user input from `System.in`. A `try-with-resources` block ensures the `Scanner` is properly closed.
 *     *   A `while` loop keeps the simulation running.
 *     *   A `switch` statement dispatches control based on the user's command string.
 *     *   `System.out.println` is used for prompts, status updates, and successful operations.
 *     *   `System.err.println` is used specifically for displaying error messages, as required.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `addWorkOrder`: Takes a `WorkOrder` object and adds it to the `workOrderQueue` using `offer()`.
 *     *   `processNextOrder`: Uses `poll()` to retrieve and remove the head of the queue. It checks if the result is `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it creates a `FinishedItem` and adds it to the `finishedItems` list.
 *     *   `getStatus`: Iterates through the `finishedItems` list to calculate the total quantity and reports the queue size and total finished quantity.
 *     *   `viewFinishedItems`: Iterates through the `finishedItems` list (accessed via the `List` interface) and prints each item's details.
 * 
 * 5.  **Error Handling (`try-catch`, Input Validation):**
 *     *   **Input Validation:** The `WorkOrder` constructor throws an `IllegalArgumentException` if the quantity is not positive. The `add` command catches this to print an error. The `add` command also includes a `try-catch (InputMismatchException)` specifically for handling non-integer input when reading the quantity from the `Scanner`, preventing a crash and prompting the user.
 *     *   **Processing Empty Queue:** The `processNextOrder` method explicitly checks if `workOrderQueue.poll()` returns `null` and prints an error to `System.err`.
 *     *   **Class-wide Exception Handling:** A `try-catch (Exception e)` block is placed around the core logic within the main command processing loop (`while (running)`). This demonstrates catching unexpected errors that might occur during command execution, printing an error message to `System.err` and preventing the program from crashing entirely. While specific error handling is done for input and empty queue, this outer block serves as a general safety net.
 * 
 * 6.  **Best Practices:**
 *     *   Fields are `private` and accessed via public getters (`WorkOrder`, `FinishedItem`).
 *     *   Method and variable names (`workOrderQueue`, `processNextOrder`, `productType`) are descriptive.
 *     *   Basic Javadoc comments are provided for classes and methods.
 *     *   The code is structured logically within the `ProductionLineSimulator` class.
 *     *   Using `LinkedList` for `Queue` and `ArrayList` for `List` are standard practices. Returning `List` interface in `getFinishedItems` promotes flexibility.
 * 
 * This solution effectively combines the required Java components to simulate a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a work order for the production line.
 */
class WorkOrder {
    private final String productType;
    private final int quantity;

    /**
     * Constructs a new WorkOrder.
     * @param productType The type of product to produce.
     * @param quantity The quantity to produce.
     */
    public WorkOrder(String productType, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.productType = productType;
        this.quantity = quantity;
    }

    public String getProductType() {
        return productType;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return productType + " (" + quantity + ")";
    }
}

/**
 * Represents items finished from a single work order.
 */
class FinishedItem {
    private final String productType;
    private final int quantity;

    /**
     * Constructs a new FinishedItem entry.
     * @param productType The type of product finished.
     * @param quantity The quantity finished from one order.
     */
    public FinishedItem(String productType, int quantity) {
        this.productType = productType;
        this.quantity = quantity;
    }

    public String getProductType() {
        return productType;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Type: " + productType + ", Quantity: " + quantity;
    }
}

/**
 * Simulates a production line managing work orders and finished items.
 */
public class ProductionLineSimulator {

    private Queue<WorkOrder> workOrderQueue;
    private List<FinishedItem> finishedItems; // Using List interface

    /**
     * Constructs a new ProductionLineSimulator.
     */
    public ProductionLineSimulator() {
        // LinkedList is a common implementation for Queue
        this.workOrderQueue = new LinkedList<>();
        this.finishedItems = new ArrayList<>();
    }

    /**
     * Adds a new work order to the queue.
     * @param order The WorkOrder to add.
     */
    public void addWorkOrder(WorkOrder order) {
        workOrderQueue.offer(order); // offer is preferred over add for capacity-constrained queues, but works fine here
        System.out.println("Work order added: " + order);
    }

    /**
     * Processes the next work order in the queue.
     * @return true if an order was processed, false if the queue was empty.
     */
    public boolean processNextOrder() {
        WorkOrder nextOrder = workOrderQueue.poll(); // poll returns null if queue is empty

        if (nextOrder == null) {
            System.err.println("Error: Production line queue is empty.");
            return false;
        }

        System.out.println("Processing work order: " + nextOrder);

        // Simulate production...
        FinishedItem finishedItem = new FinishedItem(nextOrder.getProductType(), nextOrder.getQuantity());
        finishedItems.add(finishedItem);

        System.out.println("Finished items produced: " + finishedItem);
        return true;
    }

    /**
     * Gets the current status of the production line.
     * @return A string describing the status.
     */
    public String getStatus() {
        int totalFinishedQuantity = 0;
        for (FinishedItem item : finishedItems) {
            totalFinishedQuantity += item.getQuantity();
        }
        return "Queue size: " + workOrderQueue.size() + "\nTotal finished items quantity: " + totalFinishedQuantity;
    }

    /**
     * Gets an unmodifiable list of finished items.
     * Using List interface as return type.
     * @return A List of FinishedItem objects.
     */
    public List<FinishedItem> getFinishedItems() {
        // Return a copy or unmodifiable list to prevent external modification
        // For this simulation, returning the list directly is acceptable for simplicity,
        // but returning Collections.unmodifiableList(finishedItems) is better practice.
        return finishedItems;
    }

    /**
     * Main method to run the production line simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            System.out.println("Production Line Simulator");
            boolean running = true;

            while (running) {
                System.out.print("Enter command (add, process, status, view, exit): ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Class-wide exception handling around command processing
                try {
                    switch (command) {
                        case "add":
                            System.out.print("Enter product type: ");
                            String type = scanner.nextLine();
                            System.out.print("Enter quantity: ");
                            int quantity = -1; // Initialize with invalid value
                            try {
                                quantity = scanner.nextInt();
                                // Consume the newline character left by nextInt()
                                scanner.nextLine();
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid quantity input. Please enter an integer.");
                                // Consume the invalid input to prevent infinite loop
                                scanner.nextLine();
                                continue; // Skip to next loop iteration
                            }

                            try {
                                WorkOrder newOrder = new WorkOrder(type, quantity);
                                simulator.addWorkOrder(newOrder);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case "process":
                            simulator.processNextOrder();
                            break;

                        case "status":
                            System.out.println(simulator.getStatus());
                            break;

                        case "view":
                            List<FinishedItem> items = simulator.getFinishedItems(); // Using List interface
                            System.out.println("--- Finished Items ---");
                            if (items.isEmpty()) {
                                System.out.println("No items finished yet.");
                            } else {
                                for (FinishedItem item : items) {
                                    System.out.println(item);
                                }
                            }
                            System.out.println("----------------------");
                            break;

                        case "exit":
                            System.out.println("Exiting simulator.");
                            running = false;
                            break;

                        default:
                            System.err.println("Error: Unknown command. Please use add, process, status, view, or exit.");
                            break;
                    }
                } catch (Exception e) {
                    // Catch any unexpected exceptions during command execution
                    System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging unexpected errors
                }
                System.out.println(); // Add a newline for better readability between commands
            }
        } // Scanner is automatically closed here by try-with-resources
    }
}
