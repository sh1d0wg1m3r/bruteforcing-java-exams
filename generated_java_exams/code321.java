/*
 * Exam Question #321
 * Generated on: 2025-05-11 22:54:42
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduling System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Scheduling System. The system needs to manage patients, doctors, and appointments, including a waiting list for patients who cannot be scheduled immediately.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides a command-line interface for the following functionalities:
 * 
 * 1.  **Add New Doctor:** Record a doctor's ID, name, and specialization.
 * 2.  **Add New Patient:** Record a patient's ID and name.
 * 3.  **Schedule Appointment:** Attempt to schedule an appointment for a patient with a specific doctor at a given date/time (represented as a simple string for this exercise, e.g., "2023-10-27 10:00").
 *     *   If the patient or doctor ID is not found, report an error.
 *     *   If the doctor is already booked at that *exact* date/time string, the appointment cannot be scheduled immediately. The patient should be added to a waiting list. Report whether the appointment was scheduled or the patient was added to the waiting list.
 * 4.  **View All Appointments:** Display a list of all scheduled appointments, showing patient name, doctor name, specialization, and date/time.
 * 5.  **View Waiting List:** Display the list of patients currently in the waiting list queue.
 * 6.  **Process Waiting List:** Take the patient at the front of the waiting list queue. Prompt the user to attempt to schedule an appointment for this patient by entering a doctor ID and date/time.
 *     *   If the scheduling attempt is successful, remove the patient from the waiting list.
 *     *   If the scheduling attempt fails (doctor/patient not found or conflict), report the error and *do not* remove the patient from the waiting list (they remain at the front).
 * 7.  **Exit:** Terminate the program.
 * 
 * **Technical Constraints & Required Components:**
 * 
 * Your solution *must* utilize the following Java components:
 * 
 * *   `java.util.Queue`: Specifically, use a `Queue` implementation (like `LinkedList`) to manage the waiting list.
 * *   `java.util.ArrayList`: Use `ArrayList` as the concrete implementation for storing lists of doctors, patients, and appointments.
 * *   `java.util.List`: Declare variables/fields holding collections of doctors, patients, and appointments using the `List` interface type.
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the main menu options.
 * *   `System.err`: For displaying error messages (e.g., invalid input, item not found, scheduling conflict).
 * *   `System.out`: For displaying menus, prompts, successful operation messages, and lists.
 * *   Class-wide exception handling: Implement `try-catch` blocks to handle potential runtime errors, particularly around user input parsing or unexpected issues. A main `try-catch` wrapping the core application loop is acceptable for catching general exceptions.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Use private fields and public getter/setter methods for your entity classes (`Patient`, `Doctor`, `Appointment`).
 * *   **Meaningful Names:** Use descriptive names for classes, variables, and methods.
 * *   **Comments & Documentation:** Include comments explaining complex logic or class/method purposes.
 * *   **Input Validation:** Validate user input where necessary (e.g., check for empty strings for IDs/names, handle non-numeric input if applicable).
 * *   **Proper Error Handling:** Use `System.err` for errors and handle logical failures gracefully.
 * *   **Clean Code Structure:** Organize your code into appropriate classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user and perform the requested actions, printing results or errors to the console using `System.out` and `System.err` respectively.
 * 
 * ```
 * --- Hospital Scheduling System ---
 * 1. Add Doctor
 * 2. Add Patient
 * 3. Schedule Appointment
 * 4. View All Appointments
 * 5. View Waiting List
 * 6. Process Waiting List
 * 7. Exit
 * Enter your choice:
 * ```
 * 
 * (Subsequent prompts and outputs will depend on user interaction).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling, structure).
 * *   Handling of edge cases (e.g., scheduling with non-existent IDs, trying to process an empty waiting list).
 * 
 * **Note:** You do not need to implement complex date/time comparisons beyond exact string matching for scheduling conflicts. Persistence (saving data to file/database) is not required; data can be stored in memory.
 *
 * EXPLANATION:
 * The provided solution implements the requested Hospital Appointment Scheduling System, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Structure:**
 * 
 * The code is organized into four classes:
 * 1.  `Doctor`, `Patient`, and `Appointment`: These are simple Plain Old Java Objects (POJOs) representing the core entities. They use private fields and public getters, fulfilling the encapsulation requirement. Constructors include basic validation for non-empty required fields, throwing `IllegalArgumentException`.
 * 2.  `AppointmentScheduler`: This class acts as the central manager. It holds the collections (`List`s and `Queue`) and contains the business logic for adding, scheduling, viewing, and processing.
 * 3.  `HospitalSchedulerApp`: This class contains the `main` method, which sets up the application, runs the main menu loop, handles user interaction via `Scanner`, and includes the required `try-catch` block.
 * 
 * **Required Components Usage:**
 * 
 * *   **`java.util.Queue`**: The `waitingList` field in `AppointmentScheduler` is declared as a `Queue<Patient>` and initialized with a `LinkedList` implementation (`new LinkedList<>()`). The `scheduleAppointment` method uses `waitingList.offer(patient)` to add a patient when a doctor is busy. The `processWaitingList` method uses `waitingList.peek()` to view the patient at the front without removing them and `waitingList.poll()` to remove the patient after a successful scheduling attempt.
 * *   **`java.util.ArrayList`**: The `doctors`, `patients`, and `appointments` fields in `AppointmentScheduler` are declared as `List<...>` and initialized using `new ArrayList<>()`. `ArrayList` is used as the concrete implementation for these lists, fulfilling the requirement.
 * *   **`java.util.List`**: The fields `doctors`, `patients`, and `appointments` in `AppointmentScheduler` are explicitly declared using the `List` interface type (`private List<Doctor> doctors;`, etc.), demonstrating programming to the interface.
 * *   **`java.util.Scanner`**: A `Scanner` object is created in `HospitalSchedulerApp`'s `main` method and used throughout the application's static methods (`addDoctor`, `addPatient`, etc.) to read user input from `System.in`.
 * *   **`switch` statement**: The `runMenu` method in `HospitalSchedulerApp` uses a `switch` statement based on the user's integer choice to direct execution to the appropriate handler method.
 * *   **`System.err`**: `System.err.println()` is used in various places to report errors: invalid menu choices, input validation failures (e.g., empty strings, non-numeric input), entity not found errors during scheduling/processing, and logical errors like trying to add a duplicate ID or a doctor being busy. It is also used in the main `catch` block.
 * *   **`System.out`**: `System.out.println()` is used for all normal output: printing the menu, prompts for input, confirmation messages for successful operations, and displaying lists of doctors, patients, appointments, and the waiting list.
 * *   **`try-catch` blocks**:
 *     *   A main `try-catch(Exception e)` block wraps the `runMenu()` call in the `main` method. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur within the main application loop and printing an error message and stack trace to `System.err`.
 *     *   Specific `try-catch(IllegalArgumentException e)` blocks are used around the creation of `Doctor` and `Patient` objects in `addDoctor` and `addPatient` methods to catch validation errors from the constructors.
 *     *   Input validation for the menu choice (`scanner.hasNextInt()`) is done *before* attempting to read the integer, preventing `InputMismatchException` and handling it gracefully using `System.err`.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Achieved through private fields and public getters in the entity classes. The `AppointmentScheduler` manages its internal collections directly.
 * *   **Meaningful Names:** Classes (`Doctor`, `Patient`, `Appointment`, `AppointmentScheduler`, `HospitalSchedulerApp`), variables (`patientId`, `doctorId`, `waitingList`), and methods (`addDoctor`, `scheduleAppointment`, `processWaitingList`) have descriptive names.
 * *   **Comments & Documentation:** Javadoc-style comments are used for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 * *   **Input Validation:** Basic validation is performed for non-empty strings when adding entities or scheduling. The menu input specifically checks for integer validity. `IllegalArgumentException` is used for constructor validation.
 * *   **Proper Error Handling:** Logical errors (not found, busy, duplicate ID) are checked and reported using `System.err` with informative messages. Runtime exceptions are caught by the `try-catch` blocks.
 * *   **Clean Code Structure:** The code is divided into logical units (entity classes, scheduler logic, main application loop) within separate classes and methods.
 * 
 * **Functionality Details:**
 * 
 * *   Adding Doctors/Patients: Simple creation and addition to `ArrayList`s. Checks for duplicate IDs.
 * *   Scheduling: Finds entities by ID. Checks for exact string match for doctor availability. If busy, the patient is added to the `waitingList` `Queue`.
 * *   Viewing: Iterates through the respective `List` or `Queue` and prints details.
 * *   Processing Waiting List: Uses `waitingList.peek()` to inspect the first patient. Prompts for new scheduling details. Calls `scheduler.processWaitingList()`. Based on the return code, it reports success (and the scheduler removes the patient via `poll()`) or failure (and the patient remains at the front).
 * 
 * This solution effectively combines the required Java components to build a functional, albeit simplified, real-world system, demonstrating key programming concepts and best practices suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal while iterating if processing waiting list differently

// --- Entity Classes ---

/**
 * Represents a Doctor in the system.
 */
class Doctor {
    private String id;
    private String name;
    private String specialization;

    public Doctor(String id, String name, String specialization) {
        if (id == null || id.trim().isEmpty() || name == null || name.trim().isEmpty() || specialization == null || specialization.trim().isEmpty()) {
            throw new IllegalArgumentException("Doctor ID, name, and specialization cannot be empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
        this.specialization = specialization.trim();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSpecialization() {
        return specialization;
    }

    @Override
    public String toString() {
        return "Doctor [ID=" + id + ", Name=" + name + ", Specialization=" + specialization + "]";
    }
}

/**
 * Represents a Patient in the system.
 */
class Patient {
    private String id;
    private String name;

    public Patient(String id, String name) {
        if (id == null || id.trim().isEmpty() || name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient ID and name cannot be empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

/**
 * Represents a scheduled Appointment.
 */
class Appointment {
    private Patient patient;
    private Doctor doctor;
    private String dateTime; // Simple string representation

    public Appointment(Patient patient, Doctor doctor, String dateTime) {
        if (patient == null || doctor == null || dateTime == null || dateTime.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient, doctor, and dateTime cannot be null or empty.");
        }
        this.patient = patient;
        this.doctor = doctor;
        this.dateTime = dateTime.trim();
    }

    // Getters
    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public String getDateTime() {
        return dateTime;
    }

    @Override
    public String toString() {
        return "Appointment [Patient=" + patient.getName() + ", Doctor=" + doctor.getName() +
               " (" + doctor.getSpecialization() + "), Time=" + dateTime + "]";
    }
}

// --- Scheduler Class ---

/**
 * Manages doctors, patients, appointments, and the waiting list.
 */
class AppointmentScheduler {
    private List<Doctor> doctors;
    private List<Patient> patients;
    private List<Appointment> appointments;
    private Queue<Patient> waitingList;

    public AppointmentScheduler() {
        // Use ArrayList for lists as required
        this.doctors = new ArrayList<>();
        this.patients = new ArrayList<>();
        this.appointments = new ArrayList<>();
        // Use LinkedList as a Queue implementation as required
        this.waitingList = new LinkedList<>();
    }

    /**
     * Adds a new doctor to the system.
     * @param doctor The Doctor object to add.
     * @return true if added successfully, false if ID already exists.
     */
    public boolean addDoctor(Doctor doctor) {
        if (findDoctorById(doctor.getId()) != null) {
            return false; // Doctor with this ID already exists
        }
        doctors.add(doctor);
        return true;
    }

    /**
     * Adds a new patient to the system.
     * @param patient The Patient object to add.
     * @return true if added successfully, false if ID already exists.
     */
    public boolean addPatient(Patient patient) {
        if (findPatientById(patient.getId()) != null) {
            return false; // Patient with this ID already exists
        }
        patients.add(patient);
        return true;
    }

    /**
     * Attempts to schedule an appointment.
     * If successful, adds to appointments. If doctor is busy, adds patient to waiting list.
     * @param patientId The ID of the patient.
     * @param doctorId The ID of the doctor.
     * @param dateTime The desired date and time string.
     * @return 0 for success, 1 for patient not found, 2 for doctor not found, 3 for doctor busy (added to waiting list).
     */
    public int scheduleAppointment(String patientId, String doctorId, String dateTime) {
        Patient patient = findPatientById(patientId);
        Doctor doctor = findDoctorById(doctorId);

        if (patient == null) {
            return 1; // Patient not found
        }
        if (doctor == null) {
            return 2; // Doctor not found
        }

        // Check if doctor is busy at this exact time string
        if (isDoctorBusy(doctorId, dateTime)) {
            // Add patient to waiting list if doctor is busy
            if (!waitingList.contains(patient)) { // Avoid adding the same patient multiple times if they are already waiting
                 waitingList.offer(patient); // offer() is standard Queue method
            }
            return 3; // Doctor busy, added to waiting list
        }

        // Schedule the appointment
        Appointment appointment = new Appointment(patient, doctor, dateTime);
        appointments.add(appointment);
        return 0; // Success
    }

    /**
     * Checks if a doctor is busy at a specific time string.
     * @param doctorId The doctor's ID.
     * @param dateTime The date and time string to check.
     * @return true if the doctor has an appointment at that time, false otherwise.
     */
    private boolean isDoctorBusy(String doctorId, String dateTime) {
        for (Appointment app : appointments) {
            if (app.getDoctor().getId().equals(doctorId) && app.getDateTime().equals(dateTime)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Finds a doctor by their ID.
     * @param id The doctor's ID.
     * @return The Doctor object or null if not found.
     */
    public Doctor findDoctorById(String id) {
        for (Doctor doc : doctors) {
            if (doc.getId().equals(id)) {
                return doc;
            }
        }
        return null;
    }

    /**
     * Finds a patient by their ID.
     * @param id The patient's ID.
     * @return The Patient object or null if not found.
     */
    public Patient findPatientById(String id) {
        for (Patient pat : patients) {
            if (pat.getId().equals(id)) {
                return pat;
            }
        }
        return null;
    }

    /**
     * Gets the list of all scheduled appointments.
     * @return A List of Appointment objects.
     */
    public List<Appointment> getAllAppointments() {
        return new ArrayList<>(appointments); // Return a copy to prevent external modification
    }

    /**
     * Gets the waiting list queue.
     * @return The Queue of Patient objects.
     */
    public Queue<Patient> getWaitingList() {
        return waitingList;
    }

    /**
     * Processes the patient at the front of the waiting list.
     * Attempts to schedule an appointment for them.
     * @param doctorId The ID of the doctor for the new attempt.
     * @param dateTime The new date and time string for the attempt.
     * @return 0 for success (patient scheduled and removed from queue),
     *         1 if waiting list is empty,
     *         2 for doctor not found (patient remains in queue),
     *         3 for doctor busy (patient remains in queue).
     */
    public int processWaitingList(String doctorId, String dateTime) {
        Patient patient = waitingList.peek(); // Look at the front without removing

        if (patient == null) {
            return 1; // Waiting list is empty
        }

        Doctor doctor = findDoctorById(doctorId);
        if (doctor == null) {
            return 2; // Doctor not found
        }

        if (isDoctorBusy(doctorId, dateTime)) {
            return 3; // Doctor busy
        }

        // Schedule the appointment from the waiting list
        Appointment appointment = new Appointment(patient, doctor, dateTime);
        appointments.add(appointment);
        waitingList.poll(); // Successfully scheduled, remove from queue
        return 0; // Success
    }
}

// --- Main Application Class ---

public class HospitalSchedulerApp {

    private static AppointmentScheduler scheduler = new AppointmentScheduler();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Hospital Scheduling System ---");

        // Class-wide exception handling for the main loop
        try {
            runMenu();
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to err
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }

    /**
     * Runs the main menu loop.
     */
    private static void runMenu() {
        int choice = -1;
        while (choice != 7) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                // Input validation: Check if the next input is an integer
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number between 1 and 7.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after the integer

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addDoctor();
                        break;
                    case 2:
                        addPatient();
                        break;
                    case 3:
                        scheduleAppointment();
                        break;
                    case 4:
                        viewAllAppointments();
                        break;
                    case 5:
                        viewWaitingList();
                        break;
                    case 6:
                        processWaitingList();
                        break;
                    case 7:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            } catch (IllegalArgumentException e) {
                // Catch exceptions thrown by entity constructors due to empty input
                System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                 // This catch block inside the loop handles errors specific to one operation,
                 // while the outer catch handles unexpected errors in the loop itself.
                 // For this exam, we rely more on the outer catch as per requirement,
                 // but specific catches here are also good practice.
                 // Let's keep the outer catch as the primary requirement fulfillment.
                 // For this structure, the IllegalArgumentException is the most likely specific one.
                 System.err.println("An error occurred during operation: " + e.getMessage());
                 // e.printStackTrace(System.err); // Optional: for detailed debugging
            }
            System.out.println(); // Add a newline for better readability between operations
        }
    }

    /**
     * Prints the main menu options.
     */
    private static void printMenu() {
        System.out.println("--- Hospital Scheduling System ---");
        System.out.println("1. Add Doctor");
        System.out.println("2. Add Patient");
        System.out.println("3. Schedule Appointment");
        System.out.println("4. View All Appointments");
        System.out.println("5. View Waiting List");
        System.out.println("6. Process Waiting List");
        System.out.println("7. Exit");
    }

    /**
     * Handles adding a new doctor.
     */
    private static void addDoctor() {
        System.out.println("--- Add Doctor ---");
        System.out.print("Enter Doctor ID: ");
        String id = scanner.nextLine().trim();
        System.out.print("Enter Doctor Name: ");
        String name = scanner.nextLine().trim();
        System.out.print("Enter Doctor Specialization: ");
        String specialization = scanner.nextLine().trim();

        // Basic input validation
        if (id.isEmpty() || name.isEmpty() || specialization.isEmpty()) {
            System.err.println("Error: ID, name, and specialization cannot be empty.");
            return;
        }

        try {
            Doctor doctor = new Doctor(id, name, specialization);
            if (scheduler.addDoctor(doctor)) {
                System.out.println("Doctor added successfully: " + doctor);
            } else {
                System.err.println("Error: Doctor with ID " + id + " already exists.");
            }
        } catch (IllegalArgumentException e) {
             // This catch handles the validation inside the Doctor constructor
             System.err.println("Error creating Doctor: " + e.getMessage());
        }
    }

    /**
     * Handles adding a new patient.
     */
    private static void addPatient() {
        System.out.println("--- Add Patient ---");
        System.out.print("Enter Patient ID: ");
        String id = scanner.nextLine().trim();
        System.out.print("Enter Patient Name: ");
        String name = scanner.nextLine().trim();

         // Basic input validation
        if (id.isEmpty() || name.isEmpty()) {
            System.err.println("Error: ID and name cannot be empty.");
            return;
        }

        try {
            Patient patient = new Patient(id, name);
            if (scheduler.addPatient(patient)) {
                System.out.println("Patient added successfully: " + patient);
            } else {
                System.err.println("Error: Patient with ID " + id + " already exists.");
            }
        } catch (IllegalArgumentException e) {
            // This catch handles the validation inside the Patient constructor
            System.err.println("Error creating Patient: " + e.getMessage());
        }
    }

    /**
     * Handles scheduling a new appointment.
     */
    private static void scheduleAppointment() {
        System.out.println("--- Schedule Appointment ---");
        System.out.print("Enter Patient ID: ");
        String patientId = scanner.nextLine().trim();
        System.out.print("Enter Doctor ID: ");
        String doctorId = scanner.nextLine().trim();
        System.out.print("Enter Date and Time (e.g., 2023-10-27 10:00): ");
        String dateTime = scanner.nextLine().trim();

         // Basic input validation
        if (patientId.isEmpty() || doctorId.isEmpty() || dateTime.isEmpty()) {
            System.err.println("Error: Patient ID, Doctor ID, and Date/Time cannot be empty.");
            return;
        }

        int result = scheduler.scheduleAppointment(patientId, doctorId, dateTime);

        switch (result) {
            case 0:
                System.out.println("Appointment scheduled successfully.");
                break;
            case 1:
                System.err.println("Error: Patient with ID " + patientId + " not found.");
                break;
            case 2:
                System.err.println("Error: Doctor with ID " + doctorId + " not found.");
                break;
            case 3:
                System.out.println("Doctor is busy at " + dateTime + ". Patient added to waiting list.");
                break;
            default:
                System.err.println("An unknown error occurred during scheduling.");
        }
    }

    /**
     * Handles viewing all scheduled appointments.
     */
    private static void viewAllAppointments() {
        System.out.println("--- All Scheduled Appointments ---");
        List<Appointment> appointments = scheduler.getAllAppointments();
        if (appointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            for (int i = 0; i < appointments.size(); i++) {
                System.out.println((i + 1) + ". " + appointments.get(i));
            }
        }
    }

    /**
     * Handles viewing the waiting list.
     */
    private static void viewWaitingList() {
        System.out.println("--- Waiting List ---");
        Queue<Patient> waitingList = scheduler.getWaitingList();
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            int i = 1;
            // Iterate through the queue without removing elements
            for (Patient patient : waitingList) {
                 System.out.println(i++ + ". " + patient);
            }
        }
    }

    /**
     * Handles processing the patient at the front of the waiting list.
     */
    private static void processWaitingList() {
        System.out.println("--- Process Waiting List ---");
        Queue<Patient> waitingList = scheduler.getWaitingList();

        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty. Nothing to process.");
            return;
        }

        Patient patientToProcess = waitingList.peek(); // Look at the first patient
        System.out.println("Processing patient from waiting list: " + patientToProcess.getName() + " (ID: " + patientToProcess.getId() + ")");

        System.out.print("Enter Doctor ID for this appointment attempt: ");
        String doctorId = scanner.nextLine().trim();
        System.out.print("Enter Date and Time for this appointment attempt: ");
        String dateTime = scanner.nextLine().trim();

         // Basic input validation
        if (doctorId.isEmpty() || dateTime.isEmpty()) {
            System.err.println("Error: Doctor ID and Date/Time cannot be empty.");
            return;
        }

        int result = scheduler.processWaitingList(doctorId, dateTime);

        switch (result) {
            case 0:
                System.out.println("Successfully scheduled appointment for " + patientToProcess.getName() + ". Patient removed from waiting list.");
                break;
            case 1:
                 // This case should ideally not happen if we check isEmpty() first,
                 // but included for completeness based on scheduler method return.
                System.out.println("Waiting list became empty before processing.");
                break;
            case 2:
                System.err.println("Error: Doctor with ID " + doctorId + " not found. " + patientToProcess.getName() + " remains in waiting list.");
                break;
            case 3:
                System.out.println("Doctor " + doctorId + " is busy at " + dateTime + ". " + patientToProcess.getName() + " remains in waiting list.");
                break;
             default:
                System.err.println("An unknown error occurred during waiting list processing.");
        }
    }
}
