/*
 * Exam Question #1031
 * Generated on: 2025-05-12 17:15:15
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Print Job Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line application to manage print jobs in a small office. The system should allow users to add new print jobs, process the next waiting job, list all jobs (pending and completed), and check the status of a specific job.
 * 
 * Your solution must demonstrate proficiency in core Java collections, input handling, control flow, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:** Create a class named `PrintJob` to represent a single print job. It should have:
 *     *   Private fields for `id` (an integer, unique identifier), `fileName` (String), `pages` (int), and `status` (use an `enum` named `JobStatus` with values like `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   A constructor to initialize these fields.
 *     *   Public getter methods for all fields.
 *     *   A method to update the job's status.
 * 
 * 2.  **`PrintJobManager` Class:** Create a class named `PrintJobManager` to manage the print jobs. It must contain:
 *     *   A private field `pendingJobs` of type `Queue<PrintJob>` to store jobs waiting to be printed. Use a suitable implementation (e.g., `LinkedList`).
 *     *   A private field `completedJobs` of type `List<PrintJob>` to store jobs that have been processed. Use `ArrayList` but declare it using the `List` interface.
 *     *   A private integer field `nextJobId` to generate unique IDs for new jobs, starting from 1.
 *     *   A constructor to initialize the collections and `nextJobId`.
 *     *   Public methods:
 *         *   `addJob(String fileName, int pages)`: Creates a new `PrintJob`, assigns a unique ID, sets status to `PENDING`, and adds it to the `pendingJobs` queue. Validate that `pages` is greater than 0.
 *         *   `processNextJob()`: Retrieves the next job from the `pendingJobs` queue. If a job exists, change its status to `COMPLETED` (simulate processing) and move it to the `completedJobs` list. If the queue is empty, report an error.
 *         *   `listAllJobs()`: Prints details of all jobs, listing pending jobs first, then completed jobs. Include ID, file name, pages, and status for each job.
 *         *   `getJobStatus(int jobId)`: Finds a job (either pending or completed) by its ID and prints its current status. If the job is not found, report an error.
 *     *   A public method `runSystem()` which contains the main application loop. This method should:
 *         *   Use `Scanner` to read user commands from the console.
 *         *   Present a menu of options to the user (e.g., Add Job, Process Next, List All, Check Status, Exit).
 *         *   Use a `switch` statement to handle different user commands ('a', 'p', 'l', 's', 'q').
 *         *   Implement input validation for commands and any required numerical inputs (like pages or job ID).
 *         *   Use `System.out` for normal output (menu, job details, success messages).
 *         *   Use `System.err` for all error messages (invalid input, queue empty, job not found, invalid page count).
 *         *   Implement class-wide exception handling using a `try-catch` block within the `runSystem` method to catch unexpected errors during the command processing loop and provide a graceful shutdown or retry option. Specific input validation errors (like non-integer input) should also be handled appropriately.
 * 
 * 3.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu. Example interactions:
 * 
 * ```
 * Print Job Management System
 * Menu:
 * a - Add Job
 * p - Process Next Job
 * l - List All Jobs
 * s - Check Job Status
 * q - Exit
 * Enter command: a
 * Enter file name: document.txt
 * Enter number of pages: 10
 * Job 1 (document.txt, 10 pages) added. Status: PENDING
 * 
 * Enter command: a
 * Enter file name: image.jpg
 * Enter number of pages: 5
 * Job 2 (image.jpg, 5 pages) added. Status: PENDING
 * 
 * Enter command: p
 * Processing job 1 (document.txt, 10 pages)... COMPLETED.
 * 
 * Enter command: l
 * --- Pending Jobs ---
 * Job 2 (image.jpg, 5 pages) - Status: PENDING
 * --- Completed Jobs ---
 * Job 1 (document.txt, 10 pages) - Status: COMPLETED
 * 
 * Enter command: s
 * Enter Job ID: 1
 * Job 1 status: COMPLETED
 * 
 * Enter command: s
 * Enter Job ID: 3
 * Error: Job with ID 3 not found.
 * 
 * Enter command: p
 * Processing job 2 (image.jpg, 5 pages)... COMPLETED.
 * 
 * Enter command: p
 * Error: No jobs pending.
 * 
 * Enter command: a
 * Enter file name: report.pdf
 * Enter number of pages: -5
 * Error: Number of pages must be positive.
 * 
 * Enter command: x
 * Error: Invalid command. Please enter a, p, l, s, or q.
 * 
 * Enter command: q
 * Exiting Print Job Management System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to the problem requirements and logic.
 * *   Effective input validation and error handling using `System.err`.
 * *   Proper encapsulation and code structure.
 * *   Meaningful naming and documentation.
 * *   The ability to run and produce output similar to the example.
 * 
 * **Note:** For simplicity in this exam context, you do not need to handle closing the `Scanner` connected to `System.in`.
 *
 * EXPLANATION:
 * This solution implements a `PrintJobManager` class that simulates a basic print queue system, fulfilling all the requirements of the exam question.
 * 
 * 1.  **`PrintJob` Class:** A simple class `PrintJob` is created with private fields (`id`, `fileName`, `pages`, `status`) and public getters, demonstrating encapsulation. An `enum JobStatus` is used for clarity regarding job states. A `setStatus` method allows updating the job state. The `toString()` method provides a convenient way to display job details.
 * 
 * 2.  **`PrintJobManager` Class:**
 *     *   **Collections:**
 *         *   `pendingJobs` is declared as `Queue<PrintJob>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and a suitable implementation for managing a waiting list where jobs are processed in the order they are added (FIFO - First-In, First-Out).
 *         *   `completedJobs` is declared as `List<PrintJob>` and initialized with `new ArrayList<>()`. This meets the requirement of using the `List` interface while implementing it with `ArrayList`. The `ArrayList` is suitable for storing completed jobs as a simple list where order might not be strictly FIFO after completion, but easy iteration is needed.
 *     *   **`nextJobId`:** A private field `nextJobId` is used to ensure each job gets a unique identifier, incremented upon adding a new job.
 *     *   **Methods:**
 *         *   `addJob`: Creates a new `PrintJob` with the next available ID and adds it to the `pendingJobs` queue using `offer()`. It includes input validation to ensure the number of pages is positive, printing an error to `System.err` if not.
 *         *   `processNextJob`: Uses `pendingJobs.poll()` to retrieve and remove the job at the front of the queue. If `poll()` returns `null` (queue is empty), an error is printed to `System.err`. Otherwise, the job's status is updated to `COMPLETED`, and it's added to the `completedJobs` list.
 *         *   `listAllJobs`: Iterates through both the `pendingJobs` queue and the `completedJobs` list, printing details of each job using `System.out`. It clearly separates the two lists in the output.
 *         *   `getJobStatus`: Searches for a job by its ID in both collections. It iterates through `pendingJobs` first, then `completedJobs`. If found, it prints the status to `System.out`; otherwise, it prints a "not found" error to `System.err`.
 *     *   **`runSystem()`:** This is the core interactive loop.
 *         *   It uses `Scanner` to read user input.
 *         *   It displays a menu using `System.out`.
 *         *   It reads the user's command and uses a `switch` statement to dispatch the appropriate action (`addJob`, `processNextJob`, `listAllJobs`, `getJobStatus`, or exit). This fulfills the `switch` requirement.
 *         *   Input validation for numerical inputs (pages and job ID) is handled using specific `try-catch` blocks around `scanner.nextInt()` to catch `InputMismatchException` and print an error to `System.err`. `scanner.nextLine()` is called after reading an integer to consume the remaining newline character, preventing input issues in the next iteration.
 *         *   Default case in the `switch` handles invalid commands, printing an error to `System.err`.
 *         *   **Exception Handling:** The entire `while` loop within `runSystem()` is wrapped in a `try-catch(Exception e)` block. This serves as the "class-wide" exception handling mechanism. It catches any unexpected exceptions that might occur during the execution of commands and prints an error message and stack trace to `System.err`, preventing the program from crashing abruptly and demonstrating robust error handling.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `PrintJob` and `PrintJobManager` are private, accessed via public methods.
 *     *   **Naming:** Variable and method names (`pendingJobs`, `processNextJob`, `fileName`, `getJobStatus`) are descriptive.
 *     *   **Documentation:** Javadoc comments are included for classes and key methods, explaining their purpose, parameters, and return values.
 *     *   **Clean Code:** The code is structured logically with separate methods for distinct operations, making it readable and maintainable.
 *     *   **Input/Output:** `System.out` is consistently used for normal output (menus, job lists, success messages), and `System.err` is exclusively used for error messages, fulfilling the requirement.
 * 
 * The solution effectively integrates all the required Java components into a practical, interactive application, demonstrating advanced understanding of collection types, control flow, input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a print job
enum JobStatus {
    PENDING,
    PROCESSING, // Could be used if simulation was more complex
    COMPLETED,
    FAILED // Could be used for error simulation
}

/**
 * Represents a single print job with ID, file details, and status.
 */
class PrintJob {
    private int id;
    private String fileName;
    private int pages;
    private JobStatus status;

    /**
     * Constructs a new PrintJob.
     *
     * @param id The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the file.
     */
    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
        this.status = JobStatus.PENDING; // New jobs start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public JobStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the print job.
     *
     * @param status The new status for the job.
     */
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Job %d (%s, %d pages) - Status: %s",
                             id, fileName, pages, status);
    }
}

/**
 * Manages a queue of pending print jobs and a list of completed jobs.
 * Provides methods to add, process, list, and check status of jobs.
 */
public class PrintJobManager {
    // Required: Queue for pending jobs
    private Queue<PrintJob> pendingJobs;
    // Required: List interface for completed jobs, using ArrayList implementation
    private List<PrintJob> completedJobs;
    private int nextJobId;

    /**
     * Constructs a new PrintJobManager.
     * Initializes the job queues and ID counter.
     */
    public PrintJobManager() {
        // Use LinkedList as a Queue implementation
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList implementing the List interface
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue.
     *
     * @param fileName The name of the file.
     * @param pages The number of pages.
     */
    public void addJob(String fileName, int pages) {
        // Input validation for pages
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive.");
            return;
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName, pages);
        pendingJobs.offer(newJob); // offer() is preferred for queues
        System.out.println(newJob + " added.");
    }

    /**
     * Processes the next job in the pending queue.
     * Moves the job from pending to completed list after processing.
     */
    public void processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        PrintJob jobToProcess = pendingJobs.poll();
        if (jobToProcess == null) {
            System.err.println("Error: No jobs pending.");
        } else {
            // Simulate processing
            System.out.println("Processing " + jobToProcess.toString().replace("PENDING", "PROCESSING") + "...");
            jobToProcess.setStatus(JobStatus.COMPLETED);
            completedJobs.add(jobToProcess);
            System.out.println("Job " + jobToProcess.getId() + " COMPLETED.");
        }
    }

    /**
     * Lists all jobs, pending and completed.
     */
    public void listAllJobs() {
        System.out.println("\n--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            // Iterate through the Queue (order matters for pending)
            for (PrintJob job : pendingJobs) {
                System.out.println(job);
            }
        }

        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No completed jobs.");
        } else {
            // Iterate through the List
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println(); // Add a newline for readability
    }

    /**
     * Finds a job by ID and prints its status.
     * Searches both pending and completed job collections.
     *
     * @param jobId The ID of the job to find.
     */
    public void getJobStatus(int jobId) {
        PrintJob foundJob = null;

        // Search pending jobs
        for (PrintJob job : pendingJobs) {
            if (job.getId() == jobId) {
                foundJob = job;
                break;
            }
        }

        // If not found in pending, search completed jobs
        if (foundJob == null) {
            for (PrintJob job : completedJobs) {
                if (job.getId() == jobId) {
                    foundJob = job;
                    break;
                }
            }
        }

        if (foundJob == null) {
            System.err.println("Error: Job with ID " + jobId + " not found.");
        } else {
            System.out.println("Job " + foundJob.getId() + " status: " + foundJob.getStatus());
        }
    }

    /**
     * Runs the interactive command-line system loop.
     * Handles user input, command dispatch, and exception handling.
     */
    public void runSystem() {
        // Required: Scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Print Job Management System");

        // Required: Class-wide exception handling using try-catch
        // This try-catch block wraps the main operational loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Required: Switch statement for flow control
                switch (command) {
                    case "a": // Add Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        System.out.print("Enter number of pages: ");
                        try {
                            // Specific handling for non-integer input
                            int pages = scanner.nextInt();
                            // Consume the rest of the line after reading int
                            scanner.nextLine();
                            addJob(fileName, pages);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for pages. Please enter a number.");
                            // Consume the invalid input to prevent infinite loop
                            scanner.nextLine();
                        }
                        break;

                    case "p": // Process Next Job
                        processNextJob();
                        break;

                    case "l": // List All Jobs
                        listAllJobs();
                        break;

                    case "s": // Check Job Status
                        System.out.print("Enter Job ID: ");
                        try {
                            // Specific handling for non-integer input
                            int jobId = scanner.nextInt();
                             // Consume the rest of the line after reading int
                            scanner.nextLine();
                            getJobStatus(jobId);
                        } catch (InputMismatchException e) {
                             System.err.println("Error: Invalid input for Job ID. Please enter a number.");
                             // Consume the invalid input
                             scanner.nextLine();
                        }
                        break;

                    case "q": // Exit
                        running = false;
                        System.out.println("Exiting Print Job Management System.");
                        break;

                    default:
                        // Required: System.err for error messages
                        System.err.println("Error: Invalid command. Please enter a, p, l, s, or q.");
                        break;
                }
            }
        } catch (Exception e) {
            // Required: Catch-all for unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
             // In a simple console app like this, closing System.in scanner can be tricky
             // and might interfere if System.in is needed elsewhere or if the JVM doesn't exit immediately.
             // For exam purposes demonstrating basic Scanner use, leaving it open is acceptable
             // if the application is designed to exit after the loop.
             // scanner.close(); // Uncomment in a real application if appropriate
        }
    }

    private void printMenu() {
        System.out.println("\nMenu:");
        System.out.println("a - Add Job");
        System.out.println("p - Process Next Job");
        System.out.println("l - List All Jobs");
        System.out.println("s - Check Job Status");
        System.out.println("q - Exit");
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.runSystem();
    }
}
