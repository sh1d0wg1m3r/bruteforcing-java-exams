/*
 * Exam Question #458
 * Generated on: 2025-05-11 23:14:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Print Job Management System
 * 
 * **Objective:** Design and implement a console-based application for managing print jobs. The system should allow users to add new print jobs to a queue, process the next job in the queue, view pending jobs, and view completed jobs. This task requires demonstrating proficiency in core Java data structures, control flow, user input handling, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a list of print jobs waiting to be processed.
 *     *   Maintain a list of print jobs that have been completed.
 *     *   Allow users to add a new print job by providing a file name and number of pages.
 *     *   Allow users to process the next job in the queue. Processing removes the job from the pending queue and adds it to the completed list.
 *     *   Allow users to view all pending print jobs.
 *     *   Allow users to view all completed print jobs.
 *     *   Provide an option to exit the application.
 * 
 * 2.  **Required Java Components:**
 *     *   Use `java.util.Queue` to store pending print jobs.
 *     *   Use `java.util.ArrayList` to store completed print jobs.
 *     *   Refer to the completed jobs collection using the `java.util.List` interface where appropriate (e.g., method return types).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement to handle user commands.
 *     *   Use `System.err` to print error messages (e.g., trying to process a job when the queue is empty, invalid input).
 *     *   Use `System.out` to print normal output (prompts, job details, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input and potentially risky operations.
 * 
 * 3.  **Design and Best Practices:**
 *     *   Create a `PrintJob` class to represent a single print job with relevant attributes (e.g., job ID, file name, pages, status).
 *     *   Create a `PrintManager` class to encapsulate the logic for managing the pending queue and completed list. This class should contain methods for adding, processing, and retrieving jobs.
 *     *   Use proper encapsulation (`private` fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc documentation.
 *     *   Implement input validation (e.g., ensure page count is positive, file name is not empty).
 *     *   Handle potential errors gracefully (e.g., inform the user if the queue is empty when processing).
 *     *   Structure the code clearly with separate classes for different responsibilities.
 * 
 * **User Interface (Console Interaction):**
 * 
 * The application should present a menu of options to the user:
 * 
 * ```
 * Print Job Management System
 * -----------------------------
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the user's choice, the system should perform the corresponding action, prompt for additional details if necessary, and provide feedback.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Print Job Management System
 * -----------------------------
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: document.txt
 * Enter number of pages: 10
 * Job ID 1 (document.txt, 10 pages) added to queue.
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 1
 * Enter file name: image.jpg
 * Enter number of pages: 5
 * Job ID 2 (image.jpg, 5 pages) added to queue.
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 3
 * Pending Jobs:
 * Job ID 1 (document.txt, 10 pages) - Pending
 * Job ID 2 (image.jpg, 5 pages) - Pending
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 2
 * Processing Job ID 1 (document.txt, 10 pages)... Done.
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 3
 * Pending Jobs:
 * Job ID 2 (image.jpg, 5 pages) - Pending
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 4
 * Completed Jobs:
 * Job ID 1 (document.txt, 10 pages) - Completed
 * 
 * Print Job Management System
 * -----------------------------
 * ... (menu) ...
 * Enter your choice: 5
 * Exiting Print Job Management System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented design principles (encapsulation, separation of concerns).
 * *   Code readability, comments, and documentation.
 * *   Robustness through input validation and error handling.
 * 
 * **Note:** You do not need to implement actual printing logic. Simulating the processing by moving the job is sufficient.
 *
 * EXPLANATION:
 * The provided solution implements a console-based Print Job Management System, fulfilling all the requirements of the exam task.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents an individual print job with `jobId`, `fileName`, `pages`, and `status`.
 *     *   Uses a static counter (`nextJobId`) to ensure unique IDs for each job instance, demonstrating a common pattern for generating unique identifiers.
 *     *   Employs encapsulation by making fields `private` and providing public getter/setter methods.
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Manages the core data structures: a `Queue<PrintJob>` (`pendingJobs`) for jobs waiting to be printed and a `List<PrintJob>` (`completedJobs`) for finished jobs.
 *     *   Uses `LinkedList` as the implementation for the `Queue`, suitable for efficient additions (`offer`) and removals from the head (`poll`).
 *     *   Uses `ArrayList` as the implementation for the `List` of completed jobs, suitable for storing and iterating through a collection where elements are added at the end.
 *     *   Provides methods (`addJob`, `processNextJob`, `getPendingJobs`, `getCompletedJobs`) that encapsulate the logic for manipulating these collections.
 *     *   `processNextJob` demonstrates the use of `Queue.poll()` to retrieve and remove the head element, simulating processing. It includes a check for an empty queue before attempting to poll.
 *     *   `getCompletedJobs` returns a `List`, demonstrating the use of the interface type.
 * 
 * 3.  **`PrintJobSystem` Class (Main Application):**
 *     *   Contains the `main` method, which is the entry point.
 *     *   Uses `java.util.Scanner` to read user input from `System.in`. The scanner is managed carefully, including consuming newline characters after reading numbers (`scanner.nextLine()`).
 *     *   Implements the main application loop that repeatedly displays a menu and processes user input.
 *     *   Utilizes a `switch` statement to dispatch control based on the user's menu choice, providing a clear structure for handling different commands.
 *     *   **Error Handling:**
 *         *   Uses `System.err.println()` to output error messages, distinguishing them from normal application output (`System.out.println()`). Examples include invalid menu choices, trying to process an empty queue, empty file names, and non-positive page counts.
 *         *   Implements input validation within `handleAddJob` to check for empty file names and non-positive page counts. It uses a loop and `try-catch` specifically for the page count input to handle `InputMismatchException` if the user enters non-numeric input.
 *         *   Implements a **class-wide `try-catch` block** around the main `while` loop in the `main` method. This catches any unexpected `Exception` that might occur during the program's execution, preventing the application from crashing abruptly and providing a generic error message and stack trace using `e.printStackTrace(System.err)`.
 *         *   A `finally` block ensures the `Scanner` resource is closed when the application terminates, regardless of whether an exception occurred or the user exited normally.
 * 
 * 4.  **Data Structure Usage:**
 *     *   `Queue`: Effectively used to maintain the order of pending jobs (FIFO - First-In, First-Out), crucial for a processing queue.
 *     *   `ArrayList`: Used to store completed jobs, where order matters (order of completion) and elements are added sequentially.
 *     *   `List`: The `completedJobs` is often referred to via the `List` interface, demonstrating programming to interfaces, which promotes flexibility.
 * 
 * 5.  **Best Practices:**
 *     *   Clear separation of concerns: `PrintJob` for data representation, `PrintManager` for data structure management and logic, `PrintJobSystem` for user interaction and application flow.
 *     *   Meaningful names (`pendingJobs`, `processNextJob`, `handleAddJob`).
 *     *   Comments and Javadoc explaining classes, methods, and key logic.
 *     *   Input validation and specific error messages guide the user.
 *     *   Graceful handling of operations on empty collections (`processNextJob`).
 * 
 * This solution demonstrates a solid understanding of fundamental and intermediate Java concepts, including object-oriented design, collection framework usage, exception handling, input/output, and control flow, integrated into a practical simulation.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job.
 */
class PrintJob {
    private static int nextJobId = 1; // Class-level static counter for unique IDs

    private int jobId;
    private String fileName;
    private int pages;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new PrintJob with the given details.
     * Assigns a unique job ID and sets status to "Pending".
     *
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the file.
     */
    public PrintJob(String fileName, int pages) {
        this.jobId = nextJobId++;
        this.fileName = fileName;
        this.pages = pages;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the print job.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID " + jobId + " (" + fileName + ", " + pages + " pages) - " + status;
    }
}

/**
 * Manages the queue of pending print jobs and the list of completed jobs.
 */
class PrintManager {
    private Queue<PrintJob> pendingJobs; // Queue for jobs waiting to be processed
    private List<PrintJob> completedJobs; // List for jobs that have been processed

    /**
     * Constructs a new PrintManager.
     * Initializes the pending job queue and completed job list.
     */
    public PrintManager() {
        this.pendingJobs = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedJobs = new ArrayList<>(); // ArrayList for completed jobs
    }

    /**
     * Adds a new print job to the pending queue.
     *
     * @param job The PrintJob object to add.
     */
    public void addJob(PrintJob job) {
        pendingJobs.offer(job); // offer is preferred over add for queues (doesn't throw exception)
        System.out.println(job + " added to queue.");
    }

    /**
     * Processes the next job in the pending queue.
     * Removes the job from the queue, changes its status to "Completed",
     * and adds it to the completed jobs list.
     * Prints an error to System.err if the queue is empty.
     */
    public void processNextJob() {
        PrintJob jobToProcess = pendingJobs.poll(); // poll retrieves and removes the head of the queue

        if (jobToProcess != null) {
            System.out.println("Processing " + jobToProcess.getFileName() + "...");
            jobToProcess.setStatus("Completed"); // Simulate processing
            completedJobs.add(jobToProcess);
            System.out.println("Job ID " + jobToProcess.getJobId() + " processed and completed.");
        } else {
            System.err.println("Error: No pending jobs to process.");
        }
    }

    /**
     * Returns the list of pending print jobs.
     *
     * @return A List containing the pending PrintJob objects.
     */
    public List<PrintJob> getPendingJobs() {
        // To avoid external modification of the internal queue structure,
        // we can return a copy or iterate and print directly.
        // For this example, iterating and printing within the main app is simpler.
        // A more robust system might return an unmodifiable list or a copy.
        // We'll return a List view of the current queue elements for examination.
        return new ArrayList<>(pendingJobs); // Return a new list containing queue elements
    }

    /**
     * Returns the list of completed print jobs.
     *
     * @return A List containing the completed PrintJob objects.
     */
    public List<PrintJob> getCompletedJobs() {
        // Returning the internal list reference is acceptable for this exam context,
        // though in a larger system, returning an unmodifiable list or a copy is safer.
        return completedJobs;
    }
}

/**
 * Main class for the Print Job Management System application.
 * Handles user interaction and coordinates with the PrintManager.
 */
public class PrintJobSystem {

    private static final Scanner scanner = new Scanner(System.in); // Scanner for user input
    private static final PrintManager printManager = new PrintManager(); // Manages print jobs

    /**
     * Displays the main menu to the user.
     */
    private static void displayMenu() {
        System.out.println("\nPrint Job Management System");
        System.out.println("-----------------------------");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the process of adding a new print job based on user input.
     */
    private static void handleAddJob() {
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine().trim(); // Use nextLine() for potential spaces

        // Input validation for file name
        if (fileName.isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return; // Exit the handler method
        }

        int pages = 0;
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter number of pages: ");
            try {
                pages = scanner.nextInt();
                scanner.nextLine(); // Consume the newline left-over
                // Input validation for pages
                if (pages <= 0) {
                    System.err.println("Error: Number of pages must be positive.");
                } else {
                    validInput = true; // Input is valid
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a valid number for pages.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            }
        }

        // If we reached here, input is valid
        PrintJob newJob = new PrintJob(fileName, pages);
        printManager.addJob(newJob);
    }

    /**
     * Handles displaying the list of pending jobs.
     */
    private static void handleViewPendingJobs() {
        List<PrintJob> pending = printManager.getPendingJobs();
        System.out.println("\nPending Jobs:");
        if (pending.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            for (PrintJob job : pending) {
                System.out.println(job); // Print uses the job's toString() method
            }
        }
    }

    /**
     * Handles displaying the list of completed jobs.
     */
    private static void handleViewCompletedJobs() {
        List<PrintJob> completed = printManager.getCompletedJobs();
        System.out.println("\nCompleted Jobs:");
        if (completed.isEmpty()) {
            System.out.println("No completed jobs.");
        } else {
            for (PrintJob job : completed) {
                System.out.println(job); // Print uses the job's toString() method
            }
        }
    }

    /**
     * The main entry point of the application.
     * Contains the main command loop and class-wide exception handling.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Handle potential InputMismatchException for the menu choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline after reading int
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number from the menu.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use a switch statement to handle user choices
                switch (choice) {
                    case 1:
                        handleAddJob();
                        break;
                    case 2:
                        printManager.processNextJob();
                        break;
                    case 3:
                        handleViewPendingJobs();
                        break;
                    case 4:
                        handleViewCompletedJobs();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Print Job Management System.");
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Error: Invalid choice. Please select a valid option (1-5).");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the application's runtime
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
