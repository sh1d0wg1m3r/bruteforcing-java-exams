/*
 * Exam Question #126
 * Generated on: 2025-05-11 22:18:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team. The system should allow users to add new tasks, view tasks that are pending processing, process the next task in line, and view tasks that have been completed and archived.
 * 
 * **Task Definition:**
 * 
 * Each task should have a unique ID, a description, and a status (Pending or Completed).
 * 
 * **System Functionality:**
 * 
 * 1.  **Add New Task:** Allows the user to enter a description for a new task. The task is created with a "Pending" status and added to a queue of tasks awaiting processing.
 * 2.  **View Pending Tasks:** Displays all tasks currently in the pending queue, in the order they will be processed.
 * 3.  **Process Next Task:** Takes the task at the front of the pending queue, changes its status to "Completed", and moves it to an archive list of completed tasks. If the queue is empty, an appropriate message should be displayed.
 * 4.  **View Completed Tasks:** Displays all tasks currently in the completed tasks archive list.
 * 5.  **Exit:** Terminates the application.
 * 
 * **User Interface:**
 * 
 * The system should present a menu of options to the user via the console. User input should be read using a `Scanner`.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Core Data Structures:**
 *     *   Use a `java.util.Queue` to manage the pending tasks.
 *     *   Use a `java.util.ArrayList` to store the completed tasks.
 *     *   Declare the completed tasks storage using the `java.util.List` interface (`List<Task> completedTasksArchive = new ArrayList<>();`).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue).
 * 5.  **Exception Handling:**
 *     *   Implement exception handling using `try-catch` blocks, particularly for handling invalid user input (e.g., non-integer input for menu choices). Ensure robust handling that allows the program to continue after an input error. Include a broader catch for unexpected errors in the main application loop.
 * 6.  **Code Structure and Best Practices:**
 *     *   Create a `Task` class with private fields (description, status, ID) and public getter methods. Include a method to set the status. Use an `enum` for task status.
 *     *   Create a main class (e.g., `TaskManager`) that contains the `main` method and the logic for managing tasks.
 *     *   Use proper encapsulation (private fields, public/private methods).
 *     *   Employ meaningful variable and method names.
 *     *   Include appropriate comments to explain key parts of the code.
 *     *   Implement input validation (e.g., checking for empty task description, handling non-numeric input).
 *     *   Handle edge cases gracefully (e.g., attempting to process or view tasks when collections are empty).
 *     *   Ensure the `Scanner` resource is closed properly upon exiting.
 * 
 * **Expected Output:**
 * 
 * Your program should demonstrate the following interactions:
 * 
 * *   Display the main menu.
 * *   Prompt the user for input.
 * *   Add a task, showing a confirmation message.
 * *   View pending tasks, showing the list of tasks in the queue.
 * *   Attempt to process a task when the queue is empty, showing an error message on `System.err`.
 * *   Process a task when the queue is not empty, showing a confirmation and the task details.
 * *   View pending tasks again, showing the processed task is removed.
 * *   View completed tasks, showing the processed task in the archive list.
 * *   Enter invalid input (e.g., text instead of a number) for the menu choice, showing an error message on `System.err` and re-displaying the menu.
 * *   Enter an invalid menu number, showing an error message on `System.err` and re-displaying the menu.
 * *   Exit the application, showing a goodbye message.
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class and `TaskStatus` Enum:**
 *     *   The `Task` class encapsulates the data for a single task: a unique `id`, a `description`, and a `status`.
 *     *   A `static int nextId` ensures each task gets a unique identifier upon creation.
 *     *   An `enum TaskStatus` provides a type-safe way to represent the two possible states of a task (`PENDING`, `COMPLETED`).
 *     *   The class includes private fields, a constructor, public getters, and a public setter for the status, adhering to encapsulation principles.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the main class containing the application logic and data structures.
 *     *   `private Queue<Task> pendingTasksQueue = new LinkedList<>();`: A `Queue` is used to store tasks waiting to be processed. `LinkedList` is a common implementation of `Queue` that provides FIFO behavior, suitable for processing tasks in the order they were added.
 *     *   `private List<Task> completedTasksArchive = new ArrayList<>();`: A `List` is used to archive completed tasks. It is declared using the `List` interface but instantiated as an `ArrayList`, demonstrating polymorphism. `ArrayList` is suitable for storing and iterating over completed tasks.
 *     *   `private Scanner scanner = new Scanner(System.in);`: A `Scanner` is used to read user input from the standard input stream (`System.in`).
 *     *   **`displayMenu()`:** A private helper method to print the menu options to `System.out`.
 *     *   **`addTask()`:** Reads the task description from the user, creates a `Task` object with `PENDING` status, validates that the description is not empty, and adds it to the `pendingTasksQueue` using the `add()` method. Uses `scanner.nextLine()` after `scanner.nextInt()` in the main loop to consume the leftover newline character.
 *     *   **`viewPendingTasks()`:** Checks if the `pendingTasksQueue` is empty. If not, it iterates through the queue using an enhanced for loop and prints each task's details to `System.out`. If empty, it prints a message to `System.out`.
 *     *   **`processNextTask()`:** Checks if the `pendingTasksQueue` is empty. If empty, it prints an error message to `System.err`. If not empty, it uses `pendingTasksQueue.poll()` to retrieve and remove the task at the head of the queue. It then updates the task's status to `COMPLETED` using the setter and adds it to the `completedTasksArchive` list using the `add()` method. Success messages are printed to `System.out`.
 *     *   **`viewCompletedTasks()`:** Checks if the `completedTasksArchive` list is empty. If not, it iterates through the list using an enhanced for loop and prints each task's details to `System.out`. If empty, it prints a message to `System.out`.
 *     *   **`run()`:** This method contains the main application loop (`while(running)`).
 *         *   It repeatedly displays the menu.
 *         *   It uses a `try-catch` block specifically for reading the integer menu choice. It catches `InputMismatchException` if the user enters non-integer input, prints an error to `System.err`, consumes the invalid input using `scanner.next()` to prevent an infinite loop, and uses `continue` to restart the loop iteration, prompting for input again. A broader `catch (Exception e)` is included to handle any other unexpected errors during input reading, fulfilling the "class-wide exception handling" requirement by handling errors in the main execution flow of the class.
 *         *   A `switch` statement directs the program flow based on the valid user choice, calling the appropriate private methods.
 *         *   The `default` case of the `switch` handles invalid numeric inputs, printing an error to `System.err`.
 *         *   When the user chooses option 5, `running` is set to `false`, terminating the loop.
 *         *   Finally, `scanner.close()` is called outside the loop to release the scanner resource.
 *     *   **`main()`:** The entry point of the application. It creates an instance of `TaskManager` and calls its `run()` method to start the system.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **`Queue`:** Used for managing pending tasks in a FIFO manner (`poll()` for retrieval/removal, `add()` for insertion).
 * *   **`ArrayList` & `List`:** Used for storing completed tasks. Shows declaration using the `List` interface and instantiation with `ArrayList`.
 * *   **`Scanner`:** Used for interactive console input.
 * *   **`switch`:** Used for multi-way branching based on menu choices.
 * *   **`System.out` & `System.err`:** Correctly used for standard output and error reporting respectively.
 * *   **`try-catch`:** Implemented for robust input handling (`InputMismatchException`) and a general catch for unexpected errors in the main processing loop, demonstrating exception handling within the class's core operational method.
 * *   **Encapsulation:** Private fields and controlled access via public methods in the `Task` class.
 * *   **Input Validation:** Checks for empty description and handles non-numeric menu input.
 * *   **Error Handling:** Specific error messages for invalid operations (empty queue/list) and invalid input, directed to `System.err`.
 * *   **Object-Oriented Design:** Separation of concerns between the `Task` data structure and the `TaskManager` logic.
 * *   **Enums:** Used for representing task status in a clear and type-safe way.
 * *   **Resource Management:** Closing the `Scanner` resource.
 * 
 * This solution effectively integrates the required Java components into a functional application, demonstrating advanced understanding of collection usage, control flow, error handling, and basic object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING, COMPLETED
}

// Task Class
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    // Static counter for unique task IDs
    private static int nextId = 1;

    /**
     * Constructor for creating a new Task.
     * Automatically assigns a unique ID and sets status to PENDING.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for Status (used by TaskManager) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation including ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Main Task Management System Class
public class TaskManager {

    // Queue for tasks awaiting processing (FIFO)
    private Queue<Task> pendingTasksQueue = new LinkedList<>();

    // List for completed tasks archive
    private List<Task> completedTasksArchive = new ArrayList<>();

    // Scanner for reading user input
    private Scanner scanner = new Scanner(System.in);

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles adding a new task based on user input.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(description.trim());
        pendingTasksQueue.add(newTask); // Add task to the pending queue
        System.out.println("Task added successfully: " + newTask.getDescription());
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue (order is maintained by LinkedList)
            int count = 1;
            for (Task task : pendingTasksQueue) {
                System.out.println(count++ + ". " + task);
            }
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes it from the queue, updates status, and adds to the completed archive.
     */
    private void processNextTask() {
        System.out.println("\n--- Processing Task ---");
        if (pendingTasksQueue.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            Task taskToProcess = pendingTasksQueue.poll(); // Get and remove the head of the queue
            // Simulate processing
            System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");

            // Update status and move to completed archive
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasksArchive.add(taskToProcess); // Add to the completed list

            System.out.println("Task ID " + taskToProcess.getId() + " marked as completed and archived.");
        }
    }

    /**
     * Displays all tasks currently in the completed tasks archive list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasksArchive.isEmpty()) {
            System.out.println("No completed tasks archived.");
        } else {
            // Iterate through the completed tasks list
            int count = 1;
            for (Task task : completedTasksArchive) {
                System.out.println(count++ + ". " + task);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            // --- Exception Handling for User Input ---
            try {
                choice = scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the rest of the loop iteration and show menu again
            } catch (Exception e) {
                 // Broader catch for any other unexpected errors during input reading
                 System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                 // e.printStackTrace(System.err); // Uncomment for debugging detailed errors
                 scanner.nextLine(); // Attempt to clear the rest of the line
                 continue; // Skip the rest of the loop iteration
            }

            // --- Switch statement for menu choices ---
            switch (choice) {
                case 1:
                    addTask();
                    break;
                case 2:
                    viewPendingTasks();
                    break;
                case 3:
                    processNextTask();
                    break;
                case 4:
                    viewCompletedTasks();
                    break;
                case 5:
                    running = false; // Set flag to exit loop
                    System.out.println("Exiting Task Management System. Goodbye!");
                    break;
                default:
                    // Handle choices outside the valid range
                    System.err.println("Invalid choice. Please enter a number between 1 and 5.");
            }
        }
        // Close the scanner resource when the application exits
        scanner.close();
    }

    /**
     * Main method to start the Task Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
