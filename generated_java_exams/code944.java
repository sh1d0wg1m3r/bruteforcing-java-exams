/*
 * Exam Question #944
 * Generated on: 2025-05-12 17:03:12
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Objective:** Design and implement a command-line based system to manage patient appointments for a small clinic. The system should allow scheduling new appointments, processing the next appointment in the queue, viewing the waiting queue, and listing available doctors.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   **Schedule Appointment:** Allow a user to input patient name, desired doctor's name, and a preferred time slot. Validate the doctor's existence. If valid, add the appointment to a waiting queue.
 *     *   **Process Next Appointment:** Remove and display the details of the appointment that has been waiting the longest in the queue.
 *     *   **View Waiting Queue:** Display all appointments currently in the waiting queue without removing them.
 *     *   **View Doctors:** Display the list of available doctors.
 *     *   **Exit:** Terminate the program.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `Queue<Appointment>` to manage the waiting list of appointments.
 *     *   Use an `ArrayList<Doctor>` to store the list of available doctors.
 *     *   Declare the collection of doctors using the `List` interface (`List<Doctor>`).
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input for menu choices and appointment details.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for all normal program output (menu, confirmations, lists, processed appointments).
 *     *   Use `System.err` to print error messages (e.g., invalid doctor name, invalid menu choice, queue empty).
 *     *   Implement class-wide or main method level exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., input mismatches, unexpected issues).
 * 
 * 5.  **Code Structure and Best Practices:**
 *     *   Create separate classes for `Doctor` and `Appointment` with appropriate private fields and public getter methods (encapsulation).
 *     *   Implement the main application logic within a class (e.g., `HospitalScheduler`).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and Javadoc where appropriate to explain the code.
 *     *   Perform basic input validation (e.g., checking if a doctor exists before scheduling).
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Classes to Create:**
 * 
 * *   `Doctor`: Represents a doctor with properties like `name` and `specialty`.
 * *   `Appointment`: Represents a scheduled appointment with properties like `patientName`, `doctor`, and `timeSlot`.
 * *   `HospitalScheduler`: Contains the main logic, including the `main` method, the `Queue` of appointments, the `List` of doctors, and methods for handling the menu options.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule Appointment
 * 2. Process Next Appointment
 * 3. View Waiting Queue
 * 4. View Doctors
 * 5. Exit
 * Enter your choice: 4
 * --- Available Doctors ---
 * Dr. Smith (Cardiology)
 * Dr. Jones (Pediatrics)
 * ---
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter doctor name: Dr. Smith
 * Enter time slot (e.g., 10:00 AM): 10:30 AM
 * Appointment scheduled for Alice with Dr. Smith at 10:30 AM.
 * --- Hospital Appointment Scheduler ---
 * ... (menu again)
 * Enter your choice: 3
 * --- Waiting Queue ---
 * 1. Patient: Alice, Doctor: Dr. Smith, Time: 10:30 AM
 * ---
 * ... (menu again)
 * Enter your choice: 2
 * Processing appointment: Patient: Alice, Doctor: Dr. Smith, Time: 10:30 AM
 * ---
 * ... (menu again)
 * Enter your choice: 3
 * --- Waiting Queue ---
 * Queue is empty.
 * ---
 * ... (menu again)
 * Enter your choice: 1
 * Enter patient name: Bob
 * Enter doctor name: Dr. Evil
 * Enter time slot (e.g., 10:00 AM): 11:00 AM
 * Error: Doctor 'Dr. Evil' not found.
 * --- Hospital Appointment Scheduler ---
 * ... (menu again)
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * Your solution should compile and run from the command line, providing the described functionality and adhering to all requirements.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required features.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability, comments, and documentation.
 * *   Effective error handling and input validation.
 * *   Clean code structure.
 *
 * EXPLANATION:
 * This solution implements the Hospital Appointment Scheduler as required, demonstrating the use of all specified Java components in a cohesive, practical scenario.
 * 
 * 1.  **`Doctor` and `Appointment` Classes:** These classes are simple data holders (`POJOs`) demonstrating **encapsulation**. They have private fields (`name`, `specialty`, `patientName`, `doctor`, `timeSlot`) and public getter methods (`getName`, `getSpecialty`, etc.) to access the data. The `toString()` method is overridden for convenient printing of object details.
 * 
 * 2.  **`HospitalScheduler` Class:** This is the main class containing the application logic.
 *     *   **Data Structures:**
 *         *   `Queue<Appointment> appointmentQueue`: A `LinkedList` is used here because it efficiently implements the `Queue` interface's methods (`offer`, `poll`, `peek`) which are suitable for a waiting line (FIFO - First-In, First-Out). It's declared as a `Queue` interface type, adhering to the principle of programming to interfaces.
 *         *   `List<Doctor> doctors`: An `ArrayList` is used to store the collection of doctors. It's declared as a `List` interface type, as required. `ArrayList` is suitable here because we primarily need to iterate through the list and search for a doctor by name.
 *     *   **`Scanner`:** A `Scanner` object is initialized to read user input from `System.in`.
 *     *   **`findDoctorByName` Method:** This helper method iterates through the `doctors` list to find a doctor based on the provided name, demonstrating list traversal and basic search.
 *     *   **`displayMenu` Method:** Prints the options to `System.out`.
 *     *   **Action Methods (`scheduleAppointment`, `processNextAppointment`, `viewWaitingQueue`, `viewDoctors`):** These methods encapsulate the logic for each menu option.
 *         *   `scheduleAppointment`: Reads input using `scanner.nextLine()`, validates the doctor, creates an `Appointment` object, and adds it to the `appointmentQueue` using `offer()`. Uses `System.out` for confirmation and `System.err` for the validation error.
 *         *   `processNextAppointment`: Uses `appointmentQueue.poll()` to retrieve and remove the head of the queue. It checks if the result is `null` (meaning the queue was empty) before printing the processed appointment details to `System.out`. Handles the empty queue case with `System.out`.
 *         *   `viewWaitingQueue`: Iterates through the `appointmentQueue` using an enhanced for loop to display its contents *without* removing elements. Checks for emptiness and uses `System.out`.
 *         *   `viewDoctors`: Iterates through the `doctors` list and prints each `Doctor` object using `System.out` (implicitly calling `Doctor.toString()`).
 *     *   **`run` Method:** This method contains the main application loop.
 *         *   It uses a `boolean running` flag to control the loop.
 *         *   **`try-catch` Block:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This provides class-wide exception handling, catching any unexpected runtime errors that might occur within the main execution flow. A more specific `catch(InputMismatchException e)` could be added if reading numbers directly with `nextInt()` was heavily used, but reading lines and parsing (as done for the menu choice) is safer against non-numeric input. The generic `Exception` catch serves as a robust fallback. Error messages are printed to `System.err`, and the stack trace is printed for debugging.
 *         *   **`switch` Statement:** Inside the loop, a `switch` statement is used to direct execution based on the user's parsed integer choice.
 *         *   **Input Validation (Menu Choice):** The user input for the choice is read as a `String` first. A nested `try-catch(NumberFormatException)` is used when parsing the string to an integer. If parsing fails, the `choice` variable remains its default invalid value (`-1`), which is then caught by the `default` case of the `switch`, triggering an error message on `System.err`. This prevents the program from crashing on non-numeric input for the menu.
 *         *   **`finally` Block:** A `finally` block is used to ensure the `scanner.close()` method is called, releasing the system resource associated with the `Scanner`, regardless of whether the program exits normally or due to an exception.
 * 
 * 3.  **`main` Method:** The standard entry point of the application. It creates an instance of `HospitalScheduler` and calls its `run()` method to start the scheduler.
 * 
 * This solution effectively combines the required data structures (`Queue`, `ArrayList`, `List`), control flow (`switch`), I/O (`Scanner`, `System.out`, `System.err`), object-oriented principles (encapsulation in `Doctor` and `Appointment`), and error handling (`try-catch`) to create a functional and robust command-line application simulating a real-world scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues

/**
 * Represents a Doctor in the hospital.
 */
class Doctor {
    private String name;
    private String specialty;

    /**
     * Constructs a Doctor object.
     * @param name The doctor's name.
     * @param specialty The doctor's specialty.
     */
    public Doctor(String name, String specialty) {
        this.name = name;
        this.specialty = specialty;
    }

    /**
     * Gets the doctor's name.
     * @return The doctor's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the doctor's specialty.
     * @return The doctor's specialty.
     */
    public String getSpecialty() {
        return specialty;
    }

    /**
     * Returns a string representation of the Doctor.
     * @return String representation.
     */
    @Override
    public String toString() {
        return name + " (" + specialty + ")";
    }
}

/**
 * Represents a patient appointment.
 */
class Appointment {
    private String patientName;
    private Doctor doctor;
    private String timeSlot;

    /**
     * Constructs an Appointment object.
     * @param patientName The name of the patient.
     * @param doctor The Doctor for the appointment.
     * @param timeSlot The scheduled time slot.
     */
    public Appointment(String patientName, Doctor doctor, String timeSlot) {
        this.patientName = patientName;
        this.doctor = doctor;
        this.timeSlot = timeSlot;
    }

    /**
     * Gets the patient's name.
     * @return The patient's name.
     */
    public String getPatientName() {
        return patientName;
    }

    /**
     * Gets the Doctor for the appointment.
     * @return The Doctor object.
     */
    public Doctor getDoctor() {
        return doctor;
    }

    /**
     * Gets the time slot for the appointment.
     * @return The time slot string.
     */
    public String getTimeSlot() {
        return timeSlot;
    }

    /**
     * Returns a string representation of the Appointment.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Patient: " + patientName + ", Doctor: " + doctor.getName() + ", Time: " + timeSlot;
    }
}

/**
 * Main class for the Hospital Appointment Scheduler application.
 * Manages the queue of appointments and list of doctors.
 */
public class HospitalScheduler {

    // Use LinkedList as it implements both Queue and List, but declare as interfaces
    private Queue<Appointment> appointmentQueue;
    private List<Doctor> doctors;
    private Scanner scanner;

    /**
     * Constructs a HospitalScheduler, initializing doctors and the appointment queue.
     */
    public HospitalScheduler() {
        // Initialize the queue using LinkedList
        appointmentQueue = new LinkedList<>();

        // Initialize the list of doctors using ArrayList
        doctors = new ArrayList<>();
        // Add some initial doctors
        doctors.add(new Doctor("Dr. Smith", "Cardiology"));
        doctors.add(new Doctor("Dr. Jones", "Pediatrics"));
        doctors.add(new Doctor("Dr. Lee", "General Practice"));

        scanner = new Scanner(System.in);
    }

    /**
     * Finds a doctor by name (case-insensitive search).
     * @param name The name of the doctor to find.
     * @return The Doctor object if found, null otherwise.
     */
    private Doctor findDoctorByName(String name) {
        for (Doctor doc : doctors) {
            if (doc.getName().equalsIgnoreCase(name)) {
                return doc;
            }
        }
        return null; // Doctor not found
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment Scheduler ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. Process Next Appointment");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Doctors");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the scheduling of a new appointment.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine();

        System.out.print("Enter doctor name: ");
        String doctorName = scanner.nextLine();

        Doctor selectedDoctor = findDoctorByName(doctorName);

        if (selectedDoctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return; // Exit the method if doctor is not found
        }

        System.out.print("Enter time slot (e.g., 10:00 AM): ");
        String timeSlot = scanner.nextLine();

        Appointment newAppointment = new Appointment(patientName, selectedDoctor, timeSlot);
        appointmentQueue.offer(newAppointment); // Add to the end of the queue

        System.out.println("Appointment scheduled for " + patientName + " with " + selectedDoctor.getName() + " at " + timeSlot + ".");
    }

    /**
     * Handles processing the next appointment in the queue.
     */
    private void processNextAppointment() {
        Appointment nextAppointment = appointmentQueue.poll(); // Get and remove the head of the queue

        if (nextAppointment == null) {
            System.out.println("--- Waiting Queue ---");
            System.out.println("Queue is empty. No appointments to process.");
            System.out.println("---");
        } else {
            System.out.println("Processing appointment: " + nextAppointment);
        }
    }

    /**
     * Handles viewing all appointments currently in the waiting queue.
     */
    private void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (appointmentQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            int i = 1;
            // Iterate through the queue without removing elements
            for (Appointment appt : appointmentQueue) {
                System.out.println(i++ + ". " + appt);
            }
        }
        System.out.println("---");
    }

    /**
     * Handles viewing the list of available doctors.
     */
    private void viewDoctors() {
        System.out.println("--- Available Doctors ---");
        if (doctors.isEmpty()) {
            System.out.println("No doctors available.");
        } else {
            for (Doctor doc : doctors) {
                System.out.println(doc); // Uses Doctor's toString() method
            }
        }
        System.out.println("---");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                String choiceStr = scanner.nextLine(); // Read choice as string to avoid InputMismatchException on non-numeric input
                int choice = -1; // Default invalid choice

                // Attempt to parse the choice string to an integer
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // If parsing fails, choice remains -1, triggering the default case
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        scheduleAppointment();
                        break;
                    case 2:
                        processNextAppointment();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewDoctors();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting scheduler.");
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed regardless of exceptions or exit
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run(); // Start the application
    }
}
