/*
 * Exam Question #907
 * Generated on: 2025-05-12 16:57:56
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Request Processing System
 * 
 * **Objective:** Design and implement a text-based application to manage customer service requests, demonstrating advanced understanding of Java collections, input handling, control flow, and error management.
 * 
 * **Scenario:** You are building a simplified system for a customer service department. Incoming requests are placed in a queue to be handled by agents. The system needs to track all requests, allow agents to process the next available request, and enable viewing requests by status.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:** Create the following classes:
 *     *   `RequestStatus`: An `enum` with states like `PENDING`, `PROCESSING`, `COMPLETED`.
 *     *   `Request`: Represents a single customer request. It must have private fields for `id` (auto-generated unique integer starting from 1), `description` (String), `type` (String, e.g., "Technical", "Billing"), and `status` (`RequestStatus`). Include a constructor and public getter methods for all fields, and a public setter specifically for the `status`. Override `toString()` for easy printing.
 *     *   `RequestService`: Manages the collections of requests. It must contain:
 *         *   A `Queue<Request>` to hold requests that are currently `PENDING`. Use a concrete implementation like `LinkedList`.
 *         *   A `List<Request>` to hold *all* requests ever submitted, regardless of status. Use a concrete implementation like `ArrayList`.
 *         *   Public methods:
 *             *   `submitRequest(String description, String type)`: Creates a new `Request` object, sets its initial status to `PENDING`, adds it to both the pending queue and the master list of all requests. Returns the ID of the newly created request. Must validate input (description and type cannot be empty).
 *             *   `processNextRequest()`: Removes the oldest request from the pending queue. Updates its status to `COMPLETED` (or `PROCESSING` then `COMPLETED`) within the master list. Returns the processed `Request` object. Must handle the case where the queue is empty.
 *             *   `getAllRequests()`: Returns the `List` containing all requests.
 *             *   `getPendingRequests()`: Returns a `List` containing only the requests currently in the pending queue (do not return the queue object itself directly).
 *     *   `ServiceSystem`: The main class with the `main` method to run the application.
 * 
 * 2.  **Main Application Flow (`ServiceSystem`):**
 *     *   Implement a text-based menu using `System.out` for options:
 *         1.  Submit New Request
 *         2.  Process Next Request
 *         3.  View All Requests
 *         4.  View Pending Requests
 *         5.  Exit
 *     *   Use `Scanner` to read user input for menu choices and request details.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 3.  **Required Java Components:** You **must** use and demonstrate the practical use of **ALL** of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for normal output)
 *     *   Class-wide or main loop exception handling using `try-catch` blocks, in addition to specific error handling where necessary (e.g., input validation, empty queue).
 * 
 * 4.  **Best Practices:**
 *     *   Adhere to principles of encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for methods).
 *     *   Implement input validation (e.g., menu choice is an integer, request details are not empty strings).
 *     *   Provide proper error handling using `try-catch` and inform the user via `System.err`. Handle potential `InputMismatchException` from `Scanner`. Handle attempts to process when the queue is empty.
 *     *   Structure the code cleanly across the defined classes.
 * 
 * **Expected Output:** The output should be interactive, guiding the user through the menu options. Examples:
 * *   Displaying the menu.
 * *   Prompts for request description and type when submitting.
 * *   Confirmation message with Request ID upon successful submission.
 * *   Message indicating which request was processed, or that the queue is empty.
 * *   Listing all requests with their details (ID, Type, Status, Desc).
 * *   Listing only pending requests.
 * *   Error messages printed to `System.err` for invalid input or actions (e.g., non-integer choice, empty description, processing an empty queue).
 * *   An unexpected error message if a general exception is caught.
 * 
 * **Evaluation:** Your solution will be evaluated on correctness, adherence to all requirements (especially the use of specified components), code quality, error handling, and clarity.
 * 
 * ```
 * Example Interaction:
 * --- Customer Service Request Processing System ---
 * Please choose an option:
 * 1. Submit New Request
 * ...
 * Enter choice: 1
 * 
 * --- Submit New Request ---
 * Enter request description: My internet is down.
 * Enter request type (e.g., Technical, Billing, General): Technical
 * Request submitted successfully! Your Request ID is: 1
 * 
 * Please choose an option:
 * ...
 * Enter choice: 4
 * 
 * --- Pending Requests ---
 * Request [ID=1, Type=Technical, Status=PENDING, Desc='My internet is down.']
 * 
 * Please choose an option:
 * ...
 * Enter choice: 2
 * 
 * --- Process Next Request ---
 * Successfully processed request:
 * Request [ID=1, Type=Technical, Status=COMPLETED, Desc='My internet is down.']
 * 
 * Please choose an option:
 * ...
 * Enter choice: 4
 * 
 * --- Pending Requests ---
 * No requests are currently pending.
 * 
 * Please choose an option:
 * ...
 * Enter choice: 3
 * 
 * --- All Requests ---
 * Request [ID=1, Type=Technical, Status=COMPLETED, Desc='My internet is down.']
 * 
 * Please choose an option:
 * ...
 * Enter choice: abc
 * Invalid input. Please enter an integer.
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Please choose an option:
 * ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Note:** Focus on demonstrating the required Java features in a functional system. You do not need to implement complex threading, database persistence, or advanced UI.
 *
 * EXPLANATION:
 * This solution implements the Customer Service Request Processing System as described in the exam question, incorporating all required Java components and best practices.
 * 
 * 1.  **Class Structure:** The problem is broken down into four classes (`RequestStatus`, `Request`, `RequestService`, `ServiceSystem`), promoting modularity and organization.
 *     *   `RequestStatus` enum provides a clear and type-safe way to represent the status of a request.
 *     *   `Request` is a simple data class with an auto-incrementing ID, encapsulating request data.
 *     *   `RequestService` acts as the core logic handler, managing the collections and operations on requests.
 *     *   `ServiceSystem` contains the `main` method, handling user interaction via the menu.
 * 
 * 2.  **Collections Usage:**
 *     *   `java.util.Queue`: The `pendingRequests` field in `RequestService` is declared as `Queue<Request>` and instantiated with `LinkedList`. The `offer()` method is used to add new requests to the end of the queue, and `poll()` is used to retrieve and remove the oldest request from the front, correctly implementing FIFO behavior for pending requests.
 *     *   `java.util.ArrayList`: The `allRequests` field in `RequestService` is declared as `List<Request>` and instantiated with `ArrayList`. This list serves as a master record of all requests, regardless of their status. `ArrayList` is suitable here for storing and iterating over all items.
 *     *   `java.util.List interface`: Both `allRequests` and the return types of `getAllRequests()` and `getPendingRequests()` are declared using the `List` interface. This demonstrates programming to interfaces, which is a good practice. `getPendingRequests()` explicitly creates a new `ArrayList` and populates it from the queue's iterator, as the `Queue` interface itself doesn't provide a direct `List` view.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `java.util.Scanner`: A `Scanner` object is used in the `ServiceSystem` class to read user input from `System.in` for menu choices and request details.
 *     *   `switch` statement: The main menu logic in `ServiceSystem.main()` uses a `switch` statement to direct execution based on the integer choice returned by `getUserChoice()`.
 *     *   The main application loop runs within a `while(running)` loop controlled by the "Exit" option (`case 5`).
 * 
 * 4.  **Error Handling and Output:**
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input (`InputMismatchException` caught in `getUserChoice`), validation failures (`IllegalArgumentException` caught in `submitNewRequest`), or unexpected issues caught by general `try-catch` blocks. This distinguishes error output from normal program output.
 *     *   `System.out`: Used for all standard output, including the menu, prompts, success messages, and displaying request details.
 *     *   `try-catch` blocks:
 *         *   A general `try-catch(Exception e)` block surrounds the main `while` loop in `ServiceSystem.main()`. This acts as a safety net for any unhandled exceptions that might occur during the program's execution, preventing the program from crashing abruptly.
 *         *   Specific `try-catch` blocks are used where particular exceptions are expected: `getUserChoice()` catches `InputMismatchException` for non-integer input, and `submitNewRequest()` catches `IllegalArgumentException` thrown by `RequestService.submitRequest()` for invalid (empty) description/type.
 *         *   Input validation is performed in `RequestService.submitRequest()` by checking if description/type are null or empty and throwing an `IllegalArgumentException`.
 *         *   The `processNextRequest()` method handles the case of an empty queue by checking if `queue.poll()` returns `null`.
 * 
 * 5.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Class fields are `private`, accessed via `public` getters and controlled setters (`setStatus`).
 *     *   **Meaningful Names:** Variables (`pendingRequests`, `allRequests`, `description`, `type`, `choice`), methods (`submitRequest`, `processNextRequest`, `viewAllRequests`, `getUserChoice`), and the enum (`RequestStatus`) have descriptive names.
 *     *   **Comments/Documentation:** Basic Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** Checks for empty strings in request details and non-integer input for the menu choice are implemented.
 *     *   **Scanner Handling:** The `finally` block in `getUserChoice()` correctly consumes the newline character left by `nextInt()`, preventing issues when `nextLine()` is called subsequently. The `Scanner` is closed in a `finally` block in `main` to ensure resources are released.
 * 
 * This solution effectively combines various core Java concepts to build a functional, albeit simple, application that meets all the specified requirements, demonstrating a solid understanding of Java programming principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for request status
enum RequestStatus {
    PENDING, PROCESSING, COMPLETED
}

// Class representing a customer request
class Request {
    private static int nextId = 1; // Auto-generate unique IDs
    private int id;
    private String description;
    private String type;
    private RequestStatus status;

    /**
     * Constructs a new Request with PENDING status.
     * @param description The request description.
     * @param type The request type.
     */
    public Request(String description, String type) {
        this.id = nextId++;
        this.description = description;
        this.type = type;
        this.status = RequestStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    public RequestStatus getStatus() {
        return status;
    }

    // --- Setter for status (controlled access) ---
    public void setStatus(RequestStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Request [ID=" + id + ", Type=" + type + ", Status=" + status + ", Desc='" + description + "']";
    }
}

// Class to manage the collections of requests
class RequestService {
    // Queue for pending requests (FIFO processing)
    private Queue<Request> pendingRequests;
    // List for all requests (history)
    private List<Request> allRequests;

    /**
     * Constructs a new RequestService.
     */
    public RequestService() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.allRequests = new ArrayList<>();
    }

    /**
     * Submits a new request to the system.
     * Adds the request to the pending queue and the master list.
     * @param description The request description.
     * @param type The request type.
     * @return The ID of the newly submitted request.
     * @throws IllegalArgumentException if description or type is null or empty.
     */
    public int submitRequest(String description, String type) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Request type cannot be empty.");
        }

        Request newRequest = new Request(description.trim(), type.trim());
        pendingRequests.offer(newRequest); // Add to the end of the queue
        allRequests.add(newRequest);     // Add to the master list
        return newRequest.getId();
    }

    /**
     * Processes the next request from the pending queue.
     * Updates the status of the processed request in the master list to COMPLETED.
     * @return The Request object that was processed, or null if the pending queue is empty.
     */
    public Request processNextRequest() {
        Request requestToProcess = pendingRequests.poll(); // Retrieve and remove the head of the queue

        if (requestToProcess != null) {
            // Find the request in the allRequests list and update its status
            // We need to iterate because the queue holds references to the same objects in the list
            for (Request req : allRequests) {
                if (req.getId() == requestToProcess.getId()) {
                    // Optional: req.setStatus(RequestStatus.PROCESSING); // Simulate processing state briefly
                    req.setStatus(RequestStatus.COMPLETED); // Set to completed
                    return req; // Return the updated request
                }
            }
            // This part should ideally not be reached if the request came from the queue
            // and the queue elements are guaranteed to be in the allRequests list.
            System.err.println("Internal Error: Processed request not found in master list!");
            return null; // Indicate an internal issue
        } else {
            return null; // No pending requests
        }
    }

    /**
     * Gets a list of all requests ever submitted.
     * @return A List containing all requests.
     */
    public List<Request> getAllRequests() {
        // Returning the reference to the internal list.
        // For production code, consider returning an unmodifiable list or a copy
        // to prevent external modification of the internal state.
        return allRequests;
    }

    /**
     * Gets a list of all requests currently in the pending queue.
     * Creates a new list by iterating through the queue elements.
     * @return A List containing all pending requests.
     */
    public List<Request> getPendingRequests() {
        // Queue does not directly provide a List view.
        // Iterate through the queue and add elements to a new List.
        List<Request> pendingList = new ArrayList<>();
        // The iterator for LinkedList (used as Queue) follows insertion order (FIFO)
        for (Request req : pendingRequests) {
            pendingList.add(req);
        }
        return pendingList;
    }
}

// Main application class
public class ServiceSystem {

    private static RequestService requestService = new RequestService();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Customer Service Request Processing System ---");
        boolean running = true;

        // --- Class-wide exception handling for the main application loop ---
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice(); // Handles InputMismatchException internally

                // --- Switch statement for menu control ---
                switch (choice) {
                    case 1:
                        submitNewRequest();
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewAllRequests();
                        break;
                    case 4:
                        viewPendingRequests();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range (after getUserChoice returns -1 or valid int)
                        if (choice != -1) { // Avoid printing this after InputMismatchException handled by getUserChoice
                             System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        }
                        break;
                }
                System.out.println(); // Add a blank line for readability between interactions
            }
        } catch (Exception e) {
            // --- Catch any unexpected exceptions during the main loop execution ---
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes in an exam
        } finally {
            // --- Ensure scanner is closed properly ---
            if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Submit New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View All Requests");
        System.out.println("4. View Pending Requests");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input using try-catch.
     * @return The valid integer choice, or -1 if input was invalid.
     */
    private static int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // --- Use System.err for input error messages ---
            System.err.println("Invalid input. Please enter an integer.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        } finally {
             // Consume the rest of the line (including the newline character)
             // left by nextInt() or next(). This is crucial before subsequent nextLine() calls.
             scanner.nextLine();
        }
        return choice;
    }

    /**
     * Handles the process of submitting a new request based on user input.
     * Includes specific try-catch for submission validation errors.
     */
    private static void submitNewRequest() {
        System.out.println("\n--- Submit New Request ---");
        System.out.print("Enter request description: ");
        // Use nextLine() to read the whole line after consuming newline in getUserChoice's finally block
        String description = scanner.nextLine();

        System.out.print("Enter request type (e.g., Technical, Billing, General): ");
        String type = scanner.nextLine();

        try {
            int requestId = requestService.submitRequest(description, type);
            System.out.println("Request submitted successfully! Your Request ID is: " + requestId);
        } catch (IllegalArgumentException e) {
            // --- Use System.err for validation errors ---
            System.err.println("Submission failed: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during submission
             System.err.println("An unexpected error occurred during submission: " + e.getMessage());
        }
    }

    /**
     * Handles processing the next pending request.
     * Reports success or if no requests are pending.
     */
    private static void processNextRequest() {
        System.out.println("\n--- Process Next Request ---");
        try {
            Request processedRequest = requestService.processNextRequest();
            if (processedRequest != null) {
                System.out.println("Successfully processed request:");
                System.out.println(processedRequest); // Uses Request's toString()
            } else {
                // --- Use System.out for informational messages like empty queue ---
                System.out.println("No pending requests to process.");
            }
        } catch (Exception e) {
             // Catch any unexpected errors during processing
             System.err.println("An unexpected error occurred during processing: " + e.getMessage());
        }
    }

    /**
     * Displays all requests submitted so far.
     */
    private static void viewAllRequests() {
        System.out.println("\n--- All Requests ---");
        List<Request> all = requestService.getAllRequests();
        if (all.isEmpty()) {
            System.out.println("No requests have been submitted yet.");
        } else {
            for (Request req : all) {
                System.out.println(req); // Uses Request's toString()
            }
        }
    }

    /**
     * Displays requests that are currently pending in the queue.
     */
    private static void viewPendingRequests() {
        System.out.println("\n--- Pending Requests ---");
        List<Request> pending = requestService.getPendingRequests();
        if (pending.isEmpty()) {
            System.out.println("No requests are currently pending.");
        } else {
            for (Request req : pending) {
                System.out.println(req); // Uses Request's toString()
            }
        }
    }
}
