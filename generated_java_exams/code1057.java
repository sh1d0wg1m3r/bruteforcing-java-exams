/*
 * Exam Question #1057
 * Generated on: 2025-05-12 17:19:00
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based Task Management System for a small team. The system needs to keep track of tasks, allow new tasks to be added, process tasks when they are completed, and provide views of both pending and all historical tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:**
 *     *   Create a `public` class named `Task`.
 *     *   The `Task` class must have the following `private` fields:
 *         *   An integer `id` that is automatically generated and unique for each new task (starting from 1).
 *         *   A `String` `description` for the task.
 *         *   A `TaskStatus` representing the current status of the task.
 *     *   Define a `public enum TaskStatus` with two values: `PENDING` and `COMPLETED`.
 *     *   Implement a constructor `public Task(String description)` that initializes the description and sets the status to `PENDING`. The ID should be generated automatically within the constructor.
 *     *   Provide `public` getter methods for `id`, `description`, and `status`.
 *     *   Provide a `public` setter method `setStatus(TaskStatus status)` to update the task's status.
 *     *   Override the `toString()` method to provide a clear string representation of a task (e.g., "Task [ID=..., Description='...', Status=...]").
 * 
 * 2.  **Data Management:**
 *     *   In your main class (e.g., `TaskManagementSystem`), maintain two data structures:
 *         *   A `Queue<Task>` named `pendingTasks` to store tasks that are currently waiting to be processed.
 *         *   A `List<Task>` named `allTasks` to store *every* task that has ever been created, regardless of its current status. Use `java.util.ArrayList` for the implementation of the `List`.
 *     *   When a new task is created, it must be added to both the `allTasks` `List` and the `pendingTasks` `Queue`.
 *     *   When a task is processed, it must be removed from the `pendingTasks` `Queue`, and its status in the `allTasks` `List` must be updated to `COMPLETED`.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   Implement a text-based menu using `System.out` that presents the following options:
 *         1.  Add New Task
 *         2.  Process Next Pending Task
 *         3.  View All Tasks
 *         4.  View Pending Tasks
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read the user's menu choice and task descriptions from standard input.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   The program should run in a loop until the user chooses to exit.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Use `System.err` to print all error messages.
 *     *   Implement input validation:
 *         *   Ensure the user enters a valid integer for the menu choice. Handle `InputMismatchException`.
 *         *   Handle cases where the user enters an invalid menu number.
 *         *   Ensure the task description is not empty when adding a task.
 *     *   Handle the case where the user tries to process a task when the `pendingTasks` `Queue` is empty. Print an informative error message using `System.err`.
 *     *   Include **class-wide exception handling** using `try-catch` blocks to catch and report any unexpected errors that might occur during the system's operation. A single `try-catch(Exception e)` block around the main application loop is acceptable for this requirement, in addition to specific input handling.
 * 
 * 5.  **Required Java Components:**
 *     *   Your solution *must* explicitly use and demonstrate the functionality of:
 *         *   `java.util.Queue`
 *         *   `java.util.ArrayList`
 *         *   `java.util.List` (declared as `List` type)
 *         *   `java.util.Scanner`
 *         *   `switch` statement
 *         *   `System.err`
 *         *   `System.out`
 *         *   `try-catch` blocks (including a general `catch(Exception)` for class-wide handling)
 * 
 * 6.  **Code Quality:**
 *     *   Adhere to best practices: proper encapsulation, meaningful variable/method names, appropriate comments.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output Interaction:**
 * 
 * The output should guide the user through the menu options and display task information or error messages based on their input. An example interaction flow is provided in the thought process above and should be reproducible by your code.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of the Task class and its methods.
 * *   Correct usage of `Queue` and `List` for managing task data as specified.
 * *   Accurate implementation of menu options using `Scanner` and `switch`.
 * *   Robust input validation and error handling using `System.err`.
 * *   Presence and correct usage of class-wide `try-catch` exception handling.
 * *   Adherence to all specified Java component requirements.
 * *   Code structure, readability, encapsulation, and naming conventions.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class represents a single task. It uses `private` fields (`id`, `description`, `status`) and `public` getters for encapsulation. An `enum` (`TaskStatus`) is used for task states, which is a good practice for representing a fixed set of constants. The `id` is automatically generated using `AtomicInteger` to ensure uniqueness, even though the system is single-threaded, it's a robust approach. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **Data Structures (`TaskManagementSystem` class):**
 *     *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing methods like `offer()` to add elements to the end and `poll()` to remove elements from the front. This structure correctly models a waiting line of tasks.
 *     *   `allTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` provides a dynamic, resizable array that is suitable for storing all tasks created, allowing easy iteration over the complete history of tasks.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   `printMenu()` displays the available options using `System.out`.
 *     *   `Scanner` is used to read user input. `scanner.nextInt()` reads the choice, and `scanner.nextLine()` is used afterwards to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls when reading the description.
 *     *   A `switch` statement based on the user's `choice` directs the program flow to the appropriate handler method (`addTask`, `processNextTask`, etc.).
 * 
 * 4.  **Error Handling and Validation:**
 *     *   **Input Validation:**
 *         *   A `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice. `System.err.println()` is used for the error message, and `scanner.nextLine()` is called within the catch block to consume the invalid input, preventing an infinite loop.
 *         *   In `addTask()`, `description.isEmpty()` checks for an empty task description. `System.err.println()` is used for the validation error message.
 *         *   The `default` case in the `switch` statement handles invalid menu numbers, printing an error to `System.err`.
 *     *   **Operational Error Handling:**
 *         *   In `processNextTask()`, `pendingTasks.isEmpty()` checks if there are tasks to process before calling `poll()`. An error message is printed to `System.err` if the queue is empty.
 *     *   **Class-wide Exception Handling:** A broad `try-catch(Exception e)` block wraps the entire `while(running)` loop in the `run()` method. This serves as a catch-all for any unexpected runtime exceptions that might occur, printing an error message to `System.err`. This fulfills the requirement for class-wide handling of unforeseen issues.
 *     *   **Resource Management:** The `finally` block ensures that the `scanner.close()` method is called when the `try` block is exited, whether normally or due to an exception, releasing the system resource.
 * 
 * 5.  **Component Usage:**
 *     *   `Queue` is used for `pendingTasks` (`offer`, `poll`, iteration).
 *     *   `ArrayList` is used for `allTasks`.
 *     *   `List` is used as the type declaration for `allTasks`.
 *     *   `Scanner` is used for all user input.
 *     *   `switch` statement controls the main menu flow.
 *     *   `System.err` is exclusively used for error reporting.
 *     *   `System.out` is used for normal program output (menu, prompts, success messages, task listings).
 *     *   `try-catch` blocks are used for both specific input handling and general exception handling around the main loop.
 * 
 * 6.  **Best Practices:** The code follows encapsulation principles, uses clear and descriptive names for variables and methods, includes comments explaining key parts, and handles basic input validation and error conditions gracefully, directing errors to `System.err`.
 * 
 * This solution effectively combines the required data structures and control flow mechanisms to create a functional, albeit simple, task management system, demonstrating a solid understanding of core Java concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.concurrent.atomic.AtomicInteger; // For unique task ID

// Represents the status of a task
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task in the system
class Task {
    // Use AtomicInteger for thread-safe unique ID generation (good practice)
    private static final AtomicInteger count = new AtomicInteger(0);
    private int id;
    private String description;
    private TaskStatus status;

    // Constructor to create a new task
    public Task(String description) {
        // Automatically generate a unique ID for each new task
        this.id = count.incrementAndGet();
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending initially
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for status (needed when processing) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    // --- toString method for easy printing ---
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Main class for the Task Management System
public class TaskManagementSystem {

    // Queue to hold tasks that are currently pending processing
    private Queue<Task> pendingTasks;
    // List to hold all tasks ever created (both pending and completed)
    private List<Task> allTasks;
    // Scanner for reading user input
    private Scanner scanner;

    // Constructor to initialize data structures and scanner
    public TaskManagementSystem() {
        // LinkedList implements the Queue interface and maintains insertion order
        this.pendingTasks = new LinkedList<>();
        // ArrayList implements the List interface
        this.allTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Main method to run the task management system
    public void run() {
        boolean running = true;

        // Class-wide exception handling for unexpected errors during system operation
        try {
            while (running) {
                printMenu();
                int choice = -1;

                // Specific exception handling for input errors (non-integer input)
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    // Use System.err for error messages
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Switch statement for handling user menu choices
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewAllTasks();
                        break;
                    case 4:
                        viewPendingTasks();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the program's execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace to error stream for debugging
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Prints the main menu options to System.out
    private void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Exit");
        System.out.println("--------------------------");
    }

    // Handles adding a new task based on user input
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read the description and remove leading/trailing whitespace

        // Input validation: Check if description is empty
        if (description.isEmpty()) {
            System.err.println("Task description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(description);
        allTasks.add(newTask); // Add the new task to the list of all tasks
        pendingTasks.offer(newTask); // Add the new task to the queue of pending tasks (offer is preferred over add for queues)

        System.out.println("Task added successfully: " + newTask.getDescription());
    }

    // Handles processing the next task from the pending queue
    private void processNextTask() {
        // Check if the pending tasks queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to process.");
            return; // Exit the method if there are no pending tasks
        }

        // Get and remove the next task from the front of the queue
        Task taskToProcess = pendingTasks.poll();

        // Update the status of this task in the allTasks list
        // Iterate through the list to find the task by its ID
        boolean foundAndUpdated = false;
        for (Task task : allTasks) { // Iterating through the List
            if (task.getId() == taskToProcess.getId()) {
                task.setStatus(TaskStatus.COMPLETED); // Update the status
                foundAndUpdated = true;
                break; // Found the task, no need to continue the loop
            }
        }

        // This check is a safeguard for logic errors
        if (foundAndUpdated) {
            System.out.println("Processed task: " + taskToProcess.getDescription());
        } else {
            // Should theoretically not happen if tasks are managed correctly
            System.err.println("Error: Processed task not found in all tasks list (ID: " + taskToProcess.getId() + ").");
        }
    }

    // Displays all tasks (pending and completed) from the list
    private void viewAllTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been created yet.");
        } else {
            // Iterate through the List of all tasks
            for (Task task : allTasks) {
                System.out.println(task); // Uses Task's toString() method
            }
        }
        System.out.println("-----------------");
    }

    // Displays only the tasks currently in the pending queue
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            // Iterate through the elements of the Queue to display them
            // Note: Iteration order might vary depending on Queue implementation,
            // but LinkedList (used here) maintains insertion order.
            for (Task task : pendingTasks) { // Iterating through the Queue
                System.out.println(task); // Uses Task's toString() method
            }
        }
        System.out.println("---------------------");
    }

    // Entry point of the program
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run(); // Start the system
    }
}
