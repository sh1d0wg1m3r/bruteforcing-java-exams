/*
 * Exam Question #1168
 * Generated on: 2025-05-12 17:34:17
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Ticket Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Technical Support Ticket Management System. The system should allow users (simulated via console input) to perform basic operations: adding new support tickets, processing the next available ticket, viewing the list of pending tickets, and viewing a history of all tickets (including resolved ones).
 * 
 * The system must adhere to the following specific implementation requirements and best practices.
 * 
 * **System Functionality:**
 * 
 * 1.  **Add Ticket:** Allows the user to submit a new support ticket by providing a description. The system should automatically assign a unique integer ID to each ticket, starting from 1. New tickets are initially in a "PENDING" state and are added to a queue for processing.
 * 2.  **Process Ticket:** Takes the next ticket from the front of the pending queue. If a ticket is successfully retrieved, its status should be updated to "RESOLVED". If the queue is empty, an appropriate message should be displayed.
 * 3.  **View Pending Tickets:** Displays a list of all tickets currently in the pending queue.
 * 4.  **View All Tickets:** Displays a list of all tickets ever submitted to the system, including both "PENDING" and "RESOLVED" ones.
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * 
 * You MUST use **ALL** of the following Java components in your solution:
 * 
 * *   `java.util.Queue`: To manage the collection of tickets awaiting processing (the pending queue).
 * *   `java.util.ArrayList`: To store a history of all tickets ever created in the system.
 * *   `java.util.List`: Declare the variable holding the history of all tickets using the `List` interface type, instantiated as an `ArrayList`.
 * *   `java.util.Scanner`: To read user input from the console (menu choices and ticket descriptions).
 * *   `switch` statement: To handle the user's menu selection.
 * *   `System.err`: To print error messages (e.g., invalid input, attempting to process an empty queue).
 * *   `System.out`: To print normal output (menu, prompts, ticket information, success messages).
 * *   Class-wide exception handling with `try-catch` blocks: Implement a top-level `try-catch` block in your `main` method or the primary operational loop to gracefully handle unexpected exceptions during execution, printing an error using `System.err`.
 * 
 * **Best Practices & Constraints:**
 * 
 * *   **Encapsulation:** Design a `Ticket` class with private fields (ID, description, status) and public methods (getters, potentially a setter for status). The `SupportSystem` class managing the collections should also use private fields for its collections.
 * *   **Meaningful Names:** Use descriptive names for classes, variables, and methods.
 * *   **Comments:** Include comments where necessary to explain complex logic or parts of the system.
 * *   **Input Validation:** Handle cases where the user enters non-numeric input for menu choices or empty strings for ticket descriptions.
 * *   **Error Handling:** Provide informative messages for errors, using `System.err`.
 * *   **Clean Code:** Structure your code logically into appropriate classes.
 * *   The system should run in a loop until the user chooses to exit.
 * 
 * **Menu:**
 * 
 * The system should present the following menu to the user:
 * 
 * ```
 * Technical Support Ticket System
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * **Expected Output Examples:**
 * 
 * *   **Adding a ticket:**
 *     ```
 *     Enter ticket description: My printer is broken
 *     Ticket #1 added.
 *     ```
 * *   **Processing a ticket:**
 *     ```
 *     Processing next ticket...
 *     Ticket #1 (My printer is broken) resolved.
 *     ```
 * *   **Processing with empty queue:**
 *     ```
 *     Processing next ticket...
 *     No pending tickets to process.
 *     ```
 * *   **Viewing Pending:**
 *     ```
 *     --- Pending Tickets ---
 *     Ticket #2: Software installation failed
 *     Ticket #3: Network connection issues
 *     -----------------------
 *     ```
 * *   **Viewing All:**
 *     ```
 *     --- All Tickets ---
 *     Ticket #1: My printer is broken [RESOLVED]
 *     Ticket #2: Software installation failed [PENDING]
 *     Ticket #3: Network connection issues [PENDING]
 *     -------------------
 *     ```
 * *   **Invalid Menu Input:**
 *     ```
 *     Invalid input. Please enter a number between 1 and 5.
 *     ```
 * *   **Unexpected Error:**
 *     ```
 *     An unexpected error occurred: [Error details]
 *     ```
 * 
 * **Task:**
 * 
 * Write the complete Java code for this Technical Support Ticket Management System, ensuring all specified requirements and best practices are met.
 *
 * EXPLANATION:
 * This solution implements the Technical Support Ticket Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `pendingTickets` variable in the `SupportSystem` class is declared as a `Queue<Ticket>` and instantiated using `new LinkedList<>()`. A `Queue` is appropriate here because tickets are processed in the order they are received (First-In, First-Out or FIFO).
 *     *   `offer()`: Used in `addTicket` to add a new ticket to the end of the queue.
 *     *   `poll()`: Used in `processNextTicket` to retrieve and remove the ticket at the head of the queue.
 *     *   `isEmpty()`: Used in `viewPendingTickets` to check if the queue has any tickets.
 *     *   Iteration: The enhanced for loop in `viewPendingTickets` iterates through the queue elements without removing them, suitable for viewing.
 * 
 * 2.  **`java.util.ArrayList`**: The `allTickets` variable in the `SupportSystem` class is instantiated as `new ArrayList<>()`. An `ArrayList` is suitable for storing a dynamic list of *all* tickets, allowing easy iteration and access to the full history.
 * 
 * 3.  **`java.util.List`**: The `allTickets` variable is *declared* using the `List` interface type (`private List<Ticket> allTickets;`). This adheres to the principle of programming to interfaces, making the code more flexible if a different `List` implementation were needed later. It is then instantiated with `ArrayList`.
 * 
 * 4.  **`java.util.Scanner`**: An instance of `Scanner` is created in the `main` method (`Scanner scanner = new Scanner(System.in);`) to read user input from the console for menu choices and ticket descriptions.
 *     *   `nextInt()`: Used to read the integer menu choice.
 *     *   `nextLine()`: Used to read the ticket description and to consume the newline character left by `nextInt()`.
 * 
 * 5.  **`switch` statement**: A `switch` statement in the `main` method is used to handle the integer input from the user, directing the program flow to the corresponding action (add, process, view, exit).
 * 
 * 6.  **`System.err`**: Used for printing error messages, such as when the user enters invalid input for the menu choice (`InputMismatchException` catch block and the `default` case in the `switch`) or when a ticket description is empty (`addTicket` method validation). It's also used in the top-level `catch` block for unexpected errors.
 * 
 * 7.  **`System.out`**: Used for all standard output, including printing the menu, prompts for input, success messages (ticket added, ticket resolved), and displaying the lists of tickets.
 * 
 * 8.  **Class-wide exception handling with `try-catch`**: The core application loop in the `main` method is wrapped in a `try-catch (Exception e)` block. This provides a top-level handler for any unhandled exceptions that might occur within the loop, printing a generic error message using `System.err` before the program potentially terminates (or continues, depending on the exception and logic). A specific `catch (InputMismatchException e)` is also included *inside* the loop's `try` block to handle non-integer menu input more gracefully and allow the loop to continue. The `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Ticket` class has private fields (`id`, `description`, `status`) and public methods (`getId`, `getDescription`, `getStatus`, `setStatus`, `toString`) to control access to its data. The `SupportSystem` class also uses private fields for its collections (`pendingTickets`, `allTickets`, `nextTicketId`).
 * *   **Meaningful Names:** Variables like `pendingTickets`, `allTickets`, `nextTicketId`, `description`, `choice`, and methods like `addTicket`, `processNextTicket`, `viewPendingTickets`, `viewAllTickets`, `printMenu` are clearly named reflecting their purpose.
 * *   **Comments:** Comments are included to explain the purpose of classes, fields, methods, and specific code blocks (like the `InputMismatchException` handling).
 * *   **Input Validation:** The `addTicket` method checks if the description is null or empty/whitespace. The `InputMismatchException` handling explicitly validates that the menu input is an integer. The `switch` `default` case handles valid integers outside the 1-5 range.
 * *   **Error Handling:** Specific error messages are provided for different failure conditions (empty description, invalid menu input, empty queue for processing, unexpected system errors). `System.err` is used appropriately for errors.
 * *   **Clean Code:** The code is structured into logical classes (`Ticket`, `SupportSystem`, `SupportSystemApp`). The `main` method handles user interaction and delegates business logic to the `SupportSystem` class. A separate `printMenu` helper method improves readability.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-integer input

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "RESOLVED"

    // Constructor
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // New tickets are pending by default
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Ticket #" + id + ": " + description + " [" + status + "]";
    }
}

// Manages the collections of tickets and system operations
class SupportSystem {
    // Queue for tickets waiting to be processed
    private Queue<Ticket> pendingTickets;
    // List to store all tickets ever created (for history)
    private List<Ticket> allTickets;
    // Counter for unique ticket IDs
    private int nextTicketId;

    // Constructor
    public SupportSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.allTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the system.
     * @param description The description of the issue.
     */
    public void addTicket(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }

        Ticket newTicket = new Ticket(nextTicketId, description.trim());
        pendingTickets.offer(newTicket); // Add to the end of the queue
        allTickets.add(newTicket); // Add to the history list
        System.out.println("Ticket #" + nextTicketId + " added.");
        nextTicketId++; // Increment for the next ticket
    }

    /**
     * Processes the next ticket in the pending queue.
     */
    public void processNextTicket() {
        System.out.println("Processing next ticket...");
        Ticket ticketToProcess = pendingTickets.poll(); // Retrieve and remove the head of the queue

        if (ticketToProcess != null) {
            // Find the ticket in the allTickets list and update its status
            // In a real system, you might find by ID, but since we added the same object,
            // we can just update the status of the object retrieved from the queue.
            // Because List and Queue hold references to the *same* Ticket objects,
            // updating the status on the object polled from the queue also updates it
            // in the allTickets list.
            ticketToProcess.setStatus("RESOLVED");
            System.out.println(ticketToProcess.getDescription() + " resolved.");
        } else {
            System.out.println("No pending tickets to process.");
        }
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                // Note: The status shown here will always be "PENDING" as per the queue's purpose
                System.out.println("Ticket #" + ticket.getId() + ": " + ticket.getDescription());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets ever created in the system.
     */
    public void viewAllTickets() {
        System.out.println("\n--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets have been created yet.");
        } else {
            // Iterate through the list of all tickets
            for (Ticket ticket : allTickets) {
                System.out.println(ticket); // Uses Ticket's toString() method
            }
        }
        System.out.println("-------------------");
    }
}

// Main class to run the system with user interaction
public class SupportSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem();
        boolean running = true;

        // Top-level try-catch for class-wide exception handling
        try {
            while (running) {
                printMenu();

                int choice = -1; // Default invalid choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        system.addTicket(description);
                        break;
                    case 2:
                        system.processNextTicket();
                        break;
                    case 3:
                        system.viewPendingTickets();
                        break;
                    case 4:
                        system.viewAllTickets();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Technical Support Ticket System");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View All Tickets");
        System.out.println("5. Exit");
    }
}
