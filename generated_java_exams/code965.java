/*
 * Exam Question #965
 * Generated on: 2025-05-12 17:06:09
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Management Simulator
 * 
 * **Objective:** Implement a command-line application that simulates a simplified production line's task management system. The application should allow users to add new tasks, process the next available task, and view lists of tasks that are pending or have been completed, demonstrating proficiency in core Java concepts and data structures.
 * 
 * **Scenario:** Imagine a production line where tasks arrive and are queued up for processing by workers. Once a task is processed, it moves to a list of completed tasks. Your system will simulate this flow.
 * 
 * **Detailed Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple Java class named `Task`.
 *     *   It must have private fields for a unique integer `id` and a `String` `description`.
 *     *   Implement a constructor to initialize these fields.
 *     *   Provide public getter methods for `id` and `description`.
 *     *   Ensure proper encapsulation.
 * 
 * 2.  **Production Line Management:** Create a class named `ProductionLine`.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks). The queue should follow a First-In, First-Out (FIFO) order. You can use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *     *   It must use a `java.util.List<Task>` to store tasks that have been processed (completed tasks). You must use `java.util.ArrayList` as the concrete implementation for this list, but declare the variable using the `List` interface type.
 *     *   Include a mechanism to generate unique task IDs starting from 1.
 *     *   Implement the following public methods:
 *         *   `void addTask(String description)`: Creates a new `Task` with the next unique ID and the given description, then adds it to the pending queue.
 *         *   `Task processNextTask()`: Removes the next task from the head of the pending queue and adds it to the completed list. It should return the processed `Task` object.
 *         *   `Queue<Task> getPendingTasks()`: Returns the collection of pending tasks.
 *         *   `List<Task> getCompletedTasks()`: Returns the collection of completed tasks.
 * 
 * 3.  **User Interface and Control Flow:** Create a main class (e.g., `ProductionLineSimulator`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a loop that continuously displays a menu of options: Add Task, Process Task, View Tasks (Pending/Completed), Exit.
 *     *   Read the user's command using the `Scanner`.
 *     *   Use a `switch` statement to handle the different user commands based on their input.
 *     *   For the "View Tasks" command, prompt the user whether they want to view pending or completed tasks and display the appropriate list.
 * 
 * 4.  **Required Component Usage:** Your solution *must* explicitly use and demonstrate the functionality of ALL of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` for error output
 *     *   `System.out` for normal output (menu, prompts, success messages, task lists)
 *     *   Class-wide exception handling with `try-catch` blocks
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Define a custom exception class (e.g., `NoTasksPendingException`) within or related to the `ProductionLine` class. The `processNextTask()` method should throw this exception if the pending queue is empty.
 *     *   In the `main` method, catch the `NoTasksPendingException` specifically and report the error to the user using `System.err`.
 *     *   Include input validation (e.g., check for empty task description). Report validation errors using `System.err`.
 *     *   Include a general `try-catch(Exception e)` block in the `main` method to catch any other unexpected exceptions during the program's execution and report them using `System.err`.
 *     *   Ensure resources like the `Scanner` are properly closed (e.g., in a `finally` block).
 * 
 * 6.  **Best Practices:** Follow Java best practices, including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc is encouraged).
 *     *   Clean code structure with methods for different functionalities (e.g., displaying menu, displaying tasks).
 * 
 * **Expected Interaction Flow:**
 * 
 * The program should present a menu. Based on the user's single-character input ('a', 'p', 'v', 'e'), it should perform the corresponding action, prompting for more input if needed (like task description or view type). Error messages must go to `System.err`. Normal messages and lists must go to `System.out`.
 * 
 * Example:
 * ```
 * --- Production Line Simulator Menu ---
 * a - Add New Task
 * p - Process Next Task
 * v - View Tasks (prompts for pending/completed)
 * e - Exit
 * ------------------------------------
 * Enter command: a
 * Enter task description: Assemble Widget
 * Task added successfully.
 * 
 * --- Production Line Simulator Menu ---
 * ...
 * Enter command: p
 * Processed Task: ID 1 - Assemble Widget
 * 
 * --- Production Line Simulator Menu ---
 * ...
 * Enter command: p
 * No tasks currently pending in the queue.
 * 
 * --- Production Line Simulator Menu ---
 * ...
 * Enter command: v
 * View (p)ending or (c)completed tasks? c
 * --- Completed Tasks (1) ---
 *     ID: 1, Description: 'Assemble Widget'
 * --------------------
 * 
 * --- Production Line Simulator Menu ---
 * ...
 * Enter command: invalid
 * Invalid command. Please enter 'a', 'p', 'v', or 'e'.
 * 
 * --- Production Line Simulator Menu ---
 * ...
 * Enter command: e
 * Exiting Production Line Simulator.
 * ```
 * 
 * Your solution should be a single, cohesive program (can be in multiple files if preferred, but submit as one logical unit).
 *
 * EXPLANATION:
 * This solution provides a complete implementation for the Production Line Task Management Simulator, fulfilling all the requirements of the exam task.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A simple class demonstrating basic object-oriented principles, including private fields (`id`, `description`), a constructor for initialization, and public getter methods for accessing data (encapsulation). It also includes basic input validation in the constructor for the description.
 * 
 * 2.  **`ProductionLine` Class:** This class encapsulates the core logic of the simulation.
 *     *   **`java.util.Queue`**: The `pendingTasks` field is declared as a `Queue<Task>` and initialized with a `LinkedList`. This correctly models the waiting area where tasks are processed in the order they arrive (FIFO). Methods like `offer()` (used in `addTask`) and `poll()` (used in `processNextTask`) are standard `Queue` operations demonstrated.
 *     *   **`java.util.ArrayList` and `java.util.List`**: The `completedTasks` field is declared using the `java.util.List` interface type but initialized with a `new ArrayList<>()`. This demonstrates programming to the interface, a key best practice. `ArrayList` is suitable here as completed tasks are simply stored and iterated over, and their order might need to be preserved or accessed by index (though not strictly required by this problem, `ArrayList` is a common and efficient choice for a growing list).
 *     *   **Managing State:** The class maintains the state of pending and completed tasks and manages the generation of unique task IDs.
 *     *   **Core Logic:** The `addTask` and `processNextTask` methods implement the state transitions (adding to queue, moving from queue to list).
 * 
 * 3.  **`ProductionLineSimulator` (Main Class):**
 *     *   **`java.util.Scanner`**: Used in the `main` method to read user input line by line from `System.in`.
 *     *   **Command Loop and `switch` Statement**: The main `while` loop keeps the simulator running, displaying a menu and processing user commands. A `switch` statement is effectively used to direct the program flow based on the first character of the user's input, handling different cases for adding, processing, viewing, and exiting.
 *     *   **`System.out` and `System.err`**: `System.out.println()` and `System.out.print()` are used exclusively for displaying the menu, prompts, success messages, and the contents of the task lists as required. `System.err.println()` is used strictly for outputting error messages, such as invalid commands, validation failures, or processing errors. This distinction is important for separating normal program output from error reporting.
 * 
 * 4.  **Exception Handling (`try-catch` and Custom Exception):**
 *     *   **`NoTasksPendingException`**: A custom exception class is defined to represent the specific error condition where `processNextTask()` is called when the `pendingTasks` queue is empty. This demonstrates creating and using domain-specific exceptions for clearer error reporting. It is defined as a static nested class within the main file for simplicity in this exam context.
 *     *   **Specific `catch`**: In the `main` method, there is a specific `catch (NoTasksPendingException e)` block to handle this particular error gracefully, printing its message to `System.err`.
 *     *   **General `catch`**: A `catch (Exception e)` block is included around the main loop to catch any other unexpected runtime exceptions, fulfilling the requirement for class-wide exception handling and preventing the program from crashing abruptly. It also reports these errors to `System.err`.
 *     *   **Input Validation Handling**: `try-catch` blocks are also used around calls that might throw `IllegalArgumentException` (like `addTask` due to validation in `Task` constructor), ensuring validation errors are caught and reported via `System.err`.
 *     *   **Resource Management**: The `Scanner` is closed in a `finally` block to ensure the resource is released regardless of whether exceptions occurred.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Achieved in both `Task` and `ProductionLine` classes.
 *     *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `nextTaskId`), methods (`addTask`, `processNextTask`, `displayMenu`, `displayTasks`), and classes are named descriptively.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and exceptions.
 *     *   **Clean Structure:** The code is organized into separate classes with distinct responsibilities. Helper methods (`displayMenu`, `displayTasks`) are used to break down functionality.
 *     *   **Input Validation:** Checks for empty command input, empty task description, and valid view types are performed.
 * 
 * In summary, this solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch` including a custom exception) within a practical simulation scenario, adhering to best practices for code quality and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // Optional: Use AtomicInteger for thread-safe ID, simple int is fine for single-threaded exam

/**
 * Represents a single task in the production line.
 */
class Task {
    private final int id; // Use final as ID doesn't change
    private final String description; // Use final as description doesn't change

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "']";
    }
}

/**
 * Custom exception for when there are no tasks to process.
 * Made static nested class to be usable directly via ProductionLine.NoTasksPendingException
 * without needing an instance of ProductionLine.
 */
class NoTasksPendingException extends Exception {
    /**
     * Constructs a new NoTasksPendingException with the specified detail message.
     * @param message The detail message.
     */
    public NoTasksPendingException(String message) {
        super(message);
    }
}


/**
 * Manages the flow of tasks through a simulated production line.
 * Tasks are added to a pending queue and moved to a completed list upon processing.
 */
class ProductionLine {
    // Use Queue for pending tasks (FIFO - First-In, First-Out)
    private final Queue<Task> pendingTasks;

    // Use List for completed tasks (allows easy iteration and storage).
    // Declared as List interface, implemented by ArrayList.
    private final List<Task> completedTasks;

    // Counter for generating unique task IDs. Using simple int as it's single-threaded.
    private int nextTaskId;

    /**
     * Constructs a new ProductionLine.
     * Initializes the pending and completed task collections.
     */
    public ProductionLine() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * A unique ID is automatically assigned.
     * @param description The description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if description is null or empty (validation delegated to Task constructor).
     */
    public void addTask(String description) {
        // Task constructor handles null/empty validation
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer is preferred over add for queues, returns boolean
        // Output confirmation is handled by the simulator's main method
    }

    /**
     * Processes the next task from the pending queue.
     * The task is removed from the pending queue and added to the completed list.
     * @return The task that was processed.
     * @throws NoTasksPendingException if the pending queue is empty.
     */
    public Task processNextTask() throws NoTasksPendingException {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty

        if (taskToProcess == null) {
            throw new NoTasksPendingException("Error: No tasks currently pending in the queue.");
        }

        completedTasks.add(taskToProcess);
        return taskToProcess;
    }

    /**
     * Gets the list of pending tasks.
     * Note: Returns the internal queue for simplicity in this exam context.
     * In a real application, might return an unmodifiable view or a copy to prevent external modification.
     * @return The queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Gets the list of completed tasks.
     * Note: Returns the internal list for simplicity in this exam context.
     * In a real application, might return an unmodifiable view or a copy to prevent external modification.
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}


/**
 * Main class for the Production Line Simulator.
 * Provides a command-line interface for interacting with the production line.
 */
public class ProductionLineSimulator {

    /**
     * Main method to run the simulator.
     * Handles user input, command processing, and basic error handling.
     * Implements class-wide try-catch and uses Scanner, switch, System.out, System.err.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = null; // Declare scanner outside try to ensure finally can close it
        ProductionLine productionLine = new ProductionLine();
        boolean running = true;

        // Class-wide exception handling block
        try {
            scanner = new Scanner(System.in); // Initialize scanner here

            while (running) {
                displayMenu();
                System.out.print("Enter command: ");
                String commandLine = scanner.nextLine().trim(); // Read entire line and trim whitespace

                if (commandLine.isEmpty()) {
                    System.err.println("Invalid command. Input cannot be empty.");
                    continue; // Skip to next iteration of the loop
                }

                // Use the first character for command, case-insensitive
                char command = commandLine.toLowerCase().charAt(0);

                // Use switch statement for command handling
                switch (command) {
                    case 'a': // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        try {
                            productionLine.addTask(description);
                            System.out.println("Task added successfully.");
                        } catch (IllegalArgumentException e) {
                            // Catch validation errors (e.g., empty description) from addTask/Task constructor
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 'p': // Process Next Task
                        try {
                            Task processedTask = productionLine.processNextTask();
                            System.out.println("Processed Task: ID " + processedTask.getId() + " - " + processedTask.getDescription());
                        } catch (NoTasksPendingException e) {
                            // Specific error for no tasks pending, use System.err as required
                            System.err.println(e.getMessage());
                        } catch (Exception e) {
                             // Catch any other unexpected errors during processing
                             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
                             // e.printStackTrace(); // Uncomment for detailed debugging stack trace
                        }
                        break;

                    case 'v': // View Tasks (Pending/Completed)
                        System.out.print("View (p)ending or (c)ompleted tasks? ");
                        String viewTypeLine = scanner.nextLine().trim();
                        if (viewTypeLine.isEmpty()) {
                            System.err.println("Invalid view type. Input cannot be empty.");
                        } else {
                            char viewType = viewTypeLine.toLowerCase().charAt(0);
                            if (viewType == 'p') {
                                // Get the Queue and convert it to an ArrayList to pass to displayTasks (which takes List)
                                displayTasks(new ArrayList<>(productionLine.getPendingTasks()), "Pending Tasks");
                            } else if (viewType == 'c') {
                                // Get the List directly and pass it
                                displayTasks(productionLine.getCompletedTasks(), "Completed Tasks");
                            } else {
                                System.err.println("Invalid view type. Use 'p' for pending or 'c' for completed.");
                            }
                        }
                        break;

                    case 'e': // Exit
                        running = false;
                        System.out.println("Exiting Production Line Simulator.");
                        break;

                    default: // Invalid command
                        System.err.println("Invalid command. Please enter 'a', 'p', 'v', or 'e'.");
                }
                System.out.println(); // Add a blank line for readability between commands
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur outside specific blocks
            System.err.println("An unhandled error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner resource is closed to prevent resource leaks
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private static void displayMenu() {
        System.out.println("--- Production Line Simulator Menu ---");
        System.out.println("a - Add New Task");
        System.out.println("p - Process Next Task");
        System.out.println("v - View Tasks (prompts for pending/completed)");
        System.out.println("e - Exit");
        System.out.println("------------------------------------");
    }

    /**
     * Displays a list of tasks using System.out.
     * Uses the List interface for generality.
     * @param tasks The list of tasks to display.
     * @param title The title for the list (e.g., "Pending Tasks").
     */
    private static void displayTasks(List<Task> tasks, String title) {
        System.out.println("--- " + title + " (" + tasks.size() + ") ---");
        if (tasks.isEmpty()) {
            System.out.println("    No tasks.");
        } else {
            // Iterate through the list (or ArrayList created from Queue)
            for (Task task : tasks) {
                System.out.println("    ID: " + task.getId() + ", Description: '" + task.getDescription() + "'");
            }
        }
        System.out.println("--------------------");
    }
}
