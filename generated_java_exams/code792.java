/*
 * Exam Question #792
 * Generated on: 2025-05-12 16:41:24
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Priority Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based application for managing tasks with different priority levels for a small team. The system should allow users to add tasks, view all pending tasks sorted by priority, and complete the next task based on its priority.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   A unique integer ID (automatically generated).
 *     *   A `String` description.
 *     *   A `Priority` enum (`HIGH`, `MEDIUM`, `LOW`).
 *     *   Include appropriate getters and a `toString()` method for displaying task information.
 *     *   The constructor should validate that the description is not null or empty and the priority is not null, throwing an `IllegalArgumentException` if validation fails.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must internally use **three separate `Queue` objects**, one for each priority level (`HIGH`, `MEDIUM`, `LOW`). Use `java.util.LinkedList` as the concrete implementation for the `Queue`s.
 *     *   Implement a method `void addTask(String description, Task.Priority priority)` that creates a `Task` object and adds it to the correct priority queue.
 *     *   Implement a method `Task completeNextTask()` that removes and returns the task with the highest priority that was added earliest within that priority level. If the high priority queue is empty, check the medium, then the low. Return `null` if no tasks are pending in any queue.
 *     *   Implement a method `List<Task> viewAllPendingTasks()` that returns a **`List`** containing all tasks currently in the queues. The tasks in the returned list must be ordered first by priority (HIGH, then MEDIUM, then LOW), and then by their original addition order within each priority level. This method must use an **`ArrayList`** internally to collect the tasks from the queues before returning the `List`.
 *     *   Include any necessary helper methods (e.g., to check if queues are empty).
 * 
 * 3.  **Console Application:** Create a main application class (e.g., `TaskManagerApp`) with a `main` method that provides a command-line interface.
 *     *   Use **`java.util.Scanner`** to get user input.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  View All Pending Tasks
 *         3.  Complete Next Task
 *         0.  Exit
 *     *   Use a **`switch` statement** to handle the user's menu choice.
 *     *   Display informational messages and results using **`System.out`**.
 *     *   Display error messages (e.g., invalid input, operation failures) using **`System.err`**.
 *     *   Implement robust input validation (e.g., handle non-numeric input for menu choices or priority selection).
 *     *   Include **class-wide exception handling with `try-catch` blocks**. This should include handling potential `InputMismatchException` from `Scanner` and `IllegalArgumentException` from your `Task` or `TaskManager` methods. Place a general `try-catch(Exception)` block around the main application loop to catch any unexpected errors.
 * 
 * **Required Java Components Checklist:**
 * 
 * Your solution *must* demonstrate the usage of ALL of the following:
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling with `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 * *   Ensure proper resource management (e.g., close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console. Examples of expected interactions include:
 * 
 * *   Displaying a menu.
 * *   Prompting for task details (description, priority).
 * *   Confirming task addition.
 * *   Listing pending tasks in the correct priority and order.
 * *   Announcing which task was completed or stating if no tasks are pending.
 * *   Printing error messages to `System.err` for invalid inputs or operations.
 * *   Printing a message upon exiting.
 * *   Printing an error message and stack trace to `System.err` if an unexpected exception occurs in the main loop.
 * 
 * **Submission:**
 * 
 * Submit the complete Java source code for all necessary classes (`Task.java`, `TaskManager.java`, `TaskManagerApp.java`, etc.).
 *
 * EXPLANATION:
 * This solution implements the Priority Task Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: Used within the `TaskManager` class. Three separate `Queue<Task>` instances (`highPriorityQueue`, `mediumPriorityQueue`, `lowPriorityQueue`) are declared and initialized with `java.util.LinkedList`. Tasks are added using `queue.add()` in the `addTask` method and removed using `queue.poll()` in the `completeNextTask` method, respecting the first-in, first-out (FIFO) nature of the queue *within* each priority level.
 * 
 * 2.  **`java.util.ArrayList`**: Used internally within the `TaskManager.viewAllPendingTasks()` method. This method needs to collect tasks from the three separate queues into a single list to return. An `ArrayList` is created for this purpose.
 * 
 * 3.  **`java.util.List` interface**: Used as the return type for the `TaskManager.viewAllPendingTasks()` method. Although an `ArrayList` is created and populated internally, the method signature returns the more general `List` interface, promoting good practice by programming to an interface.
 * 
 * 4.  **`java.util.Scanner`**: Used in the `TaskManagerApp` class (specifically in `main` and helper methods like `addTask`, `runApplication`) to read user input from the console (`System.in`). It reads menu choices, task descriptions, and priority selections.
 * 
 * 5.  **`switch` statement**: Used in multiple places:
 *     *   In `TaskManagerApp.runApplication` to handle the main menu selections (Add, View, Complete, Exit).
 *     *   In `TaskManagerApp.addTask` to map the user's numeric priority choice (1, 2, 3) to the `Task.Priority` enum value (`HIGH`, `MEDIUM`, `LOW`).
 *     *   In `TaskManager.addTask` to direct the newly created `Task` object to the appropriate priority queue based on its `Priority` enum value.
 * 
 * 6.  **`System.err`**: Used to print error messages to the standard error stream. This is done for invalid user input (e.g., non-numeric input caught by `InputMismatchException`, invalid menu or priority choices caught by `default` cases in `switch` or conditional checks) and for operation failures (e.g., `IllegalArgumentException` caught when adding a task with an empty description). Using `System.err` visually distinguishes error output from normal program output (`System.out`) in most console environments.
 * 
 * 7.  **`System.out`**: Used for all standard program output, including the menu, prompts for input, confirmation messages when tasks are added or completed, and the list of pending tasks.
 * 
 * 8.  **Class-wide exception handling with `try-catch` blocks**:
 *     *   A general `try-catch(Exception e)` block is placed in the `main` method around the call to `runApplication()`. This acts as a safety net to catch any unhandled exceptions that might occur within the main application logic, preventing the program from crashing silently. It prints a general error message and the stack trace to `System.err`.
 *     *   Specific `try-catch` blocks are used within `runApplication()` and `addTask()` to handle expected exceptions:
 *         *   `InputMismatchException`: Catches cases where the user enters non-integer input when an integer is expected by `Scanner`.
 *         *   `IllegalArgumentException`: Catches exceptions thrown by the `Task` constructor or `TaskManager.addTask` if input validation fails (e.g., empty description).
 *     This tiered approach demonstrates handling specific anticipated errors gracefully while having a fallback for unexpected runtime issues.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskManager` classes have private fields, accessed or modified only through public methods (`getters`, `addTask`, `completeNextTask`, etc.).
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskManagerApp`), variable names (`description`, `priority`, `highPriorityQueue`, `pendingTasks`), and method names (`addTask`, `completeNextTask`, `viewAllPendingTasks`, `printMenu`) are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are provided for classes and public methods explaining their purpose, parameters, return values, and exceptions. Inline comments clarify specific logic points.
 * *   **Input Validation:** The `Task` constructor explicitly checks for null or empty description/priority. The `TaskManagerApp` methods validate menu choices and priority selections, handling invalid inputs gracefully using `System.err` and preventing the program from proceeding with invalid data.
 * *   **Proper Error Handling:** Specific exceptions (`InputMismatchException`, `IllegalArgumentException`) are caught and handled appropriately, providing user-friendly error messages via `System.err`. The general `Exception` catch in `main` serves as a robust fallback.
 * *   **Clean Code Structure:** The code is divided into three logical classes (`Task`, `TaskManager`, `TaskManagerApp`), separating concerns (data representation, business logic, user interface). Helper methods (`printMenu`, `addTask`, `viewPendingTasks`, `completeNextTask`) in `TaskManagerApp` break down the user interaction logic into smaller, manageable units. Resource management is included by ensuring the `Scanner` is closed in a `finally` block.
 * 
 * This solution effectively integrates all required components into a practical application, demonstrating an advanced understanding of Java programming concepts, object-oriented design, collection usage, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collection; // For addAll on Queue implementation

/**
 * Represents a single task with description, priority, and a unique ID.
 */
class Task {
    public enum Priority { HIGH, MEDIUM, LOW }

    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private Priority priority;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Must not be null or empty.
     * @param priority The priority of the task. Must not be null.
     * @throws IllegalArgumentException if description is null/empty or priority is null.
     */
    public Task(String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
            throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description.trim();
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     */
    @Override
    public String toString() {
        return String.format("Task #%d [%s]: %s", id, priority, description);
    }
}

/**
 * Manages a collection of tasks across different priority queues.
 */
class TaskManager {
    // Use Queue interface with LinkedList implementation
    private Queue<Task> highPriorityQueue;
    private Queue<Task> mediumPriorityQueue;
    private Queue<Task> lowPriorityQueue;

    /**
     * Constructs a TaskManager with empty priority queues.
     */
    public TaskManager() {
        highPriorityQueue = new LinkedList<>();
        mediumPriorityQueue = new LinkedList<>();
        lowPriorityQueue = new LinkedList<>();
    }

    /**
     * Adds a new task to the appropriate priority queue based on its priority.
     * @param description The description for the new task.
     * @param priority The priority for the new task.
     * @throws IllegalArgumentException if description is invalid or priority is null (handled by Task constructor).
     */
    public void addTask(String description, Task.Priority priority) {
        // Task constructor validates inputs and throws IllegalArgumentException
        Task task = new Task(description, priority);
        // Use switch statement for flow control based on priority
        switch (priority) {
            case HIGH:
                highPriorityQueue.add(task);
                break;
            case MEDIUM:
                mediumPriorityQueue.add(task);
                break;
            case LOW:
                lowPriorityQueue.add(task);
                break;
            default:
                // This case should not be reached with the current Priority enum
                System.err.println("Internal Error: Attempted to add task with unknown priority.");
                break;
        }
        System.out.println("Successfully added: " + task);
    }

    /**
     * Removes and returns the next task to be completed based on priority.
     * Checks high, then medium, then low priority queues.
     * @return The completed Task, or null if no tasks are pending.
     */
    public Task completeNextTask() {
        Task completedTask = null;
        // Check queues in priority order (HIGH -> MEDIUM -> LOW)
        if (!highPriorityQueue.isEmpty()) {
            completedTask = highPriorityQueue.poll(); // Removes and returns head
        } else if (!mediumPriorityQueue.isEmpty()) {
            completedTask = mediumPriorityQueue.poll();
        } else if (!lowPriorityQueue.isEmpty()) {
            completedTask = lowPriorityQueue.poll();
        }
        return completedTask; // Will be null if all queues were empty
    }

    /**
     * Returns a List of all pending tasks, ordered by priority (HIGH, MEDIUM, LOW)
     * and then by addition order within priority.
     * Uses ArrayList to collect tasks from queues.
     * @return A List of pending tasks. Returns an empty list if no tasks are pending.
     */
    public List<Task> viewAllPendingTasks() {
        // Use ArrayList to collect tasks from queues
        List<Task> allTasks = new ArrayList<>();

        // Add all tasks from each queue to the list.
        // LinkedList implements Collection, which has addAll.
        // addAll preserves the iteration order of the source collection (insertion order for LinkedList).
        allTasks.addAll(highPriorityQueue);
        allTasks.addAll(mediumPriorityQueue);
        allTasks.addAll(lowPriorityQueue);

        // Return the collected tasks as a List interface type
        return allTasks;
    }

    /**
     * Checks if there are any tasks pending in any queue.
     * @return true if at least one task is pending, false otherwise.
     */
    public boolean hasPendingTasks() {
        return !highPriorityQueue.isEmpty() || !mediumPriorityQueue.isEmpty() || !lowPriorityQueue.isEmpty();
    }
}

/**
 * Main application class for the Priority Task Management System.
 * Handles user interaction via the console.
 */
public class TaskManagerApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = null; // Initialize scanner to null

    public static void main(String[] args) {
        System.out.println("--- Priority Task Management System ---");
        scanner = new Scanner(System.in);

        // Class-wide exception handling around the main application logic
        // Catches unexpected exceptions that might occur during runtime
        try {
            runApplication(); // Delegate main loop to a separate method
        } catch (Exception e) {
            // Catch any Exception subclass
            System.err.println("\nAn unexpected fatal error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error stream
            System.err.println("Application is shutting down due to an error.");
        } finally {
            // Ensure scanner is closed properly whether an exception occurred or not
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
            System.out.println("--- Application Ended ---");
        }
    }

    /**
     * Contains the main application loop and menu handling.
     */
    private static void runApplication() {
        int choice = -1;
        // Loop until user chooses to exit (choice 0)
        while (choice != 0) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu options
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        completeNextTask();
                        break;
                    case 0:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range (1-3, 0)
                        System.err.println("Invalid choice. Please enter a number between 0 and 3.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure loop continues
            } catch (IllegalArgumentException e) {
                // Catch exceptions thrown by Task or TaskManager methods (e.g., empty description)
                System.err.println("Operation failed: " + e.getMessage());
            }
            System.out.println(); // Add a newline for better readability between menu iterations
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Pending Tasks");
        System.out.println("3. Complete Next Task");
        System.out.println("0. Exit");
    }

    /**
     * Handles the process of adding a new task based on user input.
     * Includes input validation and calls TaskManager.addTask().
     */
    private static void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.println("Select priority:");
        System.out.println("1. HIGH");
        System.out.println("2. MEDIUM");
        System.out.println("3. LOW");
        System.out.print("Enter priority choice (1-3): ");

        try {
            int priorityChoice = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            Task.Priority priority = null;
            // Use switch statement for priority selection
            switch (priorityChoice) {
                case 1:
                    priority = Task.Priority.HIGH;
                    break;
                case 2:
                    priority = Task.Priority.MEDIUM;
                    break;
                case 3:
                    priority = Task.Priority.LOW;
                    break;
                default:
                    // Handle invalid priority numbers
                    System.err.println("Invalid priority choice. Task not added.");
                    return; // Exit the method if priority choice is invalid
            }

            // Call TaskManager method to add the task.
            // TaskManager.addTask and Task constructor handle IllegalArgumentException
            taskManager.addTask(description, priority);

        } catch (InputMismatchException e) {
            // Handle non-integer input for priority choice
            System.err.println("Invalid input for priority. Please enter a number (1-3).");
            scanner.nextLine(); // Consume invalid input
        } catch (IllegalArgumentException e) {
             // Catch exception from Task constructor if description was empty
             System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Retrieves and displays all pending tasks using TaskManager.viewAllPendingTasks().
     * Prints results to System.out.
     */
    private static void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks (Ordered by Priority) ---");
        // Call TaskManager method which uses List and ArrayList
        List<Task> pendingTasks = taskManager.viewAllPendingTasks();

        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate and print each task from the List
            for (int i = 0; i < pendingTasks.size(); i++) {
                System.out.println((i + 1) + ". " + pendingTasks.get(i));
            }
        }
    }

    /**
     * Attempts to complete the next task using TaskManager.completeNextTask().
     * Prints the completed task or a message if none were pending to System.out.
     */
    private static void completeNextTask() {
        System.out.println("\n--- Complete Next Task ---");
        // Call TaskManager method which uses Queue.poll()
        Task completedTask = taskManager.completeNextTask();

        if (completedTask != null) {
            System.out.println("Successfully completed: " + completedTask);
        } else {
            System.out.println("No tasks to complete.");
        }
    }
}
