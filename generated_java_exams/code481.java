/*
 * Exam Question #481
 * Generated on: 2025-05-11 23:17:34
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * You are tasked with developing a simple command-line Task Management System. This system should allow users to add tasks to a waiting queue, process tasks one by one, and view both waiting and completed tasks. The system must demonstrate proficiency in core Java concepts and utilize specific data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String, e.g., "High", "Medium", "Low"). Implement a constructor and public getter methods. The constructor must validate that the description is not empty and the priority is one of the accepted values, throwing an `IllegalArgumentException` if validation fails. Include a `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue` (implemented by `java.util.LinkedList`) to store tasks that are waiting to be processed.
 *     *   It must use a `java.util.List` (implemented by `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Implement a method `addTask(Task task)` that adds a valid task to the waiting queue.
 *     *   Implement a method `processNextTask()` that removes the next task from the waiting queue and adds it to the completed tasks list. If the waiting queue is empty, it should print a message to `System.out` and return null.
 *     *   Implement methods `getWaitingTasks()` and `getCompletedTasks()` that return the current lists of tasks (consider encapsulation when returning collections).
 * 3.  **User Interface:** Create a main class (`TaskManagementApp`) with a `main` method to handle user interaction via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user: Add Task, Process Task, View Waiting Tasks, View Completed Tasks, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for normal output (menu, task details, success messages).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid task input).
 * 4.  **Error Handling:**
 *     *   Implement input validation using `try-catch` blocks, especially when reading user input that is expected to be a number (menu choice) and when creating `Task` objects (catching `IllegalArgumentException`).
 *     *   Implement "class-wide" exception handling by wrapping the main operational loop in the `main` method with a `try-catch` block to catch any unexpected runtime exceptions and print an error message to `System.err` before the program terminates. Ensure the `Scanner` is closed properly, perhaps in a `finally` block.
 * 5.  **Best Practices:** Adhere to Java best practices including proper encapsulation, meaningful variable and method names, appropriate comments, and clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and respond to user input. Examples of expected interactions:
 * 
 * ```
 * Task Management System
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write Exam Question
 * Enter priority (High, Medium, Low): High
 * Task added: [High] Write Exam Question
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Grade Papers
 * Enter priority (High, Medium, Low): Medium
 * Task added: [Medium] Grade Papers
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. [High] Write Exam Question
 * 2. [Medium] Grade Papers
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: [High] Write Exam Question
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. [Medium] Grade Papers
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. [High] Write Exam Question
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: [Medium] Grade Papers
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * No tasks in the waiting queue to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: add
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description:
 * Enter priority (High, Medium, Low): Low
 * Failed to add task: Task description cannot be empty.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * Task Management System shut down.
 * ```
 * 
 * Your solution should consist of the Java code for the `Task`, `TaskManager`, and `TaskManagementApp` classes.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   Represents a task with `description` and `priority`.
 *     *   Uses private fields and public getters for encapsulation.
 *     *   The constructor performs input validation for description and priority, throwing `IllegalArgumentException` as required. This shifts validation logic to the data object itself, promoting data integrity.
 *     *   Includes a `toString()` method for convenient output formatting.
 * 
 * 2.  **TaskManager Class:**
 *     *   Manages two collections: `waitingTasks` and `completedTasks`.
 *     *   `waitingTasks` is declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. This fulfills the requirement to use `Queue` and `LinkedList` (as `LinkedList` implements `Queue`). The `Queue` interface provides methods like `offer()` for adding and `poll()` for removing, which are appropriate for managing a waiting list where items are processed in arrival order (FIFO).
 *     *   `completedTasks` is declared as `List<Task>` and instantiated as `ArrayList<Task>`. This fulfills the requirement to use both the `List` interface and `ArrayList`. `ArrayList` is suitable for storing completed tasks as a dynamic list where order of completion is maintained and elements can be accessed by index (though not strictly required by the `viewCompletedTasks` method, it's a common `List` operation).
 *     *   `addTask` uses `queue.offer()` to add a task.
 *     *   `processNextTask` uses `queue.poll()` to retrieve and remove the head of the queue. It checks for `null` return to handle the empty queue case gracefully. The processed task is added to the `completedTasks` list.
 *     *   `getWaitingTasks` returns a *copy* of the `waitingTasks` queue wrapped in a new `ArrayList`. This is a good practice for encapsulation, preventing external code from directly modifying the internal queue.
 *     *   `getCompletedTasks` returns a reference to the internal `completedTasks` `ArrayList`. For this problem scope, returning the reference is acceptable, but for stricter encapsulation, a copy could also be returned.
 * 
 * 3.  **TaskManagementApp Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses a static `Scanner` for reading user input.
 *     *   Uses a static `TaskManager` instance to manage the tasks throughout the application's lifetime.
 *     *   The `runMenu` method contains the main application loop.
 *     *   A `switch` statement is used within the loop to handle the different menu options selected by the user, directing execution to appropriate private helper methods (`addTask`, `processNextTask`, etc.). This satisfies the `switch` requirement.
 *     *   `System.out` is used extensively for displaying the menu, prompts, task details, and success messages.
 *     *   `System.err` is used specifically for displaying error messages, such as invalid menu choices, input validation failures, and unexpected exceptions. This fulfills the `System.err` requirement.
 * 
 * 4.  **Error Handling:**
 *     *   **Input Validation:**
 *         *   The `Task` constructor throws `IllegalArgumentException` for invalid task data. This is caught in the `addTask` method, and an error message is printed to `System.err`.
 *         *   The `runMenu` method uses a `try-catch` block around `scanner.nextInt()` to catch `InputMismatchException` if the user enters non-integer input for the menu choice. It prints an error to `System.err` and importantly calls `scanner.nextLine()` to consume the invalid input, preventing an infinite loop.
 *     *   **Class-wide Exception Handling:** The `main` method wraps the call to `runMenu()` in a `try-catch(Exception e)` block. This serves as a top-level or "class-wide" handler that catches any unhandled exception that might occur within the main application logic (`runMenu` and methods it calls). It prints a generic error message to `System.err` and the stack trace for debugging.
 *     *   **Resource Management:** A `finally` block in `main` ensures that the `Scanner` resource is closed, preventing resource leaks.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in `Task` and `TaskManager` by making fields private and providing controlled access through methods. Returning a copy in `getWaitingTasks` is another example.
 *     *   Meaningful names are used for classes, methods, and variables (`description`, `waitingTasks`, `processNextTask`, `runMenu`, etc.).
 *     *   Comments and basic Javadoc are included to explain the purpose of classes and methods.
 *     *   The code is structured into logical classes with single responsibilities (`Task` for data, `TaskManager` for logic, `TaskManagementApp` for UI/orchestration).
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, Task Management System, demonstrating key Java programming skills including object-oriented design, data structures, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority; // Using String for simplicity based on input options

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (High, Medium, or Low).
     * @throws IllegalArgumentException if description is empty or priority is invalid.
     */
    public Task(String description, String priority) {
        // Validate description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        // Validate priority
        if (!isValidPriority(priority)) {
             throw new IllegalArgumentException("Invalid priority: '" + priority + "'. Must be High, Medium, or Low (case-insensitive).");
        }
        this.description = description.trim(); // Trim whitespace
        this.priority = priority.trim(); // Trim whitespace
    }

    /**
     * Checks if the provided priority string is valid.
     * @param priority The priority string to check.
     * @return true if the priority is "High", "Medium", or "Low" (case-insensitive), false otherwise.
     */
    private boolean isValidPriority(String priority) {
        if (priority == null) {
            return false;
        }
        String lowerPriority = priority.trim().toLowerCase();
        return lowerPriority.equals("high") || lowerPriority.equals("medium") || lowerPriority.equals("low");
    }

    /**
     * Gets the task description.
     * @return The description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The priority.
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string like "[Priority] Description".
     */
    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

/**
 * Manages collections of waiting and completed tasks.
 */
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO based on arrival)
    private Queue<Task> waitingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Declared as List interface

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // Use LinkedList which implements Queue
        this.waitingTasks = new LinkedList<>();
        // Use ArrayList which implements List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the waiting queue.
     * @param task The task to add. Must not be null.
     */
    public void addTask(Task task) {
        if (task != null) {
            // offer() is generally preferred for adding to a queue, returns false on failure (rare for LinkedList)
            waitingTasks.offer(task);
            System.out.println("Task added: " + task);
        } else {
            // This case should ideally be prevented by input validation before calling this method
            System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task in the waiting queue (FIFO order).
     * Removes the task from the waiting queue and adds it to the completed tasks list.
     * @return The processed Task object, or null if the waiting queue was empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task taskToProcess = waitingTasks.poll();

        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
            return taskToProcess;
        } else {
            System.out.println("No tasks in the waiting queue to process.");
            return null;
        }
         // Note: No specific try-catch needed around poll/add for typical LinkedList/ArrayList operations,
         // but a general catch could be added if unexpected RuntimeExceptions were anticipated from the collection implementations themselves,
         // or if methods called *within* this method could throw checked exceptions.
         // The main app's try-catch will handle most unexpected runtime errors.
    }

    /**
     * Returns a list of tasks currently in the waiting queue.
     * Returns a new ArrayList containing the elements to protect the internal queue state (encapsulation).
     * @return A new List of waiting tasks.
     */
    public List<Task> getWaitingTasks() {
        return new ArrayList<>(waitingTasks); // Return a copy
    }

    /**
     * Returns a list of tasks that have been completed.
     * Returns the internal ArrayList reference. External modification is possible but acceptable for this problem scope.
     * To strictly enforce read-only, return a copy: new ArrayList<>(completedTasks).
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Return reference to the internal list
    }

    /**
     * Checks if the waiting queue is empty.
     * @return true if the waiting queue is empty, false otherwise.
     */
    public boolean isWaitingQueueEmpty() {
        return waitingTasks.isEmpty();
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and orchestrates TaskManager operations.
 */
public class TaskManagementApp {

    // Static fields for shared resources
    private static Scanner scanner = null; // Initialize to null
    private static TaskManager taskManager = new TaskManager();

    /**
     * Main entry point of the application.
     * Initializes scanner and runs the main menu loop within a top-level exception handler.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("Task Management System");
        scanner = new Scanner(System.in); // Initialize scanner here

        // Class-wide exception handling: Wrap the main operational logic
        try {
            runMenu(); // Start the main menu loop
        } catch (Exception e) {
            // Catch any unexpected exceptions that bubble up from runMenu or other parts
            System.err.println("An unexpected fatal error occurred. The system is shutting down.");
            System.err.println("Error details: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner is closed regardless of whether an exception occurred
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
            System.out.println("Task Management System shut down.");
        }
    }

    /**
     * Runs the main interactive menu loop.
     * Reads user input, processes choices using a switch statement, and handles input errors.
     */
    private static void runMenu() {
        int choice = -1;
        // Loop until the user chooses to exit (option 5)
        while (choice != 5) {
            printMenu(); // Display the menu options

            try {
                System.out.print("Enter your choice: ");
                // Read integer input for menu choice. Can throw InputMismatchException.
                choice = scanner.nextInt();
                // Consume the rest of the line including the newline character after reading the integer
                scanner.nextLine();

                // Use a switch statement to direct control flow based on user choice
                switch (choice) {
                    case 1:
                        addTask(); // Call method to handle adding a task
                        break;
                    case 2:
                        processNextTask(); // Call method to handle processing a task
                        break;
                    case 3:
                        viewWaitingTasks(); // Call method to view waiting tasks
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        // Loop condition will terminate the program
                        break;
                    default:
                        // Handle invalid integer input within the valid range of choice type but outside menu options
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to ensure loop continues and re-prompts
            } catch (IllegalArgumentException e) {
                 // Catch exceptions thrown by Task constructor during addTask() if not caught there
                 // (though addTask catches it, this shows handling exceptions from called methods)
                 System.err.println("Operation failed due to invalid data: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the menu processing loop
                System.err.println("An error occurred during menu operation: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
             System.out.println(); // Add a newline for better separation between menu interactions
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Prompts the user for task details and adds a new task via TaskManager.
     * Handles potential IllegalArgumentException from Task constructor.
     */
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read description

        System.out.print("Enter priority (High, Medium, Low): ");
        String priority = scanner.nextLine(); // Read priority

        try {
            // Attempt to create a new Task object. This constructor performs validation.
            Task newTask = new Task(description, priority);
            // If successful, add the task using the TaskManager
            taskManager.addTask(newTask);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from the Task constructor and report them to the user
            System.err.println("Failed to add task: " + e.getMessage());
        }
         // No specific catch for other exceptions needed here, the outer runMenu catch handles others.
    }

    /**
     * Instructs the TaskManager to process the next task in the queue.
     */
    private static void processNextTask() {
        // The TaskManager's method handles the logic and messages for empty queue
        taskManager.processNextTask();
    }

    /**
     * Retrieves and displays the list of tasks currently waiting in the queue.
     */
    private static void viewWaitingTasks() {
        // Get the list of waiting tasks from the TaskManager
        List<Task> waitingTasks = taskManager.getWaitingTasks(); // Uses List interface

        if (waitingTasks.isEmpty()) {
            System.out.println("No tasks currently waiting.");
        } else {
            System.out.println("--- Waiting Tasks ---");
            // Iterate and print using the List interface methods
            for (int i = 0; i < waitingTasks.size(); i++) {
                System.out.println((i + 1) + ". " + waitingTasks.get(i));
            }
        }
    }

    /**
     * Retrieves and displays the list of tasks that have been completed.
     */
    private static void viewCompletedTasks() {
        // Get the list of completed tasks from the TaskManager
        List<Task> completedTasks = taskManager.getCompletedTasks(); // Uses List interface

         if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
             // Iterate and print using the List interface methods
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
    }
}
