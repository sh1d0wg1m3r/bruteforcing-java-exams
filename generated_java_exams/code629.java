/*
 * Exam Question #629
 * Generated on: 2025-05-12 16:17:02
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Warehouse Order Fulfillment System in Java. This system needs to manage incoming customer orders, queue them for processing, and record them as completed shipments once processed. The system should be interactive, allowing a user (e.g., a warehouse manager) to add new orders, process the next pending order, view pending orders, and view completed shipments via a menu-driven interface.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incoming orders that are waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store records of completed shipments.
 *     *   Declare variables holding the completed shipments list using the `java.util.List` interface.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input for menu selections and order details.
 *     *   Implement a menu with options:
 *         *   Add New Order
 *         *   Process Next Pending Order
 *         *   View Pending Orders
 *         *   View Completed Shipments
 *         *   Exit
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, order/shipment details, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process when the queue is empty).
 * 
 * 5.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. The main interactive loop should be robust and handle potential issues like invalid user input (non-numeric where numbers are expected) or attempts to perform operations on empty data structures (like processing an order when the queue is empty). You may define a custom exception for specific scenarios if helpful, but the core requirement is the use of `try-catch` around operations that might fail.
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create separate classes for `Order` and `Shipment` to encapsulate their data (e.g., ID, details, quantity, date).
 *     *   Create a `WarehouseSystem` class that manages the `Queue` and `List`, and contains the methods for adding orders, processing orders, and displaying data.
 *     *   Follow best practices:
 *         *   Use private fields and public methods (`getters` if necessary for display, though direct printing methods are acceptable for this task).
 *         *   Use meaningful variable and method names.
 *         *   Include appropriate comments (Javadoc for classes/methods, inline for complex logic).
 *         *   Validate user input where appropriate (e.g., quantity must be positive).
 * 
 * **Classes to Create:**
 * 
 * *   `Order`: Fields: `orderId` (int), `itemDetails` (String), `quantity` (int).
 * *   `Shipment`: Fields: `shipmentId` (int), `orderId` (int), `processedDate` (String or `java.util.Date` - String is simpler for this task).
 * *   `WarehouseSystem`: Manages the queue and list, contains the main logic.
 * *   `Main` (or similar): Contains the `main` method to create a `WarehouseSystem` instance and start the menu loop.
 * 
 * **Functionality Details:**
 * 
 * *   When adding an order, assign a unique `orderId` (start from 1).
 * *   When processing an order, take the order from the front of the queue, assign a unique `shipmentId` (start from 1), record the `orderId` it came from, and add it to the list of completed shipments.
 * *   Handle the case where the user tries to process an order when the queue is empty. Print an error message using `System.err`.
 * *   Handle invalid menu input (non-numeric or out of range). Print an error message using `System.err`.
 * *   Handle non-numeric input when expecting numbers (e.g., for quantity). Print an error message using `System.err`.
 * 
 * **Expected Output Structure:**
 * 
 * The output should be menu-driven. When displaying lists, print details clearly. Error messages should stand out using `System.err`.
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add New Order
 * 2. Process Next Pending Order
 * 3. View Pending Orders
 * 4. View Completed Shipments
 * 5. Exit
 * Enter your choice: 
 * ```
 * 
 * (Example output for adding order)
 * ```
 * Enter item details: Laptop
 * Enter quantity: 5
 * Order #1 added to queue.
 * ```
 * 
 * (Example output for processing order)
 * ```
 * Order #1 (Laptop, Qty: 5) processed. Shipment #1 recorded.
 * ```
 * 
 * (Example output for viewing pending)
 * ```
 * --- Pending Orders ---
 * Order ID: 2, Item: Mouse, Qty: 10
 * Order ID: 3, Item: Keyboard, Qty: 2
 * ----------------------
 * ```
 * 
 * (Example output for viewing completed)
 * ```
 * --- Completed Shipments ---
 * Shipment ID: 1, Order ID: 1, Processed: [Current Date/Time]
 * -------------------------
 * ```
 * 
 * (Example error output)
 * ```
 * ERROR: No pending orders to process.
 * ```
 * or
 * ```
 * ERROR: Invalid input. Please enter a number.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Grading Criteria:**
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective implementation of `try-catch` for error handling.
 * *   Proper object-oriented design (encapsulation, classes).
 * *   Correct implementation of menu logic and operations.
 * *   Input validation and error handling robustness.
 * *   Code clarity, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * The solution implements a simple Warehouse Order Fulfillment System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Order` and `Shipment` classes encapsulate the data for individual orders and completed shipments, respectively, using private fields and public getters (`toString` provides a convenient display format).
 *     *   `WarehouseSystem` is the core class managing the application state (`orderQueue`, `completedShipments`) and logic. It uses private fields for encapsulation.
 *     *   `WarehouseApp` contains the `main` method, the entry point of the application. It creates instances of `Scanner` and `WarehouseSystem` and starts the interactive menu.
 * 
 * 2.  **Data Structures:**
 *     *   `orderQueue`: Declared as `Queue<Order>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for processing orders in the order they were received. `offer()` is used to add orders to the tail, and `poll()` is used to remove orders from the head.
 *     *   `completedShipments`: Declared as `List<Shipment>` and initialized with `new ArrayList<>()`. `ArrayList` is a dynamic array implementation of the `List` interface, suitable for storing completed shipments where order is maintained and elements can be iterated over. `add()` is used to append shipments.
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner`: Used in `WarehouseSystem.runMenu()` to read user input from `System.in`. `nextInt()` reads integer choices, and `nextLine()` is used to read string input (item details) and crucially, to consume the newline character left by `nextInt()`.
 *     *   `switch`: Located in `WarehouseSystem.runMenu()`, this statement efficiently handles the different menu options selected by the user, directing execution to the appropriate methods (`addOrder`, `processNextOrder`, `displayPendingOrders`, `displayCompletedShipments`).
 * 
 * 4.  **Output:**
 *     *   `System.out.println()` is used for printing the menu, prompts, and successful operation confirmations or data displays.
 *     *   `System.err.println()` is used specifically for printing error messages, making them distinct from normal output.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A large `try-catch` block wraps the core logic within the `runMenu` method's loop. This provides class-wide handling for potential exceptions during user interaction.
 *     *   `InputMismatchException`: Caught to handle cases where the user enters non-numeric input when an integer is expected (e.g., for the menu choice or quantity). The `scanner.nextLine()` within the catch block is essential to clear the invalid input from the scanner buffer and prevent an infinite loop.
 *     *   `IllegalArgumentException`: Thrown by the `addOrder` method if a non-positive quantity is provided. This is caught in the `runMenu` method after the `addOrder` call.
 *     *   `EmptyQueueException`: A custom exception defined to specifically signal an attempt to process an order when the `orderQueue` is empty. This exception is thrown by `processNextOrder()` and caught in `runMenu()`.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime exceptions, printing an error message and the stack trace for debugging.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Order`, `Shipment`, and `WarehouseSystem` are `private`. Access is controlled via public methods.
 *     *   **Naming:** Variable names (`orderQueue`, `completedShipments`, `nextOrderId`, `itemDetails`, `runMenu`, `processNextOrder`) and method names are descriptive.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points (e.g., consuming the newline after `nextInt()`).
 *     *   **Input Validation:** `addOrder` explicitly checks if the quantity is positive. The `try-catch` block in `runMenu` handles invalid *format* input (non-numeric).
 *     *   **Error Handling:** Specific error messages are printed using `System.err` for different failure conditions (invalid choice, invalid input format, empty queue, invalid quantity).
 *     *   **Clean Code Structure:** Logic is separated into methods within the `WarehouseSystem` class. The `main` method is kept simple, focusing only on setup and starting the system.
 * 
 * This solution effectively integrates all required components into a practical, menu-driven application while demonstrating robust error handling and good object-oriented design principles suitable for an advanced programming exam.
 */

import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Date; // For shipment date

// Class representing an Order
class Order {
    private int orderId;
    private String itemDetails;
    private int quantity;

    public Order(int orderId, String itemDetails, int quantity) {
        this.orderId = orderId;
        this.itemDetails = itemDetails;
        this.quantity = quantity;
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public String getItemDetails() {
        return itemDetails;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Item: " + itemDetails + ", Qty: " + quantity;
    }
}

// Class representing a completed Shipment
class Shipment {
    private int shipmentId;
    private int orderId; // The ID of the order that was shipped
    private Date processedDate;

    public Shipment(int shipmentId, int orderId, Date processedDate) {
        this.shipmentId = shipmentId;
        this.orderId = orderId;
        this.processedDate = processedDate;
    }

    // Getters
    public int getShipmentId() {
        return shipmentId;
    }

    public int getOrderId() {
        return orderId;
    }

    public Date getProcessedDate() {
        return processedDate;
    }

    @Override
    public String toString() {
        return "Shipment ID: " + shipmentId + ", Order ID: " + orderId + ", Processed: " + processedDate;
    }
}

// Custom exception for empty queue processing attempt
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Class managing the warehouse system logic
class WarehouseSystem {
    // Use Queue for pending orders (FIFO)
    private Queue<Order> orderQueue;
    // Use List for completed shipments (ArrayList implementation)
    private List<Shipment> completedShipments;

    private int nextOrderId;
    private int nextShipmentId;

    public WarehouseSystem() {
        // Initialize data structures
        orderQueue = new LinkedList<>(); // LinkedList implements Queue
        completedShipments = new ArrayList<>(); // ArrayList implements List

        // Initialize ID counters
        nextOrderId = 1;
        nextShipmentId = 1;
    }

    /**
     * Adds a new order to the pending queue.
     * @param itemDetails Details of the item(s) in the order.
     * @param quantity The quantity of items.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addOrder(String itemDetails, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        Order newOrder = new Order(nextOrderId++, itemDetails, quantity);
        orderQueue.offer(newOrder); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
        System.out.println("Order #" + newOrder.getOrderId() + " added to queue.");
    }

    /**
     * Processes the next order from the queue and records it as a shipment.
     * @throws EmptyQueueException if the order queue is empty.
     */
    public void processNextOrder() throws EmptyQueueException {
        Order orderToProcess = orderQueue.poll(); // poll() retrieves and removes the head, returns null if empty

        if (orderToProcess == null) {
            throw new EmptyQueueException("No pending orders to process.");
        }

        // Create a shipment record
        Shipment completedShipment = new Shipment(nextShipmentId++, orderToProcess.getOrderId(), new Date());
        completedShipments.add(completedShipment);

        System.out.println("Order #" + orderToProcess.getOrderId() + " (" + orderToProcess.getItemDetails() + ", Qty: " + orderToProcess.getQuantity() + ") processed. Shipment #" + completedShipment.getShipmentId() + " recorded.");
    }

    /**
     * Displays all pending orders in the queue.
     */
    public void displayPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all completed shipments.
     */
    public void displayCompletedShipments() {
        System.out.println("\n--- Completed Shipments ---");
        if (completedShipments.isEmpty()) {
            System.out.println("No completed shipments.");
        } else {
            // Iterate through the list
            for (Shipment shipment : completedShipments) {
                System.out.println(shipment);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main interactive menu loop for the warehouse system.
     * Handles user input and dispatches operations.
     * Includes class-wide exception handling.
     * @param scanner The Scanner object for reading input.
     */
    public void runMenu(Scanner scanner) {
        int choice = -1; // Initialize with a value outside the menu range

        while (choice != 5) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read integer input
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Order
                        System.out.print("Enter item details: ");
                        String itemDetails = scanner.nextLine();
                        System.out.print("Enter quantity: ");
                        int quantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        // Input validation and exception handling for addOrder
                        try {
                            addOrder(itemDetails, quantity);
                        } catch (IllegalArgumentException e) {
                            System.err.println("ERROR: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Pending Order
                        // Exception handling for processNextOrder
                        try {
                            processNextOrder();
                        } catch (EmptyQueueException e) {
                            System.err.println("ERROR: " + e.getMessage());
                        }
                        break;

                    case 3: // View Pending Orders
                        displayPendingOrders();
                        break;

                    case 4: // View Completed Shipments
                        displayCompletedShipments();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        break;

                    default: // Invalid choice
                        System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 5.");
                }

            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice or quantity
                System.err.println("ERROR: Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            } finally {
                 // Optional: actions to perform regardless of exception, e.g., logging
            }

            System.out.println(); // Add a blank line for readability between operations
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Pending Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Shipments");
        System.out.println("5. Exit");
    }
}

// Main class to start the application
public class WarehouseApp {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        WarehouseSystem system = new WarehouseSystem();

        // Start the menu loop within the WarehouseSystem instance
        system.runMenu(scanner);

        scanner.close(); // Close the scanner when done
    }
}
