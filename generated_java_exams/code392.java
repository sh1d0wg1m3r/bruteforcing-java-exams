/*
 * Exam Question #392
 * Generated on: 2025-05-11 23:04:16
 * Generated by: Account 1
 * 
 * QUESTION:
 * Design and implement a simplified Task Management System for a small team. The system should allow users to add new tasks, mark existing tasks as "ready for processing", process tasks from a dedicated processing queue, and view the status of all tasks and the contents of the processing queue.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Core Data Structures:**
 *     *   Maintain a central list of all tasks using `java.util.ArrayList`.
 *     *   Maintain a queue of tasks that are ready for processing using `java.util.Queue` (e.g., implemented by `java.util.LinkedList`).
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to accept user input for menu choices and task details.
 *     *   Present a menu of options to the user.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle user menu selections.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 
 * 4.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, task lists, success messages, and other normal output.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, task not found, queue empty, task already processed).
 * 
 * 5.  **Task Representation:**
 *     *   Create a `Task` class with appropriate fields (e.g., description, status) and methods (e.g., to mark as ready, mark as completed).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * 6.  **Functionality:**
 *     *   **Add Task:** Prompt the user for a task description and add a new `Task` object to the main list.
 *     *   **Mark Task Ready:** Display the list of all tasks with indices. Prompt the user to select a task by number. If valid, mark the selected task as ready and add the *same* `Task` object instance to the processing queue. Handle cases where the task is already ready or completed.
 *     *   **Process Next Task:** Take the next task from the front of the processing queue. Mark the *corresponding* task in the main list as completed. Remove the task from the queue. Handle the case where the queue is empty.
 *     *   **View All Tasks:** Display all tasks in the main list, including their status (e.g., Pending, Ready, Completed).
 *     *   **View Processing Queue:** Display the tasks currently waiting in the processing queue.
 *     *   **Exit:** Terminate the program gracefully.
 * 
 * 7.  **Error Handling:**
 *     *   Implement input validation for user choices and task selection.
 *     *   Use `try-catch` blocks for class-wide exception handling, specifically wrapping the main application loop to catch any unexpected errors.
 *     *   Handle specific error conditions within methods (e.g., invalid index, empty queue) using `System.err`.
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary to explain complex logic.
 *     *   Ensure resource cleanup (e.g., closing the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting input, and displaying results or errors based on user actions. Example interaction might look like:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Mark Task Ready for Processing
 * 3. Process Next Task from Queue
 * 4. View All Tasks
 * 5. View Processing Queue
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * Task added: Implement Task Class
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter task description: Write Exam Question
 * Task added: Write Exam Question
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- All Tasks ---
 * 1. [Pending] Implement Task Class
 * 2. [Pending] Write Exam Question
 * -----------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Select a task to mark as ready:
 * 
 * --- All Tasks ---
 * 1. [Pending] Implement Task Class
 * 2. [Pending] Write Exam Question
 * -----------------
 * Enter task number (index + 1): 1
 * Task 'Implement Task Class' marked ready and added to processing queue.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Processing Queue ---
 * 1. [Ready] Implement Task Class
 * ------------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Processed task: 'Implement Task Class'
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- All Tasks ---
 * 1. [Completed] Implement Task Class
 * 2. [Pending] Write Exam Question
 * -----------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Processing queue is empty.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Structure:**
 * The system is composed of two main classes:
 * 1.  `Task`: Represents an individual task with a description and boolean flags for its status (`isCompleted`, `isReadyForProcessing`). It includes a constructor and methods (`markReady`, `markCompleted`) to manage the task's state, ensuring state transitions are logical. The `toString` method provides a convenient way to display the task status. Encapsulation is achieved by making fields private and providing public access/modifier methods.
 * 2.  `TaskManager`: This is the main class that orchestrates the system. It holds the data structures (`allTasks` and `processingQueue`) and the application logic (menu, user interaction, task operations).
 * 
 * **Data Structures:**
 * -   `List<Task> allTasks = new ArrayList<>();`: An `ArrayList` is used to store all tasks created in the system. It's declared using the `List` interface type, which is a good practice for flexibility. `ArrayList` provides dynamic resizing and efficient random access by index, useful for viewing all tasks or selecting one by number.
 * -   `Queue<Task> processingQueue = new LinkedList<>();`: A `Queue` is used to manage tasks that are ready to be worked on. `LinkedList` is chosen as it implements the `Queue` interface and is suitable for efficient additions to the tail (`offer`) and removals/accesses from the head (`poll`, `peek`). This structure naturally supports a FIFO (First-In, First-Out) processing order.
 * 
 * **Workflow and Object Management:**
 * -   When a task is added (`addTask`), a new `Task` object is created and added to `allTasks`.
 * -   When a task is marked ready (`markTaskReady`), the existing `Task` object is retrieved from `allTasks` by index. Its internal state is updated (`markReady()`), and the *same object reference* is added to the `processingQueue` using `offer()`. This is crucial: the list and the queue hold references to the same `Task` objects.
 * -   When a task is processed (`processNextTask`), the next `Task` object is retrieved from the front of the `processingQueue` using `peek()`. The `markCompleted()` method is called on this object. Because it's the same object instance stored in `allTasks`, its status automatically updates in the main list. Finally, the task is removed from the queue using `poll()`.
 * 
 * **User Interaction and Control Flow:**
 * -   `Scanner`: The `Scanner` object reads user input from `System.in`. Helper methods like `getUserChoice()` handle reading specific input types and basic validation.
 * -   `displayMenu()`: Prints the available options using `System.out`.
 * -   `run()` method: Contains the main application loop (`while(true)`). Inside the loop, it displays the menu, gets user input, and uses a `switch` statement to direct execution to the appropriate method based on the `choice`. The loop continues until the user enters `0`, which triggers a `return` from the `run` method.
 * 
 * **Input/Output:**
 * -   `System.out`: Used for all normal output, such as the menu, task lists, and success messages.
 * -   `System.err`: Used specifically for printing error messages, making them distinct from standard output. This is used for invalid inputs, attempts to mark/process tasks in invalid states, etc.
 * 
 * **Error Handling:**
 * -   **Specific Error Handling:** Methods like `addTask`, `markTaskReady`, and `processNextTask` include checks for specific error conditions (e.g., empty description, invalid task index, empty queue, task already completed/ready) and print informative messages using `System.err`.
 * -   **Input Validation:** The `getUserChoice` method validates that the input is an integer and consumes invalid tokens. `markTaskReady` validates the task index against the `allTasks` list size.
 * -   **Class-wide Exception Handling:** The `run()` method's main loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected runtime exceptions that might occur within the application logic, preventing the program from crashing abruptly and providing a general error message using `System.err`.
 * -   **Resource Cleanup:** A `finally` block in the `run()` method ensures that the `Scanner` object is closed when the `try` block finishes (either normally or due to an exception), releasing the underlying system resource.
 * 
 * **Best Practices:**
 * -   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed or modified via public methods.
 * -   **Meaningful Names:** Variables (`allTasks`, `processingQueue`, `description`, `taskToMark`), methods (`addTask`, `markTaskReady`, `processNextTask`), and classes (`Task`, `TaskManager`) have names reflecting their purpose.
 * -   **Comments:** Basic comments explain the purpose of classes, methods, and key code sections.
 * -   **Clean Code:** The logic is broken down into smaller, focused methods.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, well-structured application that follows best practices for encapsulation, validation, and error handling. The challenge lies in correctly managing the state of `Task` objects across the list and the queue and handling various user input scenarios robustly.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task with a description and status.
 */
class Task {
    private String description;
    private boolean isCompleted;
    private boolean isReadyForProcessing;

    /**
     * Constructs a new Task with a given description.
     * Initially, tasks are neither completed nor ready.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.isCompleted = false;
        this.isReadyForProcessing = false;
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    public boolean isReadyForProcessing() {
        return isReadyForProcessing;
    }

    // --- State Change Methods ---
    /**
     * Marks the task as ready for processing.
     * A task can only be marked ready if it's not already completed.
     */
    public void markReady() {
        if (!this.isCompleted) {
             this.isReadyForProcessing = true;
        } else {
            // In a real system, maybe throw an exception. For this exam, print error.
            System.err.println("Error: Task '" + description + "' is already completed and cannot be marked ready.");
        }
    }

    /**
     * Marks the task as completed.
     * A task can only be completed if it's marked ready and not already completed.
     */
    public void markCompleted() {
        if (this.isReadyForProcessing && !this.isCompleted) {
            this.isCompleted = true;
            this.isReadyForProcessing = false; // No longer ready once completed
        } else if (this.isCompleted) {
             System.err.println("Error: Task '" + description + "' is already completed.");
        } else {
             System.err.println("Error: Task '" + description + "' is not ready for processing yet.");
        }
    }

    /**
     * Returns a string representation of the task including its status.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        String status = "Pending";
        if (isCompleted) {
            status = "Completed";
        } else if (isReadyForProcessing) {
            status = "Ready";
        }
        return "[" + status + "] " + description;
    }
}

/**
 * Manages a collection of tasks, including a processing queue.
 */
public class TaskManager {
    // Use List interface type, implemented by ArrayList
    private List<Task> allTasks;
    // Use Queue interface type, implemented by LinkedList
    private Queue<Task> processingQueue;
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing task lists and scanner.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Mark Task Ready for Processing");
        System.out.println("3. Process Next Task from Queue");
        System.out.println("4. View All Tasks");
        System.out.println("5. View Processing Queue");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input errors.
     * @return The valid integer choice entered by the user.
     */
    private int getUserChoice() {
        // Loop until a valid integer is entered
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
            scanner.next(); // Consume the invalid input (e.g., a String)
            System.out.print("Enter your choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return choice;
    }

    /**
     * Adds a new task based on user input.
     * Validates that the description is not empty.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return; // Exit the method if input is invalid
        }

        Task newTask = new Task(description.trim());
        allTasks.add(newTask); // Add to the main list
        System.out.println("Success: Task added: '" + newTask.getDescription() + "'");
    }

    /**
     * Marks a task as ready and adds it to the processing queue.
     * Prompts the user to select a task by its displayed number.
     * Includes input validation for the task number.
     */
    private void markTaskReady() {
        if (allTasks.isEmpty()) {
            System.out.println("Info: No tasks available to mark as ready.");
            return;
        }

        System.out.println("\nSelect a task to mark as ready:");
        viewAllTasks(); // Display tasks with their numbers (index + 1)

        System.out.print("Enter task number (from the list above): ");
        while (!scanner.hasNextInt()) {
             System.err.println("Invalid input. Please enter a number.");
             scanner.next(); // Consume invalid input
             System.out.print("Enter task number: ");
        }
        int taskNumber = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        int index = taskNumber - 1; // Convert task number to 0-based index

        // Validate index range
        if (index < 0 || index >= allTasks.size()) {
            System.err.println("Error: Invalid task number.");
            return;
        }

        Task taskToMark = allTasks.get(index); // Get the task object from the list

        // Check current task status before marking
        if (taskToMark.isReadyForProcessing()) {
            System.out.println("Info: Task '" + taskToMark.getDescription() + "' is already in the processing queue.");
            return;
        }
        if (taskToMark.isCompleted()) {
             System.out.println("Info: Task '" + taskToMark.getDescription() + "' is already completed.");
             return;
        }

        taskToMark.markReady(); // Update the state of the task object
        processingQueue.offer(taskToMark); // Add the *same* object instance to the queue

        System.out.println("Success: Task '" + taskToMark.getDescription() + "' marked ready and added to processing queue.");
    }

    /**
     * Processes the next task from the front of the processing queue.
     * Marks the task as completed in the main list (since it's the same object).
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        if (processingQueue.isEmpty()) {
            System.out.println("Info: Processing queue is empty. No tasks to process.");
            return;
        }

        // Peek first to get the task object without removing it yet
        Task taskToProcess = processingQueue.peek();

        // Since the object in the queue is the same instance as in allTasks,
        // calling markCompleted() on it updates its state globally.
        // No need to search for it in allTasks explicitly.
        taskToProcess.markCompleted(); // Update the state of the task object

        // If markCompleted() was successful (which it should be if it came from the queue),
        // then remove it from the queue.
        // We could add a check here based on markCompleted's return if it returned boolean,
        // but given our Task class implementation, it just prints errors internally.
        // So we assume if it's in the queue, it's ready to be marked completed.
        processingQueue.poll(); // Remove the task from the front of the queue

        System.out.println("Success: Processed task: '" + taskToProcess.getDescription() + "'");
    }

    /**
     * Displays all tasks currently in the system's main list.
     */
    private void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("Info: No tasks in the system.");
            return;
        }
        System.out.println("\n--- All Tasks ---");
        // Iterate through the list and print each task with its number (index + 1)
        for (int i = 0; i < allTasks.size(); i++) {
            System.out.println((i + 1) + ". " + allTasks.get(i));
        }
        System.out.println("-----------------");
    }

    /**
     * Displays all tasks currently waiting in the processing queue.
     */
    private void viewProcessingQueue() {
        if (processingQueue.isEmpty()) {
            System.out.println("Info: Processing queue is empty.");
            return;
        }
        System.out.println("\n--- Processing Queue ---");
        // Iterate through the queue (for viewing purposes) and print each task
        int i = 1;
        for (Task task : processingQueue) {
            System.out.println(i++ + ". " + task);
        }
        System.out.println("------------------------");
    }

    /**
     * The main application loop that displays the menu and handles user choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        try {
            // Main application loop
            while (true) {
                displayMenu();
                int choice = getUserChoice();

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        markTaskReady();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewAllTasks();
                        break;
                    case 5:
                        viewProcessingQueue();
                        break;
                    case 0:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        return; // Exit the run method and terminate the program
                    default:
                        // Handles choices outside the 0-5 range
                        System.err.println("Invalid choice. Please enter a number between 0 and 5.");
                }
            }
        } catch (Exception e) {
            // Class-wide catch block for any unexpected runtime exceptions
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            // In a real application, you might log the exception or provide more detail.
            // e.printStackTrace(); // Uncomment for detailed debugging output in exam
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                // Optional: Confirmation message
                // System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
