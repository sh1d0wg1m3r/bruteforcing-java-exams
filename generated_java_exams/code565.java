/*
 * Exam Question #565
 * Generated on: 2025-05-11 23:30:08
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Production Line Task Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a console-based simulation of a simple production line task management system. The system needs to manage tasks waiting to be processed and keep a record of tasks that have been completed. Tasks arrive and are processed in a First-In, First-Out (FIFO) manner.
 * 
 * **Task Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each `Task` should have:
 *     *   A unique integer `id`.
 *     *   A `description` (String).
 *     *   A `status` (e.g., "PENDING", "COMPLETED").
 * 
 * 2.  **Task Management:** Create a class named `ProductionLineManager` that handles the core logic. This class should:
 *     *   Maintain a collection of tasks waiting to be processed. This collection must be implemented using `java.util.Queue`.
 *     *   Maintain a collection of tasks that have been completed. This collection must be implemented using `java.util.ArrayList` and declared using the `java.util.List` interface.
 *     *   Provide methods to:
 *         *   Add a new task to the pending queue. Tasks should be automatically assigned a unique ID starting from 1.
 *         *   Process the next task: remove the next task from the pending queue (if any), update its status to "COMPLETED", and add it to the completed tasks list.
 *         *   List all pending tasks.
 *         *   List all completed tasks.
 * 
 * 3.  **User Interface:** Implement a console-based user interface in the `main` method of a separate class (e.g., `ProductionLineApp`). The interface should:
 *     *   Display a menu of options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  List Pending Tasks
 *         4.  List Completed Tasks
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display normal program output and status messages using `System.out`.
 *     *   Display error messages using `System.err`.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for the menu choice to ensure the user enters a valid integer corresponding to a menu option.
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `java.util.InputMismatchException` during integer input.
 *     *   Gracefully handle cases where the user tries to process a task when the pending queue is empty.
 *     *   Gracefully handle cases where the user tries to list tasks when the respective queue or list is empty.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure the `Scanner` resource is closed properly upon exiting the application.
 * 
 * **Required Java Components Checklist:**
 * 
 * *   [ ] `java.util.Queue`
 * *   [ ] `java.util.ArrayList`
 * *   [ ] `java.util.List` interface
 * *   [ ] `java.util.Scanner`
 * *   [ ] `switch` statement
 * *   [ ] `System.err`
 * *   [ ] `System.out`
 * *   [ ] Class-wide exception handling with `try-catch` blocks
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Assemble Component X
 * Task added: Task{id=1, description='Assemble Component X', status='PENDING'}
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Quality Check Part Y
 * Task added: Task{id=2, description='Quality Check Part Y', status='PENDING'}
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=1, description='Assemble Component X', status='PENDING'}
 * Task{id=2, description='Quality Check Part Y', status='PENDING'}
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Assemble Component X', status='PENDING'}
 * Task 1 completed.
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=2, description='Quality Check Part Y', status='PENDING'}
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Assemble Component X', status='COMPLETED'}
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: invalid_input
 * java.util.InputMismatchException: Invalid input. Please enter a number.
 * --- Production Line Menu ---
 * 1. Add New Task
 * ... (menu repeats)
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Production Line Menu ---
 * 1. Add New Task
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Production Line Manager.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Task`, `ProductionLineManager`, and the main application class (`ProductionLineApp`).
 *
 * EXPLANATION:
 * The solution implements a simple production line task management system using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class encapsulates the data for a single task (`id`, `description`, `status`).
 *     *   It uses private fields and public getter methods, demonstrating encapsulation.
 *     *   The `markAsCompleted()` method changes the internal state, showing behavior encapsulation.
 *     *   `toString()` provides a convenient way to print task details.
 * 
 * 2.  **`ProductionLineManager` Class:**
 *     *   This class manages the collections of tasks.
 *     *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation for the `Queue` interface, providing FIFO behavior. `Queue` methods like `offer()` (add) and `poll()` (retrieve and remove) are used.
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is used for dynamic resizing and easy storage of completed tasks. Using the `List` interface for declaration is good practice as it allows for flexibility if a different `List` implementation was needed later.
 *     *   `nextTaskId`: A simple counter ensures each task gets a unique ID.
 *     *   Methods like `addTask()`, `processNextTask()`, `listPendingTasks()`, and `listCompletedTasks()` encapsulate the logic for managing the task collections.
 *     *   These methods include checks for empty collections (`taskQueue.isEmpty()`, `completedTasks.isEmpty()`) before attempting operations or listing, providing graceful handling.
 * 
 * 3.  **`ProductionLineApp` Class (Main Application):**
 *     *   The `main` method contains the application's entry point and the main loop for the user interface.
 *     *   `Scanner`: An instance is created to read input from the console (`System.in`).
 *     *   `ProductionLineManager`: An instance is created to handle the task logic.
 *     *   **Main Loop and `switch`:** A `while(running)` loop keeps the application active until the user chooses to exit. A `displayMenu()` method keeps the `main` method cleaner. Inside the loop, a `switch` statement directs the flow based on the user's integer input, calling the appropriate methods on the `manager` object.
 *     *   **`try-catch` Handling:**
 *         *   An inner `try-catch(InputMismatchException e)` is specifically used when reading the integer menu choice (`scanner.nextInt()`). This catches non-integer input. If caught, an error message is printed to `System.err`, the invalid input line is consumed (`scanner.nextLine()`), and `continue` restarts the loop, prompting the user again.
 *         *   An outer `try-catch(Exception e)` wraps the entire `while` loop. This acts as a general catch-all for any other unexpected runtime exceptions that might occur during the application's execution, printing the error to `System.err`.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for normal output (menu, task added, task completed, listing tasks). `System.err.println()` is used specifically for error messages (invalid input, empty description).
 *     *   **Scanner Closing:** The `finally` block ensures that `scanner.close()` is called regardless of whether the loop finishes normally (user exits) or an unexpected exception occurs. This releases the system resource associated with the scanner.
 * 
 * This solution effectively demonstrates the required Java components in a practical scenario, adhering to best practices for object-oriented design, input handling, and error management.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the production line.
 */
class Task {
    private int id;
    private String description;
    private String status; // Could be an enum, but String is simpler for this problem

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markAsCompleted() {
        this.status = "COMPLETED";
    }

    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class ProductionLineManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> taskQueue;

    // List to hold tasks that have been completed
    private List<Task> completedTasks;

    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new ProductionLineManager.
     */
    public ProductionLineManager() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation for completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        taskQueue.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but fine here
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the queue, marks it as completed, and adds it to the completed list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll() returns null if queue is empty

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.markAsCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " completed.");
        } else {
            System.out.println("No pending tasks to process.");
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Lists all tasks that have been completed.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }
}

/**
 * Main application class for the Production Line Task Management System.
 * Handles user interaction and menu driven operations.
 */
public class ProductionLineApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Production Line Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLineManager manager = new ProductionLineManager();
        boolean running = true;

        // Outer try-catch for general exception handling during the application lifecycle
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Initialize choice to an invalid value

                // Inner try-catch for handling input specific exceptions like InputMismatchException
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Use System.err for reporting input errors
                    System.err.println("java.util.InputMismatchException: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and display menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Task description cannot be empty.");
                        } else {
                           manager.addTask(description.trim());
                        }
                        break;
                    case 2:
                        manager.processNextTask();
                        break;
                    case 3:
                        manager.listPendingTasks();
                        break;
                    case 4:
                        manager.listCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Production Line Manager.");
                        break;
                    default:
                        System.out.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
