/*
 * Exam Question #435
 * Generated on: 2025-05-11 23:10:45
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam: Workflow Processor**
 * 
 * **Objective:**
 * Design and implement a simple command-line Workflow Processor application in Java. This application will manage tasks that move through a basic workflow: from a pending state (waiting to be processed) to a completed state. Your solution must demonstrate a strong understanding of core Java concepts, including collections, input handling, control flow, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a `Task` class with private fields for `description` (String) and `status` (String, e.g., "Pending", "Completed").
 *     *   Provide a constructor to initialize a task with a description, setting the initial status to "Pending".
 *     *   Include public getter methods for the fields.
 *     *   Include a public setter method for the status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (e.g., "[Status: Pending] Task description here").
 * 
 * 2.  **Workflow Management:**
 *     *   Create a `TaskManager` class.
 *     *   Inside `TaskManager`, use a `java.util.Queue` to store tasks that are pending processing. Choose an appropriate implementation of the `Queue` interface (e.g., `LinkedList`).
 *     *   Inside `TaskManager`, use a `java.util.List` (declared using the `List` interface type) to store tasks that have been completed. Use `java.util.ArrayList` as the concrete implementation.
 *     *   Implement the following methods in `TaskManager`:
 *         *   `addTask(String description)`: Creates a new `Task` object and adds it to the pending queue. Validate that the description is not null or empty. Use `System.err` for validation errors. Use `System.out` for success messages.
 *         *   `processNextTask()`: Retrieves the next task from the pending queue, changes its status to "Completed", and moves it to the completed list. If the pending queue is empty, print an error message using `System.err`. Use `System.out` for success messages.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue using `System.out`. Indicate if the queue is empty.
 *         *   `viewCompletedTasks()`: Displays all tasks currently in the completed list using `System.out`. Indicate if the list is empty.
 * 
 * 3.  **User Interface:**
 *     *   In the `TaskManager` class (or a separate class with a `main` method that uses `TaskManager`), create a simple command-line menu loop.
 *     *   Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 *     *   Display the following menu options using `System.out`:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Handle invalid menu options (e.g., entering a number outside the range 1-5 or non-numeric input) by printing an error message using `System.err` and allowing the user to try again.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `TaskManager` or the class containing the main application loop. This block should catch general exceptions that might occur during the program's execution (e.g., unexpected issues in input processing or logic). Print an error message and stack trace using `System.err` if an unexpected exception occurs.
 *     *   Ensure specific input validation and operational errors (like processing an empty queue) are handled as described in requirement 2 & 3, using `System.err`.
 *     *   Properly handle potential `InputMismatchException` when reading numeric input from the `Scanner`.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments where necessary to explain complex logic.
 *     *   Ensure `Scanner` resources are properly closed.
 * 
 * **Expected Output:**
 * 
 * Your program should present a menu, accept user input, perform the requested actions, and print appropriate messages using `System.out` for normal operations and `System.err` for errors or invalid input. The output should clearly show tasks being added, processed, and listed.
 * 
 * Example interaction flow:
 * ```
 * --- Workflow Processor Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * -----------------------------
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: "Write exam question"
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Create solution code
 * Task added: "Create solution code"
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [Status: Pending] Write exam question
 * 2. [Status: Pending] Create solution code
 * ---------------------
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 2
 * Task processed: "Write exam question"
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [Status: Pending] Create solution code
 * ---------------------
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. [Status: Completed] Write exam question
 * -----------------------
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 2
 * Task processed: "Create solution code"
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Workflow Processor Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Workflow Processor. Goodbye!
 * ```
 * 
 * **Evaluation Criteria:**
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Proper implementation of `Task` and `TaskManager` classes.
 * *   Effective use of `Scanner` for input.
 * *   Correct implementation of the `switch` statement for menu navigation.
 * *   Appropriate use of `System.out` and `System.err`.
 * *   Robust error handling, including input validation, operational error checks, and class-wide exception handling.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   The solution compiles and runs correctly according to the requirements.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * The solution implements a simple Workflow Processor demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (`description` and `status`). It follows best practices with private fields, a constructor for initialization, and public getters/setters. The `toString()` method provides a convenient way to display task information. Input validation for the description is done in the constructor using an `IllegalArgumentException`.
 * 
 * 2.  **`TaskManager` Class:** This class manages the collections of tasks.
 *     *   `pendingTasks` is declared as a `Queue<Task>` and instantiated as a `LinkedList`. This correctly uses the `Queue` interface and a common implementation suitable for adding to one end and removing from the other (FIFO - First-In, First-Out).
 *     *   `completedTasks` is declared as a `List<Task>` and instantiated as an `ArrayList`. This demonstrates using the `List` interface type while using a concrete `ArrayList` implementation, which is efficient for storing and iterating over completed items.
 *     *   `addTask()`: Takes a description, creates a `Task`, and uses `pendingTasks.offer()` to add it to the queue. It includes a `try-catch` to handle the `IllegalArgumentException` from the `Task` constructor and uses `System.err` for the error message, fulfilling a requirement.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` is suitable as it returns `null` if the queue is empty, which is checked to print an error using `System.err` as required. If a task is retrieved, its status is updated, and it's added to the `completedTasks` `List`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: These methods iterate through their respective collections and print the tasks using `System.out`. They check for empty collections and print appropriate messages. Iterating directly over the `Queue` is acceptable for simply viewing its contents without removing them.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   The `run()` method contains the main application loop.
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   `printMenu()` displays the options using `System.out`.
 *     *   A `while` loop continues until the user chooses option 5 (Exit).
 *     *   Inside the loop, `scanner.nextInt()` reads the menu choice, followed by `scanner.nextLine()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   A `switch` statement handles the different integer choices, calling the appropriate `TaskManager` methods.
 *     *   The `default` case of the `switch` handles integer choices outside the valid range (1-5) and prints an error using `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   An inner `try-catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input when a number is expected for the menu choice. It prints an error using `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   An outer `try-catch (Exception e)` block wraps the entire `while` loop in the `run()` method. This serves as the "class-wide exception handling" mechanism, catching any other unexpected runtime exceptions that might occur within the loop. It prints a generic error message and the stack trace using `System.err` for debugging.
 *     *   Specific operational errors, like calling `processNextTask()` on an empty queue, are handled within the method itself using an `if (nextTask == null)` check and `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in both `Task` and `TaskManager`.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`).
 *     *   Comments explain the purpose of classes, methods, and key logic points.
 *     *   Input validation for the task description is performed.
 *     *   Error handling distinguishes between input errors (`InputMismatchException`), validation errors (`IllegalArgumentException` caught in `addTask`), operational errors (empty queue checked in `processNextTask`), and unexpected errors (general `Exception` caught in `run`).
 *     *   The `Scanner` is closed in a `finally` block to ensure resource cleanup.
 * 
 * This solution effectively integrates all the required components into a functional and well-structured program, demonstrating advanced Java concepts and best practices within a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the workflow
class Task {
    private String description;
    private String status;

    /**
     * Constructs a new Task with a description and sets initial status to "Pending".
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.status = "Pending";
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string including status and description.
     */
    @Override
    public String toString() {
        return "[Status: " + status + "] " + description;
    }
}

// Manages the collection of pending and completed tasks
class TaskManager {
    // Queue for tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Using List interface type

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        pendingTasks = new LinkedList<>(); // Implementation of Queue
        completedTasks = new ArrayList<>(); // Implementation of List
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            pendingTasks.offer(newTask); // offer() is preferred for capacity-constrained queues, good practice
            System.out.println("Task added: \"" + description + "\"");
        } catch (IllegalArgumentException e) {
            // Use System.err for validation errors
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the pending queue, moving it to the completed list.
     */
    public void processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll() retrieves and removes the head, returns null if empty
        if (nextTask == null) {
            // Use System.err for operational errors (like empty queue)
            System.err.println("Error: No pending tasks to process.");
        } else {
            nextTask.setStatus("Completed");
            completedTasks.add(nextTask); // Add to the completed list
            System.out.println("Task processed: \"" + nextTask.getDescription() + "\"");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            System.out.println("--- Pending Tasks ---");
            int index = 1;
            // Iterating over a Queue is safe for viewing elements
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            System.out.println("--- Completed Tasks ---");
            int index = 1;
            // Iterating over a List
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Workflow Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide exception handling wrapping the main application loop
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    // Read user input for menu choice
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            addTask(description);
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Workflow Processor. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid menu options
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to ensure loop continues
                }
                System.out.println(); // Add a newline for better spacing between interactions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Workflow Processor application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
