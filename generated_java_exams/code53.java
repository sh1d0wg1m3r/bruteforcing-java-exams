/*
 * Exam Question #53
 * Generated on: 2025-05-11 22:06:01
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory and Order Fulfillment System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line application for managing inventory and processing orders in a small warehouse. The system needs to keep track of products in stock and process incoming customer orders on a first-in, first-out basis. Orders must be fulfilled completely; the system does not support partial order fulfillment.
 * 
 * **Requirements:**
 * 
 * 1.  **Project Structure:** Create a Java program with the following classes:
 *     *   `Product`: Represents an item in the warehouse inventory.
 *     *   `OrderItem`: Represents a specific product and quantity requested within an `Order`.
 *     *   `Order`: Represents a customer order containing a list of `OrderItem`s.
 *     *   `WarehouseSystem`: The main class that manages the inventory, incoming orders, processed orders, and handles user interaction.
 * 
 * 2.  **`Product` Class:**
 *     *   Must have `private` fields: `id` (int), `name` (String), `quantity` (int).
 *     *   Include a constructor and `public` getter methods for all fields.
 *     *   Include a `public` method `updateQuantity(int delta)` to adjust the quantity (add or subtract). Ensure quantity does not go below zero.
 * 
 * 3.  **`OrderItem` Class:**
 *     *   Must have `private` fields: `productId` (int), `quantity` (int).
 *     *   Include a constructor and `public` getter methods.
 * 
 * 4.  **`Order` Class:**
 *     *   Must have `private` fields: `orderId` (int), `items` (`List<OrderItem>`).
 *     *   Include a constructor and a `public` getter for `items`.
 * 
 * 5.  **`WarehouseSystem` Class:**
 *     *   Must have `private` fields:
 *         *   `inventory`: A `List` (specifically, an `ArrayList`) to store `Product` objects.
 *         *   `incomingOrders`: A `Queue` (use an implementation like `java.util.LinkedList`) to store `Order` objects waiting to be processed.
 *         *   `processedOrders`: A `List` (specifically, an `ArrayList`) to store `Order` objects that have been successfully fulfilled.
 *         *   `nextOrderId`: An integer to assign unique IDs to new orders, starting from 1.
 *         *   `scanner`: A `Scanner` object for reading user input.
 *     *   **Constructor:** Initialize the collections (`inventory`, `incomingOrders`, `processedOrders`). Pre-populate the `inventory` list with at least 3 distinct `Product`s with initial quantities. Initialize `nextOrderId` and the `scanner`.
 *     *   **`run()` Method:** Implement the main application loop. Display a menu of options to the user. Read the user's choice using the `scanner`. Use a `switch` statement to handle the user's selection and call appropriate private methods. The loop should continue until the user chooses to exit.
 *     *   **Private Methods:** Implement methods for each menu option:
 *         *   `displayMenu()`: Prints the available options to `System.out`.
 *         *   `viewInventory()`: Prints the details (ID, name, quantity) of all products in the `inventory` list to `System.out`.
 *         *   `addIncomingOrder()`: Prompts the user to enter details for a new order. The user should specify the product ID and quantity for each item in the order. Allow the user to add multiple items to a single order. Validate user input:
 *             *   Ensure product ID exists in the inventory.
 *             *   Ensure quantity is positive.
 *             *   Handle potential `InputMismatchException` or `NumberFormatException` if the user enters non-integer input. Report errors using `System.err`.
 *             *   Collect valid `OrderItem`s into a `List`. If at least one valid item is entered, create a new `Order` with a unique ID (`nextOrderId++`) and add it to the `incomingOrders` queue. Confirm the order was added using `System.out`. If no valid items were entered, do not create the order.
 *         *   `processNextOrder()`: Attempts to process the order at the front of the `incomingOrders` queue (`peek()` first, then `poll()` if processing is possible).
 *             *   If the queue is empty, print a message to `System.out`.
 *             *   If an order exists, check if the required quantity for *every* `OrderItem` in the order is available in the `inventory`.
 *             *   If **all** items can be fulfilled: Decrement the quantity of each corresponding product in the `inventory`. Remove the order from `incomingOrders` (`poll()`) and add it to the `processedOrders` list. Print a success message to `System.out`.
 *             *   If **any** item cannot be fulfilled: Do NOT modify inventory quantities. Report the failure and the specific product(s) that caused it using `System.err`. The order remains in the `incomingOrders` queue (or is discarded, report clearly if discarded - discarding is simpler for this exam). For this exam, discard the order and report failure.
 *         *   `viewProcessedOrders()`: Prints the details (Order ID and items) of all orders in the `processedOrders` list to `System.out`.
 *         *   `exit()`: Prints a goodbye message to `System.out` and closes the `scanner`.
 * 
 * 6.  **Exception Handling:**
 *     *   Implement specific `try-catch` blocks within methods like `addIncomingOrder()` and `processNextOrder()` to handle expected issues like invalid input format or insufficient inventory checks. Report these using `System.err`.
 *     *   Wrap the call to `warehouseSystem.run()` in the `main` method with a `try-catch` block to demonstrate class-wide exception handling for any unexpected errors. Report such errors using `System.err`.
 * 
 * 7.  **Output:**
 *     *   Use `System.out` for all normal program output (menu, inventory listings, successful operations, status messages).
 *     *   Use `System.err` exclusively for reporting errors (invalid input, validation failures, insufficient stock, unhandled exceptions).
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply appropriate access modifiers (`private`, `public`).
 *     *   Include comments to explain complex logic or sections.
 *     *   Ensure input validation is performed where necessary.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Warehouse System Menu:
 * 1. View Inventory
 * 2. Add Incoming Order
 * 3. Process Next Order
 * 4. View Processed Orders
 * 5. Exit
 * Enter your choice: 1
 * --- Current Inventory ---
 * ID: 1, Name: Laptop, Quantity: 10
 * ID: 2, Name: Keyboard, Quantity: 50
 * ID: 3, Name: Mouse, Quantity: 30
 * -------------------------
 * Enter your choice: 2
 * --- Add New Order ---
 * Enter item details (Product ID, Quantity) or 'done' to finish:
 * Product ID: 1
 * Quantity: 2
 * Item added: Product ID 1, Quantity 2
 * Enter item details (Product ID, Quantity) or 'done' to finish:
 * Product ID: 2
 * Quantity: 5
 * Item added: Product ID 2, Quantity 5
 * Enter item details (Product ID, Quantity) or 'done' to finish:
 * Product ID: 99
 * Quantity: 1
 * Error: Invalid Product ID: 99. Item skipped.
 * Enter item details (Product ID, Quantity) or 'done' to finish:
 * done
 * Order 1 added to incoming queue.
 * ---------------------
 * Enter your choice: 3
 * Processing Order 1...
 * Order 1 successfully processed and fulfilled. Inventory updated.
 * Enter your choice: 1
 * --- Current Inventory ---
 * ID: 1, Name: Laptop, Quantity: 8
 * ID: 2, Name: Keyboard, Quantity: 45
 * ID: 3, Name: Mouse, Quantity: 30
 * -------------------------
 * Enter your choice: 3
 * Processing next order...
 * Incoming orders queue is empty. No order to process.
 * Enter your choice: 4
 * --- Processed Orders ---
 * Order ID: 1
 *   Item: Product ID 1, Quantity 2
 *   Item: Product ID 2, Quantity 5
 * ------------------------
 * Enter your choice: 5
 * Exiting Warehouse System. Goodbye!
 * ```
 * 
 * Your solution should implement the described functionality adhering to all specified requirements, including the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks.
 * 
 * **Grading Criteria:**
 * *   Correct implementation of all required classes and their fields/methods.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, and `switch`.
 * *   Accurate implementation of inventory management and order processing logic.
 * *   Robust input validation and error handling using `try-catch` and `System.err`.
 * *   Correct use of `System.out` for normal output.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Program runs without crashing on valid and reasonably invalid inputs.
 *
 * EXPLANATION:
 * The provided solution implements the Warehouse Inventory and Order Fulfillment System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * -   `Product`, `OrderItem`, and `Order` classes encapsulate the data for products, items within an order, and the orders themselves, respectively. They use `private` fields and `public` getters, adhering to encapsulation principles. `Product` includes a method to safely update quantity.
 * -   `WarehouseSystem` is the main class that orchestrates the system's operations. It holds the core data structures (`inventory`, `incomingOrders`, `processedOrders`) and the application logic.
 * 
 * **Data Structures:**
 * -   `inventory`: An `ArrayList<Product>` is used to store the list of available products. `ArrayList` is suitable here as we primarily need to store a collection of items and iterate through them or find by ID (which involves iteration). It fulfills the `List` and `ArrayList` requirements.
 * -   `incomingOrders`: A `Queue<Order>` implemented using `LinkedList<Order>` is used to store incoming orders. `Queue` is the natural choice for processing items in a FIFO (First-In, First-Out) manner, which is required for order processing. `LinkedList` is a common `Queue` implementation.
 * -   `processedOrders`: An `ArrayList<Order>` is used to store orders that have been successfully fulfilled. An `ArrayList` is fine here as we just need to store a history and display it. It fulfills the `List` and `ArrayList` requirements again.
 * 
 * **User Interaction (`Scanner`, `switch`):**
 * -   A `Scanner` object (`scanner`) is used in the `WarehouseSystem` constructor to read input from `System.in`.
 * -   The `run()` method contains the main application loop. It repeatedly displays a menu using `displayMenu()` and reads the user's integer choice.
 * -   A `switch` statement is used to direct the program flow based on the user's `choice`, calling the appropriate private methods (`viewInventory`, `addIncomingOrder`, etc.). This fulfills the `Scanner` and `switch` requirements.
 * 
 * **Core Logic (`addIncomingOrder`, `processNextOrder`):**
 * -   `addIncomingOrder()`: Prompts the user for product ID and quantity for each item. It uses a loop to allow adding multiple items. Input validation checks if the product ID exists and if the quantity is positive. Valid items are collected into a temporary `List<OrderItem>`. If the list is not empty after input, a new `Order` is created with a unique ID (`nextOrderId++`) and added to the `incomingOrders` queue using `offer()`.
 * -   `processNextOrder()`: Checks if the `incomingOrders` queue is empty using `isEmpty()`. If not, it peeks at the next order using `peek()` to check fulfillment possibility without removing it yet. It iterates through the order's items, finding corresponding products in the `inventory` list and checking if enough quantity is available for *all* items.
 *     -   If `canFulfill` remains `true` after checking all items, the order is removed from the queue using `poll()`, inventory quantities are decremented using the `Product.updateQuantity()` method, and the order is added to the `processedOrders` list.
 *     -   If `canFulfill` is `false` (due to insufficient stock for at least one item), an error is reported using `System.err`, and the order is removed from the `incomingOrders` queue using `poll()` (as per the requirement to discard failed orders in this model).
 * 
 * **Error Handling (`try-catch`, `System.err`):**
 * -   Specific `try-catch` blocks are used within `run()` and `addIncomingOrder()` to handle `InputMismatchException` when reading integer input from the `Scanner`, and `NumberFormatException` when parsing string input in `addIncomingOrder`. These catch blocks print informative error messages to `System.err` and handle the error gracefully (e.g., clearing the invalid scanner input, skipping an invalid order item).
 * -   `processNextOrder()` includes checks for insufficient stock and reports these specific business logic errors using `System.err`.
 * -   A comprehensive `try-catch` block wraps the `system.run()` call in the `main` method. This demonstrates class-wide exception handling, catching any `Exception` that might escape the main application logic and reporting it using `System.err` before the program terminates. This fulfills the class-wide `try-catch` and `System.err` requirements.
 * 
 * **Output (`System.out`, `System.err`):**
 * -   `System.out.println()` is used for all normal program output: displaying the menu, inventory lists, successful operations, order details, and status messages.
 * -   `System.err.println()` is used exclusively for reporting errors: invalid menu choices, invalid input formats, validation failures during order creation, insufficient stock during processing, and unhandled exceptions. This clearly separates normal output from error reporting.
 * 
 * **Best Practices:**
 * -   Meaningful names (`inventory`, `incomingOrders`, `processNextOrder`, `findProductById`, etc.) are used throughout the code.
 * -   Access modifiers (`private`, `public`) are used appropriately to enforce encapsulation.
 * -   Basic comments are included to explain the purpose of classes and key methods.
 * -   Input validation is performed in `addIncomingOrder`.
 * -   The `Scanner` resource is closed when the program exits in the `exit()` method.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application that simulates a real-world warehouse scenario, while adhering to best practices for code structure, encapsulation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a product in the warehouse inventory
class Product {
    private int id;
    private String name;
    private int quantity;

    public Product(int id, String name, int quantity) {
        this.id = id;
        this.name = name;
        this.quantity = quantity;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    // Updates the quantity, ensuring it doesn't go below zero
    public boolean updateQuantity(int delta) {
        if (this.quantity + delta >= 0) {
            this.quantity += delta;
            return true;
        }
        return false; // Cannot go below zero
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Quantity: " + quantity;
    }
}

// Represents an item within an order
class OrderItem {
    private int productId;
    private int quantity;

    public OrderItem(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public int getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "  Item: Product ID " + productId + ", Quantity " + quantity;
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<OrderItem> items; // Using List interface

    public Order(int orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = items;
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        for (OrderItem item : items) {
            sb.append(item.toString()).append("\n");
        }
        return sb.toString();
    }
}

// Main system class managing warehouse operations
public class WarehouseSystem {
    private List<Product> inventory; // Using List interface, implemented by ArrayList
    private Queue<Order> incomingOrders; // Using Queue interface, implemented by LinkedList
    private List<Order> processedOrders; // Using List interface, implemented by ArrayList
    private int nextOrderId;
    private Scanner scanner;

    public WarehouseSystem() {
        // Initialize collections
        inventory = new ArrayList<>();
        incomingOrders = new LinkedList<>(); // LinkedList implements Queue
        processedOrders = new ArrayList<>();
        nextOrderId = 1;
        scanner = new Scanner(System.in);

        // Pre-populate inventory
        inventory.add(new Product(101, "Laptop", 15));
        inventory.add(new Product(102, "Monitor", 25));
        inventory.add(new Product(103, "Webcam", 50));

        System.out.println("Warehouse System Initialized.");
    }

    // Main application loop
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        viewInventory();
                        break;
                    case 2:
                        addIncomingOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewProcessedOrders();
                        break;
                    case 5:
                        exit();
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during menu processing
                System.err.println("An unexpected error occurred during menu processing: " + e.getMessage());
                // e.printStackTrace(); // Optional: for debugging
            }
            System.out.println(); // Add a newline for better readability between actions
        }
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. View Inventory");
        System.out.println("2. Add Incoming Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Processed Orders");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }

    // Displays current inventory
    private void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product); // Uses Product.toString()
            }
        }
        System.out.println("-------------------------");
    }

    // Finds a product by its ID
    private Product findProductById(int id) {
        for (Product product : inventory) {
            if (product.getId() == id) {
                return product;
            }
        }
        return null; // Product not found
    }

    // Adds a new order to the incoming queue
    private void addIncomingOrder() {
        System.out.println("--- Add New Order ---");
        List<OrderItem> items = new ArrayList<>();
        String inputLine;

        System.out.println("Enter item details (Product ID, Quantity) or 'done' to finish:");

        while (true) {
            System.out.print("Item (e.g., '101 5') or 'done': ");
            inputLine = scanner.nextLine().trim();

            if (inputLine.equalsIgnoreCase("done")) {
                break;
            }

            try {
                String[] parts = inputLine.split(" ");
                if (parts.length != 2) {
                    System.err.println("Error: Invalid input format. Use 'ProductID Quantity'.");
                    continue;
                }

                int productId = Integer.parseInt(parts[0]);
                int quantity = Integer.parseInt(parts[1]);

                // Validate product ID existence
                Product product = findProductById(productId);
                if (product == null) {
                    System.err.println("Error: Invalid Product ID: " + productId + ". Item skipped.");
                    continue;
                }

                // Validate quantity
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive for Product ID " + productId + ". Item skipped.");
                    continue;
                }

                items.add(new OrderItem(productId, quantity));
                System.out.println("Item added: Product ID " + productId + ", Quantity " + quantity);

            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid number format for Product ID or Quantity.");
            } catch (Exception e) {
                // Catch any other unexpected errors during item input
                System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
            }
        }

        if (items.isEmpty()) {
            System.out.println("No valid items entered. Order not created.");
        } else {
            Order newOrder = new Order(nextOrderId++, items);
            incomingOrders.offer(newOrder); // Add to the end of the queue
            System.out.println("Order " + newOrder.getOrderId() + " added to incoming queue.");
        }
        System.out.println("---------------------");
    }

    // Processes the next order in the queue
    private void processNextOrder() {
        System.out.println("--- Processing Next Order ---");
        if (incomingOrders.isEmpty()) {
            System.out.println("Incoming orders queue is empty. No order to process.");
            System.out.println("-----------------------------");
            return;
        }

        // Peek at the order without removing it yet
        Order orderToProcess = incomingOrders.peek();
        System.out.println("Attempting to process Order " + orderToProcess.getOrderId() + "...");

        boolean canFulfill = true;
        List<Product> productsToUpdate = new ArrayList<>(); // Keep track of products involved

        try {
            // First pass: Check if all items can be fulfilled
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProductId());
                if (product == null) {
                    // This shouldn't happen if addIncomingOrder validates, but good practice
                    System.err.println("Error: Product with ID " + item.getProductId() + " not found in inventory during processing.");
                    canFulfill = false;
                    break; // Cannot fulfill if product doesn't exist
                }
                if (product.getQuantity() < item.getQuantity()) {
                    System.err.println("Insufficient stock for Product ID " + product.getId() + " (" + product.getName() + "). Needed: " + item.getQuantity() + ", Available: " + product.getQuantity() + ".");
                    canFulfill = false;
                    // Don't break, check all items to report all shortages
                }
                productsToUpdate.add(product); // Add product to list for potential update
            }

            if (canFulfill) {
                // Second pass: Decrement quantities if fulfillment is possible
                Order processedOrder = incomingOrders.poll(); // Remove from queue
                for (OrderItem item : processedOrder.getItems()) {
                    Product product = findProductById(item.getProductId()); // Re-find product
                    // We already checked availability, so update should succeed
                    product.updateQuantity(-item.getQuantity());
                }
                processedOrders.add(processedOrder); // Add to processed list
                System.out.println("Order " + processedOrder.getOrderId() + " successfully processed and fulfilled. Inventory updated.");
            } else {
                // Cannot fulfill - report error and discard the order
                System.err.println("Order " + orderToProcess.getOrderId() + " cannot be fulfilled due to insufficient stock. Order discarded.");
                incomingOrders.poll(); // Remove the order that couldn't be fulfilled
            }
        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during order processing: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
            // Decide what to do with the order - maybe leave it in queue or discard?
            // For simplicity here, we'll assume if an error happens, the order processing failed.
            // If peek() succeeded but poll() or quantity update failed, the order might be lost or stuck.
            // A more robust system would handle this failure more carefully.
            // For this exam, we'll assume if an exception occurs during the fulfillment logic *after* peek,
            // the order is problematic and we might remove it to prevent infinite loops.
            // Let's remove it to simplify state for the exam.
             if (orderToProcess != null) {
                 System.err.println("Removing problematic Order " + orderToProcess.getOrderId() + " from queue.");
                 incomingOrders.remove(orderToProcess); // Attempt to remove the problematic order
             }
        }
        System.out.println("-----------------------------");
    }

    // Displays successfully processed orders
    private void viewProcessedOrders() {
        System.out.println("--- Processed Orders ---");
        if (processedOrders.isEmpty()) {
            System.out.println("No orders have been processed yet.");
        } else {
            for (Order order : processedOrders) {
                System.out.print(order); // Uses Order.toString()
            }
        }
        System.out.println("------------------------");
    }

    // Exits the system
    private void exit() {
        System.out.println("Exiting Warehouse System. Goodbye!");
        scanner.close(); // Close the scanner resource
    }

    // Main method - Entry point and class-wide exception handling
    public static void main(String[] args) {
        // Class-wide exception handling using try-catch
        try {
            WarehouseSystem system = new WarehouseSystem();
            system.run();
        } catch (Exception e) {
            // Catch any unhandled exceptions that escape the run loop
            System.err.println("\n--- SYSTEM CRITICAL ERROR ---");
            System.err.println("An unhandled exception caused the system to terminate:");
            System.err.println("Error Type: " + e.getClass().getName());
            System.err.println("Error Message: " + e.getMessage());
            // e.printStackTrace(); // Optional: print stack trace for detailed debugging
            System.err.println("-----------------------------");
        }
    }
}
