/*
 * Exam Question #822
 * Generated on: 2025-05-12 16:46:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Package Delivery Routing Simulator**
 * 
 * **Scenario:**
 * You are tasked with building a simple command-line application that simulates the initial stages of a package delivery routing system. Packages arrive at a sorting hub and are placed in a queue for processing. A dispatcher interacts with the system to manage the flow: adding new packages, viewing packages waiting in the queue, processing packages from the queue, and viewing packages that have been processed for delivery.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the `Package` class:**
 *     *   A simple class to represent a package.
 *     *   It should have private fields for `packageId` (String), `destinationZone` (String), and `weightKg` (double).
 *     *   Provide a constructor that initializes these fields. Include basic validation (e.g., ID and zone not empty, weight positive).
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the package.
 * 
 * 2.  **Implement the `DeliverySimulator` class:**
 *     *   This class will contain the main logic and the `main` method to run the simulation.
 *     *   It must use a `java.util.Queue<Package>` (specifically, use `LinkedList` as the implementation) to represent the sorting queue for incoming packages.
 *     *   It must use a `java.util.List<Package>` (specifically, use `ArrayList` as the implementation, but declare the variable using the `List` interface type) to store packages that have been processed for delivery.
 *     *   Use a `java.util.Scanner` to get user input from the console.
 *     *   Implement a main simulation loop that presents a menu to the user and processes their choice.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Implement the following menu options:
 *         *   **1. Add New Package:** Prompts the user for package details (ID, zone, weight) and adds a new `Package` object to the sorting queue. Validate user input (e.g., ensure weight is a valid number and positive, ID/Zone are not empty).
 *         *   **2. View Sorting Queue:** Displays the details of all packages currently waiting in the sorting queue without removing them.
 *         *   **3. Process Packages:** Takes packages from the front of the sorting queue one by one, simulates a simple processing step (e.g., print a message, maybe check weight and print a warning to `System.err` if it's above a threshold), and moves the processed package to the list of delivered packages. Continue processing until the queue is empty. Handle the case where the queue is already empty.
 *         *   **4. View Delivered Packages:** Displays the details of all packages currently in the delivered packages list.
 *         *   **5. Exit:** Terminates the simulation.
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, listing packages).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, invalid input when adding a package, warnings during processing).
 *     *   Implement class-wide exception handling using `try-catch` blocks. This should cover potential unexpected errors during the simulation loop. Also include specific exception handling where appropriate (e.g., for `Scanner` input errors or validation errors during package creation).
 *     *   Adhere to Java best practices: proper encapsulation, meaningful variable/method names, appropriate comments/documentation.
 * 
 * **Expected Output:**
 * The program should display a menu, accept user input, perform the requested actions, and display results or error messages accordingly. Example flow:
 * ```
 * --- Package Delivery Routing Simulator ---
 * Select an action:
 * 1. Add New Package to Sorting Queue
 * 2. View Sorting Queue
 * 3. Process Packages from Queue
 * 4. View Delivered Packages
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Package ---
 * Enter Package ID: PKG001
 * Enter Destination Zone: ZoneA
 * Enter Weight (kg): 15.5
 * Package added to sorting queue: PKG001
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter your choice: 1
 * 
 * --- Add New Package ---
 * Enter Package ID: PKG002
 * Enter Destination Zone: ZoneB
 * Enter Weight (kg): 25.0
 * Package added to sorting queue: PKG002
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter your choice: 2
 * 
 * --- Sorting Queue ---
 * Packages waiting (2 total):
 * 1. Package{ID='PKG001', Zone='ZoneA', Weight=15.5kg}
 * 2. Package{ID='PKG002', Zone='ZoneB', Weight=25.0kg}
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter your choice: 3
 * 
 * --- Processing Packages ---
 * Processing package: PKG001...
 *   Package PKG001 processed and moved to delivered list.
 * Processing package: PKG002...
 *   WARNING: Package PKG002 is heavy (25.0kg). Requires special handling.
 *   Package PKG002 processed and moved to delivered list.
 * Finished processing. 2 packages processed.
 * 2 packages were flagged as heavy.
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter your choice: 4
 * 
 * --- Delivered Packages ---
 * Packages delivered (2 total):
 * 1. Package{ID='PKG001', Zone='ZoneA', Weight=15.5kg}
 * 2. Package{ID='PKG002', Zone='ZoneB', Weight=25.0kg}
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting simulation...
 * Simulation ended. Goodbye!
 * ```
 * Error messages should go to `System.err`. For example, entering text for weight should result in an error message on `System.err`.
 * 
 * **Evaluation:**
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct functionality according to the requirements.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 *
 * EXPLANATION:
 * This solution implements the `Package Delivery Routing Simulator` by demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:** This is a simple Plain Old Java Object (POJO) representing the data for a package. It uses private fields (`packageId`, `destinationZone`, `weightKg`) for encapsulation. The constructor includes basic input validation using `IllegalArgumentException`, ensuring that packages are created with valid data. Public getter methods provide controlled access to the package data. The `toString()` method is overridden for easy printing of package details.
 * 
 * 2.  **`DeliverySimulator` Class:** This class orchestrates the simulation.
 *     *   **Data Structures:**
 *         *   `Queue<Package> sortingQueue`: A `LinkedList` is used here because it implements the `Queue` interface and provides efficient methods for adding to the end (`offer`) and removing from the front (`poll`), which are typical queue operations. It simulates packages waiting in line to be processed.
 *         *   `List<Package> deliveredPackages`: An `ArrayList` is used here, declared using the `List` interface. This demonstrates polymorphic usage. An `ArrayList` is suitable for storing processed packages as we might need to iterate through them or access them by index (though simple iteration is used here). It represents the collection of packages that have gone through the sorting/processing step.
 *     *   **User Input:** A `Scanner` (`scanner`) is used to read user commands and package details from `System.in`. The `getUserChoice()` method specifically handles potential `InputMismatchException` if the user enters non-integer input for the menu choice, consuming the invalid input to prevent an infinite loop and printing an error to `System.err`. The `addPackage()` method carefully handles reading different types (`nextLine` for strings, `nextDouble` for double) and consuming the newline characters left by `nextDouble()` to avoid issues with subsequent `nextLine()` calls.
 *     *   **Control Flow:**
 *         *   A `while(running)` loop keeps the simulation active until the user chooses to exit.
 *         *   A `switch` statement inside the loop dispatches the execution based on the user's valid integer input (`choice`). This is a clean way to handle multiple distinct command options.
 *     *   **Core Logic Methods:**
 *         *   `addPackage()`: Prompts for input, handles `Scanner`-related input errors with a specific `try-catch`, and uses another `try-catch` to catch `IllegalArgumentException` thrown by the `Package` constructor if the input data is invalid. Valid packages are added to the `sortingQueue` using `offer()`.
 *         *   `viewSortingQueue()`: Iterates through the `sortingQueue` (using an enhanced for loop, which does not remove elements from the `Queue` during iteration) and prints package details using `System.out`.
 *         *   `processPackages()`: This method simulates the core work. It uses a `while (!sortingQueue.isEmpty())` loop and `sortingQueue.poll()` to retrieve and *remove* packages from the front of the queue one by one. It includes a simple check for heavy packages, printing a warning to `System.err`. Processed packages are added to the `deliveredPackages` `List` using `add()`.
 *         *   `viewDeliveredPackages()`: Iterates through the `deliveredPackages` `List` (using an indexed for loop) and prints package details using `System.out`.
 *         *   `stopSimulation()`: Sets the `running` flag to `false` to exit the main loop.
 *     *   **Output Streams:** `System.out` is used for all standard information displayed to the user (menu, prompts, lists, confirmations). `System.err` is specifically used for error messages (invalid choices, input errors, package creation errors) and processing warnings (heavy packages). This is good practice for separating normal output from error information.
 *     *   **Exception Handling:**
 *         *   Specific `try-catch` blocks are used in `getUserChoice()` for `InputMismatchException` and in `addPackage()` for `InputMismatchException` (for weight) and `IllegalArgumentException` (from `Package` constructor). This handles expected types of errors near their source.
 *         *   A broad `try-catch(Exception e)` is wrapped around the main `while(running)` loop in `runSimulation()`. This serves as a class-wide safety net, catching any unexpected runtime exceptions that might occur within any of the command processing logic and preventing the program from crashing abruptly. It prints the error message and stack trace to `System.err`. The `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the simulation exited normally.
 * 
 * This solution effectively integrates all the required Java components within a practical, albeit simplified, real-world scenario, demonstrating understanding of data structures, control flow, input/output handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package in the delivery simulation.
 */
class Package {
    private String packageId;
    private String destinationZone;
    private double weightKg;

    /**
     * Constructs a new Package object.
     *
     * @param packageId The unique identifier for the package.
     * @param destinationZone The destination zone for the package.
     * @param weightKg The weight of the package in kilograms.
     * @throws IllegalArgumentException if input is invalid (null, empty, non-positive).
     */
    public Package(String packageId, String destinationZone, double weightKg) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destinationZone == null || destinationZone.trim().isEmpty()) {
             throw new IllegalArgumentException("Destination zone cannot be null or empty.");
        }
        if (weightKg <= 0) {
            throw new IllegalArgumentException("Weight must be positive.");
        }
        this.packageId = packageId.trim();
        this.destinationZone = destinationZone.trim();
        this.weightKg = weightKg;
    }

    // Getters
    public String getPackageId() {
        return packageId;
    }

    public String getDestinationZone() {
        return destinationZone;
    }

    public double getWeightKg() {
        return weightKg;
    }

    /**
     * Provides a string representation of the Package object.
     *
     * @return A formatted string describing the package.
     */
    @Override
    public String toString() {
        return "Package{" +
               "ID='" + packageId + '\'' +
               ", Zone='" + destinationZone + '\'' +
               ", Weight=" + weightKg + "kg" +
               '}';
    }
}

/**
 * Simulates a package delivery routing system.
 * Manages incoming packages in a sorting queue and processed packages in a list.
 */
public class DeliverySimulator {

    private Queue<Package> sortingQueue;
    private List<Package> deliveredPackages;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a new DeliverySimulator.
     * Initializes the queue, list, and scanner.
     */
    public DeliverySimulator() {
        // Use LinkedList as a concrete implementation of Queue
        this.sortingQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.deliveredPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts and runs the package delivery simulation loop.
     * Handles user input and dispatches commands using a switch statement.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        System.out.println("--- Package Delivery Routing Simulator ---");

        // Class-wide exception handling for the main simulation loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        viewSortingQueue();
                        break;
                    case 3:
                        processPackages();
                        break;
                    case 4:
                        viewDeliveredPackages();
                        break;
                    case 5:
                        stopSimulation();
                        break;
                    default:
                        // Use System.err for invalid input messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation run
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure scanner is closed when the simulation stops
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Simulation ended. Goodbye!");
        }
    }

    /**
     * Prints the main menu options to the console.
     * Uses System.out for normal output.
     */
    private void printMenu() {
        System.out.println("Select an action:");
        System.out.println("1. Add New Package to Sorting Queue");
        System.out.println("2. View Sorting Queue");
        System.out.println("3. Process Packages from Queue");
        System.out.println("4. View Delivered Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles InputMismatchException using try-catch.
     *
     * @return The validated user choice, or -1 if input was invalid.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            // Read integer input
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Use System.err for input errors
            System.err.println("Invalid input. Please enter a number.");
            // Consume the invalid input to prevent infinite loop
        } finally {
             // Consume the rest of the line after reading the integer choice
             // This prevents issues with subsequent scanner.nextLine() calls
             if (scanner.hasNextLine()) { // Check if there's a line separator left
                 scanner.nextLine();
             }
        }
        return choice;
    }


    /**
     * Prompts the user for package details and adds a new package to the sorting queue.
     * Includes input validation and specific exception handling for package creation and scanner input.
     */
    private void addPackage() {
        System.out.println("\n--- Add New Package ---");
        try {
            System.out.print("Enter Package ID: ");
            String packageId = scanner.nextLine().trim();

            System.out.print("Enter Destination Zone: ");
            String destinationZone = scanner.nextLine().trim();

            double weightKg = -1; // Initialize with an invalid value
            System.out.print("Enter Weight (kg): ");
            try {
                // Attempt to read double input
                weightKg = scanner.nextDouble();
            } catch (InputMismatchException e) {
                 System.err.println("Invalid input format for weight. Please enter a number.");
                 // Consume the invalid input and return, preventing package creation
                 scanner.nextLine();
                 return;
            } finally {
                // Consume the newline character left after nextDouble()
                if (scanner.hasNextLine()) {
                     scanner.nextLine();
                }
            }


            // Package constructor handles validation and throws IllegalArgumentException
            Package newPackage = new Package(packageId, destinationZone, weightKg);

            sortingQueue.offer(newPackage); // Add package to the end of the queue
            System.out.println("Package added to sorting queue: " + newPackage.getPackageId());

        } catch (IllegalArgumentException e) {
            // Catch exceptions thrown by the Package constructor due to invalid data
            System.err.println("Error creating package: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during package addition
            System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        }
    }

    /**
     * Displays the packages currently in the sorting queue.
     * If the queue is empty, prints an appropriate message.
     * Uses System.out for normal output.
     */
    private void viewSortingQueue() {
        System.out.println("\n--- Sorting Queue ---");
        if (sortingQueue.isEmpty()) {
            System.out.println("The sorting queue is empty.");
        } else {
             System.out.println("Packages waiting (" + sortingQueue.size() + " total):");
             int index = 1;
             // Iterate over the Queue elements without removing them
             for (Package pkg : sortingQueue) {
                 System.out.println(index++ + ". " + pkg);
             }
        }
    }

    /**
     * Processes packages from the sorting queue.
     * Dequeues packages and adds them to the delivered packages list.
     * Simulates a simple processing rule (e.g., heavy packages warning).
     * Uses System.out for normal processing messages and System.err for warnings.
     */
    private void processPackages() {
        System.out.println("\n--- Processing Packages ---");
        if (sortingQueue.isEmpty()) {
            System.out.println("Sorting queue is empty. Nothing to process.");
            return;
        }

        int processedCount = 0;
        int heavyCount = 0;
        double heavyWeightThreshold = 20.0; // Example threshold for warning

        // Process all packages currently in the queue
        while (!sortingQueue.isEmpty()) {
            // Get and remove the head of the queue using poll()
            Package packageToProcess = sortingQueue.poll();

            if (packageToProcess != null) {
                // Simulate processing logic
                System.out.println("Processing package: " + packageToProcess.getPackageId() + "...");

                // Example processing rule: check for heavy packages
                if (packageToProcess.getWeightKg() > heavyWeightThreshold) {
                    System.err.println("  WARNING: Package " + packageToProcess.getPackageId() +
                                       " is heavy (" + packageToProcess.getWeightKg() + "kg). Requires special handling.");
                    heavyCount++;
                }

                // Add the processed package to the delivered list
                deliveredPackages.add(packageToProcess);
                processedCount++;
                System.out.println("  Package " + packageToProcess.getPackageId() + " processed and moved to delivered list.");
            }
        }
        System.out.println("Finished processing. " + processedCount + " packages processed.");
        if (heavyCount > 0) {
             System.err.println(heavyCount + " packages were flagged as heavy.");
        }
    }

    /**
     * Displays the packages that have been processed and marked as delivered.
     * If the list is empty, prints an appropriate message.
     * Uses System.out for normal output.
     */
    private void viewDeliveredPackages() {
        System.out.println("\n--- Delivered Packages ---");
        if (deliveredPackages.isEmpty()) {
            System.out.println("No packages have been delivered yet.");
        } else {
            System.out.println("Packages delivered (" + deliveredPackages.size() + " total):");
            // Iterate through the List and print each package with index
            for (int i = 0; i < deliveredPackages.size(); i++) {
                Package pkg = deliveredPackages.get(i);
                System.out.println((i + 1) + ". " + pkg);
            }
        }
    }

    /**
     * Stops the simulation loop by setting the running flag to false.
     * Uses System.out for exit message.
     */
    private void stopSimulation() {
        System.out.println("Exiting simulation...");
        this.running = false;
    }

    /**
     * Main method to start the DeliverySimulator.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliverySimulator simulator = new DeliverySimulator();
        simulator.runSimulation();
    }
}
