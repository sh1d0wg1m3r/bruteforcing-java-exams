/*
 * Exam Question #290
 * Generated on: 2025-05-11 22:50:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Project Task Dispatcher System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for managing project tasks. The system should allow a project manager to add tasks to a queue, dispatch tasks for execution, view the list of pending tasks, and view the history of completed tasks. Urgent tasks must be prioritized and dispatched before regular tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class (can be an inner class) with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `isUrgent` (boolean): Indicates if the task is urgent.
 *     *   Include a constructor, appropriate getters, and an overridden `toString()` method for easy printing.
 * 
 * 2.  **Task Management Logic:** Implement a class (e.g., `ProjectTaskDispatcher`) that manages the tasks. This class should use the following data structures and components:
 *     *   A `Queue<Task>` to hold tasks waiting to be dispatched. Urgent tasks added should be placed at the front of the queue, while non-urgent tasks are added to the back.
 *     *   A `List<Task>` to store tasks that have been dispatched (completed). Use an `ArrayList` as the concrete implementation.
 * 
 * 3.  **Core Functionality (Methods):**
 *     *   `addTask(String description, boolean isUrgent)`: Creates a new `Task` with a unique ID and adds it to the task queue based on its urgency. Assign task IDs sequentially starting from 1.
 *     *   `dispatchTask()`: Removes the next task from the front of the queue, adds it to the completed tasks list, and returns the dispatched task. Handle the case where the queue is empty.
 *     *   `viewTaskQueue()`: Prints the details of all tasks currently in the queue without removing them.
 *     *   `viewCompletedTasks()`: Returns the `List` of completed tasks.
 * 
 * 4.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in a main application loop within the `ProjectTaskDispatcher` class (or a separate `Main` class). The interface should present a menu with options:
 *     *   Add New Task
 *     *   Dispatch Next Task
 *     *   View Task Queue
 *     *   View Completed Tasks
 *     *   Exit
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu selection.
 * 
 * 6.  **Output and Error Handling:**
 *     *   Use `System.out` for normal application output (menu, prompts, success messages, task listings).
 *     *   Use `System.err` for printing error messages (e.g., invalid menu choice, attempting to dispatch from an empty queue, invalid task description).
 *     *   Implement **class-wide exception handling** using a `try-catch` block wrapping the main application loop to catch unexpected runtime exceptions and print an error message using `System.err`. Also, handle potential input errors from the `Scanner` (e.g., non-integer input for menu choice).
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement basic input validation (e.g., check if task description is empty, handle non-numeric input).
 *     *   Ensure resources like the `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * Your program should demonstrate the following interactions (exact formatting may vary slightly but content should be clear):
 * 
 * ```
 * Project Task Dispatcher System
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Dispatch Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Is this task urgent? (yes/no): no
 * Task added to the queue: Task [ID=1, Desc='Design database schema', Urgent=false]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix critical bug
 * Is this task urgent? (yes/no): yes
 * Urgent task added to the front of the queue: Task [ID=2, Desc='Fix critical bug', Urgent=true]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Task Queue ---
 * 1. Task [ID=2, Desc='Fix critical bug', Urgent=true]
 * 2. Task [ID=1, Desc='Design database schema', Urgent=false]
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Task dispatched: Task [ID=2, Desc='Fix critical bug', Urgent=true]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Task dispatched: Task [ID=1, Desc='Design database schema', Urgent=false]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Task Queue ---
 * The task queue is empty.
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Task [ID=2, Desc='Fix critical bug', Urgent=true]
 * 2. Task [ID=1, Desc='Design database schema', Urgent=false]
 * -----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Error: Task queue is empty. No tasks to dispatch.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Project Task Dispatcher. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `ProjectTaskDispatcher` system that manages tasks using a queue and a list, demonstrating several core Java concepts.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`Task` Class:** A private static inner class `Task` is used to encapsulate the data for each task (ID, description, urgency). This promotes encapsulation by making the fields private and providing public getters. The `toString()` method provides a convenient way to represent task objects as strings for printing.
 * 
 * 2.  **`Queue<Task>`:** A `Queue` is used to represent tasks waiting to be processed. Specifically, a `LinkedList` is chosen as the implementation (`taskQueue = new LinkedList<>();`). `LinkedList` implements both `Queue` and `Deque` interfaces. This allows us to use the standard `Queue` methods like `add()` (which adds to the end) and `poll()` (which removes from the front), but crucially, it also provides `addFirst()` from the `Deque` interface. This is used to implement the priority requirement: urgent tasks are added to the front using `((LinkedList<Task>) taskQueue).addFirst(newTask);`, while non-urgent tasks use the standard `taskQueue.add(newTask);` which adds to the end.
 * 
 * 3.  **`List<Task>` and `ArrayList<Task>`:** An `ArrayList` (`completedTasks = new ArrayList<>();`) is used to store the history of tasks once they are dispatched. The `viewCompletedTasks()` method is designed to return the list using the more general `List` interface (`public List<Task> viewCompletedTasks()`), demonstrating the principle of programming to interfaces.
 * 
 * 4.  **`Scanner`:** A `Scanner` object (`scanner = new Scanner(System.in);`) is used throughout the `run()` method to read user input from the console for menu choices and task details.
 * 
 * 5.  **`Switch` Statement:** The `switch` statement in the `run()` method is used to control the application flow based on the user's integer input for the menu selection, directing execution to the appropriate task management method (`addTask`, `dispatchTask`, `viewTaskQueue`, `viewCompletedTasks`, or exit).
 * 
 * 6.  **`System.err`:** `System.err.println()` is used specifically for outputting error messages. This includes messages for invalid menu choices, attempting to dispatch from an empty queue, empty task descriptions, and invalid input types from the scanner. Using `System.err` separates error output from normal application output (`System.out`), which is a standard practice.
 * 
 * 7.  **`System.out`:** `System.out.println()` is used for all normal application output, such as printing the menu, prompts for input, confirmation messages when tasks are added or dispatched, and displaying the contents of the task queue and completed tasks list.
 * 
 * 8.  **Class-Wide Exception Handling (`try-catch`)**: A large `try-catch` block is wrapped around the main `while(true)` loop in the `run()` method. This serves as a class-wide handler for any unexpected `Exception` that might occur during the application's execution. If an unhandled exception propagates up to this block, it will be caught, an error message will be printed to `System.err`, and the stack trace will be printed for debugging. Additionally, a nested `try-catch` is used specifically around the `scanner.nextInt()` call to catch `InputMismatchException`, handling non-integer input gracefully without crashing the program. The `finally` block ensures the `Scanner` resource is closed when the `run` method exits, regardless of whether it exits normally or due to an exception.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in both `ProjectTaskDispatcher` and `Task` classes are `private`, accessed only through public methods.
 * *   **Meaningful Names:** Variable and method names (`taskQueue`, `completedTasks`, `addTask`, `dispatchTask`, `isUrgent`, etc.) are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic, like the use of `addFirst` for urgent tasks.
 * *   **Input Validation:** Basic validation checks if the task description is empty. The nested `try-catch` handles non-integer input for the menu choice.
 * *   **Error Handling:** Specific error conditions (empty queue, invalid input) are checked, and informative messages are printed to `System.err`.
 * *   **Clean Code Structure:** The code is organized into logical methods, each responsible for a specific part of the application's functionality (adding, dispatching, viewing, printing menu, running the loop).
 * 
 * This solution effectively integrates all required components into a cohesive, practical application while adhering to important programming best practices and demonstrating advanced understanding of Java collections, control flow, and error handling.
 */

import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList; // Using LinkedList for Queue implementation to support addFirst/addLast
import java.util.List;
import java.util.ArrayList; // Using ArrayList for List implementation
import java.util.InputMismatchException;

public class ProjectTaskDispatcher {

    // Inner static Task class to encapsulate task data
    private static class Task {
        private int taskId;
        private String description;
        private boolean isUrgent;

        /**
         * Constructs a new Task.
         * @param taskId The unique ID for the task.
         * @param description The description of the task.
         * @param isUrgent True if the task is urgent, false otherwise.
         */
        public Task(int taskId, String description, boolean isUrgent) {
            this.taskId = taskId;
            this.description = description;
            this.isUrgent = isUrgent;
        }

        // Getters for task properties
        public int getTaskId() { return taskId; }
        public String getDescription() { return description; }
        public boolean isUrgent() { return isUrgent; }

        /**
         * Provides a string representation of the Task.
         * @return A formatted string describing the task.
         */
        @Override
        public String toString() {
            return "Task [ID=" + taskId + ", Desc='" + description + "', Urgent=" + isUrgent + "]";
        }
    }

    // Data structures for managing tasks
    private Queue<Task> taskQueue; // Queue of tasks waiting to be dispatched
    private List<Task> completedTasks; // List of tasks that have been completed
    private int nextTaskId; // Counter for assigning unique task IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new ProjectTaskDispatcher.
     * Initializes the task queue, completed tasks list, and task ID counter.
     */
    public ProjectTaskDispatcher() {
        // Initialize collections using concrete implementations
        taskQueue = new LinkedList<>(); // LinkedList implements Queue and Deque
        completedTasks = new ArrayList<>(); // ArrayList implements List
        nextTaskId = 1; // Start task IDs from 1
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the queue. Urgent tasks are added to the front,
     * non-urgent tasks are added to the back.
     * @param description The task description.
     * @param isUrgent True if the task is urgent, false otherwise.
     */
    public void addTask(String description, boolean isUrgent) {
        // Basic input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), isUrgent);

        // Add to the queue based on urgency
        // Using LinkedList's specific methods (addFirst) for priority
        if (isUrgent) {
            // Cast is needed because Queue interface doesn't have addFirst
            ((LinkedList<Task>) taskQueue).addFirst(newTask);
            System.out.println(System.lineSeparator() + "Urgent task added to the front of the queue: " + newTask);
        } else {
            taskQueue.add(newTask); // add() is standard Queue method, adds to the end
            System.out.println(System.lineSeparator() + "Task added to the queue: " + newTask);
        }
    }

    /**
     * Dispatches (removes) the next task from the front of the queue and
     * adds it to the list of completed tasks.
     * @return The dispatched task, or null if the queue was empty.
     */
    public Task dispatchTask() {
        // Check if the queue is empty before attempting to poll
        if (taskQueue.isEmpty()) {
            System.err.println(System.lineSeparator() + "Error: Task queue is empty. No tasks to dispatch.");
            return null;
        }

        // Remove and retrieve the head of the queue
        Task dispatchedTask = taskQueue.poll();
        // Add the dispatched task to the completed list
        completedTasks.add(dispatchedTask);

        System.out.println(System.lineSeparator() + "Task dispatched: " + dispatchedTask);
        return dispatchedTask;
    }

    /**
     * Prints the tasks currently waiting in the queue without removing them.
     */
    public void viewTaskQueue() {
        System.out.println(System.lineSeparator() + "--- Current Task Queue ---");
        // Check if the queue is empty
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            int index = 1;
            // Iterate through the queue elements
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("--------------------------" + System.lineSeparator());
    }

    /**
     * Returns the list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> viewCompletedTasks() {
        // Return the completed tasks list. Returning the List interface type
        // demonstrates programming to the interface.
        return completedTasks;
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Dispatch Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Project Task Dispatcher System");

        // Class-wide try-catch block to handle potential exceptions during execution
        try {
            // Main application loop
            while (true) {
                printMenu();
                int choice = -1;

                // Inner try-catch block specifically for handling Scanner input errors
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println(System.lineSeparator() + "Invalid input. Please enter a number." + System.lineSeparator());
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Switch statement to process user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Is this task urgent? (yes/no): ");
                        String urgentInput = scanner.nextLine().trim().toLowerCase();
                        boolean isUrgent = urgentInput.equals("yes") || urgentInput.equals("y"); // Simple check

                        addTask(description, isUrgent);
                        break;

                    case 2: // Dispatch Task
                        dispatchTask(); // Method handles empty queue error internally
                        break;

                    case 3: // View Task Queue
                        viewTaskQueue();
                        break;

                    case 4: // View Completed Tasks
                        System.out.println(System.lineSeparator() + "--- Completed Tasks ---");
                        // Retrieve completed tasks using the List interface
                        List<Task> completed = viewCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No tasks have been completed yet.");
                        } else {
                            int index = 1;
                            // Iterate through the List to print completed tasks
                            for (Task task : completed) {
                                System.out.println(index++ + ". " + task);
                            }
                        }
                        System.out.println("-----------------------" + System.lineSeparator());
                        break;

                    case 5: // Exit
                        System.out.println(System.lineSeparator() + "Exiting Project Task Dispatcher. Goodbye!");
                        return; // Exit the run method, which will lead to the finally block

                    default: // Handle invalid number choices
                        System.err.println(System.lineSeparator() + "Invalid choice. Please enter a number between 1 and 5." + System.lineSeparator());
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed properly regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner resource closed."); // Optional confirmation
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProjectTaskDispatcher app = new ProjectTaskDispatcher();
        app.run(); // Start the application
    }
}
