/*
 * Exam Question #721
 * Generated on: 2025-05-12 16:31:00
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based Warehouse Management System. This system should allow users to manage inventory and process customer orders placed in a queue.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures and control flow mechanisms, adhering to best programming practices.
 * 
 * **System Functionality:**
 * 
 * 1.  **Add Inventory:** Allow the user to add new items to the warehouse inventory or increase the quantity of existing items.
 * 2.  **Place Order:** Allow the user to place an order for a specific item and quantity. Orders are added to a processing queue in the order they are received (FIFO).
 * 3.  **Process Next Order:** Attempt to fulfill the next order waiting in the queue. Fulfillment requires checking if sufficient inventory exists for the item requested in the order.
 *     *   If inventory is sufficient, decrease the inventory quantity and report successful processing. The order is removed from the queue.
 *     *   If inventory is insufficient, report the failure due to low stock. The order should be removed from the queue in this simplified simulation.
 *     *   If the order queue is empty, report that there are no orders to process.
 * 4.  **View Inventory:** Display the current list of items in the inventory and their available quantities.
 * 5.  **View Pending Orders:** Display the list of orders currently waiting in the processing queue.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must use **ALL** of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the incoming customer orders in a First-In, First-Out manner.
 * *   `java.util.ArrayList`: To store the warehouse inventory items.
 * *   `java.util.List`: Use this interface type for methods or variables that handle collections compatible with `ArrayList`, demonstrating abstraction.
 * *   `java.util.Scanner`: To read user input from the console (menu choices, item names, quantities).
 * *   `switch` statement: To handle the main menu options selected by the user.
 * *   `System.err`: To output error messages (e.g., invalid input, insufficient inventory, queue empty).
 * *   `System.out`: To output normal messages (menu, prompts, success messages, status displays).
 * *   Class-wide exception handling using `try-catch` blocks: Implement robust error handling, particularly around user input processing and potential unexpected issues in the main execution flow.
 * 
 * **Best Practices Requirements:**
 * 
 * *   **Encapsulation:** Use private fields and public methods within your classes.
 * *   **Meaningful Names:** Use descriptive names for classes, variables, and methods.
 * *   **Comments and Documentation:** Include Javadoc comments for classes and methods, and inline comments for complex logic.
 * *   **Input Validation:** Validate user inputs (e.g., quantities must be positive numbers). Report invalid input using `System.err`.
 * *   **Proper Error Handling:** Handle potential exceptions (like `InputMismatchException`) and logical errors (like insufficient inventory) gracefully.
 * *   **Clean Code Structure:** Organize your code into appropriate classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept their choice, and perform the corresponding action, displaying relevant information or error messages. The output should be clear and follow the usage of `System.out` for normal messages and `System.err` for errors.
 * 
 * Example interaction flow (not exhaustive):
 * 
 * ```
 * --- Warehouse Management System ---
 * 1. Add Inventory
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter choice: 1
 * Enter item name: Laptop
 * Enter quantity to add: 10
 * Added 10 of Laptop to inventory.
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 4
 * 
 * --- Current Inventory ---
 * Laptop: 10
 * -------------------------
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 2
 * Enter item name for order: Laptop
 * Enter quantity for order: 3
 * Order for 3 of Laptop placed.
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 5
 * 
 * --- Pending Orders ---
 * 3 of Laptop
 * ----------------------
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 3
 * Successfully processed order for 3 of Laptop.
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 4
 * 
 * --- Current Inventory ---
 * Laptop: 7
 * -------------------------
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 3
 * Successfully processed order for ... (if more orders)
 * Error: No pending orders to process. (if queue empty)
 * 
 * 1. Add Inventory
 * ...
 * Enter choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * **Note:** You should create separate classes as needed (e.g., for InventoryItem, Order) to maintain a clean structure.
 * 
 * **Submission:** Provide the complete, runnable Java code.
 *
 * EXPLANATION:
 * The provided solution implements a simple Warehouse Management System, fulfilling all the requirements of the exam task.
 * 
 * **Code Structure:**
 * 
 * 1.  **`InventoryItem` Class:** A basic class representing an item in the warehouse with `name` and `quantity`. It follows encapsulation principles with private fields and public getter/setter methods.
 * 2.  **`Order` Class:** A basic class representing a customer order with the `itemName` and `quantity` requested. It also uses encapsulation.
 * 3.  **`WarehouseManager` Class:** This is the core class that manages the state of the warehouse.
 *     *   It holds the inventory in a `private List<InventoryItem> inventory`, specifically initialized as an `ArrayList`.
 *     *   It holds pending orders in a `private Queue<Order> orderQueue`, specifically initialized as a `LinkedList` (which is a common implementation of `Queue`).
 *     *   It contains methods for `addItemToInventory`, `placeOrder`, `processNextOrder`, `getInventory`, and `getOrderQueue`.
 *     *   Helper methods like `findInventoryItem` and `decreaseInventory` are private, supporting the public operations.
 *     *   `getInventory()` and `getOrderQueue()` methods are designed to return the collection using the `List` and `Queue` interface types respectively, demonstrating the use of these interfaces.
 * 4.  **`WarehouseSimulation` Class:** This class contains the `main` method and handles the user interaction loop.
 *     *   It creates instances of `WarehouseManager` and `Scanner`.
 *     *   It presents a menu to the user.
 *     *   It reads user input using `Scanner`.
 *     *   It uses a `switch` statement to direct the program flow based on the user's menu choice.
 *     *   It calls the appropriate methods in the `WarehouseManager` based on the choice.
 *     *   It includes input validation checks (e.g., positive quantities) before calling manager methods, reporting errors to `System.err`.
 *     *   It implements a class-wide `try-catch` block around the main loop's core logic to catch potential `InputMismatchException` during scanner operations and any other unexpected `Exception`, printing error messages to `System.err`.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Effective use of `ArrayList` for dynamic inventory storage and `Queue` (implemented by `LinkedList`) for managing orders in a FIFO manner.
 * *   **Interfaces:** Usage of `List` and `Queue` interfaces in method signatures (`getInventory`, `getOrderQueue`) promotes flexibility and programming to interfaces rather than concrete implementations.
 * *   **Object-Oriented Programming:** Proper use of classes (`InventoryItem`, `Order`, `WarehouseManager`) with encapsulation (private fields, public methods) and separation of concerns.
 * *   **User Input:** Reading various data types from the console using `Scanner`, including handling the newline character after reading integers.
 * *   **Control Flow:** Using a `while` loop for the main program loop and a `switch` statement for multi-way branching based on user input.
 * *   **Error Handling:**
 *     *   Input validation checks performed immediately after reading user input.
 *     *   Specific error messages printed to `System.err` for validation failures and business logic errors (e.g., insufficient inventory, empty queue).
 *     *   `try-catch` blocks to handle expected exceptions like `InputMismatchException` from `Scanner`.
 *     *   A general `catch (Exception e)` block as a fallback for unexpected runtime errors, demonstrating class-wide exception handling in the main execution flow.
 * *   **Output:** Using `System.out` for standard program output (menu, prompts, success messages, data display) and `System.err` specifically for error conditions, as required.
 * *   **Code Clarity:** Use of meaningful variable/method names and comments to explain the code's purpose and logic.
 * 
 * This solution provides a solid foundation for the warehouse simulation, demonstrating the required Java components and best practices in a cohesive and practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an item in the warehouse inventory.
 */
class InventoryItem {
    private String name;
    private int quantity;

    /**
     * Constructs an InventoryItem.
     * @param name The name of the item.
     * @param quantity The initial quantity of the item.
     */
    public InventoryItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current quantity of the item.
     * @return The item quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Sets the quantity of the item.
     * @param quantity The new quantity.
     */
    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private String itemName;
    private int quantity;

    /**
     * Constructs an Order.
     * @param itemName The name of the item ordered.
     * @param quantity The quantity ordered.
     */
    public Order(String itemName, int quantity) {
        this.itemName = itemName;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the item ordered.
     * @return The item name.
     */
    public String getItemName() {
        return itemName;
    }

    /**
     * Gets the quantity ordered.
     * @return The quantity ordered.
     */
    public int getQuantity() {
        return quantity;
    }
}

/**
 * Manages the warehouse inventory and order processing queue.
 */
class WarehouseManager {
    // Using ArrayList for inventory storage
    private List<InventoryItem> inventory;
    // Using LinkedList as a Queue implementation for orders
    private Queue<Order> orderQueue;

    /**
     * Constructs a WarehouseManager.
     * Initializes inventory and order queue.
     */
    public WarehouseManager() {
        this.inventory = new ArrayList<>(); // Requirement: Use ArrayList
        this.orderQueue = new LinkedList<>(); // Requirement: Use Queue (LinkedList implements Queue)
    }

    /**
     * Adds quantity to an existing item or adds a new item to the inventory.
     * @param itemName The name of the item.
     * @param quantity The quantity to add. Must be positive.
     */
    public void addItemToInventory(String itemName, int quantity) {
        // Basic validation (more done in main)
        if (quantity <= 0) {
            System.err.println("Error: Quantity to add must be positive.");
            return;
        }

        InventoryItem existingItem = findInventoryItem(itemName);
        if (existingItem != null) {
            existingItem.setQuantity(existingItem.getQuantity() + quantity);
        } else {
            inventory.add(new InventoryItem(itemName, quantity));
        }
    }

    /**
     * Places a new order into the processing queue.
     * @param itemName The name of the item ordered.
     * @param quantity The quantity ordered. Must be positive.
     */
    public void placeOrder(String itemName, int quantity) {
         // Basic validation (more done in main)
        if (quantity <= 0) {
            System.err.println("Error: Order quantity must be positive.");
            return;
        }
        orderQueue.offer(new Order(itemName, quantity)); // offer is safer than add for queues
    }

    /**
     * Attempts to process the next order in the queue.
     * Checks inventory and updates if sufficient stock is available.
     * Reports success or failure using System.out or System.err.
     */
    public void processNextOrder() {
        if (orderQueue.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
            return;
        }

        // Peek at the next order without removing it yet
        Order order = orderQueue.peek();
        String orderedItemName = order.getItemName();
        int orderedQuantity = order.getQuantity();

        InventoryItem inventoryItem = findInventoryItem(orderedItemName);

        if (inventoryItem == null) {
            System.err.println("Error processing order for " + orderedQuantity + " of " + orderedItemName + ": Item not found in inventory.");
            orderQueue.poll(); // Remove the order as it cannot be fulfilled
        } else if (inventoryItem.getQuantity() < orderedQuantity) {
            System.err.println("Error processing order for " + orderedQuantity + " of " + orderedItemName + ": Insufficient inventory. Only " + inventoryItem.getQuantity() + " available.");
            orderQueue.poll(); // Remove the order as it cannot be fulfilled
        } else {
            // Sufficient inventory exists
            decreaseInventory(orderedItemName, orderedQuantity);
            orderQueue.poll(); // Remove the order ONLY after successful processing
            System.out.println("Successfully processed order for " + orderedQuantity + " of " + orderedItemName + ".");
        }
    }

    /**
     * Gets the current inventory list.
     * Demonstrates using the List interface type.
     * @return A List of InventoryItem objects.
     */
    public List<InventoryItem> getInventory() {
        return inventory; // Returning the internal list for simplicity in exam context
    }

    /**
     * Gets the current order queue.
     * Demonstrates using the Queue interface type.
     * @return The Queue of Order objects.
     */
    public Queue<Order> getOrderQueue() {
        return orderQueue; // Returning the internal queue for simplicity in exam context
    }

    /**
     * Finds an inventory item by name (case-insensitive).
     * @param itemName The name of the item to find.
     * @return The InventoryItem object if found, otherwise null.
     */
    private InventoryItem findInventoryItem(String itemName) {
        for (InventoryItem item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                return item;
            }
        }
        return null; // Item not found
    }

    /**
     * Decreases the quantity of an inventory item.
     * Assumes the item exists and sufficient quantity has been checked.
     * @param itemName The name of the item.
     * @param quantity The quantity to decrease.
     */
    private void decreaseInventory(String itemName, int quantity) {
        InventoryItem item = findInventoryItem(itemName);
        if (item != null) {
            item.setQuantity(item.getQuantity() - quantity);
            // In a real system, you might remove the item if quantity <= 0,
            // but for this exam, we keep it with non-positive quantity.
        }
        // Note: Error handling for item not found or insufficient quantity
        // is primarily done in processNextOrder before calling this.
    }
}

/**
 * Main class to run the Warehouse Management System simulation.
 */
public class WarehouseSimulation {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Warehouse Management System ---");
        System.out.println("1. Add Inventory");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Main method to run the simulation loop.
     * Handles user interaction, input validation, and calls WarehouseManager methods.
     * Includes class-wide exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Warehouse Management System ---");

        // Class-wide exception handling loop
        while (true) {
            printMenu();
            System.out.print("Enter choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character after reading int

                // Use switch statement for menu control
                switch (choice) {
                    case 1: // Add Inventory
                        System.out.print("Enter item name: ");
                        String addItemName = scanner.nextLine();
                        System.out.print("Enter quantity to add: ");
                        int addQuantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        // Input validation
                        if (addQuantity <= 0) {
                            System.err.println("Error: Quantity must be positive.");
                        } else {
                            manager.addItemToInventory(addItemName, addQuantity);
                            System.out.println("Added " + addQuantity + " of " + addItemName + " to inventory.");
                        }
                        break;

                    case 2: // Place Order
                        System.out.print("Enter item name for order: ");
                        String orderItemName = scanner.nextLine();
                        System.out.print("Enter quantity for order: ");
                        int orderQuantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        // Input validation
                         if (orderQuantity <= 0) {
                            System.err.println("Error: Order quantity must be positive.");
                        } else {
                            manager.placeOrder(orderItemName, orderQuantity);
                            System.out.println("Order for " + orderQuantity + " of " + orderItemName + " placed.");
                        }
                        break;

                    case 3: // Process Next Order
                        manager.processNextOrder(); // Logic handled within manager method
                        break;

                    case 4: // View Inventory
                        System.out.println("\n--- Current Inventory ---");
                        List<InventoryItem> inventory = manager.getInventory(); // Requirement: Use List interface
                        if (inventory.isEmpty()) {
                            System.out.println("Inventory is empty.");
                        } else {
                             for (InventoryItem item : inventory) {
                                System.out.println(item.getName() + ": " + item.getQuantity());
                            }
                        }
                        System.out.println("-------------------------");
                        break;

                    case 5: // View Pending Orders
                        System.out.println("\n--- Pending Orders ---");
                        Queue<Order> orderQueue = manager.getOrderQueue(); // Requirement: Use Queue interface
                        if (orderQueue.isEmpty()) {
                            System.out.println("No pending orders.");
                        } else {
                            // Iterate through the queue without removing elements (using enhanced for loop or iterator)
                            for (Order order : orderQueue) {
                                System.out.println(order.getQuantity() + " of " + order.getItemName());
                            }
                        }
                         System.out.println("----------------------");
                        break;

                    case 6: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method, ending the program

                    default:
                        // Handle invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number for the choice or quantity.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(); // Uncomment for detailed debugging info
            }
            // Add a newline for better separation between command outputs
            System.out.println();
        }
    }
}
