/*
 * Exam Question #962
 * Generated on: 2025-05-12 17:05:49
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Attendee Check-in and Service Queue Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for managing attendees at a large event. Attendees are pre-registered. Upon arrival, they need to check in. After checking in, they must proceed to a specific service station (e.g., for badge collection or entry to a restricted area), where they are processed in the order they checked in.
 * 
 * **Task:**
 * Implement a console-based Java application that simulates this event management process.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Representation:** Create a class named `Attendee` with the following characteristics:
 *     *   `private int id;`
 *     *   `private String name;`
 *     *   `private boolean checkedIn;`
 *     *   A constructor `Attendee(int id, String name)`.
 *     *   Public getter methods for `id`, `name`, and `checkedIn`.
 *     *   A public setter method `setCheckedIn(boolean checkedIn)`.
 *     *   Override the `toString()` method to provide a user-friendly representation of the attendee (e.g., "ID: [id], Name: [name], Checked In: [status]").
 * 
 * 2.  **Data Storage:**
 *     *   Use a `java.util.List<Attendee>` (specifically, a `java.util.ArrayList`) to store the list of all pre-registered attendees. Initialize this list with at least 5 sample attendees (hardcoded).
 *     *   Use a `java.util.Queue<Attendee>` to manage attendees waiting for service after check-in.
 * 
 * 3.  **User Interface:**
 *     *   Implement a menu-driven interface using `java.util.Scanner` for user input.
 *     *   The menu should present the following options:
 *         1.  Check In Attendee
 *         2.  Process Next Attendee from Service Queue
 *         3.  List All Registered Attendees
 *         4.  List Attendees Currently in Service Queue
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Functionality:**
 *     *   **Check In Attendee:**
 *         *   Prompt the user for the Attendee ID.
 *         *   Read the input using `Scanner`.
 *         *   Validate that the input is a valid integer.
 *         *   Search the registered attendee list for an attendee with the given ID.
 *         *   If found:
 *             *   Check if the attendee is already checked in. If so, display an error message using `System.err`.
 *             *   If not already checked in: Mark the attendee as checked in (`setCheckedIn(true)`), add them to the service queue (`queue.offer()`), and display a success message using `System.out`.
 *         *   If not found: Display an error message using `System.err`.
 *     *   **Process Next Attendee from Service Queue:**
 *         *   Check if the service queue is empty. If so, display a message using `System.out` indicating the queue is empty.
 *         *   If not empty: Remove the next attendee from the queue (`queue.poll()`) and display a message using `System.out` indicating which attendee is being processed.
 *     *   **List All Registered Attendees:** Iterate through the `List` of registered attendees and print their details using `System.out`.
 *     *   **List Attendees Currently in Service Queue:** Iterate through the `Queue` (you can print the queue directly as `Queue` implementations usually have a useful `toString()`) and print the details of attendees currently waiting using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 5.  **Error Handling and Input Validation:**
 *     *   Implement robust input validation for menu choices and attendee IDs. Handle non-integer input gracefully.
 *     *   Use `System.err` for all error messages (e.g., invalid input, attendee not found, already checked in, etc.).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, list displays).
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main application loop to catch any unexpected runtime exceptions.
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation principles for the `Attendee` class.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Ensure clean code structure and formatting.
 *     *   Close the `Scanner` resource when the program exits.
 * 
 * **Sample Pre-registered Attendees:**
 * *   ID: 101, Name: Alice Smith
 * *   ID: 102, Name: Bob Johnson
 * *   ID: 103, Name: Charlie Brown
 * *   ID: 104, Name: Diana Prince
 * *   ID: 105, Name: Ethan Hunt
 * 
 * **Expected Output Examples:**
 * 
 * *   Upon starting: Menu displayed.
 * *   Entering invalid menu choice (e.g., "abc"): Error message on `System.err`.
 * *   Choosing 1, entering valid ID (e.g., 101) for first time: Success message on `System.out`, attendee added to queue.
 * *   Choosing 1, entering same ID (101) again: "Attendee already checked in." message on `System.err`.
 * *   Choosing 1, entering non-existent ID (e.g., 999): "Attendee with ID 999 not found." message on `System.err`.
 * *   Choosing 1, entering non-integer ID (e.g., "xyz"): "Invalid input. Please enter a valid integer ID." message on `System.err`.
 * *   Choosing 2 when queue is not empty: "Processing next attendee..." message on `System.out` with attendee details.
 * *   Choosing 2 when queue is empty: "Service queue is currently empty." message on `System.out`.
 * *   Choosing 3: List of all attendees printed on `System.out`.
 * *   Choosing 4: List of attendees in queue printed on `System.out`.
 * *   Choosing 5: Program exits.
 *
 * EXPLANATION:
 * This solution implements the Event Attendee Check-in and Service Queue Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Attendee` Class:**
 *     *   Models an attendee with private fields (`id`, `name`, `checkedIn`).
 *     *   Provides public getters (`getId`, `getName`, `isCheckedIn`) and a setter (`setCheckedIn`), adhering to encapsulation principles.
 *     *   The `toString()` method is overridden for convenient printing of attendee details.
 * 
 * 2.  **Data Structures (`List` and `Queue`):**
 *     *   `List<Attendee> registeredAttendees`: An `ArrayList` is used to store the fixed set of pre-registered attendees. `ArrayList` is suitable here because we primarily iterate through it to find attendees by ID.
 *     *   `Queue<Attendee> serviceQueue`: A `LinkedList` is used as it implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior required for a waiting queue. `offer()` is used to add attendees to the end, and `poll()` is used to remove attendees from the front.
 * 
 * 3.  **User Interface and Control Flow (`Scanner`, `switch`):**
 *     *   A `Scanner` reads user input from the console.
 *     *   The `displayMenu()` method presents the options.
 *     *   The `run()` method contains the main application loop.
 *     *   A `switch` statement within the loop processes the user's integer choice, directing execution to the appropriate method (`checkInAttendee`, `processNextInQueue`, etc.).
 *     *   Input validation for the menu choice ensures only integers are processed, and a `default` case handles invalid numbers.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `initializeAttendees()`: Populates the `registeredAttendees` list with sample data.
 *     *   `findAttendeeById()`: A helper method to search the `registeredAttendees` list.
 *     *   `checkInAttendee()`: Prompts for an ID, finds the attendee, checks if they exist and are not already checked in, updates their status, and adds them to the `serviceQueue` using `offer()`.
 *     *   `processNextInQueue()`: Uses `poll()` to remove and retrieve the next attendee from the `serviceQueue`, simulating processing. It handles the case where the queue is empty.
 *     *   `listAllAttendees()`: Iterates through the `registeredAttendees` list and prints each attendee's details.
 *     *   `listQueue()`: Prints the `serviceQueue`. `LinkedList`'s `toString()` method provides a useful representation of the queue's contents.
 * 
 * 5.  **Error Handling (`System.err`, `try-catch`):**
 *     *   `System.err.println()` is used exclusively for displaying error messages (e.g., attendee not found, already checked in, invalid input).
 *     *   `System.out.println()` is used for all normal output (menu, prompts, success messages, list contents).
 *     *   Specific `try-catch` blocks are used within `checkInAttendee()` and the main loop's input reading to handle `InputMismatchException` when the user enters non-integer input. This prevents the program from crashing and allows the user to try again.
 *     *   A broad `try-catch` block wraps the entire `while (running)` loop in the `run()` method. This serves as class-wide exception handling, catching any unexpected `RuntimeException` or `Exception` that might occur elsewhere in the application logic and preventing the program from terminating abruptly without providing information. The `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop exited normally.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in the `Attendee` class.
 *     *   Method and variable names are descriptive (`checkInAttendee`, `serviceQueue`, `registeredAttendees`, `attendeeId`).
 *     *   Comments are included to explain the purpose of classes, methods, and key logic sections.
 *     *   The code is structured into logical methods, improving readability and maintainability.
 *     *   The `Scanner` resource is properly closed in the `finally` block.
 * 
 * This solution effectively integrates all the required Java components to solve a practical problem, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an attendee for the event
class Attendee {
    private int id;
    private String name;
    private boolean checkedIn;

    // Constructor
    public Attendee(int id, String name) {
        this.id = id;
        this.name = name;
        this.checkedIn = false; // Attendees are not checked in by default
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isCheckedIn() {
        return checkedIn;
    }

    // Setter for checkedIn status
    public void setCheckedIn(boolean checkedIn) {
        this.checkedIn = checkedIn;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Checked In: " + (checkedIn ? "Yes" : "No");
    }
}

// Main class for the Event Management System
public class EventSystem {

    private List<Attendee> registeredAttendees;
    private Queue<Attendee> serviceQueue;
    private Scanner scanner;

    // Constructor to initialize data structures and scanner
    public EventSystem() {
        registeredAttendees = new ArrayList<>();
        serviceQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        scanner = new Scanner(System.in);
        initializeAttendees(); // Add sample attendees
    }

    // Initialize with sample pre-registered attendees
    private void initializeAttendees() {
        registeredAttendees.add(new Attendee(101, "Alice Smith"));
        registeredAttendees.add(new Attendee(102, "Bob Johnson"));
        registeredAttendees.add(new Attendee(103, "Charlie Brown"));
        registeredAttendees.add(new Attendee(104, "Diana Prince"));
        registeredAttendees.add(new Attendee(105, "Ethan Hunt"));
        System.out.println("Event system initialized with " + registeredAttendees.size() + " registered attendees.");
    }

    // Display the main menu
    private void displayMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Check In Attendee");
        System.out.println("2. Process Next Attendee from Service Queue");
        System.out.println("3. List All Registered Attendees");
        System.out.println("4. List Attendees Currently in Service Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Find an attendee by ID in the registered list
    private Attendee findAttendeeById(int id) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId() == id) {
                return attendee;
            }
        }
        return null; // Return null if not found
    }

    // Handle attendee check-in process
    private void checkInAttendee() {
        System.out.print("Enter Attendee ID to check in: ");
        try {
            int attendeeId = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();

            Attendee attendee = findAttendeeById(attendeeId);

            if (attendee == null) {
                System.err.println("Error: Attendee with ID " + attendeeId + " not found.");
            } else {
                if (attendee.isCheckedIn()) {
                    System.err.println("Error: Attendee ID " + attendeeId + " (" + attendee.getName() + ") is already checked in.");
                } else {
                    attendee.setCheckedIn(true);
                    serviceQueue.offer(attendee); // Add to the service queue
                    System.out.println("Success: Attendee ID " + attendeeId + " (" + attendee.getName() + ") checked in and added to service queue.");
                }
            }
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid integer ID.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
        } catch (Exception e) {
             // Catch any other unexpected exceptions during check-in
            System.err.println("An unexpected error occurred during check-in: " + e.getMessage());
        }
    }

    // Handle processing the next attendee from the service queue
    private void processNextInQueue() {
        if (serviceQueue.isEmpty()) {
            System.out.println("Service queue is currently empty. No attendees to process.");
        } else {
            Attendee nextAttendee = serviceQueue.poll(); // Remove and get the head of the queue
            System.out.println("Processing next attendee from queue: " + nextAttendee.getName() + " (ID: " + nextAttendee.getId() + ")");
            // In a real system, more processing logic would go here
        }
    }

    // List all registered attendees
    private void listAllAttendees() {
        System.out.println("\n--- All Registered Attendees ---");
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered.");
        } else {
            for (Attendee attendee : registeredAttendees) {
                System.out.println(attendee);
            }
        }
    }

    // List attendees currently in the service queue
    private void listQueue() {
        System.out.println("\n--- Attendees in Service Queue ---");
        if (serviceQueue.isEmpty()) {
            System.out.println("Service queue is empty.");
        } else {
            // Printing the queue directly leverages its toString() method
            System.out.println(serviceQueue);
            // Alternatively, iterate:
            /*
            int position = 1;
            for (Attendee attendee : serviceQueue) {
                System.out.println(position++ + ". " + attendee.getName() + " (ID: " + attendee.getId() + ")");
            }
            */
        }
    }

    // Run the main application loop
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1:
                        checkInAttendee();
                        break;
                    case 2:
                        processNextInQueue();
                        break;
                    case 3:
                        listAllAttendees();
                        break;
                    case 4:
                        listQueue();
                        break;
                    case 5:
                        System.out.println("Exiting Event Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur outside specific method handling
            System.err.println("\nAn unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        EventSystem system = new EventSystem();
        system.run();
    }
}
