/*
 * Exam Question #722
 * Generated on: 2025-05-12 16:31:15
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processor Simulation
 * 
 * **Objective:** Design and implement a console-based application that simulates a basic task management system. The system should handle tasks added to a pending queue and move them to a history list after processing. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are building a simplified backend system for managing tasks within a small team. New tasks are submitted and wait in a queue. A processor picks up the next task from the queue, simulates its execution (based on user input), updates its status, and moves it to a historical record.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a class named `Task` with the following private fields:
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (enum `TaskStatus`): The current status of the task (e.g., `PENDING`, `COMPLETED`, `FAILED`).
 *     *   Include a constructor that takes the description and initializes the status to `PENDING`. Implement input validation in the constructor to ensure the description is not null or empty.
 *     *   Provide public getter methods for `description` and `status`.
 *     *   Provide a public setter method for `status`.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task.
 * 
 * 2.  **TaskProcessor Class:** Create a class named `TaskProcessor` to manage the task workflow.
 *     *   Include private fields:
 *         *   A `Queue<Task>` to hold tasks that are waiting to be processed. Use an appropriate implementation from the Java Collections Framework.
 *         *   A `List<Task>` to hold tasks after they have been processed (completed or failed). Use an `ArrayList` and declare the field using the `List` interface type.
 *         *   A `Scanner` object to read user input from the console.
 *     *   Implement a constructor to initialize the collection fields and the `Scanner`.
 *     *   Implement a `public void run()` method that contains the main application loop. This loop should:
 *         *   Display a menu of options to the user.
 *         *   Read the user's choice using the `Scanner`.
 *         *   Use a `switch` statement to execute the action corresponding to the user's choice.
 *         *   Handle invalid menu input (non-integer or out of range) using `System.err`.
 *         *   Include a `try-catch` block within or around the main loop to handle potential exceptions during execution, printing error messages to `System.err`.
 *         *   Continue looping until the user chooses to exit.
 *     *   Implement private methods for each menu option:
 *         *   `private void addTask()`: Prompts the user for a task description, creates a new `Task` object, and adds it to the pending queue. Handle potential `IllegalArgumentException` from the `Task` constructor using `System.err`.
 *         *   `private void processNextTask()`: Retrieves the next task from the pending queue. If the queue is empty, print an error message to `System.err`. If a task is retrieved, simulate processing by asking the user if the task succeeded (e.g., enter 1 for Success, 0 for Failure). Based on valid user input, update the task's status (`COMPLETED` or `FAILED`). Handle invalid input for the outcome using `System.err` and mark the task as `FAILED`. After processing (or handling input error), add the task to the processed history list. Ensure this method uses `try-catch` to handle potential input issues during the outcome prompt.
 *         *   `private void viewPendingTasks()`: Iterates through and prints all tasks currently in the pending queue. Print a message if the queue is empty.
 *         *   `private void viewProcessedTasks()`: Iterates through and prints all tasks in the processed history list. Print a message if the list is empty.
 *         *   `private void displayMenu()`: Prints the menu options to `System.out`.
 *     *   Include a `public static void main(String[] args)` method to create an instance of `TaskProcessor` and call its `run()` method.
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 3.  **General Requirements & Best Practices:**
 *     *   Use `java.util.Queue`, `java.util.ArrayList`, and `java.util.List` interface as specified.
 *     *   Use `java.util.Scanner` for all user input.
 *     *   Use `switch` for the main menu control flow.
 *     *   Use `System.out` for normal program output (menu, prompts, task lists, success messages).
 *     *   Use `System.err` for all error messages (input validation failures, empty queue/list errors, exception details).
 *     *   Implement comprehensive exception handling using `try-catch` blocks, covering input errors and other potential issues. A broad `catch(Exception e)` in the main loop is acceptable for general unexpected errors, but specific handling for known issues (like invalid task description or outcome input) is preferred where applicable.
 *     *   Adhere to best practices: proper encapsulation (private fields, public methods), meaningful variable and method names, basic code comments, input validation, and clean code structure.
 * 
 * **Expected Output:** The program should present a clear menu, accept user input for various operations, print task details and status, and report errors clearly using `System.err` without crashing due to invalid input or empty collections.
 * 
 * **Time Allotment:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements the `Simple Task Processor Simulation` according to the requirements, demonstrating the use of various Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   The `Task` class encapsulates the data for a single task: `description` and `status`.
 *     *   An `enum` `TaskStatus` is used for clear and type-safe representation of task states (`PENDING`, `COMPLETED`, `FAILED`).
 *     *   The constructor includes input validation, throwing an `IllegalArgumentException` if the description is invalid. This promotes data integrity.
 *     *   Getter and setter methods provide controlled access to the private fields, adhering to encapsulation principles.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   This class orchestrates the application logic.
 *     *   It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to manage tasks in a First-In, First-Out (FIFO) order, suitable for a processing queue.
 *     *   It uses a `List<Task>` (`processedTasks`) declared using the `List` interface type but instantiated as an `ArrayList`. This stores completed and failed tasks as a history, allowing easy iteration and access.
 *     *   A `Scanner` is used to read console input for menu choices and task details.
 *     *   **`run()` Method:** This is the main entry point for the application logic loop.
 *         *   It repeatedly displays the menu and reads user input.
 *         *   It uses `scanner.hasNextInt()` and `scanner.nextInt()` to read the integer choice, followed by `scanner.nextLine()` to consume the leftover newline character, which is a common requirement when mixing `nextInt()` and `nextLine()`.
 *         *   A `switch` statement handles the different menu options, calling the appropriate private methods.
 *         *   Invalid integer choices or non-integer input are detected and reported to `System.err`.
 *         *   A `try-catch(Exception e)` block wraps the core logic within the loop to catch any unhandled exceptions that might occur during an operation, preventing the program from crashing and printing an error message to `System.err`.
 *     *   **`displayMenu()`:** A simple helper method to print the menu options to `System.out`.
 *     *   **`addTask()`:** Prompts for input, creates a `Task` object, and adds it to the `pendingTasks` queue using `offer()`. It includes a `try-catch` block to specifically handle the `IllegalArgumentException` that might be thrown by the `Task` constructor if the description is invalid, reporting the error via `System.err`.
 *     *   **`processNextTask()`:**
 *         *   Checks if `pendingTasks` is empty and prints an error to `System.err` if it is.
 *         *   Uses `pendingTasks.poll()` to retrieve and remove the next task from the queue.
 *         *   Simulates processing by asking for user input (0 or 1).
 *         *   Uses `scanner.hasNextInt()` and reads the input, handling potential `InputMismatchException` or other errors within a `try-catch` block.
 *         *   Validates the integer input (0 or 1) and sets the task status accordingly. Invalid input (non-integer or integer other than 0/1) results in the task being marked as `FAILED`, and an error is printed to `System.err`.
 *         *   A `finally` block is used to ensure that, regardless of whether the outcome input was successful or caused an error, the `taskToProcess` is added to the `processedTasks` list.
 *     *   **`viewPendingTasks()` and `viewProcessedTasks()`:** These methods iterate through the respective collections (`pendingTasks` and `processedTasks`) and print the tasks using the `Task` class's `toString()` method. They check if the collections are empty and print a message to `System.out` if they are. Iteration over the `Queue` uses a for-each loop, which iterates without removing elements.
 *     *   **`main()` Method:** The standard entry point that creates a `TaskProcessor` instance and starts the application by calling `run()`.
 *     *   **Resource Management:** The `Scanner` is closed using `scanner.close()` when the main loop finishes, releasing the underlying system resource.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated structure, demonstrating input validation and error handling best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING, COMPLETED, FAILED
}

// Represents a single task
class Task {
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with PENDING status.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.status = TaskStatus.PENDING;
    }

    // Getters
    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status
    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     * @throws IllegalArgumentException if the status is null.
     */
    public void setStatus(TaskStatus status) {
        if (status == null) {
            throw new IllegalArgumentException("Task status cannot be null.");
        }
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task [Description: '" + description + "', Status: " + status + "]";
    }
}

// Manages the task processing workflow
public class TaskProcessor {

    private Queue<Task> pendingTasks; // Queue for tasks waiting processing
    private List<Task> processedTasks; // List for processed task history
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TaskProcessor, initializing collections and scanner.
     */
    public TaskProcessor() {
        // LinkedList is a common implementation for Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.processedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        System.out.println("--- Simple Task Processor Simulation ---");
        boolean running = true;

        // Main application loop
        while (running) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Process user choice using switch statement
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewProcessedTasks();
                            break;
                        case 5:
                            running = false; // Set running to false to exit loop
                            System.out.println("Exiting Task Processor. Goodbye!");
                            break;
                        default:
                            // Handle choices outside the valid range (1-5)
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } else {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input token to prevent infinite loop
                    scanner.nextLine(); // Consume the rest of the line
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally, print stack trace for debugging: e.printStackTrace();
            }
            System.out.println(); // Add a blank line for readability between operations
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks History");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Prompts user for task description and adds a new task to the pending queue.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        try {
            Task newTask = new Task(description);
            // offer() is generally preferred over add() for queues as it handles capacity constraints (though LinkedList doesn't have capacity limits)
            pendingTasks.offer(newTask);
            System.out.println("Task successfully added: '" + description + "'");
        } catch (IllegalArgumentException e) {
            // Handle validation error from Task constructor
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Retrieves the next task from the queue, simulates processing, and moves it to history.
     */
    private void processNextTask() {
        // Check if the pending queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to process.");
            return;
        }

        // Retrieve the next task from the head of the queue
        // poll() retrieves and removes the head, returning null if empty (handled above)
        Task taskToProcess = pendingTasks.poll();

        System.out.println("Processing task: '" + taskToProcess.getDescription() + "'");
        System.out.print("Did the task succeed? (Enter 1 for Yes, 0 for No): ");

        try {
            // Check if the next input for outcome is an integer
            if (scanner.hasNextInt()) {
                int outcome = scanner.nextInt();
                scanner.nextLine(); // Consume the newline

                // Update task status based on valid outcome input
                if (outcome == 1) {
                    taskToProcess.setStatus(TaskStatus.COMPLETED);
                    System.out.println("Task marked as COMPLETED.");
                } else if (outcome == 0) {
                    taskToProcess.setStatus(TaskStatus.FAILED);
                    System.out.println("Task marked as FAILED.");
                } else {
                    // Handle integer input that is not 0 or 1
                    System.err.println("Invalid outcome input (" + outcome + "). Expected 0 or 1. Task marked as FAILED.");
                    taskToProcess.setStatus(TaskStatus.FAILED); // Mark as failed due to invalid input
                }
            } else {
                // Handle non-integer input for outcome
                System.err.println("Invalid outcome input. Expected a number (0 or 1). Task marked as FAILED.");
                scanner.next(); // Consume the invalid input token
                scanner.nextLine(); // Consume the rest of the line
                taskToProcess.setStatus(TaskStatus.FAILED); // Mark as failed due to invalid input
            }
        } catch (Exception e) {
            // Catch any other unexpected error during outcome input
            System.err.println("An error occurred while reading task outcome: " + e.getMessage());
            taskToProcess.setStatus(TaskStatus.FAILED); // Mark as failed on unexpected error
            System.out.println("Task marked as FAILED due to an error during outcome input.");
        } finally {
            // Ensure the task is always added to the processed history list
            processedTasks.add(taskToProcess);
            System.out.println("Task moved to processed history.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }
        System.out.println("--- Pending Tasks ---");
        int index = 1;
        // Iterate through the queue without removing elements
        for (Task task : pendingTasks) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the processed history list.
     */
    private void viewProcessedTasks() {
        if (processedTasks.isEmpty()) {
            System.out.println("No processed tasks history.");
            return;
        }
        System.out.println("--- Processed Tasks History ---");
        int index = 1;
        // Iterate through the list
        for (Task task : processedTasks) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("-----------------------------");
    }

    /**
     * Main method to start the Task Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor app = new TaskProcessor();
        app.run();
    }
}
