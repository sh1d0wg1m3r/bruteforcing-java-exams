/*
 * Exam Question #744
 * Generated on: 2025-05-12 16:34:31
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Request Processor
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple Customer Service Request Processor system. This system should manage incoming service requests, allow agents to process them in the order they were received, and maintain a record of completed requests.
 * 
 * The system will operate via a command-line interface, accepting user commands to perform different actions.
 * 
 * **Requirements:**
 * 
 * 1.  **Request Representation:** Create a class named `Request` to represent a service request. It should have the following private fields:
 *     *   `id`: An integer representing a unique request ID. IDs should be generated sequentially starting from 1.
 *     *   `description`: A String describing the request.
 *     *   `status`: An enum type `RequestStatus` (Pending, Processing, Completed) indicating the current state of the request.
 *     *   Include appropriate public getter methods for these fields and a method to update the status.
 * 
 * 2.  **Request Status:** Create an enum `RequestStatus` with the values `Pending`, `Processing`, `Completed`.
 * 
 * 3.  **Request Management:** Create a class named `RequestProcessor` that manages the requests. It should have:
 *     *   A private `Queue<Request>` to store pending requests.
 *     *   A private `List<Request>` (using `ArrayList`) to store completed requests.
 *     *   A private integer to keep track of the next available request ID.
 *     *   Public methods for the following operations:
 *         *   `addRequest(String description)`: Creates a new `Request` with status `Pending`, assigns a unique ID, and adds it to the pending queue.
 *         *   `viewNextPendingRequest()`: Returns the next `Request` in the pending queue without removing it. Returns `null` if the queue is empty.
 *         *   `processNextPendingRequest()`: Removes the next `Request` from the pending queue, updates its status to `Completed`, and adds it to the completed requests list. Returns the processed `Request` or `null` if the queue was empty.
 *         *   `getAllPendingRequests()`: Returns a `List` of all pending requests (do not modify the original queue).
 *         *   `getAllCompletedRequests()`: Returns the `List` of all completed requests.
 * 
 * 4.  **User Interface:** Implement a command-line interface in the `main` method of a separate class (e.g., `ExamQuestion`). The interface should present a menu with the following options:
 *     *   1. Add New Request
 *     *   2. View Next Pending Request
 *     *   3. Process Next Pending Request
 *     *   4. View All Pending Requests
 *     *   5. View All Completed Requests
 *     *   6. Exit
 * 
 * 5.  **Implementation Details & Constraints:**
 *     *   Use `java.util.Queue` for the pending requests queue. A `java.util.LinkedList` is a common implementation that also implements `Queue`.
 *     *   Use `java.util.ArrayList` for the completed requests list, declared using the `java.util.List` interface (`List<Request> completedRequests = new ArrayList<>();`).
 *     *   Use `java.util.Scanner` to read user input from `System.in`.
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Use `System.out.println` for displaying the menu, prompts, request details, and success messages.
 *     *   Use `System.err.println` to display error messages (e.g., invalid menu choice, trying to process an empty queue).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks, specifically to handle potential `InputMismatchException` when reading integer menu choices and to gracefully handle operations on empty queues or lists.
 *     *   Ensure proper encapsulation by making fields private and providing public methods where necessary.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc to explain the code structure and logic.
 *     *   Validate user input where appropriate (e.g., menu choice must be an integer within the valid range).
 * 
 * **Expected Output:**
 * 
 * The program should display the menu, prompt for user input, and perform the requested action, printing results or error messages.
 * 
 * *   Adding a request should print a confirmation.
 * *   Viewing/Processing an empty queue should print an error message to `System.err`.
 * *   Viewing lists should display the details of the requests.
 * *   Invalid menu input (non-integer or out of range) should be caught and report an error to `System.err` without crashing.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Customer Service Request Processor Menu:
 * 1. Add New Request
 * 2. View Next Pending Request
 * 3. Process Next Pending Request
 * 4. View All Pending Requests
 * 5. View All Completed Requests
 * 6. Exit
 * Enter your choice: 1
 * Enter request description: Printer not working
 * 
 * Request added with ID: 1
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 1
 * Enter request description: Software installation failed
 * 
 * Request added with ID: 2
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 2
 * Next pending request: Request [ID=1, Description=Printer not working, Status=Pending]
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 3
 * Processing request: Request [ID=1, Description=Printer not working, Status=Pending]
 * Request ID 1 processed and completed.
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 4
 * Pending Requests:
 * Request [ID=2, Description=Software installation failed, Status=Pending]
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 5
 * Completed Requests:
 * Request [ID=1, Description=Printer not working, Status=Completed]
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 7
 * Error: Invalid menu choice. Please enter a number between 1 and 6.
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a valid number for the menu choice.
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 3
 * Error: No pending requests to process.
 * 
 * Customer Service Request Processor Menu:
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 *
 * EXPLANATION:
 * This solution implements the Customer Service Request Processor system as described in the problem. It effectively demonstrates the usage of all required Java components and follows best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`Queue<Request>` (using `LinkedList`):** The `pendingRequests` field in `RequestProcessor` is declared as a `Queue`. A `LinkedList` is used as the concrete implementation because it supports the `Queue` interface methods efficiently (`offer` for adding, `peek` for viewing the head, `poll` for removing the head). This correctly models the FIFO (First-In, First-Out) nature of processing requests.
 * 2.  **`ArrayList<Request>`:** The `completedRequests` field is an `ArrayList`. This is suitable for storing completed requests as a simple dynamic list where elements are added sequentially, and random access or iteration is easy.
 * 3.  **`List<Request>`:** The `completedRequests` field is declared using the `List` interface (`List<Request> completedRequests = new ArrayList<>();`). This is a good practice as it programs to the interface rather than the implementation, allowing easier changes to the underlying list type in the future if needed. The `getAllPendingRequests` method also returns a `List`, further adhering to this principle.
 * 4.  **`Scanner`:** A `Scanner` object is created in the `main` method to read user input from `System.in` for menu choices and request descriptions.
 * 5.  **`switch` statement:** The `main` method uses a `switch` statement based on the integer menu choice read from the user. This provides a clean and readable way to dispatch control to the appropriate logic for each menu option.
 * 6.  **`System.err`:** Error messages, such as invalid input, trying to process an empty queue, or empty request descriptions, are printed to `System.err.println`. This separates error output from normal program output (`System.out`).
 * 7.  **`System.out`:** Normal program output, including the menu, prompts, successful action confirmations, and lists of requests, is printed using `System.out.println`.
 * 8.  **Class-wide `try-catch`:** A large `try-catch` block wraps the main `while(running)` loop in the `main` method. This demonstrates a form of class-wide handling for unexpected exceptions that might occur within the main execution flow. Additionally, a specific `try-catch` block is used around reading the integer menu choice (`scanner.nextInt()`) to gracefully handle `InputMismatchException` if the user enters non-integer input. A `finally` block ensures `scanner.nextLine()` is called to consume the rest of the line after `nextInt()`, preventing input issues in subsequent reads.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** The `Request` and `RequestProcessor` classes have private fields (`id`, `description`, `status`, `pendingRequests`, `completedRequests`, `nextRequestId`) and provide public methods (`get...`, `set...`, `addRequest`, `processNextPendingRequest`, etc.) to interact with their state.
 * *   **Meaningful Names:** Class names (`Request`, `RequestProcessor`), enum name (`RequestStatus`), field names (`pendingRequests`, `completedRequests`, `nextRequestId`), and method names (`addRequest`, `viewNextPendingRequest`, `processNextPendingRequest`, `getAllPendingRequests`, `getAllCompletedRequests`, `printMenu`) are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Basic inline comments and Javadoc comments are included to explain the purpose of classes, methods, and specific code sections.
 * *   **Input Validation:** The code checks if the entered menu choice is within the valid range (1-6) and handles invalid integer input using `try-catch`. It also includes a basic check for empty request descriptions.
 * *   **Error Handling:** Operations on the queue (`peek`, `poll`) are checked for `null` results to determine if the queue was empty, and appropriate error messages are printed to `System.err`. The `try-catch` blocks handle input errors and potential unexpected exceptions.
 * *   **Clean Code Structure:** The code is organized into logical classes (`RequestStatus`, `Request`, `RequestProcessor`, `ExamQuestion`) with clear responsibilities. The main loop and menu handling are separated into the `main` method and a helper `printMenu` method.
 * 
 * This solution provides a solid foundation for a simple request processing system, showcasing the required Java features in a practical and challenging context suitable for an exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Request Status
enum RequestStatus {
    Pending, Processing, Completed
}

// Class to represent a service request
class Request {
    private int id;
    private String description;
    private RequestStatus status;

    /**
     * Constructs a new Request.
     * @param id The unique ID for the request.
     * @param description The description of the request.
     */
    public Request(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = RequestStatus.Pending; // New requests start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public RequestStatus getStatus() {
        return status;
    }

    // --- Setter for status ---
    /**
     * Updates the status of the request.
     * @param status The new status to set.
     */
    public void setStatus(RequestStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Request [ID=" + id + ", Description=" + description + ", Status=" + status + "]";
    }
}

// Class to manage the queue and list of requests
class RequestProcessor {
    private Queue<Request> pendingRequests;
    private List<Request> completedRequests;
    private int nextRequestId;

    /**
     * Constructs a new RequestProcessor.
     */
    public RequestProcessor() {
        // Using LinkedList as a Queue implementation
        this.pendingRequests = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Adds a new request to the pending queue.
     * @param description The description for the new request.
     */
    public void addRequest(String description) {
        Request newRequest = new Request(nextRequestId++, description);
        pendingRequests.offer(newRequest); // Use offer for safe insertion
        System.out.println("\nRequest added with ID: " + newRequest.getId());
    }

    /**
     * Views the next request in the pending queue without removing it.
     * @return The next pending request, or null if the queue is empty.
     */
    public Request viewNextPendingRequest() {
        return pendingRequests.peek(); // Use peek to view without removing
    }

    /**
     * Processes the next request in the pending queue.
     * Removes it from the queue, updates its status to Completed, and adds it to the completed list.
     * @return The processed request, or null if the queue was empty.
     */
    public Request processNextPendingRequest() {
        Request requestToProcess = pendingRequests.poll(); // Use poll to remove and retrieve
        if (requestToProcess != null) {
            requestToProcess.setStatus(RequestStatus.Completed);
            completedRequests.add(requestToProcess);
        }
        return requestToProcess;
    }

    /**
     * Gets a list of all pending requests.
     * Note: This creates a new list to avoid modifying the internal queue state during iteration.
     * @return A List containing all pending requests.
     */
    public List<Request> getAllPendingRequests() {
        // Create a new list from the queue elements for safe iteration/display
        return new ArrayList<>(pendingRequests);
    }

    /**
     * Gets a list of all completed requests.
     * @return A List containing all completed requests.
     */
    public List<Request> getAllCompletedRequests() {
        return completedRequests; // Return the list directly
    }
}

// Main class for the exam question entry point
public class ExamQuestion {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RequestProcessor processor = new RequestProcessor();
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Try-catch for reading the menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a valid number for the menu choice.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Consume the rest of the line after reading the integer choice
                     // This prevents issues when reading the next line (like description)
                     scanner.nextLine();
                }

                // Switch statement to handle menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        if (description != null && !description.trim().isEmpty()) {
                             processor.addRequest(description.trim());
                        } else {
                             System.err.println("Error: Request description cannot be empty.");
                        }
                        break;
                    case 2:
                        Request nextPending = processor.viewNextPendingRequest();
                        if (nextPending != null) {
                            System.out.println("\nNext pending request: " + nextPending);
                        } else {
                            System.err.println("Error: No pending requests to view.");
                        }
                        break;
                    case 3:
                        Request processedRequest = processor.processNextPendingRequest();
                        if (processedRequest != null) {
                            System.out.println("\nProcessing request: " + processedRequest); // Shows before status change
                            System.out.println("Request ID " + processedRequest.getId() + " processed and completed.");
                        } else {
                            System.err.println("Error: No pending requests to process.");
                        }
                        break;
                    case 4:
                        List<Request> pendingList = processor.getAllPendingRequests();
                        System.out.println("\n--- Pending Requests ---");
                        if (pendingList.isEmpty()) {
                            System.out.println("No pending requests.");
                        } else {
                            for (Request req : pendingList) {
                                System.out.println(req);
                            }
                        }
                        System.out.println("------------------------");
                        break;
                    case 5:
                        List<Request> completedList = processor.getAllCompletedRequests();
                        System.out.println("\n--- Completed Requests ---");
                         if (completedList.isEmpty()) {
                            System.out.println("No completed requests.");
                        } else {
                            for (Request req : completedList) {
                                System.out.println(req);
                            }
                        }
                        System.out.println("--------------------------");
                        break;
                    case 6:
                        running = false;
                        System.out.println("\nExiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Print a newline for better formatting between operations
            }
        } catch (Exception e) {
             // Catch any unexpected exceptions that might occur in the main loop
             System.err.println("An unexpected error occurred: " + e.getMessage());
             e.printStackTrace(); // Optional: print stack trace for debugging in exam
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Customer Service Request Processor Menu:");
        System.out.println("1. Add New Request");
        System.out.println("2. View Next Pending Request");
        System.out.println("3. Process Next Pending Request");
        System.out.println("4. View All Pending Requests");
        System.out.println("5. View All Completed Requests");
        System.out.println("6. Exit");
    }
}
