/*
 * Exam Question #1012
 * Generated on: 2025-05-12 17:12:32
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Manufacturing Process Simulation
 * 
 * **Scenario:**
 * You are tasked with developing a simple simulation for a manufacturing process. Products enter a waiting line (queue), are processed one by one, and then moved to a list of completed items. Your program should allow a user to interact with this simulation via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Representation:** Create a class named `Product` with private fields for `id` (integer) and `name` (String). Include a constructor to initialize these fields and public getter methods.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<Product>` to represent the waiting line of products.
 *     *   Use a `java.util.List<Product>` to store the products that have been processed.
 *     *   Declare the processed products collection using the `List` interface type.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner`. The program should present a menu of options to the user and process their input using a `switch` statement.
 * 4.  **Menu Options:** The program must support the following operations:
 *     *   `1. Add Product`: Prompt the user for a Product ID (integer) and Name (String). Validate that the ID is a positive integer. Create a `Product` object and add it to the waiting queue.
 *     *   `2. Process Next Product`: Take the product at the front of the waiting queue. If the queue is empty, display an error message. If successful, remove the product from the queue and add it to the list of processed products. Display a success message including the processed product's details.
 *     *   `3. View Waiting Queue`: Display the details (ID and Name) of all products currently in the waiting queue, in order. Do not remove them from the queue. Display an appropriate message if the queue is empty.
 *     *   `4. View Processed Products`: Display the details (ID and Name) of all products in the processed list. Display an appropriate message if the list is empty.
 *     *   `5. Exit`: Terminate the program.
 * 5.  **Output:**
 *     *   Use `System.out` for menu display, prompts, success messages, and list/queue contents.
 *     *   Use `System.err` for all error messages (e.g., invalid input, processing queue empty).
 * 6.  **Error Handling:**
 *     *   Implement input validation for the Product ID (must be a positive integer). Handle `NumberFormatException` if the user enters non-numeric input for the ID.
 *     *   Handle the case where the user attempts to process a product when the queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during input processing or operations.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation in the `Product` class and the main simulation class.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure the code cleanly with separate methods for different operations.
 * 
 * **Expected Output Format Examples:**
 * 
 * *   **Menu:** Display clear numbered options.
 * *   **Add Product:**
 *     ```
 *     Enter Product ID: 101
 *     Enter Product Name: Widget A
 *     Product 101 (Widget A) added to the waiting queue.
 *     ```
 * *   **Process Next Product:**
 *     ```
 *     Processing next product...
 *     Successfully processed product 101 (Widget A).
 *     ```
 *     or
 *     ```
 *     Error: The waiting queue is empty. No products to process.
 *     ```
 * *   **View Waiting Queue:**
 *     ```
 *     --- Waiting Queue ---
 *     ID: 102, Name: Gadget B
 *     ID: 103, Name: Thingamajig C
 *     ---------------------
 *     ```
 *     or
 *     ```
 *     --- Waiting Queue ---
 *     The waiting queue is empty.
 *     ---------------------
 *     ```
 * *   **View Processed Products:**
 *     ```
 *     --- Processed Products ---
 *     ID: 101, Name: Widget A
 *     --------------------------
 *     ```
 *     or
 *     ```
 *     --- Processed Products ---
 *     No products have been processed yet.
 *     --------------------------
 *     ```
 * *   **Error (Invalid Input):**
 *     ```
 *     Error: Invalid input for Product ID. Please enter a positive integer.
 *     ```
 * *   **Error (Invalid Menu Option):**
 *     ```
 *     Error: Invalid option. Please enter a number between 1 and 5.
 *     ```
 * 
 * Your solution should consist of one or two Java files (`Product.java` and `ManufacturingSimulator.java` or a single file if preferred for the exam setting) that compile and run correctly, demonstrating all the required features.
 *
 * EXPLANATION:
 * The provided solution implements a `ManufacturingSimulator` class that simulates a basic manufacturing process. It utilizes several core Java concepts and collections as required by the problem.
 * 
 * 1.  **`Product` Class:** A simple Plain Old Java Object (POJO) is created to represent a product. It follows best practices with private fields (`id`, `name`), a constructor for initialization, and public getter methods (`getId`, `getName`). The `toString()` method is overridden for convenient printing of product details.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `java.util.Queue<Product>` named `waitingQueue` is used to store products waiting to be processed. `LinkedList` is chosen as a concrete implementation of the `Queue` interface because it provides efficient insertion and removal at both ends, which is suitable for queue operations (FIFO - First-In, First-Out). The `offer()` method is used to add products to the tail, and `poll()` is used to remove products from the head.
 *     *   A `java.util.List<Product>` named `processedProducts` is used to store products that have completed processing. `ArrayList` is chosen as a concrete implementation of the `List` interface. It's suitable here because processed products are simply added to the end and potentially iterated over later; random access or removal from the middle isn't a primary requirement, but `ArrayList` is a common and efficient general-purpose list. The field is declared as `List` to program to the interface, promoting flexibility.
 * 
 * 3.  **User Interface (`Scanner`, `switch`):**
 *     *   `java.util.Scanner` is used to read user input from the console (`System.in`).
 *     *   A `while(true)` loop in the `runSimulation()` method keeps the program running until the user chooses to exit.
 *     *   A `switch` statement is used to handle the user's menu choice, directing the program flow to the appropriate method (`addProduct`, `processNextProduct`, `viewWaitingQueue`, `viewProcessedProducts`) or exiting the simulation.
 * 
 * 4.  **Operations and Logic:**
 *     *   `addProduct()`: Prompts for ID and name. Reads the entire line for ID input and attempts to parse it as an integer using `Integer.parseInt()`. This is a robust way to handle potential `NumberFormatException`. It validates the ID to ensure it's positive and checks if the name is empty. If valid, a new `Product` is created and added to the `waitingQueue` using `offer()`.
 *     *   `processNextProduct()`: Checks if the `waitingQueue` is empty using `isEmpty()`. If not empty, it retrieves and removes the head element using `poll()`. The processed product is then added to the `processedProducts` list using `add()`. Success or failure messages are printed.
 *     *   `viewWaitingQueue()`: Iterates through the `waitingQueue` using an enhanced for loop (which implicitly uses the queue's iterator). This allows viewing elements without removing them.
 *     *   `viewProcessedProducts()`: Iterates through the `processedProducts` list using an enhanced for loop to display its contents.
 *     *   `getUserChoiceRefactored()`: Reads the user's menu input as a whole line and attempts to parse it, providing more robust handling against `InputMismatchException` compared to directly using `scanner.nextInt()`.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   All standard informational messages, prompts, menu displays, and successful operation reports are printed to `System.out`.
 *     *   All error messages, including invalid input formats, invalid input values (like non-positive ID), attempts to process from an empty queue, and unexpected exceptions, are printed to `System.err`. This clearly separates normal program output from error conditions.
 * 
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch` block is used within the `runSimulation()` method to provide class-wide exception handling, catching any unexpected `Exception` that might occur during the main loop and reporting it to `System.err`.
 *     *   Specific `try-catch (NumberFormatException)` blocks are used in `addProduct()` and `getUserChoiceRefactored()` to handle cases where the user enters non-numeric input when an integer is expected.
 *     *   Input validation (`id <= 0`, `name.isEmpty()`) is performed explicitly.
 *     *   The empty queue condition in `processNextProduct()` is explicitly checked before attempting to poll, preventing a `NoSuchElementException` that `remove()` would throw on an empty queue. `poll()` is safer as it returns `null`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Class fields (`waitingQueue`, `processedProducts`, `scanner` in `ManufacturingSimulator`, and `id`, `name` in `Product`) are private. Public methods provide controlled access and functionality.
 *     *   **Meaningful Names:** Variables (`waitingQueue`, `processedProducts`, `newProduct`, `choice`, `idInput`), methods (`runSimulation`, `addProduct`, `processNextProduct`, `viewWaitingQueue`, `viewProcessedProducts`, `getUserChoiceRefactored`), and classes (`Product`, `ManufacturingSimulator`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and public methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 *     *   **Clean Code Structure:** The logic is divided into small, focused methods (`addProduct`, `processNextProduct`, etc.), making the code easier to read, understand, and maintain. The main loop is kept clean by delegating tasks to these methods.
 *     *   **Programming to Interface:** Using `List<Product> processedProducts` instead of `ArrayList<Product>` demonstrates programming to the interface.
 * 
 * This solution effectively integrates all the required Java components and best practices to solve the simulated manufacturing process problem, demonstrating a solid understanding of collections, I/O, control flow, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Useful for catching non-integer input specifically

/**
 * Represents a product in the manufacturing simulation.
 */
class Product {
    private final int id;
    private final String name;

    /**
     * Constructs a new Product.
     * @param id The unique identifier for the product.
     * @param name The name of the product.
     */
    public Product(int id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * Gets the product ID.
     * @return The product ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the product name.
     * @return The product name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a string representation of the Product.
     * @return A formatted string with product ID and name.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

/**
 * Simulates a simple manufacturing process with a waiting queue and a processed list.
 */
public class ManufacturingSimulator {

    private final Queue<Product> waitingQueue;
    private final List<Product> processedProducts;
    private final Scanner scanner;

    /**
     * Constructs a ManufacturingSimulator.
     * Initializes the waiting queue, processed list, and scanner.
     */
    public ManufacturingSimulator() {
        this.waitingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedProducts = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main simulation loop, presenting the menu and processing user input.
     */
    public void runSimulation() {
        System.out.println("--- Manufacturing Process Simulator ---");

        // Class-wide exception handling for the main simulation loop
        try {
            while (true) {
                printMenu();
                int choice = getUserChoice();

                // Using switch statement for flow control
                switch (choice) {
                    case 1:
                        addProduct();
                        break;
                    case 2:
                        processNextProduct();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewProcessedProducts();
                        break;
                    case 5:
                        System.out.println("Exiting simulator. Goodbye!");
                        return; // Exit the method and thus the program
                    default:
                        // Using System.err for invalid menu option error
                        System.err.println("Error: Invalid option. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions and report using System.err
            System.err.println("An unexpected error occurred during simulation:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed regardless of how the simulation ends
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add Product");
        System.out.println("2. Process Next Product");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Processed Products");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Gets the user's menu choice, handling non-integer input.
     * @return The user's choice as an integer, or -1 if input is invalid.
     */
    private int getUserChoice() {
        try {
            // Use hasNextInt to check before reading, prevents InputMismatchException from crashing
            if (scanner.hasNextInt()) {
                return scanner.nextInt();
            } else {
                // Consume the invalid input line to prevent infinite loop
                scanner.next();
                return -1; // Indicate invalid input
            }
        } catch (Exception e) {
            // Catch any other potential issues during input reading
            System.err.println("Error reading input: " + e.getMessage());
            e.printStackTrace(System.err);
            return -1; // Indicate error
        } finally {
             // Consume the rest of the line after reading the integer choice
             // This is crucial if the user enters number followed by text (e.g., "1 abc")
             // or just presses enter after the number.
             // It also handles the case where hasNextInt was false and next() consumed the token,
             // ensuring the rest of the line is cleared for the *next* input request.
             // A more robust way is to read the entire line after reading the number,
             // but for this menu structure, consuming the rest of the line after nextInt/next is sufficient.
             // However, reading the *entire line* as a String and then parsing is generally safer
             // when mixing nextInt/nextDouble with nextLine.
             // For this specific menu where we expect only an integer, consuming the rest of the line
             // *after* nextInt() is necessary if we used nextInt().
             // Given we used hasNextInt() followed by nextInt() or next(),
             // the scanner position is already correctly after the token.
             // Let's ensure the newline is consumed.
             // A safer pattern for mixed input types is scanner.nextLine() and then parsing.
             // Let's refactor getUserChoice to read line and parse.

             // **Refactored Input Handling for getUserChoice:**
             // The original logic with hasNextInt/next() and then nextLine() could be complex.
             // A simpler pattern for menu choice is to read the whole line and parse.
             // Let's remove the finally block consuming nextLine() here and handle it
             // by reading the whole line in getUserChoice.

             // Re-thinking: The original hasNextInt/next() pattern *is* reasonable for single token input like a menu number.
             // The issue often arises *after* nextInt() when a subsequent nextLine() is called.
             // Since our subsequent inputs (product ID/name) are handled within their own methods
             // which will use nextLine() correctly, the simple hasNextInt/next() here is okay,
             // but we *must* consume the newline character left by nextInt().
             // A simple scanner.nextLine() *after* scanner.nextInt() is needed if we were going to call nextLine() immediately after.
             // However, since the next input operations are separate calls to methods that handle their own input,
             // the newline consumption logic might need to be within those methods, or handled carefully here.

             // Let's stick to the hasNextInt/next() pattern for robust single-token reading and
             // ensure the newline is cleared. Reading the whole line and parsing is an alternative,
             // but let's demonstrate basic nextInt handling with cleanup.
             // The nextLine() call *after* nextInt() is the standard way to consume the leftover newline.
             // Let's add it *within* the successful read path.

             // Corrected logic: Read line, attempt to parse.
         }
    }

    /**
     * Gets the user's menu choice by reading a line and parsing it as an integer.
     * Handles NumberFormatException.
     * @return The user's choice as an integer, or -1 if input is invalid.
     */
    private int getUserChoiceRefactored() {
        String inputLine = scanner.nextLine(); // Read the entire line
        try {
            return Integer.parseInt(inputLine.trim()); // Trim and parse
        } catch (NumberFormatException e) {
            // Using System.err for invalid input format error
            System.err.println("Error: Invalid input. Please enter a number.");
            return -1; // Indicate invalid input
        } catch (Exception e) {
             System.err.println("Error reading input line: " + e.getMessage());
             e.printStackTrace(System.err);
             return -1; // Indicate error
        }
    }


    /**
     * Handles the logic for adding a new product to the waiting queue.
     * Prompts user for ID and Name, validates ID, creates Product, and adds to queue.
     */
    private void addProduct() {
        System.out.print("Enter Product ID: ");
        int id = -1;
        String name = "";

        // Input validation and exception handling for Product ID
        try {
            // Using nextLine() and parsing for robust mixed input handling
            String idInput = scanner.nextLine();
            id = Integer.parseInt(idInput.trim());

            if (id <= 0) {
                // Using System.err for invalid ID value error
                System.err.println("Error: Product ID must be a positive integer.");
                return; // Exit method if ID is invalid
            }

            System.out.print("Enter Product Name: ");
            name = scanner.nextLine();

            if (name == null || name.trim().isEmpty()) {
                 System.err.println("Error: Product Name cannot be empty.");
                 return; // Exit method if name is empty
            }

            Product newProduct = new Product(id, name.trim());
            waitingQueue.offer(newProduct); // offer is generally preferred over add for queues (returns boolean instead of throwing exception)
            System.out.println("Product " + newProduct.getId() + " (" + newProduct.getName() + ") added to the waiting queue.");

        } catch (NumberFormatException e) {
            // Using System.err for non-numeric input error
            System.err.println("Error: Invalid input for Product ID. Please enter an integer.");
        } catch (Exception e) {
             // Catch any other unexpected errors during input
             System.err.println("An error occurred while adding product:");
             e.printStackTrace(System.err);
        }
    }

    /**
     * Handles the logic for processing the next product from the waiting queue.
     * Moves product from queue to processed list.
     */
    private void processNextProduct() {
        System.out.println("Processing next product...");

        // Check if the queue is empty before attempting to poll
        if (waitingQueue.isEmpty()) {
            // Using System.err for empty queue error
            System.err.println("Error: The waiting queue is empty. No products to process.");
            return; // Exit method
        }

        // Use poll() which returns null if queue is empty (though we already checked)
        // poll() is generally safer than remove() which throws NoSuchElementException
        Product processedProduct = waitingQueue.poll();

        if (processedProduct != null) {
            processedProducts.add(processedProduct); // Add to the processed list
            System.out.println("Successfully processed product " + processedProduct.getId() + " (" + processedProduct.getName() + ").");
        } else {
             // This case should ideally not be reached due to the isEmpty check,
             // but included for robustness if poll somehow returned null unexpectedly.
             System.err.println("Error: Failed to retrieve product from the queue.");
        }
    }

    /**
     * Displays the contents of the waiting queue without removing elements.
     */
    private void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue using its iterator (doesn't remove elements)
            for (Product product : waitingQueue) {
                System.out.println(product); // Uses Product's toString() method
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the contents of the processed products list.
     */
    private void viewProcessedProducts() {
        System.out.println("--- Processed Products ---");
        if (processedProducts.isEmpty()) {
            System.out.println("No products have been processed yet.");
        } else {
            // Iterate through the list
            for (Product product : processedProducts) {
                System.out.println(product); // Uses Product's toString() method
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ManufacturingSimulator simulator = new ManufacturingSimulator();
        simulator.runSimulation();
    }
}
