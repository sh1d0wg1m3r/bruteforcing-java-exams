/*
 * Exam Question #105
 * Generated on: 2025-05-11 22:15:01
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Service Request Processing System**
 * 
 * You are tasked with developing a simple Service Request Processing System for a small organization. The system should allow users to submit new service requests, process pending requests one by one, and view both pending and completed requests.
 * 
 * Your solution must demonstrate proficiency in core Java concepts, including collections, input/output, control flow, exception handling, and object-oriented principles.
 * 
 * **System Requirements:**
 * 
 * 1.  **Service Request Object:** Create a class `ServiceRequest` to represent a single request.
 *     *   It must have private fields: `requestId` (an integer, unique identifier), `requestType` (a character, e.g., 'P' for Priority, 'S' for Standard, 'M' for Maintenance), `description` (a String), and `status` (a String, e.g., "Pending", "Processing", "Completed").
 *     *   Provide a constructor to initialize these fields (status should default to "Pending").
 *     *   Include public getter methods for all fields.
 *     *   Include a public method `updateStatus(String newStatus)` to change the request's status.
 *     *   Override the `toString()` method for easy printing of request details.
 * 
 * 2.  **Request Processing System:** Create a class `RequestProcessor` to manage the requests.
 *     *   It must have private fields: a `Queue<ServiceRequest>` to hold requests that are pending processing, and a `List<ServiceRequest>` to store requests that have been completed.
 *     *   Maintain a counter for generating unique request IDs.
 *     *   Implement the following public methods:
 *         *   `submitRequest(char type, String description)`: Adds a new `ServiceRequest` to the pending queue.
 *             *   Validate that the `type` is one of the allowed types ('P', 'S', 'M'). If invalid, print an error message to `System.err` and do not add the request.
 *         *   `processNextRequest()`:
 *             *   Retrieves the next request from the pending queue.
 *             *   If the queue is empty, print a message to `System.out` indicating no pending requests.
 *             *   If a request is retrieved, update its status to "Processing" (you can simulate processing instantly for this task).
 *             *   After simulated processing, update its status to "Completed" and move it from the queue to the completed list.
 *             *   Print a message to `System.out` indicating which request was processed.
 *         *   `viewPendingRequests()`: Prints details of all requests currently in the pending queue. If the queue is empty, print a message to `System.out`.
 *         *   `viewCompletedRequests()`: Prints details of all requests in the completed list. If the list is empty, print a message to `System.out`.
 * 
 * 3.  **User Interface:** In your `main` method (within the `RequestProcessor` class or a separate class), create a command-line interface using `Scanner`.
 *     *   Present a menu to the user with options:
 *         1.  Submit New Request
 *         2.  Process Next Request
 *         3.  View Pending Requests
 *         4.  View Completed Requests
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop so the menu is shown repeatedly until the user chooses to exit.
 * 
 * 4.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main application loop to catch potential unexpected errors during input reading or processing.
 *     *   Specifically handle potential `java.util.InputMismatchException` if the user enters non-integer input for the menu choice. Print an error message to `System.err` and clear the invalid input from the scanner.
 * 
 * 5.  **Input/Output:**
 *     *   Use `Scanner` to read user input.
 *     *   Use `System.out` for menu display, prompts, successful operations, and viewing requests.
 *     *   Use `System.err` for all error messages (e.g., invalid request type, invalid menu input).
 * 
 * 6.  **Java Components Usage:** Your solution *must* explicitly use:
 *     *   `java.util.Queue` (e.g., implemented by `java.util.LinkedList`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as the type for the completed requests collection)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (including Javadoc for classes/methods) and documentation.
 *     *   Implement input validation as specified.
 *     *   Ensure proper error handling using `try-catch` and `System.err`.
 *     *   Structure the code cleanly.
 * 
 * **Expected Output Format:**
 * 
 * *   Menu should be clearly displayed.
 * *   Prompts for input should be clear.
 * *   When viewing requests (pending or completed), print each request on a new line using its `toString()` representation.
 * *   Error messages should be clearly distinguishable (using `System.err`).
 * 
 * **Example Interaction Flow (partial):**
 * 
 * ```
 * --- Service Request System ---
 * 1. Submit New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 1
 * Enter request type (P/S/M): S
 * Enter request description: Install new software
 * Request submitted successfully!
 * 
 * --- Service Request System ---
 * ...
 * Enter choice: 3
 * --- Pending Requests ---
 * Request ID: 1, Type: S, Description: Install new software, Status: Pending
 * --------------------------
 * 
 * --- Service Request System ---
 * ...
 * Enter choice: 2
 * Processing Request ID: 1
 * Request ID: 1 processed and completed.
 * 
 * --- Service Request System ---
 * ...
 * Enter choice: 4
 * --- Completed Requests ---
 * Request ID: 1, Type: S, Description: Install new software, Status: Completed
 * --------------------------
 * 
 * --- Service Request System ---
 * ...
 * Enter choice: x
 * Error: Invalid input. Please enter a number.
 * 
 * --- Service Request System ---
 * ...
 * Enter choice: 1
 * Enter request type (P/S/M): X
 * Error: Invalid request type. Please enter P, S, or M.
 * ```
 * 
 * Write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements the Service Request Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`ServiceRequest` Class:**
 *     *   Encapsulation: Private fields (`requestId`, `requestType`, `description`, `status`) are used, and public getters provide controlled access.
 *     *   Constructor: Initializes a new request with a unique ID, type, description, and sets the initial status to "Pending".
 *     *   `updateStatus()`: A public method allows controlled modification of the status.
 *     *   `toString()`: Provides a convenient string representation for printing request details.
 * 
 * 2.  **`RequestProcessor` Class:**
 *     *   **`Queue<ServiceRequest> pendingRequests`:** A `LinkedList` is used to implement the `Queue` interface. This is suitable for a pending queue because requests are added to the end (`add()`) and processed from the front (`poll()`), following a First-In, First-Out (FIFO) order.
 *     *   **`List<ServiceRequest> completedRequests`:** An `ArrayList` is used to implement the `List` interface. This collection stores completed requests, where order might be less critical after processing, and random access or iteration is common.
 *     *   **`nextRequestId`:** A simple integer counter ensures each new request gets a unique ID.
 *     *   **`submitRequest()`:** Takes type and description, performs input validation for the type ('P', 'S', 'M'). If invalid, it prints an error using `System.err` and returns without creating the request. Otherwise, it creates a `ServiceRequest` object and adds it to the `pendingRequests` queue.
 *     *   **`processNextRequest()`:** Uses `pendingRequests.poll()` to retrieve and remove the head of the queue. It checks if the result is `null` (meaning the queue was empty) and prints an appropriate message to `System.out`. If a request is found, it simulates processing by updating the status and then moves the request to the `completedRequests` list. Success messages are printed to `System.out`.
 *     *   **`viewPendingRequests()`:** Iterates through the `pendingRequests` queue using an enhanced for loop (which doesn't remove elements) and prints each request's `toString()` representation to `System.out`. Handles the empty queue case.
 *     *   **`viewCompletedRequests()`:** Iterates through the `completedRequests` list and prints each request's `toString()` representation to `System.out`. Handles the empty list case.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`run()`:** Contains the main application loop. It uses a `Scanner` to read user input.
 *         *   **`switch` statement:** Handles the different menu options (`case 1` through `5`).
 *         *   **`try-catch` block:** A `try-catch` block wraps the core logic inside the `while` loop.
 *             *   It specifically catches `InputMismatchException` which occurs if `scanner.nextInt()` fails (e.g., user enters text instead of a number). An error message is printed to `System.err`, and `scanner.nextLine()` is called to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *             *   A general `Exception` catch is included as a fallback for any other unexpected runtime errors, printing a message to `System.err`.
 *         *   Input for submitting a request is read using `scanner.nextLine()` after consuming the newline left by `scanner.nextInt()`. Basic validation for the type string length is added.
 *         *   `System.err` is used exclusively for error messages (invalid input, invalid request type).
 *         *   `System.out` is used for all normal output (menu, prompts, success messages, viewing lists/queue).
 *         *   The scanner is closed when the loop exits (user chooses option 5).
 * 
 * 3.  **`main` Method:**
 *     *   The entry point of the application. It creates an instance of `RequestProcessor` and calls its `run()` method to start the system.
 * 
 * 4.  **Best Practices:**
 *     *   Clear separation of concerns between `ServiceRequest` (data object) and `RequestProcessor` (system logic).
 *     *   Meaningful names (`pendingRequests`, `processNextRequest`, `requestId`, etc.).
 *     *   Javadoc comments explain the purpose of classes and methods.
 *     *   Input validation is performed before processing (e.g., request type check).
 *     *   Error handling is implemented using `try-catch` and `System.err` for clear error reporting.
 *     *   The code is structured logically with private helper methods (`displayMenu`).
 * 
 * This solution effectively integrates all required components into a functional system, demonstrating key Java programming skills necessary for handling collections, I/O, control flow, and errors in a structured, object-oriented manner.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single service request in the system.
 */
class ServiceRequest {
    private int requestId;
    private char requestType;
    private String description;
    private String status;

    private static final String STATUS_PENDING = "Pending";
    private static final String STATUS_PROCESSING = "Processing";
    private static final String STATUS_COMPLETED = "Completed";

    /**
     * Constructs a new ServiceRequest.
     *
     * @param requestId The unique identifier for the request.
     * @param requestType The type of the request ('P', 'S', 'M').
     * @param description A brief description of the request.
     */
    public ServiceRequest(int requestId, char requestType, String description) {
        this.requestId = requestId;
        this.requestType = requestType;
        this.description = description;
        this.status = STATUS_PENDING; // Default status
    }

    // --- Getters ---
    public int getRequestId() {
        return requestId;
    }

    public char getRequestType() {
        return requestType;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the service request.
     *
     * @param newStatus The new status for the request.
     */
    public void updateStatus(String newStatus) {
        this.status = newStatus;
    }

    @Override
    public String toString() {
        return "Request ID: " + requestId +
               ", Type: " + requestType +
               ", Description: " + description +
               ", Status: " + status;
    }
}

/**
 * Manages the queue and processing of service requests.
 */
public class RequestProcessor { // Made public for the main method

    private Queue<ServiceRequest> pendingRequests;
    private List<ServiceRequest> completedRequests;
    private int nextRequestId; // Counter for unique IDs

    /**
     * Constructs a new RequestProcessor.
     */
    public RequestProcessor() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.completedRequests = new ArrayList<>(); // ArrayList implements List
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Submits a new service request to the pending queue.
     *
     * @param type The type of the request ('P', 'S', 'M').
     * @param description A brief description of the request.
     */
    public void submitRequest(char type, String description) {
        // Input validation for request type
        if (type != 'P' && type != 'S' && type != 'M') {
            System.err.println("Error: Invalid request type. Please enter P, S, or M.");
            return; // Do not add the request
        }

        ServiceRequest newRequest = new ServiceRequest(nextRequestId++, type, description);
        pendingRequests.add(newRequest);
        System.out.println("Request submitted successfully! ID: " + newRequest.getRequestId());
    }

    /**
     * Processes the next request from the pending queue.
     */
    public void processNextRequest() {
        ServiceRequest requestToProcess = pendingRequests.poll(); // Retrieves and removes the head of the queue

        if (requestToProcess == null) {
            System.out.println("No pending requests to process.");
        } else {
            System.out.println("Processing Request ID: " + requestToProcess.getRequestId());
            requestToProcess.updateStatus("Processing"); // Simulate processing

            // Simulate completion instantly after "processing"
            requestToProcess.updateStatus("Completed");
            completedRequests.add(requestToProcess); // Move to completed list
            System.out.println("Request ID: " + requestToProcess.getRequestId() + " processed and completed.");
        }
    }

    /**
     * Prints all requests currently in the pending queue.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No requests currently pending.");
        } else {
            // Iterating through the queue without removing elements
            for (ServiceRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Prints all requests that have been completed.
     */
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No requests have been completed yet.");
        } else {
            // Iterating through the list
            for (ServiceRequest request : completedRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Service Request System ---");
        System.out.println("1. Submit New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize with a value outside the menu range

        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                switch (choice) {
                    case 1:
                        System.out.print("Enter request type (P/S/M): ");
                        String typeInput = scanner.nextLine().trim().toUpperCase();
                        if (typeInput.length() != 1) {
                             System.err.println("Error: Invalid input for type. Please enter a single character (P, S, or M).");
                             break; // Go back to menu
                        }
                        char type = typeInput.charAt(0);

                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        submitRequest(type, description);
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        System.out.println("Exiting Service Request System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Clear the invalid input from the scanner
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    public static void main(String[] args) {
        RequestProcessor processor = new RequestProcessor();
        processor.run();
    }
}
