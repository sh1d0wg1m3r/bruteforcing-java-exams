/*
 * Exam Question #571
 * Generated on: 2025-05-11 23:30:58
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple simulation of a system that manages and processes tasks. Tasks are submitted and placed into a waiting queue. The system processes tasks one by one from the front of the queue in a First-In, First-Out (FIFO) manner. Once a task is processed, it is moved to a history list of completed tasks. The system should allow users to interact via a command-line interface to add tasks, process the next task, and view the current status of pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. It should have private fields for a unique `id` (integer), a `description` (String), and a `status` (String, e.g., "PENDING", "COMPLETED"). Include a constructor, appropriate getters, and a method to update the status.
 * 2.  **Task Processor Class:** Create a class named `TaskProcessor` that manages the task lifecycle.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed.
 *     *   It must use a `java.util.ArrayList<Task>` to store tasks that have been completed. This `ArrayList` instance must be assigned to a variable declared with the `java.util.List` interface type.
 *     *   Include the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and "PENDING" status, and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, changes its status to "COMPLETED", and adds it to the completed list. If the queue is empty, display an appropriate error message.
 *         *   `viewPendingTasks()`: Displays details of all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Displays details of all tasks in the completed list.
 *         *   `run()`: This method should contain the main application loop. It should prompt the user for commands and execute the corresponding actions.
 * 3.  **User Interaction:** Use `java.util.Scanner` in the `run()` method to read user commands from the console.
 * 4.  **Flow Control:** Use a `switch` statement within the `run()` method to handle different user commands (e.g., "add", "process", "view pending", "view completed", "exit").
 * 5.  **Output:** Use `System.out` for displaying menus, prompts, and the details of tasks.
 * 6.  **Error Handling:** Use `System.err` to display error messages (e.g., invalid command, no tasks to process, invalid input).
 * 7.  **Exception Handling:** Implement class-wide exception handling using a `try-catch` block around the main command processing loop within the `run()` method to catch and report any unexpected errors during execution.
 * 8.  **Best Practices:** Adhere to best practices including proper encapsulation (private fields, public methods), meaningful variable and method names, basic input validation (e.g., check for empty task description), and clear code structure with comments where necessary.
 * 
 * **Expected Output:**
 * 
 * The program should start, display a menu of available commands, and wait for user input. Based on the command, it should perform the requested action and provide feedback or display task lists. Invalid commands or operations (like processing an empty queue) should result in error messages printed to `System.err`. The program should continue until the user enters the "exit" command.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Task Processing Simulation System
 * Commands: add, process, view pending, view completed, exit
 * Enter command: add
 * Enter task description: Write exam question
 * Task added.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: add
 * Enter task description: Create solution code
 * Task added.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: view pending
 * Pending Tasks:
 * ID: 1, Description: Write exam question, Status: PENDING
 * ID: 2, Description: Create solution code, Status: PENDING
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: process
 * Processing Task ID: 1 - Write exam question... Done.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: view completed
 * Completed Tasks:
 * ID: 1, Description: Write exam question, Status: COMPLETED
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: process
 * Processing Task ID: 2 - Create solution code... Done.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: view pending
 * Pending Tasks:
 * (Queue is empty)
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: process
 * Error: No tasks in the pending queue to process.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: view completed
 * Completed Tasks:
 * ID: 1, Description: Write exam question, Status: COMPLETED
 * ID: 2, Description: Create solution code, Status: COMPLETED
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: invalid_command
 * Error: Invalid command. Please try again.
 * 
 * Commands: add, process, view pending, view completed, exit
 * Enter command: exit
 * Exiting system.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple task processing simulation system as described in the problem.
 * 
 * 1.  **`Task` Class:** Represents a single task with an ID, description, and status. It follows encapsulation principles with private fields and public getters/setters. The `toString()` method provides a convenient way to display task information.
 * 2.  **`TaskProcessor` Class:** This is the core class managing the task workflow.
 *     *   **`Queue<Task> pendingTasks = new LinkedList<>();`**: A `Queue` is used for `pendingTasks`. `LinkedList` is a common implementation of the `Queue` interface, suitable for FIFO operations (`offer` to add, `poll` to remove from the head). This directly addresses the requirement to use `java.util.Queue`.
 *     *   **`List<Task> completedTasks = new ArrayList<>();`**: An `ArrayList` is used for `completedTasks`, which is assigned to a `List` interface variable. This fulfills the requirement to use both `java.util.ArrayList` and `java.util.List`. `ArrayList` is suitable here as we primarily add to the end and iterate through the list.
 *     *   **`nextTaskId`**: A simple counter ensures unique IDs for tasks.
 *     *   **`addTask(String description)`**: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask()`**: Uses `poll()` to get and remove the task at the front of the `pendingTasks` queue. If `poll()` returns `null` (queue is empty), it prints an error using `System.err`. Otherwise, it updates the task status and adds it to the `completedTasks` list.
 *     *   **`viewPendingTasks()` / `viewCompletedTasks()`**: These methods iterate through the respective collections and print task details using `System.out`. They also handle the case where the collections are empty.
 *     *   **`run()`**: This is the main loop.
 *         *   It uses `java.util.Scanner` to read user input from the console.
 *         *   A `while(true)` loop keeps the system running until explicitly exited.
 *         *   **`try-catch(Exception e)`**: A `try-catch` block wraps the core logic *inside* the `while` loop. This provides "class-wide" exception handling for the `run` method's operational loop, catching any unexpected `Exception` that might occur during command processing (though the current logic is simple, this structure demonstrates the required pattern for robustness). Error messages from caught exceptions are printed to `System.err`.
 *         *   **`switch (command)`**: A `switch` statement is used to direct execution based on the user's input command, fulfilling the requirement for `switch` flow control.
 *         *   **`System.out` / `System.err`**: `System.out` is used for normal messages (menu, prompts, task lists) and `System.err` for error conditions (invalid command, empty queue, empty description).
 *         *   Basic input validation checks if the task description is empty before adding.
 *         *   The "exit" command closes the `Scanner` and uses `return` to exit the `run` method, terminating the program.
 * 3.  **Main Method:** The `main` method in `TaskProcessor` creates an instance of `TaskProcessor` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, simulated scenario, demonstrating understanding of data structures, object-oriented principles (encapsulation), and basic application structure with user interaction and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Class representing a single task
class Task {
    private int id;
    private String description;
    private String status; // Using String for simplicity as required

    // Constructor
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    // toString method for easy printing
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Class managing the task processing simulation
public class TaskProcessor {

    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List interface, implemented by ArrayList, for completed tasks
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    // Constructor
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head
        if (taskToProcess != null) {
            System.out.println("Processing Task ID: " + taskToProcess.getId() + " - " + taskToProcess.getDescription() + "... Done.");
            taskToProcess.setStatus("COMPLETED");
            completedTasks.add(taskToProcess);
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("(List is empty)");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main simulation loop, handling user commands.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Task Processing Simulation System");

        while (true) {
            try { // Class-wide exception handling for the command loop
                displayMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Using switch statement for command handling
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        // Basic input validation
                        if (description.isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            addTask(description);
                        }
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "view pending":
                        viewPendingTasks();
                        break;
                    case "view completed":
                        viewCompletedTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting system.");
                        scanner.close();
                        return; // Exit the run method
                    default:
                        System.err.println("Error: Invalid command. Please try again.");
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // In a real application, you might log the full stack trace:
                // e.printStackTrace();
            }
            System.out.println(); // Add a blank line for readability between commands
        }
    }

    // Helper method to display the command menu
    private void displayMenu() {
        System.out.println("Commands: add, process, view pending, view completed, exit");
    }

    // Main method to start the simulation
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
