/*
 * Exam Question #139
 * Generated on: 2025-05-11 22:20:24
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line Task Management System. This system should allow users to add tasks with different priorities, mark tasks as complete, view pending and completed tasks, and process the next highest priority task.
 * 
 * The system needs to demonstrate a strong understanding of core Java collections, input handling, error management, and object-oriented principles.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `id`: A unique integer identifier for the task.
 *     *   `description`: A string describing the task.
 *     *   `priority`: An enumeration (`Priority`) with values `HIGH`, `MEDIUM`, `LOW`.
 *     *   `status`: An enumeration (`Status`) with values `PENDING`, `COMPLETED`.
 *     *   Implement appropriate constructors, getters for all fields, and a method to mark the task as completed. Include a `toString()` method for easy printing.
 * 2.  **Task Storage:** Use the following collections within your main application class (`TaskManager`):
 *     *   A `java.util.Queue<Task>` to store tasks with `HIGH` priority. Tasks should be processed from the head of this queue.
 *     *   A `java.util.List<Task>` (using `java.util.ArrayList` implementation) to store tasks with `MEDIUM` and `LOW` priority.
 *     *   A separate `java.util.List<Task>` (using `java.util.ArrayList` implementation) to store completed tasks.
 * 3.  **User Interaction:** Implement a command-line interface using `java.util.Scanner` to provide a menu-driven experience. The menu should include options for:
 *     *   Add a new task (prompt for description and priority).
 *     *   Complete a task (prompt for task ID).
 *     *   List all pending tasks (show high priority queue and regular tasks separately).
 *     *   List all completed tasks.
 *     *   Process the next high priority task (remove from the queue, mark as completed, and move to completed tasks list).
 *     *   Exit the application.
 * 4.  **Flow Control:** Use a `switch` statement to handle the different menu options.
 * 5.  **Output:** Use `System.out` for normal messages, prompts, and listing tasks. Use `System.err` for all error messages.
 * 6.  **Exception Handling:** Implement class-wide exception handling using a `try-catch` block that wraps the main application loop or critical operational methods to catch potential unexpected errors. Also, handle specific expected errors like invalid input formats or attempting operations on empty collections/non-existent tasks.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic inline comments are acceptable for an exam).
 *     *   Implement input validation (e.g., validating priority input, handling non-integer input for IDs/choices).
 *     *   Ensure proper error handling messages are displayed via `System.err`.
 *     *   Structure your code cleanly into logical classes and methods.
 * 
 * **Expected Output Structure:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or error messages.
 * 
 * Example flow:
 * ```
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * High priority task added with ID: 1
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Regular task added with ID: 2
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * High Priority Queue:
 *   Task [ID=1, Desc='Write report', Priority=HIGH, Status=PENDING]
 * 
 * Regular Tasks:
 *   Task [ID=2, Desc='Schedule meeting', Priority=MEDIUM, Status=PENDING]
 * ---------------------
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 5
 * Processing High Priority Task: Task [ID=1, Desc='Write report', Priority=HIGH, Status=PENDING]
 * Task ID 1 moved to completed.
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 *   Task [ID=1, Desc='Write report', Priority=HIGH, Status=COMPLETED]
 * -----------------------
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 2
 * Enter ID of task to complete: 2
 * Task ID 2 marked as completed.
 * 
 * --- Task Management Menu ---
 * ... (menu options) ...
 * Enter your choice: 6
 * Exiting Task Manager. Goodbye!
 * ```
 * Error messages (e.g., invalid ID, processing empty queue) should go to `System.err`.
 * 
 * **Note:** You can implement the entire solution within a single `.java` file for simplicity in an exam setting, with the `TaskManager` class containing the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It uses private fields (`id`, `description`, `priority`, `status`) and public getter methods, adhering to encapsulation. The `Priority` and `Status` are defined as enums for type safety and readability. The `markComplete()` method demonstrates a state change within the object. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskManager Class:** This is the main class containing the application logic.
 *     *   **Collections:** It uses a `Queue<Task>` (implemented by `LinkedList`) for high-priority tasks, and two `List<Task>` interfaces implemented by `ArrayList` for regular tasks and completed tasks. This fulfills the requirement of using `Queue`, `ArrayList`, and `List` interface.
 *     *   **Encapsulation:** The collection fields (`highPriorityQueue`, `regularTasks`, `completedTasks`) and the task ID counter (`nextTaskId`) are `private`.
 *     *   **Scanner:** A `Scanner` object is used as a class member to handle user input throughout the application lifecycle, and it's properly closed in the `finally` block.
 *     *   **Methods:** Public methods like `addTask`, `completeTask`, `listPendingTasks`, `listCompletedTasks`, and `processNextHighPriorityTask` encapsulate specific operations. A private helper method `findPendingTaskById` demonstrates internal logic separation.
 *     *   **Input Validation:** The `addTask` method includes a loop with a `try-catch` block (`IllegalArgumentException`) to validate that the user enters a valid priority string corresponding to the `Priority` enum. The `completeTask` and `main` methods use `try-catch` (`NumberFormatException`) to handle cases where the user enters non-integer input when a number is expected (task ID or menu choice).
 *     *   **Error Handling (`System.err`):** `System.err` is used consistently for displaying error messages related to invalid input, tasks not found, or attempting to process an empty queue.
 *     *   **Output (`System.out`):** `System.out` is used for the menu, prompts, success messages, and listing task details.
 * 
 * 3.  **`main` Method:** The `main` method resides within the `TaskManager` class.
 *     *   **Application Loop:** It contains the main `while` loop that keeps the application running until the user chooses to exit.
 *     *   **`switch` Statement:** A `switch` statement is used to dispatch control to the appropriate `TaskManager` method based on the user's menu choice. This satisfies the `switch` requirement.
 *     *   **Class-Wide Exception Handling:** A large `try-catch(Exception e)` block wraps the entire `while` loop. This provides a top-level catch for any unexpected runtime errors that might occur during the execution of the menu options, preventing the program from crashing abruptly. The caught exception's stack trace is printed to `System.err` for debugging purposes.
 *     *   **Resource Management (`finally`):** A `finally` block is used to ensure that the `Scanner` resource is closed when the application loop terminates, whether normally or due to an unexpected exception caught by the `try-catch` block.
 * 
 * 4.  **Collection Usage Details:**
 *     *   `Queue.offer()` is used to add tasks to the high-priority queue.
 *     *   `Queue.poll()` is used to retrieve and remove the next task from the high-priority queue (returns `null` if empty, which is handled).
 *     *   `List.add()` is used to add tasks to `regularTasks` and `completedTasks`.
 *     *   `List.remove(object)` and `Queue.remove(object)` are used in `completeTask` to remove the specific task object from its pending collection after it's marked complete. While object removal can be less efficient than index removal for some collections, it's suitable here given the need to remove a specific task instance found by ID.
 *     *   Iteration over collections (`for (Task task : collection)`) is used for listing tasks and finding tasks by ID.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating crucial programming concepts like object-oriented design, collection usage, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly required by prompt, good practice to catch specific Scanner errors. NumberFormatException from Integer.parseInt is more relevant here.

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

// Task class representing a single task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     *
     * @param id          The unique ID of the task.
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markComplete() {
        this.status = Status.COMPLETED;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Priority=" + priority + ", Status=" + status + "]";
    }
}

// TaskManager class to manage the collections of tasks and user interaction
public class TaskManager {

    // --- Task Storage ---
    private Queue<Task> highPriorityQueue;
    private List<Task> regularTasks; // MEDIUM and LOW priority tasks
    private List<Task> completedTasks; // Completed tasks

    private int nextTaskId; // Counter for generating unique task IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TaskManager, initializing collections and scanner.
     */
    public TaskManager() {
        // Initialize collections
        highPriorityQueue = new LinkedList<>(); // LinkedList implements Queue
        regularTasks = new ArrayList<>();      // ArrayList implements List
        completedTasks = new ArrayList<>();    // ArrayList implements List

        nextTaskId = 1; // Start task IDs from 1
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task based on user input for description and priority.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        // Input validation loop for priority
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityStr = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityStr);
                validPriority = true; // Input is valid, exit loop
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid priority '" + priorityStr + "'. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        // Create the new task
        Task newTask = new Task(nextTaskId++, description, priority);

        // Add task to the appropriate collection based on priority
        if (priority == Priority.HIGH) {
            highPriorityQueue.offer(newTask); // offer() is preferred over add() for queues, handles capacity issues (though LinkedList is unbounded)
            System.out.println("High priority task added with ID: " + newTask.getId());
        } else {
            regularTasks.add(newTask);
            System.out.println("Regular task added with ID: " + newTask.getId());
        }
    }

    /**
     * Marks a task as completed based on its ID.
     * Prompts user for the task ID.
     */
    public void completeTask() {
        System.out.print("Enter ID of task to complete: ");
        int taskId = -1;
        try {
            // Read and parse the integer ID
            taskId = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            // Handle non-integer input
            System.err.println("Invalid input. Please enter a number for the Task ID.");
            return; // Exit the method if input is invalid
        }

        // Find the task in the pending collections
        Task taskToComplete = findPendingTaskById(taskId);

        if (taskToComplete == null) {
            // Task not found in pending lists or already completed (as findPendingTaskById only looks in pending)
            System.err.println("Task with ID " + taskId + " not found or is already completed.");
        } else {
            // Mark the task as complete
            taskToComplete.markComplete();

            // Remove the task from its original pending collection
            if (taskToComplete.getPriority() == Priority.HIGH) {
                 // Removing from Queue by object. Note: This can be O(n) for some Queue implementations.
                 highPriorityQueue.remove(taskToComplete);
            } else {
                 // Removing from List by object. This is O(n) for ArrayList.
                 regularTasks.remove(taskToComplete);
            }

            // Add the completed task to the completed tasks list
            completedTasks.add(taskToComplete);
            System.out.println("Task ID " + taskId + " marked as completed.");
        }
    }

    /**
     * Helper method to find a pending task by its ID in both high priority queue and regular tasks list.
     *
     * @param taskId The ID of the task to find.
     * @return The Task object if found and pending, otherwise null.
     */
    private Task findPendingTaskById(int taskId) {
        // Search in high priority queue
        for (Task task : highPriorityQueue) { // Iterating over a Queue is possible
            if (task.getId() == taskId) {
                return task;
            }
        }
        // Search in regular tasks list
        for (Task task : regularTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found in pending collections
    }

    /**
     * Lists all pending tasks, separating high priority from regular.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");

        System.out.println("High Priority Queue:");
        if (highPriorityQueue.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            // Iterate and print tasks in the queue without removing them
            for (Task task : highPriorityQueue) {
                System.out.println("  " + task);
            }
        }

        System.out.println("\nRegular Tasks:");
        if (regularTasks.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            // Iterate and print tasks in the list
            for (Task task : regularTasks) {
                System.out.println("  " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all completed tasks.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            // Iterate and print tasks in the list
            for (Task task : completedTasks) {
                System.out.println("  " + task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Processes the next task from the high priority queue.
     * Removes it from the queue, marks it complete, and moves it to completed tasks.
     */
    public void processNextHighPriorityTask() {
        // Retrieve and remove the head of the queue
        Task nextTask = highPriorityQueue.poll(); // poll() returns null if queue is empty

        if (nextTask == null) {
            // Handle case where queue is empty
            System.err.println("No high priority tasks in the queue to process.");
        } else {
            // Process the task (in this simulation, just mark complete and move)
            System.out.println("Processing High Priority Task: " + nextTask);
            nextTask.markComplete(); // Mark as completed
            completedTasks.add(nextTask); // Move to completed list
            System.out.println("Task ID " + nextTask.getId() + " moved to completed.");
        }
    }

    /**
     * Main method to run the Task Management System application loop.
     * Includes class-wide exception handling.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        boolean running = true;

        // --- Class-wide exception handling ---
        try {
            // Main application loop
            while (running) {
                // Display menu
                System.out.println("\n--- Task Management Menu ---");
                System.out.println("1. Add Task");
                System.out.println("2. Complete Task");
                System.out.println("3. List Pending Tasks");
                System.out.println("4. List Completed Tasks");
                System.out.println("5. Process Next High Priority Task");
                System.out.println("6. Exit");
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read and parse user's menu choice
                    choice = Integer.parseInt(manager.scanner.nextLine());
                } catch (NumberFormatException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // --- Switch statement for menu actions ---
                switch (choice) {
                    case 1:
                        manager.addTask();
                        break;
                    case 2:
                        manager.completeTask();
                        break;
                    case 3:
                        manager.listPendingTasks();
                        break;
                    case 4:
                        manager.listCompletedTasks();
                        break;
                    case 5:
                        manager.processNextHighPriorityTask();
                        break;
                    case 6:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // --- Catch any unexpected exceptions ---
            System.err.println("\nAn unexpected error occurred during application execution:");
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
             // --- Ensure scanner is closed ---
             if (manager.scanner != null) {
                 manager.scanner.close();
                 System.out.println("Scanner closed."); // Optional confirmation
             }
        }
    }
}
