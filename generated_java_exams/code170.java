/*
 * Exam Question #170
 * Generated on: 2025-05-11 22:25:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation of a server task processing system. The system manages incoming tasks and assigns them to available servers. Tasks are processed based on their arrival order.
 * 
 * Your system must handle the following operations via a command-line interface:
 * 
 * 1.  **Add New Task:** Create a new task with a user-provided description and add it to a waiting queue.
 * 2.  **Assign Task to Server:** Take the next task from the waiting queue and assign it to the first available server. If no tasks are waiting or no servers are available, report the appropriate status.
 * 3.  **Complete Task on Server:** Simulate a server completing its current task. The user must specify which server is completing the task (by server ID). If the specified server is not busy or does not exist, report an error.
 * 4.  **List All Tasks:** Display the status (Waiting, Processing, Completed) and details of all tasks currently in the system (waiting in the queue, being processed by a server, or already completed).
 * 5.  **List Server Status:** Display the status of each server (Available or Busy, including the task it is processing if busy).
 * 6.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be implemented in Java and adhere to the following specific requirements:
 * 
 * *   Use `java.util.Queue` to manage the queue of waiting tasks.
 * *   Use `java.util.ArrayList` to store and manage the collection of servers.
 * *   Use `java.util.List` interface type when declaring the collection of servers (`List<Server> servers = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the different user commands.
 * *   Use `System.err.println()` for displaying error messages (e.g., invalid input, server not found, no available servers, no waiting tasks).
 * *   Use `System.out.println()` for displaying normal output (menu, task status, server status, confirmations).
 * *   Implement class-wide exception handling using a `try-catch` block in the main execution loop to catch potential runtime errors during user interaction or system operations.
 * 
 * **Design and Best Practices:**
 * 
 * *   Create separate classes for `Task` and `Server`.
 * *   Create a main class (e.g., `TaskProcessingSystem`) to manage the queue, servers, and user interaction.
 * *   Use private fields and public methods for proper encapsulation.
 * *   Use meaningful variable and method names.
 * *   Include basic input validation (e.g., for numeric input like server ID).
 * *   Add appropriate comments and documentation (e.g., Javadoc).
 * *   Maintain a clean code structure.
 * 
 * **Task and Server Details:**
 * 
 * *   **Task:** Should have an `id` (integer, automatically generated starting from 1), a `description` (String), and a `status` (enum: `WAITING`, `PROCESSING`, `COMPLETED`).
 * *   **Server:** Should have an `id` (integer, automatically assigned starting from 1), and a reference to the `Task` it is currently processing (can be `null` if available).
 * 
 * **Initial State:**
 * 
 * The system should start with a predefined number of servers (e.g., 3). The waiting queue should be empty.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu of options to the user, accept commands, and provide feedback based on the operations performed, using `System.out` for success/status and `System.err` for errors.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Assign Task to Server
 * 3. Complete Task on Server
 * 4. List All Tasks
 * 5. List Server Status
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Process user request
 * Task 1 "Process user request" added to queue.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 2
 * Task 1 "Process user request" assigned to Server 1.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 5
 * Server 1: Busy (Task 1: Process user request - PROCESSING)
 * Server 2: Available
 * Server 3: Available
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 3
 * Enter Server ID to complete task: 1
 * Server 1 completed Task 1.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 4
 * --- All Tasks ---
 * Task 1: Process user request - COMPLETED
 * --- Waiting Tasks ---
 * (None)
 * --- Processing Tasks ---
 * (None)
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simplified server task processing system demonstrating the required Java concepts.
 * 
 * 1.  **Structure:** The solution is organized into three classes: `Task`, `Server`, and `TaskProcessingSystem`. This follows good object-oriented design principles by separating concerns.
 *     *   `Task`: Encapsulates task data (ID, description, status). Uses an `enum` (`TaskStatus`) for clear status representation.
 *     *   `Server`: Encapsulates server data (ID, current task). Includes methods to check availability (`isBusy`), assign a task, and complete a task.
 *     *   `TaskProcessingSystem`: Acts as the controller, managing the collections of tasks and servers and handling user interaction.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue (java.util.Queue)`: The `waitingTasks` field is declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a concrete class that implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a waiting queue. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove the next task.
 *     *   `ArrayList (java.util.ArrayList)`: The `servers` field is initialized with `new ArrayList<>()`. `ArrayList` is used to store the server objects, allowing easy iteration and access by index or searching by ID. The `completedTasks` list also uses `ArrayList`.
 *     *   `List interface (java.util.List)`: The `servers` field is declared using the `List` interface type (`List<Server> servers`), promoting good practice by programming to the interface rather than the concrete implementation (`ArrayList`).
 *     *   `Scanner (java.util.Scanner)`: A `Scanner` object is used in the `TaskProcessingSystem` to read user input (integers for menu choices and server IDs, strings for task descriptions) from `System.in`.
 *     *   `Switch statement`: The `startSystem()` method uses a `switch` statement to handle the user's menu choice, directing execution to the appropriate private method (`addTask`, `assignTaskToServer`, etc.).
 *     *   `System.err`: Used in the `startSystem()` method's `catch` block for general errors and in specific methods (e.g., `completeTaskOnServer`, `addTask`) for reporting invalid input or operational failures (e.g., server not found, empty description).
 *     *   `System.out`: Used extensively for displaying the menu, confirmations, task details, and server status.
 *     *   `Class-wide exception handling (try-catch)`: The main `while` loop in the `startSystem()` method is wrapped in a `try-catch` block. This block catches potential `InputMismatchException` from `Scanner` (when the user enters non-numeric input where a number is expected) and any other unexpected `Exception` that might propagate up, providing a central point for error reporting and preventing the program from crashing abruptly. A nested `try-catch` specifically for `InputMismatchException` is used inside the loop to handle invalid numerical input gracefully without exiting the main loop.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Private fields (`id`, `description`, `status` in `Task`; `id`, `currentTask` in `Server`; collections, scanner, counters in `TaskProcessingSystem`) are accessed and modified only through public methods (getters, setters, specific action methods like `assignTask`, `completeCurrentTask`).
 *     *   **Meaningful Names:** Class names (`Task`, `Server`, `TaskProcessingSystem`), variable names (`waitingTasks`, `servers`, `nextTaskId`, `currentTask`), and method names (`addTask`, `assignTaskToServer`, `listServerStatus`) are descriptive.
 *     *   **Comments and Documentation:** Basic comments explain the purpose of classes and methods. Javadoc-style comments could be added for more formal documentation.
 *     *   **Input Validation:** Checks are included for empty task descriptions and for the existence of a server ID entered by the user. The `try-catch` for `InputMismatchException` handles incorrect input types.
 *     *   **Error Handling:** Specific error conditions (no waiting tasks, no available servers, server not found, server not busy) are checked, and informative messages are printed to `System.out` or `System.err`. The main `try-catch` provides a fallback for unexpected errors.
 *     *   **Clean Code:** Methods are kept relatively short and focused on a single task. The main loop clearly separates input reading, choice handling, and method calls. Resource management (closing the `Scanner`) is handled in a `finally` block.
 * 
 * 4.  **Logic Flow:**
 *     *   The system is initialized with a set number of servers.
 *     *   The `startSystem` method enters a loop displaying the menu.
 *     *   User input is read. `InputMismatchException` is handled if the input is not an integer.
 *     *   A `switch` statement processes the valid integer choice.
 *     *   `addTask`: Creates a new `Task` with a unique ID and description, sets its status to `WAITING`, and adds it to the `waitingTasks` queue.
 *     *   `assignTaskToServer`: Checks if the queue is empty and if any server is available. If both conditions are met, it polls the next task from the queue, finds the first available server, assigns the task to the server, and updates the task's status to `PROCESSING`.
 *     *   `completeTaskOnServer`: Prompts for a server ID, finds the server, checks if it's busy, completes the task on the server, updates the task's status to `COMPLETED`, and adds it to the `completedTasks` list.
 *     *   `listAllTasks`: Iterates through the `completedTasks` list, then the tasks currently held by servers, and finally the tasks in the `waitingTasks` queue (using an enhanced for loop which iterates without removing elements from the queue) to display their details and status.
 *     *   `listServerStatus`: Iterates through the `servers` list and prints the status of each server.
 *     *   `Exit`: Breaks the main loop, the `finally` block closes the scanner, and the program terminates.
 * 
 * This solution effectively combines the required Java components within a practical, albeit simplified, simulation scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    WAITING,
    PROCESSING,
    COMPLETED
}

// Class representing a Task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.WAITING; // New tasks start as WAITING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task " + id + ": " + description + " - " + status;
    }
}

// Class representing a Server
class Server {
    private int id;
    private Task currentTask;

    public Server(int id) {
        this.id = id;
        this.currentTask = null; // Server is initially available
    }

    // Getters
    public int getId() {
        return id;
    }

    public Task getCurrentTask() {
        return currentTask;
    }

    // Check if server is busy
    public boolean isBusy() {
        return currentTask != null;
    }

    // Assign a task to the server
    public void assignTask(Task task) {
        if (!isBusy()) {
            this.currentTask = task;
            // Task status is updated in TaskProcessingSystem after assignment
        } else {
            // In a real system, this would throw an exception or return false
            // For this simulation, we assume assignTask is only called on available servers
            System.err.println("Error: Server " + id + " is already busy.");
        }
    }

    // Complete the current task
    public Task completeCurrentTask() {
        Task completed = this.currentTask;
        if (completed != null) {
            this.currentTask = null; // Make server available
            // Task status is updated in TaskProcessingSystem after completion
        }
        return completed; // Return the completed task
    }

    @Override
    public String toString() {
        if (isBusy()) {
            return "Server " + id + ": Busy (" + currentTask.toString() + ")";
        } else {
            return "Server " + id + ": Available";
        }
    }
}

// Main class managing the system
public class TaskProcessingSystem {

    private Queue<Task> waitingTasks;
    private List<Server> servers;
    private List<Task> completedTasks; // To keep track of completed tasks for listing
    private Scanner scanner;
    private int nextTaskId;
    private int numberOfServers;

    // Constructor
    public TaskProcessingSystem(int numberOfServers) {
        this.numberOfServers = numberOfServers;
        this.waitingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.servers = new ArrayList<>(); // ArrayList implements List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1;

        // Initialize servers
        for (int i = 1; i <= numberOfServers; i++) {
            servers.add(new Server(i));
        }
    }

    // Display the menu
    private void displayMenu() {
        System.out.println("\n--- Task Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Assign Task to Server");
        System.out.println("3. Complete Task on Server");
        System.out.println("4. List All Tasks");
        System.out.println("5. List Server Status");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Add a new task to the queue
    private void addTask() {
        System.out.print("Enter task description: ");
        scanner.nextLine(); // Consume newline left-over from previous nextInt()
        String description = scanner.nextLine();
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        waitingTasks.offer(newTask); // Add to the end of the queue
        System.out.println("Task " + newTask.getId() + " \"" + newTask.getDescription() + "\" added to queue.");
    }

    // Assign a task from the queue to an available server
    private void assignTaskToServer() {
        if (waitingTasks.isEmpty()) {
            System.out.println("No tasks waiting in the queue.");
            return;
        }

        Server availableServer = null;
        for (Server server : servers) {
            if (!server.isBusy()) {
                availableServer = server;
                break; // Found an available server
            }
        }

        if (availableServer == null) {
            System.out.println("No servers are currently available.");
            return;
        }

        // Get the next task from the queue (and remove it)
        Task taskToAssign = waitingTasks.poll();

        // Assign the task to the server
        availableServer.assignTask(taskToAssign);
        taskToAssign.setStatus(TaskStatus.PROCESSING); // Update task status

        System.out.println("Task " + taskToAssign.getId() + " \"" + taskToAssign.getDescription() + "\" assigned to Server " + availableServer.getId() + ".");
    }

    // Simulate completing a task on a specific server
    private void completeTaskOnServer() {
        System.out.print("Enter Server ID to complete task: ");
        int serverId = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        Server targetServer = null;
        for (Server server : servers) {
            if (server.getId() == serverId) {
                targetServer = server;
                break;
            }
        }

        if (targetServer == null) {
            System.err.println("Error: Server with ID " + serverId + " not found.");
            return;
        }

        if (!targetServer.isBusy()) {
            System.out.println("Server " + serverId + " is not currently busy.");
            return;
        }

        // Complete the task and get the completed task object
        Task completedTask = targetServer.completeCurrentTask();
        completedTask.setStatus(TaskStatus.COMPLETED); // Update task status
        completedTasks.add(completedTask); // Add to the completed tasks list

        System.out.println("Server " + serverId + " completed Task " + completedTask.getId() + ".");
    }

    // List all tasks (waiting, processing, completed)
    private void listAllTasks() {
        System.out.println("\n--- All Tasks ---");

        // List completed tasks first
        if (!completedTasks.isEmpty()) {
             System.out.println("--- Completed Tasks ---");
             for (Task task : completedTasks) {
                 System.out.println(task);
             }
        } else {
             System.out.println("--- Completed Tasks ---");
             System.out.println("(None)");
        }


        // List tasks currently being processed
        System.out.println("--- Processing Tasks ---");
        boolean processingFound = false;
        for (Server server : servers) {
            if (server.isBusy()) {
                System.out.println(server.getCurrentTask());
                processingFound = true;
            }
        }
        if (!processingFound) {
            System.out.println("(None)");
        }

        // List tasks waiting in the queue
        System.out.println("--- Waiting Tasks ---");
        if (!waitingTasks.isEmpty()) {
            // Iterate through the queue without removing elements
            for (Task task : waitingTasks) {
                System.out.println(task);
            }
        } else {
            System.out.println("(None)");
        }
    }

    // List the status of all servers
    private void listServerStatus() {
        System.out.println("\n--- Server Status ---");
        for (Server server : servers) {
            System.out.println(server);
        }
    }

    // Main method to start the system loop
    public void startSystem() {
        int choice = -1;

        // Class-wide exception handling for the main loop
        try {
            while (choice != 6) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    // Handle the rest of the line after reading the integer
                    // (scanner.nextLine() is called inside methods that need it)
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number between 1 and 6.");
                    scanner.nextLine(); // Consume the invalid input line
                    choice = -1; // Reset choice to prevent unintended action
                    continue; // Skip the switch statement and show menu again
                }

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        assignTaskToServer();
                        break;
                    case 3:
                        completeTaskOnServer();
                        break;
                    case 4:
                        listAllTasks();
                        break;
                    case 5:
                        listServerStatus();
                        break;
                    case 6:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Main method to run the application
    public static void main(String[] args) {
        // You can change the number of servers here
        TaskProcessingSystem system = new TaskProcessingSystem(3);
        system.startSystem();
    }
}
