/*
 * Exam Question #242
 * Generated on: 2025-05-11 22:38:05
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Office Print Queue Management System
 * 
 * **Objective:** Design and implement a simple command-line application to simulate a print queue management system for a small office. The system should allow users to add print jobs, process the next job in the queue, view the current queue, and view completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a `PrintJob` class to represent a single print job. It should have private fields for `jobId` (an integer, unique identifier), `fileName` (a String), and `numberOfPages` (an integer). Include a constructor and appropriate public getter methods. Override the `toString()` method to provide a user-friendly string representation of a print job.
 *     *   Create a `PrintQueueManager` class to manage the print queue and completed jobs. It should have private fields: a `Queue` to hold waiting jobs and a `List` to hold completed jobs. Use the `Queue` interface type instantiated with a suitable concrete class (like `LinkedList`) and the `List` interface type instantiated with `ArrayList`.
 *     *   Implement the following public methods in `PrintQueueManager`:
 *         *   `addJob(String fileName, int numberOfPages)`: Creates a new `PrintJob` with a unique ID and adds it to the print queue. Perform basic validation: file name should not be empty, and number of pages must be greater than 0. Print success or error messages using `System.out` or `System.err` accordingly.
 *         *   `processNextJob()`: Removes the next job from the queue, adds it to the completed jobs list, and simulates "printing" it. If the queue is empty, report an error using `System.err`. Otherwise, report the completed job using `System.out`. Return the processed `PrintJob` or `null` if the queue was empty.
 *         *   `viewQueue()`: Prints the details of all jobs currently in the queue to `System.out`. If the queue is empty, report that the queue is empty.
 *         *   `viewCompletedJobs()`: Prints the details of all completed jobs to `System.out`. If no jobs are completed, report that.
 *     *   Create a main class (e.g., `PrintQueueSystem`) with a `main` method to run the application.
 * 
 * 2.  **Main Application Logic (`PrintQueueSystem`):**
 *     *   Use a `Scanner` object to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Print Queue
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement the logic for each menu option by calling the appropriate methods of the `PrintQueueManager`.
 *     *   The application should loop until the user chooses to exit.
 * 
 * 3.  **Error Handling & Validation:**
 *     *   Use `Scanner` to read different input types (String, int).
 *     *   Implement input validation for adding a job (file name not empty, pages > 0). Report validation errors using `System.err`.
 *     *   Use `try-catch` blocks to handle potential input errors when reading integers (e.g., `InputMismatchException`). Report these errors using `System.err` and prevent the program from crashing or processing invalid data.
 *     *   Include a general `try-catch` block around the main application loop to catch any unexpected runtime exceptions and print an error message to `System.err` before exiting.
 *     *   Handle the case where the user tries to process a job when the queue is empty, reporting the error via `System.err`.
 * 
 * 4.  **Java Components Usage:** Ensure your solution explicitly uses:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as the type for completed jobs)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks for exception handling.
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`) for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts of the code.
 *     *   Include basic Javadoc comments for classes and methods.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The application should interact with the user via the console. Example interactions might look like:
 * 
 * ```
 * Print Queue Management System
 * -----------------------------
 * Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job added: [ID: 1] report.pdf (15 pages)
 * 
 * Menu:
 * 1. Add New Print Job
 * ...
 * Enter your choice: 1
 * Enter file name: presentation.pptx
 * Enter number of pages: 30
 * Job added: [ID: 2] presentation.pptx (30 pages)
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Current Print Queue ---
 * [ID: 1] report.pdf (15 pages)
 * [ID: 2] presentation.pptx (30 pages)
 * ---------------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Processing job: [ID: 1] report.pdf (15 pages)
 * Job [ID: 1] completed.
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Current Print Queue ---
 * [ID: 2] presentation.pptx (30 pages)
 * ---------------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * [ID: 1] report.pdf (15 pages)
 * ----------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Processing job: [ID: 2] presentation.pptx (30 pages)
 * Job [ID: 2] completed.
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Error: Print queue is empty. No jobs to process.
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * [ID: 1] report.pdf (15 pages)
 * [ID: 2] presentation.pptx (30 pages)
 * ----------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Menu:
 * ...
 * Enter your choice: 1
 * Enter file name: document.docx
 * Enter number of pages: abc
 * Error: Invalid input. Please enter a valid integer for the number of pages.
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * Exiting Print Queue Management System. Goodbye!
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Print Queue Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:** A basic Plain Old Java Object (POJO) representing a print job with private fields (`jobId`, `fileName`, `numberOfPages`), a constructor, public getters for encapsulation, and an overridden `toString()` method for easy printing.
 * 
 * 2.  **`PrintQueueManager` Class:** This class encapsulates the core logic for managing the print jobs.
 *     *   It uses a `Queue<PrintJob>` named `printQueue`, instantiated with `LinkedList`. The `Queue` interface is suitable here because print jobs are processed in a First-In, First-Out (FIFO) manner. Methods like `offer()` (add) and `poll()` (retrieve and remove head) are used.
 *     *   It uses a `List<PrintJob>` named `completedJobs`, instantiated with `ArrayList`. The `List` interface is appropriate for storing completed jobs, allowing sequential access and easy iteration.
 *     *   `addJob()` performs basic input validation on `fileName` and `numberOfPages` before creating a `PrintJob` and adding it to the queue using `offer()`. It uses `System.err` for validation errors and `System.out` for success messages.
 *     *   `processNextJob()` uses `poll()` to get the next job from the queue. It checks if the queue is empty and reports an error using `System.err` if it is. If a job is retrieved, it's added to the `completedJobs` list.
 *     *   `viewQueue()` and `viewCompletedJobs()` iterate through their respective collections (using enhanced for loops, which implicitly use iterators) and print job details to `System.out`. They also handle and report empty lists/queues.
 *     *   A simple `nextJobId` counter is used to ensure unique IDs for each job.
 * 
 * 3.  **`PrintQueueSystem` Class (Main Application):**
 *     *   The `main` method drives the application.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `displayMenu()` method shows the options.
 *     *   A `switch` statement handles the user's integer choice, directing execution to the appropriate logic block.
 *     *   **Exception Handling (`try-catch`):**
 *         *   A `try-catch(InputMismatchException)` block is used specifically when reading the menu choice and the number of pages. This catches cases where the user enters non-integer input when an integer is expected. `System.err` is used to report the error, and `scanner.next()` or `scanner.nextLine()` is called to consume the invalid input, preventing an infinite loop.
 *         *   A general `try-catch(Exception e)` block wraps the main `while` loop. This serves as a "class-wide" or application-level catch-all for any unexpected runtime exceptions that might occur during execution, printing an error to `System.err` and the stack trace for debugging.
 *     *   **`System.err` and `System.out`:** Used throughout the application as required for error messages and standard output respectively.
 *     *   **`Scanner` Closing:** A `finally` block ensures that the `scanner` object is closed when the main `try` block is exited (either normally or due to an exception), releasing system resources.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `PrintJob` and `PrintQueueManager` are `private`, accessed via public methods where necessary.
 *     *   **Naming:** Variables (`printQueue`, `completedJobs`, `fileName`, `numberOfPages`), methods (`addJob`, `processNextJob`, `viewQueue`), and classes (`PrintJob`, `PrintQueueManager`, `PrintQueueSystem`) have clear, descriptive names.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments explain specific logic points (e.g., validation, `offer` vs `add`, `poll`).
 *     *   **Input Validation:** Explicit checks are made for empty file names and non-positive page counts in `addJob`.
 *     *   **Error Handling:** Specific input errors are caught, and the empty queue condition is handled gracefully. A general catch block provides robustness against unexpected issues.
 *     *   **Structure:** The code is organized into logical classes, making it modular and easier to understand.
 * 
 * This solution effectively integrates all required Java components within a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with ID, file name, and number of pages.
 */
class PrintJob {
    private int jobId;
    private String fileName;
    private int numberOfPages;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param numberOfPages The number of pages in the file.
     */
    public PrintJob(int jobId, String fileName, int numberOfPages) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.numberOfPages = numberOfPages;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getNumberOfPages() {
        return numberOfPages;
    }

    /**
     * Provides a string representation of the print job.
     * @return Formatted string details of the print job.
     */
    @Override
    public String toString() {
        return "[ID: " + jobId + "] " + fileName + " (" + numberOfPages + " pages)";
    }
}

/**
 * Manages the print queue and keeps track of completed jobs.
 */
class PrintQueueManager {
    private Queue<PrintJob> printQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId; // To generate unique job IDs

    /**
     * Constructs a new PrintQueueManager.
     * Initializes the queue and completed jobs list.
     */
    public PrintQueueManager() {
        this.printQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedJobs = new ArrayList<>(); // ArrayList for completed jobs list
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the queue after validation.
     * @param fileName The name of the file.
     * @param numberOfPages The number of pages.
     */
    public void addJob(String fileName, int numberOfPages) {
        // --- Input Validation ---
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }
        if (numberOfPages <= 0) {
            System.err.println("Error: Number of pages must be greater than 0.");
            return;
        }

        // --- Create and Add Job ---
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim(), numberOfPages);
        printQueue.offer(newJob); // offer() is preferred over add() in queues as it doesn't throw exception on capacity limits (though LinkedList is unbounded)
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the queue.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        if (printQueue.isEmpty()) {
            System.err.println("Error: Print queue is empty. No jobs to process.");
            return null;
        }

        // --- Process Job ---
        PrintJob jobToProcess = printQueue.poll(); // poll() retrieves and removes the head of the queue
        if (jobToProcess != null) {
            System.out.println("Processing job: " + jobToProcess);
            // Simulate printing...
            completedJobs.add(jobToProcess);
            System.out.println("Job [ID: " + jobToProcess.getJobId() + "] completed.");
        }
        return jobToProcess; // Return the job that was processed
    }

    /**
     * Prints the details of all jobs currently waiting in the queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PrintJob job : printQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Prints the details of all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs completed yet.");
        } else {
            // Iterate through the completed jobs list
            int index = 1;
            for (PrintJob job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("----------------------");
    }
}

/**
 * Main application class for the Print Queue Management System.
 * Handles user interaction and menu navigation.
 */
public class PrintQueueSystem {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\nPrint Queue Management System");
        System.out.println("-----------------------------");
        System.out.println("Menu:");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Print Queue Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintQueueManager manager = new PrintQueueManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // --- Class-wide Exception Handling ---
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                // --- Input Handling with try-catch for menu choice ---
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    // Consume the newline character left by nextInt()
                    // This is important before reading String input later
                    if (scanner.hasNextLine()) { // Check if there's a line to consume
                         scanner.nextLine();
                    }
                }


                // --- Menu Navigation using switch ---
                switch (choice) {
                    case 1: // Add New Print Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();

                        System.out.print("Enter number of pages: ");
                        int numberOfPages = -1;
                        // --- Input Handling with try-catch for number of pages ---
                        try {
                            numberOfPages = scanner.nextInt();
                            // Consume the newline character after nextInt()
                            scanner.nextLine(); // Added here specifically after reading pages

                            manager.addJob(fileName, numberOfPages);

                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a valid integer for the number of pages.");
                            scanner.next(); // Consume the invalid input
                            // No job is added if input is invalid
                        } catch (Exception e) {
                             // Catch any other unexpected exceptions during job addition
                             System.err.println("An unexpected error occurred while adding the job: " + e.getMessage());
                             e.printStackTrace(); // Print stack trace for debugging
                        }
                        break;

                    case 2: // Process Next Job
                        manager.processNextJob();
                        break;

                    case 3: // View Print Queue
                        manager.viewQueue();
                        break;

                    case 4: // View Completed Jobs
                        manager.viewCompletedJobs();
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Print Queue Management System. Goodbye!");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // --- Catch any unexpected exceptions outside the specific input handling ---
            System.err.println("\nAn unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // --- Ensure Scanner is closed ---
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}
