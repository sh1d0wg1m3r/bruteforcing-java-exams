/*
 * Exam Question #262
 * Generated on: 2025-05-11 22:46:24
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam: Warehouse Inventory & Order Fulfillment System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified warehouse management system. This system should manage a list of inventory items and process customer orders on a first-in, first-out basis. The system must be interactive, allowing a user (simulating a warehouse operator) to perform various actions via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Inventory Management:**
 *     *   Maintain a list of `Item` objects. Each `Item` should have a unique integer ID, a String name, and an integer quantity representing the current stock level.
 *     *   Allow adding initial items to the inventory (can be hardcoded or read from input initially).
 *     *   Allow receiving new stock for an existing item (update quantity).
 * 
 * 2.  **Order Management:**
 *     *   Maintain a queue of `Order` objects. Each `Order` should have a unique integer ID, the ID of the item being ordered, and the integer quantity requested.
 *     *   Allow placing new orders (add to the queue).
 *     *   Process the next order in the queue. An order can only be fully processed if the required item quantity is available in the inventory. If successful, the item's stock is reduced, and the order is removed from the queue. If insufficient stock, the order remains in the queue, and an error message is displayed.
 * 
 * 3.  **User Interface:**
 *     *   Provide a menu-driven interface using `Scanner` for user input.
 *     *   Use a `switch` statement to handle different menu options.
 *     *   Display information (inventory list, pending orders, success messages) using `System.out`.
 *     *   Display error messages (e.g., invalid input, item not found, insufficient stock) using `System.err`.
 * 
 * 4.  **Data Structures & Components:**
 *     *   Use `java.util.Queue` for managing pending orders.
 *     *   Use `java.util.ArrayList` for managing inventory items.
 *     *   Declare your inventory list using the `java.util.List` interface type.
 *     *   Use `java.util.Scanner` for reading user input from the console.
 *     *   Use a `switch` statement for processing menu choices.
 *     *   Use `System.err` for all error output.
 *     *   Use `System.out` for all standard output.
 *     *   Implement class-wide exception handling using `try-catch` blocks to manage potential issues like invalid user input (e.g., non-integer input when expecting an integer) or logical errors (e.g., attempting to process an order for a non-existent item).
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation for `Item` and `Order` classes (private fields, public getters/setters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform input validation where necessary (e.g., checking for positive quantities, ensuring item IDs exist).
 *     *   Handle errors gracefully and inform the user via `System.err`.
 *     *   Structure your code cleanly (e.g., separate methods for different operations).
 * 
 * **Menu Options:**
 * 
 * 1.  View Inventory
 * 2.  Receive Stock
 * 3.  Place Order
 * 4.  Process Next Order
 * 5.  View Pending Orders
 * 6.  Exit
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Warehouse Management Menu ---
 * 1. View Inventory
 * 2. Receive Stock
 * 3. Place Order
 * 4. Process Next Order
 * 5. View Pending Orders
 * 6. Exit
 * Enter your choice: 1
 * Current Inventory:
 * ID: 101, Name: Laptop, Quantity: 5
 * ID: 102, Name: Mouse, Quantity: 20
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter item ID for order: 101
 * Enter quantity for order: 2
 * Order placed: OrderID=1, ItemID=101, Quantity=2
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing OrderID: 1
 * Checking stock for ItemID 101, requested quantity 2...
 * Stock available. Fulfilling order.
 * Stock updated for ItemID 101. New quantity: 3
 * Order 1 fulfilled successfully.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing OrderID: 2
 * Checking stock for ItemID 102, requested quantity 30...
 * Insufficient stock for ItemID 102. Requested: 30, Available: 20
 * Order 2 could not be fulfilled and remains in the queue.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 5
 * Pending Orders:
 * OrderID: 2, ItemID: 102, Quantity: 30
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Warehouse Management System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accuracy and completeness of the warehouse logic (inventory updates, order processing).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Robustness in handling invalid user input and edge cases (e.g., processing an empty queue, requesting negative quantity).
 * *   Clarity and structure of the code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * The provided solution implements a simplified Warehouse Inventory and Order Fulfillment System, demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Implementation:**
 * 
 * 1.  **`Item` Class:**
 *     *   A simple Plain Old Java Object (POJO) representing an inventory item with `id`, `name`, and `quantity`.
 *     *   Fields are `private` adhering to encapsulation.
 *     *   `public` getters are provided.
 *     *   A `setQuantity` method allows modifying the stock level.
 *     *   `toString()` is overridden for easy printing.
 * 
 * 2.  **`Order` Class:**
 *     *   A POJO representing a customer order with a unique `orderId`, the `itemId` being ordered, and the requested `quantity`.
 *     *   A `static` counter `nextOrderId` ensures each new order gets a unique ID.
 *     *   Fields are `private` with `public` getters.
 *     *   `toString()` is overridden for easy printing.
 * 
 * 3.  **`WarehouseManager` Class:**
 *     *   This is the main class containing the application logic.
 *     *   **`List<Item> inventory = new ArrayList<>();`**: Demonstrates using the `List` interface type while using `ArrayList` as the concrete implementation for flexible, index-based storage and retrieval of inventory items.
 *     *   **`Queue<Order> pendingOrders = new LinkedList<>();`**: Demonstrates using the `Queue` interface type with `LinkedList` as the implementation. `LinkedList` is a common choice for implementing `Queue` in Java, providing efficient FIFO operations (`offer`, `peek`, `poll`).
 *     *   **`Scanner scanner = new Scanner(System.in);`**: Used to read user input from the standard input stream (`System.in`).
 *     *   **`switch (choice)`**: The `run()` method uses a `switch` statement to direct the program flow based on the user's menu selection.
 *     *   **`System.out`**: Used extensively in methods like `displayMenu()`, `viewInventory()`, `viewPendingOrders()`, and for success messages in `receiveStock()`, `placeOrder()`, and `processNextOrder()`.
 *     *   **`System.err`**: Used specifically for printing error messages, such as invalid input, item not found, insufficient stock, or other unexpected issues in `receiveStock()`, `placeOrder()`, `processNextOrder()`, and the main `run()` loop. This distinguishes error output from normal program output.
 *     *   **`try-catch` Blocks**:
 *         *   The `run()` method has an outer `try-catch` block to catch broad exceptions that might occur during the main loop or menu processing (specifically `InputMismatchException` for non-integer input in the main menu).
 *         *   Specific methods like `receiveStock()`, `placeOrder()`, and `processNextOrder()` have their own `try-catch` blocks to handle exceptions specific to their operations, such as `InputMismatchException` when reading quantities or item IDs, and general `Exception` for other potential issues during complex logic. Error messages are printed to `System.err`, and stack traces are also printed to `System.err` for debugging unexpected errors.
 *     *   **Methods for Operations:** Separate `private` methods (`displayMenu`, `findItemById`, `viewInventory`, `receiveStock`, `placeOrder`, `processNextOrder`, `viewPendingOrders`) encapsulate the logic for each specific task, improving code organization and readability.
 *     *   **Input Validation:** Checks are included to ensure quantities are positive in `receiveStock()` and `placeOrder()`. The `findItemById()` method is used to validate if an item exists before attempting to receive stock or process an order for it. `InputMismatchException` handling specifically addresses non-integer input issues from the `Scanner`.
 *     *   **Order Processing Logic (`processNextOrder`)**:
 *         *   Uses `pendingOrders.peek()` to look at the next order without removing it.
 *         *   Finds the corresponding `Item` in the `inventory`.
 *         *   Checks if sufficient stock (`item.getQuantity() >= nextOrder.getQuantity()`).
 *         *   If sufficient, updates the item quantity (`item.setQuantity(...)`) and removes the order using `pendingOrders.poll()`.
 *         *   If insufficient, prints an error to `System.err` and the order remains in the queue.
 *         *   Handles cases where the item ID in the order does not exist in the inventory.
 *     *   **`main` Method:** Creates an instance of `WarehouseManager` and calls its `run()` method to start the application loop.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block within the `run()` method to release system resources.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Private fields and public methods in `Item` and `Order`.
 * *   **Meaningful Names:** Variables (`inventory`, `pendingOrders`, `itemId`, `quantity`), methods (`viewInventory`, `processNextOrder`), and classes (`Item`, `Order`, `WarehouseManager`) have clear, descriptive names.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic.
 * *   **Input Validation:** Checks for positive quantities and existence of items.
 * *   **Error Handling:** Use of `try-catch` for anticipated (InputMismatchException) and unanticipated exceptions, printing errors to `System.err`. Specific error messages guide the user.
 * *   **Clean Code Structure:** Logic is broken down into small, focused methods. The main loop is simple, delegating work to these methods.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating an understanding of data structures, control flow, input/output, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an item in the warehouse inventory.
 */
class Item {
    private int id;
    private String name;
    private int quantity;

    /**
     * Constructs a new Item.
     * @param id The unique ID of the item.
     * @param name The name of the item.
     * @param quantity The initial stock quantity.
     */
    public Item(int id, String name, int quantity) {
        this.id = id;
        this.name = name;
        this.quantity = quantity;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    // Setter for quantity (used when receiving stock or processing orders)
    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Quantity: " + quantity;
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs

    private int orderId;
    private int itemId;
    private int quantity;

    /**
     * Constructs a new Order.
     * @param itemId The ID of the item being ordered.
     * @param quantity The quantity of the item requested.
     */
    public Order(int itemId, int quantity) {
        this.orderId = nextOrderId++;
        this.itemId = itemId;
        this.quantity = quantity;
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public int getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "OrderID: " + orderId + ", ItemID: " + itemId + ", Quantity: " + quantity;
    }
}

/**
 * Manages the warehouse inventory and order processing.
 */
public class WarehouseManager {

    // Inventory stored as a List of Items (using ArrayList implementation)
    private List<Item> inventory;

    // Pending orders stored as a Queue of Orders (using LinkedList implementation)
    private Queue<Order> pendingOrders;

    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a WarehouseManager with initial inventory.
     */
    public WarehouseManager() {
        // Use List interface type for inventory
        inventory = new ArrayList<>();
        // Use Queue interface type for orders
        pendingOrders = new LinkedList<>(); // LinkedList implements both List and Queue

        scanner = new Scanner(System.in);

        // Initialize with some sample items
        inventory.add(new Item(101, "Laptop", 10));
        inventory.add(new Item(102, "Mouse", 50));
        inventory.add(new Item(103, "Keyboard", 30));
        System.out.println("Warehouse system initialized with sample inventory.");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse Management Menu ---");
        System.out.println("1. View Inventory");
        System.out.println("2. Receive Stock");
        System.out.println("3. Place Order");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Finds an item in the inventory by its ID.
     * @param itemId The ID of the item to find.
     * @return The Item object if found, null otherwise.
     */
    private Item findItemById(int itemId) {
        for (Item item : inventory) {
            if (item.getId() == itemId) {
                return item;
            }
        }
        return null;
    }

    /**
     * Handles the "View Inventory" operation.
     */
    private void viewInventory() {
        System.out.println("\nCurrent Inventory:");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Item item : inventory) {
                System.out.println(item);
            }
        }
    }

    /**
     * Handles the "Receive Stock" operation.
     * Prompts user for item ID and quantity.
     */
    private void receiveStock() {
        System.out.println("\n--- Receive Stock ---");
        int itemId = -1;
        int quantity = -1;

        try {
            System.out.print("Enter item ID to receive stock: ");
            itemId = scanner.nextInt();

            System.out.print("Enter quantity to add: ");
            quantity = scanner.nextInt();

            // Consume the newline character left by nextInt()
            scanner.nextLine();

            if (quantity <= 0) {
                System.err.println("Error: Quantity must be positive.");
                return;
            }

            Item item = findItemById(itemId);

            if (item != null) {
                item.setQuantity(item.getQuantity() + quantity);
                System.out.println("Stock updated for ItemID " + itemId + ". New quantity: " + item.getQuantity());
            } else {
                System.err.println("Error: Item with ID " + itemId + " not found.");
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter integers for ID and quantity.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
            // Catch any other unexpected exceptions during this operation
            System.err.println("An unexpected error occurred during stock reception: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        }
    }

    /**
     * Handles the "Place Order" operation.
     * Prompts user for item ID and quantity, adds order to queue.
     */
    private void placeOrder() {
        System.out.println("\n--- Place Order ---");
        int itemId = -1;
        int quantity = -1;

        try {
            System.out.print("Enter item ID for order: ");
            itemId = scanner.nextInt();

            System.out.print("Enter quantity for order: ");
            quantity = scanner.nextInt();

            // Consume the newline character left by nextInt()
            scanner.nextLine();

            if (quantity <= 0) {
                System.err.println("Error: Quantity must be positive.");
                return;
            }

            // Optional: Check if item exists before placing order
            if (findItemById(itemId) == null) {
                 System.err.println("Error: Item with ID " + itemId + " not found in inventory. Cannot place order.");
                 return;
            }


            Order newOrder = new Order(itemId, quantity);
            pendingOrders.offer(newOrder); // offer is generally preferred over add for queues
            System.out.println("Order placed: " + newOrder);

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter integers for ID and quantity.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             // Catch any other unexpected exceptions during this operation
            System.err.println("An unexpected error occurred during order placement: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        }
    }

    /**
     * Handles the "Process Next Order" operation.
     * Processes the order at the front of the queue.
     */
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders to process.");
            return;
        }

        // Peek at the next order without removing it yet
        Order nextOrder = pendingOrders.peek();

        if (nextOrder == null) {
             // This case should ideally not happen if isEmpty() is false,
             // but good practice to check the result of peek().
             System.err.println("Error: Could not retrieve next order from queue.");
             return;
        }

        System.out.println("Processing " + nextOrder + "...");

        try {
            Item item = findItemById(nextOrder.getItemId());

            if (item == null) {
                System.err.println("Error: Item with ID " + nextOrder.getItemId() + " for OrderID " + nextOrder.getOrderId() + " not found in inventory.");
                // Optionally remove the order if item doesn't exist, or leave it?
                // Let's remove it for simplicity in this exam context, assuming invalid orders are cleared.
                pendingOrders.poll();
                System.err.println("Order " + nextOrder.getOrderId() + " removed due to invalid item ID.");
            } else {
                if (item.getQuantity() >= nextOrder.getQuantity()) {
                    // Sufficient stock, fulfill the order
                    item.setQuantity(item.getQuantity() - nextOrder.getQuantity());
                    // Remove the order from the queue
                    pendingOrders.poll();
                    System.out.println("Stock updated for ItemID " + item.getId() + ". New quantity: " + item.getQuantity());
                    System.out.println("Order " + nextOrder.getOrderId() + " fulfilled successfully.");
                } else {
                    // Insufficient stock
                    System.err.println("Insufficient stock for ItemID " + item.getId() + ". Requested: " + nextOrder.getQuantity() + ", Available: " + item.getQuantity());
                    System.err.println("Order " + nextOrder.getOrderId() + " could not be fulfilled and remains in the queue.");
                    // Order stays in the queue
                }
            }
        } catch (Exception e) {
             // Catch any other unexpected exceptions during this operation
            System.err.println("An unexpected error occurred during order processing: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
             // Decide whether to remove the order or not on error.
             // For simplicity, let's remove it on unexpected errors to prevent blocking the queue.
             pendingOrders.poll();
             System.err.println("Order " + nextOrder.getOrderId() + " removed due to processing error.");
        }
    }

    /**
     * Handles the "View Pending Orders" operation.
     */
    private void viewPendingOrders() {
        System.out.println("\nPending Orders:");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
    }

    /**
     * Runs the main warehouse management loop.
     */
    public void run() {
        int choice = -1;

        // Use a try-catch block around the main loop to handle broad exceptions
        // or exceptions originating from the menu input itself.
        try {
            while (choice != 6) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    // Consume the newline character
                    scanner.nextLine();

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            viewInventory();
                            break;
                        case 2:
                            receiveStock();
                            break;
                        case 3:
                            placeOrder();
                            break;
                        case 4:
                            processNextOrder();
                            break;
                        case 5:
                            viewPendingOrders();
                            break;
                        case 6:
                            System.out.println("Exiting Warehouse Management System.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to avoid exiting unintentionally
                }
                 // Note: Specific operation methods (receiveStock, placeOrder, processNextOrder)
                 // have their own try-catch blocks for errors specific to those operations,
                 // like quantity validation or item lookup. This outer catch is more for
                 // general menu input issues.
            }
        } catch (Exception e) {
            // Catch any unexpected exception that might occur outside the specific method logic
            System.err.println("An unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        manager.run();
    }
}
