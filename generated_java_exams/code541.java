/*
 * Exam Question #541
 * Generated on: 2025-05-11 23:27:04
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Batch Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified system to manage and process background jobs. The system allows users to add new jobs to a queue, process jobs from the queue one by one, and view the status of all submitted jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that simulates this batch processing system. Your solution must adhere to the following:
 * 
 * 1.  **Job Representation:** Create a `Job` class with private fields for a unique `id` (integer), a `description` (String), and a `status` (use an enum for status like `PENDING`, `PROCESSING`, `COMPLETED`). Include a constructor, appropriate getters, and a method to update the status.
 * 2.  **Batch Processor:** Create a `BatchProcessor` class that manages the jobs.
 *     *   Maintain a list of **all** submitted jobs using `java.util.List` (specifically, use `java.util.ArrayList` for the concrete implementation).
 *     *   Maintain a queue of jobs that are currently waiting to be processed using `java.util.Queue`.
 *     *   Implement methods to:
 *         *   `addJob(String description)`: Creates a new `Job` object, assigns it a unique ID, adds it to both the history list and the processing queue.
 *         *   `processNextJob()`: Removes the next job from the processing queue. If the queue is empty, output an error message. If a job is retrieved, update its status in the history list (and the job object itself) to `PROCESSING`, simulate processing (no actual work needed, just update status), then update the status to `COMPLETED`. Output messages indicating the job being processed and completed.
 *         *   `viewAllJobs()`: Print details (ID, status, description) of all jobs in the history list.
 *         *   `viewPendingJobs()`: Print details (ID, status, description) of jobs currently in the processing queue.
 *     *   Implement a `run()` method that contains the main application loop.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Display a menu with options: "Add New Job", "Process Next Job", "View All Jobs", "View Pending Jobs", "Exit".
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, job details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, attempting to process from an empty queue, invalid input type).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `run()` method's main loop to catch potential issues like invalid input format (`InputMismatchException`) or unexpected errors.
 *     *   Handle the specific case of trying to process a job when the queue is empty without throwing an exception from `processNextJob`, instead printing an error to `System.err`.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Implement basic input validation (e.g., checking if menu choice is within range, handling non-integer input for menu).
 *     *   Ensure resources like `Scanner` are handled appropriately (e.g., closed).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and output results or errors as described above. The status of jobs should correctly transition from PENDING (when added) to PROCESSING and then COMPLETED (when processed).
 * 
 * ```
 * Batch Processing System Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View All Jobs
 * 4. View Pending Jobs
 * 5. Exit
 * Enter your choice: <user input>
 * ... (system output or error based on choice)
 * Batch Processing System Menu:
 * ... (menu repeats until exit)
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper use of `System.out` and `System.err`.
 * *   Effective implementation of `try-catch` for error handling.
 * *   Adherence to encapsulation and naming conventions.
 * *   Correct implementation of job status transitions and queue/list management.
 * *   Robustness in handling invalid user input and empty queue scenarios.
 * *   Overall code structure and readability.
 *
 * EXPLANATION:
 * The provided solution implements a simple Batch Processing System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`Job` Class:**
 *     *   Represents a single unit of work.
 *     *   Uses private fields (`id`, `description`, `status`) for encapsulation.
 *     *   Includes getters and a `setStatus` method for controlled access to its state.
 *     *   Uses the `JobStatus` enum to clearly define possible states, improving readability and preventing invalid status values.
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 2.  **`BatchProcessor` Class:**
 *     *   Manages the collection of jobs and the processing logic.
 *     *   Uses a `List<Job>` (`jobHistory` implemented as `ArrayList`) to keep a record of *all* jobs ever submitted. This fulfills the `List` and `ArrayList` requirements.
 *     *   Uses a `Queue<Job>` (`processingQueue` implemented as `ArrayDeque`) to manage jobs waiting to be processed in a FIFO (First-In, First-Out) manner. This fulfills the `Queue` requirement. `ArrayDeque` is a common and efficient implementation for queues.
 *     *   `nextJobId` is a private counter ensuring unique IDs for new jobs.
 *     *   `scanner` is a private field used throughout the `run` method for input.
 * 
 * 3.  **Methods:**
 *     *   `addJob`: Creates a `Job` object, adds it to *both* the `jobHistory` list and the `processingQueue`. It uses `offer()` for the queue, which is generally preferred over `add()` as it handles capacity-constrained queues gracefully (though `ArrayDeque` is not capacity-constrained).
 *     *   `processNextJob`: Uses `poll()` to get the head of the queue. If `poll()` returns `null`, it means the queue is empty, and an error message is printed to `System.err`. Otherwise, it updates the status of the retrieved `Job` object. Since the same `Job` object reference exists in both the queue (before polling) and the history list, updating the object's status updates it in the list as well. Success messages are printed to `System.out`.
 *     *   `viewAllJobs`: Iterates through the `jobHistory` `ArrayList` to print details of all jobs.
 *     *   `viewPendingJobs`: Iterates through the `processingQueue` `ArrayDeque`. Iterating a queue provides elements in their processing order without removing them. Prints details of jobs still in the queue.
 *     *   `displayMenu`: A helper method to print the menu options to `System.out`.
 * 
 * 4.  **User Interface and Control Flow:**
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   `displayMenu()` is called inside the loop to show options.
 *     *   `Scanner` is used to read user input.
 *     *   A `switch` statement handles the integer choice read from the scanner, directing execution to the appropriate method (`addJob`, `processNextJob`, etc.). This fulfills the `Scanner` and `switch` requirements.
 *     *   `System.out` is used for normal program output (menu, prompts, job details, success messages).
 *     *   `System.err` is used specifically for error messages (invalid choice, empty queue, input errors). This fulfills the `System.out` and `System.err` requirements.
 * 
 * 5.  **Error Handling (`try-catch`) and Input Validation:**
 *     *   The main `while` loop in `run()` is wrapped in a top-level `try-catch(Exception e)` block. This provides "class-wide" exception handling by catching any unhandled exceptions that propagate up to the main application loop, preventing the program from crashing unexpectedly and printing the error details to `System.err`.
 *     *   A specific `try-catch(InputMismatchException e)` block is nested inside the loop around `scanner.nextInt()`. This handles cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop caused by the scanner failing to read the input.
 *     *   The `processNextJob` method explicitly checks if `processingQueue.poll()` returns `null` to handle the empty queue scenario gracefully, printing an error to `System.err` rather than relying on an exception.
 *     *   Basic validation is included in `addJob` to check for empty descriptions.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods demonstrate encapsulation.
 *     *   Variable and method names (e.g., `jobHistory`, `processingQueue`, `addJob`, `processNextJob`) are descriptive.
 *     *   Basic comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation for menu choice and job description is included.
 *     *   Error handling is implemented using appropriate streams (`System.out`, `System.err`) and `try-catch`.
 *     *   The `Scanner` resource is closed in a `finally` block associated with the main `try` block in `run()`, ensuring it's closed regardless of how the loop exits (normal exit or unexpected exception).
 *     *   The code is structured into logical classes (`Job`, `BatchProcessor`) and methods, promoting modularity.
 * 
 * This solution effectively integrates all specified Java components and demonstrates key programming concepts like object-oriented design, data structures (`List`, `Queue`), control flow (`switch`, loops), user interaction (`Scanner`), and robust error handling (`try-catch`, `System.err`).
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.ArrayDeque; // A common Queue implementation
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Job Status
enum JobStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED // Added FAILED for potential future use, but not required by prompt
}

// Represents a single job in the system
class Job {
    private int id;
    private String description;
    private JobStatus status;

    /**
     * Constructs a new Job.
     * @param id The unique identifier for the job.
     * @param description A brief description of the job.
     */
    public Job(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = JobStatus.PENDING; // Jobs start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public JobStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the job.
     * @param status The new status for the job.
     */
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Job " + id + " [" + status + "]: " + description;
    }
}

// Manages the batch processing system
public class BatchProcessor {
    // Using List interface, implemented by ArrayList for history
    private List<Job> jobHistory;
    // Using Queue interface, implemented by ArrayDeque for processing queue
    private Queue<Job> processingQueue;
    private int nextJobId; // Counter for assigning unique job IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new BatchProcessor.
     */
    public BatchProcessor() {
        jobHistory = new ArrayList<>();
        processingQueue = new ArrayDeque<>(); // ArrayDeque is efficient for queue operations
        nextJobId = 1;
        scanner = new Scanner(System.in); // Initialize scanner
    }

    /**
     * Adds a new job to the system.
     * @param description The description of the job.
     */
    public void addJob(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Job description cannot be empty.");
            return;
        }
        Job newJob = new Job(nextJobId++, description.trim());
        jobHistory.add(newJob); // Add to history list
        processingQueue.offer(newJob); // Add to processing queue (offer is preferred over add)
        System.out.println("Job " + newJob.getId() + " added.");
    }

    /**
     * Processes the next job in the queue.
     */
    public void processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Job jobToProcess = processingQueue.poll();

        if (jobToProcess == null) {
            System.err.println("Error: Queue is empty, no jobs to process.");
            return;
        }

        // Update status to PROCESSING (this updates the Job object reference in jobHistory as well)
        jobToProcess.setStatus(JobStatus.PROCESSING);
        System.out.println("Processing job: " + jobToProcess.getId() + " - " + jobToProcess.getDescription());

        // Simulate processing time (optional, commented out for exam time constraint)
        /*
        try {
            Thread.sleep(500); // Simulate work
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Processing interrupted for job " + jobToProcess.getId());
            jobToProcess.setStatus(JobStatus.FAILED); // Example of setting FAILED status
            return;
        }
        */

        // Update status to COMPLETED
        jobToProcess.setStatus(JobStatus.COMPLETED);
        System.out.println("Job " + jobToProcess.getId() + " completed successfully.");
    }

    /**
     * Displays details of all jobs in the history list.
     */
    public void viewAllJobs() {
        System.out.println("\n--- All Jobs ---");
        if (jobHistory.isEmpty()) {
            System.out.println("No jobs submitted yet.");
            return;
        }
        // Iterate through the ArrayList (jobHistory)
        for (Job job : jobHistory) {
            System.out.println(job); // Job's toString() is used here
        }
        System.out.println("----------------");
    }

    /**
     * Displays details of jobs currently waiting in the processing queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Jobs (in Queue) ---");
        if (processingQueue.isEmpty()) {
            System.out.println("No jobs currently pending.");
            return;
        }
        // Iterate through the Queue (processingQueue) without removing elements
        // Note: Iterating a Queue directly shows elements in iteration order,
        // which for ArrayDeque is the order they would be polled.
        for (Job job : processingQueue) {
            System.out.println(job);
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nBatch Processing System Menu:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View All Jobs");
        System.out.println("4. View Pending Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Contains the switch statement and class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt(); // Read integer choice
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to next loop iteration
                }

                // Switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        addJob(description);
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewAllJobs();
                        break;
                    case 4:
                        viewPendingJobs();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Batch Processing System.");
                        break;
                    default:
                        // Handles choices outside the 1-5 range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BatchProcessor processor = new BatchProcessor();
        processor.run(); // Start the application loop
    }
}
