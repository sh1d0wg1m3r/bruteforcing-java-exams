/*
 * Exam Question #410
 * Generated on: 2025-05-11 23:07:06
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Shared Resource Booking System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application to manage the booking of a limited number of shared resources (e.g., meeting rooms, lab computers). Users can request to book a specific resource by its ID. If the resource is available, the booking is successful. If the resource is currently booked, the user is added to a waiting list. When a resource is released, the system automatically allocates it to the next user in the waiting list, if any.
 * 
 * Your solution must demonstrate proficiency in using core Java data structures and control flow mechanisms, adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.List` (specifically, an `ArrayList`) to store the currently available resources. Each resource can be represented by a simple integer ID.
 *     *   Use a separate `java.util.List` (specifically, an `ArrayList`) to keep track of the currently active bookings. A booking should associate a user ID (String) with a resource ID (int).
 *     *   Use a `java.util.Queue` (specifically, a `java.util.LinkedList` which implements `Queue`) to manage the waiting list of user IDs (Strings) who requested a resource that was unavailable.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and input from the console (`System.in`).
 *     *   Support the following commands:
 *         *   `book <userID> <resourceID>`: Attempt to book the specified resource for the user.
 *         *   `release <userID> <resourceID>`: Attempt to release the specified resource that the user has booked.
 *         *   `status`: Display the current state of the system (available resources, active bookings, waiting queue).
 *         *   `exit`: Terminate the application.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to process the different user commands.
 *     *   Use a loop to keep the application running until the `exit` command is given.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for successful operations and status messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command format, resource not found, resource already booked by someone else, user trying to release a resource they didn't book).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during command processing (e.g., `InputMismatchException` from `Scanner`, or any custom exceptions you might define/encounter). Any caught exception should be reported to `System.err` before the program continues its main loop.
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods for interaction).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc for classes/methods, inline for complex logic).
 *     *   Validate user input (e.g., correct number of arguments for commands, valid resource IDs).
 *     *   Structure the code logically into appropriate classes (e.g., a main `BookingSystem` class, maybe a simple `Booking` data class).
 * 
 * **Initial State:**
 * 
 * The system should start with a predefined set of available resources (e.g., resources with IDs 101, 102, 103).
 * 
 * **Expected Output:**
 * 
 * *   Successful booking: Print a message indicating the resource is booked for the user.
 * *   Resource unavailable: Print a message indicating the resource is booked and the user is added to the waiting list.
 * *   Successful release: Print a message indicating the resource is released. If a user was waiting, print a message indicating the resource is now booked for the waiting user.
 * *   Status: Print lists of available resources, active bookings (user ID, resource ID), and users in the waiting queue.
 * *   Errors: Print informative error messages to `System.err`.
 * *   Exceptions: Print exception details to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Enter command: status
 * Available Resources: [101, 102, 103]
 * Active Bookings: []
 * Waiting Queue: []
 * Enter command: book userA 101
 * Resource 101 successfully booked by userA.
 * Enter command: status
 * Available Resources: [102, 103]
 * Active Bookings: [Booking{user='userA', resourceId=101}]
 * Waiting Queue: []
 * Enter command: book userB 101
 * Resource 101 is currently booked. userB added to the waiting list.
 * Enter command: book userC 102
 * Resource 102 successfully booked by userC.
 * Enter command: status
 * Available Resources: [103]
 * Active Bookings: [Booking{user='userA', resourceId=101}, Booking{user='userC', resourceId=102}]
 * Waiting Queue: [userB]
 * Enter command: release userA 101
 * Resource 101 released by userA. Resource 101 is now booked by userB from the waiting list.
 * Enter command: status
 * Available Resources: [103]
 * Active Bookings: [Booking{user='userC', resourceId=102}, Booking{user='userB', resourceId=101}]
 * Waiting Queue: []
 * Enter command: release userA 101
 * Error: Resource 101 is not currently booked by userA.
 * Enter command: exit
 * Exiting system.
 * ```
 * 
 * Your code should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements a `SharedResourceBookingSystem` class that manages the state and logic for booking resources.
 * 
 * 1.  **Class Structure:**
 *     *   A simple `Booking` class is created to hold the user ID and resource ID for each active booking. It includes a `toString` method for easy printing and getter methods following encapsulation principles.
 *     *   The main `SharedResourceBookingSystem` class contains the core logic and data structures.
 * 
 * 2.  **Data Structures:**
 *     *   `availableResources`: An `ArrayList<Integer>` stores the IDs of resources that are currently free and can be booked immediately. `ArrayList` is used because we need dynamic resizing and efficient removal/addition by value or index, which is suitable for managing a list of available items. It implements the `List` interface.
 *     *   `currentBookings`: An `ArrayList<Booking>` stores `Booking` objects representing resources that are currently allocated to users. `ArrayList` is used for similar reasons as `availableResources`. It also implements the `List` interface.
 *     *   `waitingQueue`: A `LinkedList<String>` is used as a `Queue` to store the user IDs of users waiting for a resource. `Queue` is the appropriate interface here because users wait in a First-In, First-Out (FIFO) order. `LinkedList` is a common implementation of the `Queue` interface that provides efficient addition (`offer`) and removal (`poll`) from the ends.
 * 
 * 3.  **Core Logic (`bookResource`, `releaseResource`):**
 *     *   `bookResource(userId, resourceId)`:
 *         *   It first checks if the `resourceId` exists in the `availableResources` list.
 *         *   If found, it removes the resource ID from `availableResources`, creates a new `Booking` object, adds it to `currentBookings`, and prints a success message to `System.out`.
 *         *   If not found in `availableResources`, it checks if the resource is in `currentBookings`. If it is, the user is added to the `waitingQueue` using `offer()`, and a message is printed to `System.out`. If the resource ID is not found in either list, it's considered an invalid resource, and an error is printed to `System.err`.
 *     *   `releaseResource(userId, resourceId)`:
 *         *   It iterates through `currentBookings` to find a matching `Booking` object for the given `userId` and `resourceId`.
 *         *   If found, the booking is removed from `currentBookings`. A success message is printed to `System.out`.
 *         *   It then checks if the `waitingQueue` is empty using `isEmpty()`.
 *         *   If the queue is NOT empty, `poll()` is used to get and remove the next user ID from the queue. This user is then immediately allocated the just-released resource by creating a new `Booking` for them and adding it to `currentBookings`. A message indicating this re-allocation is printed to `System.out`. The resource is *not* added back to `availableResources` in this case.
 *         *   If the queue IS empty, the released `resourceId` is added back to the `availableResources` list.
 *         *   If the booking was not found (either the resource was booked by someone else or was already available), an appropriate error message is printed to `System.err`.
 * 
 * 4.  **User Interaction and Control Flow (`run`, `main`):**
 *     *   The `main` method creates an instance of the `SharedResourceBookingSystem` with initial resources and calls the `run` method.
 *     *   The `run` method contains the main application loop.
 *     *   A `Scanner` reads input lines from `System.in`.
 *     *   Input lines are split into command parts.
 *     *   A `switch` statement handles the different commands (`book`, `release`, `status`, `exit`).
 *     *   Input validation is performed within each case (checking the number of arguments).
 *     *   Resource IDs are parsed as integers, with `NumberFormatException` handled specifically for invalid number format.
 * 
 * 5.  **Exception Handling:**
 *     *   A `try-catch(Exception e)` block wraps the core logic inside the `while` loop in the `run` method. This provides "class-wide" handling for any unexpected exceptions that might occur during the processing of a single command (e.g., issues with input parsing, although `NumberFormatException` is handled more specifically, this catches others).
 *     *   Caught exceptions are reported to `System.err` using `e.getMessage()`. This prevents the program from crashing and allows the loop to continue.
 *     *   Specific input validation errors (like wrong command format or empty user ID) are handled with `if` statements and reported directly to `System.err`.
 * 
 * 6.  **Output:**
 *     *   `System.out` is used for all successful operations and the status display (`displayStatus` method).
 *     *   `System.err` is used exclusively for error messages, clearly separating them from normal output.
 * 
 * 7.  **Best Practices:**
 *     *   Fields (`availableResources`, `currentBookings`, `waitingQueue`) are `private`.
 *     *   Methods (`bookResource`, `releaseResource`, `displayStatus`, `run`) are `public` to expose the system's functionality.
 *     *   Variable and method names are descriptive (`userId`, `resourceId`, `waitingQueue`, `bookResource`).
 *     *   Javadoc comments are provided for classes and methods, explaining their purpose.
 *     *   Input validation checks are included before processing commands.
 *     *   Error handling differentiates between user input errors (`System.err` messages) and unexpected system errors (`try-catch` reporting to `System.err`).
 *     *   The `Scanner` is closed when the application exits.
 * 
 * This solution effectively utilizes all the required Java components within a practical scenario, demonstrating understanding of data structures, control flow, error handling, and basic object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a booking of a resource by a user.
 */
class Booking {
    private String userId;
    private int resourceId;

    /**
     * Constructs a new Booking.
     * @param userId The ID of the user making the booking.
     * @param resourceId The ID of the resource being booked.
     */
    public Booking(String userId, int resourceId) {
        this.userId = userId;
        this.resourceId = resourceId;
    }

    /**
     * Gets the user ID associated with this booking.
     * @return The user ID.
     */
    public String getUserId() {
        return userId;
    }

    /**
     * Gets the resource ID associated with this booking.
     * @return The resource ID.
     */
    public int getResourceId() {
        return resourceId;
    }

    @Override
    public String toString() {
        return "Booking{user='" + userId + "', resourceId=" + resourceId + "}";
    }
}

/**
 * Manages the booking and allocation of shared resources.
 */
public class SharedResourceBookingSystem {

    private List<Integer> availableResources; // List of resource IDs that are free
    private List<Booking> currentBookings;    // List of active bookings
    private Queue<String> waitingQueue;       // Queue of user IDs waiting for a resource

    /**
     * Constructs a new SharedResourceBookingSystem with initial resources.
     * @param initialResourceIds An array of resource IDs to initialize the system with.
     */
    public SharedResourceBookingSystem(int[] initialResourceIds) {
        this.availableResources = new ArrayList<>();
        for (int id : initialResourceIds) {
            this.availableResources.add(id);
        }
        this.currentBookings = new ArrayList<>();
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Attempts to book a resource for a user.
     * If the resource is available, it is booked. If not, the user is added to the waiting queue.
     * @param userId The ID of the user requesting the booking.
     * @param resourceId The ID of the resource requested.
     */
    public void bookResource(String userId, int resourceId) {
        // Validate user ID
        if (userId == null || userId.trim().isEmpty()) {
            System.err.println("Error: User ID cannot be empty.");
            return;
        }

        // Check if resource ID exists (optional but good practice, assuming predefined resources)
        // For this problem, we'll assume any int resourceId is potentially valid if it exists in the initial list or current bookings
        boolean resourceExists = availableResources.contains(resourceId) ||
                                 currentBookings.stream().anyMatch(b -> b.getResourceId() == resourceId);

        if (!resourceExists && !waitingQueue.contains(userId)) { // Simple check if it was an initial resource or is currently booked/requested
             // This check is a bit weak. A better system would have a master list of all resources.
             // For this problem, we'll allow booking/releasing any ID and handle availability.
        }


        // Check if resource is available
        if (availableResources.remove(Integer.valueOf(resourceId))) {
            // Resource was available, book it
            currentBookings.add(new Booking(userId, resourceId));
            System.out.println("Resource " + resourceId + " successfully booked by " + userId + ".");
        } else {
            // Resource is not available, check if it's currently booked
            boolean isBooked = currentBookings.stream().anyMatch(booking -> booking.getResourceId() == resourceId);

            if (isBooked) {
                // Resource is booked, add user to waiting queue if not already waiting
                if (!waitingQueue.contains(userId)) {
                    waitingQueue.offer(userId); // Add to the end of the queue
                    System.out.println("Resource " + resourceId + " is currently booked. " + userId + " added to the waiting list.");
                } else {
                     System.out.println(userId + " is already in the waiting list for resource " + resourceId + ".");
                }
            } else {
                 // Resource ID was not found in available OR booked lists
                 System.err.println("Error: Resource ID " + resourceId + " is not a valid resource in the system.");
            }
        }
    }

    /**
     * Attempts to release a resource booked by a user.
     * If the resource is released successfully, it is allocated to the next waiting user, if any.
     * @param userId The ID of the user releasing the resource.
     * @param resourceId The ID of the resource being released.
     */
    public void releaseResource(String userId, int resourceId) {
         // Validate user ID
        if (userId == null || userId.trim().isEmpty()) {
            System.err.println("Error: User ID cannot be empty.");
            return;
        }

        // Find the booking
        Booking bookingToRemove = null;
        for (Booking booking : currentBookings) {
            if (booking.getUserId().equals(userId) && booking.getResourceId() == resourceId) {
                bookingToRemove = booking;
                break;
            }
        }

        if (bookingToRemove != null) {
            currentBookings.remove(bookingToRemove);
            System.out.println("Resource " + resourceId + " released by " + userId + ".");

            // Check the waiting queue
            if (!waitingQueue.isEmpty()) {
                String nextUserId = waitingQueue.poll(); // Get and remove the head of the queue
                System.out.println("Resource " + resourceId + " is now booked by " + nextUserId + " from the waiting list.");
                // Immediately book the resource for the waiting user
                currentBookings.add(new Booking(nextUserId, resourceId)); // Add to booked list
                // Note: The resource is NOT added back to availableResources list as it's immediately re-booked
            } else {
                // No one waiting, add resource back to available list
                availableResources.add(resourceId);
            }

        } else {
            // Booking not found for this user and resource
            boolean resourceIsBookedBySomeoneElse = currentBookings.stream()
                                                        .anyMatch(b -> b.getResourceId() == resourceId);
            boolean resourceIsAvailable = availableResources.contains(resourceId);

            if (resourceIsBookedBySomeoneElse) {
                 System.err.println("Error: Resource " + resourceId + " is currently booked by someone else, not " + userId + ".");
            } else if (resourceIsAvailable) {
                 System.err.println("Error: Resource " + resourceId + " is already available, not booked by anyone.");
            }
            else {
                 System.err.println("Error: Resource " + resourceId + " is not currently booked or available in the system.");
            }
        }
    }

    /**
     * Displays the current status of the booking system.
     * Shows available resources, active bookings, and the waiting queue.
     */
    public void displayStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Available Resources: " + availableResources);
        System.out.println("Active Bookings: " + currentBookings);
        System.out.println("Waiting Queue: " + waitingQueue);
        System.out.println("---------------------");
    }

    /**
     * Runs the main application loop, processing user commands.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Shared Resource Booking System started. Enter commands (book, release, status, exit).");

        // Class-wide exception handling for the main command loop
        while (running) {
            System.out.print("Enter command: ");
            try {
                String inputLine = scanner.nextLine();
                String[] parts = inputLine.trim().split("\\s+");
                if (parts.length == 0 || parts[0].isEmpty()) {
                    continue; // Skip empty input
                }

                String command = parts[0].toLowerCase();

                switch (command) {
                    case "book":
                        if (parts.length == 3) {
                            String userId = parts[1];
                            try {
                                int resourceId = Integer.parseInt(parts[2]);
                                bookResource(userId, resourceId);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid resource ID format. Please enter an integer.");
                            }
                        } else {
                            System.err.println("Error: Invalid 'book' command format. Usage: book <userID> <resourceID>");
                        }
                        break;

                    case "release":
                         if (parts.length == 3) {
                            String userId = parts[1];
                             try {
                                int resourceId = Integer.parseInt(parts[2]);
                                releaseResource(userId, resourceId);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid resource ID format. Please enter an integer.");
                            }
                        } else {
                            System.err.println("Error: Invalid 'release' command format. Usage: release <userID> <resourceID>");
                        }
                        break;

                    case "status":
                        if (parts.length == 1) {
                            displayStatus();
                        } else {
                            System.err.println("Error: Invalid 'status' command format. Usage: status");
                        }
                        break;

                    case "exit":
                        if (parts.length == 1) {
                            running = false;
                            System.out.println("Exiting system.");
                        } else {
                            System.err.println("Error: Invalid 'exit' command format. Usage: exit");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'. Available commands: book, release, status, exit.");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for more detailed debugging
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        int[] initialResources = {101, 102, 103, 201, 202}; // Example initial resources
        SharedResourceBookingSystem system = new SharedResourceBookingSystem(initialResources);
        system.run();
    }
}
