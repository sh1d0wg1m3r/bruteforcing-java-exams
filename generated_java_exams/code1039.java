/*
 * Exam Question #1039
 * Generated on: 2025-05-12 17:16:27
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Quality Control Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified simulation of a manufacturing production line. The factory produces different types of products. Once a product is manufactured, it is placed in a queue to await quality control inspection. Your program should allow a user (acting as a line supervisor) to interact with this system.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this scenario. Your solution MUST utilize the following Java components:
 * 
 * 1.  `java.util.Queue`: To represent the buffer of products waiting for quality control.
 * 2.  `java.util.ArrayList`: To store the catalog of available product types that can be manufactured.
 * 3.  `java.util.List`: Use this interface type when declaring variables that hold the product catalog (e.g., `List<Product> availableTypes = new ArrayList<>();`).
 * 4.  `java.util.Scanner`: To read user input from the console.
 * 5.  `switch` statement: To control the flow of the main menu options.
 * 6.  `System.err`: To display error messages (e.g., invalid input, queue empty).
 * 7.  `System.out`: To display the menu, lists, queue status, and successful operation messages.
 * 8.  Class-wide exception handling with `try-catch` blocks: To handle potential runtime issues, particularly related to user input.
 * 
 * **Program Functionality:**
 * 
 * Your program should present a menu with the following options:
 * 
 * 1.  **View Available Product Types:** Display the list of product types that can be manufactured, including their index/ID for selection.
 * 2.  **Manufacture Product:**
 *     *   Prompt the user to select a product type from the available list by entering its index.
 *     *   Validate the user's input to ensure it's a valid index.
 *     *   If valid, create a *new* instance of the selected product type. Each manufactured product should have a unique identifier (e.g., a simple auto-incrementing ID).
 *     *   Add the newly manufactured product instance to the quality control `Queue`.
 *     *   Confirm the successful manufacturing and addition to the queue.
 *     *   If input is invalid, display an error using `System.err`.
 * 3.  **Process Quality Control:**
 *     *   Check if the quality control `Queue` is empty. If so, display an error using `System.err`.
 *     *   If the queue is not empty, remove the next product from the front of the `Queue`.
 *     *   Update the status of the processed product (e.g., change status from "Manufactured" to "Quality Controlled").
 *     *   Report which product (using its unique ID and type) was processed for quality control using `System.out`.
 * 4.  **View Quality Control Queue:**
 *     *   Check if the quality control `Queue` is empty. If so, display a message using `System.out`.
 *     *   If the queue is not empty, display the list of products currently waiting in the `Queue`, including their unique ID and type. Do NOT remove items from the queue when viewing.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Product Class:**
 * 
 * Create a simple `Product` class with the following characteristics:
 * 
 * *   Private fields: `id` (int), `name` (String), `status` (String).
 * *   A constructor to initialize `id`, `name`, and initial `status` (e.g., "Manufactured").
 * *   Public getter methods for `id`, `name`, and `status`.
 * *   A public method `updateStatus(String newStatus)` to change the product's status.
 * *   Override the `toString()` method to provide a convenient string representation of the product (e.g., "Product [ID=..., Name=..., Status=...]").
 * 
 * **Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods/getters).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments to explain complex logic or sections.
 * *   Implement input validation where necessary (e.g., menu choice, product selection index).
 * *   Handle errors gracefully using `try-catch` and `System.err`.
 * *   Structure your code cleanly into appropriate classes and methods (though a single class with main is acceptable for the core logic in this exam context, provided it's well-structured).
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying the menu, prompts, lists, and messages as described using `System.out` and error messages using `System.err`.
 * 
 * ```
 * --- Production Line Simulator ---
 * 1. View Available Product Types
 * 2. Manufacture Product
 * 3. Process Quality Control
 * 4. View Quality Control Queue
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * *(Example interaction flow would follow, showing menu display, user input, output based on choice, including error cases)*
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of program functionality as described.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code structure and readability.
 *
 * EXPLANATION:
 * The provided solution implements a `ProductionLineSimulator` class that simulates a basic manufacturing process involving a quality control queue.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `qcQueue` is declared as a `Queue<Product>` and instantiated as a `LinkedList<Product>`. `LinkedList` is a common implementation of the `Queue` interface suitable for this purpose.
 *     *   `qcQueue.add(newProduct)`: Used in `manufactureProduct()` to add a newly created product to the end of the queue.
 *     *   `qcQueue.poll()`: Used in `processQualityControl()` to retrieve and remove the product at the front of the queue, simulating processing the next item in line.
 *     *   `qcQueue.isEmpty()`: Used in `processQualityControl()` and `viewQualityControlQueue()` to check if the queue has any items before attempting to process or list them.
 *     *   Iteration (`for (Product p : qcQueue)`): Used in `viewQualityControlQueue()` to display the contents of the queue without removing elements.
 * 
 * 2.  **`java.util.ArrayList`**: The `availableProductTypes` is instantiated as an `ArrayList<Product>`. This is used to store the predefined types of products that the factory can manufacture. `ArrayList` provides dynamic resizing and efficient indexed access, suitable for a catalog.
 * 
 * 3.  **`java.util.List`**: The `availableProductTypes` variable is declared using the `List<Product>` interface type (`private List<Product> availableProductTypes;`). This demonstrates programming to the interface, which is a best practice allowing for potential changes in the underlying implementation (e.g., to `LinkedList` or another `List` implementation) without affecting the code that uses the variable.
 * 
 * 4.  **`java.util.Scanner`**: A `Scanner` instance is created (`private Scanner scanner;`) to read user input from `System.in` in the `run()` method and within the `manufactureProduct()` method.
 * 
 * 5.  **`switch` statement**: Located in the `run()` method, the `switch` statement is used to control the program's flow based on the integer choice entered by the user from the main menu. Each case corresponds to a different action (view types, manufacture, process QC, view queue, exit).
 * 
 * 6.  **`System.err`**: Used specifically for outputting error messages.
 *     *   In the `run()` method, it's used for invalid menu choices and catching general exceptions.
 *     *   In `manufactureProduct()`, it's used for invalid product type indices and `InputMismatchException`.
 *     *   In `processQualityControl()`, it's used when the queue is empty.
 * 
 * 7.  **`System.out`**: Used for all standard output:
 *     *   Displaying the main menu.
 *     *   Printing available product types.
 *     *   Confirming successful manufacturing and QC processing.
 *     *   Displaying the contents of the quality control queue.
 *     *   Printing exit messages.
 * 
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   A `try-catch` block wraps the input reading and `switch` statement in the `run()` method. This primarily catches `InputMismatchException` if the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to gracefully handle the error by printing a message to `System.err` and consuming the invalid input using `scanner.nextLine()`.
 *     *   A specific `try-catch(InputMismatchException)` is also used in `manufactureProduct()` when reading the product type index for the same reasons.
 *     *   A general `catch (Exception e)` is included in the main `run` loop's `try-catch` as a fallback for any other unexpected runtime exceptions, demonstrating a broader error handling strategy, although specific catches are preferred when possible. The stack trace is printed to `System.err` for debugging purposes.
 * 
 * **Product Class (`Product.java`):**
 * 
 * *   This simple class encapsulates the data for a product (`id`, `name`, `status`).
 * *   It uses private fields and public getter methods, demonstrating **encapsulation**.
 * *   The `updateStatus()` method provides controlled modification of the status.
 * *   The overridden `toString()` method provides a user-friendly representation for printing.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** The `Product` class fields are private with public getters and a status update method. The simulator's data structures (`availableProductTypes`, `qcQueue`) are private.
 * *   **Meaningful Names:** Variables (`availableProductTypes`, `qcQueue`, `productIdCounter`, `productToProcess`), methods (`displayMenu`, `manufactureProduct`, `processQualityControl`, `viewQualityControlQueue`), and the class names are descriptive.
 * *   **Comments:** Comments explain the purpose of classes, fields, methods, and key logic blocks (like exception handling or queue operations).
 * *   **Input Validation:** The code checks if the entered product type index is within the valid range of the `availableProductTypes` list before attempting to access it. `InputMismatchException` handling validates that the input is of the expected type (integer).
 * *   **Error Handling:** `try-catch` blocks are used, and error messages are directed to `System.err`. Specific error messages guide the user.
 * *   **Clean Code Structure:** The logic is divided into a `Product` class and a `ProductionLineSimulator` class. The simulator's main loop and different functionalities are separated into distinct private methods (`displayMenu`, `run`, `viewAvailableProductTypes`, etc.), making the code modular and easier to understand. A static counter is used for generating unique product IDs, keeping the ID generation logic contained.
 * 
 * This solution effectively integrates all required components into a functional simulation, demonstrating practical application of data structures, control flow, user interaction, and error management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a product in the manufacturing process
class Product {
    private int id;
    private String name;
    private String status;

    // Constructor
    public Product(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = "Manufactured"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status
    public void updateStatus(String newStatus) {
        this.status = newStatus;
    }

    // String representation of the product
    @Override
    public String toString() {
        return "Product [ID=" + id + ", Name=" + name + ", Status=" + status + "]";
    }
}

// Main class for the production line simulator
public class ProductionLineSimulator {

    // Static counter for unique product IDs
    private static int productIdCounter = 1;

    // List to hold available product types (templates)
    private List<Product> availableProductTypes;

    // Queue to hold products waiting for quality control
    private Queue<Product> qcQueue;

    // Scanner for user input
    private Scanner scanner;

    // Constructor to initialize the simulator
    public ProductionLineSimulator() {
        availableProductTypes = new ArrayList<>(); // Use ArrayList for the List interface
        qcQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        scanner = new Scanner(System.in);

        // Initialize some sample product types
        initializeProductTypes();
    }

    // Initializes the list of available product types
    private void initializeProductTypes() {
        // Note: These are just templates, actual products get new IDs when manufactured
        availableProductTypes.add(new Product(0, "Widget")); // ID 0 is arbitrary for type list
        availableProductTypes.add(new Product(0, "Gadget"));
        availableProductTypes.add(new Product(0, "Thingamajig"));
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Production Line Simulator ---");
        System.out.println("1. View Available Product Types");
        System.out.println("2. Manufacture Product");
        System.out.println("3. Process Quality Control");
        System.out.println("4. View Quality Control Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main simulation loop
    public void run() {
        boolean running = true;

        while (running) {
            displayMenu();

            try {
                int choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        viewAvailableProductTypes();
                        break;
                    case 2:
                        manufactureProduct();
                        break;
                    case 3:
                        processQualityControl();
                        break;
                    case 4:
                        viewQualityControlQueue();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulator. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input to prevent infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err for debugging
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    // Option 1: View available product types
    private void viewAvailableProductTypes() {
        System.out.println("\n--- Available Product Types ---");
        if (availableProductTypes.isEmpty()) {
            System.out.println("No product types defined.");
        } else {
            // Using List interface methods to iterate
            for (int i = 0; i < availableProductTypes.size(); i++) {
                Product type = availableProductTypes.get(i);
                System.out.println(i + ". " + type.getName()); // Display index and name
            }
        }
    }

    // Option 2: Manufacture a product
    private void manufactureProduct() {
        System.out.println("\n--- Manufacture Product ---");
        viewAvailableProductTypes(); // Show types to choose from

        if (availableProductTypes.isEmpty()) {
            System.err.println("Cannot manufacture: No product types available.");
            return;
        }

        System.out.print("Enter the index of the product type to manufacture: ");
        try {
            int typeIndex = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Input validation for index
            if (typeIndex >= 0 && typeIndex < availableProductTypes.size()) {
                Product selectedType = availableProductTypes.get(typeIndex);

                // Create a new Product instance with a unique ID
                Product newProduct = new Product(productIdCounter++, selectedType.getName());

                // Add the new product to the quality control queue
                qcQueue.add(newProduct); // add() throws exception if fails, offer() returns false

                System.out.println("Manufactured: " + newProduct.getName() + " (ID: " + newProduct.getId() + ")");
                System.out.println("Added to Quality Control Queue. Current queue size: " + qcQueue.size());

            } else {
                System.err.println("Invalid index. Please enter a valid index from the list.");
            }
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number for the index.");
            scanner.nextLine(); // Consume invalid input
        }
        // No need for general Exception here, specific InputMismatchException and index check cover expected issues.
    }

    // Option 3: Process Quality Control
    private void processQualityControl() {
        System.out.println("\n--- Process Quality Control ---");

        if (qcQueue.isEmpty()) {
            System.err.println("Quality Control Queue is empty. Nothing to process.");
        } else {
            // Get and remove the product at the front of the queue
            Product productToProcess = qcQueue.poll(); // poll() returns null if queue is empty (handled above)

            if (productToProcess != null) {
                // Update status
                productToProcess.updateStatus("Quality Controlled");
                System.out.println("Processed QC for: " + productToProcess);
                System.out.println("Remaining in queue: " + qcQueue.size());
            }
            // poll() returning null is already handled by the isEmpty() check,
            // so the else for productToProcess != null is technically redundant but harmless.
        }
    }

    // Option 4: View Quality Control Queue
    private void viewQualityControlQueue() {
        System.out.println("\n--- Quality Control Queue ---");

        if (qcQueue.isEmpty()) {
            System.out.println("Quality Control Queue is empty.");
        } else {
            System.out.println("Products waiting for QC:");
            // Iterate through the queue without removing elements
            // Using enhanced for loop which implicitly uses an iterator
            for (Product p : qcQueue) {
                System.out.println("- " + p); // Uses Product's toString()
            }
            System.out.println("Total items in queue: " + qcQueue.size());
        }
    }

    // Main method to start the simulator
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.run();
    }
}
