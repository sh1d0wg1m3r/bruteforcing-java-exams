/*
 * Exam Question #853
 * Generated on: 2025-05-12 16:50:42
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * You are tasked with creating a simple command-line based Task Management System for a small project team. The system should allow users to add new tasks, process the next task waiting, view all tasks ever added, and view tasks currently pending in the processing queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with private fields for `id` (int), `description` (String), and `priority` (String - allowed values: "High", "Medium", "Low"). Include a constructor and public getter methods for these fields. Override the `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a class named `TaskManager`.
 *     *   It must internally use a `java.util.Queue<Task>` to manage tasks waiting for processing. Use `java.util.LinkedList` as the concrete implementation for the Queue.
 *     *   It must also internally use a `java.util.List<Task>` (declared as the `List` interface type, implemented by `java.util.ArrayList`) to keep a record of all tasks ever added to the system.
 *     *   Include a private field to generate unique task IDs (e.g., an integer counter starting from 1).
 *     *   Implement the following public methods:
 *         *   `void addTask(String description, String priority)`: Creates a new `Task` object with a unique ID. **Validate the input priority string** to ensure it's one of "High", "Medium", or "Low" (case-insensitive). If validation fails or description is empty, print an error message to `System.err` and do not add the task. Otherwise, add the task to both the `List` of all tasks and the `Queue` of pending tasks. Print a success message to `System.out`.
 *         *   `void processNextTask()`: Removes the next task from the front of the `Queue` and prints a message to `System.out` indicating which task is being processed. If the `Queue` is empty, print an error message to `System.err`.
 *         *   `void viewAllTasks()`: Iterates through the `List` of all tasks and prints their details to `System.out`. Indicate if no tasks have been added.
 *         *   `void viewPendingTasksInQueue()`: Iterates through the `Queue` of pending tasks and prints their details to `System.out`. Indicate if the queue is empty. (Hint: Iterate without removing elements).
 * 3.  **User Interface:** Create a main class (e.g., `TaskManagementSystem`) with a `main` method.
 *     *   Implement a command-line menu using `java.util.Scanner` to interact with the user. The menu should offer options for adding a task, processing the next task, viewing all tasks, viewing pending tasks, and exiting.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display the menu and program output using `System.out`.
 *     *   Display all error messages (from input validation and empty queue processing) using `System.err`.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the `main` method's loop to handle potential exceptions like `NumberFormatException` if the user enters non-integer input for the menu choice. Provide appropriate error messages to `System.err`. Ensure the scanner input is handled correctly to avoid issues after catching exceptions.
 *     *   The program should loop until the user chooses the exit option. Close the `Scanner` before exiting.
 * 4.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary.
 *     *   Ensure input validation and error handling are robust as described above.
 * 
 * **Expected Output:**
 * Your program should demonstrate the ability to:
 * *   Display the menu.
 * *   Accept valid menu choices and perform the corresponding actions (add, process, view all, view pending, exit).
 * *   Add tasks with valid priorities and see them appear in both the "all tasks" list and the "pending queue".
 * *   Attempt to add tasks with invalid priorities or empty descriptions and see error messages on `System.err`.
 * *   Process tasks from the queue in FIFO order and see them removed from the "pending queue" view.
 * *   Attempt to process a task when the queue is empty and see an error message on `System.err`.
 * *   View the full list of tasks added.
 * *   View the tasks currently waiting in the queue.
 * *   Enter non-integer input for the menu choice and see a `NumberFormatException` handled with an error message on `System.err`.
 * *   Exit the program cleanly.
 * 
 * A typical interaction flow is shown in the thought block above.
 * 
 * **Deliverables:**
 * Provide the complete Java source code for all necessary classes (`Task`, `TaskManager`, `TaskManagementSystem` or similar).
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System based on the requirements.
 * 
 * 1.  **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) to represent a single task. It encapsulates the task's `id`, `description`, and `priority` using private fields and provides public getter methods. The `toString()` method is overridden to provide a convenient string representation for printing task details. This demonstrates basic encapsulation.
 * 
 * 2.  **`TaskManager` Class:** This class contains the core logic for managing tasks.
 *     *   It uses a `java.util.Queue<Task>` (`taskQueue`) implemented by `java.util.LinkedList`. The `Queue` is used to hold tasks that are ready for processing, naturally following a First-In, First-Out (FIFO) order. `offer()` is used for adding tasks and `poll()` for removing and retrieving the next task.
 *     *   It uses a `java.util.List<Task>` (`allTasks`) declared using the `List` interface and implemented by `java.util.ArrayList`. This list maintains a complete historical record of every task ever added to the system, separate from the processing queue.
 *     *   A private `nextTaskId` counter ensures each task gets a unique identifier.
 *     *   The `addTask` method validates the input `description` and `priority`. An invalid priority or empty description results in an error message printed to `System.err`, and the task is not added. Valid tasks are added to both the `allTasks` list and the `taskQueue`.
 *     *   The `processNextTask` method checks if the `taskQueue` is empty. If it is, an error message is printed to `System.err`. Otherwise, `poll()` is called to remove and print the next task from the queue.
 *     *   `viewAllTasks` iterates over the `allTasks` list to display every task ever created using a simple enhanced for loop.
 *     *   `viewPendingTasksInQueue` iterates over the `taskQueue`. Iterating directly over a `Queue` using an enhanced for loop or its iterator allows viewing elements without removing them, fulfilling the requirement to show pending tasks.
 * 
 * 3.  **`TaskManagementSystem` Class (Main):**
 *     *   This class contains the `main` method, which acts as the application's entry point and user interface handler.
 *     *   A `Scanner` is used to read user input from the console. Using `scanner.nextLine()` followed by `Integer.parseInt()` for reading the menu choice is a robust way to handle potential newline characters left in the buffer by previous `nextInt()` calls, although in this specific implementation, all string inputs also use `nextLine()`, simplifying buffer management.
 *     *   A `while(true)` loop keeps the menu running until the user explicitly chooses to exit.
 *     *   A `switch` statement directs the program flow based on the user's integer choice, calling the appropriate methods in the `TaskManager`.
 *     *   `System.out` is used for printing the menu, successful actions, and task details.
 *     *   `System.err` is specifically used for printing error messages related to invalid input or operational failures (like processing an empty queue), as required.
 *     *   A `try-catch` block wraps the core logic inside the `while` loop. This provides **class-wide exception handling** for the main interaction flow. It specifically catches `NumberFormatException` if the user enters non-numeric input for the menu choice, printing an informative error to `System.err`. A generic `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors that might occur during a menu iteration, demonstrating a broader exception handling strategy.
 *     *   The `Scanner` resource is closed before the program exits to prevent resource leaks.
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List` interface, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, adhering to best practices like encapsulation, validation, and clear error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although using nextLine+parseInt, good to know

// Represents a single task
class Task {
    private int id;
    private String description;
    private String priority; // "High", "Medium", "Low"

    // Constructor
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Public getter methods
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    // Override toString for easy printing of task details
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: '%s', Priority: %s", id, description, priority);
    }
}

// Manages the collection of tasks and the processing queue
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO order)
    private Queue<Task> taskQueue = new LinkedList<>();

    // List to keep track of all tasks ever added
    private List<Task> allTasks = new ArrayList<>(); // Using List interface, implemented by ArrayList

    // Counter for generating unique task IDs
    private int nextTaskId = 1;

    // Helper method to validate priority input
    private boolean isValidPriority(String priority) {
        if (priority == null) {
            return false;
        }
        String lowerPriority = priority.trim().toLowerCase();
        return lowerPriority.equals("high") || lowerPriority.equals("medium") || lowerPriority.equals("low");
    }

    // Adds a new task to the system
    public void addTask(String description, String priority) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        // Input validation for priority using the helper method
        if (!isValidPriority(priority)) {
            System.err.println("Error: Invalid priority. Must be High, Medium, or Low.");
            return;
        }

        // Create new task
        Task newTask = new Task(nextTaskId++, description.trim(), priority.trim());

        // Add to the list of all tasks
        allTasks.add(newTask);

        // Add to the queue for processing
        taskQueue.offer(newTask); // offer is generally preferred over add for queues as it doesn't throw exception on capacity limits (though LinkedList doesn't have capacity limits)

        System.out.println("Task added: " + newTask);
    }

    // Processes the next task from the queue
    public void processNextTask() {
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        // Remove and retrieve the task from the front of the queue
        Task processedTask = taskQueue.poll(); // poll returns null if queue is empty, but we checked isEmpty() already

        System.out.println("Processing task: " + processedTask);
        // In a real application, actual task work would happen here.
    }

    // Displays all tasks ever added to the system
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
            return;
        }
        System.out.println("--- All Tasks ---");
        // Iterate through the List and print each task
        for (Task task : allTasks) {
            System.out.println(task);
        }
        System.out.println("-----------------");
    }

    // Displays tasks currently waiting in the processing queue
    public void viewPendingTasksInQueue() {
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
            return;
        }
        System.out.println("--- Pending Tasks in Queue ---");
        // Iterate through the Queue without removing elements
        // The Queue interface's iterator traverses elements in processing order
        for (Task task : taskQueue) {
            System.out.println(task);
        }
        System.out.println("----------------------------");
    }
}

// Main class for the Task Management System user interface
public class TaskManagementSystem {

    // Helper method to print the main menu
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Pending Tasks in Queue");
        System.out.println("0. Exit");
        System.out.println("--------------------------");
    }

    // Main method to run the application
    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);

        // Main application loop
        while (true) {
            printMenu();
            // Class-wide exception handling for the main interaction loop
            try {
                System.out.print("Enter your choice: ");
                // Read the entire line to avoid issues with nextInt() followed by nextLine()
                String input = scanner.nextLine();
                int choice = Integer.parseInt(input); // Attempt to parse the input string

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        taskManager.addTask(description, priority);
                        break;
                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;
                    case 3: // View All Tasks
                        taskManager.viewAllTasks();
                        break;
                    case 4: // View Pending Tasks in Queue
                        taskManager.viewPendingTasksInQueue();
                        break;
                    case 0: // Exit
                        System.out.println("Exiting Task Management System.");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                }
            } catch (NumberFormatException e) {
                // Handle cases where the user input is not a valid integer
                System.err.println("Invalid input format. Please enter a number for the menu choice.");
                // No need to consume line here as nextLine() was used
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging purposes if needed
            }
            System.out.println(); // Add a blank line for better readability between menu cycles
        }
    }
}
