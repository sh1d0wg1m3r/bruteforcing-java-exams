/*
 * Exam Question #682
 * Generated on: 2025-05-12 16:25:17
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Print Job Scheduler**
 * 
 * **Scenario:**
 * You are tasked with developing a command-line application that simulates a basic print job scheduler. The system should manage a queue of pending print jobs and keep a record of jobs that have been processed or cancelled. Users should be able to add new print jobs, process the next job in the queue, view pending jobs, and view completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class `PrintJob` to represent a single print job.
 *     *   It must have private fields: `id` (int), `fileName` (String), `pages` (int), and `status` (String).
 *     *   Define static final String constants or an enum for possible job statuses (e.g., "PENDING", "PROCESSING", "COMPLETED", "CANCELLED").
 *     *   Provide a constructor `PrintJob(int id, String fileName, int pages)` that initializes the fields and sets the initial status to "PENDING".
 *     *   Include public getter methods for all fields (`getId`, `getFileName`, `getPages`, `getStatus`).
 *     *   Include a public method `setStatus(String status)` to update the job's status.
 *     *   Override the `toString()` method to provide a clear string representation of the print job (e.g., "ID: [id], File: [fileName], Pages: [pages], Status: [status]").
 * 
 * 2.  **`PrintScheduler` Class:**
 *     *   Create a class `PrintScheduler` to manage the print jobs.
 *     *   It must have private fields:
 *         *   A `Queue<PrintJob>` to store jobs that are waiting to be processed.
 *         *   A `List<PrintJob>` to store jobs that have been completed or cancelled. You *must* declare this field as `List<PrintJob>` but instantiate it as `new ArrayList<PrintJob>()`.
 *         *   An integer `nextJobId` to assign unique IDs to new jobs, starting from 1.
 *     *   Provide a constructor that initializes these fields.
 *     *   Implement the following public methods:
 *         *   `addJob(String fileName, int pages)`: Creates a new `PrintJob` with the next available ID, adds it to the pending jobs queue, and increments `nextJobId`. Validate that `pages` is positive; if not, print an error using `System.err` and do not add the job.
 *         *   `processNextJob()`: Retrieves the next job from the pending jobs queue. If a job exists, change its status to "PROCESSING", simulate processing (you don't need actual printing logic, just update the status), change its status to "COMPLETED", and move it to the completed jobs list. If the queue is empty, print a message using `System.out`.
 *         *   `viewPendingJobs()`: Iterates through the pending jobs queue and prints details of each job using its `toString()` method. If the queue is empty, print a message.
 *         *   `viewCompletedJobs()`: Iterates through the completed jobs list and prints details of each job using its `toString()` method. If the list is empty, print a message.
 *         *   `run()`: This method should contain the main application loop. It should:
 *             *   Display a menu of options to the user (Add Job, Process Next Job, View Pending, View Completed, Exit).
 *             *   Use `Scanner` to read the user's choice.
 *             *   Use a `switch` statement to handle the different menu options.
 *             *   Prompt for necessary details (file name, pages) when adding a job.
 *             *   Handle potential `InputMismatchException` if the user enters non-integer input for menu choices or pages. Use `System.err` for these errors and clear the invalid input from the scanner.
 *             *   Wrap the main loop (or the core logic within `run`) in a `try-catch` block to demonstrate class-wide exception handling. Catch a general `Exception` and print an error message to `System.err`.
 * 
 * 3.  **`Main` Class:**
 *     *   Create a class with a `main` method.
 *     *   The `main` method should create an instance of `PrintScheduler` and call its `run()` method to start the application.
 * 
 * **General Requirements & Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (Javadoc where applicable).
 * *   Ensure input validation for numeric inputs.
 * *   Use `System.out` for normal output and `System.err` for error messages.
 * *   Ensure graceful handling of empty queues/lists.
 * *   The application should continue running until the user chooses to exit.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, accept user input, and display job information or status messages based on the chosen action. Error messages should be distinct (using `System.err`).
 * 
 * ```
 * --- Print Scheduler Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice:
 * ```
 * (Followed by prompts or output based on the choice)
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation according to requirements.
 * *   Proper usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Clean code structure and readability.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements a basic print job scheduler demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print job with `id`, `fileName`, `pages`, and `status`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides public getters and a status setter.
 *     *   Includes a `toString()` method for easy display, adhering to meaningful output.
 *     *   Defines status constants for clarity and maintainability.
 * 
 * 2.  **`PrintScheduler` Class:**
 *     *   **`Queue<PrintJob> pendingJobs`**: A `LinkedList` is used here as it implements the `Queue` interface and is efficient for adding to the end and removing from the beginning, which is the nature of a print queue (FIFO - First-In, First-Out). The `offer()` method is used for adding, and `poll()` for removing the head.
 *     *   **`List<PrintJob> completedJobs`**: This field is declared using the `List` interface type, but instantiated as `new ArrayList<PrintJob>()`. This demonstrates coding to the interface, which is a key Java best practice, while still using the required `ArrayList` implementation. `ArrayList` is suitable here as completed jobs are typically stored and iterated over, and random access isn't a primary concern (though ArrayList supports it).
 *     *   **`Scanner scanner`**: Used to read user input from the console. It's a class member so it can be managed and closed properly.
 *     *   **`nextJobId`**: A simple counter to ensure unique job IDs.
 *     *   **`addJob` method**: Creates a new `PrintJob` instance and adds it to the `pendingJobs` queue using `offer()`. It includes input validation for the number of pages, printing an error to `System.err` if invalid.
 *     *   **`processNextJob` method**: Uses `poll()` to get and remove the next job from the `pendingJobs` queue. It checks if the queue was empty. If a job is retrieved, it updates its status to "PROCESSING" and then "COMPLETED" (simulating the work) and adds it to the `completedJobs` `ArrayList`.
 *     *   **`viewPendingJobs` and `viewCompletedJobs` methods**: Iterate through their respective collections (`pendingJobs` queue and `completedJobs` list) and print the details of each job using the `PrintJob`'s `toString()` method. They check for emptiness and print appropriate messages. `pendingJobs.forEach()` and `completedJobs.forEach()` demonstrate using streams/lambda expressions for iteration, which is a modern Java feature.
 *     *   **`run` method**: This is the core of the application loop.
 *         *   It presents a menu using `System.out`.
 *         *   It uses a `while` loop to keep the application running until the user chooses to exit (option 5).
 *         *   It reads user input using the `Scanner`.
 *         *   A `switch` statement is used to direct the program flow based on the user's numerical choice, fulfilling the requirement.
 *         *   It includes a `try-catch` block specifically for `InputMismatchException` when reading integer inputs (`choice`, `pages`). This handles cases where the user types non-numeric characters, prints an error to `System.err`, and importantly, consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   The entire `while` loop within the `run` method is wrapped in a larger `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any other unexpected runtime errors that might occur during the execution of the scheduler's logic and printing them to `System.err` along with a stack trace.
 *         *   A `finally` block ensures the `Scanner` is closed when the `run` method finishes (either by exiting the loop or due to an exception), releasing system resources.
 *     *   **`printMenu` method**: A private helper method to keep the `run` method cleaner, responsible solely for displaying the menu options.
 * 
 * 3.  **`AdvancedPrintScheduler` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   It simply creates an instance of `PrintScheduler` and calls its `run()` method to start the interactive command-line interface.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** `private` fields and `public` methods in both classes.
 * *   **Meaningful Names:** Variables like `pendingJobs`, `completedJobs`, `fileName`, `pages`, methods like `addJob`, `processNextJob`, `viewPendingJobs` are descriptive.
 * *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic.
 * *   **Input Validation:** Explicit check for positive page numbers in `addJob`.
 * *   **Error Handling:** Specific `catch` for `InputMismatchException` for invalid input, general `catch(Exception e)` for unexpected errors, and using `System.err` for all error messages.
 * *   **Clean Code:** Separation of concerns into `PrintJob` and `PrintScheduler` classes, use of a helper method (`printMenu`), constants for status.
 * *   **List vs ArrayList:** Demonstrates programming to the interface (`List`) while using a concrete implementation (`ArrayList`).
 * *   **Queue Usage:** Correctly uses `Queue` methods (`offer`, `poll`) for FIFO behavior.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating robust input handling, error management, and adherence to core object-oriented principles.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    // Define job statuses
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_PROCESSING = "PROCESSING";
    public static final String STATUS_COMPLETED = "COMPLETED";
    public static final String STATUS_CANCELLED = "CANCELLED"; // Optional, but good practice

    private int id;
    private String fileName;
    private int pages;
    private String status;

    /**
     * Constructs a new PrintJob.
     *
     * @param id       The unique ID of the job.
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the job.
     */
    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
        this.status = STATUS_PENDING; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    /**
     * Sets the status of the print job.
     *
     * @param status The new status (use PrintJob.STATUS_ constants).
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, File: %s, Pages: %d, Status: %s",
                             id, fileName, pages, status);
    }
}

// Manages the queue and list of print jobs
class PrintScheduler {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs; // Declared as List, instantiated as ArrayList
    private int nextJobId;
    private Scanner scanner; // Scanner instance for input

    /**
     * Constructs a new PrintScheduler.
     */
    public PrintScheduler() {
        // Use LinkedList for the Queue implementation
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList for the List implementation
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the pending queue.
     *
     * @param fileName The name of the file.
     * @param pages    The number of pages.
     */
    public void addJob(String fileName, int pages) {
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive.");
            return;
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName, pages);
        pendingJobs.offer(newJob); // offer() is preferred for capacity-constrained queues, but works here too
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the pending queue.
     * Moves the job from pending to completed list.
     */
    public void processNextJob() {
        PrintJob jobToProcess = pendingJobs.poll(); // Retrieves and removes the head of the queue

        if (jobToProcess == null) {
            System.out.println("No pending jobs to process.");
        } else {
            System.out.println("Processing job: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getId() + ")");
            jobToProcess.setStatus(PrintJob.STATUS_PROCESSING);
            // Simulate processing... (in a real system, this would involve actual printing logic)
            try {
                Thread.sleep(100); // Simulate some work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt(); // Restore interrupted status
                System.err.println("Processing interrupted.");
            }
            jobToProcess.setStatus(PrintJob.STATUS_COMPLETED);
            completedJobs.add(jobToProcess); // Add to the completed list
            System.out.println("Job completed: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getId() + ")");
        }
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            // Iterate through the queue without removing elements
            pendingJobs.forEach(System.out::println);
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all jobs currently in the completed list.
     */
    public void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No completed jobs yet.");
        } else {
            // Iterate through the list
            completedJobs.forEach(System.out::println);
        }
        System.out.println("----------------------");
    }

    /**
     * Runs the main application loop, presenting a menu to the user.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch block wrapping the main operational loop
        try {
            while (choice != 5) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter file name: ");
                            String fileName = scanner.nextLine();
                            System.out.print("Enter number of pages: ");
                            int pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            addJob(fileName, pages);
                            break;
                        case 2:
                            processNextJob();
                            break;
                        case 3:
                            viewPendingJobs();
                            break;
                        case 4:
                            viewCompletedJobs();
                            break;
                        case 5:
                            System.out.println("Exiting Print Scheduler. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Print Scheduler Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}

// Main class to start the application
public class AdvancedPrintScheduler {
    public static void main(String[] args) {
        PrintScheduler scheduler = new PrintScheduler();
        scheduler.run();
    }
}
