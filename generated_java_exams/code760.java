/*
 * Exam Question #760
 * Generated on: 2025-05-12 16:36:54
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Package Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for managing packages in a small distribution center. The system should handle packages arriving for processing and keep a record of packages that have been processed.
 * 
 * Your system must implement the following functionalities via a command-line interface:
 * 
 * 1.  **Add Package:** Allow the user to input details for a new package (ID, destination address, weight) and add it to a queue for processing. The system should generate a unique ID for each package (a simple counter starting from 1 is sufficient). Input validation is required: destination cannot be empty, and weight must be a positive number.
 * 2.  **Process Next Package:** Take the next package from the front of the processing queue, simulate its processing (e.g., print a message), and move it to a list of processed packages. If the queue is empty, inform the user.
 * 3.  **View Processing Queue:** Display the details of all packages currently waiting in the processing queue, in the order they will be processed.
 * 4.  **View Processed Packages:** Display the details of all packages that have been processed.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be written in Java and adhere to the following technical constraints:
 * 
 * *   Use `java.util.Queue` to manage the packages waiting for processing. A `LinkedList` is a suitable concrete implementation.
 * *   Use `java.util.ArrayList` to store the history of processed packages.
 * *   Declare the history storage using the `java.util.List` interface (`List<Package> processedHistory = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to control the flow based on the user's menu selection.
 * *   Use `System.err.println()` to display error messages (e.g., invalid input, attempting to process an empty queue).
 * *   Use `System.out.println()` for all normal output (menu, package details, success messages).
 * *   Implement class-wide exception handling using `try-catch` blocks, particularly to handle potential issues with user input parsing and other runtime errors. The main application loop should be enclosed in a `try-catch` block.
 * 
 * **Best Practices:**
 * 
 * *   Apply proper encapsulation: Use private fields and public methods.
 * *   Use meaningful variable, method, and class names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * *   Implement robust input validation and error handling.
 * *   Structure your code cleanly into appropriate classes (e.g., a `Package` class and a `PackageDeliveryManager` class).
 * 
 * **Expected Output Structure:**
 * 
 * The program should present a menu to the user and respond based on their selection.
 * 
 * ```
 * --- Package Processing System ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processing Queue
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Upon selecting an option, the system should perform the action and potentially print relevant information or error messages before returning to the main menu (unless 'Exit' is chosen).
 * 
 * Example of adding a package:
 * ```
 * Enter destination: New York
 * Enter weight (kg): 5.7
 * Package P1 added to queue.
 * ```
 * 
 * Example of processing:
 * ```
 * Processing package P1 to New York (5.7 kg)...
 * Package P1 processed and moved to history.
 * ```
 * 
 * Example of processing empty queue:
 * ```
 * Error: The processing queue is empty. No packages to process.
 * ```
 * 
 * Example of invalid weight input:
 * ```
 * Enter destination: Los Angeles
 * Enter weight (kg): -2.5
 * Error: Weight must be a positive number.
 * ```
 * or
 * ```
 * Enter destination: Los Angeles
 * Enter weight (kg): abc
 * Error: Invalid input. Please enter a valid number for weight.
 * ```
 * 
 * This task requires integrating several core Java concepts and standard library classes to build a functional command-line application demonstrating queue processing, list management, user interaction, and error handling.
 *
 * EXPLANATION:
 * This solution implements a simple package processing system using the required Java components and best practices.
 * 
 * 1.  **`Package` Class:** This is a simple Plain Old Java Object (POJO) representing a package. It has private fields (`packageId`, `destination`, `weight`), a constructor, and public getter methods (`getPackageId`, `getDestination`, `getWeight`), demonstrating **encapsulation**. The `toString()` method provides a convenient way to display package information.
 * 
 * 2.  **`PackageDeliveryManager` Class:** This class encapsulates the core logic of the system.
 *     *   It uses a `java.util.Queue<Package>` named `processingQueue` to hold packages waiting to be processed. A `LinkedList` is chosen as the concrete implementation, which is suitable for queue operations (`add`, `poll`, `peek`).
 *     *   It uses a `java.util.List<Package>` named `processedHistory` to store packages after they have been processed. An `ArrayList` is used as the concrete implementation, declared with the `List` interface as required.
 *     *   `packageCounter` is a private field used to generate simple, unique package IDs.
 *     *   `addPackage()`: Creates a new `Package` object, generates its ID, and adds it to the `processingQueue` using `queue.add()`.
 *     *   `processNextPackage()`: Uses `queue.poll()` to retrieve and remove the head of the queue. `poll()` is safer than `remove()` as it returns `null` if the queue is empty, avoiding an exception. If a package is retrieved, it's added to the `processedHistory` list using `list.add()`.
 *     *   `getProcessingQueue()` and `getProcessedHistory()`: Public methods to allow the main application class to access the data (read-only in this case, though the `Queue` and `List` interfaces allow modification, which is acceptable for displaying contents).
 *     *   `isProcessingQueueEmpty()`: A helper method to check the queue's state.
 * 
 * 3.  **`DeliverySystemApp` Class:** This class contains the `main` method and handles the user interface and application flow.
 *     *   `Scanner`: A `java.util.Scanner` is used to read input from `System.in`.
 *     *   **Class-wide Exception Handling:** The main `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates handling potential unexpected runtime errors that might occur anywhere within the loop's execution, preventing the application from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 *     *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the user's integer choice from the menu, fulfilling the requirement for `switch` control flow.
 *     *   **Input Validation and Error Handling (within the `switch`):**
 *         *   The code attempts to read the menu choice as an integer. If `InputMismatchException` occurs (e.g., user enters text), it's caught, an error message is printed to `System.err`, the invalid input is consumed from the scanner, and the loop continues.
 *         *   When adding a package, it validates that the destination is not empty and the weight is positive. Error messages are printed to `System.err`.
 *         *   It specifically catches `InputMismatchException` when reading the weight, printing an error to `System.err` and consuming the invalid input.
 *         *   When processing a package, it checks if the queue is empty using `manager.isProcessingQueueEmpty()` before calling `processNextPackage()`. If empty, an error message is printed to `System.err`.
 *     *   **Output:** `System.out.println()` is used for printing the menu, success messages, and package details when viewing queues or history. `System.err.println()` is used exclusively for error conditions as required.
 *     *   **Viewing Queues/History:** The code iterates through the `processingQueue` and `processedHistory` to print their contents. For the queue, it iterates without removing elements (e.g., using `forEach` or an iterator), preserving the queue's state.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical, albeit simplified, application scenario, demonstrating encapsulation, input validation, and error handling as requested.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with ID, destination, and weight.
 */
class Package {
    private String packageId;
    private String destination;
    private double weight; // in kg

    /**
     * Constructs a new Package.
     * @param packageId The unique ID of the package.
     * @param destination The destination address.
     * @param weight The weight of the package in kg.
     */
    public Package(String packageId, String destination, double weight) {
        this.packageId = packageId;
        this.destination = destination;
        this.weight = weight;
    }

    // Getters
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the package.
     * @return String representation.
     */
    @Override
    public String toString() {
        return String.format("Package %s to %s (%.2f kg)", packageId, destination, weight);
    }
}

/**
 * Manages the package processing queue and processed package history.
 */
class PackageDeliveryManager {
    private Queue<Package> processingQueue;
    private List<Package> processedHistory;
    private int packageCounter; // To generate unique package IDs

    /**
     * Constructs a new PackageDeliveryManager.
     */
    public PackageDeliveryManager() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedHistory = new ArrayList<>();  // ArrayList implements List
        this.packageCounter = 0;
    }

    /**
     * Adds a new package to the processing queue.
     * Generates a unique package ID.
     * @param destination The destination address.
     * @param weight The weight of the package.
     * @return The newly created package.
     */
    public Package addPackage(String destination, double weight) {
        packageCounter++;
        String packageId = "P" + packageCounter;
        Package newPackage = new Package(packageId, destination, weight);
        processingQueue.add(newPackage);
        return newPackage;
    }

    /**
     * Processes the next package from the queue.
     * Moves the processed package to the history list.
     * @return The processed package, or null if the queue was empty.
     */
    public Package processNextPackage() {
        Package packageToProcess = processingQueue.poll(); // poll returns null if queue is empty
        if (packageToProcess != null) {
            processedHistory.add(packageToProcess);
        }
        return packageToProcess;
    }

    /**
     * Gets the current processing queue.
     * @return The queue of packages waiting for processing.
     */
    public Queue<Package> getProcessingQueue() {
        return processingQueue;
    }

    /**
     * Gets the list of processed packages.
     * @return The list of processed packages.
     */
    public List<Package> getProcessedHistory() {
        return processedHistory;
    }

    /**
     * Checks if the processing queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isProcessingQueueEmpty() {
        return processingQueue.isEmpty();
    }
}

/**
 * Main application class for the Package Processing System.
 * Handles user interaction and manages the PackageDeliveryManager.
 */
public class DeliverySystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PackageDeliveryManager manager = new PackageDeliveryManager();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                switch (choice) {
                    case 1: // Add New Package
                        System.out.print("Enter destination: ");
                        String destination = scanner.nextLine().trim();

                        double weight = -1;
                        System.out.print("Enter weight (kg): ");
                        try {
                            weight = scanner.nextDouble();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a valid number for weight.");
                            scanner.nextLine(); // Consume the invalid input
                            break; // Exit case 1, return to menu
                        }

                        // Input validation
                        if (destination.isEmpty()) {
                            System.err.println("Error: Destination cannot be empty.");
                        } else if (weight <= 0) {
                            System.err.println("Error: Weight must be a positive number.");
                        } else {
                            Package addedPackage = manager.addPackage(destination, weight);
                            System.out.println(addedPackage.toString() + " added to queue.");
                        }
                        break;

                    case 2: // Process Next Package
                        if (manager.isProcessingQueueEmpty()) {
                            System.err.println("Error: The processing queue is empty. No packages to process.");
                        } else {
                            Package processedPackage = manager.processNextPackage();
                            if (processedPackage != null) {
                                System.out.println("Processing " + processedPackage.toString() + "...");
                                System.out.println(processedPackage.toString() + " processed and moved to history.");
                            }
                            // Note: processNextPackage() returns null only if queue was empty,
                            // which is handled by the initial check. This part is defensive.
                        }
                        break;

                    case 3: // View Processing Queue
                        System.out.println("\n--- Processing Queue ---");
                        Queue<Package> queue = manager.getProcessingQueue();
                        if (queue.isEmpty()) {
                            System.out.println("The processing queue is empty.");
                        } else {
                            // Iterate through the queue without removing elements
                            queue.forEach(pkg -> System.out.println("- " + pkg.toString()));
                        }
                        System.out.println("------------------------");
                        break;

                    case 4: // View Processed Packages
                        System.out.println("\n--- Processed Packages History ---");
                        List<Package> history = manager.getProcessedHistory(); // Using List interface
                        if (history.isEmpty()) {
                            System.out.println("No packages have been processed yet.");
                        } else {
                            history.forEach(pkg -> System.out.println("- " + pkg.toString()));
                        }
                        System.out.println("----------------------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Package Processing System. Goodbye!");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed regardless of exceptions
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Package Processing System ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
    }
}
