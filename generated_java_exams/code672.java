/*
 * Exam Question #672
 * Generated on: 2025-05-12 16:23:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Attendee Management with Waiting List**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple application to manage attendees for a limited-capacity event. The system needs to handle registrations, cancellations, and maintain both a list of confirmed attendees and a waiting list for those who register after capacity is reached. When a confirmed attendee cancels, the first person on the waiting list (if any) should automatically be moved to the confirmed list.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Event Capacity:** The event has a fixed maximum capacity, specified when the system starts.
 * 2.  **Attendee Representation:** Create a simple `Attendee` class with at least a `name` (String). Ensure `equals()` and `hashCode()` methods are properly overridden based on the attendee's name so that attendees can be correctly identified and removed from collections.
 * 3.  **Data Structures:**
 *     *   Use a `java.util.List` (specifically an `ArrayList`) to store the **confirmed attendees**.
 *     *   Use a `java.util.Queue` (specifically a `LinkedList` implementation acting as a Queue) to store attendees on the **waiting list**. Attendees should be added to the end of the waiting list and removed from the front (FIFO).
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get input from the user.
 *     *   Present a menu of options:
 *         1.  Register Attendee
 *         2.  Cancel Registration
 *         3.  Display Attendees
 *         4.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 5.  **Registration Logic:**
 *     *   Prompt for the attendee's name.
 *     *   Validate that the name is not empty or just whitespace.
 *     *   Check if the attendee is already registered (either confirmed or on the waiting list). If so, report an error.
 *     *   If capacity is not reached, add the attendee to the confirmed list. Report success.
 *     *   If capacity is reached, add the attendee to the waiting list. Report that they are added to the waiting list.
 * 6.  **Cancellation Logic:**
 *     *   Prompt for the attendee's name to cancel.
 *     *   Validate that the name is not empty or just whitespace.
 *     *   Search for the attendee in the confirmed list.
 *         *   If found, remove them from the confirmed list.
 *         *   **Crucially:** If the waiting list is *not* empty, remove the *first* attendee from the waiting list and add them to the confirmed list. Report the cancellation and, if applicable, the attendee moved from the waiting list.
 *     *   If not found in the confirmed list, search in the waiting list.
 *         *   If found, remove them from the waiting list. Report the cancellation.
 *     *   If not found in *either* list, report an error.
 * 7.  **Display Logic:**
 *     *   Print the current event capacity.
 *     *   Print the number of confirmed attendees and list their names.
 *     *   Print the number of attendees on the waiting list and list their names.
 * 8.  **Error Handling:**
 *     *   Use `System.err.println()` for all error messages (e.g., invalid input, attendee not found, already registered, invalid capacity).
 *     *   Use `System.out.println()` for normal output (menu, prompts, success messages, display lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks. At a minimum, wrap the main application loop to catch unexpected runtime errors. Also, handle potential input issues (like non-integer input for menu choice or capacity).
 * 9.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure.
 *     *   Close the `Scanner` resource when done.
 * 
 * **Expected Output Structure (Example):**
 * 
 * ```
 * Enter event capacity: 5
 * Event capacity set to 5.
 * 
 * Event Management Menu:
 * 1. Register Attendee
 * 2. Cancel Registration
 * 3. Display Attendees
 * 4. Exit
 * Enter choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 1
 * Enter attendee name: Bob
 * Bob registered successfully.
 * 
 * ... (register 4 more people) ...
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 1
 * Enter attendee name: Charlie
 * Capacity reached. Charlie added to waiting list.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 3
 * Event Capacity: 5
 * Confirmed Attendees (5): [Alice, Bob, David, Eve, Frank]
 * Waiting List (1): [Charlie]
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 2
 * Enter attendee name: Bob
 * Bob cancelled registration. Charlie moved from waiting list to confirmed.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 3
 * Event Capacity: 5
 * Confirmed Attendees (5): [Alice, David, Eve, Frank, Charlie]
 * Waiting List (0): []
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 2
 * Enter attendee name: Unknown
 * Error: Attendee 'Unknown' not found.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 4
 * Exiting application.
 * ```
 * 
 * **Note:** For simplicity, assume attendee names are unique identifiers in this problem.
 *
 * EXPLANATION:
 * This solution implements the Event Attendee Management system using the required Java components and best practices.
 * 
 * 1.  **`Attendee` Class:**
 *     *   A simple class representing an attendee with a `private String name`.
 *     *   Includes a constructor, a public getter (`getName()`), and a `toString()` method for easy printing.
 *     *   Crucially, it overrides `equals()` and `hashCode()` based *only* on the `name` field. This is essential for collections like `ArrayList` and `Queue` to correctly identify and remove `Attendee` objects when searching or using methods like `contains()` or `remove()`. `Objects.equals()` and `Objects.hash()` are used for robustness, handling potential null names (though input validation prevents this here).
 * 
 * 2.  **`EventManager` Class:**
 *     *   Encapsulates the event's state: `capacity`, `confirmedAttendees`, and `waitingList`. These are `private` fields.
 *     *   `confirmedAttendees` is declared as `List<Attendee>` and initialized as an `ArrayList<Attendee>`. This demonstrates using the `List` interface while utilizing a concrete implementation (`ArrayList`) suitable for random access and dynamic resizing, which is fine for this use case (searching/removing by object equality).
 *     *   `waitingList` is declared as `Queue<Attendee>` and initialized as a `LinkedList<Attendee>`. `LinkedList` implements both `List` and `Queue`, making it a common choice when `Queue` behavior (FIFO: `offer`/`add`, `poll`/`remove`, `peek`/`element`) is needed. Here, we use `add()` for adding to the end and `poll()` for removing from the front, adhering to Queue's FIFO principle.
 *     *   The constructor validates the initial capacity, throwing an `IllegalArgumentException` if it's not positive.
 *     *   `registerAttendee(String name)`: Handles the registration logic. It performs input validation for the name, checks for duplicates in *both* lists, and adds the attendee to the appropriate list based on capacity, printing status messages using `System.out` or `System.err`.
 *     *   `cancelRegistration(String name)`: Handles cancellation. It first attempts removal from the `confirmedAttendees` list. If successful, it checks if the `waitingList` is non-empty. If so, it uses `waitingList.poll()` to get and remove the head of the queue and `confirmedAttendees.add()` to move them to the confirmed list. If not found in the confirmed list, it attempts removal from the `waitingList`. Error messages for not finding the attendee are printed to `System.err`.
 *     *   `displayAttendees()`: Prints the current state of both lists to `System.out`. It iterates through the collections to print attendee names.
 * 
 * 3.  **`EventApp` Class (Main Application):**
 *     *   Contains the `main` method where execution begins.
 *     *   Uses `Scanner` to interact with the user.
 *     *   Includes a loop to get and validate the initial event capacity, ensuring a positive integer is entered. `try-catch` blocks handle `InputMismatchException` for non-integer input and `IllegalArgumentException` from the `EventManager` constructor. `System.err` is used for error messages.
 *     *   The main application loop runs until the user chooses to exit.
 *     *   A `switch` statement processes the user's menu choice, calling the appropriate methods on the `eventManager` instance.
 *     *   Input validation for menu choice (checking if it's an integer) is done using `try-catch`.
 *     *   A broad `try-catch(Exception e)` block wraps the main `while` loop. This serves as a class-wide handler for any unexpected runtime exceptions that might occur within the main application flow (beyond specific input or business logic errors handled elsewhere), printing the error to `System.err` and providing a stack trace for debugging.
 *     *   The `Scanner` resource is closed using `scanner.close()` after the main loop finishes.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Effective use of `List` (`ArrayList`) for a dynamic, searchable collection and `Queue` (`LinkedList`) for a FIFO waiting list, showcasing their appropriate use cases.
 * *   **Object-Oriented Programming:** Encapsulation in `Attendee` and `EventManager` classes, meaningful names, and overriding `equals`/`hashCode`.
 * *   **User Input:** Using `Scanner` for interactive console input.
 * *   **Control Flow:** Using a `switch` statement for a menu-driven interface and `while` loops for application flow and input validation loops.
 * *   **Error Handling:**
 *     *   Specific input validation checks (empty names, positive capacity).
 *     *   Using `System.err` for distinct error output.
 *     *   Using `try-catch` blocks for handling expected input errors (`InputMismatchException`) and providing a class-wide catch-all for unexpected runtime exceptions.
 * *   **API Usage:** Practical application of methods from `java.util.ArrayList`, `java.util.LinkedList`, `java.util.Queue`, `java.util.List`, `java.util.Scanner`, and `java.util.Objects`.
 * 
 * This solution provides a clear, well-structured, and robust implementation that meets all the requirements of the challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Objects; // Required for Objects.equals and Objects.hash

/**
 * Represents an attendee for the event.
 */
class Attendee {
    private String name;

    /**
     * Constructs an Attendee with the given name.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the Attendee.
     * @return The attendee's name as a string.
     */
    @Override
    public String toString() {
        return name;
    }

    /**
     * Checks if this Attendee is equal to another object.
     * Equality is based solely on the attendee's name.
     * @param o The object to compare with.
     * @return true if the objects are equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return Objects.equals(name, attendee.name);
    }

    /**
     * Returns a hash code value for the Attendee.
     * The hash code is based solely on the attendee's name.
     * @return A hash code value for this object.
     */
    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}

/**
 * Manages event attendees, including confirmed and waiting lists.
 */
class EventManager {
    private int capacity;
    private List<Attendee> confirmedAttendees;
    private Queue<Attendee> waitingList;

    /**
     * Constructs an EventManager with a specified capacity.
     * @param capacity The maximum number of confirmed attendees.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public EventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Event capacity must be positive.");
        }
        this.capacity = capacity;
        this.confirmedAttendees = new ArrayList<>(); // Using ArrayList for confirmed list
        this.waitingList = new LinkedList<>();     // Using LinkedList as a Queue for waiting list
    }

    /**
     * Registers an attendee for the event.
     * Adds to confirmed list if capacity available, otherwise to waiting list.
     * @param name The name of the attendee to register.
     * @return true if registration process was initiated (success or waiting list), false if validation failed or already registered.
     */
    public boolean registerAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return false;
        }

        String trimmedName = name.trim();
        Attendee newAttendee = new Attendee(trimmedName);

        // Check if already registered
        if (confirmedAttendees.contains(newAttendee) || waitingList.contains(newAttendee)) {
            System.err.println("Error: Attendee '" + trimmedName + "' is already registered.");
            return false;
        }

        // Check capacity
        if (confirmedAttendees.size() < capacity) {
            confirmedAttendees.add(newAttendee);
            System.out.println(trimmedName + " registered successfully.");
        } else {
            waitingList.add(newAttendee);
            System.out.println("Capacity reached. " + trimmedName + " added to waiting list.");
        }
        return true;
    }

    /**
     * Cancels an attendee's registration.
     * If a confirmed attendee cancels and the waiting list is not empty,
     * moves the first person from the waiting list to the confirmed list.
     * @param name The name of the attendee to cancel.
     * @return true if cancellation was successful, false if attendee not found or validation failed.
     */
    public boolean cancelRegistration(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return false;
        }

        String trimmedName = name.trim();
        Attendee attendeeToCancel = new Attendee(trimmedName);
        boolean cancelled = false;

        // Try to cancel from confirmed list
        if (confirmedAttendees.remove(attendeeToCancel)) {
            System.out.println(trimmedName + " cancelled registration.");
            cancelled = true;

            // If someone cancelled from confirmed, check waiting list
            if (!waitingList.isEmpty()) {
                Attendee movedAttendee = waitingList.poll(); // Remove from front of queue
                confirmedAttendees.add(movedAttendee);     // Add to confirmed list
                System.out.println(movedAttendee.getName() + " moved from waiting list to confirmed.");
            }
        } else {
            // If not in confirmed, try to cancel from waiting list
            if (waitingList.remove(attendeeToCancel)) {
                System.out.println(trimmedName + " cancelled registration from waiting list.");
                cancelled = true;
            }
        }

        if (!cancelled) {
            System.err.println("Error: Attendee '" + trimmedName + "' not found.");
            return false;
        }
        return true;
    }

    /**
     * Displays the current state of confirmed attendees and the waiting list.
     */
    public void displayAttendees() {
        System.out.println("\n--- Event Status ---");
        System.out.println("Event Capacity: " + capacity);

        System.out.println("Confirmed Attendees (" + confirmedAttendees.size() + "):");
        if (confirmedAttendees.isEmpty()) {
            System.out.println("  No confirmed attendees yet.");
        } else {
            for (Attendee attendee : confirmedAttendees) {
                System.out.println("  - " + attendee.getName());
            }
        }

        System.out.println("Waiting List (" + waitingList.size() + "):");
        if (waitingList.isEmpty()) {
            System.out.println("  Waiting list is empty.");
        } else {
            // Iterate over the queue without removing elements
            for (Attendee attendee : waitingList) {
                System.out.println("  - " + attendee.getName());
            }
        }
        System.out.println("--------------------\n");
    }
}

/**
 * Main application class for the Event Attendee Management system.
 */
public class EventApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = null;

        // --- Get and validate capacity ---
        while (eventManager == null) {
            System.out.print("Enter event capacity: ");
            try {
                int capacity = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over
                eventManager = new EventManager(capacity);
                System.out.println("Event capacity set to " + capacity + ".");
            } catch (java.util.InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for capacity.");
                scanner.nextLine(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) { // Catch any other unexpected errors during setup
                 System.err.println("An unexpected error occurred during setup: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to error stream
            }
        }

        // --- Main application loop ---
        boolean running = true;
        while (running) {
            try { // Class-wide exception handling for the main loop operations
                System.out.println("Event Management Menu:");
                System.out.println("1. Register Attendee");
                System.out.println("2. Cancel Registration");
                System.out.println("3. Display Attendees");
                System.out.println("4. Exit");
                System.out.print("Enter choice: ");

                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        System.out.print("Enter attendee name: ");
                        String regName = scanner.nextLine();
                        eventManager.registerAttendee(regName);
                        break;
                    case 2:
                        System.out.print("Enter attendee name to cancel: ");
                        String cancelName = scanner.nextLine();
                        eventManager.cancelRegistration(cancelName);
                        break;
                    case 3:
                        eventManager.displayAttendees();
                        break;
                    case 4:
                        System.out.println("Exiting application.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (java.util.InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) { // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
        }

        scanner.close(); // Close the scanner resource
        System.out.println("Scanner closed.");
    }
}
