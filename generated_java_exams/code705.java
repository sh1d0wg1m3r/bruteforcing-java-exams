/*
 * Exam Question #705
 * Generated on: 2025-05-12 16:28:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Task Dispatcher System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified Task Dispatcher system for managing and processing various types of system operations. The system should allow users to add new tasks to a queue for processing, process the next task in the queue, view tasks that are currently pending, and view tasks that have been successfully completed. The system needs to handle different task types and simulate potential errors during task processing.
 * 
 * Your solution must be a single Java application consisting of multiple classes (e.g., `Task`, `TaskDispatcher`, and the main application class) and demonstrate advanced understanding of core Java concepts and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Users should interact with the system via a command-line interface.
 *     *   The system must maintain a collection of tasks waiting to be processed. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   The system must maintain a separate collection of tasks that have been successfully processed.
 *     *   Users should be able to:
 *         *   Add a new task (specify type and description).
 *         *   Process the next task from the pending queue.
 *         *   View all pending tasks (without removing them).
 *         *   View all completed tasks.
 *         *   Exit the application.
 * 
 * 2.  **Task Definition:**
 *     *   Define a `Task` class representing an individual unit of work.
 *     *   Each `Task` should have a unique ID, a type (e.g., `PROCESS_DATA`, `GENERATE_REPORT`, `SEND_NOTIFICATION`), and a description. Use an `enum` for task types.
 * 
 * 3.  **Dispatcher Logic:**
 *     *   Create a `TaskDispatcher` class responsible for managing the collections of pending and completed tasks and handling the processing logic.
 *     *   The `TaskDispatcher` should have methods like `addTask()`, `processNextTask()`, `viewPendingTasks()`, `viewCompletedTasks()`.
 * 
 * 4.  **Required Java Components:** Your solution **must** explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue`: For managing pending tasks (FIFO).
 *     *   `java.util.ArrayList`: For storing completed tasks.
 *     *   `java.util.List`: Use `List` as the declared type for the completed tasks collection variable (programming to the interface).
 *     *   `java.util.Scanner`: For reading user input from the console.
 *     *   `switch` statement: For handling user commands in the main application loop and potentially for different task processing logic.
 *     *   `System.err`: For printing error messages (e.g., invalid input, processing failures).
 *     *   `System.out`: For printing normal output (menus, prompts, task details, success messages).
 *     *   Class-wide exception handling with `try-catch` blocks: Implement `try-catch` blocks to handle potential issues during user input or task processing. A main `try-catch` block should wrap the core application loop for robust handling of unexpected errors.
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (at least basic class/method descriptions).
 *     *   Include input validation (e.g., ensuring user enters a valid command number, handling non-integer input).
 *     *   Implement proper error handling (catching exceptions, providing informative error messages via `System.err`).
 *     *   Maintain a clean and organized code structure.
 * 
 * **Simulated Task Processing Error:**
 * 
 * In the `processNextTask` method, simulate a potential failure for at least one task type (e.g., `PROCESS_DATA` or `SEND_NOTIFICATION`) by throwing a `RuntimeException` based on a random chance (e.g., 10% probability). The `processNextTask` method should catch this specific error, report it using `System.err`, and prevent the failed task from being added to the completed tasks list.
 * 
 * **Expected Output:**
 * 
 * The system should present a menu to the user. Based on the user's numerical input, it should perform the corresponding action. Output should be clear, indicating when tasks are added, processed, viewed, or when errors occur.
 * 
 * Example Interaction (partial):
 * 
 * ```
 * Task Dispatcher System
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter command: 1
 * Select Task Type:
 * 1. PROCESS_DATA
 * 2. GENERATE_REPORT
 * 3. SEND_NOTIFICATION
 * Enter task type number: 1
 * Enter task description: Important data cleanup
 * Task added: Task #1 [PROCESS_DATA]: Important data cleanup
 * 
 * --- Menu ---
 * 1. Add New Task
 * ...
 * Enter command: 2
 * Processing task: Task #1 [PROCESS_DATA]: Important data cleanup
 *   -> Processing data for task 1
 * Error processing task 1: Simulated data processing error!
 * 
 * --- Menu ---
 * 1. Add New Task
 * ...
 * Enter command: 2
 * No tasks pending.
 * 
 * --- Menu ---
 * 1. Add New Task
 * ...
 * Enter command: 4
 * 
 * --- Completed Tasks ---
 * No tasks completed yet.
 * -----------------------
 * 
 * --- Menu ---
 * 1. Add New Task
 * ...
 * Enter command: 5
 * Exiting Task Dispatcher.
 * Application terminated.
 * ```
 * 
 * **Note:** Your solution should be a single `.java` file containing all necessary classes for submission in an exam context.
 *
 * EXPLANATION:
 * This solution implements the Task Dispatcher system using the required Java components and best practices.
 * 
 * 1.  **Class Structure:** The system is divided into three classes:
 *     *   `TaskType` (enum): Defines the possible categories of tasks. Enums are used for type safety and clarity.
 *     *   `Task`: Represents a single task object, holding its unique ID, type, and description. It uses a static counter (`nextId`) to ensure each task gets a unique identifier. Encapsulation is used with private fields and public getters.
 *     *   `TaskDispatcher`: Manages the state of the system (pending and completed tasks) and the core logic (adding and processing). It uses a `Queue` for pending tasks (FIFO) and a `List` (implemented by `ArrayList`) for completed tasks. This demonstrates programming to the interface (`List`).
 *     *   `TaskDispatcherApp`: Contains the `main` method, handles user interaction via `Scanner`, presents the menu, and delegates operations to the `TaskDispatcher`.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: The `pendingTasks` field in `TaskDispatcher` is declared as `Queue<Task>` and initialized with a `LinkedList` instance, which is a common `Queue` implementation. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove the next task in FIFO order.
 *     *   `ArrayList`: The `completedTasks` field is initialized with an `ArrayList` instance.
 *     *   `List`: The `completedTasks` field is declared using the `List<Task>` interface type, demonstrating good practice.
 *     *   `Scanner`: An instance of `Scanner` is used in `TaskDispatcherApp.main` to read user input from `System.in`. Input validation for integers (`nextInt()`) is combined with consuming the remaining newline (`nextLine()`) to prevent issues when subsequently reading strings.
 *     *   `switch` statement: Used in `TaskDispatcherApp.main` to handle the different main menu commands entered by the user. It's also used within `TaskDispatcher.processNextTask` to execute different simulation logic based on the `TaskType`.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid user input, simulated task processing failures, and unexpected fatal errors caught by the main `try-catch` block.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, confirmation messages for adding tasks, notifications about processing tasks, and displaying the contents of the pending and completed task lists.
 *     *   `try-catch`:
 *         *   The main `while` loop in `TaskDispatcherApp.main` is wrapped in a `try-catch(Exception e)` block. This provides class-wide exception handling for any unexpected errors that might occur during the application's execution, printing the error details to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *         *   Specific `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls to handle cases where the user enters non-integer input, preventing the program from crashing and providing an informative message via `System.err`.
 *         *   The `TaskDispatcher.processNextTask` method includes a `try-catch(RuntimeException e)` block specifically to catch the simulated processing errors (and the unknown type error), allowing the application to continue running even if a single task fails. The error is reported using `System.err`.
 * 
 * 3.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskDispatcher` are `private`, accessed only through public methods (getters, adders, processors, viewers).
 *     *   **Meaningful Names:** Class names (`Task`, `TaskDispatcher`, `TaskDispatcherApp`), enum names (`TaskType`), variable names (`pendingTasks`, `completedTasks`, `taskToProcess`, `description`), and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `printMenu`) are descriptive.
 *     *   **Comments/Documentation:** Basic Javadoc comments are provided for classes and methods to explain their purpose.
 *     *   **Input Validation:** The code checks if numerical inputs are within expected ranges (e.g., task type number) and uses `try-catch` to handle non-numerical input gracefully.
 *     *   **Error Handling:** Errors are caught using `try-catch`, reported using `System.err`, and the application attempts to recover or exit cleanly depending on the error severity (task processing errors are handled per-task, fatal errors stop the main loop).
 *     *   **Clean Code Structure:** The logic is separated into distinct classes with clear responsibilities. The `main` method focuses on user interaction and orchestration, while `TaskDispatcher` handles the core data structures and processing logic. Helper methods like `printMenu` improve readability.
 * 
 * 4.  **Simulated Error:** The `processNextTask` method uses `random.nextDouble()` to introduce a probability of throwing a `RuntimeException` for `PROCESS_DATA` and `SEND_NOTIFICATION` tasks, demonstrating how the `try-catch` block within the processing logic handles these specific failures without stopping the entire application. Failed tasks are not added to the `completedTasks` list.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating key concepts like object-oriented design, collection usage, user input handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList; // A common List implementation
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random; // For simulating errors

/**
 * Enum representing the different types of tasks the dispatcher can handle.
 */
enum TaskType {
    PROCESS_DATA,
    GENERATE_REPORT,
    SEND_NOTIFICATION
}

/**
 * Represents a single task with a unique ID, type, and description.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private TaskType type;
    private String description;

    /**
     * Constructs a new Task.
     * @param type The type of the task.
     * @param description A brief description of the task.
     */
    public Task(TaskType type, String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.type = type;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public TaskType getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including ID, type, and description.
     */
    @Override
    public String toString() {
        return String.format("Task #%d [%s]: %s", id, type, description);
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 * Handles adding tasks and processing the next task.
 */
class TaskDispatcher {
    private Queue<Task> pendingTasks; // Use Queue for FIFO
    private List<Task> completedTasks; // Use List interface, implemented by ArrayList
    private Random random; // For simulating processing errors

    /**
     * Constructs a new TaskDispatcher.
     * Initializes the pending and completed task collections.
     */
    public TaskDispatcher() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add. Must not be null.
     */
    public void addTask(Task task) {
        if (task == null) {
            System.err.println("Error: Cannot add a null task.");
            return; // Or throw IllegalArgumentException
        }
        pendingTasks.offer(task); // offer is preferred over add for queues (returns false on failure)
        System.out.println("Task added: " + task);
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates processing logic based on task type and handles potential errors.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue, returns null if empty

        if (taskToProcess == null) {
            System.out.println("No tasks pending.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);

        try {
            // Simulate processing based on task type using a switch statement
            switch (taskToProcess.getType()) {
                case PROCESS_DATA:
                    System.out.println("  -> Simulating data processing for task " + taskToProcess.getId());
                    // Simulate a chance of failure for PROCESS_DATA
                    if (random.nextDouble() < 0.2) { // 20% chance of failure
                        throw new RuntimeException("Simulated data processing error!");
                    }
                    // Simulate work time
                    Thread.sleep(200);
                    break;
                case GENERATE_REPORT:
                    System.out.println("  -> Simulating report generation for task " + taskToProcess.getId());
                    // Simulate work time
                    Thread.sleep(150);
                    break;
                case SEND_NOTIFICATION:
                    System.out.println("  -> Simulating sending notification for task " + taskToProcess.getId());
                     // Simulate a chance of failure for SEND_NOTIFICATION
                     if (random.nextDouble() < 0.1) { // 10% chance of failure
                        throw new RuntimeException("Simulated notification sending error!");
                    }
                    // Simulate work time
                    Thread.sleep(100);
                    break;
                default:
                    // This case should ideally not be reachable with the current enum setup
                    System.err.println("Unknown task type encountered for task " + taskToProcess.getId());
                    // Treat as a processing failure
                    throw new RuntimeException("Unknown task type processing error.");
            }

            // If processing was successful (no exception thrown)
            System.out.println("Task " + taskToProcess.getId() + " completed successfully.");
            completedTasks.add(taskToProcess); // Add to the completed list

        } catch (RuntimeException e) {
            // Catch simulated processing errors or unknown type errors
            System.err.println("Error processing task " + taskToProcess.getId() + ": " + e.getMessage());
            // Task is NOT added to completedTasks
        } catch (InterruptedException e) {
             // Handle potential interruption during sleep
             System.err.println("Task processing interrupted for task " + taskToProcess.getId());
             Thread.currentThread().interrupt(); // Restore interrupt flag
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Tasks are not removed from the queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate through the queue without removing elements
            // Using forEach with lambda for conciseness
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been successfully completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the list of completed tasks
             completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Gets the number of tasks currently pending.
     * @return The number of pending tasks.
     */
    public int getPendingTaskCount() {
        return pendingTasks.size();
    }
}

/**
 * Main application class for the Task Dispatcher system.
 * Handles user interaction and orchestrates the TaskDispatcher.
 */
public class TaskDispatcherApp {

    /**
     * Main method to run the Task Dispatcher application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskDispatcher dispatcher = new TaskDispatcher();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Task Dispatcher System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");

                int command = -1;
                try {
                    command = scanner.nextInt(); // Read integer input for command
                } catch (InputMismatchException e) {
                    // Handle non-integer input gracefully
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid token to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    // Consume the rest of the line after reading the integer command
                    // This is crucial before calling nextLine() later
                    scanner.nextLine();
                }

                // Use a switch statement for command processing
                switch (command) {
                    case 1: // Add New Task
                        System.out.println("Select Task Type:");
                        // List task types from the enum
                        TaskType[] types = TaskType.values();
                        for (int i = 0; i < types.length; i++) {
                            System.out.println((i + 1) + ". " + types[i]);
                        }
                        System.out.print("Enter task type number: ");

                        int typeChoice = -1;
                        try {
                            typeChoice = scanner.nextInt();
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for task type.");
                            scanner.next(); // Consume invalid input
                            continue; // Go back to main menu
                        } finally {
                             // Consume the rest of the line after reading the integer type choice
                             scanner.nextLine();
                        }

                        TaskType selectedType = null;
                        if (typeChoice >= 1 && typeChoice <= types.length) {
                            selectedType = types[typeChoice - 1];
                        } else {
                            System.err.println("Invalid task type selection.");
                            continue; // Go back to main menu
                        }

                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine(); // Read the full line for description

                        dispatcher.addTask(new Task(selectedType, description));
                        break;

                    case 2: // Process Next Task
                        dispatcher.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        dispatcher.viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        dispatcher.viewCompletedTasks();
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Dispatcher.");
                        break;

                    default:
                        System.err.println("Invalid command. Please try again.");
                }
            } // End while loop
        } catch (Exception e) {
            // Catch any other unexpected exceptions during runtime
            System.err.println("\nAn unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks (" + dispatcher.getPendingTaskCount() + " pending)");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
