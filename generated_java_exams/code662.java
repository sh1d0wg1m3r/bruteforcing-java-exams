/*
 * Exam Question #662
 * Generated on: 2025-05-12 16:21:59
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a command-line application for a small team to manage their tasks. The system should allow users to add tasks with different priority levels, process tasks based on their priority, and view lists of waiting and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (enum). Implement a `Priority` enum with levels `HIGH`, `MEDIUM`, and `LOW`.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for holding and managing tasks.
 *     *   Waiting tasks must be stored in a way that allows processing the highest priority tasks first. Within the same priority level, tasks should be processed in First-In-First-Out (FIFO) order. You **must** use `java.util.Queue` (specifically, a concrete implementation like `LinkedList`) for managing waiting tasks. Consider using separate queues for each priority level to simplify FIFO within priority.
 *     *   Completed tasks must be stored in a list. You **must** use `java.util.ArrayList` for this purpose.
 *     *   Provide methods to add a task, process the next task, retrieve waiting tasks, and retrieve completed tasks.
 * 3.  **Command-Line Interface:** Implement a main application class (e.g., `TaskApp`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input for menu options, task details (description, priority).
 *     *   Implement a menu with the following options using a `switch` statement:
 *         1.  Add Task
 *         2.  Process Next Task
 *         3.  List Waiting Tasks
 *         4.  List Completed Tasks
 *         5.  Exit
 *     *   The "Process Next Task" option should select the next task based on the priority logic (HIGH -> MEDIUM -> LOW, FIFO within priority), remove it from the waiting list, and add it to the completed list.
 * 4.  **Input Validation & Error Handling:**
 *     *   Validate user input for task description (must not be empty) and priority (must be one of "HIGH", "MEDIUM", "LOW", case-insensitive).
 *     *   Handle the case where the user attempts to process a task when no tasks are waiting.
 *     *   Use `System.out` for all normal output (menu, prompts, task lists, success messages).
 *     *   Use `System.err` for all error messages (invalid input, no tasks to process).
 *     *   Implement class-wide exception handling using `try-catch` blocks. At a minimum, wrap the main application loop or critical operations in `main` to catch potential exceptions (like `InputMismatchException` from `Scanner` or custom exceptions from `TaskManager`).
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (private fields, public methods) for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary.
 *     *   Use the `java.util.List` interface where appropriate (e.g., as return types for methods returning collections).
 * 
 * **Task Prioritization Logic Details:**
 * 
 * When the user selects "Process Next Task":
 * - The system should first check if there are any tasks in the HIGH priority queue. If yes, take the task at the front of this queue.
 * - If the HIGH priority queue is empty, check the MEDIUM priority queue. If not empty, take the task at the front.
 * - If both HIGH and MEDIUM queues are empty, check the LOW priority queue. If not empty, take the task at the front.
 * - If all queues are empty, report an error using `System.err`.
 * 
 * **Expected Output:**
 * 
 * - A clear menu is displayed upon starting.
 * - Prompts guide the user through adding tasks.
 * - Task lists are printed clearly showing description and priority.
 * - Success messages confirm actions.
 * - Error messages are printed to `System.err` when input is invalid or actions cannot be performed (e.g., processing with no waiting tasks).
 * - The application exits cleanly when option 5 is selected.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * - Correct implementation of all required features.
 * - Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * - Effective use of `try-catch` for error handling.
 * - Adherence to best practices (encapsulation, naming, validation, comments).
 * - Correct implementation of the task prioritization logic.
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a simple command-line task management system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `TaskManager` class uses three `Queue` instances (`highPriorityQueue`, `mediumPriorityQueue`, `lowPriorityQueue`), implemented specifically using `java.util.LinkedList`. This fulfills the requirement to use `Queue`. Tasks are added using `offer()` and removed using `poll()`, adhering to the standard `Queue` operations. The use of separate queues for each priority level ensures that tasks within the same priority are processed in FIFO order, and the `processNextTask` logic checks the queues in priority order (HIGH first, then MEDIUM, then LOW).
 * 
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `TaskManager` uses an `ArrayList` named `completedTasks` to store tasks that have been processed. This directly satisfies the requirement to use `ArrayList`. Tasks are added to this list using the `add()` method after being processed.
 * 
 * 3.  **`List` interface (`java.util.List`)**: The `getWaitingTasks()` and `getCompletedTasks()` methods in `TaskManager` are designed to return collections as the `List` interface. Although the underlying implementations are `ArrayList` and a combined list from queues (also built using `ArrayList`), returning the `List` interface is a good practice as it provides abstraction and allows flexibility if the internal collection type were to change in the future. The `completedTasks` field itself is also declared as `List<Task>`, further demonstrating the use of the interface.
 * 
 * 4.  **`Scanner` (`java.util.Scanner`)**: The `TaskApp` class uses a `Scanner` instance (`scanner`) to read user input from `System.in` for menu choices, task descriptions, and priorities. Methods like `nextInt()` and `nextLine()` are used to capture different input types. The scanner is properly closed in a `finally` block.
 * 
 * 5.  **`Switch` statement**: A `switch` statement is used prominently in the `TaskApp.runMenu()` method to handle the different menu options selected by the user. Another `switch` statement is used in `TaskManager.addTask()` to direct the task to the correct priority queue based on the task's priority enum value.
 * 
 * 6.  **`System.err`**: `System.err` is used consistently throughout the `TaskApp` class to print error messages. This includes messages for invalid menu choices, invalid input during task creation (empty description, invalid priority string), and the message thrown by the `NoTasksAvailableException` when attempting to process a task with no waiting tasks.
 * 
 * 7.  **`System.out`**: `System.out` is used for all standard output, such as printing the menu, prompts for user input, success messages (task added, task processed), and lists of waiting and completed tasks.
 * 
 * 8.  **Class-wide exception handling with `try-catch`**: The `main` method in `TaskApp` contains a `try-catch` block that wraps the call to `runMenu()`. This provides a top-level handler for any uncaught exceptions that might propagate up from the application logic, ensuring the program doesn't crash abruptly. Additionally, the `runMenu()` method itself contains a nested `try-catch` block inside its loop. This inner `try-catch` handles specific, anticipated exceptions like `InputMismatchException` (from `Scanner`), `NoTasksAvailableException` (a custom exception thrown by `TaskManager`), and `IllegalArgumentException` (thrown by `Priority.valueOf()` during invalid priority input). Handling these specific exceptions within the loop allows the program to print an error message and continue running the menu, which is user-friendly behavior. A custom exception `NoTasksAvailableException` is defined and thrown by `TaskManager.processNextTask()` when no tasks are available, demonstrating custom error types.
 * 
 * 9.  **Best Practices**:
 *     *   **Encapsulation**: Fields in `Task` and `TaskManager` are declared as `private`, and access is provided through public getter methods.
 *     *   **Meaningful Names**: Classes (`Task`, `TaskManager`, `TaskApp`), methods (`addTask`, `processNextTask`, `getWaitingTasks`), variables (`description`, `priority`, `highPriorityQueue`), and the enum (`Priority`) have names that clearly indicate their purpose.
 *     *   **Comments/Documentation**: Basic comments explain the purpose of classes, methods, and key logic sections. Javadoc-style comments are used for public methods.
 *     *   **Input Validation**: Input validation is performed in the `addTask` method (checking for empty description) and implicitly by using `Priority.valueOf()` which throws `IllegalArgumentException` for invalid priority strings. These validation errors are caught and reported using `System.err`.
 *     *   **Proper Error Handling**: Specific exceptions are caught where appropriate (`InputMismatchException`, `NoTasksAvailableException`, `IllegalArgumentException`), and general exceptions are caught at the top level. Error messages are directed to `System.err`.
 *     *   **Clean Code Structure**: The code is organized into separate classes (`Task`, `TaskManager`, `TaskApp`) and an enum (`Priority`), each with a single responsibility, promoting modularity and readability.
 * 
 * The solution effectively integrates the required components into a functional, practical application, demonstrating understanding of core Java concepts, collection usage, exception handling, and basic command-line interaction design.
 */

import java.util.Scanner;
import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.InputMismatchException;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Custom Exception for when no tasks are available to process
class NoTasksAvailableException extends Exception {
    public NoTasksAvailableException(String message) {
        super(message);
    }
}

// Represents a single task
class Task {
    private String description;
    private Priority priority;

    public Task(String description, Priority priority) {
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

// Manages the queues of waiting tasks and the list of completed tasks
class TaskManager {
    // Using LinkedList as a concrete implementation of Queue for FIFO
    private Queue<Task> highPriorityQueue;
    private Queue<Task> mediumPriorityQueue;
    private Queue<Task> lowPriorityQueue;
    // Using ArrayList as a concrete implementation of List
    private List<Task> completedTasks;

    public TaskManager() {
        highPriorityQueue = new LinkedList<>();
        mediumPriorityQueue = new LinkedList<>();
        lowPriorityQueue = new LinkedList<>();
        completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a task to the appropriate priority queue.
     * Input validation for description and priority should ideally happen before calling this.
     */
    public void addTask(String description, Priority priority) {
        Task newTask = new Task(description, priority);
        // Using switch statement to direct tasks based on priority
        switch (priority) {
            case HIGH:
                highPriorityQueue.offer(newTask); // offer() is preferred over add() as it doesn't throw exception on failure
                break;
            case MEDIUM:
                mediumPriorityQueue.offer(newTask);
                break;
            case LOW:
                lowPriorityQueue.offer(newTask);
                break;
        }
        System.out.println("Task added: " + newTask); // System.out for success message
    }

    /**
     * Processes the next task based on priority (HIGH > MEDIUM > LOW).
     * Within the same priority, processes the oldest task (FIFO).
     * Moves the processed task to the completed list.
     * @return The processed task.
     * @throws NoTasksAvailableException if no tasks are waiting in any queue.
     */
    public Task processNextTask() throws NoTasksAvailableException {
        Task taskToProcess = null;

        // Check queues in priority order (HIGH -> MEDIUM -> LOW)
        if (!highPriorityQueue.isEmpty()) {
            taskToProcess = highPriorityQueue.poll(); // poll() retrieves and removes the head of the queue
        } else if (!mediumPriorityQueue.isEmpty()) {
            taskToProcess = mediumPriorityQueue.poll();
        } else if (!lowPriorityQueue.isEmpty()) {
            taskToProcess = lowPriorityQueue.poll();
        }

        // If no task was found in any queue
        if (taskToProcess == null) {
            throw new NoTasksAvailableException("No tasks are currently waiting to be processed.");
        }

        // Add the processed task to the completed list (ArrayList)
        completedTasks.add(taskToProcess); // Add to the List (implemented by ArrayList)
        System.out.println("Processing task: " + taskToProcess); // System.out for action message
        return taskToProcess;
    }

    /**
     * Returns a list of all waiting tasks, ordered by priority (HIGH -> MEDIUM -> LOW).
     * @return A List containing all waiting tasks.
     */
    public List<Task> getWaitingTasks() {
        // Create a new List (using ArrayList) to combine tasks from all queues
        List<Task> waiting = new ArrayList<>(); // ArrayList implements List
        waiting.addAll(highPriorityQueue); // Add all elements from High queue (maintaining their order)
        waiting.addAll(mediumPriorityQueue); // Add all elements from Medium queue
        waiting.addAll(lowPriorityQueue); // Add all elements from Low queue
        return waiting; // Return as List interface
    }

    /**
     * Returns a list of all completed tasks.
     * @return A List containing all completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(completedTasks); // ArrayList implements List
    }

    /**
     * Checks if there are any tasks waiting in any queue.
     * @return true if at least one queue is not empty, false otherwise.
     */
    public boolean hasWaitingTasks() {
        return !highPriorityQueue.isEmpty() || !mediumPriorityQueue.isEmpty() || !lowPriorityQueue.isEmpty();
    }
}

// Main application class with the command-line interface
public class TaskApp {
    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in); // Use Scanner for user input

    public static void main(String[] args) {
        System.out.println("--- Team Task Manager ---"); // System.out

        // Class-wide exception handling using a try-catch block around the main application loop
        try {
            runMenu();
        } catch (InputMismatchException e) {
             // Catch specific Scanner input errors early
            System.err.println("Invalid input. Please enter a number for the menu option."); // System.err
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage()); // System.err
            e.printStackTrace(); // Print stack trace for debugging in an exam context
        } finally {
            // Ensure the scanner is closed regardless of exceptions
            scanner.close();
            System.out.println("--- Exiting Task Manager ---"); // System.out
        }
    }

    /**
     * Runs the main menu loop.
     * Declared to throw Exception to allow main's try-catch to handle unexpected issues.
     */
    private static void runMenu() throws Exception {
        int choice = -1;
        while (choice != 5) {
            printMenu();
            System.out.print("Enter your choice: "); // System.out

            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Using switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processTask();
                        break;
                    case 3:
                        listWaitingTasks();
                        break;
                    case 4:
                        listCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting..."); // System.out
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // System.err
                }
            } catch (InputMismatchException e) {
                 // Handle non-integer input for menu choice
                 System.err.println("Invalid input. Please enter a number."); // System.err
                 scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (NoTasksAvailableException e) {
                 // Handle the specific case of no tasks to process
                 System.err.println(e.getMessage()); // System.err
            } catch (IllegalArgumentException e) {
                 // Handle invalid priority string input during task creation
                 System.err.println("Error adding task: " + e.getMessage()); // System.err
            }
            // Any other unexpected exceptions will propagate up to the main try-catch
            System.out.println(); // Add a blank line for readability between interactions
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:"); // System.out
        System.out.println("1. Add Task"); // System.out
        System.out.println("2. Process Next Task"); // System.out
        System.out.println("3. List Waiting Tasks"); // System.out
        System.out.println("4. List Completed Tasks"); // System.out
        System.out.println("5. Exit"); // System.out
    }

    /**
     * Handles the "Add Task" menu option. Prompts user for description and priority.
     * Includes input validation.
     */
    private static void addTask() {
        System.out.print("Enter task description: "); // System.out
        String description = scanner.nextLine().trim();

        // Validate description input
        if (description.isEmpty()) {
            System.err.println("Task description cannot be empty."); // System.err
            return; // Exit the method if validation fails
        }

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): "); // System.out
        String priorityString = scanner.nextLine().trim().toUpperCase(); // Read and convert to uppercase

        try {
            // Validate priority input by attempting to convert string to enum
            Priority priority = Priority.valueOf(priorityString); // valueOf() throws IllegalArgumentException for invalid strings
            taskManager.addTask(description, priority); // Call TaskManager method if valid
        } catch (IllegalArgumentException e) {
            // Catch the exception thrown by Priority.valueOf()
            System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW."); // System.err
        }
    }

    /**
     * Handles the "Process Next Task" menu option.
     * Calls TaskManager to process the next task and handles the specific NoTasksAvailableException.
     */
    private static void processTask() throws NoTasksAvailableException {
        // This method calls taskManager.processNextTask() which can throw NoTasksAvailableException.
        // We declare that this method throws it, and it's caught in the runMenu try-catch block.
        taskManager.processNextTask();
    }

    /**
     * Handles the "List Waiting Tasks" menu option.
     * Retrieves and prints the list of waiting tasks.
     */
    private static void listWaitingTasks() {
        // Get the list of waiting tasks (returned as List interface, implemented by ArrayList)
        List<Task> waitingTasks = taskManager.getWaitingTasks();

        if (waitingTasks.isEmpty()) {
            System.out.println("No tasks are currently waiting."); // System.out
        } else {
            System.out.println("--- Waiting Tasks (High -> Medium -> Low) ---"); // System.out header
            // Iterate and print each task using System.out
            waitingTasks.forEach(System.out::println); // Utilizes Task's toString() method
        }
    }

    /**
     * Handles the "List Completed Tasks" menu option.
     * Retrieves and prints the list of completed tasks.
     */
    private static void listCompletedTasks() {
        // Get the list of completed tasks (returned as List interface, implemented by ArrayList)
        List<Task> completedTasks = taskManager.getCompletedTasks();

        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet."); // System.out
        } else {
            System.out.println("--- Completed Tasks ---"); // System.out header
             // Iterate and print each task using System.out
            completedTasks.forEach(System.out::println); // Utilizes Task's toString() method
        }
    }
}
