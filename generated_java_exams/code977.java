/*
 * Exam Question #977
 * Generated on: 2025-05-12 17:07:43
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Document Processing Workflow
 * 
 * **Scenario:**
 * 
 * You are tasked with building a console-based application that simulates a simple document processing workflow. Documents are submitted, placed in a queue for processing, and then processed one by one. After processing, documents are categorized into either a list of successfully completed documents or a list of documents that encountered processing errors.
 * 
 * **Requirements:**
 * 
 * 1.  **`Document` Class:**
 *     *   Create a class named `Document`.
 *     *   It must have private fields: `id` (int), `content` (String), and `status` (enum `DocumentStatus`).
 *     *   Include a constructor `Document(int id, String content)` that initializes the id and content, setting the initial status to `PENDING`.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for the `status` field.
 *     *   Override the `toString()` method to provide a descriptive string representation of the document (e.g., "ID: [id], Content: [content], Status: [status]").
 * 
 * 2.  **`DocumentStatus` Enum:**
 *     *   Create an enum named `DocumentStatus` with the following values: `PENDING`, `COMPLETED`, `ERROR`.
 * 
 * 3.  **`WorkflowManager` Class:**
 *     *   Create a class named `WorkflowManager` to manage the document flow.
 *     *   It must have the following private instance variables:
 *         *   A `Queue<Document>` to hold documents awaiting processing.
 *         *   A `List<Document>` to store successfully completed documents.
 *         *   A `List<Document>` to store documents that failed processing.
 *         *   An integer counter (`nextDocumentId`) to generate unique IDs for new documents, starting from 1.
 *     *   Include a constructor that initializes the collections (using appropriate concrete classes) and the ID counter.
 *     *   Implement the following public methods:
 *         *   `int submitDocument(String content)`:
 *             *   Validates that the `content` is not null or empty. If invalid, throw an `IllegalArgumentException`.
 *             *   Creates a new `Document` object using the `nextDocumentId`, provided content, and `PENDING` status.
 *             *   Adds the new document to the processing queue.
 *             *   Increments `nextDocumentId`.
 *             *   Returns the ID of the newly submitted document.
 *         *   `void processNextDocument()`:
 *             *   Takes the next document from the head of the processing queue.
 *             *   If the queue is empty, print a message to `System.out` indicating this.
 *             *   If a document is retrieved:
 *                 *   Simulate processing. Implement a rule: if the document's content contains the case-insensitive word "fail", simulate a processing error. Otherwise, simulate successful processing.
 *                 *   Use a `try-catch` block to handle the simulated processing outcome:
 *                     *   Inside the `try` block: If content contains "fail", throw a `RuntimeException` (or a custom exception if you prefer) to simulate an error. If successful, update the document's status to `COMPLETED` and add it to the completed documents list. Print a success message to `System.out`.
 *                     *   Inside the `catch` block: Catch the exception. Update the document's status to `ERROR`. Add the document to the errored documents list. Print an error message to `System.err` including the document ID and the error reason.
 *         *   `void viewProcessingQueue()`: Prints a header "--- Processing Queue ---" to `System.out`, then iterates and prints each document in the queue using its `toString()` method. If the queue is empty, print "Queue is empty."
 *         *   `void viewCompletedDocuments()`: Prints a header "--- Completed Documents ---" to `System.out`, then iterates and prints each document in the completed list. If the list is empty, print "No completed documents yet."
 *         *   `void viewErroredDocuments()`: Prints a header "--- Errored Documents ---" to `System.out`, then iterates and prints each document in the errored list. If the list is empty, print "No errored documents yet."
 * 
 * 4.  **`DocumentWorkflowApp` Class:**
 *     *   Create a class named `DocumentWorkflowApp` with a `main` method.
 *     *   Instantiate `WorkflowManager` and `Scanner`.
 *     *   Implement a console-based menu loop using a `while (true)` loop.
 *     *   Display the following menu options to `System.out`:
 *         ```
 *         --- Document Workflow Menu ---
 *         1. Submit New Document
 *         2. Process Next Document
 *         3. View Processing Queue
 *         4. View Completed Documents
 *         5. View Errored Documents
 *         6. Exit
 *         Enter choice:
 *         ```
 *     *   Read the user's integer choice using `Scanner`.
 *     *   Use a `switch` statement to perform actions based on the user's choice.
 *     *   Implement `try-catch` around reading the menu choice to handle `InputMismatchException` if the user enters non-integer input. If caught, print an error message to `System.err` and consume the invalid input using `scanner.next()`.
 *     *   For option 1 (Submit): Prompt the user for document content using `System.out`, read the line, and call `workflowManager.submitDocument()`. Wrap the call in a `try-catch` to handle the `IllegalArgumentException` from invalid content, printing an error to `System.err`.
 *     *   For options 2-5: Call the corresponding `WorkflowManager` methods.
 *     *   For option 6 (Exit): Print an exit message to `System.out` and terminate the program gracefully (e.g., `return;`).
 *     *   For any other choice, print an "Invalid choice." message to `System.err`.
 *     *   Ensure the `Scanner` is closed when the program exits.
 * 
 * **Constraints & Best Practices:**
 * 
 * *   Use `java.util.Queue`, `java.util.ArrayList`, and `java.util.List`. Declare variables using the interface type (`List`) where appropriate, but instantiate with concrete classes (`ArrayList`, `LinkedList`).
 * *   Use `Scanner` for all user input.
 * *   Use `switch` for the main menu control flow.
 * *   Use `System.out` for normal output, prompts, and success messages.
 * *   Use `System.err` for error messages (invalid input, processing errors).
 * *   Implement class-wide exception handling using `try-catch` as specified.
 * *   Adhere to principles of encapsulation (private fields, public methods).
 * *   Use meaningful names for classes, variables, methods, and enum values.
 * *   Include brief comments explaining the purpose of classes or complex logic sections.
 * 
 * **Expected Output:**
 * 
 * The output should match the example interaction provided in the planning phase, demonstrating successful submission, processing, viewing of lists, handling of processing errors (documents containing "fail"), and handling of invalid menu input.
 *
 * EXPLANATION:
 * The provided solution implements a simple document processing workflow system based on the requirements. It demonstrates the practical usage of the specified Java components and follows best practices.
 * 
 * 1.  **`DocumentStatus` Enum:** Defines the possible states of a document, providing type-safe status management.
 * 2.  **`Document` Class:** Represents a single document with its ID, content, and status. It encapsulates these properties with private fields and provides public getters and a status setter. The `toString()` method provides a convenient way to display document information.
 * 3.  **`WorkflowManager` Class:** This is the core class managing the workflow.
 *     *   It uses a `Queue<Document>` (`processingQueue`) implemented by `LinkedList` to store documents awaiting processing. The `Queue` interface is ideal here because documents are processed in the order they are submitted (FIFO - First-In, First-Out). `offer()` adds to the tail, `poll()` removes from the head.
 *     *   It uses `List<Document>` interfaces (`completedDocuments`, `erroredDocuments`) implemented by `ArrayList` to store documents after processing. `List` is suitable as these collections represent simple ordered lists of processed items. `ArrayList` provides efficient storage and retrieval by index, although simple iteration is used here.
 *     *   `nextDocumentId` is a simple counter ensuring unique IDs for each new document.
 *     *   `submitDocument`: Adds a new `Document` to the queue after basic input validation, throwing `IllegalArgumentException` on invalid content.
 *     *   `processNextDocument`: Retrieves (and removes) the next document from the queue using `poll()`. It checks if `poll()` returned `null` (queue empty). It then uses a `try-catch` block to simulate processing. A `RuntimeException` is thrown if the content contains "fail", simulating an error. If no exception occurs, the document is marked `COMPLETED` and added to `completedDocuments`. If an exception is caught, the document is marked `ERROR` and added to `erroredDocuments`. `System.err` is used specifically for reporting processing errors.
 *     *   `view...` methods: Iterate through the respective collections (`Queue` or `List`) and print the details of each document using its `toString()` method. They also handle the case where the collection is empty.
 * 4.  **`DocumentWorkflowApp` Class:**
 *     *   Contains the `main` method, serving as the application's entry point and console interface.
 *     *   Initializes `WorkflowManager` and `Scanner`.
 *     *   A `while (true)` loop creates the main menu cycle.
 *     *   Inside the loop, it displays the menu using `System.out`.
 *     *   A `try-catch(InputMismatchException)` block is used around `scanner.nextInt()` to gracefully handle cases where the user enters non-integer input for the menu choice. `System.err` is used for this error message, and `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop.
 *     *   A `switch` statement directs the program flow based on the valid integer input.
 *     *   Each case calls the appropriate method in the `WorkflowManager`.
 *     *   Case 1 (Submit) includes an additional `try-catch` to handle the `IllegalArgumentException` thrown by `submitDocument` if the content is invalid, reporting the specific error via `System.err`.
 *     *   Case 6 (Exit) prints a message, closes the `Scanner`, and uses `return` to exit the `main` method.
 *     *   The `default` case in the `switch` handles any valid integer input that doesn't match a menu option, reporting an error via `System.err`.
 *     *   Proper resource management is shown by closing the `Scanner` before exiting.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating encapsulation, input validation, error handling, and clear code structure suitable for evaluating advanced Java understanding.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for document status
enum DocumentStatus {
    PENDING, PROCESSING, COMPLETED, ERROR
}

// Represents a document in the workflow
class Document {
    private int id;
    private String content;
    private DocumentStatus status;

    // Constructor
    public Document(int id, String content) {
        if (content == null || content.trim().isEmpty()) {
            // This validation is also done in WorkflowManager, but good practice
            // to have basic validation in the object itself if applicable.
            // However, the requirement specifically asks for validation in WorkflowManager.
            // So, we'll rely on WorkflowManager for the IllegalArgumentException.
        }
        this.id = id;
        this.content = content;
        this.status = DocumentStatus.PENDING; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getContent() {
        return content;
    }

    public DocumentStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(DocumentStatus status) {
        this.status = status;
    }

    // String representation
    @Override
    public String toString() {
        return "ID: " + id + ", Content: \"" + content + "\", Status: " + status;
    }
}

// Manages the document processing workflow
class WorkflowManager {
    // Using LinkedList as a concrete implementation of Queue
    private Queue<Document> processingQueue;
    // Declaring using the List interface, instantiating with ArrayList
    private List<Document> completedDocuments;
    private List<Document> erroredDocuments;
    private int nextDocumentId; // Counter for unique document IDs

    // Constructor
    public WorkflowManager() {
        this.processingQueue = new LinkedList<>();
        this.completedDocuments = new ArrayList<>();
        this.erroredDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start ID from 1
    }

    /**
     * Submits a new document to the processing queue.
     * @param content The content of the document.
     * @return The ID of the newly submitted document.
     * @throws IllegalArgumentException if content is null or empty.
     */
    public int submitDocument(String content) {
        if (content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("Document content cannot be empty.");
        }
        Document newDoc = new Document(nextDocumentId, content);
        processingQueue.offer(newDoc); // Add to the end of the queue
        System.out.println("Document submitted with ID: " + nextDocumentId);
        nextDocumentId++; // Increment for the next document
        return newDoc.getId();
    }

    /**
     * Processes the next document in the queue.
     * Simulates success or failure based on content.
     */
    public void processNextDocument() {
        Document docToProcess = processingQueue.poll(); // Get and remove head of queue

        if (docToProcess == null) {
            System.out.println("Processing queue is empty. Nothing to process.");
            return; // Nothing to do
        }

        System.out.println("Processing document ID: " + docToProcess.getId());

        try {
            // Simulate processing logic: fail if content contains "fail" (case-insensitive)
            if (docToProcess.getContent().toLowerCase().contains("fail")) {
                // Simulate an error by throwing an exception
                throw new RuntimeException("Simulated processing failure due to content.");
            }

            // If successful
            docToProcess.setStatus(DocumentStatus.COMPLETED);
            completedDocuments.add(docToProcess);
            System.out.println("Document ID " + docToProcess.getId() + " completed successfully.");

        } catch (Exception e) {
            // Handle processing errors
            docToProcess.setStatus(DocumentStatus.ERROR);
            erroredDocuments.add(docToProcess);
            // Report error to System.err
            System.err.println("Error processing document ID " + docToProcess.getId() + ": " + e.getMessage());
            System.err.println("Document ID " + docToProcess.getId() + " moved to errored list.");
        }
    }

    /**
     * Displays the documents currently in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Document doc : processingQueue) {
                System.out.println(doc);
            }
        }
    }

    /**
     * Displays the documents that have been successfully completed.
     */
    public void viewCompletedDocuments() {
        System.out.println("--- Completed Documents ---");
        if (completedDocuments.isEmpty()) {
            System.out.println("No completed documents yet.");
        } else {
            for (Document doc : completedDocuments) {
                System.out.println(doc);
            }
        }
    }

    /**
     * Displays the documents that failed processing.
     */
    public void viewErroredDocuments() {
        System.out.println("--- Errored Documents ---");
        if (erroredDocuments.isEmpty()) {
            System.out.println("No errored documents yet.");
        } else {
            for (Document doc : erroredDocuments) {
                System.out.println(doc);
            }
        }
    }
}

// Main application class with console interface
public class DocumentWorkflowApp {

    public static void main(String[] args) {
        WorkflowManager workflowManager = new WorkflowManager();
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice outside the loop

        System.out.println("Welcome to the Document Workflow System.");

        while (true) {
            // Display menu
            System.out.println("\n--- Document Workflow Menu ---");
            System.out.println("1. Submit New Document");
            System.out.println("2. Process Next Document");
            System.out.println("3. View Processing Queue");
            System.out.println("4. View Completed Documents");
            System.out.println("5. View Errored Documents");
            System.out.println("6. Exit");
            System.out.print("Enter choice: ");

            // Read user choice with exception handling
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter an integer.");
                scanner.nextLine(); // Consume the invalid input line
                continue; // Skip the rest of the loop iteration and show menu again
            }

            // Process user choice using switch
            switch (choice) {
                case 1:
                    System.out.print("Enter document content: ");
                    String content = scanner.nextLine();
                    try {
                        workflowManager.submitDocument(content);
                    } catch (IllegalArgumentException e) {
                        System.err.println("Submission failed: " + e.getMessage());
                    }
                    break;
                case 2:
                    workflowManager.processNextDocument();
                    break;
                case 3:
                    workflowManager.viewProcessingQueue();
                    break;
                case 4:
                    workflowManager.viewCompletedDocuments();
                    break;
                case 5:
                    workflowManager.viewErroredDocuments();
                    break;
                case 6:
                    System.out.println("Exiting workflow system.");
                    scanner.close(); // Close the scanner
                    return; // Exit the main method and terminate program
                default:
                    System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    break;
            }
        }
    }
}
