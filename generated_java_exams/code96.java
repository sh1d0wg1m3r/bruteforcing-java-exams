/*
 * Exam Question #96
 * Generated on: 2025-05-11 22:13:43
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Support Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for managing support tickets within a small IT helpdesk. The system should handle incoming support requests, queue them for processing, allow agents to resolve tickets in the order they were received, and maintain an archive of resolved tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following attributes:
 *     *   `id`: An integer representing the unique ticket identifier (auto-generated by the system).
 *     *   `description`: A string detailing the issue.
 *     *   `status`: An enum `Status` with values `PENDING` and `RESOLVED`.
 *     *   Implement appropriate constructors, getters, and a method to update the status.
 * 
 * 2.  **System Core:** Create a `SupportTicketSystem` class that manages the ticket flow. It must contain:
 *     *   A `Queue<Ticket>` to hold tickets that are currently pending resolution.
 *     *   A `List<Ticket>` to store tickets once they have been resolved. Use `ArrayList` as the concrete implementation for the list.
 *     *   An integer field to keep track of the next available ticket ID.
 * 
 * 3.  **Functionality:** The `SupportTicketSystem` class must provide methods for the following operations, accessible via a main menu:
 *     *   **Add New Ticket:** Prompt the user for a ticket description, create a new `Ticket` object with a unique ID and `PENDING` status, and add it to the pending queue.
 *     *   **View Pending Tickets:** Display all tickets currently in the pending queue, showing their ID and description, in the order they will be processed. Indicate if the queue is empty.
 *     *   **Resolve Next Ticket:** Take the next ticket from the pending queue (FIFO), update its status to `RESOLVED`, and move it to the archived list. Indicate if the queue was empty.
 *     *   **View Archived Tickets:** Display all tickets in the archived list, showing their ID, description, and `RESOLVED` status. Indicate if the archive is empty.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **User Interface:** Implement a simple command-line menu using `Scanner` to interact with the user. The menu should present options for the operations listed above.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu selection.
 * 
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu input, attempting to resolve when the queue is empty).
 *     *   Use `try-catch` blocks to handle potential runtime errors, particularly around user input (e.g., `InputMismatchException`). Implement this exception handling around the input reading loop or critical input operations.
 *     *   Implement input validation where necessary (e.g., checking if a number was entered for the menu).
 * 
 * 7.  **Output:** Use `System.out` for all normal program output, including the menu, prompts, ticket details, and success messages.
 * 
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and Javadoc where necessary.
 *     *   Ensure clean code structure.
 * 
 * **Expected Interaction Flow (Example):**
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket 1 added to the queue.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Cannot connect to VPN.
 * Ticket 2 added to the queue.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * ID: 1, Description: My printer is not working.
 * ID: 2, Description: Cannot connect to VPN.
 * -----------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 3
 * Resolving ticket: ID: 1, Description: My printer is not working.
 * Ticket 1 resolved and moved to archive.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * ID: 2, Description: Cannot connect to VPN.
 * -----------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 4
 * --- Archived Tickets ---
 * ID: 1, Description: My printer is not working., Status: RESOLVED
 * ----------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Resolve Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 5
 * Exiting Support Ticket System. Goodbye!
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Ticket` class, the `SupportTicketSystem` class, and the main class (e.g., `Main` or `App`) that runs the system. Ensure your code adheres to all requirements and best practices.
 *
 * EXPLANATION:
 * This solution implements a basic Support Ticket Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Ticket` Class:** A simple class representing a ticket with an ID, description, and `Status`. It uses an `enum` for clarity on ticket states (`PENDING`, `RESOLVED`). Getters provide controlled access to fields, and a `setStatus` method allows changing the ticket's state. `toString()` is overridden to provide a useful representation, specifically including the status only when resolved for the archive view, and a separate `toPendingString()` is added for the pending view which doesn't need the status explicitly stated as it's implicitly PENDING.
 * 
 * 2.  **`SupportTicketSystem` Class:** This is the core of the application.
 *     *   `pendingTickets`: Declared as `Queue<Ticket>` and instantiated as `LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, suitable here because we need FIFO behavior (`offer` to add, `poll` to remove from the head).
 *     *   `archivedTickets`: Declared as `List<Ticket>` and instantiated as `ArrayList<>()`. `ArrayList` is used to store resolved tickets; `List` is used as the interface type, demonstrating good practice of programming to interfaces. `ArrayList` allows easy addition (`add`) and iteration.
 *     *   `nextTicketId`: An integer counter ensures each new ticket gets a unique, sequential ID.
 *     *   `scanner`: An instance of `Scanner` is managed within the class to handle user input throughout the application's lifecycle.
 * 
 * 3.  **Functionality Methods:**
 *     *   `displayMenu()`: A simple helper method to print the menu options.
 *     *   `addNewTicket()`: Reads the description from the user, creates a `Ticket` object, and adds it to the `pendingTickets` queue using `offer()`.
 *     *   `viewPendingTickets()`: Iterates through the `pendingTickets` queue using an enhanced for loop (which doesn't remove elements) and prints each ticket's pending details. It checks if the queue is empty before iterating.
 *     *   `resolveNextTicket()`: Uses `poll()` to retrieve and *remove* the ticket at the head of the `pendingTickets` queue. It checks if the queue is empty first. The retrieved ticket's status is updated to `RESOLVED`, and it's added to the `archivedTickets` list using `add()`.
 *     *   `viewArchivedTickets()`: Iterates through the `archivedTickets` list and prints each ticket using its `toString()` method. It checks if the list is empty.
 * 
 * 4.  **`run()` Method:** This method contains the main application loop.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   Inside the loop, the menu is displayed, and user input is read.
 *     *   **Exception Handling (`try-catch`):** A `try-catch` block is wrapped around the `scanner.nextInt()` call. This specifically catches `InputMismatchException` if the user enters non-integer input, preventing the program from crashing. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to clear the buffer for the next iteration. A generic `Exception` catch is also included as a fallback for unexpected issues during input reading, printing to `System.err`. This demonstrates class-wide handling within the main operational loop.
 *     *   **Switch Statement:** The `switch` statement handles the validated integer input, directing execution to the appropriate method (`addNewTicket`, `viewPendingTickets`, etc.) or setting the `running` flag to `false` for exit. The `default` case handles valid integer inputs that do not correspond to a menu option, printing an error to `System.err`.
 * 
 * 5.  **`main` Method:** The entry point of the application. It creates an instance of `SupportTicketSystem` and calls its `run()` method to start the system.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **`java.util.Queue`:** Used for `pendingTickets` to ensure FIFO processing order. `offer()` and `poll()` methods are used.
 * *   **`java.util.ArrayList`:** Used as the concrete implementation for `archivedTickets`.
 * *   **`java.util.List`:** Used as the interface type for `archivedTickets`, promoting flexibility and good design.
 * *   **`java.util.Scanner`:** Used to read user input from the console.
 * *   **`switch` statement:** Used for multi-way branching based on the user's menu choice.
 * *   **`System.err`:** Used specifically for outputting error messages to the standard error stream.
 * *   **`System.out`:** Used for all normal program output (menu, prompts, ticket details, success messages) to the standard output stream.
 * *   **`try-catch` blocks:** Used for robust error handling, specifically demonstrated for handling potential `InputMismatchException` during user input, preventing program termination and allowing recovery.
 * *   **Encapsulation:** Fields in `Ticket` and `SupportTicketSystem` are private, accessed via public methods (getters, mutators).
 * *   **Meaningful Names:** Class, method, variable, and enum names are descriptive (e.g., `pendingTickets`, `resolveNextTicket`, `Status.RESOLVED`).
 * *   **Comments and Documentation:** Basic Javadoc comments are included for classes and methods, explaining their purpose.
 * *   **Input Validation:** Checks for empty ticket descriptions and handles non-integer menu input.
 * *   **Error Handling:** Explicit checks for empty collections before attempting operations like resolving or viewing.
 * *   **Clean Code Structure:** Code is organized into logical classes and methods, with clear separation of concerns (Ticket data vs. System logic).
 * 
 * This solution effectively integrates the required Java components into a practical, menu-driven application, demonstrating core object-oriented principles and error handling techniques expected at an advanced level.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the status of a support ticket.
 */
enum Status {
    PENDING,
    RESOLVED
}

/**
 * Represents a single support ticket.
 */
class Ticket {
    private int id;
    private String description;
    private Status status;

    /**
     * Constructs a new Ticket.
     *
     * @param id The unique identifier for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = Status.PENDING; // New tickets are always pending
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setters (for status update) ---

    /**
     * Sets the status of the ticket.
     *
     * @param status The new status for the ticket.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     * Includes status only if it's RESOLVED, suitable for archive view.
     *
     * @return String representation of the ticket.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ID: ").append(id).append(", Description: ").append(description);
        if (status == Status.RESOLVED) {
            sb.append(", Status: ").append(status);
        }
        return sb.toString();
    }

    /**
     * Provides a string representation suitable for pending view (without status).
     *
     * @return String representation for pending view.
     */
    public String toPendingString() {
        return "ID: " + id + ", Description: " + description;
    }
}

/**
 * Manages the support ticket workflow using queues and lists.
 */
public class SupportTicketSystem {

    private Queue<Ticket> pendingTickets; // Queue for FIFO processing
    private List<Ticket> archivedTickets; // List to store resolved tickets
    private int nextTicketId; // Counter for unique ticket IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new SupportTicketSystem.
     * Initializes collections, ticket ID counter, and scanner.
     */
    public SupportTicketSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingTickets = new LinkedList<>();
        // Using ArrayList as a List implementation for archive
        this.archivedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Resolve Next Ticket");
        System.out.println("4. View Archived Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new ticket to the pending queue.
     * Prompts user for description.
     */
    private void addNewTicket() {
        System.out.print("Enter ticket description: ");
        // Consume the newline character left by previous nextInt() or similar
        // scanner.nextLine(); // This might be needed depending on previous input method
        String description = scanner.nextLine(); // Read the whole line for description

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return; // Don't add empty ticket
        }

        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.offer(newTicket); // offer adds to the tail of the queue
        System.out.println("Ticket " + newTicket.getId() + " added to the queue.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    private void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket.toPendingString());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Resolves the next ticket from the pending queue (FIFO).
     * Moves the resolved ticket to the archived list.
     */
    private void resolveNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("Error: No tickets in the pending queue to resolve.");
        } else {
            Ticket ticketToResolve = pendingTickets.poll(); // poll removes from the head
            System.out.println("Resolving ticket: " + ticketToResolve.toPendingString());
            ticketToResolve.setStatus(Status.RESOLVED);
            archivedTickets.add(ticketToResolve); // add to the end of the archive list
            System.out.println("Ticket " + ticketToResolve.getId() + " resolved and moved to archive.");
        }
    }

    /**
     * Displays all tickets in the archived list.
     */
    private void viewArchivedTickets() {
        System.out.println("\n--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("No archived tickets.");
        } else {
            // Iterate through the list
            for (Ticket ticket : archivedTickets) {
                System.out.println(ticket); // Uses Ticket.toString() which includes RESOLVED status
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            // --- Class-wide Exception Handling Example ---
            try {
                choice = scanner.nextInt();
                // Consume the newline character after reading the integer
                scanner.nextLine();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the rest of the loop and show menu again
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during input reading
                 System.err.println("An unexpected error occurred during input: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to error stream
                 running = false; // Exit loop on serious unexpected error
                 continue;
            }
            // --- End Exception Handling Example ---


            // --- Switch Statement for Flow Control ---
            switch (choice) {
                case 1:
                    addNewTicket();
                    break;
                case 2:
                    viewPendingTickets();
                    break;
                case 3:
                    resolveNextTicket();
                    break;
                case 4:
                    viewArchivedTickets();
                    break;
                case 5:
                    running = false; // Set flag to exit loop
                    System.out.println("Exiting Support Ticket System. Goodbye!");
                    break;
                default:
                    // Handle invalid number input (outside 1-5 range)
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
            // --- End Switch Statement ---
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportTicketSystem system = new SupportTicketSystem();
        system.run();
    }
}
