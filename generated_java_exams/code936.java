/*
 * Exam Question #936
 * Generated on: 2025-05-12 17:02:13
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Complex Java Programming Exam Task: Task Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage personal tasks. The system needs to keep track of tasks that are pending and tasks that have been completed. Pending tasks should be processed in the order they were added (First-In, First-Out), while completed tasks should be stored in a list for review.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:**
 *     *   Create a class named `Task` to represent a single task.
 *     *   It must have a `private String description` and a `private boolean isCompleted`.
 *     *   Include a constructor `Task(String description)` that initializes the task with the given description and sets `isCompleted` to `false`. The constructor should validate that the description is not null or empty and throw an `IllegalArgumentException` if it is.
 *     *   Provide public getter methods for `description` and `isCompleted`.
 *     *   Provide a public method `markCompleted()` that sets `isCompleted` to `true`.
 * 
 * 2.  **Task Management Logic:**
 *     *   Create a class named `TaskManager` responsible for managing the collections of tasks.
 *     *   It must use a `java.util.Queue<Task>` (using `java.util.LinkedList` as the implementation) to store tasks that are pending. This ensures tasks are processed in FIFO order.
 *     *   It must use a `java.util.List<Task>` (using `java.util.ArrayList` as the implementation) to store tasks that have been completed.
 *     *   Implement the following public methods in `TaskManager`:
 *         *   `addTask(String description)`: Attempts to create and add a new `Task` to the pending queue. This method should call the `Task` constructor and handle the `IllegalArgumentException` by printing an error message to `System.err`. Return `true` on success, `false` on failure (invalid description).
 *         *   `viewPendingTasks()`: Prints all tasks currently in the pending queue to `System.out` without removing them. Display them as a numbered list. If the queue is empty, print a message indicating so.
 *         *   `viewCompletedTasks()`: Prints all tasks currently in the completed list to `System.out` as a numbered list. If the list is empty, print a message indicating so.
 *         *   `completeNextTask()`: Removes the task at the front of the pending queue, marks it as completed using the `markCompleted()` method, and adds it to the completed list. If the pending queue is empty, print an error message to `System.err` indicating that there are no tasks to complete, and return `false`. Return `true` if a task was successfully completed.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   Create a main application class (e.g., `TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Present the user with a menu of options using `System.out`:
 *         1.  Add Task
 *         2.  View Pending Tasks
 *         3.  View Completed Tasks
 *         4.  Complete Next Task
 *         5.  Exit
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Implement an input loop that continues until the user chooses the 'Exit' option.
 *     *   After reading the integer choice with `scanner.nextInt()`, ensure you consume the leftover newline character using `scanner.nextLine()` before reading the task description.
 *     *   Handle `InputMismatchException` specifically if the user enters non-integer input for the menu choice. Print an error message to `System.err` and consume the invalid input to prevent an infinite loop.
 * 
 * 4.  **Error Handling and Output Streams:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages (e.g., "Task added:", "Completed task:").
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid task description, no tasks to complete, input format errors, unexpected errors).
 *     *   Implement a broad `try-catch` block in the `main` method wrapping the core application logic loop (`run` method call) to catch any unhandled exceptions that might occur during execution. Print a general error message including the exception details to `System.err` in the catch block.
 *     *   Implement specific error handling within `TaskManager` methods as described (e.g., checking for empty queue before polling, handling `IllegalArgumentException`).
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement input validation where necessary (e.g., non-empty task description).
 *     *   Ensure proper resource management (close the `Scanner`).
 *     *   Maintain a clean code structure with separation of concerns (Model: `Task`, Logic: `TaskManager`, UI/App: `TaskApp`).
 * 
 * **Expected Output:**
 * 
 * The program should provide a clear command-line interface as described. Output messages and errors must be directed to `System.out` and `System.err` respectively, as specified. Task lists should be numbered.
 * 
 * *Example Interaction Snippet (Illustrative):*
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (0)
 * 3. View Completed Tasks (0)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task added: Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (1)
 * 3. View Completed Tasks (0)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Task added: Schedule meeting
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (2)
 * 3. View Completed Tasks (0)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 2
 * --- Pending Tasks ---
 * 1. Pay bills
 * 2. Schedule meeting
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (2)
 * 3. View Completed Tasks (0)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 4
 * Completed task: Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (1)
 * 3. View Completed Tasks (1)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 2
 * --- Pending Tasks ---
 * 1. Schedule meeting
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (1)
 * 3. View Completed Tasks (1)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 4
 * Completed task: Schedule meeting
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (0)
 * 3. View Completed Tasks (2)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 4
 * System.err: No pending tasks to complete.
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (0)
 * 3. View Completed Tasks (2)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: 3
 * --- Completed Tasks ---
 * 1. Pay bills
 * 2. Schedule meeting
 * -----------------------
 * 
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. View Pending Tasks (0)
 * 3. View Completed Tasks (2)
 * 4. Complete Next Task
 * 5. Exit
 * --------------------------
 * Enter your choice: invalid_input
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Initiating shutdown...
 * 
 * Exiting program.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System using core Java concepts and collections as required.
 * 
 * **Overall Structure:**
 * The solution is structured into three classes following a basic Model-Logic-UI pattern:
 * 1.  `Task`: The model class representing a single task object.
 * 2.  `TaskManager`: Contains the business logic for managing collections of tasks.
 * 3.  `TaskApp`: Contains the `main` method, handles user interaction (UI), and orchestrates calls to `TaskManager`.
 * 
 * **Usage of Required Components:**
 * 
 * 1.  **`java.util.Queue`**: The `TaskManager` class uses a `Queue<Task>` named `pendingTasksQueue`. This collection is chosen specifically because the requirement is to process pending tasks in the order they were added (FIFO). `java.util.LinkedList` is used as a concrete implementation of the `Queue` interface. Tasks are added using `offer()` and removed from the front using `poll()`. The `iterator()` is used in `viewPendingTasks()` to traverse the queue without removing elements.
 * 2.  **`java.util.ArrayList`**: The `TaskManager` class uses an `ArrayList<Task>` named `completedTasksList`. This is used to store tasks after they have been completed. `ArrayList` provides a dynamic array implementation suitable for storing items and iterating over them, which is needed for the `viewCompletedTasks()` method.
 * 3.  **`java.util.List` interface**: The `completedTasksList` field in `TaskManager` is declared using the `List<Task>` interface type (`private List<Task> completedTasksList;`), although the implementation is `ArrayList`. This demonstrates programming to interfaces, a good practice.
 * 4.  **`java.util.Scanner`**: The `TaskApp` class uses a `Scanner` object to read input from the user via the console (`System.in`). It's used to read both integer choices (`nextInt()`) and string descriptions (`nextLine()`). Proper handling of the newline character after `nextInt()` is included (`scanner.nextLine()`).
 * 5.  **`switch` statement**: The `TaskApp` class uses a `switch` statement within its main loop to direct program flow based on the user's integer menu choice. Each case corresponds to a different operation (Add, View Pending, View Completed, Complete Next, Exit).
 * 6.  **`System.err`**: This stream is used specifically for printing error messages. Examples include:
 *     *   Reporting invalid menu choices (`TaskApp`).
 *     *   Reporting `InputMismatchException` when the user enters non-integer input (`TaskApp`).
 *     *   Reporting the error when attempting to complete a task but the pending queue is empty (`TaskManager`).
 *     *   Reporting `IllegalArgumentException` if a task is created with an empty description (`TaskManager` catching the exception from `Task`).
 *     *   Printing details of any unexpected, unhandled exception in the main `try-catch` block (`TaskApp.main`).
 * 7.  **`System.out`**: This stream is used for normal program output, including:
 *     *   Displaying the main menu and prompts (`TaskApp`).
 *     *   Printing task lists (`TaskManager`).
 *     *   Printing success messages (e.g., "Task added:", "Completed task:") (`TaskManager`).
 * 8.  **Class-wide exception handling with `try-catch` blocks**:
 *     *   The `main` method in `TaskApp` has a comprehensive `try-catch(Exception e)` block that wraps the call to the `run()` method. This serves as a catch-all for any unexpected exceptions that might occur during the program's execution, preventing the program from crashing abruptly and printing an error message to `System.err`.
 *     *   Specific error handling is also implemented:
 *         *   A `try-catch(InputMismatchException)` is used within the `TaskApp.run()` loop around reading the menu choice to handle cases where the user enters non-integer input.
 *         *   A `try-catch(IllegalArgumentException)` is used in `TaskManager.addTask()` to handle validation errors originating from the `Task` constructor.
 *         *   The `completeNextTask()` method in `TaskManager` checks the return value of `pendingTasksQueue.poll()`. Since `poll()` returns `null` if the queue is empty (rather than throwing an exception like `remove()`), this check handles the "no tasks to complete" error gracefully without needing a `try-catch` for `NoSuchElementException`.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskManager` classes hide their internal state (private fields) and expose functionality through public methods.
 * *   **Meaningful Names:** Classes, methods, and variables have descriptive names (e.g., `pendingTasksQueue`, `completeNextTask`, `viewCompletedTasks`).
 * *   **Comments and Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points (like consuming the newline after `nextInt()`).
 * *   **Input Validation:** The `Task` constructor validates that the description is not empty or null. The `TaskApp` handles invalid menu input types (`InputMismatchException`) and invalid menu choice values (`default` in `switch`).
 * *   **Error Handling:** Layered error handling is used, with specific catches for expected issues (`InputMismatchException`, `IllegalArgumentException`, empty queue check) and a general catch-all for unexpected errors. Errors are directed to `System.err`.
 * *   **Clean Code Structure:** The separation of concerns into `Task`, `TaskManager`, and `TaskApp` makes the code modular and easier to understand and maintain. The `main` method is kept clean by delegating the main loop to a separate `run()` method. Resource management is shown by closing the `Scanner` in a `finally` block.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, albeit simple, application context.
 */

// Task.java
package com.exam;

import java.util.Objects;

/**
 * Represents a single task with a description and completion status.
 */
public class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     *
     * @return true if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task.
     * @return The task description followed by its status.
     */
    @Override
    public String toString() {
        return description + (isCompleted ? " [Completed]" : " [Pending]");
    }

    // Optional: Override equals and hashCode if tasks need to be compared uniquely by description
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return Objects.equals(description, task.description);
    }

    @Override
    public int hashCode() {
        return Objects.hash(description);
    }
}

// TaskManager.java
package com.exam;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Iterator;

/**
 * Manages collections of pending and completed tasks using a Queue and a List.
 */
public class TaskManager {
    // Queue for pending tasks (FIFO processing)
    private Queue<Task> pendingTasksQueue;
    // List for completed tasks (ordered collection)
    private List<Task> completedTasksList;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // LinkedList is a common implementation of both Queue and List,
        // but used here specifically as a Queue for pending tasks.
        pendingTasksQueue = new LinkedList<>();
        // ArrayList is a common implementation of List.
        completedTasksList = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Validates the task description before creating the Task object.
     *
     * @param description The description of the task.
     * @return true if the task was successfully added, false otherwise (e.g., invalid description).
     */
    public boolean addTask(String description) {
        try {
            Task newTask = new Task(description); // Task constructor validates description
            // offer() is generally preferred over add() in Queue interfaces
            // as it handles capacity constraints gracefully (though LinkedList is unbounded).
            pendingTasksQueue.offer(newTask);
            System.out.println("Task added: " + description);
            return true;
        } catch (IllegalArgumentException e) {
            // Catch validation error from Task constructor and report it
            System.err.println("Error adding task: " + e.getMessage());
            return false;
        }
    }

    /**
     * Prints all tasks currently in the pending queue without removing them.
     * Uses an iterator to traverse the queue.
     */
    public void viewPendingTasks() {
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }
        System.out.println("--- Pending Tasks ---");
        // Use an iterator to view elements without removing them from the queue
        Iterator<Task> iterator = pendingTasksQueue.iterator();
        int index = 1;
        while (iterator.hasNext()) {
            Task task = iterator.next();
            System.out.println(index++ + ". " + task.getDescription()); // Print description for pending tasks
        }
        System.out.println("---------------------");
    }

    /**
     * Prints all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        if (completedTasksList.isEmpty()) {
            System.out.println("No completed tasks.");
            return;
        }
        System.out.println("--- Completed Tasks ---");
        // Iterate through the list to print completed tasks
        for (int i = 0; i < completedTasksList.size(); i++) {
            Task task = completedTasksList.get(i);
            System.out.println((i + 1) + ". " + task.getDescription()); // Print description for completed tasks
        }
        System.out.println("-----------------------");
    }

    /**
     * Completes the next task from the pending queue.
     * Removes the task from the pending queue, marks it as completed, and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     *
     * @return true if a task was successfully completed, false if the pending queue was empty.
     */
    public boolean completeNextTask() {
        // poll() retrieves and removes the head of the queue. Returns null if the queue is empty.
        Task taskToComplete = pendingTasksQueue.poll();
        if (taskToComplete == null) {
            // Handle the case where the queue is empty gracefully
            System.err.println("No pending tasks to complete.");
            return false;
        } else {
            taskToComplete.markCompleted(); // Mark the task as completed
            completedTasksList.add(taskToComplete); // Add it to the completed list
            System.out.println("Completed task: " + taskToComplete.getDescription());
            return true;
        }
    }

     /**
     * Returns the current number of pending tasks.
     * @return The count of tasks in the pending queue.
     */
    public int getPendingTaskCount() {
        return pendingTasksQueue.size();
    }

     /**
     * Returns the current number of completed tasks.
     * @return The count of tasks in the completed list.
     */
    public int getCompletedTaskCount() {
        return completedTasksList.size();
    }
}

// TaskApp.java (Main class)
package com.exam;

import java.util.InputMismatchException;
import java.util.Scanner;

/**
 * Main application class for the Task Management System.
 * Provides a command-line interface for managing tasks and handles user interaction.
 */
public class TaskApp {

    // Static fields for TaskManager and Scanner for easy access within static methods
    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    /**
     * The main entry point of the application.
     * Sets up a general exception handler for the main execution flow.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Class-wide exception handling: Wrap the core application logic in a try-catch block
        // to catch any unexpected exceptions that might occur during execution.
        try {
            run(); // Delegate the main application loop to a separate method
        } catch (Exception e) {
            // Catch any unhandled exceptions (e.g., NullPointerException, ArrayIndexOutOfBoundsException, etc.)
            System.err.println("\nAn unexpected critical error occurred:");
            e.printStackTrace(System.err); // Print the stack trace to the standard error stream
        } finally {
            // Ensure the scanner resource is closed properly to prevent resource leaks
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("\nExiting program."); // Final message printed before program terminates
        }
    }

    /**
     * Contains the main application loop, menu display, and user input processing.
     */
    private static void run() {
        int choice = 0;
        // Loop continues as long as the user's choice is not 5 (Exit)
        while (choice != 5) {
            printMenu(); // Display the main menu

            try {
                System.out.print("Enter your choice: ");
                // Read the integer input for the menu choice
                choice = scanner.nextInt();
                // Consume the rest of the line, including the newline character,
                // which is left behind by nextInt(). This is crucial before calling nextLine().
                scanner.nextLine();

                // Use a switch statement to perform actions based on the user's choice
                switch (choice) {
                    case 1:
                        addTask(); // Call method to handle adding a task
                        break;
                    case 2:
                        taskManager.viewPendingTasks(); // Call TaskManager method to view pending tasks
                        break;
                    case 3:
                        taskManager.viewCompletedTasks(); // Call TaskManager method to view completed tasks
                        break;
                    case 4:
                        taskManager.completeNextTask(); // Call TaskManager method to complete the next task
                        break;
                    case 5:
                        // The loop condition handles exiting. Print a message indicating shutdown is starting.
                        System.out.println("Initiating shutdown...");
                        break;
                    default:
                        // Handle cases where the integer input is not one of the valid options (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle specific exception for non-integer input when an integer is expected
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input token from the scanner's buffer
                // to prevent an infinite loop caused by the same invalid input being read repeatedly.
                scanner.nextLine();
                choice = 0; // Reset choice to 0 (or any value not 5) to ensure the loop continues
            }
             System.out.println(); // Print a blank line for better readability between interactions
        }
    }

    /**
     * Prompts the user to enter a task description and delegates the task creation
     * and addition to the TaskManager.
     */
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the entire line for the task description
        // Delegate the logic of adding the task and handling its specific validation
        // to the TaskManager class. TaskManager prints success/error messages for add.
        taskManager.addTask(description);
    }

    /**
     * Prints the main menu options to the console, including current task counts.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        // Display menu options with current counts from TaskManager
        System.out.println("1. Add Task");
        System.out.println("2. View Pending Tasks (" + taskManager.getPendingTaskCount() + ")");
        System.out.println("3. View Completed Tasks (" + taskManager.getCompletedTaskCount() + ")");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
        System.out.println("--------------------------");
    }
}
