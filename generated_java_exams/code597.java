/*
 * Exam Question #597
 * Generated on: 2025-05-12 16:12:50
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Manufacturing Task Queue System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified manufacturing task management system. This system will manage a queue of manufacturing tasks that need to be processed. Tasks are added to the system and processed in a First-In, First-Out (FIFO) manner. The system should allow users to add new tasks, process the next task in the queue, view the tasks currently waiting in the queue, view tasks that have already been completed, and exit the application.
 * 
 * **System Requirements:**
 * 
 * 1.  **Task Definition:** Each task should have a unique integer ID and a string description.
 * 2.  **Task Management:**
 *     *   Tasks are added to a queue for processing.
 *     *   Processing a task means removing it from the front of the queue and marking it as completed.
 *     *   The system should keep track of both pending tasks (in the queue) and completed tasks.
 * 3.  **User Interface:** The system must provide a command-line interface with the following options:
 *     *   Add New Task: Prompts the user for a task description and adds it to the pending queue. Assign a unique, incrementing ID automatically.
 *     *   Process Next Task: Removes and processes the next task from the queue. If the queue is empty, inform the user.
 *     *   View Pending Tasks: Displays all tasks currently in the pending queue, in order.
 *     *   View Completed Tasks: Displays all tasks that have been processed.
 *     *   Exit: Terminates the application.
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 * 5.  **Flow Control:** Use a `switch` statement to handle the different user menu options.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid input, trying to process from an empty queue).
 *     *   Implement exception handling using `try-catch` blocks to gracefully handle potential runtime errors, particularly related to user input (like entering non-numeric input when a number is expected). This handling should be present at a level that demonstrates understanding of how exceptions propagate.
 * 7.  **Output:** Use `System.out` for all normal output (menu, task details, success messages).
 * 8.  **Data Structures:** You *must* use the following data structures:
 *     *   `java.util.Queue` to manage the pending tasks (you can use a concrete implementation like `LinkedList`).
 *     *   `java.util.ArrayList` to store completed tasks.
 *     *   `java.util.List` interface when referring to collections where the specific implementation is not required (e.g., return types for methods viewing tasks).
 * 9.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Validate user input where necessary.
 *     *   Structure your code into appropriate classes (e.g., a `Task` class and a `TaskManager` class).
 * 
 * **Expected Output Structure:**
 * 
 * The program should display a menu, prompt for input, and based on the input, perform the requested action, printing results or errors to the console (`System.out` or `System.err`).
 * 
 * Example Interaction (Illustrative):
 * ```
 * --- Manufacturing Task Manager ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Calibrate Machine A
 * Task added: Task{id=1, description='Calibrate Machine A'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 1
 * Enter task description: Inspect Product Batch
 * Task added: Task{id=2, description='Inspect Product Batch'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=1, description='Calibrate Machine A'}
 * Task{id=2, description='Inspect Product Batch'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Calibrate Machine A'}
 * Task processed successfully.
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=2, description='Inspect Product Batch'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=1, description='Calibrate Machine A'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 2
 * Processing task: Task{id=2, description='Inspect Product Batch'}
 * Task processed successfully.
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 2
 * No tasks in the queue to process.
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=1, description='Calibrate Machine A'}
 * Task{id=2, description='Inspect Product Batch'}
 * 
 * --- Manufacturing Task Manager ---
 * ... (menu again) ...
 * Enter your choice: 5
 * Exiting Task Manager.
 * ```
 * 
 * Your solution should be provided as complete, runnable Java code.
 *
 * EXPLANATION:
 * This solution implements a Manufacturing Task Queue System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It uses private fields (`taskId`, `description`) and public getter methods (`getTaskId`, `getDescription`) and a constructor, adhering to encapsulation principles. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class encapsulates the core logic of managing tasks.
 *     *   `private Queue<Task> pendingTasksQueue;`: A `Queue` (implemented using `LinkedList`) is used to store tasks waiting to be processed. The `Queue` interface naturally supports the FIFO behavior required for processing tasks in order. `offer()` is used for adding (a safer version of `add`), and `poll()` is used for retrieving and removing the head (returns `null` if empty).
 *     *   `private ArrayList<Task> completedTasksList;`: An `ArrayList` is used to store tasks once they are processed. `ArrayList` is suitable here as we might need to iterate through completed tasks or potentially access them by index (though not strictly required by the problem, it's a common use case).
 *     *   `private int nextTaskId;`: Manages the auto-incrementing unique ID for new tasks.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasksQueue` using `offer()`. Includes basic input validation for the description.
 *     *   `processNextTask()`: Uses `poll()` to get the next task from the queue. It checks if `poll()` returned `null` (meaning the queue was empty) and provides appropriate feedback using `System.err`. If a task is retrieved, it's added to the `completedTasksList`.
 *     *   `getPendingTasks()`: Returns a `List<Task>`. Crucially, it creates a *new* `ArrayList` from the contents of the `pendingTasksQueue`. This serves two purposes: it uses `ArrayList` and returns a `List`, and it provides a snapshot of the queue without exposing the internal `Queue` object directly or allowing external modification of the queue's structure.
 *     *   `getCompletedTasks()`: Returns the `completedTasksList` as a `List<Task>`. Since `ArrayList` implements `List`, this is straightforward and follows the requirement to use the `List` interface.
 * 
 * 3.  **`ManufacturingApp` Class:** This class contains the `main` method and handles the user interaction loop.
 *     *   `Scanner scanner = new Scanner(System.in);`: Used for reading user input from the console.
 *     *   `TaskManager taskManager = new TaskManager();`: An instance of the task manager is created.
 *     *   **Main Loop (`while(running)`):** Continuously displays the menu and processes user input until the user chooses to exit.
 *     *   **`try-catch` Block:** A `try-catch` block wraps the core logic within the loop (reading input and the `switch` statement).
 *         *   `catch (InputMismatchException e)`: Specifically catches cases where the user enters non-integer input when the program expects an integer for the menu choice. It prints an error message using `System.err` and consumes the invalid input (`scanner.next()`) to prevent an infinite loop caused by the scanner repeatedly trying to read the same invalid token.
 *         *   `catch (Exception e)`: A general catch block is included to handle any other unexpected exceptions that might occur during execution within the `try` block. This demonstrates basic class-wide handling of potential runtime issues, printing an error message using `System.err`.
 *     *   **`switch (choice)`:** Directs execution based on the valid integer input from the user, calling the appropriate `TaskManager` methods or handling the exit condition.
 *     *   **Output (`System.out`, `System.err`):** `System.out` is used for displaying the menu, task details, and success messages. `System.err` is used exclusively for reporting error conditions (invalid input, empty queue).
 *     *   **`scanner.close()`:** The `Scanner` resource is closed outside the loop to release system resources.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical scenario, following good object-oriented design and error handling practices.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single manufacturing task.
 */
class Task {
    private int taskId;
    private String description;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "'}";
    }
}

/**
 * Manages the queue of pending tasks and a list of completed tasks.
 */
class TaskManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasksQueue;
    // ArrayList to hold tasks that have been processed
    private ArrayList<Task> completedTasksList;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending tasks queue and completed tasks list.
     */
    public TaskManager() {
        this.pendingTasksQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasksList = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Automatically assigns a unique ID.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasksQueue.offer(newTask); // offer is preferred over add for queues (returns boolean)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Removes it from the pending queue and adds it to the completed list.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task processedTask = pendingTasksQueue.poll();

        if (processedTask == null) {
            System.err.println("No tasks in the queue to process.");
        } else {
            completedTasksList.add(processedTask);
            System.out.println("Processing task: " + processedTask);
            System.out.println("Task processed successfully.");
        }
    }

    /**
     * Gets a list of tasks currently in the pending queue.
     * Note: Returns a copy to avoid external modification of the internal queue.
     * Uses List interface for the return type.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList from the queue's contents to return as a List
        return new ArrayList<>(pendingTasksQueue);
    }

    /**
     * Gets a list of tasks that have been completed.
     * Uses List interface for the return type.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // completedTasksList is already an ArrayList, which implements List
        return completedTasksList;
    }
}

/**
 * Main application class for the Manufacturing Task Queue System.
 * Handles user interaction and manages the TaskManager.
 */
public class ManufacturingApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Manufacturing Task Manager ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        while (running) {
            displayMenu();
            int choice = -1; // Default value for choice

            try {
                // Attempt to read user's menu choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        List<Task> pending = taskManager.getPendingTasks();
                        System.out.println("Pending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("  No tasks pending.");
                        } else {
                            for (Task task : pending) {
                                System.out.println("  " + task);
                            }
                        }
                        break;
                    case 4:
                        List<Task> completed = taskManager.getCompletedTasks();
                        System.out.println("Completed Tasks:");
                        if (completed.isEmpty()) {
                            System.out.println("  No tasks completed yet.");
                        } else {
                            for (Task task : completed) {
                                System.out.println("  " + task);
                            }
                        }
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager.");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent an infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        // Close the scanner resource
        scanner.close();
    }
}
