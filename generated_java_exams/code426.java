/*
 * Exam Question #426
 * Generated on: 2025-05-11 23:09:29
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Automated Data Processing System**
 * 
 * You are tasked with developing a simple command-line application to simulate an Automated Data Processing System. This system receives job requests, queues them for processing, processes them one by one in the order they were received, and maintains a history of completed jobs.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the jobs waiting to be processed (First-In, First-Out order).
 *     *   Use a `java.util.ArrayList` to store the history of completed jobs.
 *     *   Declare variables holding the completed jobs list using the `java.util.List` interface type.
 * 
 * 2.  **Job Representation:**
 *     *   Create a `Job` class with private fields for `id` (int), `description` (String), and `isProcessed` (boolean).
 *     *   The constructor should initialize these fields and validate that the description is not null or empty.
 *     *   Provide public getter methods for the fields.
 *     *   Include a public method `markAsProcessed()` to set the `isProcessed` flag.
 *     *   Override the `toString()` method for easy printing of job details.
 * 
 * 3.  **Processing System Logic:**
 *     *   Create a `TaskProcessingSystem` class to encapsulate the system's state and logic.
 *     *   It should have private fields for the job queue, the completed jobs list, and a counter for generating unique job IDs.
 *     *   Implement a public method `submitJob(String description)`:
 *         *   Creates a new `Job` object with a unique ID and the provided description.
 *         *   Adds the new job to the queue.
 *         *   Returns the ID of the submitted job.
 *         *   Should throw an `IllegalArgumentException` if the description is invalid (handled by the `Job` constructor).
 *     *   Implement a public method `processNextJob()`:
 *         *   Retrieves and removes the next job from the queue.
 *         *   If a job is found, calls its `markAsProcessed()` method and adds it to the completed jobs list.
 *         *   Returns the processed `Job` object, or `null` if the queue was empty.
 *     *   Implement public methods `getJobQueueContents()` and `getCompletedJobs()` that return a `List<Job>` representing the current state of the queue and completed jobs list, respectively. These methods should ideally return copies or unmodifiable views to protect the internal state. Returning a new `ArrayList` containing the elements is acceptable for this exam.
 *     *   Include methods to get the size of the queue and the number of completed jobs.
 * 
 * 4.  **User Interface (Main Application):**
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Present a menu of options to the user:
 *         1.  Submit New Job
 *         2.  Process Next Job
 *         3.  View Job Queue
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   For "Submit New Job", prompt for the description and call the `submitJob` method.
 *     *   For "Process Next Job", call the `processNextJob` method and report the result.
 *     *   For "View Job Queue" and "View Completed Jobs", call the respective getter methods and print the details of each job in the returned list. Indicate if the list/queue is empty.
 *     *   For "Exit", terminate the application.
 *     *   Handle invalid menu choices.
 * 
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for normal output (menu, prompts, success messages, job details).
 *     *   Use `System.err` to display error messages (e.g., invalid input, failure to submit job due to validation).
 *     *   Implement exception handling:
 *         *   Use specific `try-catch` blocks around operations that might throw predictable exceptions (e.g., calling `submitJob` which might throw `IllegalArgumentException`, reading integer input with `Scanner` which might throw `InputMismatchException`).
 *         *   Wrap the main application loop or a significant portion of the core logic in a general `try-catch(Exception e)` block to catch any unexpected runtime errors, printing an error message using `System.err` and potentially the stack trace.
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain key parts of the code.
 *     *   Implement input validation where necessary (e.g., job description).
 * 
 * **Expected Output Structure:**
 * 
 * The program should start, display a menu, accept input, perform the requested action, print results or errors, and loop until the user chooses to exit.
 * 
 * Example Interaction:
 * 
 * ```
 * --- Automated Task Processing System ---
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter job description: Analyze Sales Data
 * Job submitted successfully! ID: 1
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter job description: Generate Report
 * Job submitted successfully! ID: 2
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 3
 * --- Job Queue (2 jobs) ---
 * Job [ID=1, Description='Analyze Sales Data', Processed=false]
 * Job [ID=2, Description='Generate Report', Processed=false]
 * ---------------------------
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 2
 * Processed job: Job [ID=1, Description='Analyze Sales Data', Processed=true]
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 3
 * --- Job Queue (1 jobs) ---
 * Job [ID=2, Description='Generate Report', Processed=false]
 * ---------------------------
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 4
 * --- Completed Jobs (1 jobs) ---
 * Job [ID=1, Description='Analyze Sales Data', Processed=true]
 * ---------------------------
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 6
 * Invalid choice. Please try again.
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 5
 * Exiting Task Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your task is to write the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements the Automated Data Processing System as required, demonstrating the use of all specified Java components and best practices.
 * 
 * 1.  **Job Class:** Represents a single task with an ID, description, and processing status. It enforces data integrity by validating the description in the constructor and uses encapsulation with private fields and public getters/methods. The `toString()` method provides a convenient way to display job information.
 * 
 * 2.  **TaskProcessingSystem Class:** This is the core logic handler.
 *     *   It uses a `java.util.Queue<Job>` (specifically `LinkedList`) for `jobQueue` to ensure jobs are processed in the order they are submitted (FIFO). `offer()` is used to add jobs to the queue, and `poll()` is used to retrieve and remove the next job.
 *     *   It uses a `java.util.List<Job>` (specifically `ArrayList`) for `completedJobs` to store jobs after they have been processed. `ArrayList` is suitable here as we just need to add completed jobs and iterate through them.
 *     *   The `completedJobs` variable is declared using the `List` interface (`List<Job> completedJobs = new ArrayList<>();`), demonstrating the use of the interface type. Getter methods also return `List<Job>`.
 *     *   `submitJob` creates and adds jobs to the queue. It relies on the `Job` constructor for description validation.
 *     *   `processNextJob` takes a job from the queue (`poll()`), marks it as processed, and moves it to the completed list.
 *     *   `getJobQueueContents()` and `getCompletedJobs()` return *new* `ArrayList` instances containing the current elements. This is a common practice to provide access to the data without allowing external code to directly modify the internal `Queue` or `List` objects themselves, thus preserving encapsulation.
 * 
 * 3.  **TaskSystemApp Class (Main Application):**
 *     *   This class contains the `main` method and handles the user interface.
 *     *   `Scanner` is used to read input from `System.in`. The `try-with-resources` block ensures the `Scanner` is automatically closed when the block is exited, preventing resource leaks.
 *     *   A `switch` statement is used to direct the program flow based on the user's menu choice. This is a clean way to handle multiple distinct command options.
 *     *   `System.out` is used for displaying the menu, prompts, success messages, and the contents of the queue and completed lists.
 *     *   `System.err` is used specifically for error messages, such as when input validation fails (`IllegalArgumentException`) or when the user enters non-numeric input for the menu choice (`InputMismatchException`).
 *     *   **Exception Handling:**
 *         *   A specific `try-catch(InputMismatchException e)` block is used around `scanner.nextInt()` to gracefully handle cases where the user enters text instead of a number for the menu choice. It prints an error to `System.err` and consumes the invalid input.
 *         *   A specific `try-catch(IllegalArgumentException e)` block is used around `system.submitJob()` to catch the validation error thrown by the `Job` constructor if the description is empty. It prints the validation error message to `System.err`.
 *         *   A general `try-catch(Exception e)` block wraps the main `while` loop. This serves as a class-wide catch-all for any other unexpected runtime exceptions that might occur during the application's execution, preventing the program from crashing abruptly. It prints a general error message and the stack trace to `System.err` for debugging.
 * 
 * This solution effectively integrates the required Java components within a structured, encapsulated, and robust application that handles user interaction and potential errors appropriately.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner input type mismatch

/**
 * Represents a single data processing job.
 */
class Job {
    private int id;
    private String description;
    private boolean isProcessed;

    /**
     * Constructs a new Job.
     * @param id The unique ID for the job.
     * @param description The description of the task for this job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Job(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.isProcessed = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    /**
     * Marks this job as processed.
     */
    public void markAsProcessed() {
        this.isProcessed = true;
    }

    /**
     * Provides a string representation of the Job object.
     */
    @Override
    public String toString() {
        return "Job [ID=" + id + ", Description='" + description + "', Processed=" + isProcessed + "]";
    }
}

/**
 * Manages the queue of jobs and the list of completed jobs.
 */
class TaskProcessingSystem {
    // Using Queue interface, implemented by LinkedList for FIFO behavior
    private Queue<Job> jobQueue;
    // Using List interface, implemented by ArrayList for dynamic storage of completed jobs
    private List<Job> completedJobs;
    private int nextJobId; // Counter for generating unique job IDs

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the job queue, completed jobs list, and job ID counter.
     */
    public TaskProcessingSystem() {
        this.jobQueue = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new job to the processing queue.
     * @param description The description of the job.
     * @return The ID assigned to the newly submitted job.
     * @throws IllegalArgumentException if the description is invalid (handled by Job constructor).
     */
    public int submitJob(String description) {
        // Job constructor validates description and throws IllegalArgumentException if needed
        Job newJob = new Job(nextJobId++, description);
        jobQueue.offer(newJob); // Add the job to the end of the queue
        return newJob.getId();
    }

    /**
     * Processes the next available job in the queue.
     * @return The Job that was processed, or null if the queue was empty.
     */
    public Job processNextJob() {
        Job jobToProcess = jobQueue.poll(); // Retrieve and remove the head of the queue
        if (jobToProcess != null) {
            jobToProcess.markAsProcessed(); // Mark the job as complete
            completedJobs.add(jobToProcess); // Add the processed job to the completed list
        }
        return jobToProcess;
    }

    /**
     * Gets a list representing the current contents of the job queue.
     * Returns a new ArrayList to avoid exposing the internal Queue structure directly.
     * @return A List of Job objects currently in the queue.
     */
    public List<Job> getJobQueueContents() {
        // Create and return a new ArrayList containing elements from the queue
        // This provides a snapshot and protects the internal queue state
        return new ArrayList<>(jobQueue);
    }

    /**
     * Gets a list of all jobs that have been completed.
     * Returns a new ArrayList to avoid exposing the internal List directly.
     * @return A List of completed Job objects.
     */
    public List<Job> getCompletedJobs() {
        // Create and return a new ArrayList containing elements from the completedJobs list
        // This provides a snapshot and protects the internal list state
        return new ArrayList<>(completedJobs);
    }

    /**
     * Gets the current number of jobs waiting in the queue.
     * @return The size of the job queue.
     */
    public int getQueueSize() {
        return jobQueue.size();
    }

    /**
     * Gets the total number of jobs that have been completed.
     * @return The count of completed jobs.
     */
    public int getCompletedCount() {
        return completedJobs.size();
    }
}

/**
 * Main application class for the Automated Data Processing System.
 * Handles user interaction and coordinates with the TaskProcessingSystem.
 */
public class TaskSystemApp {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Submit New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Job Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        // Use try-with-resources for Scanner to ensure it's closed automatically
        try (Scanner scanner = new Scanner(System.in)) {

            System.out.println("--- Automated Task Processing System ---");

            boolean running = true;
            // Class-wide exception handling wrapping the main application loop
            try {
                while (running) {
                    printMenu();
                    System.out.print("Enter choice: ");

                    int choice = -1;
                    // Specific try-catch for reading integer input to handle non-numeric input
                    try {
                        choice = scanner.nextInt();
                        // Consume the newline character left by nextInt()
                        scanner.nextLine();
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number corresponding to a menu option.");
                        // Consume the invalid input to prevent an infinite loop
                        scanner.nextLine();
                        continue; // Skip the rest of the loop iteration and show the menu again
                    }

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1: // Submit Job
                            System.out.print("Enter job description: ");
                            String description = scanner.nextLine();
                            // Specific try-catch for submitting job to handle validation errors
                            try {
                                int jobId = system.submitJob(description);
                                System.out.println(System.lineSeparator() + "Job submitted successfully! ID: " + jobId);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error submitting job: " + e.getMessage());
                            }
                            break;

                        case 2: // Process Next Job
                            Job processedJob = system.processNextJob();
                            if (processedJob != null) {
                                System.out.println(System.lineSeparator() + "Processed job: " + processedJob);
                            } else {
                                System.out.println(System.lineSeparator() + "No jobs in the queue to process.");
                            }
                            break;

                        case 3: // View Job Queue
                            List<Job> queueContents = system.getJobQueueContents();
                            if (queueContents.isEmpty()) {
                                System.out.println(System.lineSeparator() + "Job queue is empty.");
                            } else {
                                System.out.println(System.lineSeparator() + "--- Job Queue (" + system.getQueueSize() + " jobs) ---");
                                for (Job job : queueContents) {
                                    System.out.println(job);
                                }
                                System.out.println("---------------------------");
                            }
                            break;

                        case 4: // View Completed Jobs
                            List<Job> completedList = system.getCompletedJobs();
                            if (completedList.isEmpty()) {
                                System.out.println(System.lineSeparator() + "No jobs have been completed yet.");
                            } else {
                                System.out.println(System.lineSeparator() + "--- Completed Jobs (" + system.getCompletedCount() + " jobs) ---");
                                for (Job job : completedList) {
                                    System.out.println(job);
                                }
                                System.out.println("---------------------------");
                            }
                            break;

                        case 5: // Exit
                            System.out.println(System.lineSeparator() + "Exiting Task Processing System. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break;

                        default: // Invalid choice
                            System.out.println("Invalid choice. Please try again.");
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions that occur within the main loop
                System.err.println(System.lineSeparator() + "An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging purposes
            }
            // Scanner is automatically closed by the try-with-resources block
        } // End of try-with-resources block, scanner is closed here
        System.out.println("Application finished."); // Confirmation after scanner is closed
    }
}
