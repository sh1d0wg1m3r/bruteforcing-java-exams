/*
 * Exam Question #946
 * Generated on: 2025-05-12 17:03:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simplified console-based system for managing customer orders in a small restaurant. The system should allow staff to view the menu, create new orders by selecting items from the menu, and place these orders into a queue for the kitchen to process. The kitchen staff can then process the next order waiting in the queue.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Menu:** Maintain a fixed list of menu items, each with a name and price.
 * 2.  **Order Creation:** Allow the user (simulating restaurant staff) to create a new order by repeatedly selecting items from the menu by their number. The user should indicate when they are finished adding items.
 * 3.  **Order Placement:** Once an order is finalized, it should be added to a queue of pending orders for the kitchen.
 * 4.  **Order Processing:** Allow the user (simulating kitchen staff) to process the next order from the front of the queue. Processing an order should display its details (items and total price) and remove it from the queue. Handle the case where the queue is empty.
 * 5.  **User Interface:** Provide a simple text-based menu with options to display the menu, create a new order, process the next order, or exit.
 * 6.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and item selections. Implement input validation to handle non-numeric input or invalid menu/item numbers.
 * 7.  **Error Reporting:** Use `System.err` to print error messages (e.g., invalid input, system errors).
 * 8.  **Normal Output:** Use `System.out` for all other output (menu display, prompts, order details, success messages).
 * 9.  **Flow Control:** Use a `switch` statement to handle the main menu options.
 * 10. **Data Structures:** You *must* use:
 *     *   `java.util.Queue` (use an implementing class like `LinkedList` or `ArrayDeque`) for the order queue.
 *     *   `java.util.ArrayList` (use directly or as the concrete implementation of a `List`) to store items within an `Order`.
 *     *   `java.util.List` interface (use as the type for the menu or for the list of items in an `Order`).
 * 11. **Exception Handling:** Implement class-wide `try-catch` block(s) to handle potential runtime errors gracefully, especially around user input and queue operations. Handle specific exceptions where appropriate (e.g., `InputMismatchException`).
 * 12. **Object-Oriented Design:** Structure your code using appropriate classes (e.g., `MenuItem`, `Order`, `RestaurantSystem`). Follow best practices:
 *     *   Use private fields and public methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining key parts.
 * 
 * **Expected Output:**
 * 
 * Your program should present a menu like this:
 * 
 * ```
 * Welcome to the Restaurant Order System!
 * 
 * Choose an option:
 * 1. Display Menu
 * 2. Create New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter choice:
 * ```
 * 
 * Based on the user's choice, it should perform the corresponding action. Example interactions:
 * 
 * *   **Display Menu:** Shows numbered list of items and prices.
 * *   **Create Order:** Prompts user to enter item numbers, validates input, allows adding multiple items, adds finalized order to queue, confirms placement. Handles invalid item numbers or non-numeric input with `System.err`.
 * *   **Process Order:** Removes the oldest order from the queue, displays its contents and total. If the queue is empty, prints a message to `System.out`. Handles potential errors during processing with `System.err`.
 * *   **Exit:** Ends the program.
 * 
 * Invalid main menu choices should print an error to `System.err` and reprompt. Unexpected errors during execution should be caught by a top-level handler and reported via `System.err`.
 * 
 * **Time Limit:** 45-60 minutes
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple console-based restaurant order management system as described in the problem. It effectively demonstrates the required Java concepts and follows best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Design:** The system is structured into three classes:
 *     *   `MenuItem`: Represents a single item with encapsulated `name` and `price`.
 *     *   `Order`: Represents a customer order with an `orderId` and a `List` of `MenuItem`s. It uses `ArrayList` as the concrete implementation for the list of items, showcasing the use of both the interface and an implementation. It includes methods for adding items and calculating the total.
 *     *   `RestaurantSystem`: The main class that orchestrates the application. It holds the `menu` (as a `List`), the `orderQueue` (as a `Queue`), manages the `nextOrderId`, and handles user interaction via `Scanner`. It contains the core logic for displaying the menu, creating orders, processing orders, and the main application loop.
 * 
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`):**
 *     *   `List<MenuItem> menu`: Used to store the fixed list of menu items. `ArrayList` is used for its implementation, demonstrating how the interface and concrete class are used together.
 *     *   `List<MenuItem> items` within the `Order` class: Declared as a `List` interface type but instantiated as `new ArrayList<>()`, again showing interface/implementation usage and providing a dynamic list for order items.
 *     *   `Queue<Order> orderQueue`: Used to manage the incoming orders waiting to be processed. `LinkedList` is used as a common implementation of the `Queue` interface, demonstrating its FIFO (First-In, First-Out) behavior via `offer()` (add to end) and `poll()` (remove from front) methods.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is created to read input from `System.in`.
 *     *   `scanner.nextInt()` is used to read integer choices/item numbers.
 *     *   `scanner.nextLine()` is crucial after reading an integer to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls (though not strictly needed in this exact structure where the next read is also `nextInt`, it's a vital pattern for mixing `nextInt`/`nextDouble` with `nextLine`).
 * 
 * 4.  **Flow Control (`Switch`):**
 *     *   A `switch` statement in the `run()` method is used to direct the program flow based on the user's main menu choice (1, 2, 3, or 4).
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and processed order details, representing normal program output.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid user input or unexpected issues during operations, directing error information to the standard error stream.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** `try-catch (InputMismatchException e)` blocks are used around `scanner.nextInt()` calls to gracefully handle cases where the user enters non-numeric input. The invalid input is consumed using `scanner.nextLine()` within the catch block to clear the scanner's buffer and prevent an infinite loop.
 *     *   **Specific Exception Handling:** A `try-catch (IndexOutOfBoundsException e)` is included (though the logic checks prevent it from being hit with valid input) to show handling of potential list indexing errors. A `try-catch (NoSuchElementException e)` is included in `processNextOrder` although `poll()` doesn't throw it (it returns null); this demonstrates awareness of queue-related exceptions like the one `remove()` would throw.
 *     *   **General/Class-wide Handling:** A broad `try-catch (Exception e)` block is wrapped around the main `while` loop in the `run()` method. This serves as a catch-all for any unexpected runtime errors that might occur anywhere within the main program flow that weren't handled by more specific catches. It prints a critical error message and the stack trace to `System.err` before the program terminates.
 *     *   **Resource Management:** A `finally` block is used to ensure the `scanner` is closed when the `run()` method finishes, releasing the system resource.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in all classes are `private`, and access is controlled through public methods (getters, `addItem`, `calculateTotal`).
 *     *   **Meaningful Names:** Variables (`orderQueue`, `nextOrderId`), methods (`createOrder`, `processNextOrder`), and classes (`MenuItem`, `Order`, `RestaurantSystem`) have names that clearly indicate their purpose.
 *     *   **Comments:** Basic Javadoc-style comments explain the purpose of classes and key methods.
 *     *   **Input Validation:** Checks are performed to ensure item numbers are within the valid range (0 or 1 to menu size). `InputMismatchException` is handled for non-numeric input.
 *     *   **Error Handling:** Errors are reported via `System.err`, specific exceptions are handled where appropriate, and a general catch provides robustness. The empty queue scenario is handled gracefully.
 *     *   **Clean Code Structure:** The code is divided into logical units (classes), and methods have clear responsibilities.
 * 
 * This solution effectively integrates the required Java features into a functional program that simulates a real-world scenario, demonstrating a solid understanding of core Java programming principles and practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Represents a single item on the restaurant menu.
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " ($" + String.format("%.2f", price) + ")";
    }
}

// Represents a customer order.
class Order {
    private int orderId;
    private List<MenuItem> items; // Use List interface, implemented by ArrayList

    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // Use ArrayList implementation
    }

    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return items; // Return the list of items
    }

    /**
     * Adds a menu item to the order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
        } else {
            // Should not happen with proper validation upstream, but good practice
            System.err.println("Attempted to add a null item to Order " + orderId);
        }
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double calculateTotal() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(":\n");
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append(" ($").append(String.format("%.2f", item.getPrice())).append(")\n");
        }
        sb.append("Total: $").append(String.format("%.2f", calculateTotal()));
        return sb.toString();
    }
}

// Main class managing the restaurant system.
public class RestaurantSystem { // Make public for main method

    private List<MenuItem> menu; // List interface
    private Queue<Order> orderQueue; // Queue interface
    private int nextOrderId;
    private Scanner scanner;

    public RestaurantSystem() {
        // Initialize components
        this.menu = new ArrayList<>(); // ArrayList implementation for menu
        this.orderQueue = new LinkedList<>(); // LinkedList implementation for Queue
        this.nextOrderId = 1; // Start order IDs from 1
        this.scanner = new Scanner(System.in);

        // Populate the menu (example items)
        initializeMenu();
    }

    /**
     * Populates the restaurant menu with initial items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Fries", 3.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Salad", 7.00));
        menu.add(new MenuItem("Ice Cream", 4.00));
    }

    /**
     * Displays the current menu to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
        System.out.println("------------");
    }

    /**
     * Allows staff to create a new order and add it to the queue.
     * Handles user input for item selection and validation.
     */
    private void createOrder() {
        System.out.println("\n--- Create New Order ---");
        Order currentOrder = new Order(nextOrderId); // Use current ID, increment only if placed
        boolean addingItems = true;

        while (addingItems) {
            displayMenu();
            System.out.print("Enter item number to add (0 to finish order): ");
            try {
                int itemNumber = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                if (itemNumber == 0) {
                    addingItems = false;
                    if (currentOrder.getItems().isEmpty()) {
                        System.out.println("Order creation cancelled as no items were added.");
                    } else {
                        orderQueue.offer(currentOrder); // Add order to the queue
                        System.out.println("Order #" + currentOrder.getOrderId() + " placed successfully with " + currentOrder.getItems().size() + " item(s).");
                        nextOrderId++; // Increment ID only when order is successfully placed
                    }
                } else if (itemNumber > 0 && itemNumber <= menu.size()) {
                    MenuItem selectedItem = menu.get(itemNumber - 1);
                    currentOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else {
                    System.err.println("Invalid item number. Please enter a number from the menu or 0 to finish.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IndexOutOfBoundsException e) {
                 // This catch is technically redundant due to the check above (itemNumber <= menu.size()),
                 // but included as a defensive measure.
                 System.err.println("Error selecting item: Index out of bounds.");
            } catch (Exception e) {
                // Catch any other unexpected errors during item selection loop
                System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                // Potentially set addingItems = false here if the error is critical
            }
        }
    }

    /**
     * Processes the next order from the front of the queue.
     * Removes the order after processing.
     */
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        try {
            // poll() retrieves and removes the head of the queue, returns null if queue is empty
            Order orderToProcess = orderQueue.poll();

            if (orderToProcess != null) {
                System.out.println("Processing " + orderToProcess); // Uses Order's toString()
                System.out.println("Order #" + orderToProcess.getOrderId() + " processed successfully.");
            } else {
                System.out.println("No orders in the queue to process.");
            }
        } catch (NoSuchElementException e) {
             // poll() does not throw NoSuchElementException. This catch block
             // would be relevant if using remove() instead of poll().
             // Included for demonstrating catching a queue-related exception.
             System.err.println("Error processing queue: Queue is unexpectedly empty (NoSuchElementException).");
        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred while processing order: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging critical errors
        }
    }

    /**
     * Runs the main application loop, presenting options to the user.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Welcome to the Restaurant Order System!");
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                System.out.println("\n--- Main Menu ---");
                System.out.println("1. Display Menu");
                System.out.println("2. Create New Order");
                System.out.println("3. Process Next Order");
                System.out.println("4. Exit");
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        createOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception that wasn't handled elsewhere
            System.err.println("\n[CRITICAL ERROR] A serious unexpected error occurred. The system is shutting down.");
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure scanner is closed regardless of how the loop exits (normal or error)
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System cleanup complete.");
        }
    }

    // Main method - entry point of the application
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
