/*
 * Exam Question #718
 * Generated on: 2025-05-12 16:30:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Job Processing Simulator
 * 
 * **Objective:** Design and implement a command-line application that simulates a simple job processing system. The system manages a queue of waiting jobs and a list of completed jobs.
 * 
 * **Scenario:**
 * You are building a basic system where jobs are submitted and then processed in the order they were received (First-In, First-Out). Users interact with the system via a console menu to add new jobs, process the next job, view the list of jobs waiting to be processed, view the list of jobs that have been completed, or exit the application.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store jobs that are waiting to be processed.
 *     *   Use `java.util.ArrayList` to store jobs that have been completed.
 *     *   When retrieving the list of completed jobs or waiting jobs for display, declare the variable using the `java.util.List` interface.
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 3.  **Job Representation:**
 *     *   Create a `Job` class with private fields for a unique job ID (integer) and a job description (String).
 *     *   Implement a constructor and public getter methods for the fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of a job.
 *     *   Include basic input validation in the `Job` constructor (e.g., description cannot be empty).
 * 
 * 4.  **Job Processor Logic:**
 *     *   Create a `JobProcessor` class to manage the waiting queue and completed list.
 *     *   Include methods like `addJob(String description)`, `processNextJob()`, `getWaitingJobs()`, and `getCompletedJobs()`.
 *     *   The `addJob` method should create a new `Job` with an auto-generated ID and add it to the waiting queue.
 *     *   The `processNextJob` method should remove the job from the front of the waiting queue and add it to the completed list. It should return the processed job or indicate failure if the queue is empty.
 * 
 * 5.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and job lists.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, attempting to process when the queue is empty, validation errors).
 * 
 * 6.  **Error Handling:**
 *     *   Implement input validation for menu choices (ensure it's a number within the valid range). Handle non-numeric input gracefully.
 *     *   Handle the case where the user tries to process a job when the waiting queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application logic to catch any unexpected runtime errors and report them using `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc comments for classes and methods).
 *     *   Structure the code logically into classes.
 * 
 * **Implementation Details:**
 * *   You may implement all classes within a single `.java` file for simplicity in an exam setting.
 * *   The job IDs should be simple sequential integers starting from 1.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Job Processing Simulator ---
 * Select an option:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Waiting Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Clean the office
 * Job added: Job [ID=1, Desc='Clean the office']
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 1
 * Enter job description: Prepare report
 * Job added: Job [ID=2, Desc='Prepare report']
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 3
 * --- Waiting Jobs ---
 * Job [ID=1, Desc='Clean the office']
 * Job [ID=2, Desc='Prepare report']
 * --------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * Job processed: Job [ID=1, Desc='Clean the office']
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 3
 * --- Waiting Jobs ---
 * Job [ID=2, Desc='Prepare report']
 * --------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job [ID=1, Desc='Clean the office']
 * ----------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * Job processed: Job [ID=2, Desc='Prepare report']
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * No jobs in the waiting queue to process.
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job [ID=1, Desc='Clean the office']
 * Job [ID=2, Desc='Prepare report']
 * ----------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: exit
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 5
 * Exiting simulator. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Your task is to provide the complete Java code for this Job Processing Simulator.**
 *
 * EXPLANATION:
 * This solution implements the Job Processing Simulator as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Overall Architecture:**
 * The solution is structured into three classes:
 * 1.  `Job`: Represents the data structure for a single job.
 * 2.  `JobProcessor`: Manages the collection of jobs (waiting and completed) and the core processing logic.
 * 3.  `JobSimulator`: Contains the `main` method, handles user interaction via the console, and orchestrates calls to the `JobProcessor`.
 * 
 * **Usage of Required Components:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):**
 *     *   The `JobProcessor` class declares a private field `waitingQueue` of type `Queue<Job>`.
 *     *   It is initialized using `new LinkedList<>()`, as `LinkedList` is a common class that implements the `Queue` interface.
 *     *   Jobs are added to the queue using `waitingQueue.offer()`.
 *     *   Jobs are removed from the front of the queue using `waitingQueue.poll()`.
 * 
 * 2.  **`ArrayList` (`java.util.ArrayList`):**
 *     *   The `JobProcessor` class declares a private field `completedJobs` of type `List<Job>`.
 *     *   It is initialized using `new ArrayList<>()`. `ArrayList` is used as the concrete implementation for storing completed jobs, providing dynamic array capabilities.
 * 
 * 3.  **`List interface` (`java.util.List`):**
 *     *   The `completedJobs` field in `JobProcessor` is declared using the `List` interface (`private List<Job> completedJobs;`), although it's instantiated as an `ArrayList`. This demonstrates programming to the interface.
 *     *   In the `JobSimulator` (main method), when retrieving the lists of waiting and completed jobs (`processor.getWaitingJobs()` and `processor.getCompletedJobs()`), the return values are assigned to variables declared with the `List<Job>` interface type (`List<Job> waiting = ...;`, `List<Job> completed = ...;`). This further reinforces the use of the interface for manipulating collections.
 * 
 * 4.  **`Scanner` (`java.util.Scanner`):**
 *     *   A `Scanner` object (`scanner`) is created in the `main` method to read input from `System.in`.
 *     *   `scanner.nextLine()` is used to read the user's choice and job descriptions. Reading the entire line helps handle potential non-integer input for menu choices gracefully.
 * 
 * 5.  **`Switch statement`:**
 *     *   A `switch` statement in the `main` method is used to control the program flow based on the user's integer choice from the menu (cases 1 through 5 and a `default` case for invalid numbers).
 * 
 * 6.  **`System.err`:**
 *     *   Used in the `main` method to display error messages:
 *         *   When the user enters non-numeric input for the menu choice.
 *         *   When the user enters an integer outside the valid menu range (in the `default` case of the `switch`).
 *         *   When the user attempts to process a job but the waiting queue is empty.
 *         *   When an `IllegalArgumentException` is caught during job creation (e.g., empty description).
 *         *   In the outer `catch` block to report any unexpected runtime exceptions.
 * 
 * 7.  **`System.out`:**
 *     *   Used throughout the `JobSimulator` class for standard output:
 *         *   Printing the welcome message and the main menu.
 *         *   Displaying prompts for user input.
 *         *   Printing confirmation messages (e.g., "Exiting simulator.").
 *         *   Printing the contents of the waiting and completed job lists, including headers and separators.
 *     *   Used in the `JobProcessor` class to print success messages when a job is added or processed.
 * 
 * 8.  **`Class-wide exception handling with try-catch blocks`:**
 *     *   The core `while (running)` loop in the `main` method is wrapped in a large `try-catch(Exception e)` block. This serves as the "class-wide" handler for unexpected exceptions that might occur during the program's execution, catching any `Exception` subclass not handled by more specific `try-catch` blocks.
 *     *   More specific `try-catch` blocks are used for expected potential issues within the loop:
 *         *   Catching `NumberFormatException` when parsing the user's menu input.
 *         *   Catching `IllegalArgumentException` when calling `processor.addJob()`, which can be thrown by the `Job` constructor if the description is invalid.
 *     *   A `finally` block is used to ensure the `Scanner` resource is closed regardless of whether the loop finishes normally or an exception is caught.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Job` and `JobProcessor` classes have private fields (`jobId`, `description`, `waitingQueue`, `completedJobs`, `nextJobId`) and provide public methods (`getJobId`, `getDescription`, `addJob`, `processNextJob`, etc.) to access and modify their state, controlling how the data is used.
 * *   **Meaningful Names:** Variables (`waitingQueue`, `completedJobs`, `nextJobId`, `processedJob`, `description`, `choice`, `running`), methods (`addJob`, `processNextJob`, `getWaitingJobs`, `getCompletedJobs`, `printMenu`), and classes (`Job`, `JobProcessor`, `JobSimulator`) are named descriptively, indicating their purpose.
 * *   **Comments and Documentation:** Javadoc comments are used for classes and methods to explain their purpose, parameters, return values, and potential exceptions. Inline comments clarify specific logic points.
 * *   **Input Validation:** The `Job` constructor validates the description. The `main` method validates the menu input (numeric and range).
 * *   **Proper Error Handling:** Errors are anticipated (invalid input, empty queue, invalid data) and handled using checks (`if (processedJob == null)`, `if (waiting.isEmpty())`), specific exception catches (`NumberFormatException`, `IllegalArgumentException`), and a general catch for unexpected errors. Error messages are directed to `System.err`.
 * *   **Clean Code Structure:** The logic is separated into well-defined classes with specific responsibilities. The `main` method focuses on UI and coordination, delegating job management to `JobProcessor`. A separate `printMenu` method keeps the main loop cleaner.
 * 
 * This solution effectively integrates the required Java components within a practical, albeit simplified, real-world scenario, demonstrating fundamental object-oriented design, collection usage, input/output handling, control flow, and robust error management.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single job with an ID and description.
 */
class Job {
    private int jobId;
    private String description;

    /**
     * Constructs a new Job.
     *
     * @param jobId       The unique identifier for the job.
     * @param description The description of the job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Job(int jobId, String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        this.jobId = jobId;
        this.description = description.trim();
    }

    /**
     * Gets the job ID.
     *
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the job description.
     *
     * @return The job description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Job.
     *
     * @return A formatted string including job ID and description.
     */
    @Override
    public String toString() {
        return "Job [ID=" + jobId + ", Desc='" + description + "']";
    }
}

/**
 * Manages the waiting queue and completed list of jobs.
 */
class JobProcessor {
    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<Job> waitingQueue;
    // List to hold jobs that have been completed
    private List<Job> completedJobs;
    // Counter for generating unique job IDs
    private int nextJobId;

    /**
     * Constructs a new JobProcessor, initializing the queues and lists.
     */
    public JobProcessor() {
        // Using LinkedList as an implementation of Queue
        this.waitingQueue = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new job to the waiting queue.
     *
     * @param description The description of the job.
     * @throws IllegalArgumentException if the description is null or empty,
     *                                  propagated from the Job constructor.
     */
    public void addJob(String description) {
        // Job constructor handles description validation
        Job newJob = new Job(nextJobId++, description);
        waitingQueue.offer(newJob); // offer() is a safe way to add to a queue
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job from the waiting queue.
     *
     * @return The processed Job, or null if the waiting queue was empty.
     */
    public Job processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Job jobToProcess = waitingQueue.poll();
        if (jobToProcess != null) {
            completedJobs.add(jobToProcess);
            System.out.println("Job processed: " + jobToProcess);
        } else {
            // Error message handled by the caller (main method)
        }
        return jobToProcess;
    }

    /**
     * Gets a list of jobs currently in the waiting queue.
     * Returns a new ArrayList containing the elements from the queue.
     *
     * @return A List of waiting Jobs.
     */
    public List<Job> getWaitingJobs() {
        // Return a new ArrayList copy to avoid external modification of the internal queue state
        return new ArrayList<>(waitingQueue);
    }

    /**
     * Gets a list of jobs that have been completed.
     *
     * @return A List of completed Jobs.
     */
    public List<Job> getCompletedJobs() {
        // Return the direct reference to the completedJobs ArrayList
        return completedJobs;
    }

    /**
     * Checks if the waiting queue is empty.
     *
     * @return true if the waiting queue is empty, false otherwise.
     */
    public boolean isWaitingQueueEmpty() {
        return waitingQueue.isEmpty();
    }

     /**
     * Checks if the completed jobs list is empty.
     *
     * @return true if the completed jobs list is empty, false otherwise.
     */
    public boolean isCompletedJobsEmpty() {
        return completedJobs.isEmpty();
    }
}

/**
 * Main application class for the Job Processing Simulator.
 * Handles user interaction and orchestrates JobProcessor operations.
 */
public class JobSimulator {

    /**
     * Main method to run the Job Simulator.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        JobProcessor processor = new JobProcessor();
        boolean running = true;

        System.out.println("--- Job Processing Simulator ---");

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Read the entire line to handle potential non-integer input gracefully
                String input = scanner.nextLine();
                int choice = -1; // Default invalid choice

                try {
                    // Attempt to parse the input as an integer
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // If parsing fails, choice remains -1, handled by the switch default
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use a switch statement to handle menu options
                switch (choice) {
                    case 1: // Add New Job
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        try {
                             // Add job using the processor
                             processor.addJob(description);
                        } catch (IllegalArgumentException e) {
                            // Catch validation errors from Job constructor/addJob method
                            System.err.println("Error adding job: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Job
                        // Attempt to process the next job
                        Job processedJob = processor.processNextJob();
                        if (processedJob == null) {
                            // If processNextJob returned null, the queue was empty
                            System.err.println("No jobs in the waiting queue to process.");
                        }
                        // Success message is printed inside JobProcessor.processNextJob()
                        break;

                    case 3: // View Waiting Jobs
                        // Get the list of waiting jobs using the List interface
                        List<Job> waiting = processor.getWaitingJobs();
                        if (waiting.isEmpty()) {
                            System.out.println("Waiting queue is empty.");
                        } else {
                            System.out.println("--- Waiting Jobs ---");
                            // Iterate and print using the List interface
                            for (Job job : waiting) {
                                System.out.println(job); // Uses Job's toString()
                            }
                            System.out.println("--------------------");
                        }
                        break;

                    case 4: // View Completed Jobs
                        // Get the list of completed jobs using the List interface
                        List<Job> completed = processor.getCompletedJobs();
                         if (completed.isEmpty()) {
                            System.out.println("No jobs have been completed yet.");
                        } else {
                            System.out.println("--- Completed Jobs ---");
                             // Iterate and print using the List interface
                            for (Job job : completed) {
                                System.out.println(job); // Uses Job's toString()
                            }
                            System.out.println("----------------------");
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting simulator. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;

                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // This catch block handles any unexpected runtime exceptions that occur
            // within the main operational loop.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                 scanner.close();
                 // System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Waiting Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
