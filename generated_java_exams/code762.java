/*
 * Exam Question #762
 * Generated on: 2025-05-12 16:37:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Dispatch Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation for a package dispatch center. The system needs to manage incoming packages awaiting delivery and a fleet of delivery vehicles. The goal is to process packages by assigning them to available vehicles and simulating the dispatch and return of these vehicles.
 * 
 * Your program should allow a user to interact with the system via a command-line menu.
 * 
 * **System Requirements:**
 * 
 * 1.  **Package Management:**
 *     *   Incoming packages arrive and are placed in a queue to await processing.
 *     *   Each package has a unique ID and a destination address.
 * 2.  **Vehicle Management:**
 *     *   The system maintains a list of delivery vehicles.
 *     *   Each vehicle has a unique ID, a maximum package capacity, and a status (available or on route).
 *     *   Vehicles can be added to the system.
 * 3.  **Dispatch Process:**
 *     *   Packages are dispatched by assigning them from the front of the incoming package queue to an available vehicle.
 *     *   A vehicle can only be assigned packages if it is available and has capacity.
 *     *   Packages are assigned one by one until the vehicle is full or the package queue is empty.
 *     *   Once packages are assigned, the vehicle's status changes to "on route".
 *     *   The assigned packages are removed from the incoming package queue.
 * 4.  **Vehicle Return Process:**
 *     *   A vehicle that was "on route" can return to the center.
 *     *   Upon return, the vehicle becomes available again, and its assigned packages are considered delivered (they are cleared from the vehicle's list).
 * 5.  **User Interaction:**
 *     *   The program must provide a command-line menu with options to:
 *         *   Add a new package.
 *         *   Add a new delivery vehicle.
 *         *   Dispatch packages to an available vehicle.
 *         *   Process a vehicle's return.
 *         *   View the current incoming package queue.
 *         *   View the status of all vehicles (available or on route, and assigned packages if any).
 *         *   Exit the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical constraints:
 * 
 * *   Use `java.util.Queue` (specifically, an implementation like `LinkedList` or `ArrayDeque`) to store incoming packages.
 * *   Use `java.util.ArrayList` to store the list of delivery vehicles.
 * *   Use `java.util.List` interface for declaring variables that hold lists of vehicles or packages within vehicles.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.err.println()` to display error messages (e.g., invalid input, vehicle not found, no available vehicles, queue empty when dispatching).
 * *   Use `System.out.println()` to display normal output (menu, successful operations, status views).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during program execution (e.g., invalid input format).
 * *   Apply best practices:
 *     *   Proper encapsulation (private fields, public getters/setters/methods).
 *     *   Meaningful variable and method names.
 *     *   Add comments explaining complex logic or class purpose.
 *     *   Include basic input validation (e.g., ensure vehicle capacity is positive).
 *     *   Structure the code into appropriate classes (`Package`, `DeliveryVehicle`, `DispatchCenter`, and the main simulation class).
 * 
 * **Expected Output:**
 * 
 * *   The program should display a clear menu upon startup and after each operation.
 * *   Successful operations should be confirmed with messages on `System.out`.
 * *   Error conditions should be reported on `System.err`.
 * *   Viewing the queue should list packages waiting.
 * *   Viewing vehicles should list each vehicle, its status, and packages it is currently holding (if on route).
 * 
 * **Constraints:**
 * 
 * *   Focus on the core logic of package queuing, vehicle management, and the dispatch/return simulation using the required components.
 * *   Assume package IDs and vehicle IDs are unique (you don't need to implement complex uniqueness checks, just handle them as distinct entities).
 * *   Assume all packages fit within vehicle capacity (you don't need to split packages).
 * *   The primary `try-catch` for class-wide handling should ideally wrap the main operational loop.
 * 
 * Implement the Java code for this simulation.
 *
 * EXPLANATION:
 * This solution implements a simplified Logistics Dispatch Simulator, demonstrating the required Java concepts in a practical scenario.
 * 
 * **Core Classes:**
 * 
 * 1.  **`Package`:** Represents a package with an ID and destination. It uses private fields (`packageId`, `destinationAddress`), a constructor for initialization with input validation, and public getter methods.
 * 2.  **`DeliveryVehicle`:** Represents a vehicle with an ID, capacity, a list of assigned packages, and availability status.
 *     *   Uses private fields (`vehicleId`, `capacity`, `assignedPackages`, `isAvailable`).
 *     *   `assignedPackages` is declared as `List<Package>` and initialized with `new ArrayList<>()`, fulfilling the requirement to use both `List` and `ArrayList`.
 *     *   Includes methods for assigning packages (`assignPackage`), checking status (`isAvailable`, `isFull`), dispatching (`dispatch`), and processing return (`processReturn`).
 *     *   Input validation is included in the constructor for capacity.
 *     *   `getAssignedPackages()` returns a copy to maintain encapsulation.
 * 3.  **`DispatchCenter`:** Acts as the central manager.
 *     *   Uses a `Queue<Package>` (`incomingPackages`) implemented by `LinkedList` to hold packages waiting for dispatch. `Queue` is used correctly for its FIFO (First-In, First-Out) nature, with `offer()` for adding and `poll()` for removing from the front.
 *     *   Uses a `List<DeliveryVehicle>` (`vehicles`) implemented by `ArrayList` to manage the fleet. `List` is used for its dynamic sizing and ordered collection properties.
 *     *   Methods like `addPackage`, `addVehicle`, `dispatchPackagesToVehicle`, `processVehicleReturn`, `viewPackageQueue`, and `viewVehicles` encapsulate the system's logic.
 *     *   `dispatchPackagesToVehicle` demonstrates taking items from the `Queue` (`poll()`) and adding them to a `List` within the `DeliveryVehicle`. It also includes logic to find an available vehicle and handle cases where the queue is empty or no vehicles are available using `System.err`.
 *     *   `processVehicleReturn` demonstrates finding an item in a `List` by ID and modifying its state.
 * 
 * **Main Simulation Logic (`DeliverySimulator`):**
 * 
 * *   The `main` method sets up the simulation environment (`Scanner`, `DispatchCenter`).
 * *   A `while` loop runs the main program until the user chooses to exit.
 * *   `displayMenu()` shows the user options.
 * *   User input is read using `Scanner`.
 * *   A `switch` statement is used to process the user's `choice`, calling the appropriate methods on the `dispatchCenter` object. This fulfills the `switch` requirement.
 * *   `System.out.println()` is used for displaying the menu, successful actions, and status views (`viewPackageQueue`, `viewVehicles`).
 * *   `System.err.println()` is used for displaying error messages, such as invalid menu choices, input validation failures (caught via `IllegalArgumentException` from constructors), or operational errors (e.g., attempting to dispatch with no packages or vehicles). This fulfills the `System.err` requirement.
 * *   **Class-wide Exception Handling:** A broad `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This catches any uncaught exceptions that might occur within the loop, preventing the program from crashing abruptly and printing an error message to `System.err` along with a stack trace for debugging. Specific input validation errors (`InputMismatchException`) are caught *inside* the loop to allow the program to continue after invalid input, demonstrating more granular handling where appropriate, but the outer `try-catch` ensures the "class-wide" safety net.
 * *   Input validation is handled both in the constructors (`Package`, `DeliveryVehicle`) by throwing `IllegalArgumentException` and within the `main` method's `try-catch` blocks when reading specific input types (`InputMismatchException`).
 * *   Meaningful names are used for classes, methods, and variables (e.g., `incomingPackages`, `availableVehicle`, `dispatchPackagesToVehicle`).
 * *   Basic comments explain the purpose of classes and key methods.
 * *   The code is structured into logical classes, promoting modularity and encapsulation.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, albeit simplified, simulation scenario, demonstrating advanced understanding through proper design, encapsulation, error handling, and component usage.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a package to be delivered
class Package {
    private String packageId;
    private String destinationAddress;

    public Package(String packageId, String destinationAddress) {
        if (packageId == null || packageId.trim().isEmpty() || destinationAddress == null || destinationAddress.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID and destination address cannot be empty.");
        }
        this.packageId = packageId.trim();
        this.destinationAddress = destinationAddress.trim();
    }

    public String getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    @Override
    public String toString() {
        return "Package [ID=" + packageId + ", Dest=" + destinationAddress + "]";
    }
}

// Represents a delivery vehicle
class DeliveryVehicle {
    private String vehicleId;
    private int capacity;
    private List<Package> assignedPackages; // Use List interface
    private boolean isAvailable;

    public DeliveryVehicle(String vehicleId, int capacity) {
        if (vehicleId == null || vehicleId.trim().isEmpty()) {
            throw new IllegalArgumentException("Vehicle ID cannot be empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Vehicle capacity must be positive.");
        }
        this.vehicleId = vehicleId.trim();
        this.capacity = capacity;
        this.assignedPackages = new ArrayList<>(); // Use ArrayList implementation
        this.isAvailable = true; // Vehicles start as available
    }

    public String getVehicleId() {
        return vehicleId;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Package> getAssignedPackages() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(assignedPackages);
    }

    public boolean isAvailable() {
        return isAvailable;
    }

    public boolean isFull() {
        return assignedPackages.size() >= capacity;
    }

    // Assign a package to the vehicle
    public boolean assignPackage(Package pkg) {
        if (!isAvailable || isFull()) {
            return false; // Cannot assign if not available or full
        }
        assignedPackages.add(pkg);
        return true;
    }

    // Mark vehicle as dispatched (on route)
    public void dispatch() {
        if (assignedPackages.isEmpty()) {
             // In this simulation, we only dispatch if packages are assigned.
             // A more complex system might allow empty dispatches.
             // For this problem, let's prevent dispatch if no packages assigned.
             throw new IllegalStateException("Cannot dispatch vehicle with no assigned packages.");
        }
        this.isAvailable = false;
        System.out.println("Vehicle " + vehicleId + " dispatched with " + assignedPackages.size() + " packages.");
    }

    // Process vehicle return - clears packages and makes vehicle available
    public void processReturn() {
        if (isAvailable) {
            System.err.println("Vehicle " + vehicleId + " is already available.");
            return;
        }
        System.out.println("Vehicle " + vehicleId + " returned. Delivered " + assignedPackages.size() + " packages.");
        this.assignedPackages.clear(); // Packages are delivered
        this.isAvailable = true; // Vehicle is now available
    }

    @Override
    public String toString() {
        String status = isAvailable ? "Available" : "On Route";
        String packagesInfo = assignedPackages.isEmpty() ? "None" : assignedPackages.size() + " packages";
        return "Vehicle [ID=" + vehicleId + ", Capacity=" + capacity + ", Status=" + status + ", Packages=" + packagesInfo + "]";
    }
}

// Manages the incoming packages and the fleet of vehicles
class DispatchCenter {
    private Queue<Package> incomingPackages; // Use Queue interface
    private List<DeliveryVehicle> vehicles; // Use List interface

    public DispatchCenter() {
        this.incomingPackages = new LinkedList<>(); // Use LinkedList implementation for Queue
        this.vehicles = new ArrayList<>(); // Use ArrayList implementation for List
    }

    // Add a new package to the incoming queue
    public void addPackage(Package pkg) {
        incomingPackages.offer(pkg); // offer is preferred over add for queues
        System.out.println("Package " + pkg.getPackageId() + " added to the queue.");
    }

    // Add a new vehicle to the fleet
    public void addVehicle(DeliveryVehicle vehicle) {
        // Basic check if ID already exists (optional but good practice)
        boolean idExists = vehicles.stream().anyMatch(v -> v.getVehicleId().equals(vehicle.getVehicleId()));
        if (idExists) {
            System.err.println("Error: Vehicle with ID " + vehicle.getVehicleId() + " already exists.");
            return;
        }
        vehicles.add(vehicle);
        System.out.println("Vehicle " + vehicle.getVehicleId() + " added to the fleet.");
    }

    // Find the first available vehicle
    private DeliveryVehicle findAvailableVehicle() {
        for (DeliveryVehicle vehicle : vehicles) {
            if (vehicle.isAvailable()) {
                return vehicle;
            }
        }
        return null; // No available vehicle found
    }

    // Dispatch packages from the queue to an available vehicle
    public void dispatchPackagesToVehicle() {
        if (incomingPackages.isEmpty()) {
            System.err.println("Error: No packages in the incoming queue to dispatch.");
            return;
        }

        DeliveryVehicle availableVehicle = findAvailableVehicle();
        if (availableVehicle == null) {
            System.err.println("Error: No delivery vehicles are currently available.");
            return;
        }

        System.out.println("Dispatching packages to vehicle " + availableVehicle.getVehicleId() + "...");
        int packagesAssignedCount = 0;
        // Poll packages from the queue and assign to the vehicle until full or queue is empty
        while (!incomingPackages.isEmpty() && !availableVehicle.isFull()) {
            Package pkg = incomingPackages.poll(); // Remove from queue
            if (availableVehicle.assignPackage(pkg)) {
                packagesAssignedCount++;
            } else {
                // This case should ideally not happen if vehicle was found as available and not full,
                // but good practice to handle potential issues with assignPackage logic.
                System.err.println("Failed to assign package " + pkg.getPackageId() + " to vehicle " + availableVehicle.getVehicleId());
                // Optionally, put the package back if assignment failed for unexpected reason
                 incomingPackages.offer(pkg); // Put it back at the end of the queue
                 break; // Stop trying to assign to this vehicle
            }
        }

        if (packagesAssignedCount > 0) {
            availableVehicle.dispatch(); // Mark vehicle as on route
            System.out.println(packagesAssignedCount + " package(s) dispatched with vehicle " + availableVehicle.getVehicleId() + ".");
        } else {
             // This might happen if vehicle was found but became full just before loop (unlikely with current logic)
             // or assignPackage failed.
             System.out.println("No packages were assigned to vehicle " + availableVehicle.getVehicleId() + ".");
        }
    }

    // Process the return of a vehicle by its ID
    public void processVehicleReturn(String vehicleId) {
        DeliveryVehicle vehicleToReturn = null;
        // Find the vehicle, must be currently on route
        for (DeliveryVehicle vehicle : vehicles) {
            if (vehicle.getVehicleId().equals(vehicleId) && !vehicle.isAvailable()) {
                vehicleToReturn = vehicle;
                break;
            }
        }

        if (vehicleToReturn != null) {
            vehicleToReturn.processReturn();
        } else {
            System.err.println("Error: Vehicle with ID " + vehicleId + " not found or is not currently on route.");
        }
    }

    // View all packages currently in the incoming queue
    public void viewPackageQueue() {
        System.out.println("\n--- Incoming Package Queue ---");
        if (incomingPackages.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            int index = 1;
            // Iterate through the queue without removing elements
            for (Package pkg : incomingPackages) {
                System.out.println(index++ + ". " + pkg);
            }
        }
        System.out.println("------------------------------");
    }

    // View the status of all vehicles
    public void viewVehicles() {
        System.out.println("\n--- Delivery Vehicle Status ---");
        if (vehicles.isEmpty()) {
            System.out.println("No vehicles registered.");
        } else {
            for (DeliveryVehicle vehicle : vehicles) {
                System.out.println(vehicle);
                // Optionally, list packages if on route
                if (!vehicle.isAvailable()) {
                    List<Package> assigned = vehicle.getAssignedPackages();
                    if (!assigned.isEmpty()) {
                        System.out.println("  Assigned Packages:");
                        for (Package pkg : assigned) {
                            System.out.println("    - " + pkg.getPackageId() + " (to " + pkg.getDestinationAddress() + ")");
                        }
                    }
                }
            }
        }
        System.out.println("-------------------------------");
    }
}

// Main class to run the simulation with user interaction
public class DeliverySimulator {

    private static void displayMenu() {
        System.out.println("\n--- Logistics Dispatch Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Add New Vehicle");
        System.out.println("3. Dispatch Packages to Vehicle");
        System.out.println("4. Process Vehicle Return");
        System.out.println("5. View Package Queue");
        System.out.println("6. View Vehicles");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DispatchCenter dispatchCenter = new DispatchCenter();
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to next loop iteration
                }

                switch (choice) {
                    case 1: // Add New Package
                        System.out.print("Enter Package ID: ");
                        String packageId = scanner.nextLine();
                        System.out.print("Enter Destination Address: ");
                        String destinationAddress = scanner.nextLine();
                        try {
                            Package newPackage = new Package(packageId, destinationAddress);
                            dispatchCenter.addPackage(newPackage);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding package: " + e.getMessage());
                        }
                        break;

                    case 2: // Add New Vehicle
                        System.out.print("Enter Vehicle ID: ");
                        String vehicleId = scanner.nextLine();
                        System.out.print("Enter Vehicle Capacity: ");
                        int capacity = -1;
                        try {
                            capacity = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            DeliveryVehicle newVehicle = new DeliveryVehicle(vehicleId, capacity);
                            dispatchCenter.addVehicle(newVehicle);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for capacity. Please enter a number.");
                            scanner.nextLine(); // Consume the invalid input
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding vehicle: " + e.getMessage());
                        }
                        break;

                    case 3: // Dispatch Packages
                        dispatchCenter.dispatchPackagesToVehicle();
                        break;

                    case 4: // Process Vehicle Return
                        System.out.print("Enter Vehicle ID to process return: ");
                        String returnVehicleId = scanner.nextLine();
                        dispatchCenter.processVehicleReturn(returnVehicleId);
                        break;

                    case 5: // View Package Queue
                        dispatchCenter.viewPackageQueue();
                        break;

                    case 6: // View Vehicles
                        dispatchCenter.viewVehicles();
                        break;

                    case 7: // Exit
                        System.out.println("Exiting Logistics Dispatch Simulator. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
