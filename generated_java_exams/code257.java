/*
 * Exam Question #257
 * Generated on: 2025-05-11 22:45:46
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Priority Task Processor
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to manage tasks based on their priority. The system should allow users to add new tasks with a description and priority level, process the next highest priority task, and view the lists of pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with:
 *     *   A unique `taskId` (you can generate this simply, e.g., using a counter).
 *     *   A `description` (String).
 *     *   A `priority` (integer, lower number means higher priority, e.g., 1 = highest, 5 = lowest).
 *     *   Implement the `Comparable` interface based on priority to allow sorting in a priority queue.
 *     *   Provide appropriate constructors, getters, and a `toString()` method for displaying task details. Ensure fields are private and accessed via public methods.
 * 
 * 2.  **Task Manager:** Create a `TaskManager` class that manages the tasks.
 *     *   It must maintain a collection of **pending tasks** using a `java.util.Queue`. A `PriorityQueue` is suitable here to automatically handle priority ordering.
 *     *   It must maintain a collection of **completed tasks** using a `java.util.List` implementation, specifically `java.util.ArrayList`.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, int priority)`: Adds a new task to the pending queue. Validate input: description cannot be empty, priority must be a positive integer (e.g., 1-5, though just > 0 is acceptable validation).
 *         *   `processNextTask()`: Removes and returns the highest priority task from the pending queue and adds it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `listPendingTasks()`: Displays all tasks currently in the pending queue.
 *         *   `listCompletedTasks()`: Displays all tasks currently in the completed tasks list.
 * 
 * 3.  **User Interface:** Implement a simple command-line interface in the `main` method (can be within `TaskManager` or a separate class).
 *     *   Use `java.util.Scanner` to read user commands.
 *     *   Support the following commands using a `switch` statement:
 *         *   `add`: Prompt for task description and priority, then call `addTask`.
 *         *   `process`: Call `processNextTask` and display the processed task or a message if no tasks were pending.
 *         *   `list pending`: Call `listPendingTasks`.
 *         *   `list completed`: Call `listCompletedTasks`.
 *         *   `exit`: Terminate the application.
 *         *   Handle invalid commands.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for normal application output (prompts, success messages, task lists).
 *     *   Use `System.err` for error messages (e.g., invalid input, queue is empty when processing).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential `NumberFormatException` when parsing integer input from the user. Wrap the main command processing loop in a `try-catch` block to catch unexpected errors gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic.
 *     *   Follow Java coding conventions.
 *     *   Ensure proper encapsulation.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Welcome to the Priority Task Processor!
 * Enter command (add, process, list pending, list completed, exit): add
 * Enter task description: Fix bug in login
 * Enter priority (1=highest, 5=lowest): 1
 * Task added: Task ID: 1, Description: Fix bug in login, Priority: 1
 * 
 * Enter command (add, process, list pending, list completed, exit): add
 * Enter task description: Write documentation
 * Enter priority (1=highest, 5=lowest): 3
 * Task added: Task ID: 2, Description: Write documentation, Priority: 3
 * 
 * Enter command (add, process, list pending, list completed, exit): list pending
 * --- Pending Tasks ---
 * Task ID: 1, Description: Fix bug in login, Priority: 1
 * Task ID: 2, Description: Write documentation, Priority: 3
 * ---------------------
 * 
 * Enter command (add, process, list pending, list completed, exit): process
 * Processing task: Task ID: 1, Description: Fix bug in login, Priority: 1
 * 
 * Enter command (add, process, list pending, list completed, exit): list pending
 * --- Pending Tasks ---
 * Task ID: 2, Description: Write documentation, Priority: 3
 * ---------------------
 * 
 * Enter command (add, process, list completed, exit): list completed
 * --- Completed Tasks ---
 * Task ID: 1, Description: Fix bug in login, Priority: 1
 * -----------------------
 * 
 * Enter command (add, process, list completed, exit): process
 * Processing task: Task ID: 2, Description: Write documentation, Priority: 3
 * 
 * Enter command (add, process, list completed, exit): process
 * System.err: No pending tasks to process.
 * 
 * Enter command (add, process, list completed, exit): exit
 * Exiting Task Processor.
 * ```
 * 
 * **Constraint Checklist:**
 * 
 * 1.  Queue: Yes
 * 2.  ArrayList: Yes
 * 3.  List interface: Yes
 * 4.  Scanner: Yes
 * 5.  Switch statement: Yes
 * 6.  System.err: Yes
 * 7.  System.out: Yes
 * 8.  Class-wide exception handling (try-catch): Yes
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a `Priority Task Processor` system that demonstrates the required Java concepts in a practical scenario.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents individual tasks with a unique ID, description, and priority.
 *     *   Uses `private final` fields for encapsulation, accessible via public getters.
 *     *   The `taskId` is generated using `AtomicInteger` to ensure unique, thread-safe IDs (though thread-safety isn't strictly necessary for this single-threaded example, it's a good practice).
 *     *   Implements `Comparable<Task>` and overrides `compareTo`. This is crucial for the `PriorityQueue` to know how to order `Task` objects. The comparison logic prioritizes lower `priority` values. A secondary comparison on `taskId` is added as a tie-breaker for tasks with the same priority.
 *     *   Includes basic validation in the constructor for description and priority, throwing `IllegalArgumentException` if validation fails.
 *     *   Provides a clear `toString()` representation.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This class acts as the controller for the task system.
 *     *   It uses a `java.util.Queue<Task>`, specifically a `PriorityQueue`, to store tasks that are waiting to be processed. The `PriorityQueue` automatically orders tasks based on the `compareTo` method implemented in the `Task` class, ensuring the highest priority task is always at the front.
 *     *   It uses a `java.util.List<Task>`, implemented as a `java.util.ArrayList`, to store tasks that have been completed. `ArrayList` is suitable here as the order of completed tasks doesn't need to be based on priority; simple insertion order is sufficient.
 *     *   `addTask(String description, int priority)`: Creates a new `Task` object and adds it to the `pendingTasksQueue` using `offer()`. It includes a `try-catch` block to handle `IllegalArgumentException` thrown by the `Task` constructor during validation, printing the error to `System.err`.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the head (highest priority task) from the `pendingTasksQueue`. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling of the "no tasks" scenario, where an error message is printed to `System.err`. If a task is retrieved, it's added to the `completedTasksList`.
 *     *   `listPendingTasks()`: Iterates through the `pendingTasksQueue` and prints each task to `System.out`. It includes a check for an empty queue. *Note:* The iterator of `PriorityQueue` does not guarantee traversing elements in priority order; it just traverses the underlying heap structure. For a guaranteed sorted list display, one would copy the elements to an `ArrayList` and sort it before printing. However, for this exercise, simply iterating and printing is acceptable and demonstrates queue traversal.
 *     *   `listCompletedTasks()`: Iterates through the `completedTasksList` (an `ArrayList`) and prints each completed task to `System.out`. The `ArrayList` iterator maintains insertion order.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   The `run()` method contains the main application loop.
 *     *   `java.util.Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user enters "exit".
 *     *   A `switch` statement is used to handle different user commands ("add", "process", "list pending", "list completed", "exit"). This provides clear and structured flow control based on user input.
 *     *   Invalid commands fall into the `default` case of the `switch`, printing an error to `System.err`.
 * 
 * 4.  **Error Handling & Output:**
 *     *   `System.out` is used for all successful operations, prompts, and list displays.
 *     *   `System.err` is used specifically for error messages, such as invalid input (handled by catching `IllegalArgumentException` in `addTask` and `NumberFormatException` in the `run` loop) or attempting to process an empty queue.
 *     *   A large `try-catch (Exception e)` block wraps the main `while` loop in the `run()` method. This demonstrates class-wide exception handling, catching any unexpected runtime exceptions that might occur during the command processing loop and printing an error message and stack trace to `System.err` before the application potentially terminates or continues if the exception is non-fatal to the loop structure.
 *     *   A smaller `try-catch (NumberFormatException)` block is specifically used when parsing the priority input for the "add" command, demonstrating targeted input validation and error handling for a specific expected error type.
 *     *   The `finally` block ensures the `Scanner` resource is closed when the `run` method exits, whether normally or due to an uncaught exception.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names like `pendingTasksQueue`, `completedTasksList`, `addTask`, `processNextTask` are used.
 *     *   Comments explain the purpose of classes, methods, and specific logic points (like `compareTo` or the `PriorityQueue` iteration note).
 *     *   Encapsulation is maintained by keeping fields private.
 *     *   Input validation is performed in the `Task` constructor and when parsing priority input.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, and `try-catch` for exception handling within a practical task management context, fulfilling all requirements of the problem.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

// Represents a task with a description and priority.
class Task implements Comparable<Task> {
    private static final AtomicInteger taskCounter = new AtomicInteger(0);
    private final int taskId;
    private final String description;
    private final int priority; // Lower number = higher priority

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority level (lower is higher priority).
     */
    public Task(String description, int priority) {
        // Basic validation during construction
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority <= 0) {
             throw new IllegalArgumentException("Task priority must be a positive integer.");
        }
        this.taskId = taskCounter.incrementAndGet();
        this.description = description.trim();
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Compares tasks based on priority. Lower priority number comes first.
     * If priorities are equal, compare by taskId to maintain a stable order
     * for tasks added with the same priority (though not strictly required by PQ).
     */
    @Override
    public int compareTo(Task other) {
        int priorityComparison = Integer.compare(this.priority, other.priority);
        if (priorityComparison != 0) {
            return priorityComparison;
        }
        // If priorities are the same, use taskId as a tie-breaker
        return Integer.compare(this.taskId, other.taskId);
    }

    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Priority: %d",
                             taskId, description, priority);
    }
}

// Manages collections of pending and completed tasks.
public class TaskManager {

    // Use PriorityQueue for pending tasks to process by priority
    private final Queue<Task> pendingTasksQueue;
    // Use ArrayList for completed tasks to maintain insertion order (or just a list)
    private final List<Task> completedTasksList;
    private final Scanner scanner; // Scanner for user input

    /**
     * Constructs a TaskManager.
     */
    public TaskManager() {
        this.pendingTasksQueue = new PriorityQueue<>(); // Uses Task's compareTo
        this.completedTasksList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * Handles input validation.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        try {
            Task newTask = new Task(description, priority);
            pendingTasksQueue.offer(newTask); // offer is preferred over add for queues (returns false on failure)
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes (removes) the next highest priority task from the pending queue
     * and moves it to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasksQueue.poll(); // poll returns null if queue is empty
        if (taskToProcess != null) {
            completedTasksList.add(taskToProcess);
            System.out.println("Processing task: " + taskToProcess);
        } else {
            System.err.println("No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Note: Iterating over a PriorityQueue does NOT guarantee iteration order
     * based on priority, only that poll() retrieves elements in priority order.
     * We'll just show them as they are iterated for simplicity in listing.
     * For a truly sorted list view without removing, one would copy to a List and sort it.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Simple iteration. Order is not guaranteed by iterator.
            // To guarantee order, you'd need to copy to a List and sort.
            // For this exercise, simple iteration is sufficient.
            for (Task task : pendingTasksQueue) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasksList.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // ArrayList iterator maintains insertion order
            for (Task task : completedTasksList) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main command-line interface loop.
     */
    public void run() {
        System.out.println("Welcome to the Priority Task Processor!");
        boolean running = true;

        // Class-wide try-catch for the main application loop
        try {
            while (running) {
                System.out.print("Enter command (add, process, list pending, list completed, exit): ");
                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (1=highest, 5=lowest): ");
                        try {
                            int priority = Integer.parseInt(scanner.nextLine());
                            addTask(description, priority);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid priority format. Please enter a number.");
                        }
                        break;

                    case "process":
                        processNextTask();
                        break;

                    case "list pending":
                        listPendingTasks();
                        break;

                    case "list completed":
                        listCompletedTasks();
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Processor.");
                        break;

                    default:
                        System.err.println("Unknown command. Please try again.");
                        break;
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed."); // Indicate cleanup
        }
    }

    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
