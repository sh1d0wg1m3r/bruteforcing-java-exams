/*
 * Exam Question #1131
 * Generated on: 2025-05-12 17:28:57
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced E-Commerce Order Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified back-end system for managing inventory and processing customer orders for a small e-commerce platform. The system should allow adding items to inventory, placing new orders, processing orders from a queue, and viewing current inventory and the order queue.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Inventory Management:**
 *     *   Maintain a list of `InventoryItem` objects. Each item should have a unique name (String), price (double), and current stock quantity (int).
 *     *   Allow adding new items or updating the stock/price of existing items.
 *     *   Display the current inventory.
 * 
 * 2.  **Order Management:**
 *     *   Maintain a queue of `Order` objects representing pending orders. Orders are processed in the order they are placed (FIFO).
 *     *   Allow placing new orders. An order consists of one or more items with specified quantities.
 *     *   When an order is placed, the system must check inventory availability. If all items in the requested quantities are available, decrement the stock and add the order to the queue. If not, the order fails, and stock is not changed.
 *     *   Allow processing the next order from the queue. Processing an order removes it from the queue and marks it as completed (conceptually, no need for a complex status change in this simplified version, just removal).
 *     *   Display the current order queue.
 * 
 * 3.  **User Interface:**
 *     *   Provide a simple text-based menu for the user to interact with the system (Add Item, Place Order, Process Order, View Inventory, View Queue, Exit).
 *     *   Use `java.util.Scanner` to read user input.
 * 
 * 4.  **Required Java Components:**
 *     *   `java.util.Queue`: Must be used for managing the order queue.
 *     *   `java.util.ArrayList`: Must be used for storing the inventory items.
 *     *   `java.util.List`: The inventory collection must be declared using the `List` interface type.
 *     *   `java.util.Scanner`: Must be used for all user input.
 *     *   `switch` statement: Must be used to handle the different menu options.
 *     *   `System.err`: Must be used exclusively for displaying error messages (e.g., invalid input, insufficient stock, empty queue).
 *     *   `System.out`: Must be used for displaying the menu, prompts, successful operation messages, and list contents.
 *     *   Class-wide exception handling: Implement a `try-catch` block that wraps the main user interaction loop to catch unexpected exceptions and prevent the program from crashing abruptly. Print an informative error message using `System.err` if an exception occurs.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) for your classes (`InventoryItem`, `Order`, and the main system class).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., non-negative quantities, valid menu choices).
 *     *   Handle specific error conditions gracefully (e.g., item not found, insufficient stock, processing an empty queue) using `System.err`.
 *     *   Structure your code into appropriate classes.
 * 
 * **Classes to Create:**
 * 
 * *   `InventoryItem`: Represents an item in the inventory.
 * *   `Order`: Represents a customer order.
 * *   `ECommerceSystem`: The main class containing the inventory, order queue, and the logic for handling user interactions and operations.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and perform the requested actions. Successful operations and list displays should use `System.out`. Error conditions (like invalid input, insufficient stock, or trying to process an empty queue) should be reported using `System.err`. The program should continue running until the user selects the Exit option.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- E-Commerce System Menu ---
 * 1. Add/Update Inventory Item
 * 2. Place New Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Order Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter item name: Laptop
 * Enter price: 1200.50
 * Enter quantity: 10
 * Item 'Laptop' added/updated.
 * 
 * --- E-Commerce System Menu ---
 * ...
 * Enter your choice: 2
 * Enter order ID: 101
 * Enter items for order (name quantity, type 'done' when finished):
 * Laptop 1
 * Mouse 5
 * done
 * Checking inventory...
 * Insufficient stock for Mouse. Order failed.
 * System.err: Order failed due to insufficient stock for item: Mouse
 * 
 * --- E-Commerce System Menu ---
 * ...
 * Enter your choice: 2
 * Enter order ID: 102
 * Enter items for order (name quantity, type 'done' when finished):
 * Laptop 1
 * Keyboard 2
 * done
 * Checking inventory...
 * Order 102 placed successfully. Stock updated.
 * 
 * --- E-Commerce System Menu ---
 * ...
 * Enter your choice: 3
 * Processing order 102...
 * Order 102 processed.
 * 
 * --- E-Commerce System Menu ---
 * ...
 * Enter your choice: 3
 * Order queue is empty.
 * System.err: Order queue is currently empty.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of inventory and order logic.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Clean code structure.
 * *   Program robustness (handles invalid input and error conditions gracefully).
 * 
 * **Note:** For simplicity, you can assume item names are unique and case-sensitive. Order IDs can be simple integers.
 *
 * EXPLANATION:
 * This solution implements a simplified e-commerce back-end system demonstrating the required Java concepts.
 * 
 * 1.  **Structure:** The code is organized into three classes: `InventoryItem`, `Order`, and `ECommerceSystem`.
 *     *   `InventoryItem` and `Order` are simple data classes with private fields, public getters, and appropriate constructors. `InventoryItem` includes a method `updateStock` to manage quantity changes, ensuring stock doesn't go below zero.
 *     *   `ECommerceSystem` is the main class holding the system's state (inventory and order queue) and logic.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `orderQueue` field is declared as `Queue<Order>` and initialized with a `LinkedList` instance, fulfilling the requirement to use `Queue` for FIFO order processing. `offer()` is used to add orders, and `poll()` is used to retrieve and remove the next order.
 *     *   `java.util.ArrayList`: The `inventory` field is initialized with an `ArrayList` instance, fulfilling the requirement to use `ArrayList` for inventory storage.
 *     *   `java.util.List`: The `inventory` field is declared using the `List` interface type (`List<InventoryItem> inventory`), fulfilling this requirement and promoting good practice (programming to the interface).
 *     *   `java.util.Scanner`: A `Scanner` instance is created at the class level in `ECommerceSystem` and used throughout the `run()`, `addItemToInventory()`, `placeOrder()`, and `displayMenuAndGetChoice()` methods to read user input from `System.in`.
 *     *   `switch` statement: The `run()` method uses a `switch` statement based on the user's menu choice to dispatch control to the appropriate method (`addItemToInventory`, `placeOrder`, etc.).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input, item not found, insufficient stock during order placement, or attempting to process an empty queue. It's also used in the main `try-catch` block for unexpected errors.
 *     *   `System.out`: Used for printing the menu, prompts, successful operation confirmations, and the contents of the inventory and order queue lists.
 *     *   Class-wide exception handling (`try-catch`): The `run()` method contains a `try-catch(Exception e)` block that wraps the entire logic inside the `do-while` loop (specifically, the part that gets the choice and executes the action). This catches any unhandled exceptions that might occur during the execution of a menu option, prints an error message to `System.err`, and allows the program to continue running the loop (presenting the menu again) instead of crashing. Specific methods like `addItemToInventory` and `placeOrder` also have local `try-catch` blocks for handling expected input format errors (`InputMismatchException`, `NumberFormatException`).
 * 
 * 3.  **Functionality Implementation:**
 *     *   **Inventory:** `addItemToInventory()` handles both adding new items and updating existing ones based on the item name. `viewInventory()` iterates through the `ArrayList` and prints details. `findItemByName` is a helper method for searching.
 *     *   **Orders:** `placeOrder()` collects items and quantities from the user, validates inventory availability *before* modifying stock, updates stock if validation passes, and adds the `Order` object to the `orderQueue` using `offer()`. `processNextOrder()` checks if the queue is empty and, if not, removes and returns the head element using `poll()`. `viewOrderQueue()` iterates through the `Queue` (using an enhanced for loop, which doesn't remove elements) and prints order details.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `InventoryItem`, `Order`, and `ECommerceSystem` are `private`. Access is provided through public methods (getters, update methods).
 *     *   **Meaningful Names:** Class, variable, and method names clearly describe their purpose (e.g., `inventory`, `orderQueue`, `addItemToInventory`, `placeOrder`).
 *     *   **Comments/Documentation:** Javadoc comments are included for classes and methods explaining their purpose, parameters, and return values. Inline comments clarify specific logic.
 *     *   **Input Validation:** Methods like `addItemToInventory` and `placeOrder` validate user input (non-negative numbers, non-empty strings, correct format for order items). `InputMismatchException` is handled when reading numbers.
 *     *   **Error Handling:** Specific error conditions (item not found, insufficient stock, empty queue) are checked and reported using `System.err`. The main `try-catch` provides a fallback for unexpected errors.
 *     *   **Clean Code:** Methods are relatively small and focused on a single task. The `run()` method orchestrates the main loop and user interaction.
 * 
 * This solution effectively combines multiple required Java features into a cohesive, practical application, demonstrating key skills in data structures, object-oriented design, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an item in the e-commerce inventory.
 */
class InventoryItem {
    private String name;
    private double price;
    private int stock;

    /**
     * Constructs a new InventoryItem.
     * @param name The name of the item.
     * @param price The price of the item.
     * @param stock The initial stock quantity.
     */
    public InventoryItem(String name, double price, int stock) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Item name cannot be empty.");
        }
        if (price < 0) {
            throw new IllegalArgumentException("Price cannot be negative.");
        }
        if (stock < 0) {
            throw new IllegalArgumentException("Stock cannot be negative.");
        }
        this.name = name;
        this.price = price;
        this.stock = stock;
    }

    // Getters
    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getStock() {
        return stock;
    }

    /**
     * Updates the stock quantity.
     * @param quantityChange The amount to change the stock by (positive for add, negative for remove).
     * @return true if stock update was successful, false otherwise (e.g., insufficient stock for removal).
     */
    public boolean updateStock(int quantityChange) {
        if (this.stock + quantityChange < 0) {
            return false; // Not enough stock to remove
        }
        this.stock += quantityChange;
        return true;
    }

    @Override
    public String toString() {
        return String.format("%s (Price: %.2f, Stock: %d)", name, price, stock);
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private int orderId;
    // Map item name to quantity ordered
    private Map<String, Integer> itemsOrdered;

    /**
     * Constructs a new Order.
     * @param orderId The unique identifier for the order.
     * @param itemsOrdered A map of item names to quantities.
     */
    public Order(int orderId, Map<String, Integer> itemsOrdered) {
        if (itemsOrdered == null || itemsOrdered.isEmpty()) {
             throw new IllegalArgumentException("Order must contain items.");
        }
        this.orderId = orderId;
        this.itemsOrdered = new HashMap<>(itemsOrdered); // Create a defensive copy
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public Map<String, Integer> getItemsOrdered() {
        return new HashMap<>(itemsOrdered); // Return a defensive copy
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        sb.append("  Items:");
        if (itemsOrdered.isEmpty()) {
            sb.append(" None");
        } else {
            for (Map.Entry<String, Integer> entry : itemsOrdered.entrySet()) {
                sb.append(String.format("\n    - %s: %d", entry.getKey(), entry.getValue()));
            }
        }
        return sb.toString();
    }
}

/**
 * The main system class managing inventory and orders.
 */
public class ECommerceSystem {

    // Inventory stored as a List, using ArrayList implementation
    private List<InventoryItem> inventory;

    // Order queue stored using a Queue implementation (LinkedList is a common choice)
    private Queue<Order> orderQueue;

    // Scanner for reading user input
    private Scanner scanner;

    // Counter for generating unique order IDs
    private int nextOrderId;

    /**
     * Constructs a new ECommerceSystem.
     */
    public ECommerceSystem() {
        this.inventory = new ArrayList<>(); // Use ArrayList for inventory
        this.orderQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        this.scanner = new Scanner(System.in);
        this.nextOrderId = 101; // Starting order ID
    }

    /**
     * Finds an item in the inventory by name.
     * @param name The name of the item to find.
     * @return The InventoryItem if found, null otherwise.
     */
    private InventoryItem findItemByName(String name) {
        for (InventoryItem item : inventory) {
            if (item.getName().equalsIgnoreCase(name.trim())) {
                return item;
            }
        }
        return null;
    }

    /**
     * Adds a new item or updates an existing one in the inventory.
     */
    public void addItemToInventory() {
        System.out.print("Enter item name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Item name cannot be empty.");
            return;
        }

        double price = -1;
        int quantity = -1;

        try {
            System.out.print("Enter price: ");
            price = scanner.nextDouble();
            System.out.print("Enter quantity: ");
            quantity = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Price and quantity must be numbers.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             // Consume the rest of the line after reading numbers
             if (scanner.hasNextLine()) {
                 scanner.nextLine();
             }
        }

        if (price < 0 || quantity < 0) {
             System.err.println("Price and quantity cannot be negative.");
             return;
        }

        InventoryItem existingItem = findItemByName(name);

        if (existingItem != null) {
            // Update existing item
            existingItem.updateStock(quantity - existingItem.getStock()); // Set new stock
            // Note: Updating price is not strictly required by prompt, but could be added
            System.out.println("Item '" + name + "' updated. New stock: " + existingItem.getStock());
        } else {
            // Add new item
            try {
                 InventoryItem newItem = new InventoryItem(name, price, quantity);
                 inventory.add(newItem);
                 System.out.println("Item '" + name + "' added to inventory.");
            } catch (IllegalArgumentException e) {
                 System.err.println("Error creating item: " + e.getMessage());
            }
        }
    }

    /**
     * Places a new order by checking inventory and adding to the queue.
     */
    public void placeOrder() {
        System.out.println("--- Placing New Order ---");
        Map<String, Integer> itemsToOrder = new HashMap<>();
        String itemName;
        int quantity;

        System.out.println("Enter items for order (name quantity, type 'done' when finished):");

        // Loop to get items for the order
        while (true) {
            System.out.print("> ");
            String line = scanner.nextLine().trim();
            if (line.equalsIgnoreCase("done")) {
                break;
            }

            String[] parts = line.split(" ");
            if (parts.length != 2) {
                System.err.println("Invalid input format. Please enter 'name quantity'.");
                continue;
            }

            itemName = parts[0].trim();
            try {
                quantity = Integer.parseInt(parts[1].trim());
                if (quantity <= 0) {
                    System.err.println("Quantity must be positive.");
                    continue;
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid quantity. Please enter a number.");
                continue;
            }

            // Add item and quantity to the temporary map
            itemsToOrder.put(itemName, itemsToOrder.getOrDefault(itemName, 0) + quantity);
        }

        if (itemsToOrder.isEmpty()) {
            System.err.println("No items specified for the order. Order cancelled.");
            return;
        }

        System.out.println("Checking inventory...");

        // First pass: Check if all items exist and if stock is sufficient without changing stock yet
        Map<String, Integer> stockChanges = new HashMap<>();
        boolean inventoryAvailable = true;
        String failedItemName = "";

        for (Map.Entry<String, Integer> entry : itemsToOrder.entrySet()) {
            String name = entry.getKey();
            int requestedQuantity = entry.getValue();

            InventoryItem item = findItemByName(name);
            if (item == null) {
                System.err.println("Item '" + name + "' not found in inventory.");
                inventoryAvailable = false;
                failedItemName = name;
                break; // Stop checking if one item is missing
            }

            if (item.getStock() < requestedQuantity) {
                System.err.println("Insufficient stock for '" + name + "'. Requested: " + requestedQuantity + ", Available: " + item.getStock());
                inventoryAvailable = false;
                failedItemName = name;
                break; // Stop checking if stock is insufficient
            }

            // If checks pass, note the stock change that would happen
            stockChanges.put(name, requestedQuantity);
        }

        // Second pass: If inventory is available, update stock and add order to queue
        if (inventoryAvailable) {
            // Decrement stock for each item in the order
            for (Map.Entry<String, Integer> entry : stockChanges.entrySet()) {
                String name = entry.getKey();
                int quantityToDecrement = entry.getValue();
                InventoryItem item = findItemByName(name);
                // This should not be null here because we checked in the first pass
                if (item != null) {
                    item.updateStock(-quantityToDecrement); // Decrement stock
                }
            }

            // Create and add the order to the queue
            Order newOrder = new Order(nextOrderId++, itemsToOrder);
            orderQueue.offer(newOrder); // offer() is standard for adding to Queue
            System.out.println("Order " + newOrder.getOrderId() + " placed successfully. Stock updated.");

        } else {
            System.err.println("Order failed due to insufficient stock or item not found: " + failedItemName);
        }
    }

    /**
     * Processes the next order in the queue.
     */
    public void processNextOrder() {
        System.out.println("--- Processing Next Order ---");
        if (orderQueue.isEmpty()) {
            System.err.println("Order queue is currently empty.");
            return;
        }

        Order orderToProcess = orderQueue.poll(); // poll() retrieves and removes the head of the queue
        if (orderToProcess != null) {
            System.out.println("Processing order " + orderToProcess.getOrderId() + "...");
            // In a real system, processing would involve shipping, payment, etc.
            // For this simulation, just removing from queue signifies processing.
            System.out.println("Order " + orderToProcess.getOrderId() + " processed.");
        } else {
             // This case should ideally not happen right after checking isEmpty(),
             // but good practice with poll() which can return null.
             System.err.println("Failed to retrieve order from queue.");
        }
    }

    /**
     * Displays the current inventory.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (int i = 0; i < inventory.size(); i++) {
                System.out.println((i + 1) + ". " + inventory.get(i));
            }
        }
    }

    /**
     * Displays the current order queue.
     */
    public void viewOrderQueue() {
        System.out.println("--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Order queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Order order : orderQueue) {
                System.out.println(i++ + ". " + order);
            }
        }
    }

    /**
     * Displays the main menu and gets user choice.
     * @return The user's menu choice.
     */
    private int displayMenuAndGetChoice() {
        System.out.println("\n--- E-Commerce System Menu ---");
        System.out.println("1. Add/Update Inventory Item");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Order Queue");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");

        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Consume the invalid input line
            scanner.nextLine();
            choice = -1; // Indicate invalid choice
        } finally {
             // Consume the rest of the line after reading the number, if nextInt succeeded
             if (choice != -1 && scanner.hasNextLine()) {
                 scanner.nextLine();
             }
        }
        return choice;
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice;
        do {
            // Class-wide exception handling wrapping the main loop iteration
            try {
                choice = displayMenuAndGetChoice();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addItemToInventory();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewInventory();
                        break;
                    case 5:
                        viewOrderQueue();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during an operation
                System.err.println("\nAn unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(); // For debugging purposes
                choice = -1; // Ensure loop continues unless it was the exit choice
            }

        } while (choice != 6);

        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ECommerceSystem system = new ECommerceSystem();
        system.run();
    }
}
