/*
 * Exam Question #626
 * Generated on: 2025-05-12 16:16:34
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Support Ticket Management System**
 * 
 * You are tasked with developing a simplified, console-based support ticket management system for a small IT department. The system should allow users (simulating support agents) to submit new tickets, process the oldest pending ticket, and view the status of tickets.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following private fields:
 *     *   `ticketId` (int): A unique identifier for the ticket, auto-generated by the system.
 *     *   `description` (String): The problem description provided by the user.
 *     *   `status` (String): The current status of the ticket (e.g., "PENDING", "RESOLVED"). Use constants for status strings.
 * 
 * 2.  **System Management:** Create a `SupportSystem` class to manage the tickets. This class should contain:
 *     *   A `Queue<Ticket>` to hold tickets that are currently waiting to be processed (pending). Use a suitable `Queue` implementation.
 *     *   A `List<Ticket>` to store *all* tickets ever submitted, allowing lookup by ID or viewing history. Use a suitable `List` implementation (`ArrayList`).
 *     *   A mechanism to generate unique ticket IDs.
 * 
 * 3.  **Functionality:** The `SupportSystem` class must provide the following public methods:
 *     *   `submitTicket(String description)`: Creates a new `Ticket`, assigns a unique ID, sets the status to PENDING, adds it to both the pending queue and the all-tickets list, and prints a confirmation message with the ticket ID to `System.out`.
 *     *   `processNextTicket()`: Removes the oldest ticket from the pending queue, changes its status to RESOLVED in the all-tickets list (you'll need to find it in the list), and prints a confirmation message to `System.out`. If the queue is empty, it should print an error message to `System.err`.
 *     *   `viewPendingTickets()`: Iterates through the `allTickets` list and prints the details of only the tickets with PENDING status to `System.out`. Prints a message if no pending tickets exist.
 *     *   `viewAllTickets()`: Iterates through the `allTickets` list and prints the details of all tickets (pending and resolved) to `System.out`. Prints a message if no tickets have been submitted.
 * 
 * 4.  **User Interface:** Implement a `main` method in a separate class (e.g., `SupportApp`) that provides a command-line interface using `Scanner`. The interface should present a menu with options for:
 *     *   1. Submit New Ticket
 *     *   2. Process Next Ticket
 *     *   3. View Pending Tickets
 *     *   4. View All Tickets
 *     *   5. Exit
 * 
 * 5.  **Control Flow:** Use a `switch` statement in the main loop to handle the user's menu selection.
 * 
 * 6.  **Input/Output:**
 *     *   Use `Scanner` to read user input (menu choice, ticket description).
 *     *   Use `System.out` for normal output (menu, confirmations, ticket details, lists).
 *     *   Use `System.err` for error messages (e.g., attempting to process a ticket when the queue is empty, invalid menu input).
 * 
 * 7.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle potential issues, specifically `InputMismatchException` when reading integer input from `Scanner`. The catch block should inform the user of the invalid input using `System.err` and prevent the program from crashing or entering an infinite loop.
 * 
 * 8.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement input validation where necessary (e.g., handling non-integer input for menu).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should loop, displaying the menu, accepting input, and performing the requested action. Output should be informative, indicating success or failure of operations and clearly listing ticket details when viewing. Error messages should go to the standard error stream.
 * 
 * Example interaction:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View All Tickets
 * 5. Exit
 * Enter choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket 1 submitted successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 1
 * Enter ticket description: Software installation failed.
 * Ticket 2 submitted successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: My printer is not working., Status: PENDING
 * Ticket ID: 2, Description: Software installation failed., Status: PENDING
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 2
 * Processing ticket 1...
 * Ticket 1 resolved.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 2, Description: Software installation failed., Status: PENDING
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 4
 * --- All Tickets ---
 * Ticket ID: 1, Description: My printer is not working., Status: RESOLVED
 * Ticket ID: 2, Description: Software installation failed., Status: PENDING
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 2
 * Processing ticket 2...
 * Ticket 2 resolved.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 2
 * Error: No pending tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter choice: 5
 * Exiting Support Ticket System.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based support ticket management system, fulfilling all the specified requirements and demonstrating the use of the required Java components and best practices.
 * 
 * 1.  **Scenario and Structure:** The system simulates managing support tickets, with a clear separation of concerns: `Ticket` class for data representation and `SupportSystem` for business logic and data management. The `SupportApp` class handles the user interface and main application loop.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue` (`java.util.Queue` implemented by `LinkedList`): The `pendingTickets` queue is used to manage tickets in a First-In, First-Out (FIFO) order, which is natural for processing support tickets. `offer()` adds to the tail, and `poll()` retrieves and removes from the head.
 *     *   `ArrayList` (`java.util.ArrayList` implementing `List`): The `allTickets` list is used to store a historical record of all tickets submitted. It allows easy iteration (`for` loop) to view all tickets or filter by status.
 *     *   `List interface` (`java.util.List`): `allTickets` is declared as `List<Ticket>`, promoting good practice by programming to the interface rather than the concrete implementation (`ArrayList`).
 *     *   `Scanner` (`java.util.Scanner`): Used in the `main` method to read user input from the console for menu choices and ticket descriptions.
 *     *   `Switch statement`: Used in the `main` method to control the program flow based on the user's menu selection, directing execution to the appropriate `SupportSystem` method.
 *     *   `System.err`: Used for outputting error messages, such as when trying to process a ticket with an empty queue or when the user provides invalid input. This adheres to the convention of separating error output from standard output.
 *     *   `System.out`: Used for all normal output, including the menu, successful operation messages, and ticket lists.
 *     *   `Class-wide exception handling with try-catch`: A `try-catch` block wraps the main application loop in the `main` method. This handles potential exceptions during the execution, specifically focusing on `InputMismatchException` which can occur if `scanner.nextInt()` encounters non-integer input. The catch block prints an informative error message to `System.err` and consumes the invalid input to prevent an infinite loop. A general `catch (Exception e)` is also included as a fallback for any other unexpected runtime issues, printing the stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Ticket` and `SupportSystem` are `private`, with public methods (`getters`, `resolve`, `submitTicket`, etc.) providing controlled access.
 *     *   **Meaningful Names:** Class names (`Ticket`, `SupportSystem`, `SupportApp`), variable names (`pendingTickets`, `allTickets`, `nextTicketId`, `description`, `status`), and method names (`submitTicket`, `processNextTicket`, `viewPendingTickets`, `viewAllTickets`) are descriptive and indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 *     *   **Input Validation:** The `submitTicket` method checks if the description is null or empty. The `try-catch` block in `main` handles invalid integer input for the menu choice.
 *     *   **Proper Error Handling:** Distinct error messages are provided via `System.err` for specific failure conditions (empty queue, invalid input).
 *     *   **Clean Code Structure:** The code is organized into logical classes, and methods are kept relatively short and focused on a single task. Constants are used for ticket statuses.
 * 
 * This solution effectively combines multiple Java features to create a functional and well-structured program, demonstrating advanced concepts like collection usage, object interaction, and robust error handling in a practical context.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList; // Common List implementation
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single support ticket.
 */
class Ticket {
    private int ticketId;
    private String description;
    private String status;

    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_RESOLVED = "RESOLVED";

    /**
     * Constructs a new Ticket.
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = STATUS_PENDING; // New tickets are always pending
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters/Mutators ---
    /**
     * Marks the ticket as resolved.
     */
    public void resolve() {
        this.status = STATUS_RESOLVED;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket ID: " + ticketId +
               ", Description: " + description +
               ", Status: " + status;
    }
}

/**
 * Manages the collection of support tickets.
 */
class SupportSystem {
    // Queue for tickets waiting to be processed (FIFO)
    private Queue<Ticket> pendingTickets;
    // List to store all tickets submitted (for history/lookup)
    private List<Ticket> allTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new SupportSystem.
     */
    public SupportSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.allTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start IDs from 1
    }

    /**
     * Submits a new ticket to the system.
     * @param description The description of the ticket issue.
     */
    public void submitTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // Add to the end of the queue
        allTickets.add(newTicket); // Add to the list
        System.out.println("Ticket " + newTicket.getTicketId() + " submitted successfully.");
    }

    /**
     * Processes the next ticket from the pending queue.
     * Resolves the ticket and updates its status in the allTickets list.
     */
    public void processNextTicket() {
        Ticket nextTicket = pendingTickets.poll(); // Get and remove the head of the queue

        if (nextTicket == null) {
            System.err.println("Error: No pending tickets to process.");
        } else {
            // Find the ticket in the allTickets list and update its status
            // Although we have the reference, finding by ID demonstrates list lookup
            // In this simple case, we can just use the reference directly if we are sure
            // the object in the queue is the same instance in the list.
            // A more robust approach for larger systems might involve looking up by ID
            // in the list if the queue held copies or identifiers instead of direct references.
            // Here, direct reference is fine as they are the same objects.
            nextTicket.resolve();
            System.out.println("Processing ticket " + nextTicket.getTicketId() + "...");
            System.out.println("Ticket " + nextTicket.getTicketId() + " resolved.");
        }
    }

    /**
     * Displays all tickets currently in the pending state.
     */
    public void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        boolean foundPending = false;
        // Iterate through the allTickets list and filter by status
        for (Ticket ticket : allTickets) {
            if (ticket.getStatus().equals(Ticket.STATUS_PENDING)) {
                System.out.println(ticket);
                foundPending = true;
            }
        }
        if (!foundPending) {
            System.out.println("No pending tickets found.");
        }
    }

    /**
     * Displays all tickets ever submitted to the system.
     */
    public void viewAllTickets() {
        System.out.println("--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets have been submitted yet.");
        } else {
            for (Ticket ticket : allTickets) {
                System.out.println(ticket);
            }
        }
    }
}

/**
 * Main class to run the Support Ticket Management System application.
 */
public class SupportApp {

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement for flow control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            system.submitTicket(description);
                            break;
                        case 2:
                            system.processNextTicket();
                            break;
                        case 3:
                            system.viewPendingTickets();
                            break;
                        case 4:
                            system.viewAllTickets();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Support Ticket System.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View All Tickets");
        System.out.println("5. Exit");
    }
}
