/*
 * Exam Question #401
 * Generated on: 2025-05-11 23:05:44
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Prioritized Task Queue System
 * 
 * **Scenario:** You are tasked with developing a simple console-based task management system for a small team. The system should allow users to add tasks, manage them in a waiting list, move them to a processing queue, and process tasks from the queue. Tasks have a description and a priority level.
 * 
 * **Task Definition:**
 * Each task should be represented by a Java object with the following attributes:
 * - A unique integer ID, automatically assigned starting from 1.
 * - A description (String).
 * - A priority level, which can be HIGH, MEDIUM, or LOW.
 * 
 * **System Functionality:**
 * The system should provide a menu-driven interface with the following options:
 * 1.  **Add New Task:** Prompts the user for a task description and priority. Creates a new task and adds it to a *waiting list*.
 * 2.  **Move Task from Waiting List to Processing Queue:** Displays the current tasks in the waiting list with their indices. Prompts the user to enter the index of the task they wish to move. Removes the selected task from the waiting list and adds it to the *processing queue*.
 * 3.  **Process Next Task from Queue:** Removes and simulates processing the next task from the *processing queue*. Tasks are processed in the order they were added to the queue (FIFO).
 * 4.  **View Waiting List:** Displays all tasks currently in the waiting list, including their index, ID, priority, and description.
 * 5.  **View Processing Queue:** Displays all tasks currently in the processing queue, including their ID, priority, and description.
 * 6.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * Your solution must adhere to the following technical specifications:
 * -   Utilize `java.util.Queue` (specifically, an implementation like `LinkedList`) for the *processing queue*.
 * -   Utilize `java.util.ArrayList` for the *waiting list*.
 * -   Declare the waiting list variable using the `java.util.List` interface type.
 * -   Use `java.util.Scanner` to read user input from the console for menu choices and task details.
 * -   Implement the main menu logic using a `switch` statement.
 * -   Use `System.err` to print all error messages (e.g., invalid input format, invalid menu choice, attempting an operation on an empty list/queue, invalid index).
 * -   Use `System.out` for all standard output (menu display, prompts, success messages, task listings).
 * -   Implement **class-wide exception handling** using a `try-catch` block that wraps the main application loop to catch any unexpected runtime exceptions.
 * -   Implement specific error handling within the menu options for expected issues like `InputMismatchException` (for non-integer input) or `IllegalArgumentException` (for invalid priority strings).
 * -   Follow Java best practices:
 *     -   Proper encapsulation (private fields, public methods) for classes.
 *     -   Meaningful variable and method names.
 *     -   Appropriate comments and documentation (e.g., Javadoc for public methods).
 *     -   Input validation to handle incorrect user input gracefully.
 *     -   Clean code structure (e.g., separate classes for Task and the Task Management logic).
 * 
 * **Expected Output:**
 * The application should present a clear menu, guide the user through inputs, and display task information or error messages as appropriate. The task display format should be consistent and informative.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Move Task from Waiting List to Queue
 * 3. Process Next Task from Queue
 * 4. View Waiting List
 * 5. View Processing Queue
 * 6. Exit
 * --------------------------
 * Enter your choice: 1
 * Enter task description: Design Database
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added to waiting list: Task #1 [Priority: HIGH, Desc: Design Database]
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter task description: Implement API
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added to waiting list: Task #2 [Priority: MEDIUM, Desc: Implement API]
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 4
 * --- Waiting List ---
 * 0: Task #1 [Priority: HIGH, Desc: Design Database]
 * 1: Task #2 [Priority: MEDIUM, Desc: Implement API]
 * --------------------
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * --- Waiting List ---
 * 0: Task #1 [Priority: HIGH, Desc: Design Database]
 * 1: Task #2 [Priority: MEDIUM, Desc: Implement API]
 * --------------------
 * Enter the index of the task to move: 0
 * Task moved to processing queue: Task #1 [Priority: HIGH, Desc: Design Database]
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 5
 * --- Processing Queue ---
 * 0: Task #1 [Priority: HIGH, Desc: Design Database]
 * ------------------------
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Processing task: Task #1 [Priority: HIGH, Desc: Design Database]
 * Task #1 completed.
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 5
 * --- Processing Queue ---
 * Processing queue is empty.
 * ------------------------
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Error: Processing queue is empty.
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 6
 * Exiting Task System. Goodbye!
 * ```
 * 
 * Your submission should include the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements the Prioritized Task Queue System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     -   `Priority` enum: Defines the allowed priority levels (HIGH, MEDIUM, LOW), making the code more readable and preventing invalid priority strings.
 *     -   `Task` class: Encapsulates task data (ID, description, priority). It includes private fields, a constructor, public getters, and a `toString()` method for easy display. A static counter `nextId` ensures unique IDs for each task instance.
 *     -   `TaskManager` class: Manages the two collections (`waitingList` and `processingQueue`) and the core business logic (adding, moving, processing, viewing tasks). It uses private fields for the collections and public methods for operations, adhering to encapsulation.
 *     -   `ExamTaskSystem` class: Contains the `main` method, which serves as the application's entry point. It handles user interaction, displays the menu, reads input using `Scanner`, and delegates operations to the `TaskManager`.
 * 
 * 2.  **Collection Usage:**
 *     -   `java.util.List` and `java.util.ArrayList`: The `waitingList` is declared as `List<Task>` and initialized as an `ArrayList<Task>`. This demonstrates using the interface type, which is a good practice. `ArrayList` is suitable here because tasks are added sequentially and accessed/removed by index (Option 2).
 *     -   `java.util.Queue` and `java.util.LinkedList`: The `processingQueue` is declared as `Queue<Task>` and initialized as a `LinkedList<Task>`. `LinkedList` is a common implementation of `Queue`. The `Queue` interface provides methods like `offer()` (add to end) and `poll()` (remove from front), which are essential for FIFO processing, as required by Option 3.
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     -   A `Scanner` object reads input from `System.in`.
 *     -   The main application loop continues until the `running` flag is set to `false` (by choosing option 6).
 *     -   A `switch` statement directs the program flow based on the user's integer choice, making the menu navigation clear and efficient.
 *     -   Careful handling of `scanner.nextLine()` after `scanner.nextInt()` is included to consume the leftover newline character and prevent input issues in subsequent `nextLine()` calls.
 * 
 * 4.  **Error Handling (`try-catch`, `System.err`, `System.out`):**
 *     -   **Specific Exception Handling:**
 *         -   A `try-catch(InputMismatchException)` block is used when reading the menu choice and the task index to gracefully handle cases where the user enters non-integer input. An error message is printed to `System.err`, and the invalid input is consumed to prevent an infinite loop.
 *         -   A `try-catch(IllegalArgumentException)` block is used when parsing the priority string (`Priority.valueOf()`) to catch invalid priority names entered by the user. An error message is printed to `System.err`.
 *         -   Validation for the task index when moving a task (Option 2) is performed within the `moveTaskToQueue` method in `TaskManager`. If the index is out of bounds, an error message is printed to `System.err`, and the operation is aborted.
 *         -   Checking if the queue is empty before processing (Option 3) is done within the `processNextTask` method. If empty, an error is printed to `System.err`. Similarly, checking if the waiting list is empty before attempting to move a task prevents errors and prints a message to `System.out`.
 *     -   **Class-wide Exception Handling:**
 *         -   A broad `try-catch(Exception e)` block wraps the entire `while(running)` loop in the `main` method. This serves as a fallback to catch any unexpected runtime exceptions that might occur and haven't been handled by the more specific `try-catch` blocks. It prints a generic error message and the stack trace to `System.err`, fulfilling the "class-wide" requirement by catching errors at the highest level of the application's main logic.
 *     -   **Output Streams:**
 *         -   `System.err.println()` is used exclusively for printing error messages, as required.
 *         -   `System.out.println()` is used for all normal output, including the menu, prompts, success messages, and task list displays.
 * 
 * 5.  **Best Practices:**
 *     -   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 *     -   **Naming:** Variables, methods, and classes have descriptive names (`waitingList`, `processNextTask`, `moveTaskToQueue`, `Task`, `TaskManager`, etc.).
 *     -   **Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic.
 *     -   **Input Validation:** Checks are in place for input type (`InputMismatchException`), value range (index check), and format (priority string parsing).
 *     -   **Clean Code:** The code is divided into logical units (classes), methods are reasonably sized, and the main method focuses on control flow and user interaction, delegating core logic to `TaskManager`. The `finally` block ensures the `Scanner` resource is closed properly.
 * 
 * This solution effectively integrates all specified Java components and demonstrates robust error handling and adherence to best practices within a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the priority levels for a task.
 */
enum Priority {
    HIGH, MEDIUM, LOW
}

/**
 * Represents a single task with an ID, description, and priority.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;
    private Priority priority;

    /**
     * Constructs a new Task with an auto-generated ID.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public Task(String description, Priority priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return Formatted string including task ID, priority, and description.
     */
    @Override
    public String toString() {
        return "Task #" + id + " [Priority: " + priority + ", Desc: " + description + "]";
    }
}

/**
 * Manages the collection of tasks, including a waiting list and a processing queue.
 */
class TaskManager {
    // Using List interface for the waiting list, implemented by ArrayList
    private List<Task> waitingList;
    // Using Queue interface for the processing queue, implemented by LinkedList
    private Queue<Task> processingQueue;

    /**
     * Constructs a new TaskManager with empty waiting and processing lists.
     */
    public TaskManager() {
        waitingList = new ArrayList<>();
        processingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds a new task to the waiting list.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public void addTask(String description, Priority priority) {
        Task newTask = new Task(description, priority);
        waitingList.add(newTask);
        System.out.println("Task added to waiting list: " + newTask);
    }

    /**
     * Moves a task from the waiting list to the processing queue based on its index.
     *
     * @param index The 0-based index of the task in the waiting list.
     * @return The task that was moved, or null if the index was invalid.
     */
    public Task moveTaskToQueue(int index) {
        if (index < 0 || index >= waitingList.size()) {
            // Use System.err for error messages
            System.err.println("Error: Invalid task index. Please enter an index from 0 to " + (waitingList.size() - 1) + ".");
            return null;
        }
        // Remove task from waiting list (ArrayList)
        Task taskToMove = waitingList.remove(index);
        // Add task to processing queue (Queue via LinkedList)
        processingQueue.offer(taskToMove); // offer is preferred over add for queues (doesn't throw exception)
        System.out.println("Task moved to processing queue: " + taskToMove);
        return taskToMove;
    }

    /**
     * Processes (removes) the next task from the processing queue (FIFO).
     *
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        // Poll retrieves and removes the head of the queue, returns null if empty
        Task processedTask = processingQueue.poll();
        if (processedTask == null) {
            // Use System.err for error messages
            System.err.println("Error: Processing queue is empty. No tasks to process.");
        } else {
            System.out.println("Processing task: " + processedTask);
            // Simulate work...
            System.out.println("Task #" + processedTask.getId() + " completed.");
        }
        return processedTask;
    }

    /**
     * Displays all tasks currently in the waiting list.
     * Includes index for user selection.
     */
    public void viewWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate through ArrayList to display tasks with indices
            for (int i = 0; i < waitingList.size(); i++) {
                System.out.println(i + ": " + waitingList.get(i));
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all tasks currently in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            // Iterate through Queue without removing elements (using enhanced for loop)
            int i = 0;
            for (Task task : processingQueue) {
                 System.out.println(i++ + ": " + task);
            }
        }
        System.out.println("------------------------");
    }

    // Method to check if waiting list is empty (useful for input validation)
    public boolean isWaitingListEmpty() {
        return waitingList.isEmpty();
    }
}

/**
 * Main class for the Prioritized Task Queue System application.
 * Handles user interaction and menu logic.
 */
public class ExamTaskSystem {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling block for unexpected errors
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read integer input for menu choice
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline character
                } catch (InputMismatchException e) {
                    // Specific handling for non-integer input
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show the menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                        String priorityString = scanner.nextLine().trim().toUpperCase(); // Read, trim, and convert to uppercase
                        try {
                            // Validate and parse priority string to enum
                            Priority priority = Priority.valueOf(priorityString);
                            taskManager.addTask(description, priority);
                        } catch (IllegalArgumentException e) {
                            // Specific handling for invalid priority string
                            System.err.println("Invalid priority entered. Please use HIGH, MEDIUM, or LOW.");
                        }
                        break;

                    case 2: // Move Task from Waiting List to Processing Queue
                        taskManager.viewWaitingList(); // Show list with indices
                        if (taskManager.isWaitingListEmpty()) {
                             System.out.println("Cannot move task: Waiting list is empty.");
                             break; // Exit case if list is empty
                        }
                        System.out.print("Enter the index of the task to move: ");
                        try {
                            // Read integer input for task index
                            int indexToMove = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.moveTaskToQueue(indexToMove); // TaskManager handles index validation
                        } catch (InputMismatchException e) {
                            // Specific handling for non-integer index input
                            System.err.println("Invalid input. Please enter a valid index number.");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;

                    case 3: // Process Next Task from Queue
                        taskManager.processNextTask(); // TaskManager handles empty queue check
                        break;

                    case 4: // View Waiting List
                        taskManager.viewWaitingList();
                        break;

                    case 5: // View Processing Queue
                        taskManager.viewProcessingQueue();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Task System. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;

                    default:
                        // Handle invalid menu choice numbers
                        System.out.println("Invalid choice. Please try again.");
                }
                System.out.println(); // Print a blank line for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur in the main loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Move Task from Waiting List to Queue");
        System.out.println("3. Process Next Task from Queue");
        System.out.println("4. View Waiting List");
        System.out.println("5. View Processing Queue");
        System.out.println("6. Exit");
        System.out.println("--------------------------");
    }
}
