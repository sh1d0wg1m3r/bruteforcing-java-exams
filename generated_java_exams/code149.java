/*
 * Exam Question #149
 * Generated on: 2025-05-11 22:21:57
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified hospital appointment scheduling system. The system needs to manage a waiting list of patients and a list of available doctors. Patients arrive and are added to a queue. When a doctor becomes available, the next patient from the queue is assigned to that doctor. The system should allow viewing the patient waiting list, the list of doctors, scheduling an appointment, and viewing a doctor's schedule.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Add a new patient to the waiting queue.
 *     *   List all patients currently in the waiting queue.
 *     *   List all available doctors.
 *     *   Schedule an appointment: Take the next patient from the waiting queue and assign them to a selected doctor.
 *     *   View the schedule for a specific doctor.
 *     *   Provide a menu-driven interface for the user to interact with the system.
 *     *   Allow the user to exit the application.
 * 
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the patient waiting list.
 *     *   Use `java.util.ArrayList` to store the list of doctors.
 *     *   Use `java.util.List` interface reference when interacting with the list of doctors (e.g., method parameters or variable declarations).
 * 
 * 3.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for displaying menus, lists, and successful operations.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty, doctor not found).
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options.
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensuring integer input where expected, validating menu choices, checking if queue/lists are empty before operations).
 *     *   Use `try-catch` blocks for exception handling, particularly around user input that might cause `InputMismatchException` or logical operations that could fail (like trying to dequeue from an empty queue). Implement a form of class-wide exception handling (e.g., wrapping the main operational loop in a `try-catch` to catch unexpected errors gracefully).
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create separate classes for `Patient` (at least a name) and `Doctor` (at least a name and a way to store their scheduled appointments).
 *     *   Implement proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs where appropriate).
 * 
 * **Instructions:**
 * 
 * Write a complete Java program that implements the described hospital appointment scheduler. The program should run from a `main` method and provide the interactive menu. Initialize the system with a few sample doctors.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Hospital Appointment Scheduler ---
 * 1. Add Patient to Queue
 * 2. View Patient Queue
 * 3. List Doctors
 * 4. Schedule Appointment
 * 5. View Doctor Schedule
 * 6. Exit
 * Enter choice: 1
 * Enter patient name: Alice
 * 
 * Patient Alice added to queue.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Add Patient to Queue
 * 2. View Patient Queue
 * 3. List Doctors
 * 4. Schedule Appointment
 * 5. View Doctor Schedule
 * 6. Exit
 * Enter choice: 1
 * Enter patient name: Bob
 * 
 * Patient Bob added to queue.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Add Patient to Queue
 * 2. View Patient Queue
 * 3. List Doctors
 * 4. Schedule Appointment
 * 5. View Doctor Schedule
 * 6. Exit
 * Enter choice: 2
 * 
 * Patient Queue:
 * Alice
 * Bob
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Add Patient to Queue
 * 2. View Patient Queue
 * 3. List Doctors
 * 4. Schedule Appointment
 * 5. View Doctor Schedule
 * 6. Exit
 * Enter choice: 3
 * 
 * Available Doctors:
 * 0. Dr. Smith (Cardiology)
 * 1. Dr. Jones (Pediatrics)
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Add Patient to Queue
 * 2. View Patient Queue
 * 3. List Doctors
 * 4. Schedule Appointment
 * 5. View Doctor Schedule
 * 6. Exit
 * Enter choice: 4
 * 
 * Next patient from queue: Alice
 * Select a doctor (enter number):
 * 0. Dr. Smith (Cardiology)
 * 1. Dr. Jones (Pediatrics)
 * Enter doctor number: 0
 * 
 * Appointment scheduled: Alice assigned to Dr. Smith.
 * 
 * --- Hospital Appointment Scheduler ---
 * ... (menu continues)
 * Enter choice: 5
 * Select a doctor to view schedule (enter number):
 * 0. Dr. Smith (Cardiology)
 * 1. Dr. Jones (Pediatrics)
 * Enter doctor number: 0
 * 
 * Dr. Smith's Schedule:
 * Alice
 * 
 * --- Hospital Appointment Scheduler ---
 * ... (menu continues)
 * Enter choice: 6
 * 
 * Exiting scheduler.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust error handling with `try-catch` and input validation.
 * *   Adherence to object-oriented principles (encapsulation, meaningful names).
 * *   Code clarity, comments, and structure.
 * 
 * **Note:** You do not need to persist data to files or a database. Data can be stored in memory for the duration of the program execution.
 *
 * EXPLANATION:
 * This solution implements the Hospital Appointment Scheduler problem, demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`: A simple class holding the patient's name.
 *     *   `Doctor`: Holds the doctor's name, specialty, and a `List<Patient>` to represent their scheduled appointments.
 *     *   `HospitalScheduler`: The main class containing the `main` method and the core logic. It holds the `Queue` of waiting patients and the `List` of doctors.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue (patientQueue)`: Used to maintain the waiting list. Patients are added using `offer()` and removed (for scheduling) using `poll()`. `peek()` is used to view the next patient without removing them.
 *     *   `ArrayList (doctorList)`: Used to store the `Doctor` objects. Initialized with sample doctors.
 *     *   `List interface`: Used when declaring `doctorList` (`List<Doctor> doctorList = new ArrayList<>();`) and as the return type for `Doctor.getSchedule()` (`public List<Patient> getSchedule()`).
 *     *   `Scanner (scanner)`: Used throughout the `HospitalScheduler` class to read user input from `System.in`.
 *     *   `Switch statement`: Used in the `run()` method's main loop to dispatch actions based on the user's menu choice.
 *     *   `System.err`: Used specifically for printing error messages (e.g., invalid input, queue empty, doctor not found).
 *     *   `System.out`: Used for displaying menus, prompts, lists, and success messages.
 *     *   `try-catch blocks`: Used for exception handling.
 *         *   Specific `try-catch(InputMismatchException)` blocks are used around `scanner.nextInt()` calls in `scheduleAppointment` and `viewDoctorSchedule` to handle non-integer input gracefully.
 *         *   A general `try-catch(Exception e)` is included in `scheduleAppointment` and `viewDoctorSchedule` to catch other potential runtime errors during those operations.
 *         *   A broad `try-catch(Exception e)` wraps the main `while` loop in the `run()` method. This fulfills the requirement for "class-wide exception handling" by preventing the program from crashing on most unhandled runtime exceptions within the main execution flow, printing the error to `System.err`.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Patient` and `Doctor` are `private`, accessed via `public` getter methods. The scheduler's internal data structures (`patientQueue`, `doctorList`) are also `private`.
 *     *   **Meaningful Names:** Variable names like `patientQueue`, `doctorList`, `scheduleAppointment`, `viewDoctorSchedule` clearly indicate their purpose.
 *     *   **Comments/Documentation:** Javadoc comments are provided for classes and public methods, explaining their purpose and parameters/return values. Inline comments explain specific logic where needed.
 *     *   **Input Validation:** Checks are performed for empty patient names, valid menu choices, valid doctor indices, and empty queues/lists before attempting operations that require data.
 *     *   **Error Handling:** `try-catch` is used for input type errors and logical errors (like trying to schedule from an empty queue). Error messages are directed to `System.err`.
 *     *   **Clean Code Structure:** The code is divided into logical methods (`addPatientToQueue`, `scheduleAppointment`, etc.), making the `run()` method clean and readable.
 * 
 * 4.  **Flow:**
 *     *   The `main` method creates a `HospitalScheduler` instance and calls its `run()` method.
 *     *   `run()` enters a loop that repeatedly displays the menu, reads user input, and uses a `switch` statement to call the appropriate method.
 *     *   Each method performs its specific task, interacting with the `patientQueue`, `doctorList`, and `scanner`, handling potential errors, and providing feedback via `System.out` or `System.err`.
 *     *   The loop continues until the user chooses option 6 to exit, at which point the `scanner` is closed.
 * 
 * This solution effectively integrates the required Java components into a practical scenario, demonstrating understanding of data structures, control flow, object-oriented design, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a Patient in the hospital waiting queue.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the patient's name.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Represents a Doctor with a schedule.
 */
class Doctor {
    private String name;
    private String specialty;
    private List<Patient> schedule; // Using List to store scheduled patients

    /**
     * Constructs a new Doctor.
     * @param name The doctor's name.
     * @param specialty The doctor's specialty.
     */
    public Doctor(String name, String specialty) {
        this.name = name;
        this.specialty = specialty;
        this.schedule = new ArrayList<>(); // Initialize schedule as an ArrayList
    }

    /**
     * Gets the doctor's name.
     * @return The doctor's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the doctor's specialty.
     * @return The doctor's specialty.
     */
    public String getSpecialty() {
        return specialty;
    }

    /**
     * Adds a patient to the doctor's schedule.
     * @param patient The patient to add.
     */
    public void addAppointment(Patient patient) {
        this.schedule.add(patient);
    }

    /**
     * Gets the doctor's current schedule.
     * @return A List of patients in the schedule.
     */
    public List<Patient> getSchedule() {
        return schedule;
    }

    @Override
    public String toString() {
        return name + " (" + specialty + ")";
    }
}

/**
 * The main class for the Hospital Appointment Scheduler system.
 * Manages the patient queue and doctor list.
 */
public class HospitalScheduler {

    private Queue<Patient> patientQueue;
    private List<Doctor> doctorList;
    private Scanner scanner;

    /**
     * Constructs a new HospitalScheduler.
     * Initializes the patient queue, doctor list, and scanner.
     */
    public HospitalScheduler() {
        // Using LinkedList as an implementation of Queue
        this.patientQueue = new LinkedList<>();
        // Using ArrayList as an implementation of List for doctors
        this.doctorList = new ArrayList<>();
        this.scanner = new Scanner(System.in);

        // Initialize with some sample doctors
        initializeDoctors();
    }

    /**
     * Initializes the list of doctors.
     */
    private void initializeDoctors() {
        doctorList.add(new Doctor("Dr. Smith", "Cardiology"));
        doctorList.add(new Doctor("Dr. Jones", "Pediatrics"));
        doctorList.add(new Doctor("Dr. Williams", "Neurology"));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment Scheduler ---");
        System.out.println("1. Add Patient to Queue");
        System.out.println("2. View Patient Queue");
        System.out.println("3. List Doctors");
        System.out.println("4. Schedule Appointment");
        System.out.println("5. View Doctor Schedule");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a patient to the waiting queue based on user input.
     */
    private void addPatientToQueue() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }
        Patient patient = new Patient(name.trim());
        patientQueue.offer(patient); // offer is generally preferred over add for queues
        System.out.println("Patient " + patient.getName() + " added to queue.");
    }

    /**
     * Displays the current patient waiting queue.
     */
    private void viewPatientQueue() {
        System.out.println("\nPatient Queue:");
        if (patientQueue.isEmpty()) {
            System.out.println("The queue is currently empty.");
            return;
        }
        // Iterate through the queue without removing elements
        int index = 1;
        for (Patient patient : patientQueue) {
            System.out.println(index++ + ". " + patient.getName());
        }
    }

    /**
     * Lists all available doctors.
     */
    private void listDoctors() {
        System.out.println("\nAvailable Doctors:");
        if (doctorList.isEmpty()) {
            System.out.println("No doctors available.");
            return;
        }
        // Using List interface reference implicitly here in the loop
        for (int i = 0; i < doctorList.size(); i++) {
            Doctor doctor = doctorList.get(i);
            System.out.println(i + ". " + doctor.getName() + " (" + doctor.getSpecialty() + ")");
        }
    }

    /**
     * Schedules an appointment by taking the next patient from the queue
     * and assigning them to a selected doctor.
     */
    private void scheduleAppointment() {
        if (patientQueue.isEmpty()) {
            System.err.println("Error: Patient queue is empty. Cannot schedule appointment.");
            return;
        }

        Patient nextPatient = patientQueue.peek(); // Peek to show who's next
        System.out.println("\nNext patient from queue: " + (nextPatient != null ? nextPatient.getName() : "N/A"));

        listDoctors(); // Show doctors to select from

        if (doctorList.isEmpty()) {
             System.err.println("Error: No doctors available to schedule with.");
             return;
        }

        System.out.print("Select a doctor (enter number): ");
        int doctorIndex = -1;
        try {
            doctorIndex = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over

            if (doctorIndex < 0 || doctorIndex >= doctorList.size()) {
                System.err.println("Error: Invalid doctor number.");
                return;
            }

            // Dequeue the patient ONLY after successful doctor selection
            Patient scheduledPatient = patientQueue.poll(); // poll removes and returns the head

            Doctor selectedDoctor = doctorList.get(doctorIndex);
            selectedDoctor.addAppointment(scheduledPatient);

            System.out.println("Appointment scheduled: " + scheduledPatient.getName() + " assigned to " + selectedDoctor.getName() + ".");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for the doctor.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             // Catch any other unexpected errors during scheduling
             System.err.println("An unexpected error occurred during scheduling: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream
        }
    }

    /**
     * Views the schedule for a selected doctor.
     */
    private void viewDoctorSchedule() {
        listDoctors(); // Show doctors to select from

        if (doctorList.isEmpty()) {
             System.err.println("Error: No doctors available to view schedule.");
             return;
        }

        System.out.print("Select a doctor to view schedule (enter number): ");
        int doctorIndex = -1;
        try {
            doctorIndex = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over

            if (doctorIndex < 0 || doctorIndex >= doctorList.size()) {
                System.err.println("Error: Invalid doctor number.");
                return;
            }

            Doctor selectedDoctor = doctorList.get(doctorIndex);
            List<Patient> schedule = selectedDoctor.getSchedule(); // Using List interface return type

            System.out.println("\n" + selectedDoctor.getName() + "'s Schedule:");
            if (schedule.isEmpty()) {
                System.out.println("Schedule is empty.");
            } else {
                for (int i = 0; i < schedule.size(); i++) {
                    System.out.println((i + 1) + ". " + schedule.get(i).getName());
                }
            }

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for the doctor.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             // Catch any other unexpected errors
             System.err.println("An unexpected error occurred while viewing schedule: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            try { // Class-wide exception handling around the main loop
                displayMenu();
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addPatientToQueue();
                        break;
                    case 2:
                        viewPatientQueue();
                        break;
                    case 3:
                        listDoctors();
                        break;
                    case 4:
                        scheduleAppointment();
                        break;
                    case 5:
                        viewDoctorSchedule();
                        break;
                    case 6:
                        System.out.println("Exiting scheduler.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to prevent infinite loop if not exiting
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions in the main loop
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
                // Optionally break or exit if error is critical
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * The main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
