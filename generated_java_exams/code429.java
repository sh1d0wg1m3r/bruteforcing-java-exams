/*
 * Exam Question #429
 * Generated on: 2025-05-11 23:10:03
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Traffic Simulation Controller
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation controller for a four-way traffic intersection. The intersection has designated lanes for vehicles approaching from the North, South, East, and West. Vehicles arrive and wait in their respective lanes (queues) until the controller signals them to proceed.
 * 
 * Your program should manage these waiting vehicles, process them based on commands, and report the current status of the intersection.
 * 
 * **Requirements:**
 * 
 * 1.  **Vehicle Representation:** Create a `Vehicle` class with private fields for `vehicleId` (String) and `direction` (String, e.g., "NORTH", "SOUTH", "EAST", "WEST"). Include a constructor and a public `toString()` method.
 * 2.  **TrafficIntersection Controller:** Create a `TrafficIntersection` class responsible for managing the intersection state.
 *     *   It must use separate `java.util.Queue<Vehicle>` instances to represent the waiting lane for each direction (North, South, East, West). Use a `LinkedList` implementation for the Queues.
 *     *   It must use a `java.util.List<Vehicle>` (specifically, an `ArrayList`) to keep track of vehicles that have successfully passed through the intersection.
 *     *   Include public methods:
 *         *   `addVehicle(String direction, String vehicleId)`: Adds a new `Vehicle` to the correct direction's queue. Validate the direction string (case-insensitive). If invalid, print an error to `System.err` and do not add the vehicle.
 *         *   `processVehicle(String direction)`: Attempts to remove and return the next `Vehicle` from the specified direction's queue. If successful, add the processed vehicle to the list of processed vehicles and print a success message to `System.out`. If the queue for the given direction is empty, throw a custom exception `EmptyQueueException`. Validate the direction string. If invalid, print an error to `System.err` and do nothing else.
 *         *   `getIntersectionStatus()`: Returns a `String` summarizing the number of vehicles currently waiting in each queue and the total number of vehicles processed.
 * 3.  **Custom Exception:** Define a custom checked exception `EmptyQueueException` that extends `Exception`.
 * 4.  **Main Program (`TrafficSimulation` class):**
 *     *   Create a `TrafficIntersection` object.
 *     *   Use `java.util.Scanner` to read commands from the user via the console.
 *     *   Implement a command loop that accepts the following commands (case-insensitive):
 *         *   `ADD <direction> <vehicleId>`: Calls `addVehicle`. Example: `ADD NORTH Car1`.
 *         *   `PROCESS <direction>`: Calls `processVehicle`. Example: `PROCESS EAST`.
 *         *   `STATUS`: Calls `getIntersectionStatus()` and prints the result to `System.out`.
 *         *   `EXIT`: Terminates the program.
 *         *   Any other command should result in an error message printed to `System.err`.
 *     *   Use a `switch` statement to handle the different commands.
 *     *   Implement robust exception handling using `try-catch` blocks.
 *         *   Catch `EmptyQueueException` when calling `processVehicle` and print an informative error message to `System.err`.
 *         *   Include a general `catch (Exception e)` block in the main loop to catch unexpected errors and print an error message to `System.err`.
 *     *   Ensure proper resource management for the `Scanner`.
 * 5.  **Best Practices:**
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Include comments to explain complex parts of the code.
 *     *   Ensure clean and readable code structure.
 * 
 * **Input Format:**
 * 
 * Commands will be entered line by line in the format specified above.
 * 
 * **Expected Output:**
 * 
 * *   Successful operations (vehicle added, vehicle processed, status) should be printed to `System.out`.
 * *   Error messages (invalid command, invalid direction, processing empty queue, unexpected errors) should be printed to `System.err`.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * ADD NORTH Car1
 * Vehicle Car1 added to NORTH queue.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * ADD EAST Truck2
 * Vehicle Truck2 added to EAST queue.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * STATUS
 * Intersection Status:
 * NORTH: 1 vehicle(s)
 * SOUTH: 0 vehicle(s)
 * EAST: 1 vehicle(s)
 * WEST: 0 vehicle(s)
 * Total processed: 0 vehicle(s)
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * PROCESS NORTH
 * Vehicle Car1 processed from NORTH queue.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * PROCESS NORTH
 * Error: NORTH queue is empty. Cannot process vehicle.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * ADD SOUTH Bike3
 * Vehicle Bike3 added to SOUTH queue.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * PROCESS SOUTH
 * Vehicle Bike3 processed from SOUTH queue.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * STATUS
 * Intersection Status:
 * NORTH: 0 vehicle(s)
 * SOUTH: 0 vehicle(s)
 * EAST: 1 vehicle(s)
 * WEST: 0 vehicle(s)
 * Total processed: 2 vehicle(s)
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * INVALID_COMMAND
 * Error: Unknown command. Please use ADD, PROCESS, STATUS, or EXIT.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * ADD NORTHEAST Car4
 * Error: Invalid direction: NORTHEAST. Valid directions are NORTH, SOUTH, EAST, WEST.
 * Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):
 * EXIT
 * Exiting Traffic Simulation Controller.
 * ```
 * 
 * This task requires you to demonstrate understanding of object-oriented design, collection interfaces and implementations, user input processing, control flow with switch, and robust exception handling using try-catch and custom exceptions.
 *
 * EXPLANATION:
 * This solution implements a simplified traffic intersection controller demonstrating the required Java concepts.
 * 
 * 1.  **`EmptyQueueException`:** A custom checked exception is defined to signal the specific condition where a `processVehicle` operation is attempted on an empty queue. This provides a clear and type-safe way to handle this specific error case.
 * 
 * 2.  **`Vehicle` Class:** This is a simple Plain Old Java Object (POJO) representing a vehicle. It follows encapsulation principles with `private` fields and `public` getter methods. The `toString()` method provides a convenient way to represent a vehicle object as a string.
 * 
 * 3.  **`TrafficIntersection` Class:**
 *     *   **`Queue` Usage:** It uses a `HashMap` to store `Queue<Vehicle>` objects, mapping direction strings ("NORTH", "SOUTH", "EAST", "WEST") to their respective queues. `LinkedList` is chosen as the concrete implementation of the `Queue` interface because it provides efficient adding (`offer`) and removing (`poll`) from the ends, which is characteristic of a queue (FIFO - First-In, First-Out).
 *     *   **`List` and `ArrayList` Usage:** It uses a `List<Vehicle>` variable `processedVehicles`, instantiated as an `ArrayList<Vehicle>`. This list stores vehicles after they have been successfully processed from a queue. `ArrayList` is suitable here as we primarily need to add elements and potentially iterate or get the size, and random access isn't a primary concern, though `ArrayList` provides it efficiently. The variable is typed as `List` to adhere to the requirement of using the `List` interface, promoting programming to interfaces.
 *     *   **Encapsulation:** Fields (`trafficQueues`, `processedVehicles`) are private. Operations are exposed via public methods (`addVehicle`, `processVehicle`, `getIntersectionStatus`).
 *     *   **Input Validation:** The `isValidDirection` helper method and checks in `addVehicle` and `processVehicle` ensure that operations are only attempted with valid direction strings. Invalid inputs result in messages to `System.err`.
 *     *   **Error Handling:** `processVehicle` uses `queue.poll()` which returns `null` if the queue is empty. This condition is checked, and if true, an `EmptyQueueException` is thrown as required.
 *     *   **`System.out` vs `System.err`:** Success messages and status are printed to `System.out`. Validation errors and the custom exception message are output to `System.err`.
 * 
 * 4.  **`TrafficSimulation` Class (Main Program):**
 *     *   **`Scanner` Usage:** A `Scanner` object reads user input line by line from `System.in`. It's created outside the loop and closed at the end for proper resource management.
 *     *   **Command Loop:** A `while(running)` loop keeps the program active until the "EXIT" command is given.
 *     *   **`Switch` Statement:** The core command processing logic uses a `switch` statement on the uppercase version of the first word of the input line. This efficiently directs execution based on the command.
 *     *   **Input Parsing:** `inputLine.split("\\s+")` is used to break the command line into parts based on whitespace. Basic checks (`parts.length`) are performed to ensure the command has the expected number of arguments.
 *     *   **`try-catch` for Exceptions:**
 *         *   A specific `catch (EmptyQueueException e)` block is used around the `intersection.processVehicle()` call within the "PROCESS" case. This demonstrates catching the custom exception and handling it by printing an error message to `System.err`.
 *         *   A general `catch (Exception e)` block wraps the entire command processing logic inside the `while` loop. This provides class-wide exception handling, catching any other unexpected runtime errors (e.g., `ArrayIndexOutOfBoundsException` if the split logic wasn't robust enough, although basic checks are included) and reporting them via `System.err`.
 *     *   **Control Flow:** The `running` boolean flag and the `break` statement within the `switch` (or setting `running = false`) control the loop execution.
 * 
 * This solution effectively integrates all the required Java components within a practical simulation context, demonstrating good object-oriented principles, collection usage, input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;

// Custom exception for processing an empty queue
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Represents a vehicle in the simulation
class Vehicle {
    private String vehicleId;
    private String direction; // NORTH, SOUTH, EAST, WEST

    public Vehicle(String vehicleId, String direction) {
        this.vehicleId = vehicleId;
        this.direction = direction;
    }

    public String getVehicleId() {
        return vehicleId;
    }

    public String getDirection() {
        return direction;
    }

    @Override
    public String toString() {
        return vehicleId + " (" + direction + ")";
    }
}

// Manages the traffic intersection state and operations
class TrafficIntersection {
    // Using Map to easily access queues by direction string
    private Map<String, Queue<Vehicle>> trafficQueues;
    // List to store vehicles that have passed through
    private List<Vehicle> processedVehicles;

    // Define valid directions
    private static final List<String> VALID_DIRECTIONS = List.of("NORTH", "SOUTH", "EAST", "WEST");

    public TrafficIntersection() {
        trafficQueues = new HashMap<>();
        // Initialize queues for each direction
        for (String direction : VALID_DIRECTIONS) {
            trafficQueues.put(direction, new LinkedList<>()); // LinkedList implements Queue
        }
        processedVehicles = new ArrayList<>(); // ArrayList implements List
    }

    // Validates if a direction string is one of the allowed directions
    private boolean isValidDirection(String direction) {
        if (direction == null) {
            return false;
        }
        // Case-insensitive check
        return VALID_DIRECTIONS.contains(direction.toUpperCase());
    }

    /**
     * Adds a vehicle to the specified direction's queue.
     * @param direction The approach direction (NORTH, SOUTH, EAST, WEST).
     * @param vehicleId The unique identifier for the vehicle.
     */
    public void addVehicle(String direction, String vehicleId) {
        if (!isValidDirection(direction)) {
            System.err.println("Error: Invalid direction: " + direction + ". Valid directions are " + VALID_DIRECTIONS + ".");
            return;
        }

        String upperDirection = direction.toUpperCase();
        Vehicle vehicle = new Vehicle(vehicleId, upperDirection);
        Queue<Vehicle> queue = trafficQueues.get(upperDirection);

        // offer() is generally preferred over add() for bounded queues,
        // but for unbounded LinkedList, both work. offer() is safer practice.
        if (queue.offer(vehicle)) {
            System.out.println("Vehicle " + vehicleId + " added to " + upperDirection + " queue.");
        } else {
            // This case is unlikely with LinkedList unless memory is exhausted
            System.err.println("Error: Failed to add vehicle " + vehicleId + " to " + upperDirection + " queue.");
        }
    }

    /**
     * Processes (removes) the next vehicle from the specified direction's queue.
     * @param direction The direction queue to process from.
     * @return The processed Vehicle object.
     * @throws EmptyQueueException If the specified queue is empty.
     */
    public Vehicle processVehicle(String direction) throws EmptyQueueException {
        if (!isValidDirection(direction)) {
            System.err.println("Error: Invalid direction: " + direction + ". Valid directions are " + VALID_DIRECTIONS + ".");
            // We don't throw here because the requirement is to print to System.err
            // and only throw EmptyQueueException when queue is empty.
            // Returning null or having this method return void and throwing the
            // exception would also be valid designs depending on exact requirements.
            // Let's return null here for invalid direction after printing error.
             return null; // Indicate failure due to invalid direction
        }

        String upperDirection = direction.toUpperCase();
        Queue<Vehicle> queue = trafficQueues.get(upperDirection);

        // poll() retrieves and removes the head of the queue, returns null if empty
        Vehicle processed = queue.poll();

        if (processed == null) {
            // Throw the custom exception if the queue was empty
            throw new EmptyQueueException(upperDirection + " queue is empty. Cannot process vehicle.");
        } else {
            // Add to the list of processed vehicles
            processedVehicles.add(processed);
            System.out.println("Vehicle " + processed.getVehicleId() + " processed from " + upperDirection + " queue.");
            return processed;
        }
    }

    /**
     * Gets a summary string of the current intersection status.
     * @return A string detailing queue sizes and total processed count.
     */
    public String getIntersectionStatus() {
        StringBuilder status = new StringBuilder("Intersection Status:\n");
        for (String direction : VALID_DIRECTIONS) {
            // peek() allows viewing the head without removing
            int queueSize = trafficQueues.get(direction).size();
            status.append(direction).append(": ").append(queueSize).append(" vehicle(s)\n");
        }
        status.append("Total processed: ").append(processedVehicles.size()).append(" vehicle(s)");
        return status.toString();
    }
}

// Main class to run the simulation
public class TrafficSimulation {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TrafficIntersection intersection = new TrafficIntersection();
        boolean running = true;

        System.out.println("Traffic Simulation Controller started.");
        System.out.println("Enter command (ADD <dir> <id>, PROCESS <dir>, STATUS, EXIT):");

        // Main command processing loop
        while (running) {
            try {
                System.out.print("> "); // Prompt for input
                String inputLine = scanner.nextLine().trim();
                if (inputLine.isEmpty()) {
                    continue; // Skip empty lines
                }

                String[] parts = inputLine.split("\\s+");
                String command = parts[0].toUpperCase(); // Get command and make it uppercase

                // Use switch statement for command handling
                switch (command) {
                    case "ADD":
                        if (parts.length >= 3) {
                            String direction = parts[1];
                            String vehicleId = parts[2];
                            // Additional check for multiple words in ID
                            if (parts.length > 3) {
                                StringBuilder idBuilder = new StringBuilder(vehicleId);
                                for (int i = 3; i < parts.length; i++) {
                                    idBuilder.append(" ").append(parts[i]);
                                }
                                vehicleId = idBuilder.toString();
                            }
                            intersection.addVehicle(direction, vehicleId);
                        } else {
                            System.err.println("Error: ADD command requires direction and vehicle ID. Usage: ADD <direction> <vehicleId>");
                        }
                        break;

                    case "PROCESS":
                        if (parts.length == 2) {
                            String direction = parts[1];
                            // try-catch specifically for the custom exception
                            try {
                                intersection.processVehicle(direction);
                            } catch (EmptyQueueException e) {
                                // Catching the custom exception and reporting via System.err
                                System.err.println("Error: " + e.getMessage());
                            }
                            // Note: Invalid direction is handled inside processVehicle and prints to System.err
                            // without throwing EmptyQueueException.
                        } else {
                            System.err.println("Error: PROCESS command requires a direction. Usage: PROCESS <direction>");
                        }
                        break;

                    case "STATUS":
                        if (parts.length == 1) {
                            System.out.println(intersection.getIntersectionStatus());
                        } else {
                            System.err.println("Error: STATUS command does not take arguments. Usage: STATUS");
                        }
                        break;

                    case "EXIT":
                        if (parts.length == 1) {
                            running = false; // Set flag to exit loop
                            System.out.println("Exiting Traffic Simulation Controller.");
                        } else {
                             System.err.println("Error: EXIT command does not take arguments. Usage: EXIT");
                        }
                        break;

                    default:
                        // Default case for unknown commands
                        System.err.println("Error: Unknown command. Please use ADD, PROCESS, STATUS, or EXIT.");
                        break;
                }
            } catch (Exception e) {
                // Class-wide exception handling for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging details
            }
        }

        // Close the scanner resource
        scanner.close();
    }
}
