/*
 * Exam Question #336
 * Generated on: 2025-05-11 22:56:55
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: LogiFlow Package Hub Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified package management system for a logistics hub called "LogiFlow". The system needs to handle incoming packages, process them for sorting, and store them based on their destination zone. The system should interact with a user via the console.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts, including collections, object-oriented programming, user input handling, flow control, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **`Package` Class:** Create a class named `Package` with the following private fields:
 *     *   `packageId` (String): Unique identifier for the package.
 *     *   `destinationZone` (String): The target zone for sorting (must be "A", "B", or "C").
 *     *   `weight` (double): The weight of the package in kilograms.
 *     *   Implement a constructor that initializes these fields.
 *     *   Include public getter methods for all fields.
 *     *   Implement input validation within the constructor:
 *         *   `packageId` must not be null or empty.
 *         *   `destinationZone` must be exactly "A", "B", or "C" (case-insensitive, but store uppercase).
 *         *   `weight` must be non-negative.
 *         *   If any validation fails, throw an `IllegalArgumentException` with a descriptive message.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the package (e.g., "Package [ID: P123, Zone: A, Weight: 5.5kg]").
 * 
 * 2.  **`LogiFlowHub` Class:** Create a class named `LogiFlowHub` to manage the package flow.
 *     *   Declare a private `Queue<Package>` to hold incoming packages waiting to be processed.
 *     *   Declare three private `List<Package>` variables to hold processed packages for each zone: `zoneAProcessed`, `zoneBProcessed`, and `zoneCProcessed`. These lists should be implemented using `ArrayList`.
 *     *   Implement a constructor for `LogiFlowHub` that initializes the queue (using a suitable `Queue` implementation like `LinkedList`) and the three `ArrayList` instances.
 *     *   Implement the following public methods:
 *         *   `addPackage(Package pkg)`: Adds a `Package` object to the incoming queue.
 *         *   `processNextPackage()`: Retrieves the next package from the incoming queue. If the queue is empty, it should indicate an error (see exception handling below). If successful, it removes the package from the queue and adds it to the corresponding processed list (`zoneAProcessed`, `zoneBProcessed`, or `zoneCProcessed`) based on its `destinationZone`. Print a success message to `System.out`.
 *         *   `viewIncomingQueue()`: Prints the details of all packages currently in the incoming queue to `System.out`. Indicate if the queue is empty.
 *         *   `viewProcessedPackages(String zone)`: Prints the details of all packages in the specified destination zone's processed list (`zoneAProcessed`, `zoneBProcessed`, or `zoneCProcessed`) to `System.out`. The zone input should be case-insensitive ("a", "b", "c"). Indicate if the zone is invalid or if the list for that zone is empty.
 *         *   `start()`: This method should contain the main application loop. It should display a menu to the user, read their input using `Scanner`, and perform the corresponding action using a `switch` statement. The menu options should include:
 *             1.  Add Incoming Package
 *             2.  Process Next Package
 *             3.  View Incoming Queue
 *             4.  View Processed Packages by Zone
 *             5.  Exit
 *         *   Implement a private helper method `printMenu()` to display the menu options.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   Use `Scanner` to read user input in the `start()` method.
 *     *   Use a `while` loop to keep the application running until the user chooses to exit.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Error Handling:**
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the `start()` method's main loop to gracefully handle potential errors.
 *     *   Catch `InputMismatchException` if the user enters non-numeric input for menu choice or weight.
 *     *   Catch `IllegalArgumentException` when creating a `Package` object with invalid data.
 *     *   Handle the case where `processNextPackage()` is called when the incoming queue is empty. This can be done by checking the result of `poll()` and printing an error message to `System.err`, or by throwing an exception (like `IllegalStateException`) from `processNextPackage` and catching it in `start`. **Choose the exception throwing approach for demonstrating robust handling.**
 *     *   Catch any other unexpected exceptions that might occur.
 *     *   Print all error messages to `System.err`.
 *     *   Print normal status updates and package details to `System.out`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc comments for classes and public methods).
 *     *   Ensure proper encapsulation (private fields with public getters).
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform actions. Output should be clear, using `System.out` for normal information and `System.err` for errors. Example interactions might look like:
 * 
 * ```
 * --- LogiFlow Package Hub Menu ---
 * 1. Add Incoming Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Processed Packages by Zone
 * 5. Exit
 * -----------------------------------
 * Enter choice: 1
 * Enter Package ID: P001
 * Enter Destination Zone (A, B, C): A
 * Enter Weight: 10.5
 * Package P001 added to incoming queue.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 3
 * --- Incoming Queue ---
 * Package [ID: P001, Zone: A, Weight: 10.5kg]
 * ----------------------
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 2
 * Package P001 processed and moved to Zone A.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 3
 * --- Incoming Queue ---
 * Queue is empty.
 * ----------------------
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 4
 * Enter Zone to view (A, B, C): A
 * --- Processed Packages (Zone A) ---
 * Package [ID: P001, Zone: A, Weight: 10.5kg]
 * -------------------------------------
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 2
 * Error processing package: Incoming queue is empty.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 1
 * Enter Package ID: P002
 * Enter Destination Zone (A, B, C): X
 * Enter Weight: 5.0
 * Error creating package: Invalid destination zone: X. Must be A, B, or C.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 6
 * Invalid choice. Please try again.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: five
 * Invalid input. Please enter a number for the choice.
 * 
 * --- LogiFlow Package Hub Menu ---
 * ...
 * Enter choice: 5
 * Exiting LogiFlow Package Hub.
 * ```
 * 
 * Implement the `Package` and `LogiFlowHub` classes, along with a main method to run the system.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Correct and robust input validation and error handling.
 * *   Clear and well-structured code with appropriate comments.
 * *   Accurate implementation of the package flow logic.
 *
 * EXPLANATION:
 * This solution implements the LogiFlow Package Hub system, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Package` Class:** This class serves as a simple Plain Old Java Object (POJO) representing the data entity.
 *     *   **Encapsulation:** Fields (`packageId`, `destinationZone`, `weight`) are `private`, accessed only through public getter methods.
 *     *   **Input Validation:** The constructor includes explicit checks for invalid data (null/empty ID, invalid zone, negative weight) and throws `IllegalArgumentException`, preventing the creation of invalid `Package` objects.
 *     *   **`toString()`:** Provides a readable representation, useful for printing package details.
 * 
 * 2.  **`LogiFlowHub` Class:** This is the main class managing the system's logic and state.
 *     *   **`Queue<Package>`:** The `incomingPackages` field uses `java.util.Queue`, implemented by `java.util.LinkedList`. This correctly models the "waiting line" or "buffer" for packages needing processing, where packages are added to the end and removed from the front (FIFO - First-In, First-Out). Methods like `offer()` (add) and `poll()` (retrieve and remove) are used.
 *     *   **`List<Package>` and `ArrayList`:** The `zoneAProcessed`, `zoneBProcessed`, and `zoneCProcessed` fields are declared using the `java.util.List` interface but initialized with `java.util.ArrayList`. This demonstrates programming to an interface, which is a best practice. `ArrayList` is suitable here as we need dynamic arrays to store processed packages, allowing easy addition (`add()`) and iteration.
 *     *   **Methods:** The class contains well-defined methods (`addPackage`, `processNextPackage`, `viewIncomingQueue`, `viewProcessedPackages`, `start`, `printMenu`) that encapsulate specific pieces of functionality, improving code organization and readability.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   **`Scanner`:** Used in the `start()` method to read user input from `System.in`.
 *     *   **`while` loop:** Controls the main application lifecycle, keeping it running until the user chooses to exit.
 *     *   **`switch` statement:** Efficiently handles the selection of actions based on the user's numeric menu choice.
 * 
 * 4.  **Error Handling:**
 *     *   **`try-catch` (Class-wide):** The main `start()` method has a comprehensive `try-catch` block wrapping the core logic within the `while` loop and `switch` statement. This provides **class-wide exception handling** as required, catching exceptions that might occur during user input processing or method calls.
 *     *   **Specific Exception Handling:**
 *         *   `InputMismatchException`: Caught to handle cases where the user enters input that doesn't match the expected type (e.g., text when a number is expected). The `scanner.nextLine()` call within the catch block is crucial to consume the invalid input and prevent an infinite loop.
 *         *   `IllegalArgumentException`: Caught when the `Package` constructor throws this exception due to invalid package data provided by the user.
 *         *   `IllegalStateException`: Thrown by `processNextPackage()` when the incoming queue is empty, and caught in `start()` to inform the user that there are no packages to process. This demonstrates throwing and catching specific exceptions for anticipated error conditions.
 *         *   `Exception`: A general `catch (Exception e)` block is included as a fallback to catch any other unexpected runtime errors, printing a generic error message.
 *     *   **`System.err`:** All error messages (invalid input, validation errors, processing errors, unexpected errors) are directed to `System.err`, separating them from normal program output on `System.out`.
 *     *   **Input Validation (within methods):** `viewProcessedPackages` also includes basic validation for the zone input to ensure it's one of the expected values before attempting to access a list.
 * 
 * 5.  **Best Practices:**
 *     *   **Meaningful Names:** Classes, methods, and variables have names that clearly indicate their purpose (e.g., `incomingPackages`, `processNextPackage`, `destinationZone`).
 *     *   **Comments and Documentation:** Javadoc comments are used for classes and public methods, explaining their purpose, parameters, and potential exceptions. Inline comments clarify specific logic points.
 *     *   **Clean Structure:** The code is divided into logical classes and methods, making it easier to understand and maintain. The `start()` method orchestrates the main flow, while other methods handle specific tasks.
 *     *   **Resource Management:** The `Scanner` object is closed when the application exits to release system resources.
 * 
 * In summary, this solution effectively utilizes all required Java components within a practical scenario, demonstrating object-oriented design, proper handling of collections, robust input validation, and comprehensive exception handling using `try-catch` blocks and directing errors to `System.err`.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with an ID, destination zone, and weight.
 */
class Package {
    private String packageId;
    private String destinationZone; // Must be "A", "B", or "C"
    private double weight; // in kg

    /**
     * Constructs a new Package object.
     *
     * @param packageId       The unique identifier for the package.
     * @param destinationZone The target zone ("A", "B", or "C").
     * @param weight          The weight of the package.
     * @throws IllegalArgumentException if packageId is null/empty, zone is invalid, or weight is negative.
     */
    public Package(String packageId, String destinationZone, double weight) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destinationZone == null) {
             throw new IllegalArgumentException("Destination zone cannot be null.");
        }
        String upperZone = destinationZone.trim().toUpperCase();
        if (!upperZone.equals("A") && !upperZone.equals("B") && !upperZone.equals("C")) {
            throw new IllegalArgumentException("Invalid destination zone: " + destinationZone + ". Must be A, B, or C.");
        }
        if (weight < 0) {
            throw new IllegalArgumentException("Weight cannot be negative.");
        }

        this.packageId = packageId.trim();
        this.destinationZone = upperZone;
        this.weight = weight;
    }

    /**
     * Gets the package ID.
     * @return The package ID.
     */
    public String getPackageId() {
        return packageId;
    }

    /**
     * Gets the destination zone.
     * @return The destination zone ("A", "B", or "C").
     */
    public String getDestinationZone() {
        return destinationZone;
    }

    /**
     * Gets the weight of the package.
     * @return The weight in kg.
     */
    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the package.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Package [ID: " + packageId + ", Zone: " + destinationZone + ", Weight: " + weight + "kg]";
    }
}

/**
 * Manages the flow of packages through the LogiFlow hub.
 */
class LogiFlowHub {
    private Queue<Package> incomingPackages;
    private List<Package> zoneAProcessed;
    private List<Package> zoneBProcessed;
    private List<Package> zoneCProcessed;
    private Scanner scanner;

    /**
     * Constructs a new LogiFlowHub.
     */
    public LogiFlowHub() {
        incomingPackages = new LinkedList<>(); // LinkedList implements Queue
        zoneAProcessed = new ArrayList<>();
        zoneBProcessed = new ArrayList<>();
        zoneCProcessed = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a package to the incoming queue.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        incomingPackages.offer(pkg); // offer is generally preferred over add for queues
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves the package to the appropriate processed zone list.
     * @throws IllegalStateException if the incoming queue is empty.
     */
    public void processNextPackage() {
        Package pkg = incomingPackages.poll(); // Retrieves and removes the head of the queue

        if (pkg == null) {
            throw new IllegalStateException("Incoming queue is empty. No packages to process.");
        }

        String zone = pkg.getDestinationZone();
        switch (zone) {
            case "A":
                zoneAProcessed.add(pkg);
                break;
            case "B":
                zoneBProcessed.add(pkg);
                break;
            case "C":
                zoneCProcessed.add(pkg);
                break;
            // Default case should not be reached if Package constructor validates zone
            default:
                 // This is a fallback, ideally validation prevents this
                 System.err.println("Internal Error: Processed package has an invalid zone: " + zone);
                 // Optionally add to a reject list or re-queue
                 return; // Stop processing this package further
        }
        System.out.println("Package " + pkg.getPackageId() + " processed and moved to Zone " + zone + ".");
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    public void viewIncomingQueue() {
        System.out.println("--- Incoming Queue ---");
        if (incomingPackages.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterating over a queue without removing elements
            for (Package pkg : incomingPackages) {
                System.out.println(pkg);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all packages in the processed list for a specific zone.
     *
     * @param zone The zone to view ("A", "B", or "C", case-insensitive).
     */
    public void viewProcessedPackages(String zone) {
        if (zone == null) {
             System.err.println("Zone cannot be null.");
             return;
        }
        String upperZone = zone.trim().toUpperCase();
        List<Package> targetList = null;

        switch (upperZone) {
            case "A":
                targetList = zoneAProcessed;
                break;
            case "B":
                targetList = zoneBProcessed;
                break;
            case "C":
                targetList = zoneCProcessed;
                break;
            default:
                System.err.println("Invalid zone specified: " + zone + ". Please enter A, B, or C.");
                return; // Exit method if zone is invalid
        }

        System.out.println("--- Processed Packages (Zone " + upperZone + ") ---");
        if (targetList.isEmpty()) {
            System.out.println("No packages processed for Zone " + upperZone + " yet.");
        } else {
            for (Package pkg : targetList) {
                System.out.println(pkg);
            }
        }
        System.out.println("-------------------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- LogiFlow Package Hub Menu ---");
        System.out.println("1. Add Incoming Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Packages by Zone");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Starts the main application loop for user interaction.
     * Includes class-wide exception handling.
     */
    public void start() {
        boolean running = true;

        while (running) {
            printMenu();
            System.out.print("Enter choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1: // Add Package
                        System.out.print("Enter Package ID: ");
                        String id = scanner.nextLine();
                        System.out.print("Enter Destination Zone (A, B, C): ");
                        String zone = scanner.nextLine();
                        System.out.print("Enter Weight: ");
                        double weight = scanner.nextDouble();
                        scanner.nextLine(); // Consume the newline

                        try {
                            Package newPackage = new Package(id, zone, weight);
                            addPackage(newPackage);
                            System.out.println("Package " + id + " added to incoming queue.");
                        } catch (IllegalArgumentException e) {
                            // Catch specific validation errors from Package constructor
                            System.err.println("Error creating package: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Package
                        try {
                            processNextPackage();
                        } catch (IllegalStateException e) {
                             // Catch the specific exception thrown when queue is empty
                             System.err.println("Error processing package: " + e.getMessage());
                        }
                        break;

                    case 3: // View Incoming Queue
                        viewIncomingQueue();
                        break;

                    case 4: // View Processed Packages
                        System.out.print("Enter Zone to view (A, B, C): ");
                        String viewZone = scanner.nextLine();
                        viewProcessedPackages(viewZone);
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting LogiFlow Package Hub.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please try again.");
                }
            } catch (InputMismatchException e) {
                // Catch error if user enters non-integer for menu choice or non-double for weight
                System.err.println("Invalid input. Please enter the correct data type (e.g., a number for choice/weight).");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // For debugging, you might print e.printStackTrace();
            }
            System.out.println(); // Add a blank line for readability between operations
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Main method to start the LogiFlowHub application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        LogiFlowHub hub = new LogiFlowHub();
        hub.start();
    }
}
