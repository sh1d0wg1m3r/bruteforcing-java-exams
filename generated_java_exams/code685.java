/*
 * Exam Question #685
 * Generated on: 2025-05-12 16:25:33
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to simulate a task processing system. The system should manage tasks that are submitted, queued for processing, and then moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java application consisting of two main classes: `Task` and `TaskProcessor`.
 * 
 * 1.  **`Task` Class:**
 *     *   Represent a single task with:
 *         *   An integer `taskId` (must be positive).
 *         *   A String `description` (must not be null or empty).
 *     *   Implement proper encapsulation (private fields, public getters).
 *     *   Override `toString()` for easy printing.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manage the task flow using the following data structures:
 *         *   A `Queue<Task>` to hold tasks that are waiting to be processed (pending tasks). Use a suitable implementation like `LinkedList`.
 *         *   A `List<Task>` to hold tasks that have been processed (completed tasks). Use `ArrayList` as the implementation.
 *     *   Implement the following functionalities:
 *         *   `addTask(int taskId, String description)`: Validates the inputs and adds a new `Task` to the pending queue. Reports validation errors using `System.err`. Reports successful addition using `System.out`.
 *         *   `processNextTask()`: Takes the next task from the head of the pending queue, simulates processing (e.g., prints a message), and moves it to the completed tasks list. Reports the action using `System.out`. Handles the case where the queue is empty.
 *         *   `viewPendingTasks()`: Lists all tasks currently in the pending queue using `System.out`.
 *         *   `viewCompletedTasks()`: Lists all tasks that have been processed and are in the completed list using `System.out`.
 *     *   Implement a command-line interface using `java.util.Scanner` to interact with the user.
 *     *   Present a menu with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display the menu, prompts, and successful operation messages using `System.out`.
 *     *   Display all error conditions (e.g., invalid menu choice, invalid task input, unexpected issues) using `System.err`.
 *     *   Implement input validation for user input (e.g., ensuring menu choice is an integer within range, task ID is an integer).
 *     *   Include class-wide exception handling using a `try-catch` block around the main application loop in the `TaskProcessor` class to catch unexpected errors and report them using `System.err`. Ensure the `Scanner` is properly closed.
 *     *   Adhere to Java coding best practices, including meaningful variable/method names, comments where necessary, and clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should start, display a menu, and allow the user to interact by entering numbers corresponding to menu options. It should perform the requested actions, print results or status to `System.out`, and print errors or invalid input messages to `System.err`. The program should continue until the user chooses to exit.
 * 
 * Example interaction:
 * 
 * ```
 * Task Processing System Started.
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter Task ID (positive integer): 101
 * Enter Task Description: Implement Task Class
 * Task added: Task [ID=101, Description='Implement Task Class']
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter Task ID (positive integer): abc
 * Error: Invalid Task ID. Please enter an integer.
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter Task ID (positive integer): 102
 * Enter Task Description:
 * Error: Task description cannot be empty.
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Processing task: Task [ID=101, Description='Implement Task Class']
 * Task completed: 101
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * No tasks are pending.
 * ---------------------
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task [ID=101, Description='Implement Task Class']
 * -----------------------
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Processing System as required by the exam question. It demonstrates the use of several core Java concepts and collections.
 * 
 * 1.  **`Task` Class:** This is a basic Plain Old Java Object (POJO) representing a single task. It encapsulates a `taskId` (int) and a `description` (String) using private fields and public getter methods, adhering to encapsulation principles. The `toString()` method is overridden to provide a convenient string representation for printing. A basic check for positive ID and non-empty description is included in the constructor, although the primary validation happens in the `TaskProcessor`.
 * 
 * 2.  **`TaskProcessor` Class:** This is the main class that orchestrates the system logic.
 *     *   **Collections:**
 *         *   `pendingTasks`: Declared as a `Queue<Task>` and initialized with a `LinkedList`. The `Queue` interface is used because tasks are processed in a First-In, First-Out (FIFO) manner â€“ the task that has been pending the longest is processed next. `LinkedList` is a common implementation of `Queue`.
 *         *   `completedTasks`: Declared as a `List<Task>` and initialized with an `ArrayList`. The `List` interface is suitable for storing completed tasks where the order of completion might be relevant, and elements can be accessed or iterated over easily. `ArrayList` is a standard, dynamic array implementation of `List`.
 *     *   **`Scanner`:** A `java.util.Scanner` is used to read user input from the console (`System.in`). It's initialized in the constructor and closed in the `finally` block of the `run` method to release system resources.
 *     *   **`addTask` Method:** This method takes `taskId` and `description` as input. It performs validation checks using `if` statements. If validation fails, an error message is printed to `System.err`, and the method returns. If valid, a new `Task` object is created and added to the `pendingTasks` queue using `offer()`, which is the preferred method for adding to a queue as it handles capacity-restricted queues gracefully (though `LinkedList` is not capacity-restricted). A success message is printed to `System.out`.
 *     *   **`processNextTask` Method:** This method checks if the `pendingTasks` queue is empty. If so, it prints a message to `System.out` and returns `null`. If not empty, it uses `poll()` to retrieve and remove the task at the head of the queue. It simulates processing by printing to `System.out`, then adds the processed task to the `completedTasks` list, and prints a completion message.
 *     *   **`viewPendingTasks` and `viewCompletedTasks` Methods:** These methods iterate through the respective collections (`Queue` and `List`) and print the details of each task using `System.out`. They include checks for empty collections.
 *     *   **`printMenu` Method:** A helper method to display the menu options to the user using `System.out`.
 *     *   **`run` Method:** This is the main execution loop of the application.
 *         *   It runs in a `while(true)` loop controlled by a `running` flag.
 *         *   **Class-wide Exception Handling:** A large `try-catch(Exception e)` block is wrapped around the entire `while` loop body. This fulfills the requirement for class-wide exception handling by catching any unhandled exception that might occur during the program's execution within the loop. Error details are printed to `System.err`.
 *         *   **Input Handling and Validation:** Inside the loop, it prompts the user for input. It specifically checks `scanner.hasNextInt()` before calling `scanner.nextInt()` to prevent `InputMismatchException` if the user enters non-integer input for the menu choice or task ID. If invalid input is detected, an error is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and `continue` is used to restart the loop, prompting the user again. `scanner.nextLine()` is used after reading integers to consume the trailing newline character.
 *         *   **`switch` Statement:** A `switch` statement is used to direct the program flow based on the valid integer choice entered by the user. Each case calls the appropriate method (`addTask`, `processNextTask`, etc.) or sets the `running` flag to `false` for exiting. A `default` case handles valid integer inputs that do not correspond to a menu option, printing an error to `System.err`.
 *         *   **`finally` Block:** A `finally` block ensures that `scanner.close()` is called when the `try` block is exited, whether normally or due to an exception. This is crucial for releasing system resources.
 *     *   **`main` Method:** The entry point of the application. It creates an instance of `TaskProcessor` and calls its `run()` method to start the system.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design principles, input validation, and error handling techniques.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int taskId;
    private String description;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task. Must be positive.
     * @param description A brief description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if taskId is not positive or description is null/empty.
     */
    public Task(int taskId, String description) {
        // Basic validation in constructor, main validation handled in TaskProcessor.addTask
        if (taskId <= 0) {
            throw new IllegalArgumentException("Task ID must be positive.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.taskId = taskId;
        this.description = description.trim();
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string formatted as "Task [ID=..., Description='...']".
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Description='" + description + "']";
    }
}

/**
 * Manages the task processing system, including pending and completed tasks.
 */
public class TaskProcessor {
    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List for completed tasks (ordered collection)
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessor, initializing task queues and scanner.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue after validation.
     * @param taskId The ID of the task to add.
     * @param description The description of the task to add.
     */
    public void addTask(int taskId, String description) {
        // Input validation
        if (taskId <= 0) {
            System.err.println("Error: Task ID must be a positive integer.");
            return; // Exit method if validation fails
        }
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }

        try {
            Task newTask = new Task(taskId, description.trim());
            pendingTasks.offer(newTask); // offer is preferred over add for queues
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            // This catch block is technically redundant due to checks above,
            // but good practice if Task constructor had more complex validation.
            System.err.println("Error creating task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue and moves it to the completed list.
     * Reports status using System.out.
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process.");
            return null; // Indicate no task was processed
        }

        Task taskToProcess = pendingTasks.poll(); // Get and remove the head of the queue
        // Simulate processing
        System.out.println("Processing task: " + taskToProcess);
        completedTasks.add(taskToProcess); // Add to completed list
        System.out.println("Task completed: " + taskToProcess.getTaskId());
        return taskToProcess;
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are pending.");
        } else {
            // Iterate without removing using the enhanced for loop
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("\n--- Task Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Runs the main task processing system loop, handling user input and commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Task Processing System Started.");
        boolean running = true;

        // Class-wide exception handling around the main loop as required by the problem
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Initialize choice

                // Validate if the next input is an integer before reading
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Handle non-integer input for menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input (e.g., "abc") to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }
                scanner.nextLine(); // Consume the leftover newline character after reading the integer

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter Task ID (positive integer): ");
                        int taskId = -1;
                        // Validate if the next input for task ID is an integer
                        if (scanner.hasNextInt()) {
                            taskId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline after ID
                            System.out.print("Enter Task Description: ");
                            String description = scanner.nextLine();
                            addTask(taskId, description); // Call method to add task
                        } else {
                            // Handle non-integer input for task ID
                            System.err.println("Error: Invalid Task ID. Please enter an integer.");
                            scanner.next(); // Consume invalid input
                            scanner.nextLine(); // Consume potential remaining newline
                        }
                        break;
                    case 2: // Process Next Task
                        processNextTask(); // Call method to process task
                        break;
                    case 3: // View Pending Tasks
                        viewPendingTasks(); // Call method to view pending
                        break;
                    case 4: // View Completed Tasks
                        viewCompletedTasks(); // Call method to view completed
                        break;
                    case 5: // Exit
                        System.out.println("Exiting Task Processing System.");
                        running = false; // Set flag to exit loop
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the execution of the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor system = new TaskProcessor();
        system.run(); // Start the system's main loop
    }
}
