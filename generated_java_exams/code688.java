/*
 * Exam Question #688
 * Generated on: 2025-05-12 16:26:00
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Registration System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Event Registration System for a popular workshop with limited capacity. Attendees can register, and if the event is full, they are placed on a waiting list. The system should allow administrators to manually process the waiting list when spots become available, view attendee lists, and check an individual's registration status.
 * 
 * **Requirements:**
 * 
 * Implement a Java console application that simulates this system. Your solution must demonstrate advanced understanding of core Java concepts and adhere to best practices. Specifically, your code **must** utilize **ALL** of the following Java components:
 * 
 * 1.  `java.util.Queue` (used as an interface type)
 * 2.  `java.util.ArrayList` (used as an implementation type)
 * 3.  `java.util.List` (used as an interface type)
 * 4.  `java.util.Scanner` (for user input)
 * 5.  `switch` statement (for flow control)
 * 6.  `System.err` (for error messages)
 * 7.  `System.out` (for normal output)
 * 8.  Class-wide exception handling with `try-catch` blocks
 * 
 * **Technical Specifications:**
 * 
 * 1.  **`Event` Class:**
 *     *   Create a class named `Event` to represent the workshop.
 *     *   It must have private fields for:
 *         *   `name` (String)
 *         *   `capacity` (int)
 *         *   `registeredAttendees` (declared as `List<String>`, implemented as `ArrayList<String>`)
 *         *   `waitingList` (declared as `Queue<String>`, implemented as `LinkedList<String>`)
 *     *   Include a constructor to initialize the event with a name and capacity. Validate that capacity is positive.
 *     *   Implement the following public methods:
 *         *   `String registerAttendee(String attendeeName)`: Adds an attendee. If `registeredAttendees.size() < capacity`, add to `registeredAttendees`. Otherwise, add to `waitingList`. Ensure attendee names are not empty and are unique (check both lists). Return a status message (e.g., "Registered", "Added to Waiting List", "Already Registered", "Already on Waiting List", "Invalid Name").
 *         *   `int processWaitingList()`: Moves attendees from the head of the `waitingList` to `registeredAttendees` until the event reaches capacity or the `waitingList` is empty. Returns the number of attendees moved.
 *         *   `List<String> getRegisteredAttendees()`: Returns the list of registered attendees.
 *         *   `Queue<String> getWaitingList()`: Returns the waiting list.
 *         *   `String checkStatus(String attendeeName)`: Returns the status of a given attendee ("Registered", "On Waiting List", "Not Found", "Invalid Name").
 *         *   Include necessary getter methods for name and capacity.
 * 
 * 2.  **Main Class (`EventRegistrationSystem`):**
 *     *   Create a main class (e.g., `EventRegistrationSystem`) containing the `main` method.
 *     *   Inside `main`, initialize an `Event` object with a small capacity (e.g., 3) for testing purposes.
 *     *   Use `Scanner` to interact with the user via a console menu.
 *     *   The menu should offer the following options:
 *         1.  Register Attendee
 *         2.  Process Waiting List
 *         3.  View Registered Attendees
 *         4.  View Waiting List
 *         5.  Check Attendee Status
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement helper methods (e.g., `registerAttendee()`, `processWaitingList()`, etc.) within the main class to handle the logic for each menu option, interacting with the `Event` object.
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid attendee name input, system errors).
 *     *   Implement **class-wide** exception handling using a `try-catch` block in the `main` method to catch potential runtime errors (e.g., invalid input format from Scanner, unexpected issues) and report them using `System.err`. Handle specific exceptions like `InputMismatchException` for Scanner input gracefully.
 * 
 * **Best Practices:**
 * 
 * *   Employ proper encapsulation by making class fields private.
 * *   Use meaningful names for variables, methods, and classes.
 * *   Include appropriate comments and documentation (e.g., Javadoc).
 * *   Implement input validation (e.g., check for empty attendee names, positive capacity).
 * *   Handle errors gracefully and inform the user using the correct output stream (`System.out` vs `System.err`).
 * *   Maintain a clean and organized code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu, prompt for necessary input, and provide informative output for each operation. Examples:
 * 
 * *   **Register:** "Alice Registered successfully." or "Bob added to Waiting List (Event is full)." or "Charlie is already Registered." or "Invalid Name: Attendee name cannot be empty."
 * *   **Process Waiting List:** "Successfully moved 1 attendee(s) from waiting list to registered." or "No attendees were moved from the waiting list (either list is empty or event is full)."
 * *   **View Registered:** List attendees with numbers or "No attendees currently registered."
 * *   **View Waiting:** List attendees in order or "Waiting list is empty."
 * *   **Check Status:** "David is Registered." or "Eve is on the Waiting List." or "Frank not found in registered or waiting lists." or "Invalid Name: Attendee name cannot be empty."
 * *   **Invalid Menu Choice:** "Invalid choice. Please enter a number between 1 and 6." (to `System.err`)
 * *   **Invalid Scanner Input:** "Invalid input. Please enter a number." (to `System.err`)
 * *   **System Errors:** "An unexpected error occurred: ..." (to `System.err`)
 * 
 * Your solution should compile and run, allowing interactive testing of all features.
 *
 * EXPLANATION:
 * This solution implements the Event Registration System as described, incorporating all the required Java components and best practices.
 * 
 * **Code Structure:**
 * The solution is divided into two classes:
 * 1.  `Event` (in a package `com.example.event`): Encapsulates the data and core logic related to an event, such as managing the lists of attendees and handling registration/processing.
 * 2.  `EventRegistrationSystem`: Contains the `main` method and handles the user interface, menu display, input processing, and orchestrating calls to the `Event` object.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `waitingList` field in the `Event` class is declared as a `Queue<String>` interface type. This demonstrates programming to an interface.
 * 2.  **`java.util.ArrayList`:** The `registeredAttendees` field in the `Event` class is initialized using `new ArrayList<>()`.
 * 3.  **`java.util.List`:** The `registeredAttendees` field in the `Event` class is declared as a `List<String>` interface type. The `getRegisteredAttendees()` method also returns a `List<String>`.
 * 4.  **`java.util.Scanner`:** A `Scanner` object is created in the `main` method of `EventRegistrationSystem` to read user input from the console (`System.in`).
 * 5.  **`switch` statement:** A `switch` statement is used in the `main` method to handle the user's menu choice, directing execution to the appropriate handler method. Another `switch` is used in `checkAttendeeStatus` to process the returned status string.
 * 6.  **`System.err`:** Used in `EventRegistrationSystem` for printing error messages such as invalid menu input (`InputMismatchException` catch, default switch case), invalid attendee name input in `checkAttendeeStatus`, system initialization errors (`IllegalArgumentException` catch), unexpected scanner issues (`NoSuchElementException` catch), and any other general unexpected exceptions (`Exception` catch).
 * 7.  **`System.out`:** Used extensively in `EventRegistrationSystem` for displaying the welcome message, menu, prompts, successful registration/waiting list additions, results of waiting list processing, and the contents of the registered and waiting lists.
 * 8.  **Class-wide exception handling with `try-catch`:** A large `try-catch(Exception e)` block wraps the main logic (including the `while` loop) in the `main` method. This fulfills the requirement for class-wide handling. More specific `catch` blocks (`IllegalArgumentException`, `NoSuchElementException`) and handling within the loop (`InputMismatchException`) provide more granular error management where possible. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Core Logic:**
 * 
 * *   **Registration (`registerAttendee`)**: Checks for empty names and duplicates first. Then, it checks if the `registeredAttendees` list is full (`size() < capacity`). If not full, the attendee is added to the `registeredAttendees` list. Otherwise, they are added to the `waitingList` queue using `offer()`. Status messages are returned to the caller.
 * *   **Waiting List Processing (`processWaitingList`)**: Calculates available spots. It then enters a `while` loop that continues as long as there's space and the `waitingList` is not empty. Inside the loop, `waitingList.poll()` retrieves and removes the next attendee from the front of the queue (FIFO), and this attendee is added to the `registeredAttendees` list. The count of moved attendees is returned.
 * *   **Status Check (`checkStatus`)**: Checks for empty names. It then uses `contains()` on both `registeredAttendees` (List) and `waitingList` (Queue) to determine if the attendee is in either list or not found.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Private fields in the `Event` class protect its internal state. Public methods provide controlled access and modification.
 * *   **Meaningful Names:** Variable names (`registeredAttendees`, `waitingList`, `movedCount`, `availableSpace`), method names (`registerAttendee`, `processWaitingList`, `checkStatus`), and class names are descriptive.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes, constructors, and methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** Checks for null or empty attendee names are performed early in relevant methods (`registerAttendee`, `checkStatus`). The `Event` constructor validates capacity. The main loop handles non-integer menu input using `try-catch`.
 * *   **Error Handling:** Different types of errors (invalid input, system errors) are directed to `System.err`. Specific exceptions are caught where expected (`InputMismatchException`), and a general `Exception` catch provides robustness for unforeseen issues. Informational messages (like "already registered") are printed to `System.out`.
 * *   **Clean Structure:** The separation of concerns between the `Event` class (business logic) and `EventRegistrationSystem` (UI/interaction logic) makes the code modular and easier to understand. Private helper methods in the main class keep the `main` method clean.
 * 
 * This solution effectively demonstrates the required components in a practical scenario, highlighting key Java concepts like interfaces, collections, input/output, control flow, and exception handling.
 */

// File: com/example/event/Event.java
package com.example.event;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

/**
 * Represents an event with limited capacity and a waiting list.
 */
public class Event {
    private String name;
    private int capacity;
    private List<String> registeredAttendees; // Use List interface, implemented by ArrayList
    private Queue<String> waitingList;       // Use Queue interface, implemented by LinkedList

    /**
     * Constructs an Event object.
     * @param name The name of the event.
     * @param capacity The maximum number of registered attendees.
     * @throws IllegalArgumentException if capacity is non-positive.
     */
    public Event(String name, int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Event capacity must be positive.");
        }
        this.name = name;
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Implementation: ArrayList
        this.waitingList = new LinkedList<>();       // Implementation: LinkedList
    }

    /**
     * Registers an attendee for the event. Adds to registered list if space,
     * otherwise adds to the waiting list. Checks for duplicates and invalid names.
     * @param attendeeName The name of the attendee.
     * @return A status message indicating the result of the registration.
     */
    public String registerAttendee(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            return "Invalid Name: Attendee name cannot be empty.";
        }
        String cleanedName = attendeeName.trim();

        if (registeredAttendees.contains(cleanedName)) {
            return cleanedName + " is already Registered.";
        }
        if (waitingList.contains(cleanedName)) {
            return cleanedName + " is already on the Waiting List.";
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(cleanedName);
            return cleanedName + " Registered successfully.";
        } else {
            waitingList.offer(cleanedName); // offer is safer than add for queues
            return cleanedName + " added to Waiting List (Event is full).";
        }
    }

    /**
     * Processes the waiting list, moving attendees from the head of the queue
     * to the registered list until capacity is reached or the waiting list is empty.
     * @return The number of attendees moved from waiting to registered.
     */
    public int processWaitingList() {
        int movedCount = 0;
        int availableSpace = capacity - registeredAttendees.size();

        // Move attendees from waiting list as long as there is space and people waiting
        while (availableSpace > 0 && !waitingList.isEmpty()) {
            String attendee = waitingList.poll(); // Get and remove the head of the queue
            if (attendee != null) {
                 // Basic check if they somehow ended up registered while waiting - unlikely in single thread
                 if (!registeredAttendees.contains(attendee)) {
                     registeredAttendees.add(attendee);
                     movedCount++;
                     availableSpace--;
                 }
            }
        }
        return movedCount;
    }

    /**
     * Gets the list of registered attendees.
     * @return A List of registered attendee names.
     */
    public List<String> getRegisteredAttendees() {
        // Returning the internal list directly for simplicity in exam context.
        // In a real app, might return a defensive copy: new ArrayList<>(registeredAttendees);
        return registeredAttendees;
    }

    /**
     * Gets the list of attendees on the waiting list.
     * @return A Queue of waiting attendee names.
     */
    public Queue<String> getWaitingList() {
         // Returning the internal queue directly for simplicity in exam context.
        // In a real app, might return a defensive copy or an unmodifiable view.
        return waitingList;
    }

    /**
     * Checks the registration status of an attendee.
     * @param attendeeName The name of the attendee to check.
     * @return A status string ("Registered", "On Waiting List", "Not Found", "Invalid Name").
     */
    public String checkStatus(String attendeeName) {
         if (attendeeName == null || attendeeName.trim().isEmpty()) {
            return "Invalid Name";
        }
        String cleanedName = attendeeName.trim();

        if (registeredAttendees.contains(cleanedName)) {
            return "Registered";
        }
        if (waitingList.contains(cleanedName)) {
            return "On Waiting List";
        }
        return "Not Found";
    }

    // Getters for basic info
    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }
}
```

```java
// File: EventRegistrationSystem.java
// No package declaration for the main class for simpler compilation in some exam environments

import com.example.event.Event; // Import the Event class

import java.util.InputMismatchException;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // For potential scanner issues

/**
 * Main class for the Event Registration System.
 * Manages user interaction and orchestrates operations on the Event object.
 */
public class EventRegistrationSystem {

    private static Event event; // The event being managed
    private static Scanner scanner; // Scanner for user input

    public static void main(String[] args) {
        // Class-wide exception handling using a try-catch block
        try {
            // Initialize event and scanner
            // Using a small capacity (e.g., 3) to easily test waiting list
            event = new Event("Advanced Java Techniques Workshop", 3);
            scanner = new Scanner(System.in);

            System.out.println("--- Welcome to the " + event.getName() + " Registration System ---");
            System.out.println("Event Capacity: " + event.getCapacity());

            boolean running = true;
            while (running) {
                printMenu(); // Display menu

                System.out.print("Enter your choice: ");
                int choice = -1; // Default invalid choice

                // Handle potential InputMismatchException for scanner.nextInt()
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        registerAttendee(); // Handle attendee registration
                        break;
                    case 2:
                        processWaitingList(); // Handle processing the waiting list
                        break;
                    case 3:
                        viewRegisteredAttendees(); // View registered attendees
                        break;
                    case 4:
                        viewWaitingList(); // View waiting list
                        break;
                    case 5:
                        checkAttendeeStatus(); // Check attendee status
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Exit the main loop
                        break;
                    default:
                        // Handle invalid numeric choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }

        } catch (IllegalArgumentException e) {
            // Catch exceptions thrown during system initialization (e.g., invalid event capacity)
            System.err.println("System initialization error: " + e.getMessage());
        } catch (NoSuchElementException e) {
             // Catch exceptions related to Scanner if the input stream is closed unexpectedly
             System.err.println("Input stream closed unexpectedly. Exiting.");
             e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } finally {
            // Ensure the scanner is closed regardless of whether an exception occurred
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Register Attendee");
        System.out.println("2. Process Waiting List");
        System.out.println("3. View Registered Attendees");
        System.out.println("4. View Waiting List");
        System.out.println("5. Check Attendee Status");
        System.out.println("6. Exit");
        System.out.println("--------------------");
    }

    /**
     * Handles the attendee registration process based on user input.
     * Interacts with the Event object's registerAttendee method.
     */
    private static void registerAttendee() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim(); // Read the full line and trim whitespace

        // Call the event's registration method and get the status
        String status = event.registerAttendee(name);

        // Output the status message using System.out
        System.out.println(status);
    }

    /**
     * Handles processing the waiting list.
     * Interacts with the Event object's processWaitingList method.
     */
    private static void processWaitingList() {
        // Call the event's method to process the waiting list
        int movedCount = event.processWaitingList();

        // Output the result to System.out
        if (movedCount > 0) {
            System.out.println("Successfully moved " + movedCount + " attendee(s) from waiting list to registered.");
        } else {
            System.out.println("No attendees were moved from the waiting list (either list is empty or event is full).");
        }
    }

    /**
     * Handles viewing the list of registered attendees.
     * Interacts with the Event object's getRegisteredAttendees method.
     */
    private static void viewRegisteredAttendees() {
        // Get the list of registered attendees
        List<String> registered = event.getRegisteredAttendees();

        System.out.println("--- Registered Attendees (" + registered.size() + ") ---");
        // Check if the list is empty and print accordingly
        if (registered.isEmpty()) {
            System.out.println("No attendees currently registered.");
        } else {
            // Iterate and print each attendee using System.out
            for (int i = 0; i < registered.size(); i++) {
                System.out.println((i + 1) + ". " + registered.get(i));
            }
        }
    }

    /**
     * Handles viewing the waiting list.
     * Interacts with the Event object's getWaitingList method.
     */
    private static void viewWaitingList() {
        // Get the waiting list (Queue)
        Queue<String> waiting = event.getWaitingList();

        System.out.println("--- Waiting List (" + waiting.size() + ") ---");
        // Check if the queue is empty and print accordingly
         if (waiting.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate and print each attendee using System.out.
            // Using enhanced for loop or iterator is safe as it doesn't remove elements.
            int i = 1;
            for (String attendee : waiting) {
                 System.out.println(i++ + ". " + attendee);
            }
        }
    }

    /**
     * Handles checking the status of a specific attendee based on user input.
     * Interacts with the Event object's checkStatus method.
     */
    private static void checkAttendeeStatus() {
        System.out.print("Enter attendee name to check status: ");
        String name = scanner.nextLine().trim(); // Read the full line and trim whitespace

        // Call the event's method to check status
        String status = event.checkStatus(name);

        // Use a switch statement to output the status message to System.out or System.err
        switch (status) {
            case "Registered":
                System.out.println(name + " is Registered.");
                break;
            case "On Waiting List":
                System.out.println(name + " is on the Waiting List.");
                break;
            case "Not Found":
                System.out.println(name + " not found in registered or waiting lists.");
                break;
            case "Invalid Name":
                 // Output invalid input message to System.err as it's an input error
                 System.err.println("Invalid Name: Attendee name cannot be empty.");
                 break;
            default:
                // Fallback for any unexpected status strings
                System.err.println("An unexpected status was returned: " + status);
        }
    }
}
