/*
 * Exam Question #1143
 * Generated on: 2025-05-12 17:30:48
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: IT Support Ticket System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line IT Support Ticket System. The system should allow users to submit new support tickets, process the oldest pending ticket, and view the current list of pending tickets as well as the history of processed tickets. This task requires you to demonstrate your understanding of core Java collections, user input handling, control flow, and robust error management.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tickets that are pending processing. Tickets must be processed in a First-In, First-Out (FIFO) manner. Choose an appropriate implementation class for the `Queue`.
 *     *   Use a `java.util.List` (specifically, instantiate using `java.util.ArrayList`) to store tickets that have been processed.
 * 2.  **Ticket Representation:**
 *     *   Create a simple `Ticket` class with **private** fields for `id` (an integer, automatically generated starting from 1) and `description` (a String). Include appropriate **public** getter methods for these fields. You may also add a status field if desired.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands and ticket details from the console.
 *     *   Implement a menu-driven interface displayed to the user, offering the following options:
 *         *   Submit New Ticket
 *         *   Process Next Ticket
 *         *   View Pending Tickets Queue
 *         *   View Processed Tickets History
 *         *   Exit
 *     *   Use a `switch` statement to handle the different user menu selections.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and the contents of ticket lists/queues.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, attempting to process an empty queue, submitting a ticket with an empty description).
 * 5.  **Error Handling:**
 *     *   Implement input validation where necessary (e.g., ensuring a ticket description is not empty before submitting).
 *     *   Gracefully handle the scenario where the user attempts to process a ticket when the pending queue is empty, reporting the error via `System.err`.
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main application loop or the core method processing user commands. This catch block should handle potential unexpected runtime errors and report them using `System.err`.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) within your classes.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include basic comments explaining the purpose of your classes and key methods.
 *     *   Structure your code logically, potentially using a main class (e.g., `SupportSystem`) to manage the data structures and operations, separate from the `Ticket` data class.
 * 
 * **Expected Behavior:**
 * 
 * *   Submitting a ticket adds it to the end of the pending queue with a unique, incrementing ID.
 * *   Processing a ticket removes the one at the front of the pending queue and moves it to the processed history list.
 * *   Viewing the pending queue displays the tickets in the order they will be processed without removing them.
 * *   Viewing the history displays the tickets that have been processed.
 * *   Trying to process an empty queue prints an error to `System.err`.
 * *   Providing an invalid menu choice prints an error to `System.err`.
 * *   Any unexpected exceptions during the main execution flow are caught and reported via `System.err`.
 * 
 * Solve this problem by writing the complete Java code for the `Ticket` class and the main class (e.g., `SupportSystem`) that contains the `main` method and the system logic.
 *
 * EXPLANATION:
 * This solution implements a simplified IT Support Ticket System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The solution is organized into two classes:
 *     *   `Ticket`: A simple Plain Old Java Object (POJO) class representing a support ticket. It encapsulates the ticket's `id`, `description`, and `status` using private fields and provides public getter methods, adhering to encapsulation principles. The `toString()` method is overridden for easy printing of ticket details.
 *     *   `SupportSystem`: This is the main class containing the application logic. It manages the collections of tickets and handles user interaction.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `pendingTickets`: Declared as `Queue<Ticket>` and instantiated as `LinkedList<Ticket>`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing FIFO behavior required for processing tickets in submission order. Methods like `offer()` (for adding) and `poll()` (for removing from the head) are used.
 *     *   `processedTickets`: Declared as `List<Ticket>` and instantiated as `ArrayList<Ticket>`. `ArrayList` is suitable for storing the history as it provides efficient random access and dynamic resizing, and we primarily iterate over it or add to the end. The variable is declared using the `List` interface, promoting good practice of coding to interfaces.
 * 
 * 3.  **User Interface (`Scanner`, `switch`):**
 *     *   A `Scanner` object is used in the `SupportSystem` class to read input from `System.in`.
 *     *   The `run()` method contains the main application loop. Inside this loop, `displayMenu()` shows the options, and `scanner.nextLine()` reads the user's choice.
 *     *   A `switch` statement is used to control the program flow based on the user's input string, directing execution to the appropriate method (`submitTicket`, `processNextTicket`, `viewQueue`, `viewHistory`) or exiting the loop.
 * 
 * 4.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard output, including displaying the menu, prompts, confirmation messages (e.g., ticket submitted/processed successfully), and the formatted lists of tickets.
 *     *   `System.err.println()` is used specifically for error messages, such as indicating an invalid menu choice, an empty ticket description, or attempting to process a ticket when the queue is empty. This directs error output to the standard error stream, which is a common practice.
 * 
 * 5.  **Error Handling (`try-catch`, Validation):**
 *     *   **Input Validation:** The `submitTicket()` method checks if the provided description is null or empty using `trim().isEmpty()`. If invalid, it prints an error to `System.err` and returns `false`.
 *     *   **Operational Error Handling:** The `processNextTicket()` method uses `pendingTickets.poll()`, which returns `null` if the queue is empty. The code explicitly checks for this `null` return value and prints an informative error message to `System.err` if there are no tickets to process.
 *     *   **Class-wide Exception Handling:** The core `run()` method, which contains the main application loop, is wrapped in a `try-catch (Exception e)` block. This demonstrates a class-wide approach to catching unexpected runtime errors that might occur during the system's operation (e.g., issues with the scanner, although less likely with `nextLine()`, or unforeseen errors in logic). The `catch` block prints a general error message and the exception details, including the stack trace, to `System.err` for debugging purposes. The `finally` block ensures that the `Scanner` resource is closed properly, preventing resource leaks.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is applied in the `Ticket` class and by keeping the collection fields and ticket ID counter private in `SupportSystem`.
 *     *   Meaningful names like `pendingTickets`, `processNextTicket`, `viewHistory`, etc., are used throughout the code.
 *     *   Basic comments explain the purpose of classes and key methods.
 *     *   The code is structured logically with separate methods for different operations (`submitTicket`, `processNextTicket`, `viewQueue`, `viewHistory`, `displayMenu`, `run`). The `main` method serves as a simple entry point.
 *     *   The `getPendingTickets()` method demonstrates how to access elements of a `Queue` for display without removing them, using an `Iterator` and copying elements into a new `ArrayList` which is returned as a `List`. This prevents external code from accidentally modifying the queue's state.
 * 
 * This solution effectively integrates the required Java components into a functional system while demonstrating good programming practices and error handling techniques suitable for an advanced Java programming exam.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList; // Required implementation for List
import java.util.Scanner;
import java.util.Iterator; // Useful for viewing Queue contents

/**
 * Represents a single support ticket.
 * Demonstrates encapsulation.
 */
class Ticket {
    private int id;
    private String description;
    private String status;

    /**
     * Constructs a new Ticket.
     * @param id The unique ID for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // Public getter methods
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Allows updating the ticket status.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a user-friendly string representation of the Ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the IT Support Ticket System operations.
 * Contains the main logic, data structures, and user interaction.
 * Demonstrates Queue, List, ArrayList, Scanner, switch, System.out, System.err, try-catch.
 */
public class SupportSystem { // Renamed to public class for standard Java file structure
    // Private fields for data structures and system state
    private Queue<Ticket> pendingTickets;
    private List<Ticket> processedTickets; // Declared as List, implemented as ArrayList
    private int nextTicketId;
    private Scanner scanner;

    /**
     * Constructs a new SupportSystem, initializing collections and scanner.
     */
    public SupportSystem() {
        // Initialize Queue using LinkedList implementation for FIFO
        pendingTickets = new LinkedList<>();
        // Initialize List using ArrayList implementation
        processedTickets = new ArrayList<>();
        nextTicketId = 1; // Start ticket IDs from 1
        scanner = new Scanner(System.in); // Initialize Scanner for user input
    }

    /**
     * Submits a new ticket to the pending queue.
     * @param description The description provided by the user.
     * @return true if submission was successful, false otherwise.
     */
    public boolean submitTicket(String description) {
        // Input validation: Check if description is null or empty
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return false;
        }

        // Create new ticket with auto-incrementing ID
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        // Add ticket to the end of the pending queue (FIFO)
        pendingTickets.offer(newTicket); // offer() is generally preferred over add() for capacity-constrained queues

        System.out.println("Ticket submitted successfully: " + newTicket);
        return true;
    }

    /**
     * Processes the next ticket from the pending queue.
     * Moves the ticket to the processed history list.
     * @return The processed Ticket object, or null if the queue was empty.
     */
    public Ticket processNextTicket() {
        // Retrieve and remove the head of the queue (FIFO)
        Ticket ticketToProcess = pendingTickets.poll(); // poll() returns null if queue is empty

        // Handle case where the queue is empty
        if (ticketToProcess == null) {
            System.err.println("Error: No pending tickets to process."); // Use System.err for error
            return null;
        }

        // Update ticket status and add to processed history list
        ticketToProcess.setStatus("Processed");
        processedTickets.add(ticketToProcess);

        System.out.println("Ticket processed: " + ticketToProcess); // Use System.out for success message
        return ticketToProcess;
    }

    /**
     * Returns a List view of the pending tickets queue without removing them.
     * Useful for displaying the queue contents.
     * @return A List containing the pending tickets.
     */
    public List<Ticket> getPendingTickets() {
        // Create a new list to hold pending tickets for display
        List<Ticket> pendingList = new ArrayList<>();
        // Iterate through the queue using an Iterator to avoid modifying it
        Iterator<Ticket> iterator = pendingTickets.iterator();
        while (iterator.hasNext()) {
            pendingList.add(iterator.next());
        }
        return pendingList; // Return the List interface type
    }

    /**
     * Returns the list of processed tickets.
     * @return The List containing the processed tickets history.
     */
    public List<Ticket> getProcessedTickets() {
        return processedTickets; // Return the List interface type
    }

    /**
     * Displays the main menu options to the user.
     * Uses System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- IT Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets Queue");
        System.out.println("4. View Processed Tickets History");
        System.out.println("5. Exit");
        System.out.println("-------------------------------------");
    }

    /**
     * Displays the contents of the pending tickets queue.
     * Uses System.out.
     */
    private void viewQueue() {
        List<Ticket> pending = getPendingTickets(); // Get tickets using the List-returning method
        if (pending.isEmpty()) {
            System.out.println("Pending tickets queue is empty.");
        } else {
            System.out.println("--- Pending Tickets Queue ---");
            for (Ticket ticket : pending) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
            System.out.println("-----------------------------");
        }
    }

    /**
     * Displays the contents of the processed tickets history list.
     * Uses System.out.
     */
    private void viewHistory() {
        List<Ticket> history = getProcessedTickets(); // Get tickets using the List-returning method
        if (history.isEmpty()) {
            System.out.println("Processed tickets history is empty.");
        } else {
            System.out.println("--- Processed Tickets History ---");
            for (Ticket ticket : history) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
            System.out.println("---------------------------------");
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling using try-catch.
     */
    public void run() {
        System.out.println("Welcome to the IT Support Ticket System!");

        // Class-wide exception handling for the main application loop
        try {
            boolean running = true;
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");
                String input = scanner.nextLine(); // Read user input

                // Use switch statement for flow control based on input
                switch (input.trim()) {
                    case "1":
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        submitTicket(description); // Call method to submit ticket
                        break;
                    case "2":
                        processNextTicket(); // Call method to process ticket
                        break;
                    case "3":
                        viewQueue(); // Call method to view pending queue
                        break;
                    case "4":
                        viewHistory(); // Call method to view history
                        break;
                    case "5":
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Use System.err for invalid input errors
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("\nAn unexpected system error occurred:"); // Use System.err
            System.err.println("Error details: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Main method - the entry point of the application.
     * Creates a SupportSystem instance and starts the application loop.
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run(); // Start the system's main loop
    }
}
