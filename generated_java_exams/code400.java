/*
 * Exam Question #400
 * Generated on: 2025-05-11 23:05:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Assembly Line Simulation
 * 
 * **Objective:** Design and implement a simple console-based simulation of a manufacturing assembly line using core Java data structures and control flow mechanisms.
 * 
 * **Scenario:** You are tasked with creating a program that simulates a basic assembly line. Parts arrive and are placed in a waiting area before being processed one by one at a single workstation. The program should allow users to add new parts, process the next part in line, view the parts currently waiting, and see a history of all processed parts.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the waiting area for parts. Parts should be processed in the order they arrive (FIFO).
 *     *   Use a `java.util.ArrayList` to store the history of parts that have been successfully processed.
 *     *   Ensure that the history list is declared using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement a menu-driven interface with commands for:
 *         *   Adding a new part to the waiting queue.
 *         *   Processing the next part from the waiting queue.
 *         *   Viewing the parts currently waiting in the queue.
 *         *   Viewing the history of processed parts.
 *         *   Exiting the simulation.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Implement a loop to keep the simulation running until the user chooses to exit.
 * 
 * 4.  **Input/Output & Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and list contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, trying to process from an empty queue, invalid input).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues during command execution or input processing. Include specific checks for common errors like trying to process from an empty queue.
 *     *   Implement basic input validation, such as ensuring a part name is not empty when adding a part.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation: Declare fields as private and provide public methods for interaction.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for the class and methods).
 *     *   Structure the code cleanly with separate methods for different actions (adding, processing, viewing, displaying menu).
 * 
 * **Part Representation:** For simplicity, a part can be represented by a `String` (e.g., "Widget A", "Component B").
 * 
 * **Expected Output:**
 * The program should display a menu, prompt for input, and show appropriate messages for each action.
 * *   Adding a part: Confirm the part was added.
 * *   Processing: Confirm which part was processed or indicate if the queue was empty (error).
 * *   Viewing waiting: List parts in the queue or state it's empty.
 * *   Viewing history: List processed parts or state history is empty.
 * *   Invalid command: Print an error message to `System.err`.
 * *   Empty input (e.g., empty part name): Print an error message to `System.err`.
 * *   Unexpected error: Print a general error message from the `try-catch` block to `System.err`.
 * *   Quitting: Print an exit message.
 * 
 * **Deliverables:**
 * Provide the complete Java code for the `AssemblyLineSimulation` class.
 *
 * EXPLANATION:
 * The provided Java code implements a simple assembly line simulation, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `waitingParts`: Declared as `Queue<String>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for a waiting line. The `offer()` method is used for adding parts, and `poll()` is used for removing/retrieving the head of the queue.
 *     *   `processedParts`: Declared as `List<String>` and initialized with `new ArrayList<>()`. This stores the history of processed parts. `ArrayList` provides dynamic resizing and efficient element access by index, suitable for maintaining a historical list.
 *     *   `List` Interface: The `processedParts` field is explicitly typed as `List<String>`, demonstrating the use of the interface rather than the concrete implementation (`ArrayList`) where appropriate. Additionally, in `viewWaitingParts`, a temporary `List<String>` (`currentWaitingList`) is created from the queue using `new ArrayList<>(waitingParts)` to facilitate displaying the queue contents without altering the queue itself, further demonstrating the use of both `List` and `ArrayList`.
 * 
 * 2.  **User Interaction (`Scanner`, `switch`):**
 *     *   A `Scanner` object is initialized to read input from `System.in`.
 *     *   The `runSimulation` method contains a `while` loop that continues until the `running` flag is set to `false`.
 *     *   Inside the loop, the program displays a menu and reads the user's command using `scanner.nextLine()`.
 *     *   A `switch` statement is used to direct the program flow based on the first character of the user's command (`'a'`, `'p'`, `'w'`, `'h'`, `'q'`).
 * 
 * 3.  **Input/Output & Error Handling (`System.out`, `System.err`, `try-catch`):**
 *     *   `System.out.println` and `System.out.print` are used for all standard output, including the menu, prompts, and successful action messages.
 *     *   `System.err.println` is used specifically for printing error messages, such as invalid commands, attempting to process an empty queue, or providing an empty part name. This separates normal program output from error information.
 *     *   A `try-catch(Exception e)` block is wrapped around the main command processing logic within the `runSimulation` loop. This provides a general, class-wide exception handler that catches any unexpected `Exception` that might occur during command execution or input processing, printing an error message to `System.err`. More specific error handling is done within individual methods (e.g., checking for `null` after `waitingParts.poll()`, checking for empty strings).
 *     *   Input validation is performed in the `addPart` method to ensure the user provides a non-empty part name. An error message is printed to `System.err` if validation fails.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** The data fields (`waitingParts`, `processedParts`, `scanner`) are declared as `private`. Access and modification are controlled through public or private methods (`addPart`, `processNextPart`, etc.).
 *     *   **Meaningful Names:** Variables (`waitingParts`, `processedParts`, `commandInput`, `partName`) and methods (`runSimulation`, `displayMenu`, `addPart`, `processNextPart`, `viewWaitingParts`, `viewProcessedParts`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc-style comments are used for the class and methods to explain their functionality. Inline comments clarify specific parts of the code.
 *     *   **Clean Structure:** The code is divided into small, focused methods, each responsible for a single logical task (displaying the menu, adding a part, processing a part, viewing lists). The `runSimulation` method acts as the main orchestrator.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, simulated scenario, incorporating best practices for code organization and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Simulates a simple assembly line with a waiting queue and processed parts history.
 * Demonstrates the use of Queue, List, ArrayList, Scanner, switch, System.out/err,
 * and try-catch for exception handling.
 */
public class AssemblyLineSimulation {

    private Queue<String> waitingParts;
    private List<String> processedParts;
    private Scanner scanner;

    /**
     * Constructs an AssemblyLineSimulation, initializing the data structures and scanner.
     */
    public AssemblyLineSimulation() {
        // Use LinkedList to implement the Queue interface for the waiting line (FIFO)
        waitingParts = new LinkedList<>();
        // Use ArrayList to implement the List interface for the processed history
        processedParts = new ArrayList<>();
        // Initialize scanner for user input
        scanner = new Scanner(System.in);
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulation simulation = new AssemblyLineSimulation();
        simulation.runSimulation();
    }

    /**
     * Runs the main simulation loop, handling user input and commands.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        System.out.println("--- Simple Assembly Line Simulation ---");
        boolean running = true;

        while (running) {
            try {
                displayMenu();
                System.out.print("Enter command: ");
                // Read the entire line to avoid issues with nextInt/nextLine mix
                String commandInput = scanner.nextLine().trim().toLowerCase();

                // Input validation for empty command
                if (commandInput.isEmpty()) {
                    System.err.println("Error: Command cannot be empty. Please try again.");
                    continue; // Skip the rest of the loop iteration
                }

                // Use the first character as the command
                char command = commandInput.charAt(0);

                // Use a switch statement to handle different commands
                switch (command) {
                    case 'a': // Add part
                        addPart();
                        break;
                    case 'p': // Process next part
                        processNextPart();
                        break;
                    case 'w': // View waiting parts
                        viewWaitingParts();
                        break;
                    case 'h': // View processed history
                        viewProcessedParts();
                        break;
                    case 'q': // Quit
                        System.out.println("Exiting simulation. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default: // Invalid command
                        System.err.println("Error: Invalid command '" + commandInput + "'. Please enter a command from the menu.");
                }
            } catch (Exception e) {
                // General catch block for unexpected exceptions during the loop execution
                System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
                // For debugging, you might print the stack trace:
                // e.printStackTrace();
            } finally {
                 // Add a newline for better readability between command outputs,
                 // ensuring it runs even if an exception occurs.
                 System.out.println();
            }
        }

        // Close the scanner resource when the simulation ends
        scanner.close();
        System.out.println("Simulation ended.");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\nAvailable Commands:");
        System.out.println("  a - Add new part to waiting queue");
        System.out.println("  p - Process the next part from the queue");
        System.out.println("  w - View waiting parts");
        System.out.println("  h - View processed parts history");
        System.out.println("  q - Quit simulation");
    }

    /**
     * Prompts the user for a part name and adds it to the waiting queue.
     * Includes input validation.
     */
    private void addPart() {
        System.out.print("Enter part name to add: ");
        String partName = scanner.nextLine().trim(); // Read part name

        // Input validation: check if the part name is empty
        if (partName.isEmpty()) {
            System.err.println("Error: Part name cannot be empty. Part not added.");
            return; // Exit method if input is invalid
        }

        // Add the part to the end of the waiting queue
        waitingParts.offer(partName); // offer() is generally preferred for queues as it returns false on failure, doesn't throw exception
        System.out.println("Success: Part '" + partName + "' added to the waiting queue.");
    }

    /**
     * Processes the next part from the waiting queue (FIFO).
     * Removes the part from the queue and adds it to the processed history.
     * Handles the case where the queue is empty.
     */
    private void processNextPart() {
        // Retrieve and remove the head of the queue. poll() returns null if queue is empty.
        String processedPart = waitingParts.poll();

        // Check if a part was successfully retrieved
        if (processedPart == null) {
            System.err.println("Error: No parts waiting in the queue to process.");
        } else {
            // Add the processed part to the history list
            processedParts.add(processedPart);
            System.out.println("Success: Processed part '" + processedPart + "'. Moved to history.");
        }
    }

    /**
     * Displays the parts currently waiting in the queue without removing them.
     */
    private void viewWaitingParts() {
        System.out.println("--- Current Waiting Parts Queue ---");
        // Check if the queue is empty
        if (waitingParts.isEmpty()) {
            System.out.println("  The waiting queue is empty.");
        } else {
            // Iterate through the queue elements for display.
            // Converting to a List is one way to easily display numbered items.
            // Alternatively, System.out.println(waitingParts); often works for simple types.
            List<String> currentWaitingList = new ArrayList<>(waitingParts); // Use ArrayList and List interface for display
            for (int i = 0; i < currentWaitingList.size(); i++) {
                 System.out.println("  " + (i + 1) + ". " + currentWaitingList.get(i));
            }
        }
        System.out.println("-----------------------------------");
    }

    /**
     * Displays the history of all parts that have been processed.
     */
    private void viewProcessedParts() {
        System.out.println("--- Processed Parts History ---");
        // Check if the history list is empty
        if (processedParts.isEmpty()) {
            System.out.println("  No parts have been processed yet.");
        } else {
            // Iterate through the history list and print each item
            for (int i = 0; i < processedParts.size(); i++) {
                System.out.println("  " + (i + 1) + ". " + processedParts.get(i));
            }
        }
        System.out.println("-----------------------------");
    }
}
