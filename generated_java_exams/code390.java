/*
 * Exam Question #390
 * Generated on: 2025-05-11 23:04:00
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Management Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation system for managing tasks on a production line. Tasks arrive, are placed in a queue, and are processed by workers. The system needs to track tasks, allow adding new tasks, simulate processing the next task in line, and display the current state of the queue and a history of processed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `ProductionTask` to represent a single task. It should have:
 *     *   A unique integer ID.
 *     *   A `TaskType` (enum: e.g., `ASSEMBLY`, `TESTING`, `PACKAGING`).
 *     *   A description (String).
 *     *   A `TaskStatus` (enum: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Appropriate constructor, getters, and a `toString()` method for easy display.
 *     *   Encapsulate fields (make them private).
 * 
 * 2.  **Simulator Class:** Create a main class `ProductionLineSimulator` that contains the simulation logic. It should manage:
 *     *   A queue of tasks that are waiting to be processed (`Queue<ProductionTask>`).
 *     *   A list of tasks that have been processed (either completed or failed) (`List<ProductionTask>`).
 *     *   A counter for generating unique task IDs.
 * 
 * 3.  **Functionality:** The simulator should provide a command-line interface via a menu:
 *     *   **Add Task:** Prompt the user for task type and description, create a `ProductionTask` with `PENDING` status, and add it to the queue.
 *     *   **Process Next Task:** Take the next task from the front of the queue. Simulate processing (you can just change its status to `COMPLETED` or `FAILED` based on a simple condition or randomly, and print a message). Move the processed task from the queue to the history list. Handle the case where the queue is empty.
 *     *   **View Queue:** Display the details of all tasks currently in the queue, in order.
 *     *   **View History:** Display the details of all tasks in the history list.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Required Java Components:** Your solution *must* use the following Java components:
 *     *   `java.util.Queue` (use a concrete implementation like `java.util.LinkedList`)
 *     *   `java.util.ArrayList` (for the history list)
 *     *   `java.util.List` interface (declare the history list variable using the `List` interface type)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for handling menu choices)
 *     *   `System.err` (for displaying error messages only)
 *     *   `System.out` (for displaying all normal output, including menus, prompts, task details, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., wrap the main simulation loop or critical sections to catch unexpected errors).
 * 
 * 5.  **Best Practices:** Implement the solution following best practices:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs for classes/methods where helpful).
 *     *   Input validation (e.g., validate menu choices, task types).
 *     *   Proper error handling (using `try-catch` and `System.err`).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, respond to user commands, print task details, queue contents, and history contents to `System.out`, and print error messages to `System.err`.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * Production Line Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Queue
 * 4. View History
 * 5. Exit
 * Enter your choice: 1
 * Enter task type (ASSEMBLY, TESTING, PACKAGING): ASSEMBLY
 * Enter task description: Assemble Product X
 * Task 1 (ASSEMBLY) added to queue.
 * 
 * Enter your choice: 1
 * Enter task type (TESTING, PACKAGING, ASSEMBLY): TESTING
 * Enter task description: Test Product X
 * Task 2 (TESTING) added to queue.
 * 
 * Enter your choice: 3
 * Current Task Queue:
 * Task ID: 1, Type: ASSEMBLY, Description: Assemble Product X, Status: PENDING
 * Task ID: 2, Type: TESTING, Description: Test Product X, Status: PENDING
 * 
 * Enter your choice: 2
 * Processing task 1 (ASSEMBLY)... Status updated to COMPLETED.
 * Task 1 moved to history.
 * 
 * Enter your choice: 3
 * Current Task Queue:
 * Task ID: 2, Type: TESTING, Description: Test Product X, Status: PENDING
 * 
 * Enter your choice: 4
 * Task History:
 * Task ID: 1, Type: ASSEMBLY, Description: Assemble Product X, Status: COMPLETED
 * 
 * Enter your choice: 2
 * Processing task 2 (TESTING)... Status updated to COMPLETED.
 * Task 2 moved to history.
 * 
 * Enter your choice: 3
 * Current Task Queue:
 * (Queue is empty)
 * 
 * Enter your choice: 4
 * Task History:
 * Task ID: 1, Type: ASSEMBLY, Description: Assemble Product X, Status: COMPLETED
 * Task ID: 2, Type: TESTING, Description: Test Product X, Status: COMPLETED
 * 
 * Enter your choice: 2
 * Error: The task queue is empty. No task to process. (Printed to System.err)
 * 
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. (Printed to System.err)
 * 
 * Enter your choice: 5
 * Exiting simulator.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes and the main method.
 *
 * EXPLANATION:
 * This solution implements a `ProductionLineSimulator` that manages tasks using a queue and a history list, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`ProductionTask` Class:**
 *     *   Represents individual tasks with `id`, `type`, `description`, and `status`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides public getter methods.
 *     *   Includes a setter for `status` to allow updating it during processing.
 *     *   The `toString()` method provides a convenient way to display task information.
 *     *   Uses `TaskType` and `TaskStatus` enums for clear and type-safe representation of task attributes.
 * 
 * 2.  **`ProductionLineSimulator` Class:**
 *     *   **Data Structures:**
 *         *   `taskQueue`: Declared as `Queue<ProductionTask>` and instantiated as `LinkedList<ProductionTask>`. This adheres to the requirement of using `Queue` and demonstrates using a concrete implementation. `LinkedList` is suitable as it provides efficient addition (`offer`) and removal (`poll`) from the ends, typical queue operations.
 *         *   `taskHistory`: Declared as `List<ProductionTask>` and instantiated as `ArrayList<ProductionTask>`. This meets the requirement of using both the `List` interface and `ArrayList`. `ArrayList` is suitable for storing a growing history where elements are typically added to the end and iterated over.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read user input from `System.in`.
 *     *   **`nextTaskId`:** An integer counter ensures each task gets a unique ID.
 *     *   **Encapsulation:** All data fields (`taskQueue`, `taskHistory`, `scanner`, `nextTaskId`) are private.
 *     *   **Methods:**
 *         *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *         *   `addTask()`: Reads task type and description from the user. It includes input validation to check if the entered task type matches an enum constant using `TaskType.valueOf()` within a `try-catch` block to handle `IllegalArgumentException`. It also checks for an empty description. A new `ProductionTask` is created with `PENDING` status and added to the `taskQueue` using `offer()`.
 *         *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the task at the head of the queue. It checks if the result is `null` (meaning the queue was empty) and prints an error message to `System.err`. If a task is retrieved, its status is updated (simulating processing), and it's added to the `taskHistory` list using `add()`.
 *         *   `viewQueue()`: Iterates through the `taskQueue` (using an enhanced for loop, which doesn't remove elements) and prints each task's details to `System.out`. It checks if the queue is empty.
 *         *   `viewHistory()`: Iterates through the `taskHistory` list and prints each task's details to `System.out`. It checks if the history is empty.
 *         *   `run()`: This is the main loop of the simulator. It repeatedly displays the menu, reads user input, and uses a `switch` statement to execute the corresponding action (`addTask`, `processNextTask`, `viewQueue`, `viewHistory`, or `Exit`).
 *     *   **`switch` Statement:** Used in the `run()` method to control the flow based on the user's menu choice.
 *     *   **`System.out` and `System.err`:** `System.out` is used for all standard output (menu, prompts, task details, success messages). `System.err` is used exclusively for error messages (invalid menu choice, empty queue, invalid task type, empty description, invalid input type for choice).
 *     *   **Input Validation & Error Handling:**
 *         *   Menu choice input uses a `try-catch (InputMismatchException)` block around `scanner.nextInt()` to handle non-integer input gracefully, preventing a crash and informing the user via `System.err`. `scanner.nextLine()` is used to consume the invalid input and the trailing newline after reading the integer choice.
 *         *   Task type input uses a `try-catch (IllegalArgumentException)` block around `TaskType.valueOf()` to handle invalid task type strings. An error message is printed to `System.err`.
 *         *   Empty description check is included in `addTask()`.
 *         *   Processing an empty queue is checked in `processNextTask()`, printing an error to `System.err`.
 *     *   **Class-wide `try-catch`:** The main `run()` method is wrapped in a `try-catch (Exception e)` block. This provides a class-wide handler for any unexpected exceptions that might propagate up from within the simulation logic, preventing the program from crashing abruptly and printing the error details to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   **`main` Method:** Creates an instance of `ProductionLineSimulator` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively combines various core Java features and data structures to build a functional simulation, demonstrating object-oriented principles, error handling, input processing, and the practical use of `Queue`, `List`, `ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch`.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Type
enum TaskType {
    ASSEMBLY, TESTING, PACKAGING
}

// Enum for Task Status
enum TaskStatus {
    PENDING, PROCESSING, COMPLETED, FAILED
}

/**
 * Represents a single production task.
 */
class ProductionTask {
    private int id;
    private TaskType type;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new ProductionTask.
     * @param id The unique ID of the task.
     * @param type The type of the task.
     * @param description A description of the task.
     */
    public ProductionTask(int id, TaskType type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public TaskType getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status (allows updating status during processing)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Task ID: %d, Type: %s, Description: %s, Status: %s",
                             id, type, description, status);
    }
}

/**
 * Simulates a production line managing tasks in a queue.
 */
public class ProductionLineSimulator {

    private Queue<ProductionTask> taskQueue;
    private List<ProductionTask> taskHistory;
    private Scanner scanner;
    private int nextTaskId;

    /**
     * Constructs a new ProductionLineSimulator.
     */
    public ProductionLineSimulator() {
        this.taskQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        this.taskHistory = new ArrayList<>(); // Use ArrayList for history
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nProduction Line Simulator Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Queue");
        System.out.println("4. View History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the queue based on user input.
     */
    private void addTask() {
        System.out.print("Enter task type (ASSEMBLY, TESTING, PACKAGING): ");
        String typeString = scanner.nextLine().trim().toUpperCase();
        TaskType taskType = null;

        try {
            taskType = TaskType.valueOf(typeString);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: Invalid task type entered. Please use ASSEMBLY, TESTING, or PACKAGING.");
            return; // Exit method if type is invalid
        }

        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return; // Exit method if description is empty
        }

        ProductionTask newTask = new ProductionTask(nextTaskId++, taskType, description);
        taskQueue.offer(newTask); // offer adds to the end of the queue
        System.out.println("Task " + newTask.getId() + " (" + newTask.getType() + ") added to queue.");
    }

    /**
     * Processes the next task from the queue.
     */
    private void processNextTask() {
        // poll retrieves and removes the head of the queue, returns null if empty
        ProductionTask taskToProcess = taskQueue.poll();

        if (taskToProcess == null) {
            System.err.println("Error: The task queue is empty. No task to process.");
            return; // Exit method if queue is empty
        }

        System.out.println("Processing task " + taskToProcess.getId() + " (" + taskToProcess.getType() + ")...");

        // Simulate processing - for this example, we'll just mark it as COMPLETED
        // A more complex simulation could involve delays, random failures, etc.
        taskToProcess.setStatus(TaskStatus.COMPLETED);
        System.out.println("Status updated to " + taskToProcess.getStatus() + ".");

        // Move the processed task to the history list
        taskHistory.add(taskToProcess);
        System.out.println("Task " + taskToProcess.getId() + " moved to history.");
    }

    /**
     * Displays the current tasks in the queue.
     */
    private void viewQueue() {
        System.out.println("\nCurrent Task Queue:");
        if (taskQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (ProductionTask task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays the history of processed tasks.
     */
    private void viewHistory() {
        System.out.println("\nTask History:");
        if (taskHistory.isEmpty()) {
            System.out.println("(History is empty)");
        } else {
            // Iterate through the history list
            for (ProductionTask task : taskHistory) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main simulation loop.
     */
    public void run() {
        int choice = -1; // Initialize choice to a non-menu value

        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in the loop and show menu again
                    continue; // Skip the switch and go to the next loop iteration
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewHistory();
                        break;
                    case 5:
                        System.out.println("Exiting simulator.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur within the run loop
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.run();
    }
}
