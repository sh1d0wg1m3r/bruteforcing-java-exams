/*
 * Exam Question #161
 * Generated on: 2025-05-11 22:23:40
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Task Management System. This system will allow users to add tasks, process them one by one, and view the status of tasks (pending, completed, or failed). The system simulates task processing, where tasks can randomly succeed or fail.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), `priority` (int), and `status` (using an enum `TaskStatus`: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`). Include appropriate getters and a method to update the status. Implement a meaningful `toString()` method for easy display.
 * 2.  **Task Management System:** Create a `TaskExecutorSystem` class that manages the tasks. It should contain:
 *     *   A `Queue<Task>` to hold tasks that are pending execution.
 *     *   A `List<Task>` to store tasks that have been successfully completed.
 *     *   A `List<Task>` to store tasks that have failed during processing.
 *     *   A counter to generate unique task IDs.
 * 3.  **Functionality:** The system should provide a command-line interface with the following options:
 *     *   `1. Add New Task`: Prompt the user for a task description and priority. Create a new `Task` with status `PENDING` and add it to the pending queue. Validate that the priority is a positive integer.
 *     *   `2. Process Next Task`: Take the next task from the pending queue. Simulate processing:
 *         *   If the queue is empty, report an error.
 *         *   If a task is retrieved, change its status to `PROCESSING`.
 *         *   Simulate success or failure (e.g., using a random chance).
 *         *   If successful, change status to `COMPLETED` and move the task to the completed list. Report success.
 *         *   If failed, change status to `FAILED` and move the task to the failed list. Report failure using `System.err`.
 *     *   `3. View Pending Tasks`: Display all tasks currently in the pending queue.
 *     *   `4. View Completed Tasks`: Display all tasks in the completed list.
 *     *   `5. View Failed Tasks`: Display all tasks in the failed list.
 *     *   `6. Exit`: Terminate the program.
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and task details.
 * 5.  **Flow Control:** Use a `switch` statement to handle the main menu options.
 * 6.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential `InputMismatchException` when reading integer inputs from the user (e.g., menu choice, priority).
 *     *   Use `System.err` to output error messages (e.g., invalid input, empty queue, task processing failure).
 *     *   Use `System.out` for normal output (menu, prompts, success messages, listing tasks).
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Perform input validation (e.g., positive priority).
 *     *   Ensure proper resource management (close the `Scanner`).
 *     *   Structure the code cleanly into logical classes.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu, prompt for necessary input, and provide informative feedback for each operation. Error messages should be distinguishable (e.g., printed to the error stream). Listing tasks should display their details including ID, description, priority, and current status.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View Failed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Implement Login Feature
 * Enter task priority: 5
 * Task added: Task{id=1, description='Implement Login Feature', priority=5, status=PENDING}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Implement Login Feature', priority=5, status=PROCESSING}
 * Task completed successfully: Task{id=1, description='Implement Login Feature', priority=5, status=COMPLETED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix Critical Bug
 * Enter task priority: 10
 * Task added: Task{id=2, description='Fix Critical Bug', priority=10, status=PENDING}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=2, description='Fix Critical Bug', priority=10, status=PROCESSING}
 * System.err: Task processing failed: Task{id=2, description='Fix Critical Bug', priority=10, status=FAILED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Implement Login Feature', priority=5, status=COMPLETED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Failed Tasks ---
 * System.err: Task{id=2, description='Fix Critical Bug', priority=10, status=FAILED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 * 
 * *(Note: The exact output for failed tasks might vary slightly based on whether you print the task details itself to System.err or just the failure message)*
 *
 * EXPLANATION:
 * This solution implements a simplified Task Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`), providing type safety and readability compared to using raw integers or strings for status.
 * 2.  **`Task` Class:** Represents an individual task with encapsulated data (`id`, `description`, `priority`, `status`). It includes a constructor, getters, a `setStatus` method, and an overridden `toString()` method for convenient printing.
 * 3.  **`TaskExecutorSystem` Class:** This is the core class managing the task workflow.
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used here to implement the `Queue` interface, providing FIFO (First-In, First-Out) behavior for tasks waiting to be processed. `offer()` adds to the tail, and `poll()` retrieves and removes from the head.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used to store completed tasks. `ArrayList` is a common and efficient implementation of the `List` interface for storing collections where elements are accessed by index or iterated over.
 *     *   **`List<Task> failedTasks`**: Another `ArrayList` is used for storing failed tasks, similar to `completedTasks`. Both `completedTasks` and `failedTasks` are declared using the `List` interface type, promoting good practice by programming to the interface rather than the specific implementation where possible.
 *     *   **`nextTaskId`**: A simple integer counter to ensure each task gets a unique ID.
 *     *   **`random`**: An instance of `java.util.Random` is used to simulate the non-deterministic outcome (success or failure) of task processing.
 *     *   **`addTask(String description, int priority)`**: Creates a new `Task`, validates the `priority` input (using `System.err` for validation errors), assigns a unique ID, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask()`**: Checks if the `pendingTasks` queue is empty (`isEmpty()`). If so, it prints an error to `System.err`. Otherwise, it retrieves the next task using `poll()`, simulates processing (updating status), determines success/failure using `random.nextDouble()`, updates the task status accordingly, and moves the task to the appropriate list (`completedTasks` or `failedTasks`) using `add()`. Success messages go to `System.out`, failure messages to `System.err`.
 *     *   **`view...Tasks()` methods**: These methods iterate through the respective collections (`pendingTasks`, `completedTasks`, `failedTasks`) and print the details of each task using their `toString()` method. They check if the lists/queue are empty and print a message if they are. All list views are printed to `System.out` for standard output, although failed tasks *could* arguably be listed to `System.err` if desired for stricter error reporting separation.
 *     *   **`run()` method**: This method contains the main application loop.
 *         *   It uses a `Scanner` to read user input.
 *         *   A `try-finally` block ensures that the `scanner.close()` method is called when the program finishes or exits the loop, releasing system resources.
 *         *   An outer `try-catch` block handles `InputMismatchException` that might occur if the user enters non-integer input for the main menu choice.
 *         *   A `while` loop continues until the user chooses option 6 (Exit).
 *         *   A `switch` statement is used to execute the appropriate method based on the user's valid integer input.
 *         *   Inside the "Add New Task" case, an inner `try-catch` block specifically handles `InputMismatchException` when reading the task priority, ensuring that invalid input for priority doesn't crash the entire program loop. `scanner.nextLine()` is used after reading integers to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *         *   Default case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   **`printMenu()`**: A helper method to display the menu options to the user.
 * 4.  **`ExamTaskExecutor` Class:** The main class containing the `main` method, which creates an instance of `TaskExecutorSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (via `List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, encapsulated, and well-structured program that demonstrates key Java programming concepts and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private int priority;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               ", status=" + status +
               '}';
    }
}

// Manages the collection of tasks and their processing
class TaskExecutorSystem {
    // Use LinkedList as a Queue implementation for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use ArrayList as a List implementation for completed tasks
    private List<Task> completedTasks;
    // Use ArrayList as a List implementation for failed tasks
    private List<Task> failedTasks;

    private int nextTaskId; // Counter for generating unique task IDs
    private Random random; // For simulating task success/failure

    /**
     * Constructs a new TaskExecutorSystem.
     */
    public TaskExecutorSystem() {
        this.pendingTasks = new LinkedList<>(); // Queue implemented by LinkedList
        this.completedTasks = new ArrayList<>(); // List implemented by ArrayList
        this.failedTasks = new ArrayList<>();   // List implemented by ArrayList
        this.nextTaskId = 1; // Start task IDs from 1
        this.random = new Random(); // Initialize random number generator
    }

    /**
     * Adds a new task to the pending queue.
     * Performs basic input validation for priority.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        // Input validation for priority
        if (priority <= 0) {
            System.err.println("Error: Task priority must be a positive integer.");
            return; // Do not add the task
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // Add task to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates success or failure.
     */
    public void processNextTask() {
        // Check if the pending queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        // Retrieve and remove the head of the queue
        Task currentTask = pendingTasks.poll();

        // Simulate processing
        currentTask.setStatus(TaskStatus.PROCESSING);
        System.out.println("Processing task: " + currentTask);

        // Simulate success or failure (e.g., 70% success rate)
        boolean success = random.nextDouble() < 0.7;

        if (success) {
            currentTask.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(currentTask); // Add to completed list
            System.out.println("Task completed successfully: " + currentTask);
        } else {
            currentTask.setStatus(TaskStatus.FAILED);
            failedTasks.add(currentTask); // Add to failed list
            System.err.println("Task processing failed: " + currentTask); // Report failure to error stream
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue (without removing elements)
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have failed processing.
     */
    public void viewFailedTasks() {
        System.out.println("--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("No failed tasks.");
        } else {
             // Iterate through the list
            for (Task task : failedTasks) {
                 // Optionally print failed tasks to System.err as they represent 'problem' states
                System.out.println(task); // Printing to System.out for consistency in list views
                // Or System.err.println(task); // If you want them distinct
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice outside the loop

        // Use try-finally to ensure the scanner is closed
        try {
            while (choice != 6) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch for menu navigation
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            int priority = -1;
                            try {
                                System.out.print("Enter task priority: ");
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                addTask(description, priority);
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid priority input. Please enter a number.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;
                        case 2: // Process Next Task
                            processNextTask();
                            break;
                        case 3: // View Pending Tasks
                            viewPendingTasks();
                            break;
                        case 4: // View Completed Tasks
                            viewCompletedTasks();
                            break;
                        case 5: // View Failed Tasks
                            viewFailedTasks();
                            break;
                        case 6: // Exit
                            System.out.println("Exiting Task Management System.");
                            break;
                        default: // Invalid choice
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the main menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                }
                System.out.println(); // Add a newline for better formatting between operations
            }
        } finally {
            // Ensure the scanner is closed when the program exits the loop or crashes
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
    }
}

// Main class to start the application
public class ExamTaskExecutor {
    public static void main(String[] args) {
        TaskExecutorSystem system = new TaskExecutorSystem();
        system.run(); // Start the system's main loop
    }
}
