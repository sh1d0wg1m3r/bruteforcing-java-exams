/*
 * Exam Question #885
 * Generated on: 2025-05-12 16:55:00
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Session Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified Event Management System. This system needs to manage sessions within an event, tracking registered attendees and maintaining a waiting list if a session reaches its capacity. The system should allow users to register for sessions, view session details (including attendees and waiting lists), and interact via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   The system must manage multiple `Session` objects. Each `Session` has a unique ID, a name, a maximum capacity, a list of registered attendees, and a waiting list.
 *     *   Users should be able to register an attendee for a specific session.
 *     *   If a session is not full, the attendee is added to the list of registered attendees.
 *     *   If a session is full, the attendee is added to the waiting list.
 *     *   Users should be able to view details of all sessions, including the number of registered attendees, the list of registered attendees, the number of people on the waiting list, and the waiting list itself.
 *     *   The system should provide a simple text-based menu for user interaction.
 * 
 * 2.  **Java Component Usage:**
 *     *   Use `java.util.Queue` to implement the waiting list for each session.
 *     *   Use `java.util.ArrayList` to implement the list of registered attendees for each session.
 *     *   Use the `java.util.List` interface where appropriate (e.g., for method parameters or return types where any List implementation is acceptable, or for the collection holding multiple `Session` objects).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement to handle the user's menu choices.
 *     *   Use `System.err` to output error messages (e.g., invalid input, session not found, attendee already registered/in queue).
 *     *   Use `System.out` to output normal information (e.g., menu, successful registration messages, session details).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially around user input parsing.
 * 
 * 3.  **Best Practices:**
 *     *   Apply proper encapsulation: Make fields private and provide public methods (getters, registration methods, etc.).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement basic input validation (e.g., checking for empty attendee names, valid session IDs).
 *     *   Ensure proper error handling as specified using `System.err` and `try-catch`.
 *     *   Structure the code cleanly into appropriate classes and methods.
 *     *   Manage resources like `Scanner` properly (e.g., using try-with-resources).
 * 
 * **Instructions:**
 * 
 * Write a single Java file containing all necessary classes (`Session`, `EventManager`, and a main class). The main class should set up a few initial sessions and start the interaction loop handled by the `EventManager`.
 * 
 * **Menu Options:**
 * 1.  Register Attendee
 * 2.  View Sessions
 * 3.  Exit
 * 
 * **Expected Output:**
 * The program should present a menu, process user input, display relevant information or error messages, and continue until the user chooses to exit. Session details display should clearly show registered attendees and waiting list entries.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Register Attendee
 * 2. View Sessions
 * 3. Exit
 * Enter your choice: 1
 * Enter Session ID: S1
 * Enter Attendee Name: Alice
 * Alice successfully registered for Java Basics.
 * 
 * --- Event Management Menu ---
 * 1. Register Attendee
 * 2. View Sessions
 * 3. Exit
 * Enter your choice: 1
 * Enter Session ID: S1
 * Enter Attendee Name: Bob
 * Bob successfully registered for Java Basics.
 * 
 * --- Event Management Menu ---
 * 1. Register Attendee
 * 2. View Sessions
 * 3. Exit
 * Enter your choice: 1
 * Enter Session ID: S1
 * Enter Attendee Name: Charlie
 * Session S1 (Java Basics) is full. Charlie added to waiting list.
 * 
 * --- Event Management Menu ---
 * 1. Register Attendee
 * 2. View Sessions
 * 3. Exit
 * Enter your choice: 2
 * --- Session Details ---
 * Session ID: S1
 * Name: Java Basics
 * Capacity: 2
 * Registered: 2/2
 * Attendees: [Alice, Bob]
 * Waiting List: 1 person
 * Waiting List: [Charlie]
 * 
 * Session ID: S2
 * Name: Advanced Topics
 * Capacity: 5
 * Registered: 0/5
 * Attendees: []
 * Waiting List: 0 people
 * Waiting List: []
 * --- End Session Details ---
 * 
 * --- Event Management Menu ---
 * 1. Register Attendee
 * 2. View Sessions
 * 3. Exit
 * Enter your choice: 3
 * Exiting Event Management System.
 * ```
 * 
 * Your solution should be a single, complete Java program file.
 *
 * EXPLANATION:
 * This solution provides a complete Java program for the Event Session Management System, fulfilling all the requirements of the exam task.
 * 
 * **Code Structure:**
 * 
 * 1.  **`Session` Class:**
 *     *   Encapsulates the data and behavior of a single session.
 *     *   `sessionId`, `name`, and `capacity` are private fields.
 *     *   `registeredAttendees` is a `List<String>` (implemented as `ArrayList`) to store attendees who successfully registered within capacity.
 *     *   `waitingList` is a `Queue<String>` (implemented as `LinkedList`) to store attendees waiting for a spot. `LinkedList` is a common `Queue` implementation.
 *     *   The constructor performs basic validation on input parameters.
 *     *   `registerAttendee` method implements the core logic: check capacity, add to `registeredAttendees` or `waitingList`, and handle cases where the attendee is already registered/waiting. It throws exceptions for invalid input or state.
 *     *   `getRegisteredAttendees` and `getWaitingList` provide access to the lists (the former returns an unmodifiable list as a good practice, though not strictly required by the prompt, the latter returns the queue directly for easy display).
 *     *   `displayDetails` formats and prints the session information.
 * 
 * 2.  **`EventManager` Class:**
 *     *   Manages a `List<Session>` (implemented as `ArrayList`) to hold all sessions.
 *     *   `addSession` and `getSession` methods manage the collection of sessions.
 *     *   `displaySessions` iterates through the sessions and calls their `displayDetails` method.
 *     *   `run` method contains the main application loop:
 *         *   It uses a `Scanner` within a try-with-resources block for safe resource management.
 *         *   It presents a menu and reads user input.
 *         *   A `try-catch (InputMismatchException)` block specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *         *   A `switch` statement processes valid menu choices.
 *         *   Crucially, a `try-catch (Exception e)` block *wraps the contents of the switch statement*. This provides the "class-wide exception handling" by catching exceptions that might occur during the execution of the chosen action (like `IllegalArgumentException` or `IllegalStateException` from `registerAttendee`). Error messages from these caught exceptions are printed to `System.err`.
 *         *   `handleRegisterAttendee` method is a helper to structure the logic for menu option 1, prompting for session ID and attendee name, finding the session, and calling `session.registerAttendee` within its own `try-catch` block to handle specific registration errors gracefully.
 *     *   The `main` method creates an `EventManager`, adds some initial `Session` objects, and calls the `run` method to start the application.
 * 
 * **Component Usage Breakdown:**
 * 
 * *   **`Queue` (`LinkedList`):** Used explicitly for the `waitingList` in the `Session` class. `offer` is used to add to the tail, and the `toString` method is used for display.
 * *   **`ArrayList`:** Used explicitly for the `registeredAttendees` in the `Session` class and for the `sessions` list in the `EventManager`. `add` is used to add elements, `size` to check count, and the `toString` method for display.
 * *   **`List` interface:** Used as the type for the `registeredAttendees` field (`List<String>`) and the `sessions` field (`List<Session>`). This demonstrates programming to interfaces.
 * *   **`Scanner`:** Used in the `EventManager.run` and `handleRegisterAttendee` methods to read user input lines and integers from `System.in`. Placed in a try-with-resources block.
 * *   **`Switch statement`:** Used in `EventManager.run` to direct control flow based on the user's menu choice.
 * *   **`System.err`:** Used for displaying all error messages: invalid menu input, session not found, registration errors (already registered/waiting, invalid name), and general unexpected errors caught by the `try-catch` blocks.
 * *   **`System.out`:** Used for displaying the menu, successful registration confirmations, and formatted session details.
 * *   **`try-catch` blocks:**
 *     *   A `try-with-resources` block ensures the `Scanner` is closed.
 *     *   A `try-catch (InputMismatchException)` handles non-integer input for the menu choice specifically.
 *     *   A general `try-catch (Exception)` block *within* the main loop's `try` block (surrounding the `switch`) provides class-wide handling for exceptions that might occur during the execution of the chosen action (like those thrown by `registerAttendee`).
 *     *   A specific `try-catch (IllegalArgumentException | IllegalStateException)` block is used around the call to `session.registerAttendee` to catch expected errors from that method and print specific messages to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Session` are private with public getters and methods for interaction.
 * *   **Naming:** Variable and method names are descriptive (e.g., `registeredAttendees`, `handleRegisterAttendee`).
 * *   **Comments/Documentation:** Basic Javadoc-style comments are included for classes and key methods.
 * *   **Input Validation:** Basic checks for null or empty strings are done in constructors and `registerAttendee`, and in `handleRegisterAttendee` before calling session methods. `InputMismatchException` handling validates numeric input.
 * *   **Error Handling:** Multiple `try-catch` blocks, including specific and general ones, route error messages to `System.err`.
 * *   **Clean Structure:** Code is divided logically into `Session` and `EventManager` classes, with clear method responsibilities.
 * 
 * This solution effectively demonstrates the required Java components and best practices in a practical, albeit simplified, event management context.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single session within the event
class Session {
    private String sessionId;
    private String name;
    private int capacity;
    private List<String> registeredAttendees;
    private Queue<String> waitingList;

    /**
     * Constructs a new Session.
     * @param sessionId Unique identifier for the session.
     * @param name Name of the session.
     * @param capacity Maximum number of registered attendees.
     */
    public Session(String sessionId, String name, int capacity) {
        if (sessionId == null || sessionId.trim().isEmpty()) {
            throw new IllegalArgumentException("Session ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Session name cannot be null or empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Session capacity must be positive.");
        }
        this.sessionId = sessionId.trim();
        this.name = name.trim();
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Using ArrayList for registered attendees
        this.waitingList = new LinkedList<>(); // Using LinkedList as a Queue for waiting list
    }

    // Getters
    public String getSessionId() {
        return sessionId;
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    /**
     * Attempts to register an attendee for the session.
     * Adds to registered list if capacity is available, otherwise adds to waiting list.
     * @param attendeeName The name of the attendee.
     * @return true if successfully registered, false if added to waiting list.
     * @throws IllegalArgumentException if attendeeName is null or empty.
     * @throws IllegalStateException if attendee is already registered or in waiting list.
     */
    public boolean registerAttendee(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        String nameToRegister = attendeeName.trim();

        if (registeredAttendees.contains(nameToRegister) || waitingList.contains(nameToRegister)) {
            throw new IllegalStateException(nameToRegister + " is already registered or on the waiting list for session " + sessionId);
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(nameToRegister);
            return true; // Successfully registered
        } else {
            waitingList.offer(nameToRegister); // offer returns true unless queue is full (unlikely for LinkedList)
            return false; // Added to waiting list
        }
    }

    /**
     * Gets the list of registered attendees.
     * Returns an unmodifiable list to prevent external modification.
     * @return An unmodifiable List of registered attendee names.
     */
    public List<String> getRegisteredAttendees() {
        return java.util.Collections.unmodifiableList(registeredAttendees);
    }

    /**
     * Gets the waiting list queue.
     * Returns the queue directly (handle with care externally, or return a view).
     * For this problem, returning the direct queue is acceptable for display.
     * @return The Queue of waiting list attendee names.
     */
    public Queue<String> getWaitingList() {
        return waitingList;
    }

    /**
     * Displays the details of the session, including attendees and waiting list.
     */
    public void displayDetails() {
        System.out.println("Session ID: " + sessionId);
        System.out.println("Name: " + name);
        System.out.println("Capacity: " + capacity);
        System.out.println("Registered: " + registeredAttendees.size() + "/" + capacity);

        System.out.println("Attendees: " + registeredAttendees); // ArrayList toString is useful

        System.out.println("Waiting List: " + waitingList.size() + " person(s)");
        System.out.println("Waiting List: " + waitingList); // Queue toString is also useful
        System.out.println(); // Add a newline for separation
    }
}

// Manages multiple sessions and user interaction
class EventManager {
    private List<Session> sessions; // Using List to hold sessions

    /**
     * Constructs a new EventManager.
     */
    public EventManager() {
        this.sessions = new ArrayList<>(); // Using ArrayList to store sessions
    }

    /**
     * Adds a session to the manager.
     * @param session The session to add.
     */
    public void addSession(Session session) {
        if (session != null) {
            sessions.add(session);
        }
    }

    /**
     * Finds a session by its ID.
     * @param sessionId The ID of the session to find.
     * @return The Session object if found, otherwise null.
     */
    public Session getSession(String sessionId) {
        if (sessionId == null) return null;
        for (Session session : sessions) {
            if (session.getSessionId().equalsIgnoreCase(sessionId.trim())) {
                return session;
            }
        }
        return null;
    }

    /**
     * Displays details for all managed sessions.
     */
    public void displaySessions() {
        System.out.println("--- Session Details ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions available.");
        } else {
            for (Session session : sessions) {
                session.displayDetails();
            }
        }
        System.out.println("--- End Session Details ---");
    }

    /**
     * Runs the main user interaction loop.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;
            while (choice != 3) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // May throw InputMismatchException
                    scanner.nextLine(); // Consume newline left-over

                    // Class-wide exception handling around the switch
                    try {
                        switch (choice) {
                            case 1:
                                handleRegisterAttendee(scanner);
                                break;
                            case 2:
                                displaySessions();
                                break;
                            case 3:
                                System.out.println("Exiting Event Management System.");
                                break;
                            default:
                                System.err.println("Invalid choice. Please enter 1, 2, or 3.");
                        }
                    } catch (Exception e) {
                        // Catching general exceptions within the switch cases
                        System.err.println("An error occurred during processing: " + e.getMessage());
                        // In a real system, logging the exception details would be important
                    }

                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                } catch (Exception e) {
                    // Catching any other unexpected exceptions during the loop
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Consider if this loop should break or continue on unexpected errors
                }
                System.out.println(); // Add a newline after each interaction
            }
        } // Scanner is automatically closed here
    }

    /**
     * Handles the registration process based on user input.
     * @param scanner The Scanner object for reading input.
     */
    private void handleRegisterAttendee(Scanner scanner) {
        System.out.print("Enter Session ID: ");
        String sessionId = scanner.nextLine();

        System.out.print("Enter Attendee Name: ");
        String attendeeName = scanner.nextLine();

        // Basic validation
        if (sessionId.trim().isEmpty()) {
             System.err.println("Session ID cannot be empty.");
             return;
        }
         if (attendeeName.trim().isEmpty()) {
             System.err.println("Attendee name cannot be empty.");
             return;
        }


        Session session = getSession(sessionId);

        if (session == null) {
            System.err.println("Error: Session with ID '" + sessionId + "' not found.");
            return;
        }

        try {
            boolean registeredSuccessfully = session.registerAttendee(attendeeName);
            if (registeredSuccessfully) {
                System.out.println(attendeeName + " successfully registered for " + session.getName() + ".");
            } else {
                System.out.println("Session " + session.getSessionId() + " (" + session.getName() + ") is full. " + attendeeName + " added to waiting list.");
            }
        } catch (IllegalArgumentException | IllegalStateException e) {
             // Catch exceptions thrown by Session.registerAttendee
             System.err.println("Registration failed: " + e.getMessage());
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Event Management Menu ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. View Sessions");
        System.out.println("3. Exit");
    }

    // Main method to run the application
    public static void main(String[] args) {
        EventManager manager = new EventManager();

        // Add some initial sessions
        try {
            manager.addSession(new Session("S1", "Java Basics", 2));
            manager.addSession(new Session("S2", "Advanced Topics", 5));
            manager.addSession(new Session("S3", "Database Fundamentals", 3));
        } catch (IllegalArgumentException e) {
             System.err.println("Failed to initialize sessions: " + e.getMessage());
             // Exit if initial setup fails critically
             return;
        }


        // Start the event manager application loop
        manager.run();
    }
}
