/*
 * Exam Question #165
 * Generated on: 2025-05-11 22:24:39
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Technical Support Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified technical support ticket management system. This system should simulate the workflow of receiving, processing, and tracking support requests.
 * 
 * **Core Functionality:**
 * 
 * 1.  **Submit New Ticket:** Allow a user to submit a new support ticket by providing a description of the issue. The system should assign a unique ID to the ticket and place it in a queue of pending tickets.
 * 2.  **Process Next Pending Ticket:** Simulate a support agent taking the next available ticket from the pending queue. This ticket should be removed from the queue, its status updated to "Resolved", and then added to a list of resolved tickets. If there are no pending tickets, an appropriate message should be displayed.
 * 3.  **View Pending Tickets:** Display all tickets currently waiting in the pending queue, in the order they were received.
 * 4.  **View Resolved Tickets:** Display all tickets that have been processed and marked as resolved.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate proficiency with core Java concepts and adhere to the following specific requirements:
 * 
 * *   Use `java.util.Queue` to manage the collection of pending support tickets. Choose an appropriate concrete implementation (e.g., `LinkedList`).
 * *   Use `java.util.ArrayList` to store the collection of resolved tickets.
 * *   Declare the variable holding the resolved tickets using the `java.util.List` interface type.
 * *   Use `java.util.Scanner` to read user input for menu choices and ticket descriptions from the console.
 * *   Implement the main application menu logic using a `switch` statement to handle user selections (Submit, Process, View Pending, View Resolved, Exit).
 * *   Use `System.err` specifically for printing error messages (e.g., invalid menu input, attempting to process an empty queue, invalid ticket description).
 * *   Use `System.out` for all normal output, including displaying the menu, prompts, ticket details, and success messages.
 * *   Implement class-wide exception handling using `try-catch` blocks within the main application loop to gracefully handle potential runtime errors, especially those related to user input (`InputMismatchException`) or invalid operations (like adding a ticket with an empty description, potentially handled by checking return values or catching exceptions from helper methods).
 * *   Adhere to best practices:
 *     *   Implement proper encapsulation by making class fields private and providing public methods (getters/setters where appropriate).
 *     *   Use meaningful and descriptive variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., check for empty ticket descriptions, handle non-integer menu input).
 *     *   Ensure proper error handling and user feedback.
 *     *   Structure your code logically using separate classes (e.g., a `Ticket` class, a `SupportSystem` class to manage the collections and logic, and a `Main` class for the user interface).
 * 
 * **Expected Output:**
 * 
 * The program should present a clear, numbered menu. Based on user input, it should perform the requested action, displaying relevant information or error messages. Output for viewing tickets should be formatted clearly.
 * 
 * **Constraint:** The entire solution should be contained within a single Java project and runnable from a `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple Technical Support Ticket System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:** The code is organized into three classes:
 *     *   `Ticket`: A simple Plain Old Java Object (POJO) representing a support ticket with `id`, `description`, and `status`. It uses private fields and public getters (and one setter for status) to ensure encapsulation. The `toString()` method provides a convenient way to display ticket information.
 *     *   `SupportSystem`: This class encapsulates the core logic and data structures of the system. It holds a `Queue` for pending tickets and a `List` (implemented as `ArrayList`) for resolved tickets. Methods like `addTicket`, `processNextTicket`, `viewPendingTickets`, and `viewResolvedTickets` manage the state and operations on these collections.
 *     *   `Main`: This class serves as the application's entry point and handles the user interface. It displays the menu, reads user input using `Scanner`, and calls the appropriate methods in the `SupportSystem` based on the user's choice.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: The `pendingTickets` field in `SupportSystem` is declared as `Queue<Ticket>` and initialized with a `LinkedList`. `offer()` is used to add tickets (though `add()` would also work for a `LinkedList`), and `poll()` is used to retrieve and remove the next ticket (FIFO behavior).
 *     *   `ArrayList`: The `resolvedTickets` field in `SupportSystem` is initialized with `new ArrayList<>()`.
 *     *   `List`: The `resolvedTickets` field is declared using the `List<Ticket>` interface type, demonstrating polymorphism and good practice.
 *     *   `Scanner`: Used in the `Main` class (`scanner` field) to read input from `System.in`. `nextInt()` reads the menu choice, and `nextLine()` is used to read the ticket description and also to consume the leftover newline character after reading an integer, preventing input issues in subsequent reads.
 *     *   `switch`: The `switch` statement in `Main.run()` is used to direct the program flow based on the integer menu choice entered by the user.
 *     *   `System.err`: Used specifically in `Main` for invalid menu input (`default` case in `switch`) and in `SupportSystem.processNextTicket()` when attempting to process an empty queue. It's also used in the `catch` blocks in `Main` to report errors.
 *     *   `System.out`: Used for all standard output, including printing the menu, prompts, successful operation messages, and displaying ticket lists.
 *     *   `try-catch`: A `try-catch` block wraps the core logic within the `Main.run()` loop. This provides "class-wide" handling for the main interactive part of the application. It specifically catches `InputMismatchException` for non-integer input, `IllegalArgumentException` which is thrown by `addTicket` for invalid descriptions, and a generic `Exception` catch for any other unexpected errors. This prevents the program from crashing due to common runtime issues.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Ticket` and `SupportSystem` are private, accessed via public methods.
 *     *   **Meaningful Names:** Variables (`pendingTickets`, `resolvedTickets`, `nextTicketId`, `description`, `choice`) and methods (`addTicket`, `processNextTicket`, `viewPendingTickets`, `printMenu`, `run`) are named clearly reflecting their purpose.
 *     *   **Comments/Documentation:** Basic Javadoc comments are included for classes and key methods, explaining their purpose and parameters. Inline comments clarify specific implementation details (like consuming the newline after `nextInt()`).
 *     *   **Input Validation:** `SupportSystem.addTicket` checks if the description is null or empty and throws an `IllegalArgumentException`. The `try-catch` in `Main` handles non-integer input for the menu.
 *     *   **Error Handling:** Error messages are printed using `System.err`. The `processNextTicket` method checks if the queue is empty before attempting to poll. The `try-catch` blocks in `Main` gracefully handle input and operational errors.
 *     *   **Clean Code Structure:** The separation of concerns into `Ticket`, `SupportSystem`, and `Main` classes makes the code modular and easier to understand and maintain.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single support ticket with an ID, description, and status.
 */
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Resolved"

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the issue.
     * @param status The initial status (e.g., "Pending").
     */
    public Ticket(int id, String description, String status) {
        this.id = id;
        this.description = description;
        this.status = status;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (as it changes)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string for the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the collection of pending and resolved support tickets.
 */
class SupportSystem {
    // Use Queue for pending tickets (FIFO)
    private Queue<Ticket> pendingTickets;
    // Use List (specifically ArrayList) for resolved tickets
    private List<Ticket> resolvedTickets;
    private int nextTicketId; // Counter for assigning unique IDs

    /**
     * Constructs a new SupportSystem, initializing ticket collections.
     */
    public SupportSystem() {
        pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        resolvedTickets = new ArrayList<>(); // ArrayList implements List
        nextTicketId = 1;
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the issue for the new ticket.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
             // Use IllegalArgumentException for invalid input data
             throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim(), "Pending");
        // offer is generally preferred over add for queues as it handles capacity issues (not relevant here)
        pendingTickets.offer(newTicket);
        System.out.println("Ticket #" + newTicket.getId() + " submitted successfully.");
    }

    /**
     * Processes the next ticket in the pending queue.
     * Removes the ticket from pending, updates status, and adds to resolved.
     * Prints an error message if no tickets are pending.
     * @return The processed Ticket object, or null if no tickets were pending.
     */
    public Ticket processNextTicket() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Ticket nextTicket = pendingTickets.poll();
        if (nextTicket != null) {
            nextTicket.setStatus("Resolved");
            resolvedTickets.add(nextTicket);
            System.out.println("Ticket #" + nextTicket.getId() + " processed and resolved.");
        } else {
            // Use System.err for operational errors
            System.err.println("No pending tickets to process.");
        }
        return nextTicket;
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Ticket ticket : pendingTickets) {
                 System.out.println(count++ + ". " + ticket); // Uses Ticket's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been marked as resolved.
     */
    public void viewResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
        if (resolvedTickets.isEmpty()) {
            System.out.println("No resolved tickets.");
        } else {
            // Iterate through the list
            for (Ticket ticket : resolvedTickets) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
        }
        System.out.println("------------------------");
    }
}

/**
 * Main class for the Support Ticket System application.
 * Handles user interaction, menu display, and orchestrates operations
 * using the SupportSystem.
 */
public class Main {
    private SupportSystem system;
    private Scanner scanner;

    /**
     * Constructs the Main application class, initializing the system and scanner.
     */
    public Main() {
        system = new SupportSystem();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling for input and general errors.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Class-wide exception handling for user input and operations
            try {
                // Attempt to read the integer choice
                choice = scanner.nextInt();
                // Consume the newline character left after reading the integer
                scanner.nextLine();

                // Use switch statement for menu flow control
                switch (choice) {
                    case 1:
                        submitTicket();
                        break;
                    case 2:
                        system.processNextTicket(); // Method handles its own success/error output
                        break;
                    case 3:
                        system.viewPendingTickets();
                        break;
                    case 4:
                        system.viewResolvedTickets();
                        break;
                    case 5:
                        System.out.println("Exiting Support Ticket System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu
                System.err.println("Invalid input. Please enter a number.");
                // IMPORTANT: Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to ensure the loop continues
            } catch (IllegalArgumentException e) {
                 // Catch specific exceptions thrown by SupportSystem methods (e.g., empty description)
                 System.err.println("Error submitting ticket: " + e.getMessage());
            } catch (Exception e) {
                 // Catch any other unexpected runtime exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // Optional: e.printStackTrace(); // Uncomment for detailed debugging info
            }
            System.out.println(); // Add a newline for readability between menu interactions
        }
        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Displays the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. Exit");
        System.out.println("----------------------------------");
    }

    /**
     * Prompts the user for a ticket description and submits it to the system.
     */
    private void submitTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();
        // Input validation (empty check) is handled within system.addTicket
        system.addTicket(description);
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Main app = new Main();
        app.run();
    }
}
