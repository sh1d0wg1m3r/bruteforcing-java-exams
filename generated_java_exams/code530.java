/*
 * Exam Question #530
 * Generated on: 2025-05-11 23:25:23
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Package Processing and Dispatch System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified package processing and dispatch system for a small logistics hub. The system needs to manage packages from arrival through processing to final dispatch.
 * 
 * The system should support the following operations via a command-line interface:
 * 1.  **Add Package:** Simulate the arrival of a new package. The user provides a unique Package ID and a Destination. The package is initially placed in a processing queue (represented internally).
 * 2.  **Process Package:** Simulate the processing of a package. The user specifies a Package ID. If the package exists and is in the processing state, it is moved to a dispatch queue.
 * 3.  **Dispatch Package:** Simulate dispatching packages. Packages are taken from the dispatch queue in the order they were processed and moved to dispatch.
 * 4.  **View Status:** Display the current list of packages in the processing area and the dispatch queue, including their status.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be a single Java program that demonstrates proficient use of the following Java components:
 * 
 * *   `java.util.Queue`: To manage packages ready for dispatch (FIFO order).
 * *   `java.util.ArrayList`: To manage packages currently in the processing area (order doesn't strictly matter for processing selection, but `ArrayList` allows easy listing and removal).
 * *   `java.util.List` interface: Your variable holding the processing packages must be declared using the `List` interface type, instantiated as an `ArrayList`.
 * *   `java.util.Scanner`: For all user input (menu choices, package details, package IDs).
 * *   `switch` statement: To handle the main menu navigation.
 * *   `System.err`: To print error messages (e.g., invalid input, package not found, package not in correct state for operation).
 * *   `System.out`: To print the menu, status information, and success messages.
 * *   Class-wide exception handling: Use `try-catch` blocks within the main operational loop or key methods to handle potential runtime errors (like non-integer input) gracefully.
 * 
 * **Design Requirements:**
 * 
 * *   Use object-oriented principles. Create a `Package` class to represent packages and a main class (e.g., `PackageManager`) to manage the system logic.
 * *   Implement proper encapsulation (private fields, public getters/setters where necessary).
 * *   Use meaningful variable and method names.
 * *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 * *   Implement input validation for user inputs (e.g., menu choices, non-empty IDs/Destinations).
 * *   Ensure correct state transitions for packages (e.g., a package must be in the processing area before it can be processed; it must be processed before it can be dispatched).
 * *   Handle cases where the dispatch queue is empty during a dispatch attempt.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and display status or error messages accordingly.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Package Management System
 * 1. Add Package
 * 2. Process Package
 * 3. Dispatch Package
 * 4. View Status
 * 5. Exit
 * Enter choice: 1
 * Enter Package ID: PKG001
 * Enter Destination: New York
 * Package PKG001 added for New York.
 * 
 * Enter choice: 1
 * Enter Package ID: PKG002
 * Enter Destination: Los Angeles
 * Package PKG002 added for Los Angeles.
 * 
 * Enter choice: 4
 * --- System Status ---
 * Processing Area:
 * ID: PKG001, Destination: New York, Status: INCOMING
 * ID: PKG002, Destination: Los Angeles, Status: INCOMING
 * Dispatch Queue:
 * (Empty)
 * ---------------------
 * 
 * Enter choice: 2
 * Enter Package ID to Process: PKG001
 * Package PKG001 processed and moved to dispatch queue.
 * 
 * Enter choice: 4
 * --- System Status ---
 * Processing Area:
 * ID: PKG002, Destination: Los Angeles, Status: INCOMING
 * Dispatch Queue:
 * ID: PKG001, Destination: New York, Status: READY_FOR_DISPATCH
 * ---------------------
 * 
 * Enter choice: 3
 * Dispatching package...
 * Dispatched Package: ID: PKG001, Destination: New York, Status: DISPATCHED
 * 
 * Enter choice: 4
 * --- System Status ---
 * Processing Area:
 * ID: PKG002, Destination: Los Angeles, Status: INCOMING
 * Dispatch Queue:
 * (Empty)
 * ---------------------
 * 
 * Enter choice: 3
 * Dispatching package...
 * Dispatch queue is empty. No packages to dispatch.
 * 
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple package management system demonstrating the required Java concepts.
 * 
 * 1.  **`Package` Class:** A simple class to represent a package with `id`, `destination`, and `status`. An `enum` `PackageStatus` is used for clarity. The constructor includes basic validation for non-empty ID and destination. `toString()`, `equals()`, and `hashCode()` methods are overridden for convenient printing and searching.
 * 
 * 2.  **`PackageManager` Class:** This is the main class that orchestrates the system.
 *     *   **Fields:**
 *         *   `processingArea`: Declared as `List<Package>` and initialized with `new ArrayList<>()`. This fulfills the requirement of using both `List` interface and `ArrayList` implementation. It holds packages that are newly added (`INCOMING`) or potentially undergoing simulated processing.
 *         *   `dispatchQueue`: Declared as `Queue<Package>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing the necessary FIFO behavior for dispatching. It holds packages marked as `READY_FOR_DISPATCH`.
 *         *   `scanner`: An instance of `Scanner` to read user input from `System.in`.
 *     *   **`run()` Method:** This method contains the main application loop.
 *         *   It continuously displays a menu and reads the user's choice.
 *         *   A **`switch` statement** is used to direct the flow based on the user's integer input, calling the appropriate handler method (`addPackage`, `processPackage`, etc.).
 *         *   A **`try-catch` block** is wrapped around the input reading and the `switch` statement within the `while` loop. This demonstrates class-wide exception handling by catching `InputMismatchException` (for non-integer input) and a general `Exception` for any other unexpected errors during an operation, preventing the program from crashing and printing informative messages to **`System.err`**.
 *         *   The `finally` block ensures the `scanner` is closed when the loop terminates (on exit).
 *     *   **`printMenu()`:** A helper method to display the available options to the user using **`System.out`**.
 *     *   **`addPackage()`:** Reads package details using `scanner.nextLine()`. It performs basic input validation (non-empty fields, check for duplicate ID across *both* collections) and adds a new `Package` object to the `processingArea` (`ArrayList`) with `INCOMING` status. Success messages are printed to **`System.out`**, while validation errors are printed to **`System.err`**. It also includes a `try-catch` specifically for `IllegalArgumentException` that might be thrown by the `Package` constructor.
 *     *   **`processPackage()`:** Reads the ID of the package to process. It iterates through the `processingArea` (`ArrayList`) to find the package. If found and in the correct state (`INCOMING`), it is removed from the `processingArea` and added to the `dispatchQueue` (`Queue`) using `offer()`. The package's status is updated to `READY_FOR_DISPATCH`. Error messages (package not found, wrong status) are printed to **`System.err`**. Success messages are printed to **`System.out`**.
 *     *   **`dispatchPackage()`:** Removes and returns the head of the `dispatchQueue` (`Queue`) using `poll()`. If the queue is empty (`poll()` returns `null`), a message is printed to **`System.out`**. Otherwise, the dispatched package's status is updated, and its details are printed to **`System.out`**.
 *     *   **`viewStatus()`:** Iterates through both the `processingArea` (`ArrayList`) and the `dispatchQueue` (`Queue`) to print the details of packages in each collection using **`System.out`**. It checks if each collection is empty and prints an appropriate message.
 *     *   **`findPackageById()`:** A helper method used by `addPackage` to check if a package ID already exists in either the processing area or the dispatch queue, ensuring ID uniqueness.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating data structure usage, flow control, input handling, validation, and robust error management using `try-catch` and `System.err`.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent package status
enum PackageStatus {
    INCOMING,
    PROCESSING, // Represents packages in the processing area
    READY_FOR_DISPATCH, // Represents packages in the dispatch queue
    DISPATCHED,
    CANCELLED // Optional: Could be added for more complex scenarios
}

/**
 * Represents a single package in the system.
 */
class Package {
    private String id;
    private String destination;
    private PackageStatus status;

    /**
     * Constructs a new Package object.
     * @param id The unique identifier for the package.
     * @param destination The destination of the package.
     */
    public Package(String id, String destination) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Package destination cannot be null or empty.");
        }
        this.id = id.trim();
        this.destination = destination.trim();
        this.status = PackageStatus.INCOMING; // Initial status
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getDestination() {
        return destination;
    }

    public PackageStatus getStatus() {
        return status;
    }

    // Setter (used internally by the management system)
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %s, Destination: %s, Status: %s", id, destination, status);
    }

    // Basic equals and hashCode for searching in collections
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Package aPackage = (Package) o;
        return id.equals(aPackage.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

/**
 * Manages the flow of packages through processing and dispatch.
 */
public class PackageManager {

    // List to hold packages currently in the processing area
    // Declared as List, instantiated as ArrayList as required
    private List<Package> processingArea;

    // Queue to hold packages ready for dispatch
    // Using LinkedList as a common Queue implementation
    private Queue<Package> dispatchQueue;

    private Scanner scanner;

    /**
     * Constructs a new PackageManager.
     * Initializes the processing area, dispatch queue, and scanner.
     */
    public PackageManager() {
        this.processingArea = new ArrayList<>(); // Using ArrayList
        this.dispatchQueue = new LinkedList<>(); // Using LinkedList as a Queue
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and handling user input.
     */
    public void run() {
        int choice = -1;
        System.out.println("Package Management System");

        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                printMenu();
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            addPackage();
                            break;
                        case 2:
                            processPackage();
                            break;
                        case 3:
                            dispatchPackage();
                            break;
                        case 4:
                            viewStatus();
                            break;
                        case 5:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optionally print stack trace for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
            // Ensure scanner is closed when the application exits the loop
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("1. Add Package");
        System.out.println("2. Process Package");
        System.out.println("3. Dispatch Package");
        System.out.println("4. View Status");
        System.out.println("5. Exit");
    }

    /**
     * Handles adding a new package based on user input.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine().trim();

        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine().trim();

        try {
            // Validate input fields are not empty
            if (id.isEmpty() || destination.isEmpty()) {
                System.err.println("Package ID and Destination cannot be empty.");
                return;
            }

            // Check if package ID already exists in either collection
            if (findPackageById(id) != null) {
                 System.err.println("Error: Package with ID '" + id + "' already exists.");
                 return;
            }

            Package newPackage = new Package(id, destination);
            processingArea.add(newPackage); // Add to processing area initially
            System.out.println("Package " + id + " added for " + destination + ".");

        } catch (IllegalArgumentException e) {
            // Catch validation errors from Package constructor
            System.err.println("Error adding package: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
        }
    }

    /**
     * Handles processing a package based on user input ID.
     * Moves package from processing area to dispatch queue.
     */
    private void processPackage() {
        System.out.print("Enter Package ID to Process: ");
        String idToProcess = scanner.nextLine().trim();

        if (idToProcess.isEmpty()) {
             System.err.println("Package ID cannot be empty.");
             return;
        }

        // Find the package in the processing area
        Package packageToProcess = null;
        int index = -1;
        for (int i = 0; i < processingArea.size(); i++) {
            Package p = processingArea.get(i);
            if (p.getId().equals(idToProcess)) {
                packageToProcess = p;
                index = i;
                break;
            }
        }

        if (packageToProcess == null) {
            System.err.println("Error: Package with ID '" + idToProcess + "' not found in the processing area.");
        } else if (packageToProcess.getStatus() != PackageStatus.INCOMING) {
             // Should theoretically always be INCOMING if in processingArea in this design
             System.err.println("Error: Package with ID '" + idToProcess + "' is not in the correct state for processing (Status: " + packageToProcess.getStatus() + ").");
        }
        else {
            // Simulate processing and move to dispatch queue
            processingArea.remove(index); // Remove from ArrayList
            packageToProcess.setStatus(PackageStatus.READY_FOR_DISPATCH);
            dispatchQueue.offer(packageToProcess); // Add to Queue
            System.out.println("Package " + idToProcess + " processed and moved to dispatch queue.");
        }
    }

    /**
     * Handles dispatching the next package from the dispatch queue.
     */
    private void dispatchPackage() {
        System.out.println("Dispatching package...");
        Package dispatchedPackage = dispatchQueue.poll(); // Retrieve and remove the head of the queue

        if (dispatchedPackage == null) {
            System.out.println("Dispatch queue is empty. No packages to dispatch.");
        } else {
            dispatchedPackage.setStatus(PackageStatus.DISPATCHED);
            System.out.println("Dispatched Package: " + dispatchedPackage);
            // In a real system, you might move this to a 'dispatched' list
        }
    }

    /**
     * Displays the current status of packages in the processing area and dispatch queue.
     */
    private void viewStatus() {
        System.out.println("--- System Status ---");

        System.out.println("Processing Area:");
        if (processingArea.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (Package p : processingArea) {
                System.out.println(p);
            }
        }

        System.out.println("Dispatch Queue:");
        if (dispatchQueue.isEmpty()) {
            System.out.println("(Empty)");
        } else {
             // Iterate over the queue without removing elements
            for (Package p : dispatchQueue) {
                System.out.println(p);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Helper method to find a package by ID in either collection.
     * Used primarily for checking ID uniqueness during add.
     * @param id The ID to search for.
     * @return The Package object if found, null otherwise.
     */
    private Package findPackageById(String id) {
        // Check processing area
        for (Package p : processingArea) {
            if (p.getId().equals(id)) {
                return p;
            }
        }
        // Check dispatch queue
        for (Package p : dispatchQueue) {
             if (p.getId().equals(id)) {
                 return p;
             }
         }
        return null; // Not found
    }


    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PackageManager manager = new PackageManager();
        manager.run();
    }
}
