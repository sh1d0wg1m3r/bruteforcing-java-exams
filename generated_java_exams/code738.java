/*
 * Exam Question #738
 * Generated on: 2025-05-12 16:33:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Digital Processing Unit (DPU) Simulation**
 * 
 * Design and implement a Java console application that simulates a Digital Processing Unit (DPU). The DPU processes requests in a First-In, First-Out (FIFO) manner. The system should allow users to add new requests, process the next pending request, and view lists of requests.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Request Representation:** Create a class `Request` to represent a processing request. Each request should have:
 *     *   A unique integer ID (automatically assigned, starting from 1).
 *     *   A String type (e.g., "ProcessData", "GenerateReport").
 *     *   A String description.
 *     *   A String status (e.g., "PENDING", "PROCESSING", "COMPLETED", "FAILED").
 *     *   Include appropriate constructors, getters, and a method to update the status. Override `toString()` for easy printing, possibly truncating long descriptions for readability.
 * 
 * 2.  **DPU Core Logic:** Create a class `DigitalProcessingUnit` that manages the requests. It should contain:
 *     *   A `java.util.Queue` (specifically, using `java.util.LinkedList` as the implementation) to hold requests that are currently pending processing.
 *     *   A `java.util.List` (specifically, using `java.util.ArrayList` as the implementation, but declared as the `List` interface) to maintain a history of *all* requests ever submitted to the DPU.
 *     *   A method `addRequest(String type, String description)`: Creates a new `Request`, adds it to both the pending queue and the history list. Perform input validation for type and description (cannot be null or empty after trimming whitespace). Throw an `IllegalArgumentException` if validation fails.
 *     *   A method `processNextRequest()`: Retrieves and removes the next request from the *pending* queue using the appropriate `Queue` method. Updates its status (simulate processing by changing status to "PROCESSING" then "COMPLETED"). If the queue is empty, print an error message to `System.err` and do nothing.
 *     *   A method `viewPendingRequests()`: Prints the details of all requests currently in the pending queue. Iterate over the queue without removing elements.
 *     *   A method `viewAllRequestsHistory()`: Prints the details of all requests in the history list.
 * 
 * 3.  **Console Interface:** Create a main class (e.g., `DPUConsoleApp`) with a `main` method to provide a command-line interface using `java.util.Scanner`. The interface should support the following commands:
 *     *   `add <type> <description>`: Adds a new request with the specified type and description. The description can contain spaces. Handle cases where type or description are missing or empty after trimming, printing an error to `System.err` or letting `addRequest`'s exception be caught.
 *     *   `process`: Processes the next request in the pending queue. Handle cases where extra arguments are provided (print error to `System.err`).
 *     *   `view pending`: Displays the list of requests currently in the pending queue. Handle cases where extra arguments are provided (print error to `System.err`).
 *     *   `view all`: Displays the history of all requests submitted. Handle cases where extra arguments are provided (print error to `System.err`).
 *     *   `exit`: Terminates the application. Handle cases where extra arguments are provided (print error to `System.err`).
 * 
 * 4.  **Required Java Components:** Your solution *must* explicitly use and demonstrate the functionality of *all* of the following:
 *     *   `java.util.Queue` (for pending tasks)
 *     *   `java.util.ArrayList` (as an implementation for the history list)
 *     *   `java.util.List` (declare the history list using the `List` interface)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling different commands)
 *     *   `System.err` (for printing error messages, e.g., invalid command usage, trying to process an empty queue, validation errors caught from DPU methods)
 *     *   `System.out` (for printing normal output, e.g., prompts, success messages, request details)
 *     *   Class-wide exception handling with `try-catch` blocks (handle potential issues during input processing or DPU operations in the `main` loop).
 * 
 * 5.  **Best Practices:** Implement the solution following good Java programming practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc for classes and public methods).
 *     *   Input validation (e.g., in `addRequest` and for command arguments).
 *     *   Proper error handling using `System.err` and `try-catch`.
 *     *   Clean code structure (separate classes for `Request`, `DigitalProcessingUnit`, and the main application).
 * 
 * **Expected Output:**
 * 
 * The application should provide clear prompts (`> `), print success messages to `System.out`, error messages to `System.err`, and display lists of requests in a readable format.
 * 
 * Example Interaction:
 * ```
 * Digital Processing Unit Console
 * Available commands: add <type> <description>, process, view pending, view all, exit
 * > add ProcessData Analyze sales figures
 * Request added: 1
 * > add GenerateReport Weekly summary
 * Request added: 2
 * > view pending
 * 
 * --- Pending Requests ---
 * Request ID: 1, Type: ProcessData, Description: Analyze sales figures, Status: PENDING
 * Request ID: 2, Type: GenerateReport, Description: Weekly summary, Status: PENDING
 * ------------------------
 * 
 * > process
 * Processing request: 1 (Type: ProcessData)
 * Request 1 completed.
 * > view pending
 * 
 * --- Pending Requests ---
 * Request ID: 2, Type: GenerateReport, Description: Weekly summary, Status: PENDING
 * ------------------------
 * 
 * > process
 * Processing request: 2 (Type: GenerateReport)
 * Request 2 completed.
 * > process
 * Error: No pending requests to process.
 * > add SystemCheck Daily health check
 * Request added: 3
 * > view all
 * 
 * --- All Request History ---
 * Request ID: 1, Type: ProcessData, Description: Analyze sales figures, Status: COMPLETED
 * Request ID: 2, Type: GenerateReport, Description: Weekly summary, Status: COMPLETED
 * Request ID: 3, Type: SystemCheck, Description: Daily health check, Status: PENDING
 * ---------------------------
 * 
 * > add InvalidType
 * Usage: add <type> <description>
 * > add AnotherType ""
 * Input Error: Request description cannot be null or empty.
 * > view invalid
 * Invalid view type. Usage: view pending or view all
 * > exit extra args
 * Usage: exit
 * > exit
 * Exiting DPU Console.
 * ```
 * 
 * Your code should be complete and runnable. You may structure it into multiple files or include all classes within a single file for submission, as instructed by your instructor (for this exercise, provide all code in the single SOLUTION_CODE block).
 *
 * EXPLANATION:
 * The provided solution simulates a Digital Processing Unit (DPU) console application, demonstrating the required advanced Java concepts and best practices.
 * 
 * 1.  **Request Representation (`Request` class):**
 *     *   A simple POJO (`Plain Old Java Object`) is used to model a request.
 *     *   It includes private fields (`id`, `type`, `description`, `status`) demonstrating encapsulation.
 *     *   A static counter (`nextId`) ensures unique IDs for each request.
 *     *   Public getters provide controlled access to the data.
 *     *   A `setStatus` method allows the DPU to update the request's state.
 *     *   The `toString()` method is overridden for clear console output, including basic truncation of the description.
 * 
 * 2.  **DPU Core Logic (`DigitalProcessingUnit` class):**
 *     *   `pendingRequests`: Declared as `Queue<Request>` and instantiated as `LinkedList<Request>`. This fulfills the requirement to use the `Queue` interface with a `LinkedList` implementation. The `offer()` method is used to add requests (enqueue), and `poll()` is used to retrieve and remove the next request (dequeue), adhering to FIFO.
 *     *   `allRequestsHistory`: Declared as `List<Request>` and instantiated as `ArrayList<Request>`. This fulfills the requirement to use the `List` interface with an `ArrayList` implementation. It simply stores all requests ever created using the `add()` method.
 *     *   `addRequest()`: Demonstrates input validation by checking if type or description are null or empty after trimming. It throws an `IllegalArgumentException` on failure, which is handled in the main application loop. It uses `System.out` to confirm the request was added.
 *     *   `processNextRequest()`: Uses `pendingRequests.poll()` to get the next item. It checks if `poll()` returned `null` (meaning the queue was empty) and prints an error to `System.err` if so. It simulates processing by updating the status and uses `System.out` for progress messages. A basic `try-catch` is included around the simulated processing step, although in this simple simulation, it primarily serves to demonstrate the construct; in a real system, this would catch errors from actual processing logic.
 *     *   `viewPendingRequests()` and `viewAllRequestsHistory()`: These methods iterate over the respective collections and print request details using `System.out`. `viewPendingRequests` iterates without removing elements from the queue.
 * 
 * 3.  **Console Interface (`DPUConsoleApp` class):**
 *     *   The `main` method contains the application's control flow.
 *     *   `Scanner`: An instance of `Scanner` reads user input from `System.in` line by line (`nextLine()`). This fulfills the `Scanner` requirement.
 *     *   `switch` statement: The `main` loop uses a `switch` statement on the first word of the input line to dispatch commands (`add`, `process`, `view`, `exit`). A nested `switch` handles the `view` sub-commands (`pending`, `all`). This fulfills the `switch` requirement.
 *     *   Input Parsing: The command line is split using `split("\\s+", 3)` which is a robust way to separate the command and type, leaving the rest of the line as the description, handling multi-word descriptions correctly.
 *     *   Error Handling:
 *         *   Command usage errors (wrong number of arguments) are checked and printed to `System.err`. This fulfills the `System.err` requirement.
 *         *   `try-catch`: A `try-catch` block surrounds the core command processing logic within the `while` loop. This demonstrates class-wide exception handling. It specifically catches `IllegalArgumentException` thrown by `addRequest` for invalid input, printing a user-friendly error message to `System.err`. A general `catch (Exception e)` is included as a fallback for any other unexpected errors during command execution, also printing to `System.err`. This fulfills the `try-catch` and `System.err` requirements.
 *     *   `System.out`: Used for welcome messages, prompts, success messages, and displaying request lists, fulfilling the `System.out` requirement.
 *     *   The `Scanner` is closed before the application exits, which is a good practice.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Achieved by making fields private and providing public methods for interaction in `Request` and `DigitalProcessingUnit`.
 *     *   **Meaningful Names:** Class, method, and variable names are descriptive (e.g., `pendingRequests`, `processNextRequest`, `viewAllRequestsHistory`).
 *     *   **Comments and Documentation:** Javadoc comments are used for classes and public methods, explaining their purpose and parameters/return values where applicable.
 *     *   **Input Validation:** Implemented in `addRequest` and also by checking the number of arguments for console commands in `main`.
 *     *   **Error Handling:** A layered approach using `System.err` for usage errors, specific exception handling (`IllegalArgumentException`), and a general `try-catch` for unexpected errors.
 *     *   **Clean Structure:** The code is divided into three logical classes, separating data representation (`Request`), core logic (`DigitalProcessingUnit`), and the user interface (`DPUConsoleApp`).
 * 
 * The solution effectively integrates all required Java components into a practical, albeit simulated, real-world scenario, while adhering to best practices and providing robust error handling and input validation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays; // Used for splitting command line

// Class to represent a processing request
class Request {
    private static int nextId = 1; // For unique IDs
    private int id;
    private String type;
    private String description;
    private String status; // e.g., "PENDING", "PROCESSING", "COMPLETED", "FAILED"

    /**
     * Constructs a new Request with a unique ID and initial status PENDING.
     * @param type The type of the request.
     * @param description The description of the request.
     */
    public Request(String type, String description) {
        this.id = nextId++;
        this.type = type;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (used by DPU) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Request.
     * Truncates description if too long for better console output.
     */
    @Override
    public String toString() {
        String displayDescription = description.length() > 40 ? description.substring(0, 37) + "..." : description;
        return String.format("Request ID: %d, Type: %s, Description: %s, Status: %s",
                             id, type, displayDescription, status);
    }
}

// Class representing the Digital Processing Unit
class DigitalProcessingUnit {
    // Queue to hold requests waiting to be processed (FIFO) - Required: Queue, LinkedList
    private Queue<Request> pendingRequests;
    // List to hold a history of all requests ever submitted - Required: List, ArrayList
    private List<Request> allRequestsHistory;

    /**
     * Constructs a new DigitalProcessingUnit, initializing request queues and history.
     */
    public DigitalProcessingUnit() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.allRequestsHistory = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new request to the system.
     * The request is added to both the pending queue and the history list.
     * @param type The type of the request. Must not be null or empty after trimming.
     * @param description The description of the request. Must not be null or empty after trimming.
     * @throws IllegalArgumentException if type or description is null or empty after trimming.
     */
    public void addRequest(String type, String description) throws IllegalArgumentException {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Request type cannot be null or empty.");
        }
         if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be null or empty.");
        }

        Request newRequest = new Request(type.trim(), description.trim());
        pendingRequests.offer(newRequest); // Add to the end of the queue
        allRequestsHistory.add(newRequest); // Add to the history list
        System.out.println("Request added: " + newRequest.getId()); // Required: System.out
    }

    /**
     * Processes the next request from the pending queue.
     * The processed request's status is updated, and it is removed from the pending queue.
     * If the queue is empty, a message is printed to System.err.
     */
    public void processNextRequest() {
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        Request requestToProcess = pendingRequests.poll();

        if (requestToProcess == null) {
            System.err.println("Error: No pending requests to process."); // Required: System.err
            return;
        }

        System.out.println("Processing request: " + requestToProcess.getId() + " (Type: " + requestToProcess.getType() + ")"); // Required: System.out
        // Simulate processing...
        // In a real system, this would involve actual work based on request type
        // For this simulation, we just update status and print
        try { // Required: try-catch (within method, contributes to overall handling)
             requestToProcess.setStatus("PROCESSING");
             // Simulate some work (optional, not required but good practice for realism)
             // Thread.sleep(100); // Requires handling InterruptedException
             requestToProcess.setStatus("COMPLETED");
             System.out.println("Request " + requestToProcess.getId() + " completed."); // Required: System.out
        } catch (Exception e) { // Catch any potential errors during simulated processing
             requestToProcess.setStatus("FAILED");
             System.err.println("Error processing request " + requestToProcess.getId() + ": " + e.getMessage()); // Required: System.err
        }
    }

    /**
     * Displays all requests currently in the pending queue.
     */
    public void viewPendingRequests() {
        System.out.println("\n--- Pending Requests ---"); // Required: System.out
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests."); // Required: System.out
        } else {
            // Iterate over the queue without removing elements
            pendingRequests.forEach(System.out::println); // Required: System.out
        }
        System.out.println("------------------------\n"); // Required: System.out
    }

     /**
     * Displays the history of all requests ever added to the system.
     */
    public void viewAllRequestsHistory() {
        System.out.println("\n--- All Request History ---"); // Required: System.out
        if (allRequestsHistory.isEmpty()) {
            System.out.println("No requests in history."); // Required: System.out
        } else {
            allRequestsHistory.forEach(System.out::println); // Required: System.out
        }
        System.out.println("---------------------------\n"); // Required: System.out
    }
}

// Main application class for the console interface
public class DPUConsoleApp {

    public static void main(String[] args) {
        // Required: Scanner
        Scanner scanner = new Scanner(System.in);
        DigitalProcessingUnit dpu = new DigitalProcessingUnit();
        boolean running = true;

        System.out.println("Digital Processing Unit Console"); // Required: System.out
        System.out.println("Available commands: add <type> <description>, process, view pending, view all, exit"); // Required: System.out

        while (running) {
            System.out.print("> "); // Required: System.out
            String commandLine = scanner.nextLine().trim();

            // Required: Class-wide exception handling with try-catch
            // Catch potential issues during command parsing or DPU method calls
            try {
                if (commandLine.isEmpty()) {
                    continue; // Ignore empty input
                }

                // Split the command line into at most 3 parts: command, type, rest_of_line for description
                String[] parts = commandLine.split("\\s+", 3);
                String command = parts[0].toLowerCase();

                // Required: switch statement for flow control
                switch (command) {
                    case "add":
                        // Validate arguments for add command
                        if (parts.length < 3) {
                            System.err.println("Usage: add <type> <description>"); // Required: System.err
                        } else {
                            String type = parts[1];
                            String description = parts[2];
                            // addRequest method has its own validation and throws IllegalArgumentException
                            dpu.addRequest(type, description);
                        }
                        break;

                    case "process":
                        // Validate arguments for process command
                        if (parts.length > 1) {
                             System.err.println("Usage: process"); // Required: System.err
                        } else {
                            dpu.processNextRequest();
                        }
                        break;

                    case "view":
                         // Validate arguments for view command
                         if (parts.length < 2) {
                            System.err.println("Usage: view pending or view all"); // Required: System.err
                         } else {
                             String viewType = parts[1].toLowerCase();
                             // Nested switch for view types
                             switch (viewType) {
                                 case "pending":
                                     if (parts.length > 2) {
                                         System.err.println("Usage: view pending"); // Required: System.err
                                     } else {
                                         dpu.viewPendingRequests();
                                     }
                                     break;
                                 case "all":
                                     if (parts.length > 2) {
                                          System.err.println("Usage: view all"); // Required: System.err
                                     } else {
                                         dpu.viewAllRequestsHistory();
                                     }
                                     break;
                                 default:
                                     System.err.println("Invalid view type. Usage: view pending or view all"); // Required: System.err
                                     break;
                             }
                         }
                        break;

                    case "exit":
                        // Validate arguments for exit command
                        if (parts.length > 1) {
                             System.err.println("Usage: exit"); // Required: System.err
                        } else {
                            running = false;
                            System.out.println("Exiting DPU Console."); // Required: System.out
                        }
                        break;

                    default:
                        System.err.println("Unknown command: " + command + ". Available commands: add, process, view, exit"); // Required: System.err
                        break;
                }
            } catch (IllegalArgumentException e) {
                 // Catch specific validation errors thrown by DPU methods (e.g., addRequest)
                 System.err.println("Input Error: " + e.getMessage()); // Required: System.err
            } catch (Exception e) {
                // Catch any other unexpected errors during command processing loop
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Required: System.err
                // e.printStackTrace(); // Uncomment for detailed debugging if needed
            }
        }

        scanner.close(); // Close the scanner when done
    }
}
