/*
 * Exam Question #421
 * Generated on: 2025-05-11 23:08:45
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Problem:** Design and implement a simplified console-based Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting to be processed, complete the next task in line based on arrival order, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with private fields: `description` (String), `priority` (String), and `status` (String, initially "Pending"). Include a constructor and public getter methods for these fields. Implement a basic `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a class named `TaskManager`. This class will manage the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store pending tasks. Tasks should be processed in a First-In, First-Out (FIFO) manner. Use `java.util.LinkedList` as the implementation for the `Queue`.
 *     *   It must use a `java.util.List<Task>` (implemented using `java.util.ArrayList`) to store completed tasks as an archive.
 *     *   It must use a `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Implement the following functionalities as methods within `TaskManager`:
 *         *   **Add Task:** Prompt the user for task description and priority. Create a new `Task` object and add it to the pending tasks queue. Implement basic input validation: task description cannot be empty.
 *         *   **View Pending Tasks:** Display all tasks currently in the pending queue without removing them. Indicate if the queue is empty.
 *         *   **Complete Next Task:** Remove the task at the front of the pending queue, change its status to "Completed", and add it to the completed tasks list. If the pending queue is empty, display an appropriate error message.
 *         *   **View Completed Tasks:** Display all tasks in the completed tasks list. Indicate if the list is empty.
 *         *   **Exit:** Terminate the program.
 * 3.  **User Interface:**
 *     *   Present a clear menu of options (Add Task, View Pending, Complete Next, View Completed, Exit) to the user.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The menu should loop continuously until the user explicitly chooses the Exit option.
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` exclusively for displaying the menu, prompts, task lists, and success messages (e.g., "Task added successfully!").
 *     *   Use `System.err` exclusively for displaying error messages (e.g., "Invalid choice.", "Task description cannot be empty.", "No pending tasks to complete.").
 *     *   Implement class-wide exception handling using `try-catch` blocks. This should wrap the main operational loop or input reading logic to catch potential runtime errors like invalid input format (`InputMismatchException`) and other unexpected issues. Handle specific errors like empty queue/list conditions gracefully.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation by making fields private and providing public accessors where needed.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include basic comments or Javadoc where necessary to explain the code's purpose.
 *     *   Ensure the code structure is clean and readable.
 *     *   Properly close the `Scanner` resource.
 * 
 * **Expected Output:**
 * The program should start by displaying a welcome message and the main menu. It should then repeatedly prompt the user for a choice, execute the corresponding action (adding, viewing, or completing tasks), and display the results or any errors. The interaction continues until the user selects the "Exit" option. Error messages must appear on `System.err`, while all other user-facing output appears on `System.out`.
 * 
 * ```
 * --- Simple Task Management System ---
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Implement login
 * Enter task priority (e.g., High, Medium, Low): High
 * Task added successfully!
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Write unit tests
 * Enter task priority (e.g., High, Medium, Low): Medium
 * Task added successfully!
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * 1. Task [Description: 'Implement login', Priority: 'High', Status: 'Pending']
 * 2. Task [Description: 'Write unit tests', Priority: 'Medium', Status: 'Pending']
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Complete Next Task ---
 * Completed task: Implement login
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * 1. Task [Description: 'Write unit tests', Priority: 'Medium', Status: 'Pending']
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task [Description: 'Implement login', Priority: 'High', Status: 'Completed']
 * 
 * Menu:
 * 1. Add Task
 * 2. View Pending Tasks
 * 3. Complete Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number. // This error appears on System.err
 * 
 * Menu:
 * ... (continues until 5 is entered)
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Task Management System (`TaskManager` class) that manages `Task` objects. It demonstrates the practical usage of all required Java components in a cohesive application.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (description, priority, status). It follows best practices by having private fields and public getter methods (`getDescription`, `getPriority`, `getStatus`). A setter (`setStatus`) is included to allow updating the status when a task is completed. The constructor includes basic validation to ensure the description is not empty, throwing an `IllegalArgumentException` if it is. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This is the core class containing the application logic.
 *     *   **`Queue` (`pendingTasks`):** A `java.util.Queue` is used to store tasks that are waiting to be processed. The `LinkedList` implementation is chosen as it efficiently supports queue operations (adding to the end, removing from the front). Tasks are added using `add()` and removed using `poll()`, ensuring FIFO order as required.
 *     *   **`List` (`completedTasks`) / `ArrayList`:** A `java.util.List` (implemented with `java.util.ArrayList`) is used to store tasks once they are marked as completed. This list serves as an archive, allowing completed tasks to be viewed. Tasks are added to the list using `add()`.
 *     *   **`Scanner` (`scanner`):** `java.util.Scanner` is used to read input from the standard input stream (`System.in`), allowing the user to interact with the menu and provide task details.
 *     *   **`switch` Statement:** The `switch` statement in the `start()` method is used to control the program's flow based on the integer choice entered by the user from the menu. Each case corresponds to a specific task management operation.
 *     *   **`System.out` and `System.err`:** The solution strictly adheres to using `System.out` for all normal output (menu display, prompts, task lists, success messages) and `System.err` exclusively for error messages (invalid menu choice, input validation errors, attempting to complete a task when the queue is empty). This is a good practice for separating standard output from error logging.
 *     *   **`try-catch` Blocks (Class-wide Exception Handling):**
 *         *   A large `try-catch` block wraps the main `while(running)` loop in the `start()` method. This provides a form of "class-wide" handling, catching any unexpected `Exception` that might occur during the program's execution, preventing it from crashing abruptly.
 *         *   An inner `try-catch` block is used specifically around the `scanner.nextInt()` call within the main loop. This catches `InputMismatchException` if the user enters non-integer input for the menu choice, handles the error gracefully using `System.err`, and consumes the invalid input (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   Another `catch` block within the inner `try` handles `IllegalArgumentException`, which is thrown by the `Task` constructor if validation fails (e.g., empty description). This demonstrates handling exceptions originating from other parts of the code.
 *         *   A `finally` block ensures that the `Scanner` resource is closed when the application loop terminates, releasing system resources.
 *     *   **Methods:** The `TaskManager` class contains dedicated methods for each operation (`addTask`, `viewPendingTasks`, `completeNextTask`, `viewCompletedTasks`, `displayMenu`), promoting modularity and readability.
 *     *   **Best Practices:** Encapsulation is used in both classes. Variable and method names are descriptive. Basic Javadoc comments explain the purpose of classes and methods. Input validation is performed in `addTask`. Error conditions (like an empty queue when trying to complete a task) are checked and reported using `System.err`.
 * 
 * This solution effectively combines various fundamental and advanced Java concepts, simulating a practical scenario while adhering to best practices and specific component requirements, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task with description, priority, and status.
 * Designed to be used within the TaskManager system.
 */
class Task { // Using package-private for simplicity in a single-file example
    private String description;
    private String priority;
    private String status;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task. Must not be null or empty.
     * @param priority    The priority of the task (e.g., High, Medium, Low).
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.priority = priority;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (used when completing a task) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string showing task details.
     */
    @Override
    public String toString() {
        return "Task [Description: '" + description + "', Priority: '" + priority + "', Status: '" + status + "']";
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 * Provides a console-based interface for task management using Scanner,
 * switch, and various collections. Includes error handling with try-catch
 * and distinct output streams (System.out, System.err).
 */
public class TaskManager {

    // Using Queue interface with LinkedList implementation for FIFO pending tasks
    private Queue<Task> pendingTasks;
    // Using List interface with ArrayList implementation for completed tasks archive
    private List<Task> completedTasks;
    private Scanner scanner;
    private boolean running; // Flag to control the main application loop

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true; // Application starts in running state
    }

    /**
     * Starts the task management system, displaying the menu and processing user input
     * within a loop. Includes class-wide exception handling.
     */
    public void start() {
        System.out.println("--- Simple Task Management System ---");

        // Class-wide exception handling block wrapping the main application loop.
        // Catches potential exceptions during the program's execution flow.
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Inner try-catch specifically for handling input errors (like non-integer input)
                // from the scanner read, preventing the program from crashing on bad input.
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline character after reading the integer

                    // Switch statement to control flow based on user's menu choice
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            viewPendingTasks();
                            break;
                        case 3:
                            completeNextTask();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            running = false; // Set flag to false to exit the while loop
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            // Using System.err for messages indicating invalid user action/input
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catches if the user enters something that is not an integer for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to clear the scanner buffer
                } catch (IllegalArgumentException e) {
                    // Catches exceptions thrown by the Task constructor (e.g., empty description)
                    System.err.println("Error creating task: " + e.getMessage());
                }
                System.out.println(); // Add a blank line for better readability between operations
            }
        } catch (Exception e) {
            // General catch block for any unexpected exceptions not caught by specific handlers.
            // Demonstrates a fallback for robustness.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // In a real application, you might log the full stack trace: e.printStackTrace(System.err);
        } finally {
            // The finally block ensures that the scanner resource is closed
            // regardless of whether an exception occurred or the loop finished normally.
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the console using System.out.
     */
    private void displayMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Complete Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Prompts user for task details and adds a new task to the pending queue.
     * Uses System.out for prompts and success messages.
     * Uses System.err for input validation errors.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Reads the full line

        // Basic input validation: check if description is empty or just whitespace
        if (description.trim().isEmpty()) {
            System.err.println("Task description cannot be empty."); // Error output on System.err
            return; // Exit the method if validation fails
        }

        System.out.print("Enter task priority (e.g., High, Medium, Low): ");
        String priority = scanner.nextLine(); // Reads the full line

        // Create the Task object. The Task constructor also has validation.
        // If the constructor throws IllegalArgumentException, it will be caught
        // in the start() method's catch block.
        try {
            Task newTask = new Task(description, priority);
            pendingTasks.add(newTask); // Add the new task to the end of the queue
            System.out.println("Task added successfully!"); // Success output on System.out
        } catch (IllegalArgumentException e) {
            // This catch block handles validation errors originating from the Task constructor
            System.err.println("Failed to add task: " + e.getMessage());
        }
    }

    /**
     * Displays all tasks currently in the pending queue using System.out.
     * Iterates without removing elements.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks."); // Output on System.out
        } else {
            int index = 1;
            // Iterating through the Queue using a for-each loop
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task); // Output on System.out (Task's toString)
            }
        }
    }

    /**
     * Completes the next task in the pending queue (FIFO).
     * Removes the task from the queue, updates status, and adds to completed list.
     * Uses System.out for success messages.
     * Uses System.err for error messages when the queue is empty.
     */
    private void completeNextTask() {
        System.out.println("--- Complete Next Task ---");
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task completedTask = pendingTasks.poll();

        if (completedTask == null) {
            // Using System.err for the error case (nothing to complete)
            System.err.println("No pending tasks to complete.");
        } else {
            completedTask.setStatus("Completed"); // Update status of the task object
            completedTasks.add(completedTask); // Add the completed task to the completed list
            System.out.println("Completed task: " + completedTask.getDescription()); // Success output on System.out
        }
    }

    /**
     * Displays all tasks in the completed tasks list using System.out.
     * Uses the List interface variable.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        // Accessing and iterating through the completed tasks List (ArrayList implementation)
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks."); // Output on System.out
        } else {
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task); // Output on System.out (Task's toString)
            }
        }
    }

    /**
     * Main method to start the TaskManager application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.start(); // Start the main application loop
    }
}
