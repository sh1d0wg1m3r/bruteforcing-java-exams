/*
 * Exam Question #1035
 * Generated on: 2025-05-12 17:15:51
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Document Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified document processing system. Documents are submitted for processing and are placed in a queue. A processor then picks up documents from the front of the queue, performs a simulated processing step, and moves the document to a list of processed items. Some documents might fail processing based on their content.
 * 
 * Your system must allow users to interact via a command-line interface to add documents, process the next document, view pending documents, and view processed documents.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a class `Document` to represent a document. It should have:
 *     *   A unique integer `id`.
 *     *   A `String content`.
 *     *   A status (use an enum `DocumentStatus`: `PENDING`, `PROCESSED_SUCCESS`, `PROCESSED_FAILED`).
 *     *   An optional `String processingMessage` (to explain failure or success).
 *     *   Appropriate constructors, getters, and a `toString()` method for easy printing.
 * 
 * 2.  **Document Processor:** Create a class `DocumentProcessor` that manages the processing flow. It must contain:
 *     *   A `Queue<Document>` to hold documents waiting to be processed (`pendingDocuments`).
 *     *   A `List<Document>` to hold documents that have been processed (`processedDocuments`). Use `ArrayList` as the concrete implementation for the list.
 *     *   A mechanism to generate unique document IDs (e.g., a counter).
 *     *   A public method `addDocument(String content)` that creates a new `Document` with status `PENDING` and adds it to the `pendingDocuments` queue.
 *     *   A public method `processNextDocument()` that:
 *         *   Checks if the `pendingDocuments` queue is empty. If so, it should report an error message.
 *         *   If not empty, it polls the next `Document` from the queue.
 *         *   Simulates processing: If the document's content contains the case-insensitive word "FAIL", set its status to `PROCESSED_FAILED` and set the `processingMessage` to "Content indicates failure.". Otherwise, set status to `PROCESSED_SUCCESS` and message to "Processing successful.".
 *         *   Adds the processed document (regardless of success or failure) to the `processedDocuments` list.
 *     *   Public methods `getPendingDocuments()` and `getProcessedDocuments()` that return the respective collections (consider returning immutable views or copies if aiming for higher encapsulation, but for this exam, returning the collection itself is acceptable).
 *     *   Appropriate encapsulation (private fields, public methods).
 * 
 * 3.  **Application Entry Point:** Create a class `DocumentProcessingApp` with a `main` method.
 *     *   Inside `main`, create an instance of `DocumentProcessor`.
 *     *   Use a `java.util.Scanner` to read user input from the console.
 *     *   Implement a command-line menu using `System.out` with the following options:
 *         1.  Add Document
 *         2.  Process Next Document
 *         3.  View Pending Documents
 *         4.  View Processed Documents
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range).
 *     *   Display appropriate messages using `System.out` for successful operations (e.g., "Document added.", "Document processed.").
 *     *   Use `System.err` exclusively for displaying error messages (e.g., "Invalid input.", "No pending documents to process.").
 *     *   Implement class-wide exception handling using a `try-catch` block in the `main` method to catch potential `InputMismatchException` from the `Scanner` or other unexpected runtime exceptions, printing an informative error message using `System.err`.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper resource management (close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * Your program should present the menu, accept user input, perform the requested actions, and display results or error messages clearly. An example interaction might look like:
 * 
 * ```
 * --- Document Processing Menu ---
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document content: This is document one.
 * Document added.
 * 
 * --- Document Processing Menu ---
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document content: This document will FAIL.
 * Document added.
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 3
 * --- Pending Documents ---
 * Document ID: 1, Status: PENDING
 * Document ID: 2, Status: PENDING
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 2
 * Document ID 1 processed. Status: PROCESSED_SUCCESS
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 2
 * Document ID 2 processed. Status: PROCESSED_FAILED
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 4
 * --- Processed Documents ---
 * Document ID: 1, Status: PROCESSED_SUCCESS, Message: Processing successful.
 * Document ID: 2, Status: PROCESSED_FAILED, Message: Content indicates failure.
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 6
 * Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 2
 * No pending documents to process.
 * 
 * --- Document Processing Menu ---
 * ... (menu options)
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct logic for adding, processing, and viewing documents.
 * *   Proper handling of the processing simulation (success/failure based on content).
 * *   Effective use of the `DocumentStatus` enum.
 * *   Robust error handling for input and processing scenarios, using `System.err` correctly.
 * *   Adherence to best practices (encapsulation, naming, comments, input validation).
 * *   Clear and readable code structure.
 *
 * EXPLANATION:
 * This solution implements a simple document processing system as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`DocumentStatus` Enum:** Defines the possible states of a document (`PENDING`, `PROCESSED_SUCCESS`, `PROCESSED_FAILED`), providing clear and type-safe status representation.
 * 
 * 2.  **`Document` Class:**
 *     *   Encapsulates document data (`id`, `content`, `status`, `processingMessage`).
 *     *   Uses private fields and public getters. A couple of setters are provided specifically for the `DocumentProcessor` to update status and message after processing.
 *     *   The `toString()` method is overridden for convenient printing of document details.
 * 
 * 3.  **`DocumentProcessor` Class:**
 *     *   Manages the core logic and data structures.
 *     *   `pendingDocuments`: Declared as `Queue<Document>` and initialized with `new LinkedList<>()`. `LinkedList` is a common `Queue` implementation in `java.util`. `Queue` enforces the FIFO (First-In, First-Out) order required for processing documents in the order they were added.
 *     *   `processedDocuments`: Declared as `List<Document>` and initialized with `new ArrayList<>()`. This demonstrates using the `List` interface while using `ArrayList` as the concrete implementation, allowing dynamic storage and retrieval of processed documents.
 *     *   `nextDocumentId`: A simple counter to ensure unique IDs for new documents.
 *     *   `addDocument(String content)`: Creates a new `Document` instance, assigns the next ID, sets initial status to `PENDING`, and adds it to the `pendingDocuments` queue using `offer()`. `offer()` is generally preferred for queues as it handles capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained).
 *     *   `processNextDocument()`: Uses `poll()` to retrieve and remove the head of the `pendingDocuments` queue. `poll()` returns `null` if the queue is empty, which is handled to report an error via `System.err`. If a document is retrieved, it simulates processing by checking the content for "FAIL" (case-insensitive), updates the document's status and message, and then adds the document to the `processedDocuments` list.
 *     *   `getPendingDocuments()` and `getProcessedDocuments()`: Provide access to the document lists. `getPendingDocuments()` returns a *copy* in a new `ArrayList` to prevent external code from modifying the internal `Queue` structure directly via the returned `List`. `getProcessedDocuments()` returns the internal `ArrayList` reference for simplicity in this exam context, though returning a copy or immutable view would be more robust encapsulation in a real-world system.
 * 
 * 4.  **`DocumentProcessingApp` Class:**
 *     *   Contains the `main` method, the application's entry point.
 *     *   Creates a `Scanner` for user input and a `DocumentProcessor` instance.
 *     *   Uses a `boolean running` flag and a `while` loop to keep the application running until the user chooses to exit.
 *     *   **Class-wide Exception Handling:** A `try-catch` block wraps the entire `while` loop. This catches any unexpected `RuntimeException` that might occur during the execution of the main application logic. Error details are printed to `System.err`. A `finally` block ensures the `Scanner` resource is closed, preventing resource leaks.
 *     *   **Menu and `switch`:** The `printMenu()` method displays options using `System.out`. The `switch` statement processes the integer choice read from the `Scanner`, directing execution to the appropriate `DocumentProcessor` method or application logic.
 *     *   **Input Validation and `try-catch`:** A nested `try-catch` specifically handles `InputMismatchException` that occurs if the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   **`System.out` and `System.err`:** `System.out` is used for normal program output (menu, prompts, success messages, listing documents). `System.err` is strictly used for error conditions (invalid input, queue empty, unexpected exceptions).
 *     *   **Best Practices:** Meaningful names (`DocumentProcessor`, `addDocument`, `pendingDocuments`), comments explaining parts of the code, and the use of the `finally` block to close the `Scanner` demonstrate good practices.
 * 
 * This solution effectively integrates all required components within a practical scenario, emphasizing data structure usage, flow control, error handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for document status
enum DocumentStatus {
    PENDING,
    PROCESSED_SUCCESS,
    PROCESSED_FAILED
}

// Represents a document to be processed
class Document {
    private int id;
    private String content;
    private DocumentStatus status;
    private String processingMessage;

    public Document(int id, String content) {
        this.id = id;
        this.content = content;
        this.status = DocumentStatus.PENDING;
        this.processingMessage = ""; // Initialize with empty message
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getContent() {
        return content;
    }

    public DocumentStatus getStatus() {
        return status;
    }

    public String getProcessingMessage() {
        return processingMessage;
    }

    // Setters (used by processor)
    public void setStatus(DocumentStatus status) {
        this.status = status;
    }

    public void setProcessingMessage(String processingMessage) {
        this.processingMessage = processingMessage;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Document ID: ").append(id)
          .append(", Status: ").append(status);
        if (status != DocumentStatus.PENDING) {
            sb.append(", Message: ").append(processingMessage);
        }
        return sb.toString();
    }
}

// Manages the queue and list of documents
class DocumentProcessor {
    // Use LinkedList as it implements Queue
    private Queue<Document> pendingDocuments;
    // Use ArrayList as the concrete List implementation
    private List<Document> processedDocuments;
    private int nextDocumentId;

    public DocumentProcessor() {
        this.pendingDocuments = new LinkedList<>();
        this.processedDocuments = new ArrayList<>(); // Concrete implementation
        this.nextDocumentId = 1;
    }

    /**
     * Adds a new document to the pending queue.
     * @param content The content of the document.
     */
    public void addDocument(String content) {
        Document newDoc = new Document(nextDocumentId++, content);
        pendingDocuments.offer(newDoc); // offer is preferred over add for queues
        System.out.println("Document added with ID: " + newDoc.getId());
    }

    /**
     * Processes the next document from the queue.
     * Moves the processed document to the processed list.
     * @return true if a document was processed, false if queue was empty.
     */
    public boolean processNextDocument() {
        Document docToProcess = pendingDocuments.poll(); // poll retrieves and removes head

        if (docToProcess == null) {
            // Queue is empty
            return false;
        }

        // Simulate processing logic
        if (docToProcess.getContent().toLowerCase().contains("fail")) {
            docToProcess.setStatus(DocumentStatus.PROCESSED_FAILED);
            docToProcess.setProcessingMessage("Content indicates failure.");
        } else {
            docToProcess.setStatus(DocumentStatus.PROCESSED_SUCCESS);
            docToProcess.setProcessingMessage("Processing successful.");
        }

        processedDocuments.add(docToProcess);
        System.out.println("Document ID " + docToProcess.getId() + " processed. Status: " + docToProcess.getStatus());
        return true;
    }

    /**
     * Returns the list of pending documents.
     * @return A List view of the pending documents.
     */
    public List<Document> getPendingDocuments() {
        // Returning a new ArrayList prevents external modification of the internal queue directly
        // while still providing a List interface.
        return new ArrayList<>(pendingDocuments);
    }

    /**
     * Returns the list of processed documents.
     * @return The List of processed documents.
     */
    public List<Document> getProcessedDocuments() {
        return processedDocuments;
    }
}

// Main application class
public class DocumentProcessingApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DocumentProcessor processor = new DocumentProcessor();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu control flow
                switch (choice) {
                    case 1:
                        System.out.print("Enter document content: ");
                        String content = scanner.nextLine();
                        processor.addDocument(content);
                        break;
                    case 2:
                        if (!processor.processNextDocument()) {
                            System.err.println("No pending documents to process.");
                        }
                        break;
                    case 3:
                        System.out.println("--- Pending Documents ---");
                        List<Document> pending = processor.getPendingDocuments();
                        if (pending.isEmpty()) {
                            System.out.println("No documents in the pending queue.");
                        } else {
                            for (Document doc : pending) {
                                System.out.println(doc);
                            }
                        }
                        System.out.println("-------------------------");
                        break;
                    case 4:
                        System.out.println("--- Processed Documents ---");
                        List<Document> processed = processor.getProcessedDocuments();
                         if (processed.isEmpty()) {
                            System.out.println("No documents have been processed yet.");
                        } else {
                            for (Document doc : processed) {
                                System.out.println(doc);
                            }
                        }
                        System.out.println("---------------------------");
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
             // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Document Processing Menu ---");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Pending Documents");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Exit");
    }
}
