/*
 * Exam Question #1096
 * Generated on: 2025-05-12 17:24:24
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Package Sorting and Processing System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified simulation of a package processing system at a logistics depot. Packages arrive and are placed in an incoming queue. A processing station takes the next package from the queue, verifies its destination, and moves it to a holding area categorized by destination. The system must handle user interaction for adding packages, processing packages, and viewing the status of packages.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the System:** Create a Java program that simulates this package processing flow.
 * 2.  **Required Components:** Your solution MUST effectively utilize ALL of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as an interface type)
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for flow control
 *     *   `System.err` for displaying error messages
 *     *   `System.out` for displaying normal output and information
 *     *   Class-wide exception handling with `try-catch` blocks (at least covering the main interaction loop).
 * 3.  **Package Class:** Define a `Package` class with the following private attributes:
 *     *   `packageId` (String): A unique identifier.
 *     *   `destination` (String): The target destination.
 *     *   `priority` (int): An integer representing priority (e.g., 1 for High, 2 for Medium, 3 for Low).
 *     *   Include a constructor, public getter methods for all attributes, and a meaningful `toString()` method.
 *     *   The constructor must perform basic validation: `packageId` cannot be null or empty, `destination` must be one of the valid destinations defined in the system, and `priority` must be within a valid range (e.g., 1 to 3). Throw an `IllegalArgumentException` for invalid data.
 * 4.  **Processing System Class:** Create a class (e.g., `PackageProcessingSystem`) to manage the system state and operations.
 *     *   It should maintain a `Queue` of incoming packages.
 *     *   It should maintain a structure to hold processed packages, categorized by destination. An `ArrayList` holding `List`s of `Package` objects (one list per destination) is required here.
 *     *   It should maintain a list of valid destinations (e.g., using an `ArrayList<String>`).
 *     *   Implement the following public methods:
 *         *   A constructor that initializes the data structures and defines a set of valid destinations (e.g., "NYC", "LAX", "CHI", "HOU").
 *         *   `addPackage(Package pkg)`: Adds a valid `Package` object to the incoming queue.
 *         *   `processNextPackage()`: Removes the next package from the incoming queue (FIFO), validates its destination against the known valid destinations (although the `Package` constructor already validates, this adds robustness or allows for future changes), and adds it to the corresponding destination list in the processed packages structure. If the queue is empty, print an informative message to `System.out`.
 *         *   `viewIncomingPackages()`: Prints the details of all packages currently in the incoming queue using `System.out`.
 *         *   `viewProcessedPackages(String destination)`: Finds the list for the specified destination and prints the details of all packages in that list using `System.out`. If the destination is invalid or has no processed packages, print an informative message.
 *         *   `run()`: This method should contain the main application loop. It should display a menu of options to the user (Add Package, Process Package, View Incoming, View Processed, Exit), read user input using `Scanner`, and use a `switch` statement to invoke the appropriate methods. This method should also include a `try-catch` block to handle potential runtime exceptions during the execution of the menu loop (e.g., unexpected input format issues not caught by specific validation).
 * 5.  **User Interaction:**
 *     *   The `run()` method should repeatedly display the menu until the user chooses to exit.
 *     *   For "Add Package", prompt the user for Package ID, Destination, and Priority. Handle potential `IllegalArgumentException` from the `Package` constructor and print an error message to `System.err`.
 *     *   For "View Processed", prompt the user for the destination.
 * 6.  **Error Handling and Output:**
 *     *   Use `System.err` exclusively for error messages (e.g., invalid package data, unexpected input errors caught by the main `try-catch`).
 *     *   Use `System.out` for all other output (menu, prompts, success messages, package details, empty queue/list messages).
 *     *   Ensure input validation is present as described (Package constructor, destination check).
 *     *   The main `run()` loop should have a `try-catch` block to catch general exceptions and prevent the program from crashing unexpectedly. Print a generic error message using `System.err` in the catch block.
 * 7.  **Best Practices:**
 *     *   Follow Java naming conventions.
 *     *   Use meaningful variable and method names.
 *     *   Add comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use interfaces (`List`, `Queue`) for variable types where appropriate.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Package Processing Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Incoming Packages
 * 4. View Processed Packages by Destination
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P101
 * Enter Destination (NYC, LAX, CHI, HOU): NYC
 * Enter Priority (1-3): 2
 * Package P101 added to incoming queue.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 1
 * Enter Package ID: P102
 * Enter Destination (NYC, LAX, CHI, HOU): DFW
 * Enter Priority (1-3): 1
 * Error adding package: Invalid destination: DFW
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 2
 * Processing package: [ID: P101, Dest: NYC, Priority: 2]
 * Package P101 moved to processed list for NYC.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 3
 * Incoming Packages:
 * (Queue is empty)
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 4
 * Enter destination to view processed packages: NYC
 * Processed Packages for NYC:
 * [ID: P101, Dest: NYC, Priority: 2]
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 4
 * Enter destination to view processed packages: SFO
 * Error: Invalid destination 'SFO'. Valid destinations are: NYC, LAX, CHI, HOU
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Expected Output:**
 * Your program should produce output similar to the example interaction, clearly indicating menu options, prompts, success messages, package details, and error messages (using `System.err` for errors). The format of package details should be consistent (e.g., using the `toString()` method).
 *
 * EXPLANATION:
 * The solution provides a `PackageSortingAndProcessingSystem` that simulates a basic logistics depot's workflow, fulfilling all the requirements of the exam question.
 * 
 * 1.  **`Package` Class:**
 *     *   This class represents the data structure for a single package.
 *     *   It has private fields (`packageId`, `destination`, `priority`) demonstrating encapsulation.
 *     *   The constructor includes input validation for all fields, throwing `IllegalArgumentException` if constraints are violated (null/empty ID, invalid destination, invalid priority range). This ensures data integrity from the moment a `Package` object is created.
 *     *   Public getter methods provide controlled access to the private data.
 *     *   The `toString()` method provides a convenient way to represent a package's details for printing.
 *     *   Static methods `isValidDestination` and `getValidDestinations` are provided for the system class to use, centralizing the definition of valid destinations.
 * 
 * 2.  **`PackageProcessingSystem` Class:**
 *     *   This class manages the core logic and state of the system.
 *     *   **`Queue<Package> incomingPackages`**: A `LinkedList` is used here because it implements the `Queue` interface, providing FIFO behavior. Packages arriving at the depot are added to this queue using `add()`.
 *     *   **`ArrayList<List<Package>> processedPackagesByDestination`**: This is a core part demonstrating the use of `ArrayList` and `List`. It's an `ArrayList` where each element is itself a `List<Package>`. Each inner list corresponds to a specific destination and holds all packages that have been processed and sorted for that destination. `LinkedList` is used for the inner lists as it also implements the `List` interface.
 *     *   **`ArrayList<String> validDestinations`**: An `ArrayList` is used to store the list of known valid destination names. This list is used to map destination names to the correct index in the `processedPackagesByDestination` `ArrayList`.
 *     *   **`Scanner scanner`**: An instance of `Scanner` reads user input from `System.in`.
 *     *   **`addPackage(Package pkg)`**: Simply adds a valid `Package` object to the `incomingPackages` queue using `add()`.
 *     *   **`processNextPackage()`**: This method demonstrates `Queue` usage with `poll()`, which retrieves and removes the head of the queue. It checks if the queue is empty before attempting to process. If a package is retrieved, it finds the corresponding destination list in `processedPackagesByDestination` using the index from `validDestinations.indexOf()`, and adds the package to that list using `add()`.
 *     *   **`viewIncomingPackages()`**: Iterates through the `incomingPackages` queue using an enhanced for loop to display its contents without removing elements.
 *     *   **`viewProcessedPackages(String destination)`**: Validates the input `destination` string against the `validDestinations` `ArrayList`. If valid, it retrieves the correct `List<Package>` from `processedPackagesByDestination` using the index and iterates through it to display the packages.
 *     *   **`run()`**: This is the main application loop method.
 *         *   It repeatedly prints a menu and reads the user's choice using the `scanner`.
 *         *   A `switch` statement is used to control the flow based on the user's choice, calling the appropriate system methods (`addPackage`, `processNextPackage`, etc.).
 *         *   **Exception Handling**:
 *             *   A `try-catch` block wraps the main logic inside the `while` loop. This catches general `Exception` instances, preventing the program from crashing due to unexpected issues (like errors during input processing not specifically handled). A message is printed to `System.err`, and the stack trace is printed for debugging.
 *             *   A specific `catch (java.util.InputMismatchException e)` is included to handle cases where the user enters non-integer input when a number is expected (like for menu choice or priority). This consumes the invalid input and prints an error to `System.err`, preventing an infinite loop.
 *             *   Inside the "Add Package" case, a nested `try-catch (IllegalArgumentException e)` specifically handles validation errors originating from the `Package` constructor, printing the validation error message to `System.err`.
 *     *   **Output:** `System.out.println` is used for all normal user interaction, prompts, menu display, and successful operation messages. `System.err.println` is used exclusively for error conditions as required.
 *     *   **Best Practices:** The code uses meaningful names, comments, follows encapsulation principles, and utilizes interfaces (`Queue`, `List`) for variable types where appropriate, promoting flexibility.
 * 
 * 3.  **Main Method:**
 *     *   A standard `main` method (placed within `PackageProcessingSystem` for simplicity in a single-file exam solution) creates an instance of `PackageProcessingSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, menu-driven application, demonstrating advanced understanding through proper data structure selection, encapsulation, input validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // For easier initialization of valid destinations

// Represents a single package in the system
class Package {
    private String packageId;
    private String destination;
    private int priority;

    // Valid destinations defined by the system
    private static final List<String> VALID_DESTINATIONS = Arrays.asList("NYC", "LAX", "CHI", "HOU");
    private static final int MIN_PRIORITY = 1;
    private static final int MAX_PRIORITY = 3;

    /**
     * Constructs a new Package object.
     * Performs validation on package data.
     * @param packageId The unique ID of the package.
     * @param destination The destination of the package.
     * @param priority The priority level (1=High, 2=Medium, 3=Low).
     * @throws IllegalArgumentException if packageId is null/empty, destination is invalid, or priority is out of range.
     */
    public Package(String packageId, String destination, int priority) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (!VALID_DESTINATIONS.contains(destination)) {
            throw new IllegalArgumentException("Invalid destination: " + destination + ". Valid destinations are: " + VALID_DESTINATIONS);
        }
        if (priority < MIN_PRIORITY || priority > MAX_PRIORITY) {
            throw new IllegalArgumentException("Invalid priority: " + priority + ". Priority must be between " + MIN_PRIORITY + " and " + MAX_PRIORITY + ".");
        }

        this.packageId = packageId.trim();
        this.destination = destination;
        this.priority = priority;
    }

    // Public getter methods
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Package.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "[ID: " + packageId + ", Dest: " + destination + ", Priority: " + priority + "]";
    }

    // Helper method to check if a destination is valid (used by the system class)
    public static boolean isValidDestination(String dest) {
        return VALID_DESTINATIONS.contains(dest);
    }

    public static List<String> getValidDestinations() {
        return new ArrayList<>(VALID_DESTINATIONS); // Return a copy to prevent external modification
    }
}

// Manages the package processing system
class PackageProcessingSystem {
    // Use Queue interface type, implemented by LinkedList
    private Queue<Package> incomingPackages;

    // Use List interface type for elements, stored in an ArrayList
    // This ArrayList holds Lists, where each inner List contains packages for a specific destination
    private ArrayList<List<Package>> processedPackagesByDestination;

    // Use ArrayList for managing the list of valid destination names
    private ArrayList<String> validDestinations;

    private Scanner scanner; // Scanner for user input

    /**
     * Constructs the PackageProcessingSystem.
     * Initializes queues, lists, and valid destinations.
     */
    public PackageProcessingSystem() {
        incomingPackages = new LinkedList<>(); // LinkedList implements Queue
        validDestinations = new ArrayList<>(Package.getValidDestinations()); // Get valid destinations from Package class

        // Initialize the list of processed package lists, one list per valid destination
        processedPackagesByDestination = new ArrayList<>(validDestinations.size());
        for (int i = 0; i < validDestinations.size(); i++) {
            processedPackagesByDestination.add(new LinkedList<>()); // Use LinkedList as it implements List
        }

        scanner = new Scanner(System.in);
    }

    /**
     * Adds a package to the incoming queue.
     * Validation is primarily done in the Package constructor.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        incomingPackages.add(pkg);
        System.out.println("Package " + pkg.getPackageId() + " added to incoming queue.");
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves it to the appropriate processed destination list.
     */
    public void processNextPackage() {
        Package pkgToProcess = incomingPackages.poll(); // Retrieve and remove head of the queue

        if (pkgToProcess == null) {
            System.out.println("No packages in the incoming queue to process.");
            return;
        }

        System.out.println("Processing package: " + pkgToProcess);

        String destination = pkgToProcess.getDestination();
        int destIndex = validDestinations.indexOf(destination);

        // This check should ideally not fail due to Package constructor validation,
        // but included for robustness and demonstrating destination handling.
        if (destIndex != -1) {
            processedPackagesByDestination.get(destIndex).add(pkgToProcess);
            System.out.println("Package " + pkgToProcess.getPackageId() + " moved to processed list for " + destination + ".");
        } else {
            // Should not happen with current validation, but good practice for unexpected data
            System.err.println("Error: Processed package has an invalid or unrecognized destination: " + destination);
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    public void viewIncomingPackages() {
        System.out.println("\n--- Incoming Packages Queue ---");
        if (incomingPackages.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : incomingPackages) {
                System.out.println(pkg);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays all packages processed for a specific destination.
     * @param destination The destination to view packages for.
     */
    public void viewProcessedPackages(String destination) {
        if (!validDestinations.contains(destination)) {
            System.err.println("Error: Invalid destination '" + destination + "'. Valid destinations are: " + validDestinations);
            return;
        }

        int destIndex = validDestinations.indexOf(destination);
        List<Package> processedList = processedPackagesByDestination.get(destIndex);

        System.out.println("\n--- Processed Packages for " + destination + " ---");
        if (processedList.isEmpty()) {
            System.out.println("(No packages processed for " + destination + " yet)");
        } else {
            // Iterate through the list
            for (Package pkg : processedList) {
                System.out.println(pkg);
            }
        }
        System.out.println("---------------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes a try-catch block for general error handling.
     */
    public void run() {
        int choice = -1;

        while (choice != 5) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1: // Add New Package
                        System.out.print("Enter Package ID: ");
                        String id = scanner.nextLine();
                        System.out.print("Enter Destination " + Package.getValidDestinations() + ": ");
                        String dest = scanner.nextLine().toUpperCase(); // Standardize case
                        System.out.print("Enter Priority (1-3): ");
                        int priority = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        try {
                            Package newPackage = new Package(id, dest, priority);
                            addPackage(newPackage);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding package: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Package
                        processNextPackage();
                        break;

                    case 3: // View Incoming Packages
                        viewIncomingPackages();
                        break;

                    case 4: // View Processed Packages by Destination
                        System.out.print("Enter destination to view processed packages: ");
                        String viewDest = scanner.nextLine().toUpperCase(); // Standardize case
                        viewProcessedPackages(viewDest);
                        break;

                    case 5: // Exit
                        System.out.println("Exiting system.");
                        break;

                    default:
                        System.out.println("Invalid choice. Please try again.");
                        break;
                }
            } catch (java.util.InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for your choice or priority.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
            System.out.println(); // Add a newline for better readability between menu cycles
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("--- Package Processing Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Packages");
        System.out.println("4. View Processed Packages by Destination");
        System.out.println("5. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        PackageProcessingSystem system = new PackageProcessingSystem();
        system.run();
    }
}
