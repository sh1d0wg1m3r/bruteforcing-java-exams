/*
 * Exam Question #524
 * Generated on: 2025-05-11 23:24:07
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduling System
 * 
 * **Problem Description:**
 * 
 * You are required to develop a simplified command-line application to manage patient appointments within a hospital setting. The system needs to handle patients arriving and joining a waiting list, scheduling appointments with available doctors, and managing doctor availability.
 * 
 * **Functionality Requirements:**
 * 
 * The application must provide the following menu-driven operations:
 * 
 * 1.  **Add Patient to Waiting List:** Prompt the user for a patient's name and add them to a waiting list. Patients should be served in the order they are added.
 * 2.  **Schedule Next Appointment:** Attempt to schedule an appointment. This involves taking the next patient from the waiting list and assigning them to the first available doctor. If no patient is waiting or no doctor is available, the system must report this.
 * 3.  **Complete Doctor's Appointment:** Prompt the user for the name of a doctor who has finished their appointment. Mark this doctor as available again. Handle cases where the doctor is not found or is already available.
 * 4.  **List Waiting Patients:** Display the names of all patients currently in the waiting list, in the order they will be seen.
 * 5.  **List Doctors (Availability):** Display the names of all doctors and their current availability status (Available or Busy).
 * 6.  **List Completed Appointments:** Display a history of all appointments that have been successfully scheduled, including patient name, doctor name, and a timestamp.
 * 7.  **Exit:** Terminate the application gracefully.
 * 
 * **Implementation Constraints:**
 * 
 * Your solution must be a single Java program file containing all necessary classes and the `main` method. It must **explicitly and correctly use ALL** of the following Java components:
 * 
 * *   `java.util.Queue`: To represent the patient waiting list, ensuring FIFO (First-In, First-Out) order.
 * *   `java.util.ArrayList`: As the concrete implementation for storing collections of objects (e.g., the list of doctors, the list of completed appointments).
 * *   `java.util.List` interface: Variables that hold `ArrayList` instances should be declared using the `List` interface type (e.g., `List<Doctor> doctors = new ArrayList<>();`).
 * *   `java.util.Scanner`: To read user input from the console for menu choices and data entry.
 * *   `switch` statement: To control the flow of the main menu based on user input.
 * *   `System.err`: To output **all** error messages (e.g., invalid input, operation failed due to empty queue or no availability, doctor not found).
 * *   `System.out`: To output **all** normal information (menu, prompts, confirmations, list contents, exit message).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling. The main application loop should be wrapped in a `try-catch` block to handle unexpected exceptions. Specific input validation should also be handled (e.g., catching `NumberFormatException` for menu input).
 * 
 * **Design and Best Practices:**
 * 
 * *   Create appropriate classes (e.g., `Patient`, `Doctor`, `Appointment`) with private fields and public methods (getters/setters where necessary) to demonstrate proper encapsulation.
 * *   Use meaningful and descriptive names for variables, methods, and classes.
 * *   Include comments to clarify the purpose of classes, methods, and any non-obvious logic.
 * *   Implement basic input validation to prevent errors from malformed user input.
 * *   Ensure the `Scanner` resource is properly managed and closed.
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu until the user chooses to exit. User interaction should be handled via console input. All error messages must appear on `System.err`, and all other output on `System.out`. The formatting of lists and confirmation messages should be clear.
 * 
 * **Example Interaction Snippet (Illustrative - shows output separation):**
 * 
 * ```
 * --- Hospital Scheduling System ---
 * 1. Add Patient to Waiting List
 * ...
 * Enter your choice: 1
 * Enter patient name: Patient A
 * Patient A added to the waiting list.
 * 
 * --- Hospital Scheduling System ---
 * ...
 * Enter your choice: 2
 * Error: No doctors are currently available. // <-- This line goes to System.err
 * 
 * --- Hospital Scheduling System ---
 * ...
 * Enter your choice: 5
 * 
 * --- Doctors ---
 * Dr. Smith - Available
 * Dr. Jones - Busy
 * -----------------
 * 
 * --- Hospital Scheduling System ---
 * ...
 * Enter your choice: 7
 * Exiting system. Goodbye! // <-- This line goes to System.out
 * ```
 * 
 * Your solution will be evaluated based on correct functionality, adherence to all implementation constraints (especially the use of the required components and output streams), code quality, and error handling.
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Scheduling System adhering to all specified requirements.
 * 
 * 1.  **Class Structure:** The code is organized into four classes: `Patient`, `Doctor`, `Appointment` (representing the entities in the system), and `HospitalScheduler` (containing the main logic and application loop). This promotes modularity and encapsulation.
 * 2.  **Data Structures:**
 *     *   `waitingQueue`: Declared as `Queue<Patient>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and an `ArrayList` implementation (`LinkedList` also implements `List` and `Queue`), suitable for managing patients in a FIFO manner using `offer()` to add and `poll()` to remove.
 *     *   `doctors`: Declared as `List<Doctor>` and initialized with `new ArrayList<>()`. This fulfills the requirement of using both `List` interface and `ArrayList` implementation. It stores the collection of doctors.
 *     *   `completedAppointments`: Declared as `List<Appointment>` and initialized with `new ArrayList<>()`. Similar to `doctors`, this uses the `List` interface and `ArrayList` to maintain a history of scheduled appointments.
 * 3.  **User Input (`Scanner`):** A `Scanner` object is used to read user input from `System.in` for menu choices and data (patient/doctor names). It is initialized in the constructor and closed in the `finally` block of the `main` method to release the resource.
 * 4.  **Flow Control (`switch`):** The `main` method uses a `switch` statement to process the integer menu choice entered by the user, directing execution to the appropriate method within the `HospitalScheduler` instance.
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful action messages (patient added, appointment scheduled, doctor available), and listing contents (waiting patients, doctors, completed appointments).
 *     *   `System.err.println()` is strictly used for all error messages, such as invalid menu input, attempting to schedule when the queue is empty or no doctors are available, or issues when completing an appointment (doctor not found or already available).
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A top-level `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This serves as the class-wide exception handling mechanism, catching any unexpected runtime errors that might occur and printing an error message and stack trace to `System.err`.
 *     *   A specific `try-catch (NumberFormatException e)` block is used around the `Integer.parseInt()` call for reading the menu choice. This handles cases where the user enters non-numeric input, preventing the program from crashing and prompting the user to try again using `System.err`.
 *     *   Input validation checks (like `name.trim().isEmpty()`) are used before processing input, preventing common issues and providing user-friendly error messages via `System.err`.
 * 7.  **Encapsulation and Best Practices:**
 *     *   Fields in `Patient`, `Doctor`, `Appointment`, and `HospitalScheduler` are declared as `private`. Public getter methods (and setters where state changes are needed, like `setAvailable` in `Doctor`) are provided to access or modify the data, enforcing encapsulation.
 *     *   Variable, method, and class names are chosen to be descriptive (e.g., `waitingQueue`, `scheduleAppointment`, `listCompletedAppointments`).
 *     *   Comments are included to explain the purpose of classes, constructors, key methods, and specific code sections (like data structure initialization or error handling blocks).
 *     *   Basic input validation is performed for user-provided strings (checking for empty/whitespace-only names).
 * 
 * This solution effectively demonstrates the required Java concepts and data structures in a cohesive, practical application while adhering to best practices for structure, encapsulation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Date; // For timestamp

// Represents a patient
class Patient {
    private static int nextId = 1; // Auto-incrementing ID for patients
    private int id;
    private String name;

    /**
     * Constructs a new Patient with a unique ID.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.id = nextId++;
        this.name = name;
    }

    // Getter for patient ID
    public int getId() {
        return id;
    }

    // Getter for patient name
    public String getName() {
        return name;
    }

    /**
     * Returns a string representation of the patient.
     */
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

// Represents a doctor
class Doctor {
    private String name;
    private boolean isAvailable;

    /**
     * Constructs a new Doctor, initially available.
     * @param name The name of the doctor.
     */
    public Doctor(String name) {
        this.name = name;
        this.isAvailable = true; // Doctors are initially available
    }

    // Getter for doctor name
    public String getName() {
        return name;
    }

    // Getter for availability status
    public boolean isAvailable() {
        return isAvailable;
    }

    // Setter for availability status
    public void setAvailable(boolean available) {
        isAvailable = available;
    }

    /**
     * Returns a string representation of the doctor.
     */
    @Override
    public String toString() {
        return "Doctor [Name=" + name + ", Available=" + isAvailable + "]";
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private Doctor doctor;
    private long timestamp; // Using long for System.currentTimeMillis()

    /**
     * Constructs a new Appointment.
     * @param patient The patient for the appointment.
     * @param doctor The doctor for the appointment.
     * @param timestamp The time the appointment was scheduled (in milliseconds).
     */
    public Appointment(Patient patient, Doctor doctor, long timestamp) {
        this.patient = patient;
        this.doctor = doctor;
        this.timestamp = timestamp;
    }

    // Getter for patient
    public Patient getPatient() {
        return patient;
    }

    // Getter for doctor
    public Doctor getDoctor() {
        return doctor;
    }

    // Getter for timestamp
    public long getTimestamp() {
        return timestamp;
    }

    /**
     * Returns a string representation of the appointment.
     */
    @Override
    public String toString() {
        // Use Date to format the timestamp for readability
        return "Appointment [Patient=" + patient.getName() + ", Doctor=" + doctor.getName() + ", Time=" + new Date(timestamp) + "]";
    }
}

/**
 * Main class for the Hospital Scheduling System.
 * Manages the waiting queue, doctors, and completed appointments.
 */
public class HospitalScheduler {

    // Use Queue interface, implemented by LinkedList for FIFO waiting list
    private Queue<Patient> waitingQueue;

    // Use List interface, implemented by ArrayList to store doctors
    private List<Doctor> doctors;

    // Use List interface, implemented by ArrayList to store completed appointments history
    private List<Appointment> completedAppointments;

    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new HospitalScheduler and initializes data structures and doctors.
     */
    public HospitalScheduler() {
        // Initialize data structures
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        doctors = new ArrayList<>(); // ArrayList implements List
        completedAppointments = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);

        // Initialize some doctors for the system
        doctors.add(new Doctor("Dr. Smith"));
        doctors.add(new Doctor("Dr. Jones"));
        doctors.add(new Doctor("Dr. Williams"));
        doctors.add(new Doctor("Dr. Garcia"));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Scheduling System ---");
        System.out.println("1. Add Patient to Waiting List");
        System.out.println("2. Schedule Next Appointment");
        System.out.println("3. Complete Doctor's Appointment");
        System.out.println("4. List Waiting Patients");
        System.out.println("5. List Doctors (Availability)");
        System.out.println("6. List Completed Appointments");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the waiting queue based on user input.
     * Handles input validation for the patient name.
     */
    public void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

        // Validate input name
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return; // Exit method on validation failure
        }

        Patient newPatient = new Patient(name.trim());
        waitingQueue.offer(newPatient); // Add patient to the end of the queue
        System.out.println(newPatient.getName() + " added to the waiting list.");
    }

    /**
     * Attempts to schedule the next appointment by pairing the next waiting patient
     * with the first available doctor.
     * Uses System.err for error messages if scheduling fails.
     */
    public void scheduleAppointment() {
        // Check if there are patients waiting
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: No patients currently waiting.");
            return;
        }

        // Find an available doctor from the list
        Doctor availableDoctor = null;
        for (Doctor doc : doctors) {
            if (doc.isAvailable()) {
                availableDoctor = doc;
                break; // Found the first available doctor
            }
        }

        // Check if an available doctor was found
        if (availableDoctor == null) {
            System.err.println("Error: No doctors are currently available.");
            return;
        }

        // If both patient and doctor are available, schedule the appointment
        Patient nextPatient = waitingQueue.poll(); // Get and remove the next patient from the queue
        availableDoctor.setAvailable(false); // Mark the doctor as busy

        Appointment newAppointment = new Appointment(nextPatient, availableDoctor, System.currentTimeMillis());
        completedAppointments.add(newAppointment); // Add the appointment to the history list

        System.out.println("--- Appointment Scheduled ---");
        System.out.println("Patient: " + nextPatient.getName());
        System.out.println("Doctor: " + availableDoctor.getName());
        System.out.println("Time: " + new Date(newAppointment.getTimestamp()));
        System.out.println("---------------------------");
    }

    /**
     * Marks a doctor as available after completing an appointment, based on user input.
     * Handles validation for doctor name and availability status.
     * Uses System.err for error messages.
     */
    public void completeAppointment() {
        System.out.print("Enter the name of the doctor who finished their appointment: ");
        String doctorName = scanner.nextLine();

        // Validate input name
         if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        doctorName = doctorName.trim(); // Trim whitespace

        Doctor doctorToFree = null;
        // Find the doctor in the list by name (case-insensitive search)
        for (Doctor doc : doctors) {
            if (doc.getName().equalsIgnoreCase(doctorName)) {
                doctorToFree = doc;
                break;
            }
        }

        // Check if doctor was found
        if (doctorToFree == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
        } else if (doctorToFree.isAvailable()) {
             // Check if doctor is already available
            System.err.println("Error: Doctor '" + doctorName + "' is already available.");
        } else {
            // Mark the doctor as available
            doctorToFree.setAvailable(true);
            System.out.println("Doctor '" + doctorName + "' is now available.");
        }
    }

    /**
     * Lists all patients currently in the waiting queue.
     * Uses System.out for listing, System.err if the queue is empty (though prompt says normal output).
     * Let's stick to System.out for empty list message as per example snippet implies normal output.
     */
    public void listWaitingPatients() {
        System.out.println("\n--- Waiting Patients ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("No patients in the waiting list."); // Normal output for empty list
        } else {
            // Iterate through the queue without removing elements using an enhanced for loop
            int i = 1;
            for (Patient patient : waitingQueue) {
                System.out.println(i++ + ". " + patient.getName() + " (ID: " + patient.getId() + ")");
            }
        }
        System.out.println("------------------------");
    }

     /**
      * Lists all registered doctors and their current availability status.
      * Uses System.out for output.
      */
    public void listDoctors() {
        System.out.println("\n--- Doctors ---");
        if (doctors.isEmpty()) {
             System.out.println("No doctors registered."); // Normal output for empty list
        } else {
            for (Doctor doc : doctors) {
                System.out.println(doc.getName() + " - " + (doc.isAvailable() ? "Available" : "Busy"));
            }
        }
        System.out.println("---------------");
    }

    /**
     * Lists all completed appointments from the history list.
     * Uses System.out for output.
     */
    public void listCompletedAppointments() {
        System.out.println("\n--- Completed Appointments ---");
        if (completedAppointments.isEmpty()) {
            System.out.println("No appointments have been completed yet."); // Normal output for empty list
        } else {
            // Iterate through the list of completed appointments
            for (Appointment appt : completedAppointments) {
                System.out.println(appt); // Uses the Appointment's toString() method
            }
        }
        System.out.println("----------------------------");
    }

    /**
     * The main entry point of the application.
     * Contains the main application loop and class-wide exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                scheduler.displayMenu();
                int choice = -1; // Default value for choice

                // Local try-catch for handling non-integer input for menu choice
                try {
                    String inputLine = scheduler.scanner.nextLine();
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    continue; // Skip the rest of the loop and show the menu again
                } catch (Exception e) {
                     // Catch any other unexpected issues during input reading
                    System.err.println("An error occurred while reading input: " + e.getMessage());
                    // Optionally e.printStackTrace(System.err); for debugging
                    continue;
                }


                // Switch statement to handle the user's menu choice
                switch (choice) {
                    case 1:
                        scheduler.addPatient();
                        break;
                    case 2:
                        scheduler.scheduleAppointment();
                        break;
                    case 3:
                        scheduler.completeAppointment();
                        break;
                    case 4:
                        scheduler.listWaitingPatients();
                        break;
                    case 5:
                        scheduler.listDoctors();
                        break;
                    case 6:
                        scheduler.listCompletedAppointments();
                        break;
                    case 7:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur outside specific handlers
            System.err.println("An unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scheduler.scanner != null) {
                scheduler.scanner.close();
                System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }
}
