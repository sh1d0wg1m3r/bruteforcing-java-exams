/*
 * Exam Question #510
 * Generated on: 2025-05-11 23:22:09
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Server Task Processing Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a server processing tasks. Tasks arrive and are placed in a queue awaiting processing. The server processes tasks one by one from the front of the queue. After processing, a task is either marked as completed or failed and moved to a corresponding list. The user interacts with the system via a command-line interface to manage the tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique task ID (e.g., a simple incrementing integer or a UUID string), and a description. Include a constructor, getters, and a `toString()` method for easy display.
 * 2.  **Task Processor:** Create a `TaskProcessor` class that manages the task queue and the lists of completed and failed tasks.
 *     *   It must have private fields: a `Queue` to hold tasks awaiting processing, a `List` to hold completed tasks, and a `List` to hold failed tasks. Use `ArrayList` as the concrete implementation for the `List` fields.
 *     *   It must use a `Scanner` object to read user input for commands and task details.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and the given description, and adds it to the processing queue.
 *         *   `processNextTask()`: Removes the task from the front of the queue. Prompts the user if the task processing was successful (e.g., 'y' for success, 'n' for failure). Based on the user's response, moves the task to the `completedTasks` list or the `failedTasks` list. Handle the case where the queue is empty.
 *         *   `viewQueue()`: Displays the tasks currently in the processing queue.
 *         *   `viewCompletedTasks()`: Displays the tasks in the completed list.
 *         *   `viewFailedTasks()`: Displays the tasks in the failed list.
 *         *   `run()`: This method contains the main application loop. It should display a menu of options to the user, read their input using the `Scanner`, and use a `switch` statement to call the appropriate methods. The loop should continue until the user chooses to exit.
 * 3.  **User Interface:** The `run()` method should provide a clear menu with options like:
 *     *   Add New Task
 *     *   Process Next Task
 *     *   View Task Queue
 *     *   View Completed Tasks
 *     *   View Failed Tasks
 *     *   Exit
 * 4.  **Input Handling:** Use the `Scanner` to read user choices and task descriptions.
 * 5.  **Flow Control:** Use a `switch` statement within the main loop to handle the different menu options.
 * 6.  **Error Handling:**
 *     *   Use `System.err.println()` to print error messages (e.g., "Queue is empty, no tasks to process.", "Invalid menu option.").
 *     *   Implement class-wide exception handling using a `try-catch` block around the main loop or input reading section in the `run()` method to catch potential input errors or unexpected issues.
 * 7.  **Output:** Use `System.out.println()` for displaying the menu, task details, list contents, and success messages.
 * 8.  **Best Practices:** Adhere to Java best practices including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments (Javadoc for classes/methods, inline for complex logic).
 *     *   Basic input validation (e.g., checking if a task description is empty, handling non-integer menu input via exception handling).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it displays a menu. Based on user input, it performs the requested action, prints results or errors, and redisplays the menu until the user selects the exit option.
 * 
 * Example interaction flow:
 * ```
 * Server Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. View Failed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Analyze logs
 * Task added: Task ID: 1, Description: Analyze logs
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 3
 * Tasks in Queue:
 * Task ID: 1, Description: Analyze logs
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 1, Description: Analyze logs
 * Was processing successful? (y/n): y
 * Task ID: 1 marked as completed.
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task ID: 1, Description: Analyze logs
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 2
 * Queue is empty, no tasks to process.
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 7
 * Invalid menu option. Please try again.
 * 
 * Server Task Processor Menu:
 * ...
 * Enter your choice: 6
 * Exiting Task Processor.
 * ```
 *
 * EXPLANATION:
 * The solution implements a `TaskProcessor` class that simulates a server managing tasks. It effectively demonstrates the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`taskId`, `description`), a constructor, getters, and a `toString()` method. Using `UUID.randomUUID().toString()` provides a simple way to generate unique task IDs without managing a counter, showcasing awareness of alternative ID generation methods.
 * 
 * 2.  **`TaskProcessor` Class:** This is the core class.
 *     *   **Collections:** It uses a `Queue<Task>` (`taskQueue`) implemented by `LinkedList` to store tasks waiting to be processed. The `Queue` interface ensures FIFO (First-In, First-Out) behavior, which is appropriate for a processing queue. It uses `List<Task>` (`completedTasks`, `failedTasks`) implemented by `ArrayList` to store tasks after processing. Using the `List` interface type for the fields demonstrates polymorphism, allowing flexibility if a different `List` implementation were needed later, while `ArrayList` provides dynamic resizing and efficient element access.
 *     *   **`Scanner`:** A `Scanner` object is used to read input from `System.in`, enabling user interaction.
 *     *   **Methods:**
 *         *   `addTask()`: Creates a `Task` object and adds it to the `taskQueue` using `offer()`, which is the standard way to add to a queue. Includes basic input validation for the description.
 *         *   `processNextTask()`: Retrieves the next task using `poll()`, which safely returns `null` if the queue is empty. It then prompts the user for the processing outcome and adds the task to either `completedTasks` or `failedTasks` using the `List`'s `add()` method. It handles the empty queue case gracefully.
 *         *   `viewQueue()`, `viewCompletedTasks()`, `viewFailedTasks()`: These methods iterate through their respective collections and print the details of each task using the `Task` class's `toString()` method.
 *         *   `run()`: This is the main application loop. It repeatedly displays a menu, reads the user's integer choice, and uses a `switch` statement to dispatch to the appropriate method.
 *     *   **`switch` Statement:** The `switch` statement in `run()` is used for clear and efficient control flow based on the user's menu selection.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for normal messages like the menu, task additions, and list contents. `System.err.println()` is used specifically for error conditions like invalid menu choices, empty queue processing attempts, or invalid input during processing.
 *     *   **Exception Handling:** A `try-catch` block is placed around the core logic within the `run()` loop that reads user input.
 *         *   It specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. This prevents the program from crashing and informs the user of the error. `scanner.nextLine()` is called in the catch block to consume the invalid input, preventing an infinite loop.
 *         *   A general `catch (Exception e)` block is included to catch any other unexpected runtime exceptions, providing a basic level of robustness. Printing the stack trace (`e.printStackTrace()`) is useful for debugging in an exam context. This demonstrates class-wide exception handling around the main operational flow.
 *     *   **Best Practices:** The code follows best practices:
 *         *   **Encapsulation:** Fields in both classes are private, accessed via public methods.
 *         *   **Naming:** Variable and method names are descriptive (e.g., `taskQueue`, `processNextTask`, `completedTasks`).
 *         *   **Comments:** Javadoc comments explain the purpose of classes and public methods, and inline comments clarify specific logic.
 *         *   **Input Validation:** Basic validation is done for the task description and handled implicitly by the `try-catch` for menu input.
 *         *   **Structure:** The code is organized into logical classes and methods. Resources like the `Scanner` are managed (though a simple `closeScanner()` is included, in more complex apps try-with-resources might be used).
 * 
 * This solution effectively integrates all the required Java components into a practical, interactive simulation, demonstrating a solid understanding of fundamental data structures, control flow, input/output, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.UUID; // Using UUID for unique task IDs

/**
 * Represents a single task in the server processing simulation.
 */
class Task {
    private String taskId;
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.taskId = UUID.randomUUID().toString(); // Generate a unique ID
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The unique task ID.
     */
    public String getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description;
    }
}

/**
 * Simulates a server processing tasks using a queue and managing completed/failed lists.
 */
public class TaskProcessor {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private List<Task> failedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessor, initializing collections and scanner.
     */
    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the processing queue.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // offer() is preferred over add() for queues as it doesn't throw exception on capacity limits
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the queue.
     * Prompts user for success/failure and moves task to appropriate list.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty

        if (taskToProcess == null) {
            System.err.println("Queue is empty, no tasks to process.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);
        System.out.print("Was processing successful? (y/n): ");

        String resultInput = scanner.nextLine().trim().toLowerCase();

        if ("y".equals(resultInput)) {
            completedTasks.add(taskToProcess);
            System.out.println("Task ID: " + taskToProcess.getTaskId() + " marked as completed.");
        } else if ("n".equals(resultInput)) {
            failedTasks.add(taskToProcess);
            System.out.println("Task ID: " + taskToProcess.getTaskId() + " marked as failed.");
        } else {
            // If input is invalid, the task is effectively lost from the queue,
            // which is a limitation of this simple simulation.
            // In a real system, it might go back to the queue or a pending state.
            // For this exam, just report invalid input.
            System.err.println("Invalid input for processing result. Task was removed from queue but not added to completed/failed lists.");
        }
    }

    /**
     * Displays the tasks currently in the processing queue.
     */
    public void viewQueue() {
        System.out.println("Tasks in Queue (" + taskQueue.size() + "):");
        if (taskQueue.isEmpty()) {
            System.out.println("  Queue is empty.");
        } else {
            // Iterate without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println("  " + index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the tasks in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("Completed Tasks (" + completedTasks.size() + "):");
        if (completedTasks.isEmpty()) {
            System.out.println("  No tasks completed yet.");
        } else {
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println("  " + index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the tasks in the failed tasks list.
     */
    public void viewFailedTasks() {
        System.out.println("Failed Tasks (" + failedTasks.size() + "):");
        if (failedTasks.isEmpty()) {
            System.out.println("  No tasks have failed yet.");
        } else {
            int index = 1;
            for (Task task : failedTasks) {
                System.out.println("  " + index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nServer Task Processor Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        viewFailedTasks();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Task Processor.");
                        break;
                    default:
                        System.err.println("Invalid menu option. Please try again.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for the menu choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
        closeScanner();
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the Task Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
