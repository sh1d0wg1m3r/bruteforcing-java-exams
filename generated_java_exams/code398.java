/*
 * Exam Question #398
 * Generated on: 2025-05-11 23:05:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Restaurant Order Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based order management system for a small restaurant. The system should allow staff to view the menu, place new customer orders, process orders from the kitchen queue, and view the current queue of pending orders.
 * 
 * Your solution must demonstrate a strong understanding of fundamental and advanced Java concepts, including data structures, input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items. Use an `ArrayList` internally, but declare the field and any relevant method parameters/return types using the `List` interface.
 *     *   Manage customer orders using a queue. Orders should be processed in a First-In, First-Out (FIFO) manner. Use `java.util.Queue`.
 *     *   Create appropriate classes to represent `MenuItem` (with name and price) and `Order` (with a unique ID, a list of selected `MenuItem`s, and a status).
 * 
 * 2.  **User Interface (Console-Based):**
 *     *   Present a main menu with options:
 *         1.  Display Menu
 *         2.  Place New Order
 *         3.  Process Next Order
 *         4.  View Order Queue
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read user input for menu choices and order details.
 * 
 * 3.  **Functionality:**
 *     *   **Display Menu:** List all available menu items with their numbers and prices.
 *     *   **Place New Order:**
 *         *   Prompt the user to select items from the menu by entering item numbers.
 *         *   Allow adding multiple items to a single order.
 *         *   Validate item number input (must be a valid integer within the menu range).
 *         *   Create an `Order` object containing the selected items.
 *         *   Add the new order to the order queue.
 *         *   Provide feedback to the user confirming the order has been placed.
 *     *   **Process Next Order:**
 *         *   Remove the next order from the front of the queue (simulating the kitchen completing it).
 *         *   If the queue is empty, inform the user.
 *         *   If an order is processed, display its details and confirm it's completed.
 *     *   **View Order Queue:**
 *         *   Display the details of all orders currently waiting in the queue *without removing them*.
 *         *   If the queue is empty, inform the user.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options.
 *     *   Use loops as necessary for menu item selection when placing an order.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, confirmations, queue contents).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid item number, non-integer input).
 *     *   Implement robust exception handling using `try-catch` blocks. Handle potential `InputMismatchException` when reading integers and other potential runtime errors (e.g., index out of bounds if validation fails). Include a general catch block at a higher level (e.g., around the main program loop) to catch unexpected exceptions and prevent the program from crashing abruptly.
 * 
 * 6.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public getters/setters where necessary, appropriate constructors).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include comments to explain complex logic.
 *     *   Ensure input validation is performed before processing.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting the main menu. User interaction should guide the flow. Examples:
 * 
 * *   Selecting option 1 displays the menu.
 * *   Selecting option 2 prompts for item numbers, allows multiple selections, and confirms order placement. Invalid item numbers or non-integer input should result in an error message on `System.err` and re-prompting or skipping the invalid input for that item.
 * *   Selecting option 3 processes and displays the next order, or states the queue is empty.
 * *   Selecting option 4 displays the current queue contents, or states the queue is empty.
 * *   Selecting option 5 exits the program.
 * *   Entering an invalid menu choice should print an error to `System.err` and show the menu again.
 * *   Entering non-integer input for the main menu choice should be caught by `try-catch`, print an error to `System.err`, and show the menu again.
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the `RestaurantSystem` as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * **Class Structure and Encapsulation:**
 * *   `MenuItem` and `Order` classes are simple Plain Old Java Objects (POJOs) representing the core entities. They have private fields and public getter methods, adhering to encapsulation. `Order` also includes methods for adding items and calculating the total price.
 * *   `RestaurantSystem` is the main class orchestrating the application logic. It holds the `menu` and `orderQueue` as private fields.
 * 
 * **Data Structures (`List`, `ArrayList`, `Queue`):**
 * *   `menu` is declared as `List<MenuItem>` but initialized as `new ArrayList<>()`. This demonstrates programming to the interface (`List`), while using a concrete implementation (`ArrayList`) for its dynamic array capabilities.
 * *   `Order.items` is also declared as `List<MenuItem>` and initialized as `new ArrayList<>()`, further reinforcing the use of the interface.
 * *   `orderQueue` is declared as `Queue<Order>` and initialized using `new LinkedList<>()`. `LinkedList` is a common and suitable implementation for the `Queue` interface, providing efficient additions to the tail (`offer`) and removals from the head (`poll`).
 * 
 * **Input (`Scanner`):**
 * *   A `Scanner` object is created in the `RestaurantSystem` constructor to read input from `System.in`.
 * *   `scanner.nextInt()` is used to read integer choices and item numbers.
 * *   `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls (although in this specific case, we only use `nextInt` followed by more `nextInt` or program termination, consuming the newline is a good general practice when mixing `nextInt`/`nextDouble` with `nextLine`).
 * 
 * **Control Flow (`switch`, loops):**
 * *   The `run()` method contains a `while` loop that continues until the user chooses to exit (option 5).
 * *   Inside the loop, a `switch` statement is used based on the user's integer choice to call the appropriate method (`displayMenu`, `placeOrder`, etc.).
 * *   The `placeOrder()` method uses a `while` loop to allow the user to add multiple items to a single order.
 * 
 * **Error Handling (`System.err`, `try-catch`):**
 * *   `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, invalid item numbers, or invalid input types.
 * *   `try-catch` blocks are used in multiple places:
 *     *   Around `scanner.nextInt()` calls in `run()` and `placeOrder()` to catch `InputMismatchException` if the user enters non-integer input.
 *     *   Input validation checks (`itemNumber > 0 && itemNumber <= menu.size()`) are performed before accessing menu items to prevent `IndexOutOfBoundsException`.
 *     *   A general `catch (Exception e)` block is included within the main loop in `run()` to handle any unexpected exceptions that might occur during the processing of a valid menu choice.
 *     *   A top-level `try-catch` block wraps the entire `while` loop in `run()` as a final safety net, fulfilling the requirement for "Class-wide exception handling with try-catch blocks". This catches any exception that might propagate out of the loop or its handlers.
 * *   The `finally` block in `run()` ensures the `Scanner` is closed when the program finishes or encounters a critical error, releasing system resources.
 * 
 * **Output (`System.out`):**
 * *   `System.out.println()` is used for all normal program output, including displaying the menu, prompts, order confirmations, and the contents of the order queue.
 * 
 * **Functionality Implementation:**
 * *   `initializeMenu()` populates the `ArrayList` with sample `MenuItem` objects.
 * *   `displayMenu()` iterates through the `menu` list and prints each item.
 * *   `placeOrder()` handles user interaction, input validation within a loop, creates an `Order` object, adds selected items, and uses `orderQueue.offer()` to add the order to the tail of the queue.
 * *   `processNextOrder()` uses `orderQueue.poll()` to retrieve and remove the order at the head of the queue. It handles the case where the queue is empty.
 * *   `viewOrderQueue()` iterates through the `orderQueue` using an enhanced for loop. This loop iterates over the elements *without* removing them, fulfilling the requirement.
 * 
 * **Best Practices:**
 * *   Meaningful names are used (e.g., `placeOrder`, `orderQueue`, `MenuItem`, `getTotalPrice`).
 * *   Comments are included to explain the purpose of classes and methods.
 * *   Input is validated before use.
 * *   Error handling is implemented using `try-catch` and `System.err`.
 * *   The code is structured into logical methods within the `RestaurantSystem` class.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating key programming concepts and best practices expected from an advanced student.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the restaurant menu
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    // Getters
    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the MenuItem.
     */
    @Override
    public String toString() {
        return String.format("%s (%.2f)", name, price);
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1001; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items; // Using List interface, implemented by ArrayList
    private String status;

    /**
     * Constructs a new Order with a unique ID.
     */
    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Use ArrayList internally
        this.status = "Pending";
    }

    /**
     * Adds a menu item to the order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        this.items.add(item);
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        // Return a copy or unmodifiable list to maintain encapsulation
        return new ArrayList<>(items); // Return a copy
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (e.g., when processed)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotalPrice() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    /**
     * Returns a string representation of the Order.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" [").append(status).append("]\n");
        sb.append("  Items:\n");
        if (items.isEmpty()) {
            sb.append("    (No items)\n");
        } else {
            for (MenuItem item : items) {
                sb.append("    - ").append(item).append("\n");
            }
        }
        sb.append(String.format("  Total: %.2f", getTotalPrice()));
        return sb.toString();
    }
}

// Main class for the Restaurant Order Management System
public class RestaurantSystem {

    private List<MenuItem> menu; // Declared as List interface
    private Queue<Order> orderQueue; // Declared as Queue interface
    private Scanner scanner;

    /**
     * Constructs the RestaurantSystem, initializes menu, queue, and scanner.
     */
    public RestaurantSystem() {
        // Initialize menu using ArrayList
        menu = new ArrayList<>();
        initializeMenu();

        // Initialize order queue using LinkedList (common Queue implementation)
        orderQueue = new LinkedList<>();

        scanner = new Scanner(System.in);
    }

    /**
     * Populates the menu with initial items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Fries", 3.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Pizza Slice", 4.50));
        menu.add(new MenuItem("Salad", 7.25));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Management System ---");
        System.out.println("1. Display Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Order Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the list of available menu items.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
    }

    /**
     * Guides the user through placing a new order.
     */
    private void placeOrder() {
        if (menu.isEmpty()) {
            System.err.println("Cannot place order: Menu is empty.");
            return;
        }

        Order newOrder = new Order();
        System.out.println("\n--- Placing New Order ---");
        System.out.println("Enter item numbers to add to the order (0 to finish):");

        while (true) {
            displayMenu(); // Show menu again for convenience
            System.out.print("Enter item number (0 to finish): ");
            int itemNumber = -1;

            try {
                itemNumber = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                continue; // Ask again
            }

            if (itemNumber == 0) {
                break; // Finish placing order
            }

            // Validate item number against menu bounds
            if (itemNumber > 0 && itemNumber <= menu.size()) {
                MenuItem selectedItem = menu.get(itemNumber - 1);
                newOrder.addItem(selectedItem);
                System.out.println("Added: " + selectedItem.getName());
            } else {
                System.err.println("Invalid item number. Please choose from the menu list.");
            }
        }

        if (newOrder.getItems().isEmpty()) {
            System.out.println("No items added. Order cancelled.");
        } else {
            orderQueue.offer(newOrder); // Add order to the queue
            System.out.println("\nOrder #" + newOrder.getOrderId() + " placed successfully!");
            System.out.println(newOrder); // Display the placed order details
        }
    }

    /**
     * Processes the next order in the queue.
     */
    private void processNextOrder() {
        System.out.println("\n--- Processing Next Order ---");
        Order nextOrder = orderQueue.poll(); // Get and remove the head of the queue

        if (nextOrder == null) {
            System.out.println("Order queue is empty. No orders to process.");
        } else {
            nextOrder.setStatus("Completed"); // Update status (optional, for simulation)
            System.out.println("Processing Order #" + nextOrder.getOrderId() + "...");
            System.out.println(nextOrder);
            System.out.println("Order #" + nextOrder.getOrderId() + " completed.");
        }
    }

    /**
     * Displays all orders currently waiting in the queue without removing them.
     */
    private void viewOrderQueue() {
        System.out.println("\n--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("The order queue is empty.");
        } else {
            // Iterate through the queue elements without removing them
            int position = 1;
            for (Order order : orderQueue) {
                System.out.println("Position " + position++ + ":");
                System.out.println(order);
                System.out.println("---"); // Separator
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling wrapping the main loop
        try {
            while (choice != 5) {
                displayMainMenu();
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character
                    scanner.nextLine();

                    switch (choice) {
                        case 1:
                            displayMenu();
                            break;
                        case 2:
                            placeOrder();
                            break;
                        case 3:
                            processNextOrder();
                            break;
                        case 4:
                            viewOrderQueue();
                            break;
                        case 5:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during menu processing
                    System.err.println("An unexpected error occurred during menu processing: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to error stream
                    // Optionally decide whether to break or continue based on severity
                }
            }
        } catch (Exception e) {
            // Top-level catch for any exceptions escaping the main loop handlers
            System.err.println("\nA critical error occurred. The system is shutting down.");
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
