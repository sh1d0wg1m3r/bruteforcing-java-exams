/*
 * Exam Question #785
 * Generated on: 2025-05-12 16:40:17
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Objective:** Design and implement a simple command-line based Task Management System that allows users to add tasks, process tasks from a waiting queue, and view both waiting and completed tasks. This task requires demonstrating proficiency in using various core Java collections, input handling, control flow, and exception handling mechanisms.
 * 
 * **Scenario:** You are building a simplified task processing system. New tasks are added to a waiting list (queue). An operator can then choose to process the next task from the waiting list, moving it to a list of completed tasks. The system should provide options to view the tasks in both lists.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (int). Include a constructor and public getter methods. Implement a meaningful `toString()` method for displaying task details.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<Task>` to store tasks that are waiting to be processed.
 *     *   Use a `java.util.List<Task>` (specifically an `java.util.ArrayList`) to store tasks that have been completed.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Waiting Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **System Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process from an empty queue).
 * 5.  **Input Validation and Error Handling:**
 *     *   Implement input validation for user inputs (e.g., ensuring menu choice is an integer within the valid range, validating task priority).
 *     *   Use `try-catch` blocks for exception handling. Implement "class-wide" exception handling by wrapping the main program loop or critical sections (like input reading and command processing) in `try-catch` blocks to gracefully handle potential runtime errors (e.g., `InputMismatchException`).
 *     *   Handle specific scenarios like trying to process a task when the waiting queue is empty.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation by making fields private and using public methods to access them.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Structure the code clearly into appropriate classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, performing the requested action, and providing feedback using `System.out` for normal operations and `System.err` for errors.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter task priority (integer >= 0): 10
 * Task added to the waiting queue.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Enter task priority (integer >= 0): 20
 * Task added to the waiting queue.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Waiting Tasks ---
 * 1. Task [Priority: 10, Description: Write report]
 * 2. Task [Priority: 20, Description: Prepare presentation]
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task [Priority: 10, Description: Write report]
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Task [Priority: 10, Description: Write report]
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter an integer for your choice.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * **Constraint:** You must use *all* the Java components listed in the requirements (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a cohesive solution.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System, fulfilling all the specified requirements and demonstrating the use of the required Java components and best practices.
 * 
 * 1.  **Task Class:** A `Task` class is defined with `private` fields (`description`, `priority`), a constructor for initialization, and public getter methods. The constructor includes input validation for description and priority, throwing `IllegalArgumentException` for invalid values. A `toString()` method provides a user-friendly representation. This demonstrates encapsulation and basic object-oriented design.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `waitingTasks` is declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen as a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior by default. Methods like `offer()` (to add) and `poll()` (to remove and retrieve) are used, which are standard `Queue` operations.
 *     *   `completedTasks` is declared as `List<Task>` and initialized with `new ArrayList<>()`. This fulfills the requirement to use both the `List` interface and the concrete `ArrayList` implementation. Completed tasks are simply added to this list using `add()`.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`):**
 *     *   A `Scanner` object is used to read input from `System.in`. It's declared as a class field but initialized within the `run()` method using a `try-with-resources` block to ensure it's properly closed.
 *     *   The `displayMenu()` method shows the user the available options.
 *     *   The `run()` method contains a `while` loop that keeps the program running until the user chooses to exit. Inside the loop, the user's integer choice is read, and a `switch` statement is used to direct the program flow to the appropriate method (`addTask`, `processNextTask`, etc.) based on the choice.
 * 
 * 4.  **System Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for all standard output, such as displaying the menu, prompts for input, confirmation messages, and the contents of the task lists.
 *     *   `System.err.println()` is used specifically for error messages, including invalid menu choices, `InputMismatchException` during input reading, errors during task creation (caught from `IllegalArgumentException`), and attempting to process a task from an empty queue.
 * 
 * 5.  **Input Validation and Error Handling (`try-catch`):**
 *     *   Input validation is performed at multiple levels:
 *         *   The `Task` constructor validates description and priority.
 *         *   The `addTask()` method includes a loop with a `try-catch(InputMismatchException)` to ensure the user enters a valid integer for priority, prompting them again if input is invalid or negative.
 *         *   The `run()` method's `switch` statement has a `default` case to catch menu choices outside the valid range (1-5).
 *     *   "Class-wide" exception handling is implemented in the `run()` method. A `try-with-resources` block manages the `Scanner`. Inside this `try`, the main `while` loop runs. Crucially, a `try-catch` block is placed *inside* the `while` loop, surrounding the `scanner.nextInt()` call and the `switch` statement. This catches `InputMismatchException` if the user enters non-integer input for the menu choice and a general `Exception` for any other unexpected runtime errors that might occur within the command processing, preventing the program from crashing and allowing the loop to continue (after consuming the invalid input). The `addTask` method also has a specific `try-catch` for `IllegalArgumentException` originating from the `Task` constructor.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Achieved through private fields and public methods/getters in both `Task` and `TaskManager`.
 *     *   **Meaningful Names:** Variable names (`waitingTasks`, `completedTasks`, `description`, `priority`, `choice`), method names (`addTask`, `processNextTask`, `displayMenu`, `run`), and class names (`Task`, `TaskManager`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points (like consuming the newline after `nextInt()`).
 *     *   **Clean Code Structure:** The code is divided into a dedicated `Task` class and a `TaskManager` class responsible for the application logic and interaction. Methods are kept relatively focused on a single task.
 * 
 * The solution effectively integrates all required components into a functional, albeit simple, application, demonstrating practical understanding of core Java concepts including collections, I/O, control flow, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // Required implementation for List
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner input errors

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private int priority; // Higher number could mean higher priority, or vice versa. Let's assume higher number = higher priority.

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task. Cannot be null or empty.
     * @param priority    The priority level of the task. Must be non-negative.
     * @throws IllegalArgumentException if description is invalid or priority is negative.
     */
    public Task(String description, int priority) {
        // Input validation for Task creation
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 0) {
            throw new IllegalArgumentException("Task priority cannot be negative.");
        }
        this.description = description.trim();
        this.priority = priority;
    }

    /**
     * Gets the task description.
     * @return The description string.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The priority integer.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including priority and description.
     */
    @Override
    public String toString() {
        return String.format("Task [Priority: %d, Description: %s]", priority, description);
    }
}

/**
 * Manages a collection of tasks, supporting adding, processing, and viewing.
 * Uses a Queue for waiting tasks and an ArrayList for completed tasks.
 */
public class TaskManager {

    // Use LinkedList as a Queue implementation for waiting tasks (FIFO behavior by default)
    private Queue<Task> waitingTasks;
    // Use ArrayList as the required List implementation for completed tasks
    private List<Task> completedTasks;
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TaskManager.
     * Initializes the waiting and completed task collections.
     */
    public TaskManager() {
        this.waitingTasks = new LinkedList<>(); // Initialize Queue
        this.completedTasks = new ArrayList<>(); // Initialize ArrayList (as a List)
        // Scanner is initialized later in the run method using try-with-resources
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the process of adding a new task based on user input.
     * Includes input validation and error handling for description and priority.
     */
    private void addTask() {
        // Consume the newline character left by previous scanner.nextInt() or similar
        scanner.nextLine();

        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        int priority = -1;
        boolean validPriorityInput = false;
        // Loop until valid integer input >= 0 is received for priority
        while (!validPriorityInput) {
            System.out.print("Enter task priority (integer >= 0): ");
            try {
                priority = scanner.nextInt();
                if (priority < 0) {
                    System.err.println("Error: Priority cannot be negative. Please try again.");
                } else {
                    validPriorityInput = true; // Input is valid integer and non-negative
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter an integer for priority.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            }
        }
         // Consume the newline character left by scanner.nextInt() after reading priority
        scanner.nextLine();


        try {
            // Attempt to create the Task object, which includes its own validation
            Task newTask = new Task(description, priority);
            // Add the new task to the waiting queue. offer() is preferred over add() for queues.
            waitingTasks.offer(newTask);
            System.out.println("Task added to the waiting queue.");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from the Task constructor
            System.err.println("Error creating task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the waiting queue.
     * If the queue is empty, prints an error message.
     * Moves the processed task to the completed tasks list.
     */
    private void processNextTask() {
        // Check if the waiting queue is empty using isEmpty()
        if (waitingTasks.isEmpty()) {
            System.err.println("No tasks in the waiting queue to process.");
            return;
        }

        // Retrieve and remove the head of the queue. poll() is preferred over remove().
        Task processedTask = waitingTasks.poll();
        // Add the processed task to the list of completed tasks.
        completedTasks.add(processedTask);
        System.out.println("Processed task: " + processedTask);
    }

    /**
     * Displays all tasks currently in the waiting queue.
     * If the queue is empty, prints a message indicating so.
     */
    private void viewWaitingTasks() {
        if (waitingTasks.isEmpty()) {
            System.out.println("Waiting queue is empty.");
            return;
        }
        System.out.println("\n--- Waiting Tasks ---");
        // Iterate through the queue without removing elements
        int index = 1;
        for (Task task : waitingTasks) {
            System.out.println(index++ + ". " + task);
        }
    }

    /**
     * Displays all tasks that have been completed.
     * If the completed list is empty, prints a message indicating so.
     */
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }
        System.out.println("\n--- Completed Tasks ---");
        // Iterate through the completed tasks list
        int index = 1;
        for (Task task : completedTasks) {
            System.out.println(index++ + ". " + task);
        }
    }

    /**
     * The main execution loop for the Task Manager.
     * Handles displaying the menu, reading user input, and dispatching actions.
     * Includes class-wide exception handling for the main interaction loop.
     */
    public void run() {
        // Use try-with-resources to ensure the Scanner is closed automatically
        try (Scanner scanner = new Scanner(System.in)) {
            this.scanner = scanner; // Assign the initialized scanner to the class field
            boolean running = true;

            // Class-wide exception handling wrapping the main interaction loop
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    // Read the user's menu choice
                    choice = scanner.nextInt();

                    // Switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewWaitingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Manager. Goodbye!");
                            running = false; // Set running to false to exit the loop
                            break;
                        default:
                            // Handle choices outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the menu choice
                    System.err.println("Error: Invalid input. Please enter an integer for your choice.");
                    scanner.next(); // Consume the invalid input to prevent an infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions that might occur
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging: e.printStackTrace();
                }
            }
        } // Scanner is automatically closed here by try-with-resources
        catch (Exception e) {
            // This catch block handles exceptions that might occur during Scanner initialization
            // (less likely for System.in, but good practice with try-with-resources).
            System.err.println("An error occurred during application setup: " + e.getMessage());
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application
    }
}
