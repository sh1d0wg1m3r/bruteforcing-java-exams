/*
 * Exam Question #173
 * Generated on: 2025-05-11 22:25:57
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a small team. The system should allow users to add new tasks, complete the oldest pending task, view pending tasks, view completed tasks, and exit the application.
 * 
 * **Functional Requirements:**
 * 
 * 1.  **Add Task:** Allow the user to add a new task by providing a description. New tasks are always added to the list of pending tasks.
 * 2.  **Complete Task:** Allow the user to mark the oldest pending task as completed. The completed task should be moved to a list of completed tasks.
 * 3.  **List Pending Tasks:** Display all tasks that are currently pending, in the order they were added.
 * 4.  **List Completed Tasks:** Display all tasks that have been marked as completed.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be written in Java and strictly adhere to the following:
 * 
 * 1.  Use `java.util.Queue` to manage the **pending tasks**.
 * 2.  Use `java.util.ArrayList` as the concrete implementation for a data structure holding **completed tasks**.
 * 3.  Declare the variable holding completed tasks using the `java.util.List` interface type.
 * 4.  Use `java.util.Scanner` to read user commands and input from the console (`System.in`).
 * 5.  Use a `switch` statement to process different user commands.
 * 6.  Use `System.err` to output error messages (e.g., invalid command, attempting to complete a task when none are pending, invalid input format).
 * 7.  Use `System.out` to output normal messages (e.g., prompts, success messages, task lists).
 * 8.  Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential unexpected errors during the application's execution loop.
 * 9.  Follow best practices:
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement basic input validation (e.g., check for empty task description).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 *     *   Maintain a clean code structure (e.g., separate concerns into different classes if appropriate).
 * 
 * **Input Format:**
 * 
 * Commands are entered on a single line.
 * -   `add <description>`: Adds a new task with the given description. The description can contain spaces.
 * -   `complete`: Marks the oldest pending task as completed.
 * -   `list pending`: Displays pending tasks.
 * -   `list completed`: Displays completed tasks.
 * -   `exit`: Exits the application.
 * 
 * **Expected Output:**
 * 
 * The output should be clear and informative. Error messages should go to `System.err`. Normal messages and lists should go to `System.out`.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Simple Task Management System
 * Available commands: add <description>, complete, list pending, list completed, exit
 * 
 * Enter command: add Buy groceries
 * Task added: Buy groceries
 * 
 * Enter command: add Walk the dog
 * Task added: Walk the dog
 * 
 * Enter command: list pending
 * --- Pending Tasks ---
 * 1. Buy groceries
 * 2. Walk the dog
 * --------------------
 * 
 * Enter command: complete
 * Completed task: Buy groceries
 * 
 * Enter command: list pending
 * --- Pending Tasks ---
 * 1. Walk the dog
 * --------------------
 * 
 * Enter command: list completed
 * --- Completed Tasks ---
 * 1. Buy groceries
 * ----------------------
 * 
 * Enter command: complete
 * Completed task: Walk the dog
 * 
 * Enter command: complete
 * Error: No pending tasks to complete.
 * 
 * Enter command: list pending
 * --- Pending Tasks ---
 * No pending tasks.
 * --------------------
 * 
 * Enter command: list completed
 * --- Completed Tasks ---
 * 1. Buy groceries
 * 2. Walk the dog
 * ----------------------
 * 
 * Enter command: invalid command
 * Error: Unknown command. Please use add, complete, list pending, list completed, or exit.
 * 
 * Enter command: add
 * Error: 'add' command requires a task description.
 * 
 * Enter command: exit
 * Exiting Task Manager.
 * ```
 * 
 * Implement the Java code for this Task Management System.
 *
 * EXPLANATION:
 * The solution implements a Simple Task Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Task`: A simple class encapsulating the data for a single task (description and completion status). It includes a constructor and getter/setter methods, adhering to encapsulation principles. Input validation for the description is included in the constructor.
 *     *   `TaskManager`: This class manages the collections of tasks. It holds a `Queue<Task>` for pending tasks and a `List<Task>` (implemented with `ArrayList`) for completed tasks. Methods like `addTask`, `completeNextTask`, `listPendingTasks`, and `listCompletedTasks` provide the core logic for managing the tasks.
 *     *   `TaskManagementApp`: This is the main application class containing the `main` method. It handles user interaction, reads input using `Scanner`, parses commands, and uses a `switch` statement to delegate actions to the `TaskManager`. It also implements the main `while` loop for the application runtime.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `pendingTasks` field in `TaskManager` is declared as `Queue<Task>` and instantiated as `LinkedList`. `Queue`'s `offer()` method is used to add tasks, and `poll()` is used to retrieve and remove the oldest task for completion, naturally implementing the FIFO requirement for pending tasks.
 *     *   `java.util.ArrayList`: The `completedTasks` field is instantiated as `new ArrayList<>()`. This provides a dynamic array implementation to store completed tasks in the order they were finished.
 *     *   `java.util.List`: The `completedTasks` field is declared with the interface type `List<Task>`, demonstrating programming to interfaces rather than concrete implementations where appropriate.
 *     *   `java.util.Scanner`: An instance of `Scanner` is used in the `main` method of `TaskManagementApp` to read user input from `System.in`. It is properly closed before the application exits.
 *     *   `switch` statement: A `switch` statement in `TaskManagementApp.main` is used to determine which action to perform based on the user's command ("add", "complete", "list", "exit", or default for unknown commands).
 *     *   `System.err`: Used in `TaskManager` for errors like attempting to complete an empty queue, and in `TaskManagementApp` for invalid commands, missing arguments, or the final fallback exception handling.
 *     *   `System.out`: Used for normal output like prompts, task added/completed messages, and displaying the lists of pending and completed tasks.
 *     *   `try-catch` blocks:
 *         *   A `try-catch(IllegalArgumentException)` block is used within `TaskManager.addTask` to catch validation errors originating from the `Task` constructor (e.g., empty description) and report them using `System.err`.
 *         *   A broad `try-catch(Exception e)` block wraps the entire `while` loop and setup code in `TaskManagementApp.main`. This fulfills the "class-wide exception handling" requirement by catching any unexpected runtime exceptions that might occur during the application's main execution flow, printing an error message to `System.err`, and providing a stack trace for debugging.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, accessed via public methods.
 *     *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `inputLine`, `command`) and methods (`addTask`, `completeNextTask`, `listPendingTasks`) are named clearly.
 *     *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific code sections like input parsing or error handling.
 *     *   **Input Validation:** Checks are performed for empty command input, missing descriptions for the `add` command, and invalid arguments for the `list` command. The `Task` constructor validates the description.
 *     *   **Error Handling:** Specific operational errors (like completing from an empty queue) are handled gracefully with `System.err` messages. Unexpected errors are caught by the top-level `try-catch`.
 *     *   **Clean Code Structure:** The problem is broken down into logical classes, each with a specific responsibility. The `main` method focuses on the application loop and input handling, delegating task operations to the `TaskManager`.
 * 
 * The solution effectively integrates the required components to create a functional command-line application, demonstrating an understanding of fundamental Java data structures, control flow, and error handling techniques within a practical scenario.
 */

package com.example.taskmanager; // Example package, adjust as needed

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a simple task with a description and completion status.
 */
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.isCompleted = false; // Tasks are initially not completed
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return True if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Sets the completion status of the task.
     * @param completed The new completion status.
     */
    public void setCompleted(boolean completed) {
        this.isCompleted = completed;
    }

    // Optional: Override toString for easier printing, though not strictly required by problem
    // @Override
    // public String toString() {
    //     return (isCompleted ? "[X] " : "[ ] ") + description;
    // }
}

/**
 * Manages a collection of pending and completed tasks using Queue and List.
 */
class TaskManager {
    // Queue for tasks waiting to be done (FIFO - oldest task first)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed, using List interface type
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            // offer() is preferred over add() for queues as it handles capacity constraints gracefully (though not an issue with LinkedList)
            pendingTasks.offer(newTask);
            System.out.println("Task added: " + description);
        } catch (IllegalArgumentException e) {
            // Use System.err for specific validation errors caught internally
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Completes the next task in the pending queue (the oldest one).
     * If the queue is empty, outputs an error message.
     */
    public void completeNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task taskToComplete = pendingTasks.poll();
        if (taskToComplete != null) {
            taskToComplete.setCompleted(true); // Mark as completed
            completedTasks.add(taskToComplete); // Add to the completed list
            System.out.println("Completed task: " + taskToComplete.getDescription());
        } else {
            // Use System.err for operational errors like trying to complete from an empty queue
            System.err.println("Error: No pending tasks to complete.");
        }
    }

    /**
     * Lists all pending tasks currently in the queue to System.out.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all tasks that have been completed to System.out.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            int index = 1;
            for (Task task : completedTasks) {
                 System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("----------------------");
    }
}

/**
 * Main application class for the Simple Task Management System.
 * Handles user input and interacts with the TaskManager.
 * Includes class-wide exception handling.
 */
public class TaskManagementApp {

    public static void main(String[] args) {
        // Class-wide exception handling wrapping the main execution flow
        try {
            TaskManager taskManager = new TaskManager();
            Scanner scanner = new Scanner(System.in);
            boolean running = true;

            System.out.println("Simple Task Management System");
            System.out.println("Available commands: add <description>, complete, list pending, list completed, exit");

            // Main application loop
            while (running) {
                System.out.print("\nEnter command: ");
                // Read the entire line of input
                String inputLine = scanner.nextLine().trim();

                // Basic input validation: check if input is empty after trimming
                if (inputLine.isEmpty()) {
                    System.err.println("Error: Command cannot be empty.");
                    continue; // Skip the rest of the loop iteration
                }

                // Split the input into command and potentially an argument (the rest of the line)
                // Limit split to 2 parts: command and the rest of the description
                String[] parts = inputLine.split(" ", 2);
                String command = parts[0].toLowerCase(); // Process command case-insensitively
                String argument = parts.length > 1 ? parts[1] : ""; // Get argument if available

                // Use switch statement for flow control based on the command
                switch (command) {
                    case "add":
                        // Validate that an argument (description) was provided for 'add'
                        if (argument.isEmpty()) {
                            System.err.println("Error: 'add' command requires a task description.");
                        } else {
                            taskManager.addTask(argument); // Call TaskManager method
                        }
                        break; // Exit switch case for "add"
                    case "complete":
                        // 'complete' command should not have arguments
                        if (!argument.isEmpty()) {
                             System.err.println("Warning: 'complete' command does not take arguments. Ignoring: " + argument);
                        }
                        taskManager.completeNextTask(); // Call TaskManager method
                        break; // Exit switch case for "complete"
                    case "list":
                         // Handle 'list pending' and 'list completed' sub-commands
                        if (argument.equalsIgnoreCase("pending")) {
                            taskManager.listPendingTasks(); // Call TaskManager method
                        } else if (argument.equalsIgnoreCase("completed")) {
                            taskManager.listCompletedTasks(); // Call TaskManager method
                        } else {
                             // Error for invalid 'list' argument
                             System.err.println("Error: Invalid list command. Use 'list pending' or 'list completed'.");
                        }
                        break; // Exit switch case for "list"
                    case "exit":
                        running = false; // Set flag to exit the main loop
                        System.out.println("Exiting Task Manager.");
                        break; // Exit switch case for "exit"
                    default:
                        // Handle any commands not recognized
                        System.err.println("Error: Unknown command. Please use add, complete, list pending, list completed, or exit.");
                        break; // Exit switch case for default
                }
            }

            scanner.close(); // Close the scanner resource to prevent resource leaks

        } catch (Exception e) {
            // Catch any unexpected exceptions that occur during the application's execution
            // This provides class-wide handling for runtime errors not specifically managed elsewhere
            System.err.println("An unexpected error occurred during application execution:");
            e.printStackTrace(); // Print stack trace for debugging purposes
        }
    }
}
