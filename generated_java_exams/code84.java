/*
 * Exam Question #84
 * Generated on: 2025-05-11 22:10:46
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Printing System Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a basic command-line application to manage a queue of documents waiting to be printed and keep track of completed print jobs. The system should allow users to add new documents to the queue, process the next document in the queue (simulating printing), view the current print queue, and view a history of documents that have been printed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a queue of `Document` objects waiting to be printed.
 *     *   Maintain a list of `Document` objects that have been successfully printed.
 * 2.  **Document Representation:**
 *     *   Create a `Document` class with private fields for `id` (int, unique), `name` (String), and `pages` (int).
 *     *   Include a constructor and public getter methods for its fields.
 *     *   Implement a `toString()` method for easy printing of document details.
 *     *   Generate unique IDs for documents automatically (e.g., using a static counter).
 * 3.  **Print Queue Management:**
 *     *   Create a `PrintQueueManager` class to encapsulate the system logic.
 *     *   It should contain the `Queue` for pending documents and the `List` for completed documents as private fields.
 *     *   Implement methods for:
 *         *   Adding a new document to the queue.
 *         *   Processing (simulating printing) the next document from the queue.
 *         *   Viewing the current documents in the queue.
 *         *   Viewing the history of completed print jobs.
 *         *   Running the main application loop with a user menu.
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user: Add Document, Print Next, View Queue, View History, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 5.  **Error Handling & Validation:**
 *     *   Implement input validation for adding documents (e.g., document name should not be empty, pages should be a positive integer).
 *     *   Use `try-catch` blocks to handle potential runtime errors, such as the user entering non-numeric input when a number is expected (e.g., for menu choice or number of pages).
 *     *   Handle the case where the user tries to print from an empty queue.
 *     *   Use `System.err` to output error messages (e.g., invalid input, empty queue attempts).
 *     *   Use `System.out` for normal program output (menu, prompts, status messages, list contents).
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (brief Javadoc-style comments for classes/methods are sufficient).
 *     *   Ensure the `List` interface is used as the declared type where appropriate (e.g., for the completed jobs list variable).
 *     *   The `try-catch` handling should cover potential exceptions within the main operational logic (demonstrating "class-wide" awareness of potential issues, even if specific catches are local). A `try-catch` around the main user interaction loop is one way to satisfy this.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, perform the requested action, and display relevant output or error messages. Examples:
 * 
 * ```
 * --- Print Queue Management ---
 * 1. Add Document
 * 2. Print Next
 * 3. View Queue
 * 4. View History
 * 5. Exit
 * Enter your choice: 1
 * Enter document name: MyReport.pdf
 * Enter number of pages: 15
 * Document "MyReport.pdf" (15 pages) added to queue.
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: 2
 * Printing: [ID: 1, Name: MyReport.pdf, Pages: 15]
 * Document printed successfully.
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: 3
 * Current Print Queue:
 * [ID: 2, Name: Presentation.pptx, Pages: 30]
 * Queue size: 1
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: 4
 * Completed Print Jobs:
 * [ID: 1, Name: MyReport.pdf, Pages: 15]
 * History size: 1
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: 2
 * Error: The print queue is empty. Nothing to print.
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Print Queue Management ---
 * ...
 * Enter your choice: 1
 * Enter document name:
 * Error: Document name cannot be empty.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of `Document` and `PrintQueueManager` classes.
 * *   Proper use of `Queue` and `List`/`ArrayList`.
 * *   Effective use of `Scanner` for user input.
 * *   Correct logic flow using `switch`.
 * *   Robust input validation and error handling using `try-catch` and `System.err`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Successful demonstration of all required components.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a `PrintQueueManager` class to simulate a document printing system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Document` Class:**
 *     *   Represents a single document with an auto-generated unique `id`, a `name`, and the number of `pages`.
 *     *   Uses a `static` variable `nextId` to ensure each new document gets a unique sequential ID.
 *     *   Provides a constructor to initialize these fields and public getter methods (`getId`, `getName`, `getPages`) following encapsulation principles.
 *     *   The `toString()` method provides a convenient way to display document details.
 * 
 * 2.  **`PrintQueueManager` Class:**
 *     *   **Data Structures:**
 *         *   `private Queue<Document> printQueue;`: A `Queue` is used to store documents waiting to be printed. `java.util.LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a print queue.
 *         *   `private List<Document> completedJobs;`: A `List` is used to store documents after they have been "printed". `java.util.ArrayList` is used as the concrete implementation, providing a dynamic array to store the history. The variable is declared using the `List` interface type, adhering to the principle of programming to interfaces.
 *     *   **`Scanner`:**
 *         *   `private Scanner scanner;`: An instance of `Scanner` is created once in the constructor to read user input throughout the application's lifecycle. It's closed in the `finally` block of the main loop to release system resources.
 *     *   **Methods:**
 *         *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *         *   `addDocument()`: Prompts the user for document details, performs validation (non-empty name, positive pages), handles potential `NumberFormatException` if the user enters non-numeric input for pages using a `try-catch` block, creates a `Document` object, and adds it to the `printQueue` using `offer()`. Output is to `System.out` for success, `System.err` for errors.
 *         *   `printNextDocument()`: Uses `printQueue.poll()` to retrieve and remove the document at the head of the queue. If the queue is empty, `poll()` returns `null`, which is checked to print an error message to `System.err`. If a document is retrieved, its details are printed to `System.out`, and the document is added to the `completedJobs` `List` using `add()`.
 *         *   `viewPrintQueue()`: Iterates through the `printQueue` (using a for-each loop, which doesn't remove elements) and prints each document's details to `System.out`. Handles the case of an empty queue.
 *         *   `viewCompletedJobs()`: Iterates through the `completedJobs` `List` and prints each document's details to `System.out`. Handles the case of an empty list.
 *         *   `runSystem()`: Contains the main application loop (`while(running)`). It repeatedly displays the menu, reads the user's choice, and uses a `switch` statement to call the appropriate method based on the choice.
 *     *   **Input Handling in `runSystem()`:**
 *         *   A `try-catch(InputMismatchException)` block is specifically used around `scanner.nextInt()` to handle cases where the user enters non-integer input for the menu choice. `scanner.nextLine()` is called in the `catch` and `finally` blocks to consume the invalid input or the remaining newline character after reading the integer, preventing input issues in subsequent loop iterations. Error messages are printed to `System.err`.
 *     *   **Class-wide Exception Handling:**
 *         *   The entire `while` loop within `runSystem()` is wrapped in a `try-catch(Exception e)` block. This demonstrates a form of "class-wide" handling by catching any unexpected `Exception` that might occur during the system's main operation loop, printing an error message and stack trace to `System.err` before the system potentially terminates or recovers (in this case, it prints and then the `finally` block runs).
 *     *   **`finally` Block:**
 *         *   A `finally` block is used in `runSystem()` to ensure that the `scanner.close()` method is called regardless of whether the loop completes normally (user chooses exit) or an unexpected exception occurs. This is crucial for resource management.
 *     *   **`main` Method:**
 *         *   The entry point of the application. It simply creates an instance of `PrintQueueManager` and calls its `runSystem()` method to start the application.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** All data fields (`printQueue`, `completedJobs`, `scanner` in `PrintQueueManager`, and `id`, `name`, `pages` in `Document`) are `private`. Access is controlled through public methods.
 *     *   **Naming:** Variable and method names are descriptive (`addDocument`, `completedJobs`, `viewPrintQueue`).
 *     *   **Comments:** Basic Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific logic (like using `LinkedList` for `Queue`).
 *     *   **Input Validation:** Checks for empty name and non-positive pages are included in `addDocument()`.
 *     *   **Error Handling:** `try-catch` is used for `InputMismatchException` (menu choice), `NumberFormatException` (pages input), and a general `Exception` catch for the main loop. `System.err` is used exclusively for error reporting.
 *     *   **List Interface:** The `completedJobs` variable is declared as `List<Document>`, demonstrating the use of the interface type.
 *     *   **Clean Code:** The code is organized into logical methods within the `PrintQueueManager` class, separating concerns (displaying menu, adding, printing, viewing).
 * 
 * This solution effectively uses all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating understanding of data structures, object-oriented principles, and robust input/error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a document with an ID, name, and number of pages.
class Document {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String name;
    private int pages;

    /**
     * Constructs a new Document object.
     * Automatically assigns a unique ID.
     *
     * @param name The name of the document.
     * @param pages The number of pages in the document.
     */
    public Document(String name, int pages) {
        this.id = nextId++; // Assign current ID and increment for next document
        this.name = name;
        this.pages = pages;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getPages() {
        return pages;
    }

    /**
     * Returns a string representation of the Document.
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", Name: " + name + ", Pages: " + pages + "]";
    }
}

// Manages the print queue and completed jobs history.
public class PrintQueueManager {
    private Queue<Document> printQueue; // Queue for documents waiting to be printed
    private List<Document> completedJobs; // List for documents that have been printed
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new PrintQueueManager.
     * Initializes the queue, list, and scanner.
     */
    public PrintQueueManager() {
        // Using LinkedList as a Queue implementation
        this.printQueue = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedJobs = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Queue Management ---");
        System.out.println("1. Add Document");
        System.out.println("2. Print Next");
        System.out.println("3. View Queue");
        System.out.println("4. View History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new document to the print queue based on user input.
     * Includes input validation and exception handling.
     */
    private void addDocument() {
        System.out.print("Enter document name: ");
        // Consume the newline character left by previous nextInt/readLine
        // Or use nextLine exclusively and trim/parse carefully
        scanner.nextLine(); // Consume potentially left-over newline

        String name = scanner.nextLine().trim(); // Read full line and trim whitespace
        if (name.isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }

        System.out.print("Enter number of pages: ");
        int pages = -1;
        try {
            pages = scanner.nextInt(); // This might throw InputMismatchException
            if (pages <= 0) {
                System.err.println("Error: Number of pages must be a positive integer.");
                return;
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for pages. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            return;
        } finally {
             // Ensure the newline is consumed after reading the integer,
             // whether successful or not, before the next nextLine() call.
             // This is crucial if you mix nextInt() and nextLine().
             // A safer approach is often to read the line and parse it.
             // Let's stick to nextLine() and parse for robustness.
        }

        // Re-implementing input reading using nextLine() and parsing
        System.out.print("Enter document name: ");
        String docName = scanner.nextLine().trim();
        if (docName.isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }

        System.out.print("Enter number of pages: ");
        int docPages = -1;
        String pagesInput = scanner.nextLine(); // Read pages as a line
        try {
            docPages = Integer.parseInt(pagesInput); // Parse the line
            if (docPages <= 0) {
                System.err.println("Error: Number of pages must be a positive integer.");
                return;
            }
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for pages. Please enter a number.");
            return;
        }


        Document newDocument = new Document(docName, docPages);
        printQueue.offer(newDocument); // Add to the end of the queue
        System.out.println("Document \"" + docName + "\" (" + docPages + " pages) added to queue.");
    }

    /**
     * Processes (simulates printing) the next document in the queue.
     * Moves the document from the queue to the completed jobs list.
     * Handles the case of an empty queue.
     */
    private void printNextDocument() {
        Document documentToPrint = printQueue.poll(); // Retrieve and remove the head of the queue

        if (documentToPrint == null) {
            System.err.println("Error: The print queue is empty. Nothing to print.");
        } else {
            System.out.println("Printing: " + documentToPrint);
            completedJobs.add(documentToPrint); // Add to the completed list
            System.out.println("Document printed successfully.");
        }
    }

    /**
     * Displays the documents currently waiting in the print queue.
     */
    private void viewPrintQueue() {
        System.out.println("\nCurrent Print Queue:");
        if (printQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Document doc : printQueue) {
                System.out.println(index++ + ". " + doc);
            }
            System.out.println("Queue size: " + printQueue.size());
        }
    }

    /**
     * Displays the history of completed print jobs.
     */
    private void viewCompletedJobs() {
        System.out.println("\nCompleted Print Jobs:");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list
            for (int i = 0; i < completedJobs.size(); i++) {
                System.out.println((i + 1) + ". " + completedJobs.get(i));
            }
            System.out.println("History size: " + completedJobs.size());
        }
    }

    /**
     * Runs the main application loop, displaying the menu and processing user choices.
     * Includes a class-wide try-catch block for general exceptions during the loop.
     */
    public void runSystem() {
        boolean running = true;
        try { // Class-wide exception handling for the main loop
            while (running) {
                displayMenu();
                int choice = -1; // Initialize choice

                try {
                    choice = scanner.nextInt(); // Read the integer choice
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    // Consume the rest of the line after reading the integer
                    // This prevents issues with nextLine() in subsequent calls
                    scanner.nextLine();
                }


                switch (choice) {
                    case 1:
                        addDocument();
                        break;
                    case 2:
                        printNextDocument();
                        break;
                    case 3:
                        viewPrintQueue();
                        break;
                    case 4:
                        viewCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Print Queue Management. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the system run
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the system exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the Print Queue Management system.
     */
    public static void main(String[] args) {
        PrintQueueManager manager = new PrintQueueManager();
        manager.runSystem();
    }
}
