/*
 * Exam Question #985
 * Generated on: 2025-05-12 17:08:45
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based Task Manager for a small team. The system should allow users to manage pending tasks and keep a history of completed tasks. Tasks are processed in a First-In, First-Out (FIFO) manner from the pending list.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structure:**
 *     *   Represent tasks using a simple `Task` class with a private `String` field for the description and a public getter method.
 *     *   Use a `java.util.Queue` to store tasks that are pending and need to be completed. Tasks should be added to the rear and removed from the front.
 *     *   Use a `java.util.List` (specifically a `java.util.ArrayList`) to store tasks that have been completed.
 * 
 * 2.  **User Interface:**
 *     *   Implement a menu-driven interface using `java.util.Scanner` to read user input from the console.
 *     *   The menu should offer the following options:
 *         1.  Add New Task
 *         2.  Complete Next Pending Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 * 
 * 3.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description and add it to the pending task queue.
 *     *   **Complete Next Pending Task:** Remove the task at the front of the pending queue and add it to the completed tasks list.
 *     *   **View Pending Tasks:** Display all tasks currently in the pending queue without removing them.
 *     *   **View Completed Tasks:** Display all tasks in the completed tasks list.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Control Flow and Output:**
 *     *   Use a `switch` statement to handle the different menu choices.
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to complete a task when the queue is empty).
 * 
 * 5.  **Error Handling:**
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential `InputMismatchException` when reading the menu choice to ensure the program doesn't crash on non-integer input. Place this handling around the input reading and processing loop.
 *     *   Implement checks for logical errors, such as attempting to complete a task when the pending queue is empty. Use `if` statements and `System.err` for these cases.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain key parts of the code.
 *     *   Perform basic input validation (e.g., handling empty task descriptions, handling invalid menu choices).
 *     *   Structure the code cleanly with separate methods for different operations.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input for menu choices, perform the corresponding actions, and print appropriate messages or lists to the console. Error messages for invalid operations or input should be printed to the standard error stream. The program should continue until the user selects the 'Exit' option.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added to pending queue.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task added to pending queue.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. - Write report
 * 2. - Prepare presentation
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Completed task: "Write report"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. - Prepare presentation
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. - Write report
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Completed task: "Prepare presentation"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * No pending tasks to complete.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Complete Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Manager application, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) that encapsulates the task's description (`private String description`). It provides a public getter (`getDescription()`) following encapsulation principles. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **Collections (`Queue` and `List`/`ArrayList`):**
 *     *   A `java.util.Queue<Task>` named `pendingTasks` is used to store tasks that are waiting to be processed. The `LinkedList` class is chosen as a concrete implementation of the `Queue` interface, as it efficiently supports adding elements to the end (`offer()`) and removing from the beginning (`poll()`), which are characteristic queue operations. This ensures tasks are handled in a FIFO manner.
 *     *   A `java.util.List<Task>` named `completedTasks` is used to store tasks once they are finished. `ArrayList` is chosen as the concrete implementation. It's suitable for storing a history where elements are added (efficiently at the end) and iterated over, but random access or frequent middle insertions/deletions are not the primary use case here. The variable is declared as `List` to program to the interface, a common best practice.
 * 
 * 3.  **User Input (`Scanner`):** A `java.util.Scanner` object reads user input from `System.in`. It's used to read the menu choice (`nextInt()`) and the task description (`nextLine()`). Note the crucial `scanner.nextLine()` call after `scanner.nextInt()` in the `addTask` method and before the main input reading loop's `scanner.nextInt()`. This consumes the leftover newline character from the previous `nextInt()` call, preventing issues when subsequently reading a full line with `nextLine()`.
 * 
 * 4.  **Control Flow (`switch`):** The `switch` statement in the `run()` method is used to direct the program flow based on the user's integer menu choice. Each `case` corresponds to a menu option and calls the appropriate private method (`addTask`, `completeNextTask`, etc.).
 * 
 * 5.  **Output (`System.out` and `System.err`):**
 *     *   `System.out.println()` is used for standard output like displaying the menu, prompts, confirmation messages, and the lists of tasks.
 *     *   `System.err.println()` is used specifically for error messages, such as when the user enters invalid input or attempts an invalid operation (like completing a task when the queue is empty). Using `System.err` is good practice for separating error output from normal program output.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the `scanner.nextInt()` call and the `switch` statement within the main `run()` loop. This provides class-wide exception handling for the core user interaction part of the application.
 *     *   It specifically catches `InputMismatchException`, which is thrown by `scanner.nextInt()` if the user enters something that is not a valid integer. In the `catch` block, an error message is printed to `System.err`, and `scanner.next()` is called to consume the invalid input token, preventing an infinite loop. The `choice` variable is reset to an invalid value to ensure the loop continues and the menu is redisplayed.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors during the execution of the try block, printing an error message and the stack trace to `System.err` for debugging.
 * 
 * 7.  **Error Handling (Logical):**
 *     *   The `completeNextTask()` method includes an explicit `if (pendingTasks.isEmpty())` check before calling `poll()`. If the queue is empty, it prints an informative error message to `System.err` and returns, preventing a `NoSuchElementException` that `poll()` *might* throw (though `poll()` is designed to return `null` on empty, checking `isEmpty` first and using `System.err` is clearer for user feedback).
 *     *   The `addTask()` method checks if the entered description is empty and prints an error if it is.
 * 
 * 8.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManagerApp` are `private`, with access controlled by public methods where necessary.
 *     *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `description`, `choice`), methods (`addTask`, `completeNextTask`, `displayMenu`, `run`), and classes (`Task`, `TaskManagerApp`) have names that clearly indicate their purpose.
 *     *   **Comments:** Comments are included to explain the purpose of classes, fields, methods, and crucial code sections (like the `scanner.nextLine()` call).
 *     *   **Input Validation:** Checks for empty task descriptions and handles non-integer menu input.
 *     *   **Clean Structure:** The code is organized into a `Task` class and a `TaskManagerApp` class with dedicated methods for each operation, improving readability and maintainability.
 * 
 * This solution effectively integrates the required Java components and demonstrates robust handling of user input and potential errors within a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

/**
 * Represents a single task with a description.
 */
class Task {
    private String description; // Private field for encapsulation

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a user-friendly string representation of the task.
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        return "- " + description;
    }
}

/**
 * Manages a list of pending and completed tasks via a console interface.
 */
public class TaskManagerApp {

    // Queue for tasks waiting to be done (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManagerApp, initializing task collections and scanner.
     */
    public TaskManagerApp() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Pending Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts the user for a task description and adds it to the pending queue.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine().trim(); // Read the whole line and remove leading/trailing spaces

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if description is empty
        }

        Task newTask = new Task(description);
        pendingTasks.offer(newTask); // Add task to the end of the queue (FIFO)
        System.out.println("Task added to pending queue.");
    }

    /**
     * Completes the task at the front of the pending queue and moves it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void completeNextTask() {
        // Check if the queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to complete.");
            return; // Exit the method if queue is empty
        }

        Task completedTask = pendingTasks.poll(); // Remove task from the front of the queue
        completedTasks.add(completedTask); // Add completed task to the list
        System.out.println("Completed task: \"" + completedTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates without removing elements.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            int index = 1;
            // Iterate through the queue elements
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            int index = 1;
            // Iterate through the list elements
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling for input errors.
     */
    public void run() {
        int choice = -1;
        // Continue loop until user chooses to exit (option 5)
        while (choice != 5) {
            displayMenu();
            try {
                // Read the integer choice from the user
                choice = scanner.nextInt();

                // Use switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        completeNextTask(); // Call method to complete the next task
                        break;
                    case 3:
                        viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to an invalid value to continue the loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * The main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run(); // Start the main application loop
    }
}
