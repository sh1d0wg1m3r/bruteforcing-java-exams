/*
 * Exam Question #245
 * Generated on: 2025-05-11 22:38:30
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Priority Task Management System
 * 
 * **Objective:** Design and implement a console-based Priority Task Management System that allows users to add tasks with different priority levels, process tasks based on priority, and view task lists. This task requires demonstrating proficiency in using various Java collections, control flow structures, input/output, and exception handling.
 * 
 * **Scenario:** You are building a simple task management system where tasks can be designated as either "HIGH" or "LOW" priority. The system should always prioritize processing HIGH priority tasks before LOW priority tasks. A history of all tasks ever added should also be maintained.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with appropriate fields (e.g., ID, description, priority, completion status) and methods (constructor, getters, `toString`).
 * 2.  **Task Processor:** Create a `PriorityTaskProcessor` class that manages the tasks.
 *     *   It must internally use a `Queue` for HIGH priority pending tasks.
 *     *   It must internally use a separate `Queue` for LOW priority pending tasks.
 *     *   It must internally use an `ArrayList` to store a history of *all* tasks ever added (both pending and completed).
 *     *   It must have a method `addTask(String description, String priority)` that validates input, creates a `Task` object, adds it to the `allTasksEverAdded` list, and adds it to the appropriate priority queue.
 *     *   It must have a method `processNextTask()` that retrieves and "completes" the next task. It should check the HIGH priority queue first. If empty, it checks the LOW priority queue. If both are empty, it should indicate that no tasks are available. The completion status of the task object in the `allTasksEverAdded` list should be updated.
 *     *   It must have a method `viewAllTasks()` that returns a `List` of all tasks ever added.
 *     *   It must have a method `viewPendingTasks()` that returns a `List` of all tasks currently in the HIGH and LOW priority queues.
 * 3.  **Main Application:** Create a main class (e.g., `TaskApp`) with a `main` method to run the application.
 *     *   Use `Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface using a `switch` statement for the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View All Tasks History
 *         4.  View Pending Tasks
 *         5.  Exit
 *     *   Use `System.out` for displaying the menu, prompts, task details, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid task priority, empty queue when trying to process).
 *     *   Implement input validation for task priority ("HIGH" or "LOW", case-insensitive). Report invalid priority using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main application loop or critical operation calls within the loop to catch potential unexpected runtime errors and report them using `System.err`. Handle specific expected conditions (like empty queues) within the `PriorityTaskProcessor` methods and report them via return values or specific messages printed by the calling code in `main`.
 * 
 * **Best Practices:**
 * 
 * *   Employ proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (Javadoc style for classes/methods is recommended).
 * *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and print appropriate messages or task lists to `System.out` or error messages to `System.err`.
 * 
 * Example Interaction:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write Exam Question
 * Enter priority (HIGH/LOW): HIGH
 * Task added: Task{id=1, description='Write Exam Question', priority='HIGH', isCompleted=false}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Grade Exams
 * Enter priority (LOW): LOW
 * Task added: Task{id=2, description='Grade Exams', priority='LOW', isCompleted=false}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 4
 * Pending Tasks:
 * Task{id=1, description='Write Exam Question', priority='HIGH', isCompleted=false}
 * Task{id=2, description='Grade Exams', priority='LOW', isCompleted=false}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task{id=1, description='Write Exam Question', priority='HIGH', isCompleted=true}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 4
 * Pending Tasks:
 * Task{id=2, description='Grade Exams', priority='LOW', isCompleted=false}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task{id=2, description='Grade Exams', priority='LOW', isCompleted=true}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 2
 * No tasks to process.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 3
 * All Tasks History:
 * Task{id=1, description='Write Exam Question', priority='HIGH', isCompleted=true}
 * Task{id=2, description='Grade Exams', priority='LOW', isCompleted=true}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks History
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a Priority Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) representing a task. It has private fields (`id`, `description`, `priority`, `isCompleted`) ensuring encapsulation. Public getter methods provide controlled access to the task's state. The `setCompleted` method allows modification of the completion status. The `toString` method provides a convenient string representation for printing.
 * 
 * 2.  **`PriorityTaskProcessor` Class:** This is the core logic class.
 *     *   It uses two `Queue<Task>` instances (`highPriorityQueue` and `lowPriorityQueue`), implemented by `LinkedList`, to manage tasks waiting to be processed according to their priority. `offer()` is used for adding tasks to the end of the queue, and `poll()` is used for removing tasks from the front (head) of the queue for processing.
 *     *   It uses an `List<Task>` variable typed as the interface `List` but instantiated as an `ArrayList` (`allTasksEverAdded`) to store a complete history of all tasks ever created. This demonstrates using the interface type for flexibility while using a concrete implementation.
 *     *   `nextTaskId` ensures each task gets a unique ID.
 *     *   `addTask`: Validates the description and priority input. If valid, it creates a new `Task` object, adds it to the `allTasksEverAdded` list, and then adds the *same* `Task` object reference to the appropriate priority queue using `offer()`. This is efficient and ensures that when the task object is modified (e.g., marked as completed), the change is reflected in both the queue (until processed) and the history list.
 *     *   `processNextTask`: Implements the priority logic by checking `highPriorityQueue.poll()` first. If it's empty, it then checks `lowPriorityQueue.poll()`. `poll()` returns the task or `null` if the queue is empty, which is handled. If a task is retrieved, its `isCompleted` status is updated.
 *     *   `viewAllTasks`: Simply returns the `allTasksEverAdded` list, which is typed as `List<Task>`, fulfilling the `List` interface requirement for a method return type.
 *     *   `viewPendingTasks`: Creates a *new* `ArrayList<Task>` (`pendingTasks`) and adds all elements from both queues into this new list using `addAll()`. This demonstrates using `ArrayList` to collect elements from other collections (the queues) and returning the result as a `List`. It provides a snapshot of currently pending tasks without modifying the queues.
 * 
 * 3.  **`TaskApp` Class (Main):**
 *     *   The `main` method sets up the `Scanner` for input and the `PriorityTaskProcessor`.
 *     *   A `while(true)` loop runs the main application menu.
 *     *   The **class-wide `try-catch(Exception e)`** block wraps the entire `while` loop. This provides a safety net to catch any unexpected runtime exceptions that might occur anywhere within the application's main execution flow, preventing the program from crashing abruptly. It prints the error message and stack trace to `System.err`.
 *     *   Inside the `try` block, user input is read using `scanner.nextLine()`.
 *     *   A nested `try-catch(NumberFormatException)` is used specifically for parsing the user's menu choice, preventing a crash if non-numeric input is entered.
 *     *   A `switch` statement handles the different menu options (`case 1` through `case 5`).
 *     *   **`System.out`** is used extensively for printing the menu, prompts, success messages, and task details.
 *     *   **`System.err`** is used for printing specific error messages, such as invalid menu choices (in the `default` case of the `switch`) and input validation errors reported by the `addTask` method. The outer `catch` block also prints to `System.err`.
 *     *   Input validation for priority is done within the `addTask` method, reporting errors via `System.err`.
 *     *   The `finally` block ensures the `scanner.close()` method is called, releasing the system resource, regardless of whether the loop exits normally or an exception is caught.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating object-oriented design, collection usage, input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // "HIGH" or "LOW"
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     * @param priority The priority of the task ("HIGH" or "LOW").
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Tasks are initially not completed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // --- Setter for completion status ---
    public void setCompleted(boolean completed) {
        isCompleted = completed;
    }

    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", priority='" + priority + '\'' +
               ", isCompleted=" + isCompleted +
               '}';
    }
}

/**
 * Manages tasks using priority queues and maintains a history.
 */
class PriorityTaskProcessor {
    // Queue for high priority tasks
    private Queue<Task> highPriorityQueue;
    // Queue for low priority tasks
    private Queue<Task> lowPriorityQueue;
    // List to store all tasks ever added (history)
    private List<Task> allTasksEverAdded;
    private int nextTaskId;

    /**
     * Constructs a PriorityTaskProcessor.
     * Initializes queues, history list, and task ID counter.
     */
    public PriorityTaskProcessor() {
        this.highPriorityQueue = new LinkedList<>(); // LinkedList implements Queue
        this.lowPriorityQueue = new LinkedList<>();  // LinkedList implements Queue
        this.allTasksEverAdded = new ArrayList<>();  // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Validates description and priority. Adds to history and appropriate queue.
     * @param description The task description.
     * @param priorityStr The priority string ("HIGH" or "LOW").
     * @return true if task was added successfully, false otherwise (due to validation).
     */
    public boolean addTask(String description, String priorityStr) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }

        String priority = priorityStr.trim().toUpperCase();
        if (!priority.equals("HIGH") && !priority.equals("LOW")) {
            System.err.println("Error: Invalid priority. Please enter 'HIGH' or 'LOW'.");
            return false;
        }

        // Create task
        Task newTask = new Task(nextTaskId++, description.trim(), priority);

        // Add to history list
        allTasksEverAdded.add(newTask);

        // Add to appropriate queue
        if (priority.equals("HIGH")) {
            highPriorityQueue.offer(newTask); // offer is preferred over add for queues
        } else { // priority is LOW
            lowPriorityQueue.offer(newTask);
        }

        System.out.println("Task added: " + newTask);
        return true;
    }

    /**
     * Processes the next available task based on priority (HIGH then LOW).
     * Marks the task as completed.
     * @return The processed Task object, or null if no tasks were available.
     */
    public Task processNextTask() {
        Task taskToProcess = null;

        // Check high priority queue first
        if (!highPriorityQueue.isEmpty()) {
            taskToProcess = highPriorityQueue.poll(); // poll retrieves and removes the head
        } else if (!lowPriorityQueue.isEmpty()) {
            // If high priority queue is empty, check low priority queue
            taskToProcess = lowPriorityQueue.poll();
        }

        // If a task was found, process it
        if (taskToProcess != null) {
            // Find the task in the history list and mark it as completed
            // Note: Since we added the same Task object instance to both the history list
            // and the queue, updating the object here updates it in the list as well.
            taskToProcess.setCompleted(true);
            System.out.println("Processed task: " + taskToProcess);
        } else {
            System.out.println("No tasks to process.");
        }

        return taskToProcess;
    }

    /**
     * Returns a list of all tasks ever added to the system.
     * @return A List containing all Task objects.
     */
    public List<Task> viewAllTasks() {
        return allTasksEverAdded;
    }

    /**
     * Returns a list of tasks currently pending in the queues.
     * @return A List containing pending Task objects.
     */
    public List<Task> viewPendingTasks() {
        // Create a new list to collect pending tasks
        List<Task> pendingTasks = new ArrayList<>(); // Using ArrayList to collect queue contents

        // Add all tasks from high priority queue
        pendingTasks.addAll(highPriorityQueue);

        // Add all tasks from low priority queue
        pendingTasks.addAll(lowPriorityQueue);

        return pendingTasks;
    }
}

/**
 * Main application class for the Priority Task Management System.
 */
public class TaskApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PriorityTaskProcessor processor = new PriorityTaskProcessor();

        System.out.println("--- Priority Task Management System ---");

        // Class-wide try-catch block for general exception handling
        try {
            while (true) {
                printMenu();
                System.out.print("Enter your choice: ");

                String choiceInput = scanner.nextLine();
                int choice = -1; // Default to an invalid choice

                try {
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    // Handled by the default case in the switch
                }

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (HIGH/LOW): ");
                        String priority = scanner.nextLine();
                        processor.addTask(description, priority);
                        break;

                    case 2:
                        processor.processNextTask();
                        break;

                    case 3:
                        List<Task> allTasks = processor.viewAllTasks();
                        System.out.println("\n--- All Tasks History ---");
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks have been added yet.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("-------------------------\n");
                        break;

                    case 4:
                        List<Task> pendingTasks = processor.viewPendingTasks();
                        System.out.println("\n--- Pending Tasks ---");
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks are currently pending.");
                        } else {
                            // Iterating over a List returned from viewPendingTasks
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 5:
                        System.out.println("Exiting Task Management System.");
                        return; // Exit the main method

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed even if an exception occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks History");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Exit");
    }
}
