/*
 * Exam Question #118
 * Generated on: 2025-05-11 22:17:10
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Automated Task Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple console-based Automated Task Processing System. This system should allow users to add different types of tasks to a queue for processing and view the status of tasks.
 * 
 * The system must manage tasks in a First-In, First-Out (FIFO) manner for processing. Once a task is processed (either successfully or with a simulated failure), it should be moved to a history list for later review.
 * 
 * **Core Functionality:**
 * 
 * 1.  **Add Task:** Allow users to add two types of tasks: "Data Processing Task" and "Reporting Task". Each task must have a unique ID and a description provided by the user. Newly added tasks are placed in a queue with a status of `PENDING`.
 * 2.  **Process Next Task:** Take the oldest task from the queue, simulate its processing, update its status (to `COMPLETED` or `FAILED`), and move it to a history list. Simulate a potential failure during processing for at least one task type.
 * 3.  **View Pending Tasks:** Display all tasks currently waiting in the processing queue, in the order they will be processed.
 * 4.  **View Processed History:** Display all tasks that have been processed, including their final status.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate advanced understanding of Java concepts by utilizing **ALL** of the following components:
 * 
 * *   `java.util.Queue`: To manage tasks waiting for processing in FIFO order.
 * *   `java.util.ArrayList`: As the concrete implementation for storing the history of processed tasks.
 * *   `java.util.List`: As the declared type for the processed task history variable, demonstrating polymorphism.
 * *   `java.util.Scanner`: To read user commands and input (like task descriptions) from the console.
 * *   `switch` statement: To handle the different menu options/user commands.
 * *   `System.err`: To print error messages (e.g., invalid input, task processing failures).
 * *   `System.out`: To print normal output (menu, prompts, success messages, task details).
 * *   Class-wide exception handling with `try-catch` blocks: Implement exception handling for potential issues such as invalid user input, errors during task processing, or unexpected system errors. Include a broad `try-catch` block around the main application loop.
 * 
 * **Design Requirements:**
 * 
 * *   Use **proper encapsulation**: Define classes with private fields and public methods (getters/setters where appropriate).
 * *   Use **meaningful variable and method names**.
 * *   Include **appropriate comments and documentation** (e.g., Javadoc-style comments for classes and methods).
 * *   Implement **input validation** where necessary (e.g., checking for empty task descriptions, handling non-integer menu input).
 * *   Implement **proper error handling** using `try-catch` and `System.err`.
 * *   Structure your code clearly using classes and methods. Consider using inheritance or interfaces for different task types.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's numerical input, it should perform the corresponding action. Output should clearly indicate successful operations, task details, and error conditions using `System.out` and `System.err` respectively.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add Data Processing Task
 * 2. Add Reporting Task
 * 3. Process Next Task
 * 4. View Pending Tasks
 * 5. View Processed Task History
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Process customer data batch
 * DataProcessingTask added to the queue with ID 1
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Tasks ---
 * 1. Task ID: 1, Type: DataProcessingTask, Status: PENDING, Description: 'Process customer data batch'
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * Attempting to process Task ID 1...
 * Processing Data Task ID 1: Process customer data batch
 * Data Task ID 1 completed successfully.
 * Task ID 1 moved to history with status COMPLETED
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Processed Task History ---
 * 1. Task ID: 1, Type: DataProcessingTask, Status: COMPLETED, Description: 'Process customer data batch'
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number between 1 and 6.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * No pending tasks to process.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements an Automated Task Processing System using the required Java components and best practices.
 * 
 * 1.  **Task Hierarchy:**
 *     *   An `abstract class Task` defines common properties (`id`, `description`, `status`) and an abstract `process()` method. This promotes code reuse and enforces that all tasks must define their processing logic.
 *     *   `TaskStatus` enum clearly defines the possible states of a task.
 *     *   `TaskProcessingException` is a custom exception for handling errors specifically related to task processing.
 *     *   `DataProcessingTask` and `ReportingTask` extend `Task` and provide concrete implementations for the `process()` method, including simulated work and potential failures.
 * 
 * 2.  **Data Structures:**
 *     *   `Queue<Task> pendingTasks = new LinkedList<>();`: A `LinkedList` is used as a concrete implementation of the `Queue` interface. This correctly models the FIFO requirement for tasks waiting to be processed. `offer()` and `poll()` methods are used for adding and removing elements from the queue's head.
 *     *   `List<Task> processedTasksHistory = new ArrayList<>();`: An `ArrayList` is used as the concrete implementation for `processedTasksHistory`. The variable is declared using the `List` interface, demonstrating polymorphism and allowing for easy iteration and storage of processed tasks regardless of their specific type (`DataProcessingTask` or `ReportingTask`).
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner scanner = new Scanner(System.in);`: Used to read user input from the console.
 *     *   `displayMenu()`: A simple method to print the available options using `System.out`.
 *     *   `run()` method: Contains the main application loop (`while(running)`).
 *     *   `switch (choice)`: Handles the user's menu selection, directing execution to the appropriate method (`addTask`, `processNextTask`, `viewPendingTasks`, `viewProcessedHistory`, or exiting).
 *     *   Input validation: A `try-catch(InputMismatchException)` block is used when reading the menu choice to handle non-integer input gracefully, printing an error to `System.err` and consuming the invalid input. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls. Task description input is validated to ensure it's not empty.
 * 
 * 4.  **Task Management Logic:**
 *     *   `addTask(String taskType)`: Creates a new `Task` object based on the type string and user-provided description, then adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`:
 *         *   Retrieves the next task from the queue using `poll()`.
 *         *   Updates the task status to `PROCESSING`.
 *         *   Calls the task's `process()` method within a `try-catch` block to handle potential `TaskProcessingException` or other unexpected `Exception`s during processing.
 *         *   Uses a `finally` block to ensure that the task is *always* added to the `processedTasksHistory` list after processing, regardless of whether it succeeded or failed.
 *     *   `viewPendingTasks()`: Creates a temporary `ArrayList` from the `pendingTasks` queue to iterate and display tasks without removing them from the queue. Uses `System.out` for output.
 *     *   `viewProcessedHistory()`: Iterates through the `processedTasksHistory` list (declared as `List`, implemented by `ArrayList`) and displays processed tasks using `System.out`.
 * 
 * 5.  **Error Handling:**
 *     *   Specific `try-catch` blocks are used within `processNextTask` and task `process()` methods to catch `TaskProcessingException` and other potential errors.
 *     *   `System.err` is used consistently for printing all error messages, separating them from normal output.
 *     *   A broad `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This provides class-wide exception handling, catching any unhandled exceptions that might bubble up from the menu logic or other methods, preventing the program from crashing unexpectedly and providing a fallback error message and stack trace to `System.err`.
 *     *   A `finally` block in `run()` ensures the `Scanner` resource is closed when the application exits, whether normally or due to an exception.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used throughout the `Task` and `TaskProcessingSystem` classes.
 *     *   Variable and method names are descriptive (`pendingTasks`, `processNextTask`, `viewProcessedHistory`).
 *     *   Javadoc-style comments explain the purpose of classes, methods, and parameters.
 *     *   Input is validated for critical operations (menu choice format, task description presence).
 *     *   Error handling is layered and uses the appropriate stream (`System.err`).
 *     *   The code is structured logically into classes and methods, separating different concerns.
 * 
 * This solution effectively integrates all the required Java components to build a functional, robust, and well-structured application that demonstrates key object-oriented and error-handling principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicLong; // For unique task IDs

// --- Task Definition ---

/**
 * Represents the possible statuses of a task.
 */
enum TaskStatus {
    PENDING, PROCESSING, COMPLETED, FAILED
}

/**
 * Abstract base class for all tasks in the system.
 * Provides common properties like ID, description, and status.
 */
abstract class Task {
    // Use AtomicLong for thread-safe unique ID generation (good practice even in single-threaded demo)
    private static final AtomicLong idCounter = new AtomicLong(0);
    private final long id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a unique ID and initial status PENDING.
     * @param description A brief description of the task.
     */
    public Task(String description) {
        this.id = idCounter.incrementAndGet();
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public long getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setters ---
    /**
     * Sets the status of the task. Protected to be updated by concrete task classes or the system.
     * @param status The new status of the task.
     */
    protected void setStatus(TaskStatus status) {
        this.status = status;
    }

    // --- Abstract Method ---
    /**
     * Abstract method that must be implemented by concrete task types
     * to define their specific processing logic.
     * @throws TaskProcessingException If an error occurs during processing.
     */
    public abstract void process() throws TaskProcessingException;

    // --- Utility Method ---
    /**
     * Provides a string representation of the task for easy printing.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Type: %s, Status: %s, Description: '%s'",
                             id, this.getClass().getSimpleName(), status, description);
    }
}

/**
 * Custom exception class for errors that occur during task processing.
 */
class TaskProcessingException extends Exception {
    /**
     * Constructs a new TaskProcessingException with the specified detail message.
     * @param message The detail message.
     */
    public TaskProcessingException(String message) {
        super(message);
    }

    /**
     * Constructs a new TaskProcessingException with the specified detail message and cause.
     * @param message The detail message.
     * @param cause The cause (which is saved for later retrieval by the Throwable.getCause() method).
     */
    public TaskProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}

// --- Concrete Task Implementations ---

/**
 * Represents a task that performs data processing.
 * Simulates a chance of failure during processing.
 */
class DataProcessingTask extends Task {
    /**
     * Constructs a new DataProcessingTask.
     * @param description A brief description of the data processing task.
     */
    public DataProcessingTask(String description) {
        super(description);
    }

    /**
     * Simulates the processing of a data task.
     * Includes a 10% chance of simulating a failure.
     * @throws TaskProcessingException If the simulated processing fails or is interrupted.
     */
    @Override
    public void process() throws TaskProcessingException {
        System.out.println("Processing Data Task ID " + getId() + ": " + getDescription());
        try {
            // Simulate processing time
            Thread.sleep(500); // Simulate work takes 500ms

            // Simulate a chance of failure (e.g., 10% chance)
            if (Math.random() < 0.1) {
                 // Simulate an underlying issue causing the failure
                 throw new RuntimeException("Simulated data validation error during processing");
            }

            // If processing succeeds
            setStatus(TaskStatus.COMPLETED);
            System.out.println("Data Task ID " + getId() + " completed successfully.");

        } catch (InterruptedException e) {
            // Handle interruption during sleep
            setStatus(TaskStatus.FAILED);
            // Wrap the InterruptedException in a TaskProcessingException
            throw new TaskProcessingException("Data task processing interrupted for ID " + getId(), e);
        } catch (RuntimeException e) {
             // Handle simulated runtime errors during processing
             setStatus(TaskStatus.FAILED);
             // Wrap the RuntimeException in a TaskProcessingException
             throw new TaskProcessingException("Data task processing failed for ID " + getId() + ": " + e.getMessage(), e);
        }
    }
}

/**
 * Represents a task that generates a report.
 * Simulates a shorter processing time and is less likely to fail in this simulation.
 */
class ReportingTask extends Task {
     /**
     * Constructs a new ReportingTask.
     * @param description A brief description of the reporting task.
     */
     public ReportingTask(String description) {
        super(description);
    }

    /**
     * Simulates the processing of a reporting task.
     * @throws TaskProcessingException If the simulated processing is interrupted.
     */
    @Override
    public void process() throws TaskProcessingException {
        System.out.println("Processing Reporting Task ID " + getId() + ": " + getDescription());
        try {
             // Simulate processing time
            Thread.sleep(300); // Simulate work takes 300ms

            // Reporting tasks are assumed to be more stable in this simulation
            setStatus(TaskStatus.COMPLETED);
            System.out.println("Reporting Task ID " + getId() + " completed successfully.");

        } catch (InterruptedException e) {
            // Handle interruption during sleep
            setStatus(TaskStatus.FAILED);
            // Wrap the InterruptedException in a TaskProcessingException
            throw new TaskProcessingException("Reporting task processing interrupted for ID " + getId(), e);
        }
    }
}


// --- Task Processing System ---

/**
 * The main class representing the Task Processing System.
 * Manages the queue of pending tasks and the history of processed tasks.
 * Handles user interaction via the console.
 */
class TaskProcessingSystem {
    // Use LinkedList as a concrete implementation of the Queue interface for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use ArrayList as a concrete implementation of the List interface for processed task history
    private List<Task> processedTasksHistory;
    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new TaskProcessingSystem, initializing the task queues and scanner.
     */
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.processedTasksHistory = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add Data Processing Task");
        System.out.println("2. Add Reporting Task");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Processed Task History");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the pending queue based on the specified type.
     * Prompts the user for a task description and handles input validation.
     * @param taskType The type of task to add ("data" or "reporting").
     */
    private void addTask(String taskType) {
        System.out.print("Enter task description: ");
        // Read the rest of the line after the menu choice number
        String description = scanner.nextLine();

        // Input validation: Check if description is empty or just whitespace
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if input is invalid
        }

        Task newTask = null;
        // Use switch-like logic (if-else if) to create task based on type
        if ("data".equalsIgnoreCase(taskType)) {
            newTask = new DataProcessingTask(description.trim());
        } else if ("reporting".equalsIgnoreCase(taskType)) {
            newTask = new ReportingTask(description.trim());
        } else {
            // This case should ideally not be reached if menu handling is correct
            System.err.println("Internal Error: Unknown task type specified.");
            return;
        }

        // Add the new task to the end of the pending queue
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues as it doesn't throw exception on capacity limits (though LinkedList is unbounded)
        System.out.println(newTask.getClass().getSimpleName() + " added to the queue with ID " + newTask.getId());
    }

    /**
     * Processes the next task from the pending queue (FIFO).
     * Removes the task from the queue, attempts to process it,
     * updates its status, and moves it to the history list.
     * Includes specific exception handling for task processing errors.
     */
    private void processNextTask() {
        // Retrieve and remove the head of the queue
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            System.out.println("No pending tasks to process.");
            return; // Nothing to process
        }

        System.out.println("Attempting to process Task ID " + taskToProcess.getId() + "...");
        taskToProcess.setStatus(TaskStatus.PROCESSING); // Indicate processing has started

        try {
            // Call the abstract process method, which is implemented by concrete task types
            taskToProcess.process();
            // Status is set to COMPLETED or FAILED within the task's process() method

        } catch (TaskProcessingException e) {
            // Catch specific exceptions thrown by the task's process method
            // The status should already be set to FAILED within the task's method on failure
            System.err.println("Task Processing Failed for ID " + taskToProcess.getId() + ": " + e.getMessage());
            // Optionally print the cause's stack trace for debugging, but maybe too much for a simple exam output
            // if (e.getCause() != null) {
            //     System.err.println("Caused by:");
            //     e.getCause().printStackTrace(System.err);
            // }
        } catch (Exception e) {
             // Catch any other unexpected exceptions during processing
             taskToProcess.setStatus(TaskStatus.FAILED); // Ensure status is set to FAILED
             System.err.println("An unexpected error occurred while processing Task ID " + taskToProcess.getId() + ": " + e.getMessage());
             // Print stack trace for unexpected errors
             e.printStackTrace(System.err);
        } finally {
            // Ensure the task is added to the history list regardless of success or failure
            processedTasksHistory.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " moved to history with status " + taskToProcess.getStatus());
        }
    }

    /**
     * Displays all tasks currently waiting in the pending queue using System.out.
     * Iterates through the queue without removing elements.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently in the queue.");
        } else {
            // To view queue elements without removing them, you can iterate or convert to a list
            // Iterating directly might be less convenient for indexed display, so converting to List is simple.
            List<Task> pendingList = new ArrayList<>(pendingTasks);
            for (int i = 0; i < pendingList.size(); i++) {
                System.out.println((i + 1) + ". " + pendingList.get(i));
            }
        }
    }

    /**
     * Displays all tasks that have been processed (completed or failed) using System.out.
     * Iterates through the history list.
     */
    private void viewProcessedHistory() {
        System.out.println("\n--- Processed Task History ---");
        // Using the List interface variable processedTasksHistory (implemented by ArrayList)
        if (processedTasksHistory.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            for (int i = 0; i < processedTasksHistory.size(); i++) {
                System.out.println((i + 1) + ". " + processedTasksHistory.get(i));
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction and menu navigation.
     * Includes class-wide exception handling for the main execution flow.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the entire main application loop
        try {
            while (running) {
                displayMenu();

                int choice = -1; // Initialize choice to an invalid value
                try {
                    // Read the integer choice from the user
                    choice = scanner.nextInt();
                    // IMPORTANT: Consume the rest of the line, including the newline character,
                    // left by nextInt() to prevent issues with subsequent nextLine() calls.
                    scanner.nextLine();
                } catch (java.util.InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number between 1 and 6.");
                    // Consume the invalid input to prevent an infinite loop caused by the scanner
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show the menu again
                }

                // Use a switch statement to perform actions based on user choice
                switch (choice) {
                    case 1:
                        addTask("data");
                        break;
                    case 2:
                        addTask("reporting");
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewPendingTasks();
                        break;
                    case 5:
                        viewProcessedHistory();
                        break;
                    case 6:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range (1-6)
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur during the main system execution
            System.err.println("An unexpected critical error occurred during system execution:");
            // Print the stack trace to help diagnose unexpected issues
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed when the application finishes or crashes
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Inform the user the scanner is closed
            }
        }
    }

    /**
     * The main method to start the Task Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the system and run it
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
