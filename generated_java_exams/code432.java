/*
 * Exam Question #432
 * Generated on: 2025-05-11 23:10:31
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based Task Processing System. This system should manage a queue of tasks waiting to be processed and maintain a history of completed tasks. Users will interact with the system by adding new tasks, processing the next available task, and viewing lists of pending and completed tasks.
 * 
 * The system needs to handle different types of tasks and process them in a First-In, First-Out (FIFO) manner. Input validation and robust error handling are crucial.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique `taskId` (an integer, auto-generated by the system), `taskType` (String), and `description` (String). Include a constructor, public getter methods for all fields, and a meaningful `toString()` method.
 * 2.  **System Core:** Create a main class (e.g., `TaskProcessingSystem`) that contains the `main` method and the core logic. This class should manage:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   A `List<Task>` (specifically, an `ArrayList<Task>` implementation assigned to a `List` reference) to store tasks once they are completed.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and task details from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for `taskType` and `description`. Create a new `Task` object with a unique ID (you can use a simple counter starting from 1). Add the new task to the pending tasks `Queue`. Validate that `taskType` and `description` are not empty.
 *     *   **Process Next Task:** If the pending tasks `Queue` is not empty, remove (poll) the task at the front of the queue, simulate processing (e.g., print a message), and add it to the completed tasks `List`. If the queue is empty, inform the user using `System.err`.
 *     *   **View Pending Tasks:** Display the details of all tasks currently in the pending tasks `Queue`. If the queue is empty, inform the user using `System.out`. Display tasks in the order they are in the queue.
 *     *   **View Completed Tasks:** Display the details of all tasks in the completed tasks `List`. If the list is empty, inform the user using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main program loop or critical input/processing sections to catch unexpected errors. Print error details to `System.err`.
 *     *   Handle specific input errors (e.g., non-integer input for the menu choice) using `try-catch` and print messages to `System.err`. Clear the invalid input from the scanner.
 *     *   Use `System.err` for all error messages (e.g., invalid input, processing queue empty).
 *     *   Use `System.out` for all normal output (menu, prompts, task details, success messages, empty list/queue messages).
 * 6.  **Best Practices:**
 *     *   Adhere to proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept user input, perform the requested action, and provide appropriate output or error messages. Example interaction might look like:
 * 
 * ```
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type: Data Analysis
 * Enter description: Analyze Q3 sales data
 * Task added successfully.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type: Report
 * Enter description: Generate weekly status report
 * Task added successfully.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 1, Type: Data Analysis, Description: Analyze Q3 sales data
 * Task ID: 2, Type: Report, Description: Generate weekly status report
 * ---------------------
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task ID: 1, Type: Data Analysis, Description: Analyze Q3 sales data
 * Task completed and moved to history.
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 2, Type: Report, Description: Generate weekly status report
 * ---------------------
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 1, Type: Data Analysis, Description: Analyze Q3 sales data
 * -----------------------
 * 
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Errors (e.g., invalid menu input, processing empty queue) should go to `System.err`.
 * 
 * ```
 * Enter your choice: abc
 * Invalid input. Please enter a number between 1 and 5.
 * ```
 * ```
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * ```
 * 
 * This task requires you to integrate various core Java concepts and collections in a structured and error-resilient manner.
 *
 * EXPLANATION:
 * This solution implements the Task Processing System as described, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`taskId`, `taskType`, `description`) enforcing encapsulation. Public getter methods provide controlled access to the data. The `toString()` method provides a convenient way to print task details.
 * 2.  **TaskProcessingSystem Class:** This is the main class orchestrating the system.
 *     *   **`pendingTasks` (`Queue<Task>`):** A `LinkedList` is used to implement the `Queue` interface. `LinkedList` is a good choice for queues because it provides efficient insertions and removals from both ends (`offer` for adding to the tail, `poll` for removing from the head), which are the primary operations for a FIFO queue.
 *     *   **`completedTasks` (`List<Task>`):** An `ArrayList` is used to store completed tasks. It is declared using the `List` interface reference (`List<Task> completedTasks = new ArrayList<>();`), demonstrating polymorphism and programming to an interface. `ArrayList` is suitable here as we primarily need to add elements and iterate through them; random access performance is good.
 *     *   **`nextTaskId`:** A simple integer counter ensures each task gets a unique ID.
 * 3.  **Core Functionality Implementation:**
 *     *   **`addTask(String taskType, String description)`:** This method handles adding new tasks. It includes input validation to check for empty type or description, printing errors to `System.err`. If valid, it creates a new `Task` object with the next available ID and adds it to the `pendingTasks` queue using `offer()`. `offer()` is preferred over `add()` in queues as it returns `false` if the element cannot be added (though for `LinkedList`, it will always succeed unless memory is exhausted).
 *     *   **`processNextTask()`:** This method processes the task at the front of the queue. It first checks if the `pendingTasks` queue is empty using `isEmpty()`. If empty, it prints an error to `System.err`. If not empty, it uses `poll()` to retrieve and remove the head of the queue. The processed task is then added to the `completedTasks` `List` using `add()`.
 *     *   **`viewPendingTasks()`:** This method iterates through the `pendingTasks` queue using an enhanced for loop. This loop iterates over the elements without removing them, which is the desired behavior for viewing. It prints each task's details using its `toString()` method. It checks for an empty queue and prints an appropriate message to `System.out`.
 *     *   **`viewCompletedTasks()`:** This method iterates through the `completedTasks` `List` using an enhanced for loop, printing each completed task's details. It also checks for an empty list.
 * 4.  **User Interaction (`main` method):**
 *     *   A `Scanner` is used to read input. It's wrapped in a try-with-resources block (`try (Scanner scanner = new Scanner(System.in))`) to ensure it's automatically closed, preventing resource leaks.
 *     *   The main logic runs inside a `while(running)` loop.
 *     *   A `displayMenu()` method prints the options to `System.out`.
 *     *   Input for the menu choice is read using `scanner.nextInt()`. This is wrapped in a `try-catch (InputMismatchException)` block to handle cases where the user enters non-integer input. If caught, an error is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and the loop continues. A `finally` block is used after the input reading `try-catch` to consume the newline character left by `nextInt()` or `next()`, preventing issues when `nextLine()` is called subsequently for reading task type/description.
 *     *   A `switch` statement handles the valid integer choices, calling the appropriate methods of the `TaskProcessingSystem` instance. The `default` case handles invalid integer inputs.
 * 5.  **Exception Handling:**
 *     *   A broad `try-catch (Exception e)` block surrounds the main `while` loop in the `main` method. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur within the system's operation. Error messages and the stack trace are printed to `System.err`.
 *     *   Specific `try-catch (InputMismatchException)` is used for handling non-integer menu input, as described above.
 *     *   Input validation within `addTask` handles empty strings and uses `System.err`.
 *     *   Checking for an empty queue before processing (`processNextTask`) prevents potential errors and provides user-friendly messages via `System.err`.
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters/methods are used in the `Task` class. The `TaskProcessingSystem` manages its internal state (`pendingTasks`, `completedTasks`, `nextTaskId`) privately.
 *     *   **Meaningful Names:** Variable names (`pendingTasks`, `completedTasks`, `nextTaskId`, `taskType`, `description`, `taskToProcess`) and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `displayMenu`) are descriptive.
 *     *   **Comments/Documentation:** Basic Javadoc-style comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 *     *   **Clean Code Structure:** The code is organized into a separate `Task` class and the main `TaskProcessingSystem` class. The `main` method focuses on user interaction and calling system methods, keeping the core logic within the `TaskProcessingSystem` instance methods.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional system while adhering to good programming practices and handling potential errors.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task in the processing system.
 */
class Task {
    private int taskId;
    private String taskType;
    private String description;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param taskType The type of the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String taskType, String description) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task type.
     * @return The task type.
     */
    public String getTaskType() {
        return taskType;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return A string containing task details.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Type: " + taskType + ", Description: " + description;
    }
}

/**
 * Main class for the Task Processing System.
 * Manages pending tasks in a queue and completed tasks in a list.
 */
public class TaskProcessingSystem {

    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;

    // List to hold tasks that have been completed
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList

    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the collections and task ID counter.
     */
    public TaskProcessingSystem() {
        // LinkedList implements the Queue interface, suitable for FIFO operations
        this.pendingTasks = new LinkedList<>();
        // ArrayList implements the List interface, suitable for storing completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     *
     * @param taskType    The type of the task.
     * @param description The description of the task.
     * @return true if the task was added successfully, false otherwise (due to validation).
     */
    public boolean addTask(String taskType, String description) {
        // Input validation
        if (taskType == null || taskType.trim().isEmpty()) {
            System.err.println("Error: Task type cannot be empty.");
            return false;
        }
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }

        // Create a new task with a unique ID
        Task newTask = new Task(nextTaskId++, taskType.trim(), description.trim());
        // Add the task to the queue
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
        System.out.println("Task added successfully.");
        return true;
    }

    /**
     * Processes the next task in the pending tasks queue.
     * Removes the task from the queue and adds it to the completed tasks list.
     */
    public void processNextTask() {
        // Check if the queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        // Poll the next task from the queue (removes and returns the head)
        Task taskToProcess = pendingTasks.poll();

        // Simulate processing
        System.out.println("Processing task: " + taskToProcess);

        // Add the processed task to the completed tasks list
        completedTasks.add(taskToProcess);
        System.out.println("Task completed and moved to history.");
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate over the queue without removing elements
            // Using an enhanced for loop works for collections implementing Iterable
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate over the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main method to run the Task Processing System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskProcessingSystem system = new TaskProcessingSystem();
            boolean running = true;

            // Class-wide exception handling around the main operational loop
            try {
                while (running) {
                    system.displayMenu();
                    int choice = -1;

                    // Input handling for menu choice
                    try {
                        choice = scanner.nextInt();
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number between 1 and 5.");
                        scanner.next(); // Consume the invalid input
                        continue; // Skip the rest of the loop and show menu again
                    } finally {
                         // Consume the newline character left by nextInt() or next()
                         // This is important before reading strings with nextLine()
                         if (scanner.hasNextLine()) { // Check if there's a newline to consume
                              scanner.nextLine();
                         }
                    }


                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task type: ");
                            String type = scanner.nextLine();
                            System.out.print("Enter description: ");
                            String description = scanner.nextLine();
                            system.addTask(type, description);
                            break;
                        case 2:
                            system.processNextTask();
                            break;
                        case 3:
                            system.viewPendingTasks();
                            break;
                        case 4:
                            system.viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Processing System.");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                }
            } catch (Exception e) {
                // Generic catch for any unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err
            }

        } // Scanner is automatically closed here by try-with-resources
    }
}
