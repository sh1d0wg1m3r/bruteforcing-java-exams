/*
 * Exam Question #889
 * Generated on: 2025-05-12 16:55:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Warehouse Management System
 * 
 * You are required to develop a simplified Warehouse Management System (SWMS) in Java. This system will manage product inventory and process customer orders placed in a queue.
 * 
 * Your solution must demonstrate proficiency in using various core Java constructs and collections while adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a list of products in the warehouse, each with a name and quantity.
 *     *   Maintain a queue of pending customer orders. Each order specifies a unique ID, a product name, and a requested quantity.
 *     *   Provide a menu-driven interface for user interaction.
 *     *   Allow users to perform the following operations:
 *         *   **Add/Update Product Inventory:** Add a new product to the inventory or update the quantity of an existing product.
 *         *   **Add Customer Order:** Create a new order and add it to the end of the pending orders queue.
 *         *   **Process Next Pending Order:** Take the next order from the front of the queue. Check if the requested product exists in the inventory and if the available quantity is sufficient. If both conditions are met, decrease the inventory quantity and report the order as fulfilled using `System.out`. If not, report the order as rejected using `System.err`.
 *         *   **View Inventory:** Display the current list of products and their quantities using `System.out`.
 *         *   **View Pending Orders:** Display the list of orders currently waiting in the queue using `System.out`.
 *         *   **Exit:** Terminate the application.
 * 
 * 2.  **Mandatory Java Components:** Your code *must* include and correctly utilize **ALL** of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (Declare a variable using this interface type)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling the menu options)
 *     *   `System.err` (for outputting error messages and order rejections)
 *     *   `System.out` (for outputting normal messages, menu, inventory, and order fulfillment success)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., wrapping the main application loop or significant operational blocks to catch potential runtime errors gracefully).
 * 
 * 3.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields with public accessors/mutators where necessary) for your classes.
 *     *   Use meaningful and descriptive names for variables, methods, and classes.
 *     *   Include appropriate comments and basic documentation (e.g., JavaDocs for classes and key methods).
 *     *   Implement input validation (e.g., check for non-negative quantities, handle non-numeric input gracefully).
 *     *   Provide proper error handling using `try-catch` blocks and `System.err` for user-friendly error reporting.
 *     *   Structure your code cleanly using separate classes for different concerns (e.g., `Product`, `Order`, `WarehouseManager`, and the main application class).
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu to the user. Based on the user's choice, it should perform the requested operation, display relevant information (inventory, pending orders) using `System.out`, and report any errors or order rejections using `System.err`. The interaction flow should be intuitive and robust against common input errors.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Simple Warehouse Management System ---
 * 
 * --- Menu ---
 * 1. Add/Update Product Inventory
 * 2. Add Customer Order
 * 3. Process Next Pending Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter choice: 1
 * Enter product name: Laptop
 * Enter quantity: 10
 * Product added/updated.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 2
 * Enter product name for order: Laptop
 * Enter quantity for order: 2
 * Order 1 added to queue.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 2
 * Enter product name for order: Keyboard
 * Enter quantity for order: 5
 * Order 2 added to queue.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 5
 * --- Pending Orders ---
 * Order ID: 1, Product: Laptop, Quantity: 2
 * Order ID: 2, Product: Keyboard, Quantity: 5
 * --- End Pending Orders ---
 * 
 * --- Menu ---
 * ...
 * Enter choice: 3
 * Processing Order ID: 1...
 * Order 1 for Laptop (Qty: 2) fulfilled. Inventory updated.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 4
 * --- Current Inventory ---
 * Product: Laptop, Quantity: 8
 * Product: Keyboard, Quantity: 0
 * --- End Inventory ---
 * 
 * --- Menu ---
 * ...
 * Enter choice: 3
 * Processing Order ID: 2...
 * System.err: Order 2 for Keyboard (Qty: 5) rejected. Insufficient stock or product not found.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 1
 * Enter product name: Keyboard
 * Enter quantity: 20
 * Product added/updated.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 3
 * Processing Order ID: 2...
 * Order 2 for Keyboard (Qty: 5) fulfilled. Inventory updated.
 * 
 * --- Menu ---
 * ...
 * Enter choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided Java solution implements a Simple Warehouse Management System (SWMS) according to the exam question requirements.
 * 
 * **Class Structure:**
 * - `Product`: Encapsulates product data (name, quantity). Uses private fields, public getters, and a setter with input validation. Includes a `toString()` method for easy printing.
 * - `Order`: Encapsulates order data (ID, product name, quantity). Uses private fields, public getters, and includes a `toString()` method. Validates positive quantity upon creation.
 * - `WarehouseManager`: Manages the core logic of the system.
 *     - It uses a `List<Product>` (`ArrayList` implementation) named `inventory` to store products. This allows easy searching and updating.
 *     - It uses a `Queue<Order>` (`LinkedList` implementation) named `pendingOrders` to store orders in a FIFO (First-In, First-Out) manner. `LinkedList` is a common implementation that supports the `Queue` interface methods efficiently.
 *     - It contains methods for `addProduct`, `addOrder`, `processNextOrder`, `viewInventory`, and `viewPendingOrders`, implementing the system's operations. Encapsulation is maintained by keeping the collections private and exposing functionality through public methods.
 *     - The `addProduct` method handles both adding new products and updating existing ones based on the product name.
 *     - The `processNextOrder` method uses `pendingOrders.poll()` to get the next order and remove it from the queue. It then checks inventory and updates quantities if the order can be fulfilled, printing results to `System.out` or `System.err` accordingly.
 *     - A private helper method `findProductByName` demonstrates searching within the `ArrayList` inventory.
 * - `WarehouseSystem`: The main class containing the `main` method. This class handles user interaction via the console.
 * 
 * **Required Components Usage:**
 * - `java.util.Queue`: Used for `pendingOrders` in `WarehouseManager`. Methods like `offer()` (to add) and `poll()` (to retrieve and remove) are used.
 * - `java.util.ArrayList`: Used as the concrete implementation for the `inventory` `List`.
 * - `java.util.List`: The `inventory` variable in `WarehouseManager` is declared using the `List` interface type, demonstrating programming to interfaces.
 * - `java.util.Scanner`: Used in the `main` method to read user input from `System.in`. It is closed in a `finally` block to release system resources.
 * - `switch` statement: Used in the `main` method to control the flow of the application based on the user's menu choice.
 * - `System.err`: Used to print error messages, such as invalid input notifications (`NumberFormatException`), validation errors (`IllegalArgumentException` caught from manager methods), and order rejection messages.
 * - `System.out`: Used for all normal output, including the menu, success messages (product added, order added, order fulfilled), and displaying the inventory and pending orders lists.
 * - Class-wide exception handling: A large `try-catch(Exception e)` block is wrapped around the main `while(true)` loop in the `main` method. This catches any uncaught exceptions that might occur during the program's execution, providing a layer of robustness and preventing the program from crashing unexpectedly. More specific `try-catch` blocks are also used within the loop to handle expected input parsing errors (`NumberFormatException`) gracefully, allowing the user to retry input without exiting the main loop or triggering the generic `Exception` catch. `IllegalArgumentException` thrown by the manager methods for validation errors (like negative quantities) are also caught in the `main` method's `switch` cases and reported via `System.err`.
 * 
 * **Best Practices:**
 * - **Encapsulation:** Fields in `Product`, `Order`, and `WarehouseManager` are private, with access controlled by public methods.
 * - **Meaningful Names:** Class names (`Product`, `Order`, `WarehouseManager`, `WarehouseSystem`), variable names (`inventory`, `pendingOrders`, `nextOrderId`, `productName`, `quantity`), and method names (`addProduct`, `processNextOrder`, `viewInventory`, `printMenu`) are descriptive.
 * - **Comments and Documentation:** Basic JavaDocs are included for classes and key methods, explaining their purpose and parameters/return values. Inline comments clarify specific logic.
 * - **Input Validation:** Quantities are checked for non-negativity (or positivity for orders) in the `Product` and `Order` constructors and `Product.setQuantity`, throwing `IllegalArgumentException`. The `main` method also handles non-numeric input for menu choices and quantities using `try-catch(NumberFormatException)`.
 * - **Error Handling:** `try-catch` blocks are used for handling exceptions (`NumberFormatException`, `IllegalArgumentException`, generic `Exception`). Error messages are directed to `System.err`.
 * - **Clean Code Structure:** The code is divided into logical classes, separating concerns (data representation, business logic, user interface).
 * 
 * This solution effectively combines the required Java components in a practical scenario, demonstrating understanding of collections, control flow, exception handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product in the warehouse inventory.
 */
class Product {
    private String name;
    private int quantity;

    /**
     * Constructs a new Product.
     *
     * @param name     The name of the product.
     * @param quantity The initial quantity of the product.
     * @throws IllegalArgumentException if quantity is negative.
     */
    public Product(String name, int quantity) {
        if (quantity < 0) {
            throw new IllegalArgumentException("Quantity cannot be negative.");
        }
        this.name = name;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the product.
     * @return The product name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current quantity of the product.
     * @return The product quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Sets the quantity of the product.
     * @param quantity The new quantity.
     * @throws IllegalArgumentException if quantity is negative.
     */
    public void setQuantity(int quantity) {
        if (quantity < 0) {
             throw new IllegalArgumentException("Quantity cannot be negative.");
        }
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Product: " + name + ", Quantity: " + quantity;
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private int orderId;
    private String productName;
    private int quantity;

    /**
     * Constructs a new Order.
     *
     * @param orderId     The unique ID of the order.
     * @param productName The name of the product ordered.
     * @param quantity    The quantity ordered.
     * @throws IllegalArgumentException if quantity is negative or zero.
     */
    public Order(int orderId, String productName, int quantity) {
         if (quantity <= 0) {
            throw new IllegalArgumentException("Order quantity must be positive.");
        }
        this.orderId = orderId;
        this.productName = productName;
        this.quantity = quantity;
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the name of the product ordered.
     * @return The product name.
     */
    public String getProductName() {
        return productName;
    }

    /**
     * Gets the quantity ordered.
     * @return The ordered quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Product: " + productName + ", Quantity: " + quantity;
    }
}

/**
 * Manages the warehouse inventory and pending orders.
 */
class WarehouseManager {
    // Using List interface, implemented by ArrayList
    private List<Product> inventory;
    // Using Queue interface, implemented by LinkedList
    private Queue<Order> pendingOrders;

    /**
     * Constructs a new WarehouseManager.
     */
    public WarehouseManager() {
        this.inventory = new ArrayList<>();
        this.pendingOrders = new LinkedList<>(); // LinkedList is a common Queue implementation
    }

    /**
     * Adds a new product or updates the quantity of an existing product.
     *
     * @param name     The name of the product.
     * @param quantity The quantity to add or set.
     * @throws IllegalArgumentException if quantity is negative.
     */
    public void addProduct(String name, int quantity) {
         if (quantity < 0) {
            throw new IllegalArgumentException("Cannot add negative quantity to inventory.");
        }
        // Find product by name (case-insensitive search for robustness)
        Product existingProduct = findProductByName(name);

        if (existingProduct != null) {
            // Product exists, update quantity
            existingProduct.setQuantity(existingProduct.getQuantity() + quantity);
        } else {
            // Product does not exist, add new
            inventory.add(new Product(name, quantity));
        }
    }

    /**
     * Adds a new customer order to the pending queue.
     *
     * @param orderId     The unique ID for the order.
     * @param productName The name of the product ordered.
     * @param quantity    The quantity ordered.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addOrder(int orderId, String productName, int quantity) {
         if (quantity <= 0) {
            throw new IllegalArgumentException("Order quantity must be positive.");
        }
        pendingOrders.offer(new Order(orderId, productName, quantity)); // offer is preferred over add for queues
    }

    /**
     * Processes the next order from the pending queue.
     * Checks inventory and fulfills or rejects the order.
     */
    public void processNextOrder() {
        Order nextOrder = pendingOrders.poll(); // poll retrieves and removes the head of the queue

        if (nextOrder == null) {
            System.out.println("No pending orders to process.");
            return;
        }

        System.out.println("Processing Order ID: " + nextOrder.getOrderId() + "...");

        Product productInStock = findProductByName(nextOrder.getProductName());

        if (productInStock != null && productInStock.getQuantity() >= nextOrder.getQuantity()) {
            // Sufficient stock, fulfill order
            try {
                 productInStock.setQuantity(productInStock.getQuantity() - nextOrder.getQuantity());
                 System.out.println("Order " + nextOrder.getOrderId() + " for " + nextOrder.getProductName() +
                                    " (Qty: " + nextOrder.getQuantity() + ") fulfilled. Inventory updated.");
            } catch (IllegalArgumentException e) {
                 // This case should ideally not happen if setQuantity validates >= 0
                 System.err.println("Internal error updating inventory: " + e.getMessage());
            }

        } else {
            // Insufficient stock or product not found
            System.err.println("Order " + nextOrder.getOrderId() + " for " + nextOrder.getProductName() +
                               " (Qty: " + nextOrder.getQuantity() + ") rejected. Insufficient stock or product not found.");
            // Optionally re-queue or log rejected orders elsewhere
        }
    }

    /**
     * Displays the current inventory status.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product);
            }
        }
        System.out.println("--- End Inventory ---");
    }

    /**
     * Displays the list of pending orders in the queue.
     */
    public void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate without removing elements
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("--- End Pending Orders ---");
    }

    /**
     * Helper method to find a product in the inventory by name.
     * @param name The name of the product to find.
     * @return The Product object if found, otherwise null.
     */
    private Product findProductByName(String name) {
        // Case-insensitive search
        String lowerCaseName = name.toLowerCase();
        for (Product product : inventory) {
            if (product.getName().toLowerCase().equals(lowerCaseName)) {
                return product;
            }
        }
        return null;
    }
}

/**
 * Main class to run the Simple Warehouse Management System.
 * Handles user interaction and menu navigation.
 */
public class WarehouseSystem {

    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        Scanner scanner = new Scanner(System.in);
        int nextOrderId = 1; // Simple counter for unique order IDs

        System.out.println("--- Simple Warehouse Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (true) {
                printMenu();
                System.out.print("Enter choice: ");

                String choiceStr = scanner.nextLine();
                int choice;

                // Handle non-integer input for menu choice
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration of the loop
                }

                switch (choice) {
                    case 1: // Add/Update Product
                        System.out.print("Enter product name: ");
                        String productName = scanner.nextLine();
                        System.out.print("Enter quantity to add/set: ");
                        String quantityStr = scanner.nextLine();
                        try {
                            int quantity = Integer.parseInt(quantityStr);
                            manager.addProduct(productName, quantity);
                            System.out.println("Product '" + productName + "' added/updated with quantity " + quantity + ".");
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid quantity input. Please enter a number.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding product: " + e.getMessage());
                        }
                        break;

                    case 2: // Add Order
                        System.out.print("Enter product name for order: ");
                        String orderProductName = scanner.nextLine();
                        System.out.print("Enter quantity for order: ");
                        String orderQuantityStr = scanner.nextLine();
                        try {
                            int orderQuantity = Integer.parseInt(orderQuantityStr);
                            manager.addOrder(nextOrderId++, orderProductName, orderQuantity);
                            System.out.println("Order " + (nextOrderId - 1) + " added to queue.");
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid quantity input. Please enter a number.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding order: " + e.getMessage());
                        }
                        break;

                    case 3: // Process Next Order
                        manager.processNextOrder();
                        break;

                    case 4: // View Inventory
                        manager.viewInventory();
                        break;

                    case 5: // View Pending Orders
                        manager.viewPendingOrders();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        return; // Exit the main method

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Generic catch for any unexpected errors during execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging purposes if needed
        } finally {
            // Ensure scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add/Update Product Inventory");
        System.out.println("2. Add Customer Order");
        System.out.println("3. Process Next Pending Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.println("------------");
    }
}
