/*
 * Exam Question #624
 * Generated on: 2025-05-12 16:16:31
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Processing Simulation
 * 
 * **Objective:** Implement a simple simulation of a package processing center. Packages arrive, are placed in an inbound queue, processed one by one, and then moved to a list of processed packages. The system should allow users to interact with the simulation through a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Class:** Create a `Package` class with the following private fields:
 *     *   `packageId` (String)
 *     *   `description` (String)
 *     *   `status` (String, e.g., "Pending", "Processed", "Shipped")
 *     *   `destination` (String)
 *     *   Include a constructor to initialize these fields (perhaps setting initial status to "Pending").
 *     *   Provide public getter methods for all fields.
 *     *   Include a public method `updateStatus(String newStatus)` to change the package's status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the package.
 * 
 * 2.  **PackageProcessor Class:** Create a main class `PackageProcessor` that manages the simulation.
 *     *   It must have private fields for:
 *         *   An inbound queue (`Queue<Package>`) to hold packages awaiting processing.
 *         *   A list (`List<Package>`) to hold packages that have been processed.
 *         *   A `Scanner` object for user input.
 *     *   Implement a constructor to initialize the queue, list, and scanner.
 *     *   Implement a method `startSimulation()` which contains the main application loop.
 *     *   The `startSimulation()` method must:
 *         *   Display a menu of options to the user:
 *             1.  Add New Package to Queue
 *             2.  Process Next Package from Queue
 *             3.  View Inbound Queue
 *             4.  View Processed Packages
 *             5.  Exit
 *         *   Read user input for the menu choice using `Scanner`.
 *         *   Use a `switch` statement to handle the different menu options.
 *         *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Use `System.err` for invalid input messages.
 *         *   Wrap the main loop or the core logic execution within `startSimulation` in a `try-catch` block to demonstrate class-wide exception handling. Catch general `Exception` or more specific exceptions as appropriate and print an error message using `System.err`.
 *     *   Implement the following methods called by the switch statement:
 *         *   `addPackage()`: Prompts the user for package ID, description, and destination. Creates a `Package` object and adds it to the inbound queue. Include input validation to ensure required fields are not empty.
 *         *   `processNextPackage()`: Removes the next package from the inbound queue. If the queue is empty, print an error message to `System.err`. If a package is retrieved, update its status (e.g., to "Processed"), print a success message to `System.out`, and add it to the processed packages list.
 *         *   `viewInboundQueue()`: Prints details of all packages currently in the inbound queue using `System.out`. Indicate if the queue is empty.
 *         *   `viewProcessedPackages()`: Prints details of all packages currently in the processed packages list using `System.out`. Indicate if the list is empty.
 *     *   Ensure the `Scanner` resource is closed properly when the application exits.
 * 
 * 3.  **Java Concepts:** Your solution *must* explicitly use:
 *     *   `java.util.Queue` interface
 *     *   `java.util.ArrayList` class
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` class
 *     *   `switch` statement
 *     *   `System.err` for errors
 *     *   `System.out` for normal output
 *     *   `try-catch` for class-wide exception handling.
 * 
 * 4.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Implement robust input validation and error handling as described above.
 *     *   Structure your code cleanly.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, and printing status messages or package details based on the user's choices. Error messages (like invalid input or attempting to process an empty queue) should go to `System.err`.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Package Processor Menu ---
 * 1. Add New Package to Queue
 * 2. Process Next Package from Queue
 * 3. View Inbound Queue
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P101
 * Enter Description: Small electronics
 * Enter Destination: New York
 * Package P101 added to the queue.
 * 
 * --- Package Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Inbound Queue ---
 * Package [ID=P101, Desc=Small electronics, Status=Pending, Dest=New York]
 * ---------------------
 * 
 * --- Package Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing package: Package [ID=P101, Desc=Small electronics, Status=Pending, Dest=New York]
 * Package P101 processed and moved.
 * 
 * --- Package Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Packages ---
 * Package [ID=P101, Desc=Small electronics, Status=Processed, Dest=New York]
 * --------------------------
 * 
 * --- Package Processor Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5. (Output to System.err)
 * 
 * --- Package Processor Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Package Processor.
 * ```
 *
 * EXPLANATION:
 * This solution implements a `PackageProcessing` simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   Encapsulates package data (`packageId`, `description`, `status`, `destination`) using `private` fields.
 *     *   Provides `public` getter methods for accessing the data.
 *     *   Includes a constructor for creating `Package` objects, performing basic validation to ensure essential fields are not empty.
 *     *   Has an `updateStatus` method for modifying the status.
 *     *   Overrides `toString()` for convenient printing of package details.
 * 
 * 2.  **`PackageProcessor` Class:**
 *     *   Acts as the main controller for the simulation.
 *     *   Uses a `private Queue<Package> inboundQueue = new LinkedList<>();` to store packages waiting to be processed. `LinkedList` is a common implementation of the `Queue` interface. The `Queue` interface provides methods like `add()` (or `offer()`) to add elements and `poll()` (or `remove()`) to retrieve and remove elements from the head.
 *     *   Uses a `private List<Package> processedPackages = new ArrayList<>();` to store packages after processing. `ArrayList` is a dynamic array implementation of the `List` interface, suitable for storing processed items where order might matter and random access is possible (though not strictly needed in this simple example). Using the `List` interface for the variable type promotes flexibility.
 *     *   Uses a `private Scanner scanner = new Scanner(System.in);` to read user input from the console.
 *     *   The `startSimulation()` method contains the main application loop (`while(running)`).
 *     *   **Switch Statement:** A `switch` statement is used inside the loop to direct execution based on the user's menu choice, calling the appropriate methods (`addPackage`, `processNextPackage`, etc.).
 *     *   **Input Validation:** Basic validation is performed when reading the menu choice (checking for `InputMismatchException`) and when adding a new package (checking if input strings are empty). Invalid menu choices print messages to `System.err`.
 *     *   **System.out and System.err:** `System.out.println()` is used for displaying the menu, confirmation messages, and lists of packages. `System.err.println()` is specifically used for displaying error messages, such as invalid input, attempting to process an empty queue, or issues during package creation.
 *     *   **Queue Usage (`processNextPackage`, `viewInboundQueue`):** `inboundQueue.poll()` is used to retrieve and remove the next package from the queue (FIFO - First-In, First-Out). The `viewInboundQueue` method iterates through the queue using a for-each loop, which uses the queue's iterator without removing elements.
 *     *   **List Usage (`processNextPackage`, `viewProcessedPackages`):** Processed packages are added to the `processedPackages` list using `list.add()`. The `viewProcessedPackages` method iterates through the list using a for-each loop.
 *     *   **Class-wide Exception Handling (`try-catch`):** The `startSimulation()` method's main `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching unexpected errors that might occur during the execution of any operation within the simulation loop, providing a central point for handling runtime exceptions and preventing the program from crashing abruptly. The `finally` block ensures the `Scanner` is closed regardless of whether the loop finishes normally or an exception is caught.
 *     *   **Resource Management:** The `closeScanner()` method is called in the `finally` block of the `try-catch` in `startSimulation()` to ensure the `Scanner` resource is properly closed, preventing resource leaks.
 *     *   **Best Practices:** The code follows best practices by using private fields, public methods, meaningful names, comments, and separating concerns into different methods.
 * 
 * This solution effectively integrates all the required Java components within a practical simulation, demonstrating their usage and interaction while adhering to common Java programming standards.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a package in the simulation
class Package {
    private String packageId;
    private String description;
    private String status;
    private String destination;

    // Constructor
    public Package(String packageId, String description, String destination) {
        // Input validation within constructor is good practice
        if (packageId == null || packageId.trim().isEmpty() ||
            description == null || description.trim().isEmpty() ||
            destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID, description, and destination cannot be empty.");
        }
        this.packageId = packageId.trim();
        this.description = description.trim();
        this.destination = destination.trim();
        this.status = "Pending"; // Initial status
    }

    // Public getters
    public String getPackageId() {
        return packageId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public String getDestination() {
        return destination;
    }

    // Method to update status
    public void updateStatus(String newStatus) {
        if (newStatus != null && !newStatus.trim().isEmpty()) {
            this.status = newStatus.trim();
        } else {
             System.err.println("Warning: Attempted to set empty status for package " + this.packageId);
        }
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Package [ID=" + packageId + ", Desc=" + description + ", Status=" + status + ", Dest=" + destination + "]";
    }
}

// Main class to manage the package processing simulation
public class PackageProcessor {
    private Queue<Package> inboundQueue; // Queue for packages awaiting processing
    private List<Package> processedPackages; // List for packages that have been processed
    private Scanner scanner; // Scanner for user input

    // Constructor
    public PackageProcessor() {
        // Use LinkedList as an implementation of Queue
        this.inboundQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Starts the simulation loop
    public void startSimulation() {
        boolean running = true;
        // Class-wide exception handling wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Initialize choice outside try block

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewInboundQueue();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Package Processor.");
                        break;
                    default:
                        // Use System.err for invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred during simulation:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed when simulation ends (normally or via exception)
            closeScanner();
        }
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("--- Package Processor Menu ---");
        System.out.println("1. Add New Package to Queue");
        System.out.println("2. Process Next Package from Queue");
        System.out.println("3. View Inbound Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
    }

    // Adds a new package based on user input
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Description: ");
        String description = scanner.nextLine();
        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine();

        // Input validation
        if (id.trim().isEmpty() || description.trim().isEmpty() || destination.trim().isEmpty()) {
            System.err.println("Error: Package ID, Description, and Destination cannot be empty.");
            return; // Do not add the package if validation fails
        }

        try {
            Package newPackage = new Package(id, description, destination);
            inboundQueue.add(newPackage); // Add to the end of the queue
            System.out.println("Package " + newPackage.getPackageId() + " added to the queue.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating package: " + e.getMessage());
        }
    }

    // Processes the next package from the queue
    private void processNextPackage() {
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        Package packageToProcess = inboundQueue.poll();

        if (packageToProcess == null) {
            // Use System.err for error condition
            System.err.println("The inbound queue is empty. No packages to process.");
        } else {
            System.out.println("Processing package: " + packageToProcess);
            packageToProcess.updateStatus("Processed"); // Update status
            processedPackages.add(packageToProcess); // Add to the processed list
            System.out.println("Package " + packageToProcess.getPackageId() + " processed and moved.");
        }
    }

    // Views packages currently in the inbound queue
    private void viewInboundQueue() {
        System.out.println("--- Inbound Queue ---");
        if (inboundQueue.isEmpty()) {
            System.out.println("The inbound queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : inboundQueue) {
                System.out.println(pkg); // Uses Package.toString()
            }
        }
        System.out.println("---------------------");
    }

    // Views packages currently in the processed list
    private void viewProcessedPackages() {
        System.out.println("--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("The processed packages list is empty.");
        } else {
            // Iterate through the list
            for (Package pkg : processedPackages) {
                System.out.println(pkg); // Uses Package.toString()
            }
        }
        System.out.println("--------------------------");
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        PackageProcessor processor = new PackageProcessor();
        processor.startSimulation();
    }
}
