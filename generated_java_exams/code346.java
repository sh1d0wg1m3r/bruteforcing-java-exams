/*
 * Exam Question #346
 * Generated on: 2025-05-11 22:58:18
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Task Management System
 * 
 * **Problem Description:**
 * 
 * A logistics company needs a simple system to manage incoming tasks (like sorting packages, planning routes, confirming deliveries). Tasks arrive sequentially and must be processed in the order they are received (First-In, First-Out). The system should allow operators to add new tasks, process the next task in line, view pending tasks, and view tasks that have been completed. The system must be interactive, driven by user input.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (integer, unique), `description` (String), and `status` (String, e.g., "Pending", "Completed"). Include a constructor and public getter methods for these fields.
 * 2.  **System Core:** Create a `TaskManagementSystem` class. This class will manage the pending and completed tasks.
 *     *   Use a `java.util.Queue` to store tasks that are waiting to be processed. Tasks should be processed in FIFO order.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed. Declare the field using the `java.util.List` interface type.
 *     *   Maintain a counter to generate unique task IDs starting from 1.
 *     *   Include methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and "Pending" status, and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the task from the front of the pending queue, changes its status to "Completed", and moves it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed list.
 *         *   `run()`: Contains the main application loop, presenting a menu to the user and handling their choices.
 * 3.  **User Interface:** Use `java.util.Scanner` to get input from the user. Present a menu with options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 4.  **Flow Control:** Use a `switch` statement within the main loop (`run` method) to handle the user's menu selection.
 * 5.  **Error Handling:**
 *     *   Use `System.err.println()` to print error messages (e.g., "Invalid menu choice", "No pending tasks to process", "Invalid input for task description").
 *     *   Implement input validation: Ensure task descriptions are not empty. Handle non-integer input for the menu selection using a `try-catch` block around the input reading and processing logic in the main loop.
 *     *   Use a `try-catch` block within the `run` method to handle potential exceptions that might occur during the main program execution loop.
 * 6.  **Output:** Use `System.out.println()` for menu display, task details, and success messages.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interactions might look like:
 * 
 * ```
 * Logistics Task Management System
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Sort packages for Zone A
 * Task added: Task ID 1 - Sort packages for Zone A [Pending]
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Plan route for driver B
 * Task added: Task ID 2 - Plan route for driver B [Pending]
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID 1 - Sort packages for Zone A [Pending]
 * Task ID 2 - Plan route for driver B [Pending]
 * ---------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task ID 1 - Sort packages for Zone A [Pending]
 * Task ID 1 completed.
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID 2 - Plan route for driver B [Pending]
 * ---------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID 1 - Sort packages for Zone A [Completed]
 * -----------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task ID 2 - Plan route for driver B [Pending]
 * Task ID 2 completed.
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID 1 - Sort packages for Zone A [Completed]
 * Task ID 2 - Plan route for driver B [Completed]
 * -----------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Implement the complete Java code including both classes (`Task`, `TaskManagementSystem`) in a single file for submission.
 *
 * EXPLANATION:
 * This solution implements a simple Logistics Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class encapsulates the data for a single task: `id`, `description`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide controlled access to the task's data.
 *     *   A `setStatus` method allows changing the status, necessary when a task is completed.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **TaskManagementSystem Class:**
 *     *   This is the core class managing the tasks.
 *     *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `LinkedList`. `LinkedList` implements the `Queue` interface and provides the necessary FIFO behavior using methods like `offer()` (to add) and `poll()` (to retrieve and remove).
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `ArrayList`. `ArrayList` is suitable for storing completed tasks where efficient access by index or iteration is needed. Using the `List` interface is good practice as it allows changing the underlying implementation later without affecting code that only uses `List` methods.
 *     *   `nextTaskId`: A simple integer counter ensures unique IDs for new tasks.
 *     *   `scanner`: An instance of `Scanner` is used throughout the `run` method for user input. It's initialized once and closed in the `finally` block.
 * 
 * 3.  **Methods:**
 *     *   `addTask(String description)`: Creates a new `Task` object, increments `nextTaskId`, and adds the task to the `pendingTasks` queue using `offer()`. It includes input validation to check for empty descriptions.
 *     *   `processNextTask()`: Uses `poll()` to get and remove the head of the `pendingTasks` queue. If `poll()` returns `null` (queue is empty), an error message is printed to `System.err`. Otherwise, the task's status is updated, and it's added to the `completedTasks` list.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue (using a for-each loop, which does not remove elements) and prints each task. Checks if the queue is empty. Output is directed to `System.out`.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list and prints each task. Checks if the list is empty. Output is directed to `System.out`.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   `run()`: This method contains the main application loop. It repeatedly displays the menu, reads user input, and uses a `switch` statement to call the appropriate method based on the choice.
 * 
 * 4.  **User Input and Flow Control:**
 *     *   `Scanner` reads integer input for the menu choice and string input for the task description.
 *     *   A `switch` statement effectively directs the program flow based on the user's validated choice.
 * 
 * 5.  **Error Handling:**
 *     *   `InputMismatchException`: A `try-catch` block specifically handles cases where the user enters non-integer input for the menu choice. `scanner.next()` is used within the `catch` block to consume the invalid token, preventing an infinite loop.
 *     *   Empty Queue/Invalid Input: Specific checks (`pendingTasks.isEmpty()`, `description.trim().isEmpty()`) are performed before attempting operations, and informative error messages are printed to `System.err`.
 *     *   Class-wide `try-catch`: A broad `try-catch(Exception e)` block wraps the main `while(running)` loop in the `run()` method. This provides a safety net to catch any unexpected runtime exceptions that might occur within the loop, preventing the program from crashing abruptly and printing the error details to `System.err`.
 *     *   `finally` block: Ensures the `Scanner` is closed when the `run` method exits, releasing system resources.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class and by making fields in `TaskManagementSystem` private.
 *     *   Variable and method names (`pendingTasks`, `processNextTask`, `addTask`, `nextTaskId`) are descriptive.
 *     *   Basic Javadoc comments explain the purpose of classes and methods.
 *     *   Code is structured into logical units (classes and methods).
 *     *   Input validation and error handling are explicitly implemented.
 * 
 * This solution effectively integrates the required Java components to solve a practical problem while adhering to important programming principles.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task in the logistics system.
 */
class Task {
    private int id;
    private String description;
    private String status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Tasks start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task ID " + id + " - " + description + " [" + status + "]";
    }
}

/**
 * Manages the logistics tasks using queues and lists.
 */
public class TaskManagementSystem { // Changed class name to match common practice for main class
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementSystem.
     */
    public TaskManagementSystem() {
        // Use LinkedList as an implementation of Queue for FIFO behavior
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List for storing completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer adds to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating over a Queue doesn't remove elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nLogistics Task Management System");
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate methods.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Consume the newline character left by nextInt()
                     // This is important before reading the task description string later
                     scanner.nextLine();
                }


                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
