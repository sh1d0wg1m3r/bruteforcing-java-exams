/*
 * Exam Question #861
 * Generated on: 2025-05-12 16:51:45
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Restaurant Order Management System**
 * 
 * You are tasked with developing a simplified console-based restaurant order management system. The system should allow staff to manage a predefined menu, take new customer orders, process orders in the order they were received, and view the current queue of pending orders.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items. Use `java.util.List` for the type declaration and initialize it with `java.util.ArrayList`.
 *     *   Maintain a queue of incoming customer orders. Use `java.util.Queue` for the type declaration.
 * 2.  **Classes:**
 *     *   Create a `MenuItem` class (or similar) to represent an item on the menu (e.g., name, price).
 *     *   Create an `Order` class (or similar) to represent a customer order (e.g., unique ID, list of `MenuItem`s).
 *     *   Create a main `RestaurantSystem` class to manage the menu, order queue, and user interaction.
 * 3.  **Functionality:**
 *     *   Initialize the system with a few predefined menu items.
 *     *   Provide a main menu loop for the user with the following options:
 *         *   1. View Menu
 *         *   2. Add New Order
 *         *   3. Process Next Order
 *         *   4. View Pending Orders
 *         *   5. Exit
 *     *   **View Menu:** Display the list of menu items with their names and prices.
 *     *   **Add New Order:**
 *         *   Prompt the user to select items from the menu by entering their corresponding number.
 *         *   Allow the user to add multiple items to a single order.
 *         *   Implement a way for the user to signal the end of adding items for the current order (e.g., entering 0 or a specific command).
 *         *   Create an `Order` object containing the selected items.
 *         *   Add the newly created `Order` to the end of the order queue.
 *     *   **Process Next Order:**
 *         *   Remove and display the details (including total price) of the order at the front of the queue.
 *         *   If the queue is empty, display an appropriate message.
 *     *   **View Pending Orders:**
 *         *   Display a summary of each order currently in the queue without removing them. Indicate the order ID and the number of items.
 *         *   If the queue is empty, display an appropriate message.
 *     *   **Exit:** Terminate the application.
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out.println` for displaying menus, order details, and success messages.
 *     *   Use `System.err.println` for displaying error messages (e.g., invalid menu choice, invalid item selection, attempting to process an empty queue).
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options selected by the user.
 *     *   Use loops (e.g., `while`, `do-while`) for the main menu loop and for adding multiple items to an order.
 * 6.  **Error Handling:**
 *     *   Implement robust input validation. Handle cases where the user enters non-numeric input or numbers outside the valid range for menu options or item selection.
 *     *   Use `try-catch` blocks for exception handling, particularly around input operations that might throw exceptions (`InputMismatchException`). Implement a broad `try-catch` (e.g., catching `Exception`) around the main application loop or core logic to demonstrate class-wide handling.
 *     *   Display informative error messages using `System.err`.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Implement proper encapsulation (private fields, public getters/setters/methods where appropriate).
 *     *   Include comments to explain complex logic.
 *     *   Ensure the code is well-structured and readable.
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user via the console, presenting menus, prompting for input, and displaying results or error messages based on the chosen actions. The output should be clear and follow the standard output/error streams as specified.
 * 
 * *(Self-correction: A "class-wide" try-catch typically means wrapping the main execution logic, often in the `main` method or a primary `run` method of the main class, to catch unexpected exceptions that propagate up.)*
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based restaurant order management system, fulfilling all specified requirements and demonstrating advanced Java concepts.
 * 
 * 1.  **Data Structures:**
 *     *   `menuItems`: Declared as `List<MenuItem>` and initialized with `new ArrayList<>()`. This adheres to the requirement of using the `List` interface and the `ArrayList` implementation for the menu. `ArrayList` is suitable here as we need indexed access (for selecting items by number) and iteration.
 *     *   `orderQueue`: Declared as `Queue<Order>` and initialized with `new LinkedList<>()`. This meets the requirement of using the `Queue` interface. `LinkedList` is a common implementation for `Queue` as it efficiently supports adding to the end and removing from the beginning, which are the core `Queue` operations (`offer`/`add` and `poll`).
 * 
 * 2.  **Classes:**
 *     *   `MenuItem`: A simple Plain Old Java Object (POJO) with `private` fields (`name`, `price`) and `public` getter methods, demonstrating encapsulation. Includes a `toString()` for easy printing.
 *     *   `Order`: Represents an order with a unique `orderId` (managed by a `static` counter), a `List<MenuItem>` to hold the items (using `ArrayList` internally), and a calculated `total`. It has a method `addItem` to add items and update the total, and a `toString()` method to display order details. Encapsulation is used for its fields.
 *     *   `RestaurantSystem`: The main class containing the `menuItems` `List`, the `orderQueue` `Queue`, and the `Scanner`. It orchestrates the application flow.
 * 
 * 3.  **Functionality:**
 *     *   The constructor initializes the menu with sample items and the queue.
 *     *   `displayMainMenu()`: Prints the user options to `System.out`.
 *     *   `displayMenu()`: Iterates through `menuItems` and prints each item using `System.out`.
 *     *   `addOrderFromInput()`: This method handles the complexity of creating an order. It loops, presenting the menu and prompting the user for item numbers. It uses input validation (`hasNextInt`, checking range) and adds selected items to a temporary `Order` object. Entering 0 breaks the loop. The completed order is then added to the `orderQueue` using `add()`.
 *     *   `processNextOrder()`: Uses `orderQueue.poll()` to get and remove the head of the queue. It checks if the result is `null` (meaning the queue was empty) and prints an appropriate message to `System.err` or the processed order details to `System.out`.
 *     *   `viewOrderQueue()`: Iterates through the `orderQueue` using an enhanced for loop (which implicitly uses an iterator) to display a summary of each pending order *without* removing them. It checks if the queue is empty and prints a message to `System.err` if it is.
 *     *   `run()`: Contains the main application loop (`while(running)`). It displays the menu, reads user input, and uses a `switch` statement to dispatch to the appropriate methods based on the user's choice. Option 5 sets `running` to `false`, exiting the loop.
 *     *   `main()`: The entry point, which creates an instance of `RestaurantSystem` and calls its `run()` method.
 * 
 * 4.  **Input/Output:**
 *     *   `java.util.Scanner` is used throughout `addOrderFromInput()` and `run()` to read user input.
 *     *   `System.out.println` is used for displaying menus, prompts, successful operations, and order details.
 *     *   `System.err.println` is used specifically for error messages like invalid input, invalid choices, or attempting operations on an empty queue.
 * 
 * 5.  **Control Flow:**
 *     *   A `while` loop in `run()` keeps the application running until the user chooses to exit.
 *     *   A `switch` statement in `run()` directs execution based on the user's main menu choice.
 *     *   A `while` loop in `addOrderFromInput()` allows adding multiple items to a single order until the user enters 0.
 * 
 * 6.  **Error Handling:**
 *     *   Input validation is performed using `scanner.hasNextInt()` before reading an integer to prevent `InputMismatchException`. If non-integer input is detected, an error is printed to `System.err`, the invalid input is consumed, and the loop continues.
 *     *   Validation is performed to check if item numbers entered during order creation are within the valid range of menu indices. Invalid numbers result in an error message on `System.err`.
 *     *   Checking `orderQueue.isEmpty()` or the result of `orderQueue.poll()` is done before attempting to process or view orders, preventing errors and providing user-friendly messages on `System.err`.
 *     *   A `try-catch(Exception e)` block is wrapped around the core logic within the `run()` loop. This serves as the "class-wide" or main application loop exception handler, catching any unexpected runtime exceptions that might occur and printing an error message and stack trace to `System.err` before potentially allowing the application to continue (depending on the error). A specific `catch (InputMismatchException e)` is also included, though the `hasNextInt()` check makes it less critical, it demonstrates handling specific exceptions.
 * 
 * 7.  **Best Practices:**
 *     *   Field members in `MenuItem`, `Order`, and `RestaurantSystem` are `private`.
 *     *   Public methods (`getters`, `addItem`, `run`, etc.) provide controlled access.
 *     *   Variable names (`menuItems`, `orderQueue`, `itemChoice`, `processedOrder`) and method names (`displayMenu`, `addOrderFromInput`, `processNextOrder`) are descriptive.
 *     *   Comments are used to explain the purpose of classes and methods.
 *     *   The code is structured into logical methods, making it modular and easier to understand.
 *     *   The `Scanner` is closed upon exiting the application.
 * 
 * This solution effectively integrates all required Java components into a functional, well-structured, and robust console application that simulates a real-world scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the menu
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " - $" + String.format("%.2f", price);
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items;
    private double total;

    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>();
        this.total = 0.0;
    }

    public int getOrderId() {
        return orderId;
    }

    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
            this.total += item.getPrice();
        }
    }

    public List<MenuItem> getItems() {
        return items; // Return a copy or make it unmodifiable if strict encapsulation needed
    }

    public double getTotal() {
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(":\n");
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append(" ($").append(String.format("%.2f", item.getPrice())).append(")\n");
        }
        sb.append("Total: $").append(String.format("%.2f", total));
        return sb.toString();
    }
}

// Main class managing the restaurant system
public class RestaurantSystem {

    private List<MenuItem> menuItems; // List interface, initialized with ArrayList
    private Queue<Order> orderQueue;   // Queue interface, initialized with LinkedList
    private Scanner scanner;

    public RestaurantSystem() {
        // Initialize menu
        menuItems = new ArrayList<>();
        menuItems.add(new MenuItem("Burger", 8.99));
        menuItems.add(new MenuItem("Pizza", 12.50));
        menuItems.add(new MenuItem("Fries", 3.49));
        menuItems.add(new MenuItem("Soda", 1.99));
        menuItems.add(new MenuItem("Salad", 7.00));

        // Initialize order queue
        orderQueue = new LinkedList<>();

        // Initialize scanner
        scanner = new Scanner(System.in);
    }

    // Displays the main menu options
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Management System ---");
        System.out.println("1. View Menu");
        System.out.println("2. Add New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Displays the available menu items
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menuItems.size(); i++) {
            System.out.println((i + 1) + ". " + menuItems.get(i));
        }
        System.out.println("------------");
    }

    // Handles the process of adding a new order from user input
    private void addOrderFromInput() {
        Order newOrder = new Order();
        System.out.println("\n--- Adding New Order ---");
        System.out.println("Enter item number to add to order (0 to finish):");

        while (true) {
            displayMenu();
            System.out.print("Enter item number (0 to finish): ");
            int itemChoice = -1;
            try {
                itemChoice = scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
                continue; // Ask again
            }

            if (itemChoice == 0) {
                break; // Finish adding items
            }

            if (itemChoice > 0 && itemChoice <= menuItems.size()) {
                MenuItem selectedItem = menuItems.get(itemChoice - 1);
                newOrder.addItem(selectedItem);
                System.out.println(selectedItem.getName() + " added to order.");
            } else {
                System.err.println("Invalid item number. Please select from the menu.");
            }
        }

        if (newOrder.getItems().isEmpty()) {
            System.out.println("No items added. Order cancelled.");
        } else {
            orderQueue.add(newOrder);
            System.out.println("Order #" + newOrder.getOrderId() + " added to the queue.");
        }
    }

    // Processes the next order in the queue
    private void processNextOrder() {
        System.out.println("\n--- Processing Order ---");
        Order processedOrder = orderQueue.poll(); // Retrieve and remove the head of the queue

        if (processedOrder != null) {
            System.out.println("Processed:");
            System.out.println(processedOrder);
        } else {
            System.err.println("No pending orders to process.");
        }
    }

    // Views all pending orders in the queue without removing them
    private void viewOrderQueue() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.err.println("The order queue is empty.");
        } else {
            int position = 1;
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(position + ". Order #" + order.getOrderId() + " (" + order.getItems().size() + " items)");
                position++;
            }
        }
        System.out.println("----------------------");
    }

    // Runs the main application loop
    public void run() {
        boolean running = true;
        while (running) {
            try {
                displayMainMenu();
                int choice = -1;
                
                // Input validation for main menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }
                
                // Consume the newline character left by nextInt()
                scanner.nextLine(); 

                // Use switch for main menu control
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        addOrderFromInput();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewOrderQueue();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Restaurant Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                 // This catch is less likely to be hit with the hasNextInt() check,
                 // but kept for robustness or if input handling changes.
                 System.err.println("An unexpected input error occurred. Please try again.");
                 scanner.next(); // Consume the invalid input
            } catch (Exception e) {
                // Class-wide exception handling for any other unexpected errors
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
                // Decide whether to continue or exit based on error severity
                // For this example, we'll allow it to continue
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
