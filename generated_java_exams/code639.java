/*
 * Exam Question #639
 * Generated on: 2025-05-12 16:18:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application to manage a queue of tasks. The system should allow users to add new tasks, process the next available task, view pending tasks, and view completed tasks. This system simulates a basic workflow where tasks are handled in the order they are received (FIFO).
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each task should have a unique integer ID and a String description.
 * 2.  **Task Management System:** Create a class named `TaskProcessingSystem` that manages the collection of tasks.
 *     *   It must maintain a queue of tasks that are waiting to be processed. Use `java.util.Queue`.
 *     *   It must maintain a list of tasks that have been completed. Use `java.util.ArrayList` and declare variables using the `java.util.List` interface type where appropriate (e.g., method return types).
 *     *   Implement methods for:
 *         *   Adding a new task to the pending queue. Tasks should be assigned sequential IDs starting from 1.
 *         *   Processing the next task from the pending queue. The processed task should be moved to the completed list.
 *         *   Retrieving or displaying the list of pending tasks.
 *         *   Retrieving or displaying the list of completed tasks.
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 3.  **User Interface:** Create a main application class (e.g., `TaskSystemApp`) with a `main` method to handle user interaction via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Display normal output messages and task details using `System.out`.
 *     *   Display error messages (e.g., invalid input, trying to process an empty queue, empty task description) using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu selection (ensure it's an integer within the valid range). Handle `NumberFormatException` if the input is not an integer.
 *     *   Implement validation for the task description (it cannot be empty or null).
 *     *   Handle the case where the user tries to process a task when the pending queue is empty.
 *     *   Use `try-catch` blocks for exception handling. Demonstrate class-wide exception handling by wrapping the main application loop or critical sections in a `try-catch` block that catches general `Exception` or specific exceptions.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts.
 *     *   Include basic documentation (e.g., Javadoc comments for classes/methods).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide feedback based on the user's actions. Error messages should go to `System.err`, and normal messages/task lists to `System.out`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Clean the room
 * Task added: [ID: 1] Clean the room
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: [ID: 2] Buy groceries
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 1] Clean the room
 * [ID: 2] Buy groceries
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing task: [ID: 1] Clean the room
 * Task processed.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 2] Buy groceries
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [ID: 1] Clean the room
 * -----------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing task: [ID: 2] Buy groceries
 * Task processed.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * System.err: No tasks in the pending queue to process.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: invalid
 * System.err: Invalid input. Please enter a number.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 6
 * System.err: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description:
 * System.err: Task description cannot be empty.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should include the `Task` class, `TaskProcessingSystem` class, and the main application class (`TaskSystemApp`) in a single file for submission convenience, or clearly indicate how they would be structured if in separate files.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to problem requirements and logic.
 * *   Proper encapsulation and code structure.
 * *   Effective input validation and error handling.
 * *   Meaningful naming and comments.
 * *   Program correctness based on expected output.
 * 
 * **GOOD LUCK!**
 *
 * EXPLANATION:
 * This solution implements a simple Task Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic class to encapsulate task data (`id` and `description`) with a constructor and getter methods. The `toString()` method is overridden for convenient printing. It follows encapsulation principles with private fields and public accessors.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   **`Queue<Task> pendingTasks;`**: A `Queue` is used to store tasks waiting to be processed. The `LinkedList` class is used as the concrete implementation because it provides FIFO behavior and implements the `Queue` interface. Tasks are added using `offer()` and removed using `poll()`.
 *     *   **`List<Task> completedTasks;`**: An `ArrayList` is used to store tasks after they have been processed. `ArrayList` is suitable here as we primarily add to the end and iterate through the list, and random access isn't a core requirement, but it's a common and efficient list implementation. The variable is declared using the `List` interface type (`List<Task> completedTasks`), demonstrating the use of the interface.
 *     *   **`private int nextTaskId;`**: Manages the unique ID for each new task.
 *     *   **`addTask(String description)`**: Validates the description and adds a new `Task` object with the next ID to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask()`**: Removes the head of the `pendingTasks` queue using `poll()`. If the queue is empty, `poll()` returns `null`, which is handled by printing an error message to `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   **`getPendingTasks()` / `getCompletedTasks()`**: These methods return `List<Task>`. `getPendingTasks()` returns a copy (`new ArrayList<>(pendingTasks)`) to prevent external modification of the internal queue structure, while `getCompletedTasks()` returns the internal `ArrayList`. Both use the `List` interface as the return type.
 * 
 * 3.  **`TaskSystemApp` Class:**
 *     *   **`main` method**: The entry point of the application. It creates instances of `TaskProcessingSystem` and `TaskSystemApp` and calls the `run()` method.
 *     *   **`Scanner scanner;`**: Used to read user input from `System.in`.
 *     *   **`displayMenu()`**: Prints the available options to `System.out`.
 *     *   **`run()` method**: Contains the main application loop.
 *         *   **Class-wide `try-catch (Exception e)`**: Wraps the entire `while` loop to demonstrate handling unexpected exceptions that might occur anywhere within the main execution flow. Errors are printed to `System.err`.
 *         *   **Input `try-catch (NumberFormatException e)`**: Handles cases where the user's menu input is not a valid integer. The error is printed to `System.err`, and `continue` restarts the loop, prompting the user again. Reading the full line (`scanner.nextLine()`) before parsing helps avoid issues with leftover newlines in the input buffer.
 *         *   **`switch (choice)`**: Controls the program flow based on the user's validated menu choice. Each case calls the appropriate method in the `TaskProcessingSystem` or handles the exit logic.
 *         *   **`System.out` / `System.err`**: Used throughout for normal output (menu, confirmations, task lists) and error messages (invalid input, empty queue/description).
 *         *   **List Iteration**: Cases 3 and 4 demonstrate iterating through the `List<Task>` returned by the system methods to print task details using `System.out`.
 *         *   **`finally` block**: Ensures the `Scanner` resource is closed properly, even if an exception occurs, preventing resource leaks.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating object-oriented principles, data structure usage, input handling, flow control, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "[ID: " + id + "] " + description;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessingSystem {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the pending and completed task collections.
     */
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return true if the task was added successfully, false otherwise.
     */
    public boolean addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Task description cannot be empty.");
            return false;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for capacity-constrained queues
        System.out.println("Task added: " + newTask);
        return true;
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     * @return The processed task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess == null) {
            System.err.println("No tasks in the pending queue to process.");
            return null;
        }
        System.out.println("Processing task: " + taskToProcess);
        completedTasks.add(taskToProcess);
        System.out.println("Task processed.");
        return taskToProcess;
    }

    /**
     * Returns a list of pending tasks.
     * @return A List of pending Task objects.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // to avoid exposing the internal Queue implementation directly,
        // although for this exam context, returning the list for iteration is fine.
        // A simple approach for display purposes within the app class:
        return new ArrayList<>(pendingTasks); // Return a copy
    }

    /**
     * Returns a list of completed tasks.
     * @return A List of completed Task objects.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Returning the internal list for iteration
    }

    /**
     * Gets the number of pending tasks.
     * @return The count of tasks in the pending queue.
     */
    public int getPendingTaskCount() {
        return pendingTasks.size();
    }

    /**
     * Gets the number of completed tasks.
     * @return The count of tasks in the completed list.
     */
    public int getCompletedTaskCount() {
        return completedTasks.size();
    }
}

/**
 * Main application class for the Task Processing System.
 * Handles user interaction and menu operations.
 */
public class TaskSystemApp {

    private TaskProcessingSystem system;
    private Scanner scanner;

    /**
     * Constructs the TaskSystemApp.
     */
    public TaskSystemApp() {
        system = new TaskProcessingSystem();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Processing System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate system methods.
     */
    public void run() {
        // Class-wide exception handling demonstration
        try {
            boolean running = true;
            while (running) {
                displayMenu();

                int choice = -1; // Default invalid choice
                try {
                    // Read the entire line to consume newline after number
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Go back to the start of the loop
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        system.addTask(description);
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        System.out.println("--- Pending Tasks ---");
                        List<Task> pending = system.getPendingTasks(); // Using List interface
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task); // Task.toString() is called
                            }
                        }
                        System.out.println("---------------------");
                        break;
                    case 4:
                        System.out.println("--- Completed Tasks ---");
                        List<Task> completed = system.getCompletedTasks(); // Using List interface
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task); // Task.toString() is called
                            }
                        }
                        System.out.println("-----------------------");
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskSystemApp app = new TaskSystemApp();
        app.run();
    }
}
