/*
 * Exam Question #274
 * Generated on: 2025-05-11 22:48:14
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Problem Description:**
 * 
 * You are required to build a command-line application simulating a simple task management system. This system should allow users to manage a queue of incoming tasks and a list of completed tasks. Users should be able to add new tasks, process the next task in the queue, view the current queue, view completed tasks, and exit the application.
 * 
 * **Technical Requirements:**
 * 
 * 1.  Create a `Task` class with a private `String` field for the task description and appropriate public methods (constructor, getter, `toString`).
 * 2.  Create a `TaskManager` class that will manage the tasks.
 * 3.  The `TaskManager` class must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed. You should use an implementation like `java.util.LinkedList`.
 * 4.  The `TaskManager` class must use a `java.util.List<Task>` to store tasks that have been completed. You must declare the variable using the `List` interface type, and instantiate it using `java.util.ArrayList`.
 * 5.  Use `java.util.Scanner` to read user input from the console for menu choices and task descriptions.
 * 6.  Implement a main application loop within the `TaskManager` class's `run()` method that presents a menu and uses a `switch` statement to handle the user's choice.
 * 7.  Use `System.out` for displaying the menu, prompts, success messages, and the contents of the task queue and completed tasks list.
 * 8.  Use `System.err` to display error messages (e.g., attempting to process a task when the queue is empty, invalid user input).
 * 9.  Implement class-wide exception handling within the `TaskManager` class. Wrap the main application loop (`run()` method) in a `try-catch` block to catch potential runtime exceptions. Include a `finally` block to ensure resources like the `Scanner` are properly closed.
 * 10. Implement input validation for user choices and task descriptions (e.g., ensure task description is not empty, handle non-numeric input for menu choices).
 * 11. Adhere to Java programming best practices:
 *     *   Use private fields and public methods for proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex parts or logic.
 *     *   Ensure proper resource management (like closing the `Scanner`).
 * 
 * **Menu Options:**
 * 
 * 1.  **Add New Task:** Prompt the user for a task description and add a new `Task` object to the waiting queue.
 * 2.  **Process Next Task:** Remove the task at the head of the queue and add it to the list of completed tasks. If the queue is empty, display an error message using `System.err`.
 * 3.  **View Task Queue:** Display all tasks currently in the waiting queue, in the order they are waiting. If the queue is empty, indicate so.
 * 4.  **View Completed Tasks:** Display all tasks that have been processed, in the order they were completed. If the list is empty, indicate so.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Expected Interaction and Output:**
 * 
 * *   The program should start by displaying the menu.
 * *   After each valid operation (except Exit), the menu should be displayed again.
 * *   Prompts for input should be clear (e.g., "Enter task description: ").
 * *   Success messages should confirm successful operations (e.g., "Task added...", "Processed task...").
 * *   Error messages should be printed to `System.err` and clearly explain the issue (e.g., "Error: Task queue is empty.", "Error: Invalid choice.").
 * *   Viewing tasks should list them clearly or state if the collection is empty.
 * *   Invalid input (non-numeric choice, empty task description) should be handled gracefully with error messages printed to `System.err`.
 * 
 * Your solution should be a single Java file containing both the `Task` and `TaskManager` classes.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic Plain Old Java Object (POJO) representing a task with a single `description` field. It includes a constructor, a getter, and an overridden `toString()` method for easy printing. Encapsulation is maintained by making the field `private`.
 * 
 * 2.  **`TaskManager` Class:** This is the core class managing the task workflow.
 *     *   **Collections:** It uses a `Queue<Task>` (`taskQueue`) implemented by `LinkedList` to maintain tasks in a First-In, First-Out (FIFO) order, suitable for processing tasks sequentially. It also uses a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store tasks once they are finished, allowing ordered storage and retrieval by index if needed (though simple iteration is used here). The use of `List` interface for declaration fulfills that specific requirement while using `ArrayList` for implementation.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read user input from `System.in`. It's managed within the `TaskManager` class.
 *     *   **Methods:**
 *         *   `addTask(String description)`: Takes a description, validates it (not empty), creates a `Task` object, and adds it to the `taskQueue` using `offer()`. Uses `System.out` for success or `System.err` for validation errors.
 *         *   `processNextTask()`: Checks if the `taskQueue` is empty. If not, it removes the head task using `poll()` and adds it to the `completedTasks` list. Uses `System.out` for success or `System.err` if the queue is empty.
 *         *   `viewTaskQueue()`: Iterates through the `taskQueue` (without removing elements) and prints the description of each task using `System.out`. Handles the case where the queue is empty.
 *         *   `viewCompletedTasks()`: Iterates through the `completedTasks` list and prints the description of each task using `System.out`. Handles the case where the list is empty.
 *         *   `displayMenu()`: A private helper method to print the menu options to `System.out`.
 *         *   `run()`: Contains the main application loop (`while(running)`). It repeatedly displays the menu, reads user input, and processes the choice.
 *     *   **`switch` Statement:** Inside the `run()` method, a `switch` statement is used to direct execution based on the user's numeric menu choice, calling the appropriate methods (`addTask`, `processNextTask`, etc.).
 *     *   **Input Validation:** Within `run()`, before the `switch`, the user's input line is validated:
 *         *   It checks if the input line is empty.
 *         *   It uses a nested `try-catch (NumberFormatException)` block to ensure the input can be parsed as an integer. If not, an error is printed to `System.err`, and the loop continues.
 *         *   The `default` case in the `switch` handles numeric inputs that are outside the valid range (1-5), printing an error to `System.err`.
 *         *   `addTask` method specifically validates that the task description is not empty.
 *     *   **Class-wide Exception Handling (`try-catch-finally`):** The entire `while(running)` loop in the `run()` method is enclosed in a `try-catch(Exception e)` block. This serves as a class-wide handler for any unexpected runtime exceptions that might occur during the execution of the main application logic. A `System.err` message reports the error. The `finally` block is used to guarantee that the `scanner` resource is closed, preventing resource leaks, regardless of whether the loop finishes normally or an exception occurs.
 *     *   **`main` Method:** Creates an instance of `TaskManager` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all the required components, demonstrates practical error handling, input validation, and follows good object-oriented design principles within the context of a simple, practical command-line application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although reading lines, good practice if reading other types

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return The task description formatted as a string.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a queue of waiting tasks and a list of completed tasks.
 */
public class TaskManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> taskQueue;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // LinkedList implements the Queue interface and is suitable for queue operations
        this.taskQueue = new LinkedList<>();
        // ArrayList is a common implementation for the List interface
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the waiting queue.
     * Performs validation to ensure the description is not empty.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty. Task not added.");
            return;
        }
        Task newTask = new Task(description.trim());
        // offer() is the preferred method for adding to a queue
        taskQueue.offer(newTask);
        System.out.println("Success: Task added to queue: \"" + description.trim() + "\"");
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue and adds it to the completed tasks list.
     * Displays an error if the queue is empty.
     */
    public void processNextTask() {
        // check if the queue is empty before attempting to poll
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. No tasks to process.");
            return;
        }
        // poll() retrieves and removes the head of the queue
        Task nextTask = taskQueue.poll();
        completedTasks.add(nextTask);
        System.out.println("Success: Processed task: \"" + nextTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    public void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list of completed tasks
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i).getDescription());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Simple Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                String inputLine = scanner.nextLine(); // Read the entire line input

                // Basic validation for empty input line
                if (inputLine.trim().isEmpty()) {
                    System.err.println("Error: Please enter a choice.");
                    continue; // Skip the rest of the loop and show menu again
                }

                int choice;
                try {
                    // Attempt to parse the input as an integer
                    choice = Integer.parseInt(inputLine.trim());
                } catch (NumberFormatException e) {
                    // Handle cases where the input is not a valid number
                    System.err.println("Error: Invalid input. Please enter a number corresponding to the menu options.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use a switch statement to handle different menu choices
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine(); // Read the task description
                        addTask(description); // Call method to add task
                        break;
                    case 2:
                        processNextTask(); // Call method to process task
                        break;
                    case 3:
                        viewTaskQueue(); // Call method to view queue
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle choices that are numbers but not between 1 and 5
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the application's main loop
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
             // Ensure the scanner resource is closed when the application exits or errors out
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * The main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application loop
    }
}
