/*
 * Exam Question #859
 * Generated on: 2025-05-12 16:51:33
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Scheduler Simulation
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple Task Scheduler application in Java. This application will manage a list of tasks that need to be executed. Tasks are added to a queue for processing. Once a task is executed, it is moved to a list of completed tasks. The application should interact with the user via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (String): The priority level (e.g., "normal", "high").
 *     *   `isCompleted` (boolean): Indicates whether the task has been completed.
 *     *   Include a constructor, appropriate getters, a setter for `isCompleted`, and a `toString()` method to display task details.
 * 
 * 2.  **Task Scheduler Logic:** Create a `TaskScheduler` class that manages the tasks. It should contain:
 *     *   A `Queue<Task>` to hold tasks waiting for execution. Use a `LinkedList` implementation.
 *     *   A `List<Task>` to hold completed tasks. Use an `ArrayList` implementation.
 *     *   A mechanism to generate unique task IDs (e.g., a counter).
 *     *   Methods for the following operations:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` object and adds it to the pending tasks queue. Assigns a unique ID. Validates that description is not empty and priority is either "normal" or "high" (case-insensitive).
 *         *   `executeNextTask()`: Removes the task at the head of the pending tasks queue, marks it as completed, and adds it to the completed tasks list. Handles the case where the queue is empty.
 *         *   `listAllTasks()`: Displays both pending and completed tasks.
 *         *   `listPendingTasks()`: Displays only tasks currently in the queue.
 *         *   `listCompletedTasks()`: Displays only tasks in the completed list.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method or a separate `run` method within `TaskScheduler`. The user should be presented with a menu and can enter commands to perform the operations.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Use a `switch` statement to handle different user commands (e.g., "add", "execute", "list all", "list pending", "list completed", "exit").
 *     *   Display prompts and output using `System.out`.
 *     *   Display error messages (e.g., invalid input, invalid command) using `System.err`.
 * 
 * 4.  **Error Handling and Best Practices:**
 *     *   Implement input validation within the `addTask` method and handle invalid input gracefully using `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential runtime errors during command processing. Print a generic error message to `System.err` if an unexpected exception occurs.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc for classes/methods, inline for complex logic) and documentation.
 *     *   Structure the code cleanly (e.g., separate `Task` and `TaskScheduler` classes).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Expected Output:**
 * 
 * The program should display a menu of options. Based on user input, it should perform the requested action and print results or error messages.
 * 
 * *   Adding a task should confirm success or report validation errors.
 * *   Executing a task should confirm completion or indicate if the queue is empty.
 * *   Listing tasks should display the details of the relevant tasks in a readable format, clearly indicating pending vs. completed status.
 * *   Invalid commands should result in an error message on `System.err`.
 * *   Unexpected errors during processing should be caught and reported via `System.err`.
 * *   The program should terminate when the user enters the "exit" command.
 * 
 * Implement the complete Java code for the `Task` and `TaskScheduler` classes.
 *
 * EXPLANATION:
 * This solution provides a complete implementation of the Task Scheduler application as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** A simple POJO (`Plain Old Java Object`) representing a task. It encapsulates task data (`id`, `description`, `priority`, `isCompleted`) with private fields and public getter/setter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **TaskScheduler Class:** This is the core class managing the application state and logic.
 *     *   **`Queue<Task> pendingTasks = new LinkedList<>();`**: A `LinkedList` is used as the concrete implementation of the `Queue` interface. This collection stores tasks waiting to be processed in a FIFO (First-In, First-Out) manner, which is typical for a basic task queue.
 *     *   **`List<Task> completedTasks = new ArrayList<>();`**: An `ArrayList` is used as the concrete implementation of the `List` interface. This collection stores tasks that have been executed. Using `List` as the type for `completedTasks` is good practice, programming to the interface rather than the implementation.
 *     *   **`nextTaskId`**: A simple integer counter ensures each task gets a unique ID.
 *     *   **`addTask(String description, String priority)`**: This method demonstrates input validation. It checks if the description is empty and if the priority is one of the allowed values ("normal" or "high"), printing errors to `System.err` if validation fails. Valid tasks are added to the `pendingTasks` queue using `queue.add()`.
 *     *   **`executeNextTask()`**: This method demonstrates queue operations. It first checks if the queue is empty. If not, it uses `queue.poll()` to retrieve and remove the task at the head of the queue. The task's status is updated, and it's moved to the `completedTasks` list using `list.add()`.
 *     *   **`list...Tasks()` methods**: These methods iterate over the respective collections (`Queue` and `List`) to display task details using the `Task` class's `toString()` method. Listing pending tasks iterates over the queue without removing elements.
 *     *   **`run()` method**: This method contains the main application loop.
 *         *   **`Scanner scanner = new Scanner(System.in);`**: Used to read user input from the console.
 *         *   **`while (true)` loop**: Keeps the application running until explicitly exited.
 *         *   **`try { ... } catch (Exception e) { ... }`**: This block demonstrates class-wide exception handling. It wraps the `switch` statement that processes user commands. Any unexpected `RuntimeException` or other `Exception` that might occur during command execution (e.g., a `NullPointerException` if there's a logic error not covered by specific checks) is caught here, and an error message is printed to `System.err`. This provides a safety net against program crashes.
 *         *   **`switch (command)`**: Used to control the flow based on the user's input command string, directing execution to the appropriate method (`addTask`, `executeNextTask`, etc.).
 *         *   **`System.out` and `System.err`**: Used correctly, `System.out` for normal application output (menu, prompts, successful operations, list contents) and `System.err` for reporting errors (validation failures, invalid commands, unexpected exceptions).
 *         *   **`scanner.close()`**: Important for resource management to close the `Scanner` when the program exits.
 * 
 * 3.  **Required Components Usage:** The code explicitly uses `Queue` (`LinkedList`), `ArrayList`, `List` (as the type for `completedTasks`), `Scanner`, `switch`, `System.err`, `System.out`, and a `try-catch` block around the main command processing logic.
 * 
 * 4.  **Best Practices:** The solution adheres to best practices by using meaningful names, private fields, public methods, comments (including Javadoc), basic input validation, and error handling. The code is structured into two classes with clear responsibilities.
 * 
 * This solution effectively combines the required Java elements into a functional, albeit simple, task management simulation, suitable for demonstrating understanding of core Java concepts and collection usage.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Locale; // To handle case-insensitive priority check

// Task class representing a single task
class Task {
    private int id;
    private String description;
    private String priority;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description A brief description of the task.
     * @param priority The priority level ("normal" or "high").
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Tasks start as not completed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // --- Setter ---
    public void setCompleted(boolean completed) {
        isCompleted = completed;
    }

    /**
     * Returns a string representation of the Task.
     * Includes ID, description, priority, and status.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: '%s', Priority: %s, Status: %s",
                id, description, priority, isCompleted ? "Completed" : "Pending");
    }
}

// TaskScheduler class managing the task queue and completed list
public class TaskScheduler {
    private Queue<Task> pendingTasks; // Queue for tasks waiting to be executed
    private List<Task> completedTasks; // List for completed tasks
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskScheduler.
     * Initializes the pending and completed task collections and the ID counter.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Performs validation on description and priority.
     * @param description The description of the task.
     * @param priority The priority of the task ("normal" or "high").
     */
    public void addTask(String description, String priority) {
        // --- Input Validation ---
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        String lowerPriority = priority != null ? priority.trim().toLowerCase(Locale.US) : "";
        if (!lowerPriority.equals("normal") && !lowerPriority.equals("high")) {
            System.err.println("Error: Invalid priority. Priority must be 'normal' or 'high'.");
            return;
        }
        // --- End Validation ---

        Task newTask = new Task(nextTaskId++, description.trim(), lowerPriority);
        pendingTasks.add(newTask); // Add to the tail of the queue (FIFO)
        System.out.println("Task added successfully: " + newTask.toString());
    }

    /**
     * Executes the next task from the head of the pending tasks queue.
     * Moves the executed task to the completed tasks list.
     */
    public void executeNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to execute.");
            return;
        }

        Task taskToExecute = pendingTasks.poll(); // Get and remove the head of the queue
        taskToExecute.setCompleted(true);
        completedTasks.add(taskToExecute); // Add to the completed list

        System.out.println("Task executed: " + taskToExecute.toString());
    }

    /**
     * Lists all tasks, first pending then completed.
     */
    public void listAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (pendingTasks.isEmpty() && completedTasks.isEmpty()) {
            System.out.println("No tasks available.");
            return;
        }

        listPendingTasks(); // Reuse existing method
        System.out.println("---"); // Separator
        listCompletedTasks(); // Reuse existing method
        System.out.println("-----------------");
    }

    /**
     * Lists only the pending tasks currently in the queue.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating over a Queue allows viewing elements without removing them
            pendingTasks.forEach(System.out::println);
        }
    }

    /**
     * Lists only the completed tasks.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterating over a List is straightforward
            completedTasks.forEach(System.out::println);
        }
    }

    /**
     * Runs the main command-line interface loop.
     * Handles user input and dispatches commands.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("--- Task Scheduler ---");

        while (true) {
            printMenu();
            System.out.print("Enter command: ");
            String command = scanner.nextLine().trim().toLowerCase(Locale.US);

            // --- Class-wide Exception Handling ---
            try {
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (normal/high): ");
                        String priority = scanner.nextLine();
                        addTask(description, priority);
                        break;
                    case "execute":
                        executeNextTask();
                        break;
                    case "list all":
                        listAllTasks();
                        break;
                    case "list pending":
                        listPendingTasks();
                        break;
                    case "list completed":
                        listCompletedTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        scanner.close(); // Close the scanner
                        return; // Exit the run method and thus the program
                    default:
                        System.err.println("Error: Unknown command. Please use 'add', 'execute', 'list all', 'list pending', 'list completed', or 'exit'.");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }
            System.out.println(); // Add a newline for better readability between commands
        }
    }

    /**
     * Prints the available menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nAvailable Commands:");
        System.out.println("  add          - Add a new task");
        System.out.println("  execute      - Execute the next pending task");
        System.out.println("  list all     - List all tasks (pending and completed)");
        System.out.println("  list pending - List only pending tasks");
        System.out.println("  list completed - List only completed tasks");
        System.out.println("  exit         - Exit the application");
    }

    /**
     * Main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
