/*
 * Exam Question #954
 * Generated on: 2025-05-12 17:04:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Call Center Simulation**
 * 
 * **Scenario:** You are tasked with building a simplified simulation of a customer service call center. The system needs to manage incoming calls by placing them in a waiting queue and then assigning them to agents when they become available. The system should also keep track of calls that have been completed.
 * 
 * **Task:** Implement a Java program that simulates this call center. Your solution must demonstrate advanced understanding of core Java concepts and collections, adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **`Call` Class:**
 *     *   Create a class named `Call` to represent a customer call.
 *     *   It must have two private fields: a unique integer `callId` and a `String description`.
 *     *   Implement a public constructor `Call(int callId, String description)` to initialize these fields.
 *     *   Provide public getter methods for both `callId` and `description`.
 *     *   Override the `toString()` method to provide a clear string representation of a `Call` object (e.g., "Call ID: [id], Description: [description]").
 *     *   Ensure proper encapsulation.
 * 
 * 2.  **`CallCenter` Class:**
 *     *   Create a class named `CallCenter` to manage the state of the simulation.
 *     *   It must use a `java.util.Queue<Call>` to hold calls that are waiting to be assigned to an agent. Use `java.util.LinkedList` as the concrete implementation for the Queue.
 *     *   It must use a `java.util.List<Call>` (specifically `java.util.ArrayList`) to store calls that have been successfully assigned to an agent (completed calls).
 *     *   Declare the waiting calls field using the `Queue` interface and the completed calls field using the `List` interface.
 *     *   Implement a public constructor `CallCenter()` to initialize the queue and the list.
 *     *   Implement the following public methods:
 *         *   `void addCall(Call call)`: Adds a given `Call` object to the waiting queue.
 *         *   `Call assignCallToAgent()`: Removes the next call from the front of the waiting queue and adds it to the completed calls list. This method should return the assigned `Call` object, or `null` if the waiting queue is empty.
 *         *   `java.util.List<Call> getWaitingCalls()`: Returns a `List` containing the calls currently in the waiting queue. (Returning a new `ArrayList` copy of the queue elements is acceptable for easy iteration).
 *         *   `java.util.List<Call> getCompletedCalls()`: Returns the `List` of completed calls.
 *     *   Ensure proper encapsulation for the collection fields.
 * 
 * 3.  **Main Application (`CallCenterApp` class):**
 *     *   Create a class named `CallCenterApp` with a `public static void main(String[] args)` method.
 *     *   Inside `main`, create an instance of `CallCenter`.
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement a command-line interface that accepts the following single-character commands (case-insensitive, but process as uppercase):
 *         *   `A`: **Add Call**. Prompt the user to enter the Call ID (an integer) and then the Call Description (a string). Create a new `Call` object and add it to the `CallCenter` using the `addCall` method.
 *         *   `S`: **Assign Call**. Call the `assignCallToAgent` method. If a call is assigned, print a success message. If the queue was empty, print an appropriate message.
 *         *   `L`: **List Waiting Calls**. Call `getWaitingCalls` and print the details of all calls currently in the waiting queue. Indicate the number of waiting calls.
 *         *   `C`: **List Completed Calls**. Call `getCompletedCalls` and print the details of all completed calls. Indicate the number of completed calls.
 *         *   `Q`: **Quit**. Exit the application.
 *     *   Use a `switch` statement to process the user commands.
 *     *   Use `System.out` for displaying the menu, successful operations, and lists of calls.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, queue is empty when assigning, input type mismatch).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle `java.util.InputMismatchException` when reading the Call ID input. Structure your `try-catch` logic to prevent the application from crashing on invalid input and to provide informative error messages using `System.err`. A `try-catch` block wrapping the core command processing loop iteration is suitable. Include a more general catch for unexpected errors.
 *     *   Ensure the `Scanner` resource is closed properly, ideally in a `finally` block or after the main loop.
 * 
 * **Constraints & Best Practices:**
 * 
 * *   You *must* use ALL the following components: `java.util.Queue`, `java.util.ArrayList`, `java.util.List` interface, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, `try-catch` blocks for exception handling.
 * *   Adhere to best practices for encapsulation, meaningful naming, and code structure.
 * *   Include basic comments explaining classes and methods.
 * *   Provide clear and user-friendly output and error messages.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user commands as demonstrated in the following example interaction:
 * 
 * ```
 * --- Call Center Simulation Started ---
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: A
 * Enter Call ID (integer): 101
 * Enter Call Description: Customer needs help with billing
 * Call 101 added to the queue.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: A
 * Enter Call ID (integer): 102
 * Enter Call Description: Technical support required
 * Call 102 added to the queue.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: L
 * --- Waiting Calls (2) ---
 * Call ID: 101, Description: Customer needs help with billing
 * Call ID: 102, Description: Technical support required
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: S
 * Assigned Call 101 to an agent.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: L
 * --- Waiting Calls (1) ---
 * Call ID: 102, Description: Technical support required
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: C
 * --- Completed Calls (1) ---
 * Call ID: 101, Description: Customer needs help with billing
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: S
 * Assigned Call 102 to an agent.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: S
 * No calls waiting in the queue.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: X
 * Invalid command. Please try again.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: A
 * Enter Call ID (integer): abc
 * Error: Invalid input. Please enter a valid integer for Call ID.
 * 
 * --- Call Center Menu ---
 * A: Add Call
 * S: Assign Call
 * L: List Waiting Calls
 * C: List Completed Calls
 * Q: Quit
 * Enter command: Q
 * Exiting Call Center Simulation.
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simplified Call Center simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Overall Structure:** The solution is divided into three classes: `Call` (representing the data), `CallCenter` (managing the state and logic), and `CallCenterApp` (handling user interaction and the main application flow). This separation adheres to good object-oriented design principles.
 * 
 * 2.  **`Call` Class:** This class is a simple Plain Old Java Object (POJO) with private fields (`callId`, `description`) and public getter methods, demonstrating encapsulation. The `toString()` method is overridden for convenient printing of call details.
 * 
 * 3.  **`CallCenter` Class:**
 *     *   **`Queue<Call> waitingCalls`**: A `java.util.Queue` is used to store calls in a waiting line. `LinkedList` is chosen as the concrete implementation because it efficiently supports queue operations (`offer` to add to the end, `poll` to remove from the front). The field is declared using the `Queue` interface, promoting flexibility.
 *     *   **`List<Call> completedCalls`**: A `java.util.List` is used to store calls once they are assigned. `ArrayList` is chosen as the concrete implementation, suitable for storing and iterating over a collection of completed items. The field is declared using the `List` interface.
 *     *   **`addCall(Call call)`**: Uses `waitingCalls.offer(call)` to add a call to the queue.
 *     *   **`assignCallToAgent()`**: Uses `waitingCalls.poll()` to retrieve and remove the next call from the queue. `poll()` is used because it returns `null` if the queue is empty, allowing the application to handle this case gracefully without throwing an exception. If a call is retrieved, it's added to the `completedCalls` `ArrayList`.
 *     *   **`getWaitingCalls()`**: Returns a `List` representation of the waiting queue. To easily list the items using a standard loop or enhanced for loop in the `main` method, a *new* `ArrayList` is created containing all elements from the `waitingCalls` queue. This fulfills the requirement of using `ArrayList` and `List` while providing a convenient way to display queue contents.
 *     *   **`getCompletedCalls()`**: Returns the `completedCalls` `ArrayList` (typed as `List`), allowing the main application to iterate and display completed calls.
 * 
 * 4.  **`CallCenterApp` Class:**
 *     *   **`Scanner`**: A `java.util.Scanner` is used to read command-line input from `System.in`. It's closed in a `finally` block to ensure resource cleanup.
 *     *   **`switch` Statement**: The core application loop reads a command string and uses a `switch` statement to direct execution to the corresponding logic (`A`, `S`, `L`, `C`, `Q`, or default for invalid commands). This is an efficient way to handle multiple distinct command options.
 *     *   **`System.out` and `System.err`**: `System.out.println` is used for standard output like the menu, success messages, and listing calls. `System.err.println` is used specifically for error messages, such as invalid commands or attempts to assign a call when the queue is empty. This follows the convention of directing errors to the standard error stream.
 *     *   **`try-catch` Blocks (Class-wide Exception Handling)**: The `main` method demonstrates exception handling with nested `try-catch` blocks.
 *         *   The inner `try-catch` wraps the code that reads input and executes the command within each iteration of the main loop. It specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when an integer (like Call ID) is expected by `scanner.nextInt()`. Catching this specific exception allows the program to print an informative error message using `System.err`, consume the invalid input (`scanner.nextLine()`), and continue the loop, preventing a crash. A general `catch (Exception e)` is also included in this inner block to catch any other unexpected runtime errors that might occur during a command's execution, providing a fallback error message.
 *         *   The outer `try-catch` wraps the entire `while` loop. This demonstrates a form of "class-wide" or rather, "main method scope" exception handling. It catches any exceptions that might occur outside the inner block, perhaps during loop condition evaluation or other high-level issues. While Java doesn't have true class-wide handlers like some frameworks, this structure ensures that critical errors are caught, reported via `System.err`, and the `finally` block (which closes the `Scanner`) is executed. The `finally` block is crucial for resource management.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Clearly implemented in the `Call` and `CallCenter` classes.
 *     *   **Meaningful Names:** Variables (`waitingCalls`, `completedCalls`, `callId`, `description`), methods (`addCall`, `assignCallToAgent`, `getWaitingCalls`), and classes (`Call`, `CallCenter`, `CallCenterApp`) have names that reflect their purpose.
 *     *   **Comments:** Javadoc comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific code points (e.g., consuming the newline after `nextInt()`).
 *     *   **Input Validation & Error Handling:** Handled through checking the return value of `assignCallToAgent()` for `null`, the `default` case in the `switch` for invalid commands, and the `try-catch` blocks for input type errors and other exceptions. `System.err` is used appropriately for errors.
 *     *   **Clean Code Structure:** The code is organized into logical classes, and the `main` method clearly controls the application flow with a loop and switch statement. The `displayMenu` logic is extracted into a separate private method.
 * 
 * This solution effectively integrates all required components into a cohesive, practical simulation while demonstrating robust error handling and adherence to fundamental Java best practices.
 */

package com.example.callcenter; // Example package declaration

import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a customer call with a unique ID and description.
 * Demonstrates encapsulation.
 */
class Call {
    private int callId;
    private String description;

    /**
     * Constructs a new Call.
     * @param callId The unique identifier for the call.
     * @param description A brief description of the call's purpose.
     */
    public Call(int callId, String description) {
        this.callId = callId;
        this.description = description;
    }

    /**
     * Gets the unique ID of the call.
     * @return The call ID.
     */
    public int getCallId() {
        return callId;
    }

    /**
     * Gets the description of the call.
     * @return The call description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Call.
     * @return A formatted string including call ID and description.
     */
    @Override
    public String toString() {
        return "Call ID: " + callId + ", Description: " + description;
    }
}

/**
 * Manages the state of the call center, including waiting and completed calls.
 * Demonstrates usage of Queue, List, and ArrayList.
 */
class CallCenter {
    // Queue to hold calls waiting for an agent (uses LinkedList as concrete type)
    private Queue<Call> waitingCalls;
    // List to hold calls that have been assigned to an agent (uses ArrayList as concrete type)
    private List<Call> completedCalls;

    /**
     * Constructs a new CallCenter, initializing the call queues and lists.
     */
    public CallCenter() {
        // Initialize the Queue using LinkedList
        this.waitingCalls = new LinkedList<>();
        // Initialize the List using ArrayList
        this.completedCalls = new ArrayList<>();
    }

    /**
     * Adds a new call to the waiting queue.
     * @param call The call to be added.
     */
    public void addCall(Call call) {
        if (call != null) {
            waitingCalls.offer(call); // offer is preferred for queues, returns true/false instead of throwing exception on capacity limit (not relevant for LinkedList)
        }
    }

    /**
     * Assigns the next waiting call to an agent.
     * Removes the call from the waiting queue and adds it to the completed list.
     * @return The call that was assigned, or null if the waiting queue was empty.
     */
    public Call assignCallToAgent() {
        Call assignedCall = waitingCalls.poll(); // poll retrieves and removes the head, returns null if queue is empty
        if (assignedCall != null) {
            completedCalls.add(assignedCall); // Add to the completed List (ArrayList)
        }
        return assignedCall;
    }

    /**
     * Gets the current list of calls waiting in the queue.
     * Returns a new ArrayList containing the elements from the Queue for easy listing.
     * @return A List view of the waiting calls.
     */
    public List<Call> getWaitingCalls() {
        // Create and return a new ArrayList populated with elements from the Queue
        return new ArrayList<>(waitingCalls);
    }

    /**
     * Gets the current list of completed calls.
     * @return The List (ArrayList) of completed calls.
     */
    public List<Call> getCompletedCalls() {
        // Return the internal List reference
        return completedCalls;
    }
}

/**
 * Main application class for the Call Center Simulation.
 * Handles user interaction, command processing, and exception handling.
 * Demonstrates Scanner, switch, System.out, System.err, and try-catch.
 */
public class CallCenterApp {

    /**
     * The main method to run the Call Center Simulation application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        CallCenter callCenter = new CallCenter();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Call Center Simulation Started ---");

        // Class-wide (main method scope) exception handling using try-catch-finally
        // This outer block catches any exceptions not handled by the inner block,
        // ensuring the application doesn't crash unexpectedly and resources are closed.
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter command: ");
                // Read the entire line for the command
                String command = scanner.nextLine().trim().toUpperCase(); // Read command, trim whitespace, convert to uppercase

                // Inner try-catch block for handling exceptions specific to command processing,
                // like InputMismatchException during integer input. This allows the loop to continue.
                try {
                    switch (command) {
                        case "A": // Add Call
                            System.out.print("Enter Call ID (integer): ");
                            // nextInt() reads the integer but leaves the newline character in the buffer
                            int callId = scanner.nextInt();
                            scanner.nextLine(); // Consume the leftover newline character
                            System.out.print("Enter Call Description: ");
                            String description = scanner.nextLine();
                            Call newCall = new Call(callId, description);
                            callCenter.addCall(newCall);
                            System.out.println("Call " + callId + " added to the queue.");
                            break;

                        case "S": // Assign Call
                            Call assignedCall = callCenter.assignCallToAgent();
                            if (assignedCall != null) {
                                System.out.println("Assigned Call " + assignedCall.getCallId() + " to an agent.");
                            } else {
                                // Use System.err for operational errors/warnings
                                System.err.println("No calls waiting in the queue.");
                            }
                            break;

                        case "L": // List Waiting Calls
                            List<Call> waiting = callCenter.getWaitingCalls(); // Uses List interface and ArrayList returned
                            System.out.println("--- Waiting Calls (" + waiting.size() + ") ---");
                            if (waiting.isEmpty()) {
                                System.out.println("No calls currently waiting.");
                            } else {
                                for (Call call : waiting) { // Iterate using the List
                                    System.out.println(call); // Uses Call's toString()
                                }
                            }
                            break;

                        case "C": // List Completed Calls
                            List<Call> completed = callCenter.getCompletedCalls(); // Uses List interface and ArrayList
                            System.out.println("--- Completed Calls (" + completed.size() + ") ---");
                            if (completed.isEmpty()) {
                                System.out.println("No calls have been completed yet.");
                            } else {
                                for (Call call : completed) { // Iterate using the List
                                    System.out.println(call); // Uses Call's toString()
                                }
                            }
                            break;

                        case "Q": // Quit
                            running = false;
                            System.out.println("Exiting Call Center Simulation.");
                            break;

                        default: // Invalid Command
                            // Use System.err for user input errors
                            System.err.println("Invalid command. Please try again.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Specific handling for non-integer input when reading Call ID
                    System.err.println("Error: Invalid input. Please enter a valid integer for Call ID.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input (e.g., "abc") to prevent an infinite loop
                } catch (Exception e) {
                    // Generic catch for any other unexpected errors during a command's execution
                    System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                    // Optional: e.printStackTrace(); // Uncomment for debugging detailed stack trace
                }
                System.out.println(); // Add a newline for better readability between command prompts
            }
        } catch (Exception e) {
            // This outer catch block handles any exceptions that might occur outside the inner block,
            // such as issues with the scanner itself or errors during the loop control.
            System.err.println("A critical error occurred that stopped the application: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // The finally block ensures that the scanner is closed when the try block exits,
            // whether normally or due to an exception.
            if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Displays the menu options to the user using System.out.
     */
    private static void displayMenu() {
        System.out.println("--- Call Center Menu ---");
        System.out.println("A: Add Call");
        System.out.println("S: Assign Call");
        System.out.println("L: List Waiting Calls");
        System.out.println("C: List Completed Calls");
        System.out.println("Q: Quit");
    }
}
