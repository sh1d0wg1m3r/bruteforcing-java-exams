/*
 * Exam Question #456
 * Generated on: 2025-05-11 23:13:54
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Assembly Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a manufacturing assembly line. Jobs (tasks) arrive and are placed into a waiting queue. A single worker processes jobs one by one from the front of the queue. Processed jobs are then moved to either a list of completed jobs or a list of rejected jobs based on the outcome of the processing step. The user interacts with the system via a console menu.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this assembly line. The program should allow the user to:
 * 
 * 1.  **Add a new job:** Prompt for job details (ID, description, priority) and add it to the waiting queue.
 * 2.  **Process the next job:** Take the job at the front of the waiting queue. Simulate a processing outcome (e.g., 50% chance of success, 50% chance of failure). Move the job to the appropriate list (completed or rejected).
 * 3.  **View waiting jobs:** Display all jobs currently in the waiting queue.
 * 4.  **View completed jobs:** Display all jobs that have been successfully processed.
 * 5.  **View rejected jobs:** Display all jobs that failed processing.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must strictly adhere to the following:
 * 
 * *   Use `java.util.Queue` for the waiting line of jobs. You can use `java.util.LinkedList` as the concrete implementation.
 * *   Use `java.util.ArrayList` for storing completed and rejected jobs.
 * *   Declare the completed and rejected job collections using the `java.util.List` interface (`List<Job> completedJobs = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to get user input from the console.
 * *   Use a `switch` statement to handle the main menu options selected by the user.
 * *   Use `System.err.println()` to display error messages (e.g., invalid menu choice, trying to process from an empty queue).
 * *   Use `System.out.println()` for all normal output (menu, job details, status).
 * *   Implement class-wide exception handling using `try-catch` blocks to manage potential issues during user input or processing.
 * *   Create a separate `Job` class to represent a single job with appropriate fields (ID, description, priority) and methods (getters, `toString()`).
 * *   Implement a main class (e.g., `AssemblyLineSimulation`) that contains the main logic and the `main` method.
 * *   Follow best practices:
 *     *   Use private fields and public methods for encapsulation.
 *     *   Choose meaningful variable and method names.
 *     *   Include comments and Javadoc where appropriate.
 *     *   Perform basic input validation (e.g., for menu choices).
 *     *   Handle cases like processing from an empty queue gracefully.
 * 
 * **Job Details:**
 * 
 * *   Each job should have a unique integer ID.
 * *   A string description.
 * *   An integer priority (higher number indicates higher priority, though this simulation won't use priority for processing order, only for storage/display).
 * 
 * **Processing Logic:**
 * 
 * When "Process Next Job" is selected:
 * 1.  Check if the waiting queue is empty. If so, print an error message to `System.err`.
 * 2.  If not empty, remove the job from the *front* of the queue.
 * 3.  Simulate processing outcome: Generate a random number (e.g., 0 or 1). If 0, the job fails; if 1, it succeeds.
 * 4.  Print the outcome for the specific job (ID and description).
 * 5.  Add the job to the `completedJobs` list if successful, or the `rejectedJobs` list if failed.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * Assembly Line Simulation Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Waiting Jobs
 * 4. View Completed Jobs
 * 5. View Rejected Jobs
 * 6. Exit
 * Enter your choice: 
 * ```
 * 
 * Based on the user's choice, the program should perform the action and print relevant information to `System.out` (or `System.err` for errors). Job details should be displayed clearly when viewing lists/queue.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 1
 * Enter Job ID: 101
 * Enter Job Description: Assemble Widget A
 * Enter Job Priority: 5
 * Job added to waiting queue.
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 1
 * Enter Job ID: 102
 * Enter Job Description: Inspect Part B
 * Enter Job Priority: 8
 * Job added to waiting queue.
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting Queue ---
 * Job [ID=101, Desc=Assemble Widget A, Priority=5]
 * Job [ID=102, Desc=Inspect Part B, Priority=8]
 * ---------------------
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 2
 * Processing Job [ID=101, Desc=Assemble Widget A, Priority=5]...
 * Processing successful! Job moved to completed list.
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting Queue ---
 * Job [ID=102, Desc=Inspect Part B, Priority=8]
 * ---------------------
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job [ID=101, Desc=Assemble Widget A, Priority=5]
 * ----------------------
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 2
 * Processing Job [ID=102, Desc=Inspect Part B, Priority=8]...
 * Processing failed! Job moved to rejected list.
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 5
 * --- Rejected Jobs ---
 * Job [ID=102, Desc=Inspect Part B, Priority=8]
 * ---------------------
 * 
 * Assembly Line Simulation Menu:
 * ...
 * Enter your choice: 6
 * Exiting simulation.
 * ```
 * 
 * Your solution should be a single Java file containing the `Job` class and the main simulation class.
 *
 * EXPLANATION:
 * This solution implements a simple assembly line simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Job` Class:** This class serves as a simple Plain Old Java Object (POJO) to represent the data structure for a job. It has `private` fields (`id`, `description`, `priority`) adhering to encapsulation principles. `public` getter methods provide controlled access to these fields. The `toString()` method is overridden to provide a convenient, formatted string representation of a `Job` object, which is useful for printing the contents of the collections.
 * 
 * 2.  **`AssemblyLineSimulation` Class:** This is the main class that orchestrates the simulation.
 *     *   **Data Structures:** It declares three essential data structures as `private` fields:
 *         *   `waitingQueue`: Declared as `Queue<Job>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and a concrete implementation, representing the waiting line where jobs are processed in FIFO (First-In, First-Out) order.
 *         *   `completedJobs`: Declared as `List<Job>` and initialized with `new ArrayList<>()`. This correctly uses the `List` interface and the `ArrayList` implementation to store jobs that successfully completed processing.
 *         *   `rejectedJobs`: Declared as `List<Job>` and initialized with `new ArrayList<>()`. Similar to `completedJobs`, this stores jobs that failed processing.
 *     *   **`Scanner`:** A `Scanner` object is initialized to read user input from `System.in`. It's a class-level field so it can be used across different methods and managed (closed) properly.
 *     *   **`Random`:** A `Random` object is used to simulate the non-deterministic outcome (success/failure) of job processing.
 *     *   **`displayMenu()`:** A simple `private` helper method to print the user menu options to `System.out`.
 *     *   **`addNewJob()`:** This method handles adding a job. It prompts the user for job details using the `Scanner`. It includes a `try-catch` block specifically for handling `InputMismatchException` if the user enters non-numeric input for ID or Priority, printing an error to `System.err` and clearing the invalid input from the scanner buffer. It uses `waitingQueue.offer()` to add the new `Job` object to the queue.
 *     *   **`processNextJob()`:** This is a core method. It first checks if the `waitingQueue` is empty using `isEmpty()`. If empty, it prints an error to `System.err` and returns. If not empty, it uses `waitingQueue.poll()` to retrieve and remove the job at the head of the queue. `poll()` is used because it returns `null` if the queue is empty (though we've already checked), which is safer than `remove()` which would throw an exception. It then simulates success/failure using `random.nextBoolean()` and adds the job to the appropriate `List` (`completedJobs` or `rejectedJobs`), printing the outcome to `System.out`.
 *     *   **`viewWaitingJobs()`, `viewCompletedJobs()`, `viewRejectedJobs()`:** These methods iterate through the respective collections (queue or lists) and print the details of each `Job` using its `toString()` method. They check if the collections are empty and print a message if so. Iterating over the `Queue` directly (as done in `viewWaitingJobs`) is safe; it doesn't remove elements.
 *     *   **`runSimulation()`:** This method contains the main program loop (`while(running)`). It repeatedly displays the menu and reads the user's choice.
 *         *   **`switch` statement:** A `switch` statement is used to direct execution flow based on the user's integer choice, calling the appropriate method for each option. The `default` case handles invalid numeric input.
 *         *   **Class-wide Exception Handling:** The `runSimulation` method is wrapped in a `try-catch-finally` block. The inner `try-catch` specifically handles `InputMismatchException` when reading the menu choice and other potential exceptions within the loop body, printing errors to `System.err`. The outer `try-catch` (around the `while` loop) acts as a broader safety net for any exceptions that might somehow escape the inner handling, printing a critical error message to `System.err` and its stack trace. The `finally` block ensures that the `Scanner` is closed when the simulation loop exits, regardless of whether it finished normally or due to an exception, preventing resource leaks.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `AssemblyLineSimulation` and calls its `runSimulation()` method to start the interactive process.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical simulation scenario, demonstrating good object-oriented design, encapsulation, input validation, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;
import java.util.InputMismatchException;

/**
 * Represents a single job in the assembly line simulation.
 */
class Job {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Job object.
     * @param id The unique identifier for the job.
     * @param description A brief description of the job.
     * @param priority The priority level of the job.
     */
    public Job(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Job.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job [ID=" + id + ", Desc=" + description + ", Priority=" + priority + "]";
    }
}

/**
 * Simulates an assembly line with a waiting queue and lists for completed/rejected jobs.
 */
public class AssemblyLineSimulation {

    private Queue<Job> waitingQueue;
    private List<Job> completedJobs;
    private List<Job> rejectedJobs;
    private Scanner scanner;
    private Random random; // For simulating processing outcome

    /**
     * Constructs a new AssemblyLineSimulation.
     * Initializes the waiting queue and job lists.
     */
    public AssemblyLineSimulation() {
        this.waitingQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        this.completedJobs = new ArrayList<>(); // Use ArrayList for completed jobs
        this.rejectedJobs = new ArrayList<>(); // Use ArrayList for rejected jobs
        this.scanner = new Scanner(System.in);
        this.random = new Random();
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nAssembly Line Simulation Menu:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Waiting Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. View Rejected Jobs");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new job based on user input to the waiting queue.
     */
    private void addNewJob() {
        try {
            System.out.print("Enter Job ID: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over

            System.out.print("Enter Job Description: ");
            String description = scanner.nextLine();

            System.out.print("Enter Job Priority: ");
            int priority = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            Job newJob = new Job(id, description, priority);
            waitingQueue.offer(newJob); // offer() is preferred over add() in queues as it doesn't throw exception if capacity restricted
            System.out.println("Job added to waiting queue.");

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter numeric values for ID and Priority.");
            scanner.nextLine(); // Clear the invalid input from the scanner buffer
        } catch (Exception e) {
            // Catch any other unexpected exceptions during input
            System.err.println("An error occurred while adding the job: " + e.getMessage());
        }
    }

    /**
     * Processes the job at the front of the waiting queue.
     * Simulates success or failure and moves the job to the appropriate list.
     */
    private void processNextJob() {
        // Check if the queue is empty before attempting to poll
        if (waitingQueue.isEmpty()) {
            System.err.println("The waiting queue is empty. No jobs to process.");
            return; // Exit the method if queue is empty
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        // We already checked for empty, but poll() is safer than remove()
        Job currentJob = waitingQueue.poll();

        if (currentJob != null) {
            System.out.println("Processing " + currentJob + "...");

            // Simulate processing outcome (50% success chance)
            boolean success = random.nextBoolean(); // true or false

            if (success) {
                completedJobs.add(currentJob); // Add to the completed list
                System.out.println("Processing successful! Job moved to completed list.");
            } else {
                rejectedJobs.add(currentJob); // Add to the rejected list
                System.out.println("Processing failed! Job moved to rejected list.");
            }
        } else {
             // This case should ideally not be reached due to the isEmpty() check,
             // but included for robustness if poll() somehow returned null unexpectedly.
            System.err.println("Error: Could not retrieve job from queue.");
        }
    }

    /**
     * Displays all jobs currently in the waiting queue.
     */
    private void viewWaitingJobs() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Job job : waitingQueue) {
                System.out.println(job);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all jobs that have been successfully completed.
     */
    private void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            for (Job job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all jobs that were rejected during processing.
     */
    private void viewRejectedJobs() {
        System.out.println("--- Rejected Jobs ---");
        if (rejectedJobs.isEmpty()) {
            System.out.println("No jobs have been rejected yet.");
        } else {
            for (Job job : rejectedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Runs the main simulation loop, displaying the menu and handling user input.
     * Includes class-wide exception handling for the main loop.
     */
    public void runSimulation() {
        int choice = 0;
        boolean running = true;

        // Main simulation loop with class-wide exception handling
        try {
            while (running) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    // Consume the rest of the line after reading the integer choice
                    scanner.nextLine();

                    // Use a switch statement to handle menu options
                    switch (choice) {
                        case 1:
                            addNewJob();
                            break;
                        case 2:
                            processNextJob();
                            break;
                        case 3:
                            viewWaitingJobs();
                            break;
                        case 4:
                            viewCompletedJobs();
                            break;
                        case 5:
                            viewRejectedJobs();
                            break;
                        case 6:
                            System.out.println("Exiting simulation.");
                            running = false;
                            break;
                        default:
                            // Handle invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Clear the invalid input from the scanner buffer
                } catch (Exception e) {
                    // Catch any other unexpected exceptions within the loop body
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally, print stack trace for debugging: e.printStackTrace();
                }
            }
        } catch (Exception mainException) {
            // This outer catch block handles exceptions that might escape the inner try-catch,
            // though the inner one should catch most expected issues within the loop.
            System.err.println("A critical error occurred during simulation runtime: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner is closed when the simulation ends or an exception occurs
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Simulation ended.");
        }
    }

    /**
     * The main method to start the assembly line simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulation simulation = new AssemblyLineSimulation();
        simulation.runSimulation();
    }
}
