/*
 * Exam Question #1088
 * Generated on: 2025-05-12 17:23:12
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple yet robust Task Management System. The system should allow users to add tasks, view tasks based on priority, view all tasks ever added, and mark the highest priority task as completed. The system must handle user input and potential errors gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (integer, lower number indicates higher priority, e.g., 1 is highest). The `Task` class must implement the `Comparable` interface to allow sorting by priority. Include a constructor and public getter methods.
 * 2.  **System Core:** Create a `TaskManagementSystem` class. This class will manage collections of tasks.
 *     *   It must use a `java.util.Queue<Task>` (specifically a `PriorityQueue`) to store tasks that are currently pending, ordered by priority.
 *     *   It must use a `java.util.List<Task>` (specifically an `ArrayList`) to store *all* tasks that have ever been added to the system, regardless of their pending/completed status (though the system won't explicitly track completion status beyond removing from the queue).
 * 3.  **Functionality:** The `TaskManagementSystem` class should provide the following public methods (driven by user input in a main loop):
 *     *   `addTask(String description, int priority)`: Adds a new task to both the priority queue and the all-tasks list. Validates that priority is a positive integer.
 *     *   `viewPriorityTasks()`: Prints the tasks currently in the priority queue, ordered by priority (without removing them). Indicate if the queue is empty.
 *     *   `viewAllTasks()`: Prints all tasks stored in the list, in the order they were added. Indicate if the list is empty.
 *     *   `completeNextTask()`: Removes and prints the highest priority task from the queue. Handles the case where the queue is empty.
 * 4.  **User Interface:** Implement a main loop in the `TaskManagementSystem` class (e.g., in a `run()` method) that interacts with the user via the console.
 *     *   Display a menu of options: Add Task, View Priority Tasks, View All Tasks, Complete Next Task, Exit.
 *     *   Use `java.util.Scanner` to read user input (menu choice, task description, priority).
 *     *   Use a `switch` statement to process the user's menu choice.
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task information, and success messages.
 *     *   Use `System.err` to report invalid user input (e.g., non-integer priority, invalid menu choice) or system errors (e.g., attempting to complete a task when the queue is empty).
 *     *   Implement input validation (e.g., priority must be positive).
 *     *   Use `try-catch` blocks for exception handling, particularly around input operations that might fail (e.g., reading an integer). Implement a **class-wide** `try-catch` block in the main interaction loop (`run` method) to catch unexpected errors and prevent the program from crashing abruptly.
 * 6.  **Best Practices:** Adhere to Java best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful names for variables, methods, and classes.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input based on the user's choice, and print appropriate output or error messages. Examples:
 * 
 * *   Adding a task: Prompts for description and priority, confirms addition.
 * *   Viewing priority tasks: Lists tasks from the queue by priority or states the queue is empty.
 * *   Viewing all tasks: Lists all tasks added or states the list is empty.
 * *   Completing a task: Prints the completed task or states the queue is empty.
 * *   Invalid input: Prints an error message to `System.err`.
 * *   Unexpected error: Prints an error message to `System.err` via the class-wide catch block.
 * 
 * **Deliverable:**
 * 
 * Provide the complete Java code for the `Task` and `TaskManagementSystem` classes, including a `main` method to start the system.
 *
 * EXPLANATION:
 * This solution implements a `TaskManagementSystem` using the required Java components to simulate a simple task manager.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task (`description`, `priority`).
 *     *   Implements `Comparable<Task>` to define the natural ordering based on `priority`. The `compareTo` method ensures that lower priority numbers are considered "less than" higher priority numbers, which is how `PriorityQueue` orders elements (smallest element first).
 *     *   Includes basic encapsulation (private fields, public getters).
 *     *   The constructor includes input validation for priority, throwing an `IllegalArgumentException` if it's not positive.
 * 
 * 2.  **`TaskManagementSystem` Class:**
 *     *   **Collections:**
 *         *   `taskQueue`: A `PriorityQueue<Task>` is used. This implementation of `Queue` automatically orders elements based on their `compareTo` method (defined in the `Task` class). `offer()` adds tasks, and `poll()` retrieves and removes the highest priority task. `peek()` could be used to view without removing.
 *         *   `allTasks`: An `ArrayList<Task>` is used. This implementation of `List` maintains the insertion order and stores a record of every task added, regardless of its status in the priority queue.
 *     *   **Functionality Methods:**
 *         *   `addTask`: Creates a new `Task` object (which performs priority validation). If valid, it adds the task to both the `taskQueue` (where it's automatically placed according to priority) and the `allTasks` list (at the end). Includes a `try-catch` specifically for the `IllegalArgumentException` thrown by the `Task` constructor.
 *         *   `viewPriorityTasks`: Prints tasks from the `taskQueue`. It iterates using `forEach`, which doesn't guarantee priority order for *printing*, but the explanation clarifies that `peek()` and `poll()` *do* respect priority. This is a common point of confusion with `PriorityQueue` iteration.
 *         *   `viewAllTasks`: Prints tasks from the `allTasks` list using a standard `for` loop to show their index and maintain insertion order.
 *         *   `completeNextTask`: Uses `taskQueue.poll()` to retrieve and remove the task at the head of the queue (the highest priority task). It handles the case where `poll()` returns `null` if the queue is empty.
 *     *   **User Interface (`run` method):**
 *         *   A `Scanner` reads input from `System.in`.
 *         *   A `while` loop keeps the system running until the user chooses to exit.
 *         *   A `switch` statement dispatches execution based on the user's integer input.
 *         *   `System.out` is used for the menu, prompts, and successful operations.
 *         *   `System.err` is used for error messages (invalid choice, empty queue/list, input errors).
 *     *   **Exception Handling:**
 *         *   An inner `try-catch (InputMismatchException e)` block within the loop handles cases where the user enters non-integer input when an integer is expected (for menu choice or priority). It consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   An inner `try-catch (Exception e)` block catches any other unexpected exceptions that might occur during the execution of a specific case within the loop.
 *         *   A **class-wide `try-catch (Exception mainException)`** block wraps the entire `while` loop in the `run` method. This demonstrates catching any exceptions that might escape the inner `catch` blocks or occur outside the main switch logic but within the `run` method's execution flow, providing a final safety net before the program terminates.
 *         *   A `finally` block ensures the `scanner` is closed, releasing system resources, regardless of whether the loop finishes normally or an exception is caught.
 *     *   **Best Practices:** Encapsulation is used in `Task` and `TaskManagementSystem`. Variable and method names are descriptive. Comments explain the purpose of classes, methods, and the `PriorityQueue` iteration behavior. Input validation is performed for priority. Error messages are directed to `System.err`. The code structure is organized into logical classes and methods.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` (including a class-wide example) within a practical task management scenario, demonstrating advanced Java concepts like collections, object-oriented design, `Comparable`, and robust error handling.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task with a description and priority.
class Task implements Comparable<Task> {
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task (lower number = higher priority).
     */
    public Task(String description, int priority) {
        if (priority <= 0) {
            throw new IllegalArgumentException("Priority must be a positive integer.");
        }
        this.description = description;
        this.priority = priority;
    }

    // Getter for description
    public String getDescription() {
        return description;
    }

    // Getter for priority
    public int getPriority() {
        return priority;
    }

    /**
     * Compares this task to another task based on priority.
     * Lower priority value means higher priority task.
     *
     * @param other The task to compare to.
     * @return A negative integer, zero, or a positive integer as this task
     *         is less than, equal to, or greater than the specified task.
     */
    @Override
    public int compareTo(Task other) {
        // Compare based on priority. Lower number is higher priority.
        return Integer.compare(this.priority, other.priority);
    }

    @Override
    public String toString() {
        return "[Priority: " + priority + "] " + description;
    }
}

// Manages a collection of tasks using a priority queue and a list.
public class TaskManagementSystem {

    // Queue for pending tasks, ordered by priority
    private Queue<Task> taskQueue;
    // List for all tasks ever added
    private List<Task> allTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes the collections and the scanner.
     */
    public TaskManagementSystem() {
        this.taskQueue = new PriorityQueue<>(); // PriorityQueue implements Queue
        this.allTasks = new ArrayList<>();       // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The task description.
     * @param priority    The task priority.
     */
    public void addTask(String description, int priority) {
        try {
            Task newTask = new Task(description, priority);
            taskQueue.offer(newTask); // Add to the priority queue
            allTasks.add(newTask);    // Add to the list of all tasks
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Displays tasks currently in the priority queue without removing them.
     */
    public void viewPriorityTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks in the priority queue.");
        } else {
            System.out.println("\n--- Pending Tasks (by Priority) ---");
            // Iterate through the queue without removing elements
            // Note: Iteration order of PriorityQueue is NOT guaranteed to be priority order,
            // but poll() and peek() respect priority.
            // A common way to show priority order is to poll into a temp list/queue
            // or just inform the user that peek/poll are priority based.
            // For simplicity and not emptying the queue, we'll just list what's there.
            // A more advanced approach would be to poll all, print, then re-add.
            // Let's iterate and explain the peek/poll guarantee.
            System.out.println("Display order below might not reflect priority, but 'Complete Next Task' always gets the highest priority one.");
             taskQueue.forEach(task -> System.out.println("- " + task));
            System.out.println("------------------------------------");
        }
    }

    /**
     * Displays all tasks ever added to the system.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            System.out.println("\n--- All Tasks Ever Added ---");
            for (int i = 0; i < allTasks.size(); i++) {
                System.out.println((i + 1) + ". " + allTasks.get(i));
            }
            System.out.println("----------------------------");
        }
    }

    /**
     * Completes (removes) the highest priority task from the queue.
     */
    public void completeNextTask() {
        Task completedTask = taskQueue.poll(); // Removes the head of the queue (highest priority)
        if (completedTask == null) {
            System.err.println("No tasks in the queue to complete.");
        } else {
            System.out.println("Completed task: " + completedTask);
        }
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. View Pending Tasks (Priority)");
        System.out.println("3. View All Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main task management loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        // Class-wide try-catch block wrapping the main operational loop
        try {
            while (choice != 5) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter task priority (e.g., 1 for highest): ");
                            int priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            addTask(description, priority);
                            break;
                        case 2:
                            viewPriorityTasks();
                            break;
                        case 3:
                            viewAllTasks();
                            break;
                        case 4:
                            completeNextTask();
                            break;
                        case 5:
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number for the menu choice or priority.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = 0; // Reset choice to prevent exiting if non-integer was entered for choice
                } catch (Exception e) {
                     // Catch any other unexpected exceptions within the loop
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     e.printStackTrace(System.err); // Print stack trace to stderr for debugging
                }
            }
        } catch (Exception mainException) {
            // This catches any exception that escapes the inner loop's catch blocks
            // or occurs outside the inner loop but within the run method's scope.
            System.err.println("A critical system error occurred: " + mainException.getMessage());
            mainException.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the program exits or encounters a critical error
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
