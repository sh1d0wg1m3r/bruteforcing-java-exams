/*
 * Exam Question #836
 * Generated on: 2025-05-12 16:48:37
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Internal Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line based system for an internal team to manage their tasks. The system should allow team members to add new tasks, process the next pending task, view completed tasks, and exit the system.
 * 
 * New tasks are always added to a queue, representing tasks waiting to be picked up. When a team member is ready to work, they take the *next* task from the front of this queue. Once a task is completed, it is moved to an archive list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple `Task` class with fields for a unique task ID (an integer), a description (String), and a status (e.g., "PENDING", "COMPLETED").
 * 2.  **System Core:** Create a class (e.g., `TaskManagementSystem`) that manages the tasks. This class must maintain:
 *     *   A collection of tasks waiting to be processed. This collection *must* be a `java.util.Queue`.
 *     *   A collection of tasks that have been completed. This collection *must* be a `java.util.ArrayList`, and should be referenced using the `java.util.List` interface type.
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` that presents a menu of options to the user:
 *     *   `1. Add New Task`
 *     *   `2. Process Next Task`
 *     *   `3. View Completed Tasks`
 *     *   `4. Exit`
 * 4.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description. Generate a unique ID for the task (e.g., using a simple counter). Add the new task with "PENDING" status to the pending task queue.
 *     *   **Process Next Task:** Take the task from the front of the pending task queue. If the queue is empty, inform the user. If a task is retrieved, change its status to "COMPLETED" and move it to the completed tasks list. Inform the user which task was processed.
 *     *   **View Completed Tasks:** Display all tasks currently in the completed tasks list, showing their ID, description, and status. If the list is empty, inform the user.
 *     *   **Exit:** Terminate the program.
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 6.  **Error Handling & Validation:**
 *     *   Use `System.err` to print error messages (e.g., for invalid menu choices, empty task descriptions, issues with input).
 *     *   Use `System.out` for all normal output (prompts, success messages, task listings).
 *     *   Implement input validation for the menu choice and task description.
 *     *   Use `try-catch` blocks to handle potential exceptions, such as `java.util.InputMismatchException` when reading numeric input or potential issues when interacting with collections (though `Queue.poll()` and `List.add()` are generally safe, consider how to handle unexpected scenarios gracefully). Implement class-wide or method-specific exception handling as appropriate.
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should loop, displaying the menu and processing user input until the user chooses to exit. Output should be clear and informative, using `System.out` for success/status and `System.err` for errors.
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Write report draft
 * Task 1 added: Write report draft
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Processed task 1: Write report draft
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Completed Tasks:
 * ID: 1, Description: Write report draft, Status: COMPLETED
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * No tasks in the pending queue to process.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Exiting Task Management System.
 * ```
 * 
 * **Constraints:**
 * 
 * *   You *must* use `java.util.Queue`.
 * *   You *must* use `java.util.ArrayList`.
 * *   You *must* use `java.util.List` interface type.
 * *   You *must* use `java.util.Scanner`.
 * *   You *must* use a `switch` statement.
 * *   You *must* use `System.err`.
 * *   You *must* use `System.out`.
 * *   You *must* use `try-catch` for exception handling.
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System using the specified Java components and best practices.
 * 
 * 1.  **Task Class:**
 *     *   A basic `Task` class is defined with `private` fields (`id`, `description`, `status`) to ensure encapsulation.
 *     *   It includes a constructor, public getter methods (`getId`, `getDescription`, `getStatus`), and a setter method for status (`setStatus`).
 *     *   An overridden `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskManagementSystem Class:**
 *     *   This class is the core of the system, managing the task collections.
 *     *   `private Queue<Task> pendingTasks;`: Declared as a `Queue`, which guarantees FIFO (First-In, First-Out) behavior for task processing. It's initialized with a `LinkedList`, a common `Queue` implementation.
 *     *   `private List<Task> completedTasks;`: Declared as a `List` interface type, but initialized with an `ArrayList`. This demonstrates coding to the interface, which is a good practice, while using the concrete `ArrayList` implementation for dynamic resizing and ordered storage of completed tasks.
 *     *   `private int nextTaskId;`: A simple counter to generate unique IDs for new tasks.
 *     *   `addTask(String description)`: Creates a new `Task`, increments the ID counter, and adds the task to the `pendingTasks` queue using `offer()`. It includes basic validation for the description.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the task at the front of the queue. `poll()` is used because it safely returns `null` if the queue is empty, avoiding an exception. If a task is retrieved, its status is updated, and it's added to the `completedTasks` list.
 *     *   `getCompletedTasks()`: Returns the list of completed tasks.
 *     *   `hasCompletedTasks()` and `hasPendingTasks()`: Helper methods to check if the lists are empty for better readability in the main application logic.
 * 
 * 3.  **TaskSystemApp Class (Main Application):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   `Scanner scanner = new Scanner(System.in);`: Initializes a `Scanner` to read user input from the console.
 *     *   `TaskManagementSystem system = new TaskManagementSystem();`: Creates an instance of the management system.
 *     *   **Main Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   **Menu and Input:** Inside the loop, `printMenu()` displays options using `System.out`. `scanner.nextInt()` attempts to read the user's choice.
 *     *   **Input Validation & Exception Handling (try-catch):**
 *         *   A `try-catch (InputMismatchException e)` block is wrapped around `scanner.nextInt()` to specifically handle cases where the user enters non-integer input. An error message is printed to `System.err`, and `scanner.next()` is called to consume the invalid input token, preventing an infinite loop.
 *         *   A `finally` block is used to ensure `scanner.nextLine()` is called after reading the integer, consuming the newline character left in the buffer, which is crucial before subsequent `scanner.nextLine()` calls for task descriptions.
 *         *   A broader `try-catch (Exception e)` block is wrapped around the *entire* `while` loop. This serves as a class-wide exception handler, catching any unexpected runtime errors that might occur during the system's operation and printing an error message and stack trace to `System.err` before the program potentially terminates (or exits the loop if `running` is set to false, which it isn't in the catch block here, so it would likely terminate).
 *     *   **Switch Statement:** The user's valid integer choice is processed using a `switch` statement, directing the flow to the appropriate action (add, process, view, exit, or invalid choice).
 *     *   **System.out and System.err:**
 *         *   `System.out.println(...)` is used for displaying the menu, prompts, success messages (task added/processed), and listing completed tasks.
 *         *   `System.err.println(...)` is used exclusively for error messages (invalid input, empty description, invalid menu choice, unexpected exceptions).
 *     *   **Closing Scanner:** The `finally` block after the main loop ensures `scanner.close()` is called, releasing the system resources used by the scanner when the application finishes.
 * 
 * This solution effectively demonstrates the required Java components within a practical, although simplified, application context, incorporating essential best practices like encapsulation, input validation, and exception handling.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskManagementSystem {
    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a TaskManagementSystem.
     * Initializes the collections and the task ID counter.
     */
    public TaskManagementSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the new task.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Input validation handled by caller, but defensive check here
            return null;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        return newTask;
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list after updating its status.
     * @return The processed Task object, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll returns null if queue is empty
        if (taskToProcess != null) {
            taskToProcess.setStatus("COMPLETED");
            completedTasks.add(taskToProcess);
        }
        return taskToProcess;
    }

    /**
     * Retrieves the list of completed tasks.
     * @return A List of completed Task objects.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy or unmodifiable list if external modification is not desired
        // For this problem, returning the direct list is acceptable based on scope.
        return completedTasks;
    }

    /**
     * Checks if the completed tasks list is empty.
     * @return true if the completed tasks list is empty, false otherwise.
     */
    public boolean hasCompletedTasks() {
        return !completedTasks.isEmpty();
    }

    /**
     * Checks if the pending tasks queue is empty.
     * @return true if the pending tasks queue is empty, false otherwise.
     */
    public boolean hasPendingTasks() {
        return !pendingTasks.isEmpty();
    }
}

/**
 * Main class to run the Task Management System application.
 * Handles user interaction and menu driven flow.
 */
public class TaskSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManagementSystem system = new TaskManagementSystem();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                } finally {
                     // Consume the rest of the line after reading the integer
                     // This is important to prevent issues with nextLine() calls later
                     scanner.nextLine();
                }


                // Use switch for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            Task newTask = system.addTask(description);
                            System.out.println("Task " + newTask.getId() + " added: " + newTask.getDescription());
                        }
                        break;

                    case 2: // Process Next Task
                        Task processedTask = system.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processed task " + processedTask.getId() + ": " + processedTask.getDescription());
                        } else {
                            System.out.println("No tasks in the pending queue to process.");
                        }
                        break;

                    case 3: // View Completed Tasks
                        List<Task> completed = system.getCompletedTasks();
                        if (system.hasCompletedTasks()) {
                            System.out.println("Completed Tasks:");
                            for (Task task : completed) {
                                System.out.println(task); // Task's toString() is used here
                            }
                        } else {
                            System.out.println("No tasks have been completed yet.");
                        }
                        break;

                    case 4: // Exit
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            scanner.close(); // Close the scanner when the application exits
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Exit");
    }
}
