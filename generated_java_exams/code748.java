/*
 * Exam Question #748
 * Generated on: 2025-05-12 16:35:00
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified task management system for a simulated production line. Tasks arrive, are placed in a waiting queue, processed one by one, and then moved to a list of completed tasks. Your system needs to handle user interactions to manage this process.
 * 
 * **Task Description:**
 * 
 * Implement a Java program that simulates this system. Your program should allow users to perform the following actions via a command-line interface:
 * 
 * 1.  **Add a New Task:** Create a new task with a description provided by the user and add it to the queue of pending tasks.
 * 2.  **Process Next Task:** Take the oldest task from the pending queue, mark it as completed, and move it to the list of completed tasks.
 * 3.  **View Pending Tasks:** Display all tasks currently waiting in the pending queue.
 * 4.  **View Completed Tasks:** Display all tasks that have been processed and completed.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution MUST adhere to the following technical constraints and best practices:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the tasks waiting to be processed (`pendingTasks`). Choose an appropriate implementation (e.g., `java.util.ArrayDeque`).
 *     *   Use `java.util.List` (implemented by `java.util.ArrayList`) to store tasks that have been completed (`completedTasks`).
 * 2.  **User Input:** Use `java.util.Scanner` to read user input for menu choices and task details.
 * 3.  **Flow Control:** Use a `switch` statement to handle the different menu options selected by the user.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task details, and confirmation messages.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, attempting to process when the queue is empty).
 * 5.  **Error Handling:**
 *     *   Implement robust input validation for user choices and task details.
 *     *   Use `try-catch` blocks to handle potential runtime exceptions during the program's execution (e.g., `InputMismatchException`, attempting operations on empty collections where applicable). Exception handling should cover potential issues arising from user input or system operations.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Task` class to represent individual tasks. This class should have private fields for task details (e.g., `taskId`, `description`, `status`) and public getter methods.
 *     *   Create a main class (e.g., `TaskProcessingSystem`) that manages the `pendingTasks` queue and `completedTasks` list, and contains the main application logic (menu loop, methods for each action).
 *     *   Ensure proper encapsulation (private fields, public methods) throughout your classes.
 * 7.  **Code Quality:**
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments to explain complex logic or important sections.
 *     *   Structure your code cleanly.
 * 
 * **Task Details:**
 * 
 * *   Each `Task` should have:
 *     *   A unique ID (you can generate a simple sequential ID or prefix like "TASK-").
 *     *   A description (String).
 *     *   A status (String or enum, e.g., "PENDING", "COMPLETED").
 * *   When viewing tasks, display their ID, description, and status.
 * *   When processing a task, only the next task in the queue should be processed.
 * 
 * **Expected Output:**
 * 
 * Your program should present a menu, accept user input, and display results or errors accordingly.
 * 
 * ```
 * --- Production Line Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Example Interaction (User input shown in italics):
 * 
 * ```
 * --- Production Line Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: *1*
 * Enter task description: *Assemble Unit A*
 * Task TASK-1 added to pending queue.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *1*
 * Enter task description: *Test Component B*
 * Task TASK-2 added to pending queue.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *3*
 * Pending Tasks:
 * ID: TASK-1, Description: Assemble Unit A, Status: PENDING
 * ID: TASK-2, Description: Test Component B, Status: PENDING
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *2*
 * Processing task: TASK-1
 * Task TASK-1 completed and moved to completed list.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *4*
 * Completed Tasks:
 * ID: TASK-1, Description: Assemble Unit A, Status: COMPLETED
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *2*
 * Processing task: TASK-2
 * Task TASK-2 completed and moved to completed list.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *2*
 * Error: No pending tasks to process.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *6*
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *abc*
 * Error: Invalid input. Please enter a number.
 * --- Production Line Task Management ---
 * ...
 * Enter your choice: *5*
 * Exiting system.
 * ```
 * 
 * Your solution should be provided as a single `.java` file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all menu options.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust exception handling using `try-catch`.
 * *   Correct input validation.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability, naming conventions, and comments.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * The provided solution implements a `TaskProcessingSystem` that manages a queue of pending tasks and a list of completed tasks, simulating a simple production line flow.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, and `status`.
 *     *   Fields are `private` to enforce encapsulation.
 *     *   `public` getter methods provide controlled access to task information.
 *     *   A `setStatus` method allows controlled modification of the status.
 *     *   The constructor includes basic validation for non-null/empty ID and description, throwing `IllegalArgumentException`.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `ArrayDeque<Task>`. `ArrayDeque` is a good choice for a queue as it's efficient for adding to the end and removing from the beginning. The `Queue` interface ensures we use standard queue operations (`offer`, `poll`, `peek`).
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `ArrayList<Task>`. `ArrayList` is suitable for storing completed tasks where random access or iteration is common, and order is maintained. The `List` interface provides standard list operations (`add`, iteration).
 *     *   **User Input:** A `Scanner` object (`scanner`) reads input from `System.in`.
 *     *   **`run()` Method:**
 *         *   This is the main application loop. It repeatedly displays the menu and processes user input until the 'Exit' option (5) is chosen.
 *         *   **`try-catch` Block:** A large `try-catch` block wraps the core of the loop (reading input and the `switch` statement).
 *             *   It specifically catches `InputMismatchException` if the user enters non-integer input for the menu choice. It prints an error using `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *             *   A general `catch (Exception e)` is included as a safety net to catch any other unexpected exceptions that might occur during an iteration, printing the error and stack trace to `System.err`. This demonstrates class-wide or method-wide exception handling.
 *         *   **`switch` Statement:** Controls the program flow based on the valid integer `choice` entered by the user, calling the appropriate private method for each action.
 *         *   The loop terminates when `choice` becomes 5.
 *         *   `scanner.close()` is called after the loop exits to release the system resource.
 *     *   **`displayMenu()`:** A simple helper method to print the menu options using `System.out`.
 *     *   **`addTask()`:**
 *         *   Prompts the user for a task description using `System.out`.
 *         *   Reads the description using `scanner.nextLine()`. Note the `scanner.nextLine()` call before reading the description to consume the newline character left by `scanner.nextInt()` from the menu choice.
 *         *   Includes input validation to ensure the description is not empty, printing an error to `System.err` if invalid.
 *         *   Generates a simple sequential task ID.
 *         *   Creates a new `Task` object.
 *         *   Adds the new task to the `pendingTasks` queue using `offer()`.
 *         *   Prints a success message to `System.out`.
 *         *   Includes a small `try-catch` around `Task` creation to handle potential `IllegalArgumentException` from the `Task` constructor, printing the error to `System.err`.
 *     *   **`processNextTask()`:**
 *         *   Checks if `pendingTasks` is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns.
 *         *   If not empty, it retrieves and removes the next task from the queue using `poll()`.
 *         *   Updates the task's status to "COMPLETED".
 *         *   Adds the task to the `completedTasks` list using `add()`.
 *         *   Prints success messages to `System.out`.
 *     *   **`viewPendingTasks()`:**
 *         *   Checks if `pendingTasks` is empty, printing a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `pendingTasks` queue using a for-each loop and prints each `Task` object (which uses the `toString()` method) to `System.out`. Iterating a `Queue` directly traverses its elements without removing them.
 *     *   **`viewCompletedTasks()`:**
 *         *   Checks if `completedTasks` is empty, printing a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `completedTasks` list using a for-each loop and prints each `Task` object to `System.out`.
 *     *   **`main()` Method:**
 *         *   The entry point of the program.
 *         *   Creates an instance of `TaskProcessingSystem` and calls its `run()` method to start the application loop.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating input validation, error handling, encapsulation, and clean code principles.
 */

import java.util.Queue;
import java.util.ArrayDeque; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private String taskId;
    private String description;
    private String status; // Using String for status as requested

    // Constructor
    public Task(String taskId, String description) {
        if (taskId == null || taskId.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // Getters (no setters to maintain immutability of ID and description after creation)
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status - controlled change
    public void setStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
             System.err.println("Warning: Attempted to set task status to null or empty.");
             return; // Or throw an exception depending on requirements
        }
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %s, Description: %s, Status: %s", taskId, description, status);
    }
}

// Manages the task processing system
public class TaskProcessingSystem {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner;
    private int nextTaskIdCounter; // To generate simple sequential IDs

    // Constructor
    public TaskProcessingSystem() {
        this.pendingTasks = new ArrayDeque<>(); // Use ArrayDeque for Queue
        this.completedTasks = new ArrayList<>(); // Use ArrayList for List
        this.scanner = new Scanner(System.in);
        this.nextTaskIdCounter = 1;
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Production Line Task Management ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Handles adding a new task
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline left by previous nextInt() or similar
        scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if description is invalid
        }

        String taskId = "TASK-" + nextTaskIdCounter++;
        try {
            Task newTask = new Task(taskId, description);
            pendingTasks.offer(newTask); // offer is preferred over add for queues (returns false if fails)
            System.out.println("Task " + taskId + " added to pending queue.");
        } catch (IllegalArgumentException e) {
            // This catches errors from Task constructor if validation fails there (though we pre-validated description)
            System.err.println("Error creating task: " + e.getMessage());
            // Decrement counter if task creation failed after ID generation
            nextTaskIdCounter--;
        }
    }

    // Handles processing the next task in the queue
    private void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return; // Nothing to process
        }

        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess.getTaskId());
            taskToProcess.setStatus("COMPLETED"); // Update status
            completedTasks.add(taskToProcess); // Add to completed list
            System.out.println("Task " + taskToProcess.getTaskId() + " completed and moved to completed list.");
        } else {
             // This case should ideally not happen if isEmpty() check passes, but good for robustness
             System.err.println("Error: Failed to retrieve task from queue.");
        }
    }

    // Displays all tasks in the pending queue
    private void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
            return;
        }
        System.out.println("Pending Tasks:");
        // Iterate through the queue without removing elements
        for (Task task : pendingTasks) {
            System.out.println(task);
        }
    }

    // Displays all tasks in the completed list
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks currently completed.");
            return;
        }
        System.out.println("Completed Tasks:");
        // Iterate through the list
        for (Task task : completedTasks) {
            System.out.println(task);
        }
    }

    // Main application loop
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Handle potential non-integer input
                choice = scanner.nextInt();

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handle choices outside the 1-5 range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream for debugging
            }
        }
        // Close the scanner resource when exiting
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
