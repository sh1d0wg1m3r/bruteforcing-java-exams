/*
 * Exam Question #367
 * Generated on: 2025-05-11 23:00:58
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified console-based system for managing customer orders at a small restaurant. The system needs to handle incoming orders, process them in the order they were received, and allow staff to view the status of orders.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Data Structures:**
 *     *   Define a class `MenuItem` to represent an item on the menu. It should have private fields for `id` (integer), `name` (String), and `price` (double). Include a constructor and public getter methods.
 *     *   Define a class `Order` to represent a customer order. It should have a private field for a unique `orderId` (integer) and a private field `items` which is a `List` of `MenuItem` objects. Include a constructor that takes an order ID and initializes the list, and a public method `addItem(MenuItem item)` to add items to the order. Also, include public getter methods for `orderId` and `items`, and a method to calculate the total price of the order.
 *     *   The main system class (e.g., `RestaurantOrderSystem`) must manage the menu, a queue of pending orders, and a list of completed orders.
 * 
 * 2.  **Functionality:**
 *     *   **Initialize System:** The system should start with a pre-defined menu (a `List` of `MenuItem` objects).
 *     *   **Display Menu:** Allow the user to view the available menu items with their IDs, names, and prices (`System.out`).
 *     *   **Place Order:**
 *         *   Prompt the user to enter the ID of menu items they wish to add to the current order.
 *         *   Allow the user to add multiple items to a single order until they indicate they are done (e.g., by entering a special value like `0`).
 *         *   Validate that the entered item ID exists on the menu. If not, display an error (`System.err`) and prompt again or skip the invalid input.
 *         *   Create an `Order` object with a unique ID.
 *         *   Add the selected `MenuItem` objects to the `Order`'s item list.
 *         *   Add the completed `Order` to a `Queue` of pending orders.
 *         *   Confirm the order placement (`System.out`).
 *         *   Handle potential non-integer input using `try-catch`.
 *     *   **Process Next Order:**
 *         *   Take the next order from the front of the pending orders `Queue`.
 *         *   If the queue is empty, display an error (`System.err`).
 *         *   If an order is processed, remove it from the queue and add it to a `List` of completed orders.
 *         *   Display confirmation of which order was processed (`System.out`).
 *     *   **View Pending Orders:** Display the details (order ID and items) of all orders currently in the pending `Queue` (`System.out`). Indicate if the queue is empty.
 *     *   **View Completed Orders:** Display the details (order ID, items, and total price) of all orders in the completed orders `List` (`System.out`). Indicate if the list is empty.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Use `Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Display Menu, Place Order, Process Next Order, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's choice.
 * 
 * 4.  **Error Handling & Best Practices:**
 *     *   Implement robust input validation for user choices and menu item IDs.
 *     *   Use `System.err` for all error messages (e.g., invalid input, queue empty).
 *     *   Use `System.out` for all normal program output (menus, prompts, confirmations, lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main interaction loop to catch unexpected errors and prevent program termination. Also use `try-catch` for specific input parsing errors where necessary.
 *     *   Follow best practices:
 *         *   Proper encapsulation (private fields, public getters/methods).
 *         *   Meaningful variable and method names.
 *         *   Appropriate comments and documentation (e.g., Javadoc).
 *         *   Clean code structure (separate classes for data, main logic).
 * 
 * **Required Java Components (MUST use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user via the console, presenting options, taking input, and displaying status or errors as described above. The output should be clear and formatted for readability.
 * 
 * **Time Allotment:** 45-60 minutes
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a console-based Restaurant Order Management System, demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `pendingOrders` is declared as a `Queue<Order>` and instantiated using `java.util.LinkedList`. A `Queue` is used because orders are processed in the order they are received (First-In, First-Out). `offer()` is used to add orders to the end of the queue, and `poll()` is used to retrieve and remove the order from the front.
 * 2.  **`java.util.ArrayList`**: `ArrayList` is used in two places:
 *     *   `menu`: An `ArrayList<MenuItem>` stores the restaurant's menu. `ArrayList` is suitable here because we need to store a dynamic list of items, access them by index or iterate through them, and its performance for these operations is good.
 *     *   `items` within the `Order` class: An `ArrayList<MenuItem>` is used to store the list of items belonging to a specific order. This allows an order to contain multiple items.
 * 3.  **`java.util.List`**: The `completedOrders` is declared as a `List<Order>` and instantiated using `java.util.ArrayList`. `List` is used as the interface type, adhering to the principle of programming to interfaces. `ArrayList` is a suitable implementation for storing completed orders as they are added sequentially, and we might need to iterate through them or potentially access them by index later (though not strictly required by this problem, it's a common pattern). The `items` field in the `Order` class is also declared as `List<MenuItem>`.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used in the `run()` method to read user input for the main menu choices and passed to the `placeOrder()` method to read item IDs for ordering.
 * 5.  **`switch` statement**: The `switch` statement in the `run()` method is used to control the program flow based on the user's numeric choice from the main menu, directing execution to the appropriate method (`displayMenu`, `placeOrder`, etc.).
 * 6.  **`System.err`**: `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, non-numeric input, invalid item IDs during order placement, and attempting to process an order when the pending queue is empty. This distinguishes error output from normal program information.
 * 7.  **`System.out`**: `System.out.println()` is used for all standard program output, including displaying the menu, prompts for user input, order confirmations, and listing pending and completed orders.
 * 8.  **Class-wide `try-catch` blocks**:
 *     *   The `run()` method contains a large `try-catch(Exception e)` block wrapping the main `while` loop. This serves as the class-wide handler, catching any unexpected `Exception` that might occur during the program's execution loop and preventing the program from crashing abruptly. It prints an error message using `System.err`.
 *     *   Specific `try-catch(InputMismatchException e)` blocks are used within the `run()` method (for main menu choice) and the `placeOrder()` method (for item ID input) to handle non-integer input gracefully, print an error to `System.err`, consume the invalid input, and allow the program to continue.
 * 
 * **Structure and Best Practices:**
 * 
 * *   **Encapsulation:** The `MenuItem` and `Order` classes have private fields and public getter methods, controlling access to their internal state.
 * *   **Meaningful Names:** Variables (`pendingOrders`, `completedOrders`, `nextOrderId`, `selectedItem`), methods (`displayMenu`, `placeOrder`, `processNextOrder`, `viewPendingOrders`), and classes (`MenuItem`, `Order`, `RestaurantOrderSystem`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are used for classes and methods explaining their function, parameters, and return values. Inline comments clarify specific logic where needed.
 * *   **Input Validation:** The code checks if entered menu item IDs exist and uses `try-catch` blocks to handle non-integer input for menu choices and item IDs.
 * *   **Error Handling:** `System.err` is used for errors, and `try-catch` blocks handle potential exceptions, making the program more robust.
 * *   **Clean Code Structure:** The code is organized into logical classes (`MenuItem`, `Order`, `RestaurantOrderSystem`) with distinct responsibilities. The `RestaurantOrderSystem` class manages the overall state and operations, while `MenuItem` and `Order` represent data entities. The `run()` method encapsulates the main application loop and user interaction.
 * 
 * This solution effectively integrates all required Java components within a practical scenario, demonstrating advanced understanding of collections, control flow, input/output, and exception handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param id The unique ID of the menu item.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("%d: %s (%.2f)", id, name, price);
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<MenuItem> items;

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for this order.
     */
    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // Use ArrayList for items in an order
    }

    /**
     * Adds a menu item to the order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        this.items.add(item);
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotalPrice() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" [");
        if (items.isEmpty()) {
            sb.append("Empty");
        } else {
            for (int i = 0; i < items.size(); i++) {
                sb.append(items.get(i).getName());
                if (i < items.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        sb.append("]");
        return sb.toString();
    }

    /**
     * Provides a detailed string representation including total price.
     */
    public String toDetailedString() {
         StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" (Total: ").append(String.format("%.2f", getTotalPrice())).append("):\n");
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append(" (").append(String.format("%.2f", item.getPrice())).append(")\n");
        }
        return sb.toString();
    }
}

// Main system class for managing restaurant orders
public class RestaurantOrderSystem {
    private List<MenuItem> menu;
    private Queue<Order> pendingOrders;
    private List<Order> completedOrders; // Using List for completed orders
    private int nextOrderId;

    /**
     * Constructs the RestaurantOrderSystem and initializes data.
     */
    public RestaurantOrderSystem() {
        initializeMenu();
        this.pendingOrders = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedOrders = new ArrayList<>(); // ArrayList for completed orders
        this.nextOrderId = 1;
    }

    /**
     * Initializes the restaurant menu with some default items.
     */
    private void initializeMenu() {
        menu = new ArrayList<>(); // Use ArrayList for the menu
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Fries", 3.49));
        menu.add(new MenuItem(3, "Soda", 1.99));
        menu.add(new MenuItem(4, "Pizza Slice", 5.50));
        menu.add(new MenuItem(5, "Salad", 7.00));
    }

    /**
     * Displays the current menu to the console.
     */
    public void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item);
            }
        }
        System.out.println("------------");
    }

    /**
     * Allows the user to place a new order.
     * @param scanner The Scanner object for reading user input.
     */
    public void placeOrder(Scanner scanner) {
        System.out.println("\n--- Place New Order ---");
        displayMenu();
        Order currentOrder = new Order(nextOrderId++);
        System.out.println("Enter item IDs to add to Order #" + currentOrder.getOrderId() + " (Enter 0 to finish):");

        while (true) {
            System.out.print("Enter item ID: ");
            try {
                int itemId = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (itemId == 0) {
                    break; // Finish order
                }

                MenuItem selectedItem = findMenuItemById(itemId);

                if (selectedItem != null) {
                    currentOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else {
                    System.err.println("Error: Invalid item ID. Please enter a valid ID from the menu.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                 System.err.println("An unexpected error occurred while placing order item: " + e.getMessage());
                 // Optionally log e.printStackTrace(); in a real application
                 scanner.nextLine(); // Attempt to clear input
            }
        }

        if (currentOrder.getItems().isEmpty()) {
            System.out.println("No items added. Order cancelled.");
             nextOrderId--; // Revert order ID if order was cancelled
        } else {
            pendingOrders.offer(currentOrder); // Add order to the queue
            System.out.println("\nOrder #" + currentOrder.getOrderId() + " placed successfully. Total items: " + currentOrder.getItems().size());
        }
        System.out.println("-----------------------");
    }

    /**
     * Finds a menu item by its ID.
     * @param id The ID to search for.
     * @return The MenuItem object if found, otherwise null.
     */
    private MenuItem findMenuItemById(int id) {
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null;
    }

    /**
     * Processes the next order in the pending queue.
     */
    public void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        if (pendingOrders.isEmpty()) {
            System.err.println("No pending orders to process.");
        } else {
            Order processedOrder = pendingOrders.poll(); // Get and remove the head of the queue
            completedOrders.add(processedOrder); // Add to completed list
            System.out.println("Order #" + processedOrder.getOrderId() + " processed successfully.");
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No orders are currently pending.");
        } else {
            // Iterating over the Queue without removing elements
            int count = 1;
            for (Order order : pendingOrders) {
                System.out.println(count++ + ". " + order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all orders that have been completed.
     */
    public void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No orders have been completed yet.");
        } else {
            // Iterating over the List
            for (int i = 0; i < completedOrders.size(); i++) {
                System.out.println((i + 1) + ". " + completedOrders.get(i).toDetailedString());
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order System Menu ---");
        System.out.println("1. Display Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. View Completed Orders");
        System.out.println("6. Exit");
        System.out.println("------------------------------------");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main interaction loop of the system.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMainMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                }

                // Using a switch statement for main menu control flow
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeOrder(scanner);
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        viewCompletedOrders();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
             // Catch any other unexpected exceptions at the top level
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // In a real application, you would log the full stack trace
            // e.printStackTrace();
        } finally {
            scanner.close(); // Ensure scanner is closed
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.run();
    }
}
