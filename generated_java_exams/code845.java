/*
 * Exam Question #845
 * Generated on: 2025-05-12 16:49:41
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Restaurant Order Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Restaurant Order Management System using core Java concepts. The system should allow a waiter to manage a menu, place new customer orders, view pending orders, and process (serve) the next order in line.
 * 
 * The system must handle multiple pending orders in a First-In, First-Out (FIFO) manner and manage a fixed menu of items.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain the restaurant's menu as a collection of `MenuItem` objects.
 *     *   Maintain pending customer orders as a queue of `Order` objects.
 * 2.  **Classes:**
 *     *   `MenuItem` class: Represents a single item on the menu. Should have private fields for `name` (String) and `price` (double). Provide a constructor and public getter methods. Override `toString()` for easy display.
 *     *   `Order` class: Represents a customer's order. Should have a unique order ID (can be a simple counter), and a collection of `MenuItem`s ordered. Use an `ArrayList` to store the items within the order, referenced by the `List` interface. Provide a constructor, a method to add a `MenuItem` to the order, and override `toString()` to display the order ID and list of items.
 *     *   `RestaurantSystem` class: This will be the main class orchestrating the system. It should contain the menu (a `List<MenuItem>`) and the pending order queue (a `Queue<Order>`). It will contain the main application logic, including the user interaction loop.
 * 3.  **Functionality (within `RestaurantSystem`):**
 *     *   Initialize the system with a predefined menu of at least 3-4 items.
 *     *   Implement a command-line interface using `java.util.Scanner` to interact with the user (waiter).
 *     *   Present a menu of actions to the user:
 *         1.  View Menu
 *         2.  Place New Order
 *         3.  Serve Next Order
 *         4.  View Pending Orders
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice of action.
 *     *   **View Menu:** Display the list of available menu items with their prices.
 *     *   **Place New Order:**
 *         *   Prompt the user to select items from the menu by number.
 *         *   Allow the user to add multiple items to a single order until they indicate they are done.
 *         *   Create a new `Order` object with a unique ID and the selected items.
 *         *   Add the newly created order to the pending order queue.
 *     *   **Serve Next Order:**
 *         *   Remove the order at the front of the queue and display its details, simulating serving it.
 *         *   If the queue is empty, display an appropriate message.
 *     *   **View Pending Orders:**
 *         *   Display the details of all orders currently in the queue without removing them.
 *         *   If the queue is empty, display an appropriate message.
 *     *   **Exit:** Terminate the application.
 * 4.  **Error Handling & Validation:**
 *     *   Use `try-catch` blocks to handle potential runtime errors, especially `InputMismatchException` when reading numeric input from the `Scanner`.
 *     *   Validate user input for menu choices and item selections (e.g., ensure the selected item number is within the valid range).
 *     *   Display error messages for invalid operations (e.g., trying to serve from an empty queue, invalid menu selection) using `System.err`.
 *     *   Use `System.out` for all normal output and prompts.
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`) for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc where necessary.
 *     *   Ensure the `Scanner` is properly closed upon exiting.
 *     *   Handle the case where the order queue is empty gracefully for "Serve Next Order" and "View Pending Orders".
 * 
 * **Required Java Components Checklist:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` (or specific `try-catch` where errors are expected)
 * 
 * **Expected Output:**
 * 
 * The output will be interactive based on user input. Examples of interactions:
 * 
 * *   Displaying the main menu options.
 * *   Displaying the current restaurant menu.
 * *   Prompts for placing an order (e.g., "Enter item number:").
 * *   Confirmation messages (e.g., "Order X placed.").
 * *   Messages when serving an order (e.g., "Serving Order Y: ...").
 * *   Displaying the contents of the order queue.
 * *   Error messages printed to standard error (e.g., "Error: Invalid menu choice.", "Error: Cannot serve, queue is empty.").
 * *   Messages when queue is empty (e.g., "The order queue is empty.").
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Proper use of ALL specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Robust error handling and input validation.
 * *   Clean and well-structured code.
 * 
 * ```java
 * // Your code goes here
 * ```
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Scenario and Structure:** The system simulates a basic restaurant workflow. It is structured into three classes: `MenuItem` (data model for menu items), `Order` (data model for customer orders), and `RestaurantSystem` (the main application logic controller).
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: Used in `RestaurantSystem` (`orderQueue`) to manage pending orders in a FIFO manner. Methods like `offer()` (to add orders) and `poll()` (to remove and retrieve the next order) are used. Iteration for viewing uses the queue's iterator.
 *     *   `java.util.ArrayList`: Used in `RestaurantSystem` to store the `menu` and within the `Order` class to store the list of `MenuItem`s for that specific order.
 *     *   `java.util.List`: The `menu` in `RestaurantSystem` and the `items` list in `Order` are declared using the `List` interface (`List<MenuItem> menu = new ArrayList<>();`, `List<MenuItem> items = new ArrayList<>();`), promoting good practice by programming to the interface.
 *     *   `java.util.Scanner`: Used in `RestaurantSystem` (`scanner`) to read user input from the console (`System.in`). It's initialized once and reused.
 *     *   `switch` statement: Used in the `run()` method of `RestaurantSystem` to control the flow of execution based on the user's main menu choice.
 *     *   `System.err`: Used to print error messages, such as invalid input, invalid menu choices, or attempting to serve from an empty queue. This directs error output separately from normal application output.
 *     *   `System.out`: Used for all standard output, including displaying the main menu, the restaurant menu, prompts, confirmation messages, and order details.
 *     *   `try-catch`: Used extensively for exception handling:
 *         *   Specific `try-catch (InputMismatchException e)` blocks are used around `scanner.nextInt()` calls in `run()` and `placeNewOrder()` to gracefully handle cases where the user enters non-integer input when a number is expected. The invalid input is consumed (`scanner.nextLine()`) to prevent infinite loops.
 *         *   A general `try-catch (Exception e)` is included around the main `while` loop in `run()` to catch any other unexpected runtime exceptions that might occur within the system's operation, demonstrating a class-wide approach to catching potential errors. A similar catch is added in `placeNewOrder` for robustness.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Class fields (`name`, `price`, `orderId`, `items`, `menu`, `orderQueue`, `scanner`) are declared `private`. Public methods (`getName`, `getPrice`, `addItem`, `getOrderId`, `toString`, `run`) provide controlled access.
 *     *   **Meaningful Names:** Classes (`MenuItem`, `Order`, `RestaurantSystem`), methods (`displayMainMenu`, `placeNewOrder`, `serveNextOrder`, `viewPendingOrders`, `run`), and variables (`itemChoice`, `currentOrder`, `servedOrder`, `pendingOrders`) have descriptive names.
 *     *   **Comments/Documentation:** Javadoc comments are provided for classes and key methods explaining their purpose. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Input for menu choices and item selections is validated against the valid range of options.
 *     *   **Error Handling:** Invalid inputs and operational errors (like empty queue) are explicitly checked and reported using `System.err`. `try-catch` handles input format errors.
 *     *   **Clean Structure:** The code is divided logically into separate classes with clear responsibilities. The main application logic resides in the `RestaurantSystem` class's `run()` method.
 *     *   **Scanner Closing:** The `scanner.close()` method is called after the main loop terminates to release the system resource.
 * 
 * 4.  **Functionality Details:**
 *     *   The `MenuItem` and `Order` classes provide simple data structures. `Order` uses a static counter for basic unique IDs.
 *     *   The `RestaurantSystem` constructor initializes the menu and the order queue.
 *     *   The `run()` method contains the main loop, displaying options and using the `switch` statement to call appropriate handler methods.
 *     *   `displayMenu()` iterates through the menu list.
 *     *   `placeNewOrder()` loops, allowing the user to add multiple items by selecting numbers corresponding to the menu. It validates input and adds selected items to a new `Order` object before offering it to the queue.
 *     *   `serveNextOrder()` uses `orderQueue.poll()` to get and remove the head of the queue, handling the `null` case if the queue is empty.
 *     *   `viewPendingOrders()` iterates through the `orderQueue` using an enhanced for loop (which uses the queue's iterator internally) to display orders without removing them, also checking for an empty queue.
 * 
 * This solution effectively integrates the required Java components into a functional and robust application that simulates a real-world scenario, meeting the criteria for a challenging advanced programming exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single menu item in the restaurant.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The item price.
     */
    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the menu item.
     * @return Formatted string like "ItemName ($Price)".
     */
    @Override
    public String toString() {
        return String.format("%s ($%.2f)", name, price);
    }
}

/**
 * Represents a customer order containing multiple menu items.
 */
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items; // Using List interface

    /**
     * Constructs a new Order with a unique ID.
     */
    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Using ArrayList implementation
    }

    /**
     * Adds a menu item to this order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        items.add(item);
    }

    /**
     * Gets the unique ID of this order.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Returns a string representation of the order, including its ID and items.
     * @return Formatted string for the order.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ").append(orderId).append(":\n");
        if (items.isEmpty()) {
            sb.append("  (Empty Order)");
        } else {
            for (MenuItem item : items) {
                sb.append("  - ").append(item).append("\n");
            }
        }
        return sb.toString();
    }
}

/**
 * The main class managing the restaurant system, including menu and orders.
 */
public class RestaurantSystem {
    private List<MenuItem> menu; // Using List interface
    private Queue<Order> orderQueue; // Using Queue interface
    private Scanner scanner; // For user input

    /**
     * Constructs the RestaurantSystem, initializes menu and queue.
     */
    public RestaurantSystem() {
        // Initialize menu using ArrayList
        menu = new ArrayList<>();
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Fries", 3.49));
        menu.add(new MenuItem("Soda", 1.99));

        // Initialize order queue using LinkedList (implements Queue)
        orderQueue = new LinkedList<>();

        // Initialize scanner
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu of actions to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order Management ---");
        System.out.println("1. View Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Serve Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the available menu items.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menu.size(); i++) {
            // Use index + 1 for user-friendly numbering
            System.out.println((i + 1) + ". " + menu.get(i));
        }
        System.out.println("------------");
    }

    /**
     * Handles the process of placing a new customer order.
     */
    private void placeNewOrder() {
        System.out.println("\n--- Place New Order ---");
        Order currentOrder = new Order();
        boolean addingItems = true;

        while (addingItems) {
            displayMenu(); // Show menu for selection
            System.out.print("Enter item number to add (or 0 to finish order): ");
            int itemChoice = -1;
            try {
                itemChoice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                if (itemChoice == 0) {
                    addingItems = false; // Finish adding items
                } else if (itemChoice > 0 && itemChoice <= menu.size()) {
                    // Valid item choice, add to order
                    MenuItem selectedItem = menu.get(itemChoice - 1); // Adjust for 0-based index
                    currentOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else {
                    // Invalid item number
                    System.err.println("Error: Invalid item number. Please select from the menu.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                 // Catch any other unexpected errors during input or processing
                 System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to error stream
                 scanner.nextLine(); // Consume potentially problematic input
            }
        }

        if (!currentOrder.items.isEmpty()) {
            orderQueue.offer(currentOrder); // Add order to the queue
            System.out.println("Order " + currentOrder.getOrderId() + " placed successfully.");
        } else {
            System.out.println("No items added. Order cancelled.");
            // Decrement nextOrderId if order was cancelled after creation but before adding items
            // This is a minor detail, but good practice if Order ID needs to be truly sequential for placed orders
            // However, letting it increment is also acceptable depending on requirements.
            // For simplicity, we'll let it increment.
        }
    }

    /**
     * Handles serving the next order from the queue.
     */
    private void serveNextOrder() {
        System.out.println("\n--- Serving Next Order ---");
        Order servedOrder = orderQueue.poll(); // Remove and get the head of the queue

        if (servedOrder != null) {
            System.out.println("Now Serving:");
            System.out.println(servedOrder);
        } else {
            // Queue is empty
            System.err.println("Error: The order queue is empty. No orders to serve.");
        }
    }

    /**
     * Displays all pending orders in the queue without removing them.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("The order queue is empty.");
        } else {
            // Iterate through the queue using the iterator
            int count = 0;
            for (Order order : orderQueue) {
                System.out.println(order); // Order's toString handles formatting
                count++;
            }
            System.out.println("Total pending orders: " + count);
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        // Main application loop
        while (choice != 5) {
            try {
                displayMainMenu();
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use switch for flow control based on user choice
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeNewOrder();
                        break;
                    case 3:
                        serveNextOrder();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        System.out.println("Exiting Restaurant System. Goodbye!");
                        break;
                    default:
                        // Handle invalid main menu choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for main menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to prevent infinite loop if not exiting
            } catch (Exception e) {
                 // Class-wide catch for any unexpected errors in the main loop
                 System.err.println("An unexpected system error occurred: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to error stream
                 // Decide if you want to exit or try to continue after a critical error
                 // For this problem, let's allow continuation if possible, but log the error.
            }
        }

        // Ensure scanner is closed when exiting the loop
        scanner.close();
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
