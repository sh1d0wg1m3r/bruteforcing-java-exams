/*
 * Exam Question #199
 * Generated on: 2025-05-11 22:30:42
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Registration System**
 * 
 * You are tasked with developing a simple event registration system. The system needs to manage participants for an event that has a limited number of main registration slots and an unlimited waiting list.
 * 
 * **System Requirements:**
 * 
 * 1.  **Participant Management:**
 *     *   The system must be able to register new participants.
 *     *   Each participant has a unique integer ID and a String name.
 *     *   Participants are first added to the main registered list if there is capacity.
 *     *   If the main list is full, participants are added to a waiting list.
 *     *   The system must prevent registering a participant ID that already exists in either the registered list or the waiting list.
 *     *   The system must allow checking the status of a participant (registered or on waiting list, or not found).
 *     *   The system must allow an administrator to process participants from the waiting list to the registered list when slots become available. Participants should be moved from the waiting list in the order they were added (First-In, First-Out).
 *     *   The system must display all currently registered participants and all participants on the waiting list.
 * 
 * 2.  **Technical Requirements:**
 *     *   Use `java.util.Queue` to manage the waiting list.
 *     *   Use `java.util.ArrayList` to manage the main registered participants list.
 *     *   Declare the main registered participants list using the `java.util.List` interface.
 *     *   Use `java.util.Scanner` to handle user input from the console.
 *     *   Use a `switch` statement for the main menu navigation.
 *     *   Use `System.out` for normal program output (menus, success messages, displaying lists).
 *     *   Use `System.err` for displaying error messages (invalid input, participant already exists, participant not found, etc.).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch any unexpected runtime errors.
 * 
 * 3.  **Design and Best Practices:**
 *     *   Create separate classes where appropriate (`Participant`, `EventManager`, `EventManagerApp`).
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Implement robust input validation for user inputs (e.g., ensuring integers are entered where expected).
 *     *   Implement proper error handling for business logic rules (e.g., participant exists, invalid choice).
 * 
 * **Implementation Details:**
 * 
 * *   Create a `Participant` class with `id` (int) and `name` (String) fields, a constructor, and appropriate getters. Override `equals()` and `hashCode()` based on the participant ID for correct checking in collections.
 * *   Create an `EventManager` class that holds the `List` of registered participants and the `Queue` of waiting participants. It should have a constructor that takes the maximum capacity of the registered list. Implement methods for registration, status checking, processing the waiting list, and displaying participants.
 * *   Create an `EventManagerApp` class with the `main` method. This class will handle the user interaction loop, display the menu, read input using `Scanner`, and delegate operations to an `EventManager` instance using a `switch` statement. The main loop should be wrapped in a `try-catch` block.
 * 
 * **Menu Options:**
 * 
 * 1.  Register Participant
 * 2.  Check Participant Status
 * 3.  Process Waiting List
 * 4.  Display All Participants
 * 5.  Exit
 * 
 * **Expected Output:**
 * 
 * *   Clear menu display.
 * *   Prompts for necessary input based on the chosen option.
 * *   Success messages printed to `System.out`.
 * *   Error messages printed to `System.err`.
 * *   Formatted display of registered and waiting list participants.
 * *   Graceful exit.
 * 
 * Your solution should consist of the Java code for the required classes and demonstrate the use of all specified components and best practices.
 *
 * EXPLANATION:
 * The provided solution implements a simple event registration system as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Participant` Class:** A simple Plain Old Java Object (POJO) representing a participant with an `id` and `name`. It includes a constructor, getters, and overrides `equals()` and `hashCode()` based on the `id`. Overriding these methods is crucial for correctly checking if a `Participant` object with a specific ID exists within collections like `ArrayList` or `Queue`.
 * 2.  **`EventManager` Class:** This class encapsulates the core logic of the registration system.
 *     *   It holds the state: `registeredParticipants` (a `List` implemented by `ArrayList`) and `waitingList` (a `Queue` implemented by `LinkedList`). `ArrayList` is suitable for the registered list as it provides dynamic resizing and ordered storage, while `Queue` (with `LinkedList`) is ideal for the waiting list due to its First-In, First-Out (FIFO) behavior for adding (`offer`) and removing (`poll`) elements from the front.
 *     *   `maxCapacity` defines the limit for the registered list.
 *     *   `participantExists(int participantId)`: A private helper method demonstrating encapsulation, checking both the registered list and the waiting list for a given participant ID.
 *     *   `registerParticipant(Participant participant)`: Implements the registration logic. It first checks for existing IDs using `participantExists`. If the registered list is not full, the participant is added there; otherwise, they are added to the `waitingList` using `offer()`. Success messages are printed to `System.out`, and errors (like duplicate ID) are printed to `System.err`.
 *     *   `checkStatus(int participantId)`: Iterates through both lists to find the participant by ID and reports their status to `System.out`. If not found, an error is printed to `System.err`.
 *     *   `processWaitingList(int numToProcess)`: Manages moving participants from the `waitingList` to the `registeredParticipants` list. It calculates available slots and processes up to `numToProcess` participants from the *head* of the `waitingList` using `poll()`, adding them to the `registeredParticipants` list. Status updates are printed to `System.out`.
 *     *   `displayParticipants()`: Prints the contents of both lists to `System.out`. It iterates the `Queue` to display elements without removing them.
 * 
 * 3.  **`EventManagerApp` Class:** Contains the `main` method, serving as the application's entry point and user interface handler.
 *     *   It initializes a `Scanner` for console input and an `EventManager` instance.
 *     *   It uses a `while(true)` loop to keep the application running until the user chooses to exit.
 *     *   The main loop body is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime exceptions that might occur during the execution of menu options and printing a general error message and potentially a stack trace (commented out by default) to `System.err`.
 *     *   Inside the `try` block, it prompts the user for input, reads the choice, and uses a `switch` statement to handle different menu options.
 *     *   **Input Validation:** Before processing integer inputs (menu choice, participant ID, number to process), `scanner.hasNextInt()` is used within a `while` loop to ensure the input is an integer. If not, an error is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and the user is prompted again. `scanner.nextLine()` is called after each `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   Based on the `switch` case, it prompts for necessary details, creates `Participant` objects, and calls the appropriate methods on the `eventManager` instance.
 *     *   Case 5 handles the exit, closing the `Scanner` resource and terminating the application using `return`.
 *     *   The `default` case of the `switch` handles invalid menu choices, printing an error to `System.err`.
 *     *   `System.out.println()` is used for standard output like the menu, prompts, and success messages. `System.err.println()` is used exclusively for error messages.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Collections:** Practical use of `List` (`ArrayList`) and `Queue` (`LinkedList`) based on their appropriate use cases (ordered list vs. FIFO queue).
 * *   **Interfaces:** Using the `List` and `Queue` interfaces promotes flexibility.
 * *   **Object-Oriented Programming:** Encapsulation through private fields and public methods (`EventManager`, `Participant`).
 * *   **Input Handling:** Using `Scanner` for console input and implementing robust input validation loops.
 * *   **Control Flow:** Using `switch` for multi-way branching based on user input.
 * *   **Error Handling:**
 *     *   Specific business logic errors (e.g., participant exists) handled within `EventManager` methods using `System.err`.
 *     *   General, unexpected runtime errors caught by the `try-catch(Exception e)` block in the `main` loop (`EventManagerApp`), demonstrating class-wide exception handling using `System.err`.
 * *   **Best Practices:** Meaningful names, comments, `equals`/`hashCode` override for collection compatibility, proper resource management (closing `Scanner`).
 * 
 * This solution provides a functional system that meets all the requirements of the exam question, demonstrating a solid understanding of core and intermediate Java concepts in a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Objects;

// Represents a participant in the event
class Participant {
    private int id;
    private String name;

    public Participant(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    // Override equals and hashCode based on ID for correct comparison in collections
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Participant that = (Participant) o;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

// Manages the registered participants and the waiting list
class EventManager {
    // Registered participants list (uses List interface, implemented by ArrayList)
    private List<Participant> registeredParticipants;
    // Waiting list (uses Queue interface, implemented by LinkedList for FIFO)
    private Queue<Participant> waitingList;
    private int maxCapacity;

    public EventManager(int maxCapacity) {
        this.maxCapacity = maxCapacity;
        this.registeredParticipants = new ArrayList<>(); // Use ArrayList for registered list
        this.waitingList = new LinkedList<>(); // Use LinkedList for Queue implementation
    }

    // Helper method to check if a participant ID already exists in either list
    private boolean participantExists(int participantId) {
        for (Participant p : registeredParticipants) {
            if (p.getId() == participantId) {
                return true;
            }
        }
        for (Participant p : waitingList) {
            if (p.getId() == participantId) {
                return true;
            }
        }
        return false;
    }

    // Register a new participant
    public void registerParticipant(Participant participant) {
        if (participantExists(participant.getId())) {
            System.err.println("Error: Participant with ID " + participant.getId() + " already exists.");
            return;
        }

        if (registeredParticipants.size() < maxCapacity) {
            registeredParticipants.add(participant);
            System.out.println("Participant " + participant.getName() + " (ID: " + participant.getId() + ") successfully REGISTERED.");
        } else {
            waitingList.offer(participant); // Add to the end of the waiting list queue
            System.out.println("Participant " + participant.getName() + " (ID: " + participant.getId() + ") added to WAITING LIST. The registered list is full.");
        }
    }

    // Check the status of a participant by ID
    public void checkStatus(int participantId) {
        for (Participant p : registeredParticipants) {
            if (p.getId() == participantId) {
                System.out.println("Participant ID " + participantId + " is REGISTERED.");
                return;
            }
        }

        // Check waiting list
        boolean foundInWaitingList = false;
        int position = 0;
        for (Participant p : waitingList) { // Iterating Queue is safe for checking existence/position
             position++;
             if (p.getId() == participantId) {
                 System.out.println("Participant ID " + participantId + " is on the WAITING LIST (Position approx: " + position + ").");
                 foundInWaitingList = true;
                 break; // Found, no need to continue iterating
             }
        }

        if (!foundInWaitingList) {
            System.err.println("Participant with ID " + participantId + " not found in either list.");
        }
    }

    // Process participants from the waiting list to fill available slots
    public void processWaitingList(int numToProcess) {
        int availableSlots = maxCapacity - registeredParticipants.size();

        if (availableSlots <= 0) {
            System.out.println("No slots available in the registered list.");
            return;
        }

        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty. Nothing to process.");
            return;
        }

        int processedCount = 0;
        // Process up to numToProcess OR availableSlots, whichever is smaller
        while (processedCount < numToProcess && availableSlots > 0 && !waitingList.isEmpty()) {
            Participant participantToProcess = waitingList.poll(); // Get and remove head of the queue
            if (participantToProcess != null) { // Should not be null if queue is not empty
                registeredParticipants.add(participantToProcess);
                System.out.println("Processed participant ID " + participantToProcess.getId() + " (" + participantToProcess.getName() + ") from waiting list to registered.");
                processedCount++;
                availableSlots--; // Decrement available slots
            } else {
                // This case should ideally not be reached if !waitingList.isEmpty() is checked
                System.err.println("Unexpected error: Could not poll from waiting list.");
                break;
            }
        }

        if (processedCount > 0) {
             System.out.println("Finished processing. " + processedCount + " participants moved from waiting list to registered.");
        } else {
             System.out.println("No participants were moved from waiting list (either requested 0, no slots, or waiting list empty).");
        }
    }

    // Display all registered and waiting list participants
    public void displayParticipants() {
        System.out.println("\n--- Registered Participants (" + registeredParticipants.size() + "/" + maxCapacity + ") ---");
        if (registeredParticipants.isEmpty()) {
            System.out.println("No participants registered yet.");
        } else {
            for (int i = 0; i < registeredParticipants.size(); i++) {
                System.out.println((i + 1) + ". " + registeredParticipants.get(i));
            }
        }

        System.out.println("\n--- Waiting List Participants (" + waitingList.size() + ") ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            int position = 1;
            for (Participant p : waitingList) { // Iterate queue to display elements without removing
                System.out.println(position + ". " + p);
                position++;
            }
        }
        System.out.println("----------------------------------------");
    }
}

// Main application class to run the event registration system
public class EventManagerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Create EventManager with a max capacity of 10 registered participants
        EventManager eventManager = new EventManager(10);

        System.out.println("--- Event Registration System ---");

        // Main application loop with class-wide exception handling
        while (true) {
            printMenu();

            // Use try-catch for general exception handling around the menu processing
            try {
                System.out.print("Enter your choice: ");
                // Input validation for menu choice
                while (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    scanner.next(); // Consume the invalid input
                    System.out.print("Enter your choice: ");
                }
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                switch (choice) {
                    case 1: // Register Participant
                        System.out.print("Enter Participant ID (integer): ");
                        // Input validation for participant ID
                        while (!scanner.hasNextInt()) {
                            System.err.println("Invalid input. Please enter an integer for ID.");
                            scanner.next(); // Consume invalid input
                            System.out.print("Enter Participant ID (integer): ");
                        }
                        int id = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        System.out.print("Enter Participant Name: ");
                        String name = scanner.nextLine();

                        Participant newParticipant = new Participant(id, name);
                        eventManager.registerParticipant(newParticipant);
                        break;

                    case 2: // Check Participant Status
                        System.out.print("Enter Participant ID to check status: ");
                         // Input validation for participant ID
                        while (!scanner.hasNextInt()) {
                            System.err.println("Invalid input. Please enter an integer for ID.");
                            scanner.next(); // Consume invalid input
                            System.out.print("Enter Participant ID to check status: ");
                        }
                        int statusId = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        eventManager.checkStatus(statusId);
                        break;

                    case 3: // Process Waiting List
                        System.out.print("Enter number of participants to process from waiting list: ");
                         // Input validation for number to process
                        while (!scanner.hasNextInt()) {
                            System.err.println("Invalid input. Please enter an integer.");
                            scanner.next(); // Consume invalid input
                            System.out.print("Enter number of participants to process: ");
                        }
                        int numToProcess = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        if (numToProcess < 0) {
                             System.err.println("Number to process cannot be negative.");
                        } else {
                             eventManager.processWaitingList(numToProcess);
                        }
                        break;

                    case 4: // Display All Participants
                        eventManager.displayParticipants();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Event Registration System. Goodbye!");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (Exception e) {
                // Class-wide exception handling for any unexpected errors
                System.err.println("\nAn unexpected error occurred during processing:");
                System.err.println(e.getMessage());
                // e.printStackTrace(System.err); // Optional: Print stack trace for debugging
            }
            System.out.println(); // Add a newline for better readability between operations
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Register Participant");
        System.out.println("2. Check Participant Status");
        System.out.println("3. Process Waiting List");
        System.out.println("4. Display All Participants");
        System.out.println("5. Exit");
    }
}
