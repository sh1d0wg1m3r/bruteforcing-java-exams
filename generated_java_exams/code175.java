/*
 * Exam Question #175
 * Generated on: 2025-05-11 22:26:05
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Simple Job Queue System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple job processing system. The system manages jobs that are submitted and processed sequentially. New jobs are added to a queue awaiting processing. Once a job is processed, it is moved to an archive. The system should provide a command-line interface for users to interact with it.
 * 
 * **System Functionality:**
 * 
 * 1.  **Add New Job:** Allows the user to enter a description for a new job and adds it to the end of the pending job queue.
 * 2.  **Process Next Job:** Takes the next job from the front of the pending job queue, marks it as processed, and moves it to an archived jobs list. This operation should only be possible if there are pending jobs.
 * 3.  **View Pending Jobs:** Displays all jobs currently in the pending queue, in the order they will be processed.
 * 4.  **View Archived Jobs:** Displays all jobs that have been processed and moved to the archive.
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be a single Java class and adhere to the following:
 * 
 * *   Use `java.util.Queue` to manage the pending jobs. Choose an appropriate implementation (e.g., `LinkedList`).
 * *   Use `java.util.ArrayList` to store the archived jobs.
 * *   Declare the variable holding archived jobs using the `java.util.List` interface type.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the different user menu choices.
 * *   Use `System.err` to output all error messages (e.g., invalid input, attempting to process when queue is empty).
 * *   Use `System.out` for all normal output (menu, prompts, job listings, success messages).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, including unexpected errors during the main application loop and specific input errors.
 * *   Ensure proper input validation (e.g., job description not empty, menu choice is valid).
 * *   Follow Java best practices:
 *     *   Proper encapsulation (private fields, public methods where necessary).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (at least for the class and main methods).
 *     *   Clean code structure with logical separation of concerns into methods.
 * 
 * **User Interface:**
 * 
 * The system should present a menu to the user with options corresponding to the functionalities listed above. After performing an action, the menu should be displayed again until the user chooses to exit.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Job Queue System Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Archived Jobs
 * 0. Exit
 * -----------------------------
 * Enter choice: 1
 * Enter job description: Analyze report data
 * Job added: Analyze report data
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 1
 * Enter job description: Write presentation
 * Job added: Write presentation
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 3
 * Pending Jobs:
 * 1. Analyze report data
 * 2. Write presentation
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 2
 * Processed job: Analyze report data
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 3
 * Pending Jobs:
 * 1. Write presentation
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 4
 * Archived Jobs:
 * 1. Analyze report data
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 2
 * Processed job: Write presentation
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 2
 * Error: No pending jobs to process.
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 4
 * Archived Jobs:
 * 1. Analyze report data
 * 2. Write presentation
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 5
 * Error: Invalid choice. Please try again.
 * 
 * --- Job Queue System Menu ---
 * ...
 * Enter choice: 0
 * Exiting system. Goodbye!
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `SimpleJobQueueSystem` class.
 *
 * EXPLANATION:
 * This solution implements a `SimpleJobQueueSystem` class that manages job processing using a queue for pending jobs and a list for archived jobs.
 * 
 * 1.  **Data Structures (`Queue`, `List`, `ArrayList`)**:
 *     *   `pendingJobs` is declared as a `Queue<String>` and initialized with `LinkedList<String>`. This correctly uses the `Queue` interface for FIFO behavior (jobs are processed in the order they are added). `LinkedList` is a suitable implementation for a queue as it provides efficient `offer()` (add to end) and `poll()` (remove from front) operations.
 *     *   `archivedJobs` is declared using the `List<String>` interface and initialized with `ArrayList<String>`. This demonstrates the use of the `List` interface, which is good practice, while using `ArrayList` as a concrete implementation for storing processed jobs in a dynamic array structure.
 * 
 * 2.  **User Input (`Scanner`)**:
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   `scanner.nextInt()` is used to read the integer menu choice.
 *     *   `scanner.nextLine()` is used to read the job description. Crucially, `scanner.nextLine()` is also called *after* `scanner.nextInt()` (typically in a `finally` block within the input reading logic) to consume the leftover newline character, preventing issues when subsequently reading a line of text.
 * 
 * 3.  **Control Flow (`switch`, Loop)**:
 *     *   The main application logic runs within a `while(running)` loop in the `run()` method, allowing repeated interaction until the user chooses to exit.
 *     *   A `switch` statement is used on the user's integer input (`choice`) to direct the program flow to the corresponding method (`addJob`, `processNextJob`, etc.). A `default` case handles invalid numeric input.
 * 
 * 4.  **Output (`System.out`, `System.err`)**:
 *     *   `System.out.println()` is used for all standard output, such as displaying the menu, prompts, confirmation messages, and lists of jobs.
 *     *   `System.err.println()` is used exclusively for error messages, such as when the job description is empty, the user enters an invalid menu choice, or there are no pending jobs to process. This is a standard practice to separate normal output from error streams.
 * 
 * 5.  **Error Handling (`try-catch`)**:
 *     *   A class-wide `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This serves as a general catch-all for unexpected runtime errors that might occur within the application loop, preventing the program from crashing abruptly and printing an informative message to `System.err`.
 *     *   An inner `try-catch(InputMismatchException e)` block is used specifically when reading the integer menu choice. This handles cases where the user enters non-integer input, preventing the program from throwing an exception and crashing. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` before continuing the loop.
 *     *   Specific checks are performed within methods (`processNextJob`, `viewPendingJobs`, `viewArchivedJobs`) to handle empty collections gracefully, printing informative messages to `System.err` or `System.out` as appropriate.
 * 
 * 6.  **Best Practices**:
 *     *   **Encapsulation:** Fields (`pendingJobs`, `archivedJobs`, `scanner`) are `private`. Methods like `displayMenu`, `addJob`, etc., are `private` helper methods, while `run()` and `main()` are `public` entry points.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingJobs`, `processNextJob`, `viewArchivedJobs`).
 *     *   **Comments:** Javadoc comments explain the purpose of the class and key methods. Inline comments clarify specific logic points (like consuming the newline).
 *     *   **Input Validation:** The `addJob` method checks if the entered description is empty. The input reading logic handles non-integer input for the menu choice.
 *     *   **Clean Structure:** The code is divided into logical methods, each responsible for a specific task (displaying menu, adding a job, processing a job, viewing lists).
 *     *   **Resource Management:** The `Scanner` resource is closed in a `finally` block within the `run()` method's main `try` block, ensuring it is closed regardless of how the loop terminates (normal exit or unexpected exception).
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, albeit simple, application context, providing a good challenge for an exam.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // To catch non-integer input

/**
 * A simple job queue system that manages pending and archived jobs.
 * Demonstrates the use of Queue, List, ArrayList, Scanner, switch,
 * System.out, System.err, and try-catch for error handling.
 */
public class SimpleJobQueueSystem {

    // Use Queue for pending jobs (FIFO)
    private Queue<String> pendingJobs;
    // Use List interface for archived jobs, implemented by ArrayList
    private List<String> archivedJobs;
    private Scanner scanner;

    /**
     * Constructor to initialize the job queue system components.
     */
    public SimpleJobQueueSystem() {
        // LinkedList is a good choice for Queue as it supports efficient additions and removals from both ends.
        pendingJobs = new LinkedList<>();
        archivedJobs = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Job Queue System Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Archived Jobs");
        System.out.println("0. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Adds a new job to the pending job queue.
     * Prompts the user for a job description and validates it.
     */
    private void addJob() {
        System.out.print("Enter job description: ");
        String jobDescription = scanner.nextLine().trim(); // Use nextLine() to read the whole line after nextInt(), trim whitespace

        if (jobDescription.isEmpty()) {
            System.err.println("Error: Job description cannot be empty.");
            return;
        }

        pendingJobs.offer(jobDescription); // offer() is preferred over add() for capacity-constrained queues, but works fine here.
        System.out.println("Job added: " + jobDescription);
    }

    /**
     * Processes the next job from the pending queue.
     * Removes the job from the queue and adds it to the archived list.
     * Handles the case where the queue is empty.
     */
    private void processNextJob() {
        String jobToProcess = pendingJobs.poll(); // poll() retrieves and removes the head, returns null if queue is empty

        if (jobToProcess == null) {
            System.err.println("Error: No pending jobs to process.");
        } else {
            archivedJobs.add(jobToProcess);
            System.out.println("Processed job: " + jobToProcess);
        }
    }

    /**
     * Displays all jobs currently in the pending queue.
     * Handles the case where the queue is empty.
     */
    private void viewPendingJobs() {
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            System.out.println("Pending Jobs:");
            // Iterate through the queue without removing elements
            int index = 1;
            for (String job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Displays all jobs currently in the archived list.
     * Handles the case where the list is empty.
     */
    private void viewArchivedJobs() {
        if (archivedJobs.isEmpty()) {
            System.out.println("No archived jobs.");
        } else {
            System.out.println("Archived Jobs:");
            // Iterate through the list
            for (int i = 0; i < archivedJobs.size(); i++) {
                System.out.println((i + 1) + ". " + archivedJobs.get(i));
            }
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Runs the main application loop, handling user input and actions.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice

                // Inner try-catch for reading integer input specifically
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop iteration and show menu again
                } finally {
                     // Consume the newline character left by scanner.nextInt()
                     // This is crucial before calling scanner.nextLine() later
                     scanner.nextLine();
                }


                // Use switch statement to handle different user choices
                switch (choice) {
                    case 1:
                        addJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewPendingJobs();
                        break;
                    case 4:
                        viewArchivedJobs();
                        break;
                    case 0:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to false to exit loop
                        break;
                    default:
                        // Handle invalid numeric choices
                        System.err.println("Invalid choice. Please try again.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during runtime
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed when the application exits
            closeScanner();
            System.out.println("System shut down.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SimpleJobQueueSystem system = new SimpleJobQueueSystem();
        system.run(); // Start the application loop
    }
}
