/*
 * Exam Question #910
 * Generated on: 2025-05-12 16:58:26
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simple Task Scheduler**
 * 
 * You are tasked with developing a simple command-line application for managing tasks. The system should allow users to add new tasks, process the next pending task, and view the lists of pending and completed tasks.
 * 
 * **Task Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (e.g., 1 for High, 2 for Medium, 3 for Low).
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Include a `toString()` method for easy printing of task details.
 * 
 * 2.  **Task Scheduler Logic:** Create a class `TaskScheduler` that manages the tasks.
 *     *   It must use a `java.util.Queue` to store tasks that are pending processing.
 *     *   It must use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Provide methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue (FIFO order), simulates processing (e.g., prints a message), and moves it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns a `java.util.List` view of the tasks currently in the pending queue. *Do not return the queue directly.*
 *         *   `getCompletedTasks()`: Returns a `java.util.List` containing all completed tasks.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `TaskSchedulerApp`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation:
 *         *   Ensure menu choices are valid integers within the range.
 *         *   Ensure task ID and priority are valid integers.
 *         *   Handle cases where input types don't match (`InputMismatchException`).
 *     *   Use `System.out` for displaying the menu, task details, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, no tasks to process).
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main user interaction loop to gracefully handle unexpected errors.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform actions based on the input.
 * *   Adding a task should prompt for ID, description, and priority, and confirm addition.
 * *   Processing a task should indicate which task is being processed or report if the queue is empty.
 * *   Viewing pending/completed tasks should list the tasks in the respective collections or state that the list is empty.
 * *   Invalid input or operations should result in an error message printed to `System.err`.
 * *   The program should exit gracefully when the user chooses the Exit option.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Task Description: Write report
 * Enter Priority (1-3): 2
 * Task added: Task{id=101, description='Write report', priority=2}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 1
 * Enter Task ID: 102
 * Enter Task Description: Prepare presentation
 * Enter Priority (1-3): 1
 * Task added: Task{id=102, description='Prepare presentation', priority=1}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=101, description='Write report', priority=2}
 * Task{id=102, description='Prepare presentation', priority=1}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=101, description='Write report', priority=2}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=102, description='Prepare presentation', priority=1}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=101, description='Write report', priority=2}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * Your solution must demonstrate a clear understanding of object-oriented principles, collection usage, error handling, and basic command-line interaction in Java.
 *
 * EXPLANATION:
 * This solution implements a simple task scheduler demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with private fields (`taskId`, `description`, `priority`) ensuring encapsulation.
 *     *   The constructor includes basic input validation, throwing `IllegalArgumentException` for invalid task data.
 *     *   Public getter methods provide controlled access to the task's attributes.
 *     *   `toString()` provides a convenient way to print task details.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   Uses a `Queue<Task>` (`LinkedList` implementation) for `pendingTasks`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing FIFO behavior suitable for a basic processing queue.
 *     *   Uses an `ArrayList<Task>` for `completedTasks`. `ArrayList` is suitable for storing completed tasks as a list where elements are added sequentially and can be easily iterated over.
 *     *   `addTask()` uses `queue.offer()` to add tasks to the end of the pending queue.
 *     *   `processNextTask()` uses `queue.poll()` to retrieve and remove the task at the head of the queue. It handles the case where the queue is empty by checking if `poll()` returns `null`. Processed tasks are moved to the `completedTasks` list.
 *     *   `getPendingTasks()` returns a *new* `ArrayList` created from the `pendingTasks` queue. This is a good practice to prevent external code from modifying the internal state of the queue directly.
 *     *   `getCompletedTasks()` returns the internal `completedTasks` list. While returning a copy is safer for immutability, returning the list reference is acceptable here as it's a collection of completed items, and external read access is the primary use case.
 * 
 * 3.  **`TaskSchedulerApp` Class:**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   A `Scanner` is used for reading user input from the console. It's declared as `static` and closed before the application exits.
 *     *   A `TaskScheduler` instance is created to manage the tasks.
 *     *   A `while` loop runs the main application menu until the user chooses to exit.
 *     *   Inside the loop, `printMenu()` displays the options.
 *     *   A `try-catch` block wraps the core logic inside the loop. This provides class-wide exception handling, catching `InputMismatchException` for invalid number inputs, `IllegalArgumentException` thrown by the `Task` constructor for invalid task data, and a general `Exception` for any other unexpected issues. Error messages are printed to `System.err`.
 *     *   A `switch` statement processes the user's validated integer choice, calling the appropriate methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`).
 *     *   `addTask()` prompts the user for task details and creates a `Task` object. It relies on the `Task` constructor for validation.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()` retrieve the respective lists from the scheduler and iterate through them, printing task details or an "empty" message.
 *     *   `scanner.nextLine()` is used after reading integers with `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a practical scenario, demonstrating object-oriented design, data structure usage, input handling, and error management according to best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private int taskId;
    private String description;
    private int priority; // e.g., 1=High, 2=Medium, 3=Low

    public Task(int taskId, String description, int priority) {
        if (taskId <= 0) {
            throw new IllegalArgumentException("Task ID must be positive.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 1 || priority > 3) {
            throw new IllegalArgumentException("Priority must be between 1 and 3.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.priority = priority;
    }

    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "', priority=" + priority + '}';
    }
}

// Manages the collection of tasks
class TaskScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    public TaskScheduler() {
        // LinkedList implements the Queue interface
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task == null) {
            System.err.println("Error: Cannot add a null task.");
            return;
        }
        this.pendingTasks.offer(task); // offer is generally preferred over add for queues
        System.out.println("Task added: " + task);
    }

    /**
     * Processes the next task in the queue.
     * Removes it from pending and adds to completed.
     * @return The processed task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processing task: " + nextTask);
        } else {
            System.err.println("No tasks in the pending queue to process.");
        }
        return nextTask;
    }

    /**
     * Returns a list of pending tasks.
     * @return A new ArrayList containing the pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of completed tasks.
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // It's acceptable to return the list directly if read-only access is implied
        // or if modifications to this list by external code are part of the design.
        // For this problem, returning the list directly is fine.
        return completedTasks;
    }
}

// Main application class for user interaction
public class TaskSchedulerApp {

    private static Scanner scanner = new Scanner(System.in);
    private static TaskScheduler scheduler = new TaskScheduler();

    public static void main(String[] args) {
        System.out.println("--- Simple Task Scheduler ---");

        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        scheduler.processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Scheduler.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException e) {
                System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    private static void addTask() {
        System.out.print("Enter Task ID: ");
        int id = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        System.out.print("Enter Task Description: ");
        String description = scanner.nextLine();

        System.out.print("Enter Priority (1-3): ");
        int priority = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        // Task constructor handles validation and throws IllegalArgumentException
        Task newTask = new Task(id, description, priority);
        scheduler.addTask(newTask);
    }

    private static void viewPendingTasks() {
        List<Task> pending = scheduler.getPendingTasks();
        System.out.println("Pending Tasks:");
        if (pending.isEmpty()) {
            System.out.println("  No pending tasks.");
        } else {
            for (Task task : pending) {
                System.out.println("  " + task);
            }
        }
    }

    private static void viewCompletedTasks() {
        List<Task> completed = scheduler.getCompletedTasks();
        System.out.println("Completed Tasks:");
        if (completed.isEmpty()) {
            System.out.println("  No completed tasks.");
        } else {
            for (Task task : completed) {
                System.out.println("  " + task);
            }
        }
    }
}
