/*
 * Exam Question #902
 * Generated on: 2025-05-12 16:57:17
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified backend system for a small restaurant's order management. The system needs to handle incoming customer orders, display the menu, and process orders in the order they were received.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store customer orders waiting to be processed. Orders should be processed in First-In, First-Out (FIFO) order.
 *     *   Use a `java.util.ArrayList` (implementing `java.util.List`) to store the restaurant's fixed menu items.
 * 2.  **Classes:**
 *     *   Create a `MenuItem` class to represent items on the menu (e.g., Burger, Pizza, Fries). Each menu item should have a name and a price.
 *     *   Create an `OrderItem` class to represent a single item within a customer's order (a specific `MenuItem` and the quantity ordered).
 *     *   Create an `Order` class to represent a complete customer order. An order should have a unique ID and contain a list of `OrderItem`s. It should be able to calculate its total price.
 *     *   Create a main class (e.g., `RestaurantSystem`) containing the `main` method to run the application logic.
 * 3.  **Functionality:**
 *     *   Initialize a fixed menu with several items.
 *     *   Provide a text-based menu interface to the user with options:
 *         *   View Menu
 *         *   Place New Order
 *         *   Process Next Order
 *         *   Exit
 *     *   **View Menu:** Display the list of available menu items with their prices and corresponding selection numbers.
 *     *   **Place New Order:**
 *         *   Generate a unique ID for the new order (a simple counter is sufficient).
 *         *   Allow the user to add multiple items to the order. For each item:
 *             *   Prompt the user to select an item by its number from the menu.
 *             *   Prompt the user for the quantity of the item.
 *             *   Validate the user's input (item number must be valid, quantity must be positive). Use `System.err` for invalid input messages.
 *             *   Add the selected `MenuItem` and quantity as an `OrderItem` to the current `Order`.
 *             *   Ask the user if they want to add more items to the *same* order.
 *         *   Once the user finishes adding items, add the complete `Order` to the `Queue`.
 *         *   Display a confirmation message including the order ID and total price using `System.out`.
 *     *   **Process Next Order:**
 *         *   Check if the order `Queue` is empty. If empty, print a message to `System.out` indicating no orders are pending.
 *         *   If not empty, remove the next order from the front of the `Queue`.
 *         *   Display the details of the processed order (ID, list of items with quantities, total price) using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input from the console.
 * 5.  **Control Flow:** Use a `switch` statement to handle the main menu options selected by the user.
 * 6.  **Error Handling:**
 *     *   Implement input validation for menu choices and quantities. Use loops to re-prompt on invalid input rather than crashing.
 *     *   Use `System.err.println()` to output specific error messages related to invalid user input (e.g., non-numeric input, out-of-range menu choice, non-positive quantity).
 *     *   Implement class-wide exception handling using `try-catch` blocks. The main application loop should be wrapped in a `try-catch` block to catch unexpected exceptions and provide a graceful shutdown message using `System.err`. Specific input parsing should also use `try-catch` (e.g., `NumberFormatException`).
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/setters where needed, constructors).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, allow the user to interact by typing numbers corresponding to options, provide feedback on actions, display menus and orders clearly, and output errors to the error stream (`System.err`).
 * 
 * ```
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: 2
 * --- Menu ---
 * 1. Burger ($5.99)
 * 2. Pizza ($12.50)
 * 3. Fries ($2.99)
 * 4. Drink ($1.99)
 * Enter item number to add (or 0 to finish order): 1
 * Enter quantity: 2
 * Added 2 x Burger to order.
 * Add more items? (yes/no): yes
 * Enter item number to add (or 0 to finish order): 3
 * Enter quantity: 3
 * Added 3 x Fries to order.
 * Add more items? (yes/no): no
 * Order #1 placed. Total: $17.95
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: 3
 * Processing Order #1:
 * - 2 x Burger
 * - 3 x Fries
 * Total: $17.95
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: 3
 * No pending orders in the queue.
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: invalid_input
 * [Error] Invalid input. Please enter a number.
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: 99
 * [Error] Invalid choice. Please enter a number between 1 and 4.
 * --- Restaurant Order System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. Exit
 * Enter your choice: 4
 * Exiting system.
 * ```
 * *(Note: Error messages should appear on System.err, normal output on System.out)*
 * 
 * **Constraints:**
 * 
 * *   Use *only* the specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   The menu is fixed and should be initialized at the start.
 * *   Order IDs should be simple integers starting from 1.
 * 
 * **Grading:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Robust error handling and input validation using `System.err` and `try-catch`.
 * *   Clean code structure and readability.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simplified restaurant order management system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   `MenuItem`, `OrderItem`, and `Order` classes are defined with private fields (`name`, `price`, `item`, `quantity`, `orderId`, `items`). Public methods (getters, `addOrderItem`, `getTotalPrice`) provide controlled access to the data, adhering to encapsulation principles.
 *     *   The `RestaurantSystem` class orchestrates the application, holding the main data structures (`menuItems`, `orderQueue`) and the `Scanner`.
 * 
 * 2.  **Data Structures:**
 *     *   `menuItems` is declared as `List<MenuItem>` and initialized as an `ArrayList<MenuItem>`. This demonstrates using the `List` interface while implementing it with `ArrayList`. It stores the fixed menu.
 *     *   `orderQueue` is declared as `Queue<Order>` and initialized as a `LinkedList<Order>`. `LinkedList` is chosen because it efficiently implements the `Queue` interface (offering O(1) operations for adding to the end and removing from the beginning). It stores orders waiting to be processed.
 * 
 * 3.  **Queue Usage (`java.util.Queue`):**
 *     *   `orderQueue.offer(currentOrder)` is used in `placeNewOrder` to add a completed order to the end of the queue. `offer()` is generally preferred over `add()` for capacity-constrained queues, though `LinkedList` is not capacity-constrained; it's good practice.
 *     *   `orderQueue.poll()` is used in `processNextOrder` to retrieve and remove the order at the front of the queue. `poll()` returns `null` if the queue is empty, which is handled gracefully.
 * 
 * 4.  **List/ArrayList Usage (`java.util.List`, `java.util.ArrayList`):**
 *     *   `menuItems` (declared as `List`, instantiated as `ArrayList`) stores the menu. `menuItems.get(index)` is used to retrieve a specific menu item based on the user's selection (after adjusting for 0-based indexing).
 *     *   `items` within the `Order` class is declared as `List<OrderItem>` and instantiated as `ArrayList<OrderItem>`. `items.add(orderItem)` is used to add items to a customer's order.
 * 
 * 5.  **Scanner Usage (`java.util.Scanner`):**
 *     *   A single `Scanner` instance (`scanner`) is created in the `RestaurantSystem` constructor and used throughout the application to read user input from `System.in`.
 *     *   Input is primarily read using `scanner.nextLine()` to avoid issues with the newline character left behind by `nextInt()` and to facilitate robust parsing with `try-catch`.
 * 
 * 6.  **Switch Statement:**
 *     *   A `switch` statement in the `run` method is used to direct the program flow based on the user's main menu choice (1, 2, 3, or 4).
 * 
 * 7.  **System.out and System.err:**
 *     *   `System.out.println()` and `System.out.printf()` are used for standard output: displaying the main menu, the restaurant menu, confirmations, and processed order details.
 *     *   `System.err.println()` is used specifically for displaying error messages resulting from invalid user input (e.g., non-numeric input, out-of-range choices, invalid quantities) and for fatal errors caught by the class-wide `try-catch`.
 * 
 * 8.  **Exception Handling (`try-catch`):**
 *     *   **Class-wide handling:** The `run` method contains a large `try-catch (Exception e)` block that wraps the main application loop (`while (choice != 4)`). This catches any unexpected runtime exceptions that might occur elsewhere in the code, preventing the program from crashing abruptly and providing a user-friendly (or developer-friendly, via stack trace) error message on `System.err`.
 *     *   **Specific input parsing:** Inside the `run` method's loop and within the `placeNewOrder` method, `try-catch (NumberFormatException e)` blocks are used around `Integer.parseInt(inputLine)`. This handles cases where the user enters non-numeric text when a number is expected, printing an error to `System.err` and allowing the input loop to continue asking for valid input.
 *     *   **Input Validation:** Loops (`while (!validInput)`) are used in `placeNewOrder` to repeatedly prompt the user for item numbers and quantities until valid input (correct range, positive quantity) is received. This works in conjunction with the `try-catch` blocks for parsing.
 *     *   **OrderItem validation:** The `OrderItem` constructor throws an `IllegalArgumentException` if a non-positive quantity is provided, ensuring data integrity. This exception is caught in `placeNewOrder`.
 * 
 * 9.  **Best Practices:**
 *     *   Meaningful names are used for classes (`MenuItem`, `Order`), variables (`menuItems`, `orderQueue`, `currentOrder`, `itemChoice`, `quantity`), and methods (`displayMenu`, `placeNewOrder`, `processNextOrder`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections. Javadoc comments are included for classes and public methods.
 *     *   The code is structured logically into separate methods for different actions (`displayMenu`, `placeNewOrder`, `processNextOrder`, `run`).
 *     *   The `Scanner` is closed in a `finally` block to release system resources.
 * 
 * This solution effectively integrates the required Java components to build a functional, albeit simplified, system that demonstrates robust input handling, error reporting, and basic data management using queues and lists.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Not strictly needed if reading as nextLine and parsing, but good to know.

/**
 * Represents a single menu item.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the item.
     * @param price The price of the item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The item price.
     */
    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("%s ($%.2f)", name, price);
    }
}

/**
 * Represents an item within a specific customer order.
 */
class OrderItem {
    private MenuItem item;
    private int quantity;

    /**
     * Constructs a new OrderItem.
     * @param item The MenuItem being ordered.
     * @param quantity The quantity of the item.
     */
    public OrderItem(MenuItem item, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.item = item;
        this.quantity = quantity;
    }

    /**
     * Gets the MenuItem for this order item.
     * @return The MenuItem.
     */
    public MenuItem getItem() {
        return item;
    }

    /**
     * Gets the quantity of the item.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Calculates the subtotal for this order item (price * quantity).
     * @return The subtotal.
     */
    public double getSubtotal() {
        return item.getPrice() * quantity;
    }

    @Override
    public String toString() {
        return String.format("%d x %s", quantity, item.getName());
    }
}

/**
 * Represents a complete customer order.
 */
class Order {
    private static int nextOrderId = 1;
    private int orderId;
    private List<OrderItem> items; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new Order with a unique ID.
     */
    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Using ArrayList concrete class
    }

    /**
     * Gets the unique ID of the order.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Adds an OrderItem to this order.
     * @param orderItem The OrderItem to add.
     */
    public void addOrderItem(OrderItem orderItem) {
        this.items.add(orderItem);
    }

    /**
     * Gets the list of OrderItems in this order.
     * @return The list of OrderItems.
     */
    public List<OrderItem> getItems() {
        return items;
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotalPrice() {
        double total = 0;
        for (OrderItem item : items) {
            total += item.getSubtotal();
        }
        return total;
    }
}

/**
 * Main class for the Restaurant Order Management System.
 * Manages the menu, order queue, and user interaction.
 */
public class RestaurantSystem {

    private List<MenuItem> menuItems; // Using List interface
    private Queue<Order> orderQueue; // Using Queue interface
    private Scanner scanner;

    /**
     * Constructs the RestaurantSystem, initializing menu and queue.
     */
    public RestaurantSystem() {
        // Initialize menu using ArrayList
        menuItems = new ArrayList<>();
        menuItems.add(new MenuItem("Burger", 5.99));
        menuItems.add(new MenuItem("Pizza", 12.50));
        menuItems.add(new MenuItem("Fries", 2.99));
        menuItems.add(new MenuItem("Drink", 1.99));
        menuItems.add(new MenuItem("Salad", 7.50));

        // Initialize order queue using LinkedList (implements Queue)
        orderQueue = new LinkedList<>();

        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order System ---");
        System.out.println("1. View Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the restaurant menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menuItems.size(); i++) {
            System.out.println((i + 1) + ". " + menuItems.get(i));
        }
    }

    /**
     * Handles the process of placing a new order.
     */
    private void placeNewOrder() {
        Order currentOrder = new Order();
        boolean addingItems = true;

        System.out.println("\n--- Placing New Order ---");

        while (addingItems) {
            displayMenu();
            int itemChoice = -1;
            int quantity = -1;
            boolean validInput = false;

            // Get item number input
            while (!validInput) {
                System.out.print("Enter item number to add (or 0 to finish order): ");
                String inputLine = scanner.nextLine();
                try {
                    itemChoice = Integer.parseInt(inputLine);
                    if (itemChoice == 0) {
                        validInput = true; // User wants to finish
                    } else if (itemChoice >= 1 && itemChoice <= menuItems.size()) {
                        validInput = true; // Valid item number
                    } else {
                        System.err.println("[Error] Invalid item number. Please enter a number between 1 and " + menuItems.size() + ", or 0.");
                    }
                } catch (NumberFormatException e) {
                    System.err.println("[Error] Invalid input. Please enter a number.");
                }
            }

            if (itemChoice == 0) {
                addingItems = false; // Finish the order
                break;
            }

            // Get quantity input
            validInput = false;
            while (!validInput) {
                System.out.print("Enter quantity: ");
                String inputLine = scanner.nextLine();
                try {
                    quantity = Integer.parseInt(inputLine);
                    if (quantity > 0) {
                        validInput = true; // Valid quantity
                    } else {
                        System.err.println("[Error] Quantity must be a positive number.");
                    }
                } catch (NumberFormatException e) {
                    System.err.println("[Error] Invalid input. Please enter a number.");
                }
            }

            // Add the item to the order
            try {
                MenuItem selectedItem = menuItems.get(itemChoice - 1);
                OrderItem orderItem = new OrderItem(selectedItem, quantity);
                currentOrder.addOrderItem(orderItem);
                System.out.println("Added " + quantity + " x " + selectedItem.getName() + " to order.");

                // Ask if adding more items
                boolean askMore = true;
                while(askMore) {
                    System.out.print("Add more items? (yes/no): ");
                    String moreInput = scanner.nextLine().trim().toLowerCase();
                    if (moreInput.equals("yes")) {
                        askMore = false;
                        // addingItems remains true, loop continues
                    } else if (moreInput.equals("no")) {
                        addingItems = false; // Stop adding items to this order
                        askMore = false;
                    } else {
                        System.err.println("[Error] Invalid input. Please type 'yes' or 'no'.");
                    }
                }

            } catch (IndexOutOfBoundsException e) {
                // This should ideally not happen if itemChoice is validated correctly,
                // but included for robustness.
                System.err.println("[Error] Internal error: Could not find selected menu item.");
                addingItems = false; // Abort adding items for this order
            } catch (IllegalArgumentException e) {
                 System.err.println("[Error] Could not create order item: " + e.getMessage());
                 // Decide if this should stop adding items or just skip this one
                 // For this example, let's let the user try again for the next item
            }
        }

        // Add the completed order to the queue
        if (!currentOrder.getItems().isEmpty()) {
            orderQueue.offer(currentOrder); // Add to the end of the queue
            System.out.printf("Order #%d placed. Total: $%.2f\n", currentOrder.getOrderId(), currentOrder.getTotalPrice());
        } else {
            System.out.println("Order cancelled as no items were added.");
        }
    }

    /**
     * Handles the process of processing the next order in the queue.
     */
    private void processNextOrder() {
        System.out.println("\n--- Processing Order ---");
        Order nextOrder = orderQueue.poll(); // Get and remove the head of the queue

        if (nextOrder == null) {
            System.out.println("No pending orders in the queue.");
        } else {
            System.out.println("Processing Order #" + nextOrder.getOrderId() + ":");
            for (OrderItem item : nextOrder.getItems()) {
                System.out.println("- " + item); // Uses OrderItem's toString
            }
            System.out.printf("Total: $%.2f\n", nextOrder.getTotalPrice());
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch for unexpected errors
        try {
            while (choice != 4) {
                displayMainMenu();
                String inputLine = scanner.nextLine(); // Read input as line to handle non-numeric input gracefully

                try {
                    choice = Integer.parseInt(inputLine);

                    switch (choice) {
                        case 1:
                            displayMenu();
                            break;
                        case 2:
                            placeNewOrder();
                            break;
                        case 3:
                            processNextOrder();
                            break;
                        case 4:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("[Error] Invalid choice. Please enter a number between 1 and 4.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    System.err.println("[Error] Invalid input. Please enter a number.");
                    choice = -1; // Reset choice to prevent accidental exit if 4 was part of invalid string
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("\n[FATAL ERROR] An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to error stream
            System.err.println("System is shutting down due to error.");
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
