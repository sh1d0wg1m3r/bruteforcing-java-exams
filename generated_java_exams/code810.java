/*
 * Exam Question #810
 * Generated on: 2025-05-12 16:44:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Advanced Exam Task: Automated Job Scheduling System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Automated Job Scheduling System using Java. This system will manage a queue of jobs waiting to be processed and maintain a history of completed jobs. Users will interact with the system via a command-line interface to submit new jobs, process the next available job, view the list of pending jobs, and view the history of completed jobs.
 * 
 * The system should adhere to the following specifications:
 * 
 * 1.  **Job Representation:** Create a class `Job` to represent a task. Each `Job` must have:
 *     *   A unique integer `id`.
 *     *   A `String` `description`.
 *     *   A `String` `status` (e.g., "PENDING", "COMPLETED").
 *     *   Appropriate private fields and public getter methods. Include a `toString()` method for easy printing.
 * 
 * 2.  **Scheduler Logic:** Create a class `JobScheduler` that manages the jobs. It must contain:
 *     *   A `Queue<Job>` to hold jobs that are waiting to be processed (pending jobs). Jobs should be processed in First-In, First-Out (FIFO) order.
 *     *   A `List<Job>` to store jobs that have been successfully processed (completed jobs).
 *     *   A mechanism to generate unique job IDs.
 *     *   Public methods for the following operations:
 *         *   `submitJob(String description)`: Creates a new `Job` with a unique ID and "PENDING" status, adds it to the pending queue, and returns the ID of the submitted job.
 *         *   `processNextJob()`: Removes the next job from the pending queue (if any), changes its status to "COMPLETED", and adds it to the completed jobs list. If the queue is empty, it should indicate that no job was processed.
 *         *   `viewPendingJobs()`: Returns a `List<Job>` containing all jobs currently in the pending queue, *without* removing them from the queue. The list should reflect the order in which they would be processed.
 *         *   `viewCompletedJobs()`: Returns the `List<Job>` of completed jobs.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of the `JobScheduler` class. The interface should accept the following commands:
 *     *   `submit`: Prompts the user for a job description and submits the job.
 *     *   `process`: Processes the next job in the queue.
 *     *   `view_queue`: Displays all jobs currently in the pending queue.
 *     *   `view_history`: Displays all jobs in the completed history.
 *     *   `exit`: Terminates the program.
 * 
 * 4.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of:
 *     *   `java.util.Queue` (as the type for the pending jobs collection)
 *     *   `java.util.ArrayList` (as the concrete implementation for the completed jobs collection)
 *     *   `java.util.List` (as the return type for `viewPendingJobs` and `viewCompletedJobs`)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for handling user commands)
 *     *   `System.err` (for outputting error messages, e.g., invalid command, empty description)
 *     *   `System.out` (for all normal output, e.g., prompts, success messages, job details)
 *     *   Class-wide exception handling using `try-catch` blocks (at least around the main command loop to catch unexpected errors).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for classes/methods).
 *     *   Implement basic input validation (e.g., check if job description is empty).
 *     *   Provide clear error messages using `System.err` and informative success/status messages using `System.out`.
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user as follows (example):
 * 
 * ```
 * Job Scheduler Commands: submit, process, view_queue, view_history, exit
 * Enter command: submit
 * Enter job description: Process data file
 * Job submitted with ID: 1
 * Enter command: submit
 * Enter job description: Generate report
 * Job submitted with ID: 2
 * Enter command: view_queue
 * Pending Jobs:
 * [Job ID: 1, Description: Process data file, Status: PENDING]
 * [Job ID: 2, Description: Generate report, Status: PENDING]
 * Enter command: process
 * Processing job: [Job ID: 1, Description: Process data file, Status: PENDING]
 * Job 1 completed.
 * Enter command: view_queue
 * Pending Jobs:
 * [Job ID: 2, Description: Generate report, Status: PENDING]
 * Enter command: view_history
 * Completed Jobs:
 * [Job ID: 1, Description: Process data file, Status: COMPLETED]
 * Enter command: process
 * Processing job: [Job ID: 2, Description: Generate report, Status: PENDING]
 * Job 2 completed.
 * Enter command: process
 * No pending jobs to process.
 * Enter command: view_queue
 * Pending Jobs: (Empty)
 * Enter command: view_history
 * Completed Jobs:
 * [Job ID: 1, Description: Process data file, Status: COMPLETED]
 * [Job ID: 2, Description: Generate report, Status: COMPLETED]
 * Enter command: invalid_command
 * Error: Unknown command. Please use one of: submit, process, view_queue, view_history, exit
 * Enter command: exit
 * Exiting Job Scheduler.
 * ```
 * 
 * Your solution should be a single Java file containing the `Job` class (can be an inner class or separate, but keep it in one file for the exam), the `JobScheduler` class with the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple Automated Job Scheduling System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Job Class:** The `Job` class is a simple Plain Old Java Object (POJO) encapsulating the properties of a job: `id`, `description`, and `status`. It uses private fields and public getters, adhering to encapsulation. The `toString()` method provides a convenient way to display job information.
 * 
 * 2.  **JobScheduler Class:**
 *     *   This class acts as the core manager.
 *     *   It uses a `Queue<Job>` (`pendingJobs`) implemented by `LinkedList` to ensure jobs are processed in the order they were submitted (FIFO). The `offer()` method is used for adding jobs, and `poll()` for removing the head of the queue.
 *     *   It uses a `List<Job>` (`completedJobs`) implemented by `ArrayList` to store the history of finished jobs. `ArrayList` is suitable here for dynamic resizing and easy iteration.
 *     *   `nextJobId` is a simple counter to generate unique IDs for new jobs.
 *     *   `submitJob`: Creates a `Job` object and adds it to the `pendingJobs` queue. It includes input validation to prevent empty descriptions and throws an `IllegalArgumentException` if validation fails.
 *     *   `processNextJob`: Calls `pendingJobs.poll()` to retrieve and remove the next job. If `poll()` returns `null`, it means the queue was empty. Otherwise, it updates the job's status and adds it to `completedJobs`.
 *     *   `viewPendingJobs`: This method demonstrates how to view the contents of a `Queue` without removing elements. It iterates through the queue using an `Iterator` and adds each job to a new `ArrayList`, which is then returned as a `List`. This fulfills the requirement of returning a `List` and using `ArrayList` for its implementation while preserving the queue's state.
 *     *   `viewCompletedJobs`: Simply returns the `completedJobs` list, using the `List` interface as the return type as required.
 * 
 * 3.  **Main Method (User Interface & Control Flow):**
 *     *   The `main` method resides within the `JobScheduler` class, providing the entry point and command-line interface.
 *     *   A `Scanner` is used to read user input line by line.
 *     *   A `while(running)` loop keeps the program active until the `exit` command is entered.
 *     *   A `switch` statement is used to direct execution based on the user's command, fulfilling the `switch` requirement. Command input is trimmed and lowercased for flexibility.
 *     *   `System.out` is used for displaying prompts, success messages, and the contents of job lists.
 *     *   `System.err` is specifically used for error messages, such as an unknown command or an empty job description during submission.
 *     *   **Exception Handling:** A `try-catch(Exception e)` block wraps the main `while` loop. This provides a top-level, "class-wide" mechanism to catch any unexpected runtime exceptions that might occur during the program's execution, preventing the program from crashing abruptly. More specific `try-catch` blocks are used within the `submit` case to handle the expected `IllegalArgumentException` from the `submitJob` method, demonstrating more targeted error handling.
 *     *   A `finally` block ensures the `Scanner` resource is closed when the program exits (either normally or due to an exception).
 * 
 * 4.  **Required Components & Best Practices:**
 *     *   `Queue` is used for `pendingJobs`.
 *     *   `ArrayList` is used for `completedJobs`.
 *     *   `List` interface is used as return types for `viewPendingJobs` and `viewCompletedJobs`.
 *     *   `Scanner` is used for user input.
 *     *   `switch` statement is used for command handling.
 *     *   `System.err` is used for errors.
 *     *   `System.out` is used for normal output.
 *     *   `try-catch` is used for exception handling around the loop and specific method calls.
 *     *   Encapsulation is used in `Job` and `JobScheduler`.
 *     *   Meaningful names (`pendingJobs`, `processNextJob`, `viewPendingJobs`, etc.) are used.
 *     *   Basic Javadoc and inline comments are included.
 *     *   Input validation is performed for the job description.
 *     *   Error handling includes checking for empty queues/lists before processing/viewing and using `System.err` for invalid input/commands.
 * 
 * This solution effectively integrates all required components into a functional program, demonstrating an understanding of data structures, control flow, object-oriented principles, and error handling in Java.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // Needed to iterate Queue for view_queue

/**
 * Represents a single job in the scheduling system.
 */
class Job {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Job.
     * @param id The unique ID of the job.
     * @param description The description of the job.
     */
    public Job(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Jobs start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Job.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "[Job ID: " + id + ", Description: " + description + ", Status: " + status + "]";
    }
}

/**
 * Manages the queue of pending jobs and the list of completed jobs.
 */
public class JobScheduler {

    private Queue<Job> pendingJobs;
    private List<Job> completedJobs;
    private int nextJobId; // Counter for unique job IDs

    /**
     * Constructs a new JobScheduler.
     * Initializes the pending job queue and completed job list.
     */
    public JobScheduler() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new job to the pending queue.
     * @param description The description of the job.
     * @return The ID assigned to the new job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public int submitJob(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        Job newJob = new Job(nextJobId++, description.trim());
        pendingJobs.offer(newJob); // offer is preferred over add for capacity-constrained queues (though LinkedList isn't)
        return newJob.getId();
    }

    /**
     * Processes the next job from the pending queue.
     * @return The processed Job object, or null if the queue was empty.
     */
    public Job processNextJob() {
        Job jobToProcess = pendingJobs.poll(); // Removes and returns the head of the queue, or null if empty
        if (jobToProcess != null) {
            jobToProcess.setStatus("COMPLETED");
            completedJobs.add(jobToProcess);
            System.out.println("Processing job: " + jobToProcess.toString().replace("PENDING", "PENDING") ); // Show initial state before status change
            return jobToProcess;
        }
        return null; // Indicate no job was processed
    }

    /**
     * Returns a list of jobs currently in the pending queue without removing them.
     * The order reflects processing order.
     * @return A List containing pending jobs. Returns an empty list if queue is empty.
     */
    public List<Job> viewPendingJobs() {
        // Create a new list to hold the jobs from the queue
        List<Job> pendingList = new ArrayList<>();
        // Iterate over the queue elements without removing them
        Iterator<Job> iterator = pendingJobs.iterator();
        while (iterator.hasNext()) {
            pendingList.add(iterator.next());
        }
        return pendingList;
    }

    /**
     * Returns the list of completed jobs.
     * @return A List containing completed jobs. Returns an empty list if no jobs completed.
     */
    public List<Job> viewCompletedJobs() {
        // Return the completedJobs list directly (List interface)
        return completedJobs;
    }

    /**
     * Main method to run the Job Scheduling System command-line interface.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        JobScheduler scheduler = new JobScheduler();
        boolean running = true;

        System.out.println("Welcome to the Automated Job Scheduling System.");

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                System.out.println("\nJob Scheduler Commands: submit, process, view_queue, view_history, exit");
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "submit":
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        try {
                            int jobId = scheduler.submitJob(description);
                            System.out.println("Job submitted with ID: " + jobId);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case "process":
                        Job processedJob = scheduler.processNextJob();
                        if (processedJob != null) {
                            System.out.println("Job " + processedJob.getId() + " completed.");
                        } else {
                            System.out.println("No pending jobs to process.");
                        }
                        break;

                    case "view_queue":
                        List<Job> pending = scheduler.viewPendingJobs();
                        System.out.println("Pending Jobs:");
                        if (pending.isEmpty()) {
                            System.out.println("(Empty)");
                        } else {
                            for (Job job : pending) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case "view_history":
                        List<Job> history = scheduler.viewCompletedJobs();
                        System.out.println("Completed Jobs:");
                        if (history.isEmpty()) {
                            System.out.println("(Empty)");
                        } else {
                            for (Job job : history) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Job Scheduler.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please use one of: submit, process, view_queue, view_history, exit");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
