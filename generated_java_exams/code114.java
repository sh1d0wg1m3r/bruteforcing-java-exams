/*
 * Exam Question #114
 * Generated on: 2025-05-11 22:16:34
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Event Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Event Management System. This system needs to manage multiple events, track attendees who register for these events, and handle attendee check-ins on the day of the event. Due to limited capacity, popular events might have a waiting list for attendees who couldn't initially register.
 * 
 * **Requirements:**
 * 
 * Your program must fulfill the following functional requirements:
 * 
 * 1.  **Manage Events:** Allow adding new events with a unique name and a maximum capacity.
 * 2.  **Register Attendees:** Allow registering an attendee for a specific event using their unique ID and name.
 *     *   If the event is not full (below maximum capacity), the attendee is added to the list of registered attendees.
 *     *   If the event is full, the attendee is added to a waiting list for that event.
 * 3.  **Check-In Attendees:** Allow checking in an attendee for a specific event using their attendee ID.
 *     *   The system should verify if the attendee is registered for the event.
 *     *   Upon successful check-in, the attendee is marked as checked-in (conceptually, they are confirmed).
 *     *   If an attendee is successfully checked-in and this action frees up a spot (e.g., by conceptually moving them from 'registered' to 'checked-in' status, or simply confirming their attendance), and there are attendees on the waiting list, the first attendee from the waiting list should be automatically moved to the registered list.
 * 4.  **View Event Details:** Display the details of a specific event, including its name, capacity, the list of currently registered attendees (IDs and names), and the list of attendees on the waiting list (IDs and names).
 * 5.  **Interactive Menu:** Provide a command-line interface with a menu for the user to perform these actions.
 * 
 * **Technical Constraints:**
 * 
 * Your solution *must* utilize all of the following Java components:
 * 
 * *   `java.util.Queue`: To implement the waiting list for events (First-In, First-Out).
 * *   `java.util.ArrayList`: To store the list of registered attendees for each event.
 * *   `java.util.List` interface: Use `List` as the type declaration for variables holding collections like `ArrayList`.
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the different menu options.
 * *   `System.err`: To output error messages (e.g., event not found, invalid input, registration/check-in failures).
 * *   `System.out`: To output normal program messages (menu, prompts, successful actions, event details).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, particularly for user input (e.g., non-integer input when expecting a number) and potential logical errors (e.g., trying to operate on a non-existent event).
 * 
 * **Best Practices:**
 * 
 * *   Employ proper encapsulation (private fields, public methods).
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include comments and documentation where necessary.
 * *   Implement input validation (e.g., non-empty strings, positive numbers).
 * *   Structure your code into appropriate classes (`Attendee`, `Event`, `EventManager`).
 * 
 * **Input/Output:**
 * 
 * *   The program should present a menu of options to the user.
 * *   It should prompt the user for necessary information (event name, capacity, attendee ID/name).
 * *   Success messages and requested information should be printed to `System.out`.
 * *   Error messages (invalid input, event not found, attendee issues) must be printed to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add New Event
 * 2. Register Attendee for Event
 * 3. Check-In Attendee for Event
 * 4. View Event Details
 * 5. Exit
 * Enter your choice: 1
 * Enter event name: JavaConf 2024
 * Enter maximum capacity: 100
 * Event 'JavaConf 2024' added with capacity 100.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * Enter event name: JavaConf 2024
 * Enter attendee ID: A101
 * Enter attendee name: Alice
 * Attendee A101 (Alice) registered for JavaConf 2024.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * Enter event name: FullEvent
 * Enter attendee ID: A102
 * Enter attendee name: Bob
 * Event 'FullEvent' is full. Attendee A102 (Bob) added to waiting list.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter event name: JavaConf 2024
 * Enter attendee ID: A101
 * Attendee A101 checked in for JavaConf 2024.
 * Waiting list processed: No attendees on waiting list for JavaConf 2024.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Enter event name: JavaConf 2024
 * Event: JavaConf 2024 (Capacity: 100)
 * Registered Attendees:
 * - ID: A101, Name: Alice (Checked In)
 * Waiting List:
 * (Empty)
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Event Management System.
 * ```
 * 
 * **Grading:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper and effective use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Robust error handling and input validation.
 * *   Code structure and readability.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Event Management System following all specified requirements and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: Used in the `Event` class for `waitingList`. `LinkedList` is used as the concrete implementation, which provides the necessary `offer()` (add to end) and `poll()` (remove from front) methods required for a FIFO queue. Attendees are added to the waiting list when an event is full and processed from the head of the queue when a spot opens up after a check-in.
 * 2.  **`java.util.ArrayList`**: Used in the `Event` class for `registeredAttendees`. This provides a dynamic, resizable array to store the list of attendees who are officially registered for the event. It allows easy addition (`add()`) and iteration.
 * 3.  **`java.util.List` interface**: Used as the type declaration for `registeredAttendees` in the `Event` class and `events` in the `EventManager` class (`List<Attendee> registeredAttendees`, `List<Event> events`). This demonstrates programming to the interface, allowing flexibility to change the underlying implementation (e.g., to `LinkedList` if different performance characteristics were needed) without changing the interface-based code.
 * 4.  **`java.util.Scanner`**: An instance is created in the `EventManager` to read user input from `System.in` for menu choices, event names, capacities, attendee IDs, and names. `scanner.nextLine()` is used consistently after reading integers to consume the leftover newline character.
 * 5.  **`switch` statement**: Used in the `EventManager.processUserInput()` method to direct the program flow based on the integer choice entered by the user from the main menu.
 * 6.  **`System.err`**: Used specifically for printing error messages, such as when an event is not found, input is invalid (e.g., non-numeric capacity), or when registration/check-in rules are violated (e.g., attendee already exists, attendee not registered).
 * 7.  **`System.out`**: Used for all standard output, including displaying the menu, prompting for input, confirming successful actions (adding event, registering, checking in), and displaying event details.
 * 8.  **Class-wide exception handling (`try-catch`)**: A large `try-catch (Exception e)` block is wrapped around the core `switch` statement logic in `EventManager.processUserInput()`. This catches any unexpected runtime exceptions that might occur during processing. A specific `catch (NumberFormatException e)` is included to handle cases where the user enters non-integer input when a number is expected (like the menu choice or event capacity). Additionally, specific methods like `addEvent`, `registerAttendee`, and `checkInAttendee` have internal `try-catch` blocks or validation checks to handle specific business rule errors or exceptions thrown by constructors (`IllegalArgumentException`).
 * 
 * **Code Structure and Best Practices:**
 * 
 * *   **Encapsulation:** The `Attendee`, `Event`, and `EventManager` classes have private fields accessed and modified via public methods (getters, setters where appropriate, and business logic methods like `registerAttendee`, `checkInAttendee`).
 * *   **Meaningful Names:** Variables (`eventName`, `maxCapacity`, `registeredAttendees`, `waitingList`), methods (`addEvent`, `registerAttendee`, `checkInAttendee`, `viewEventDetails`, `processUserInput`), and classes (`Attendee`, `Event`, `EventManager`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are used for classes and methods explaining their role. Inline comments explain specific logic points.
 * *   **Input Validation:** Checks are performed for null or empty strings (names, IDs) and positive numbers (capacity) before creating objects or performing operations. Invalid input results in error messages printed to `System.err`.
 * *   **Error Handling:** Beyond the main `try-catch` for input and unexpected errors, methods like `findEvent`, `registerAttendee`, and `checkInAttendee` return specific messages or handle cases where the target event or attendee doesn't exist or rules are broken.
 * *   **Clean Code:** The logic is separated into distinct methods within appropriate classes, making the code modular and easier to understand. The main processing loop is clear, and the `switch` statement handles menu dispatch cleanly.
 * 
 * **Advanced Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Design:** The problem is broken down into logical objects (`Attendee`, `Event`, `EventManager`) interacting with each other.
 * *   **Polymorphism:** Using `List` and `Queue` interfaces allows the use of concrete implementations (`ArrayList`, `LinkedList`) while programming against the more general interface type.
 * *   **Collection Framework:** Effective use of standard Java collections (`List`, `ArrayList`, `Queue`, `LinkedList`) for managing dynamic data structures.
 * *   **State Management:** The `Event` class manages the state of its attendees (registered vs. waiting list, checked-in status).
 * *   **Business Logic Implementation:** The `registerAttendee` and `checkInAttendee` methods contain the core business rules for managing capacity and the waiting list. The waiting list promotion logic after check-in adds a layer of complexity involving queue manipulation.
 * *   **Robust User Interaction:** Handling various user inputs, including expected valid inputs, invalid format inputs (`NumberFormatException`), and logically incorrect inputs (e.g., non-existent event), and providing appropriate feedback via `System.out` and `System.err`.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating a solid understanding of core Java concepts and best practices for building interactive, stateful applications with error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration

// Class representing an attendee
class Attendee {
    private String id;
    private String name;
    private boolean checkedIn;

    public Attendee(String id, String name) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
        this.checkedIn = false;
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isCheckedIn() {
        return checkedIn;
    }

    public void setCheckedIn(boolean checkedIn) {
        this.checkedIn = checkedIn;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + (checkedIn ? " (Checked In)" : "");
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id.equals(attendee.id); // ID is unique identifier
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

// Class representing an event
class Event {
    private String name;
    private int maxCapacity;
    private List<Attendee> registeredAttendees; // Using List interface, implemented by ArrayList
    private Queue<Attendee> waitingList;       // Using Queue interface, implemented by LinkedList

    public Event(String name, int maxCapacity) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Event name cannot be null or empty.");
        }
        if (maxCapacity <= 0) {
            throw new IllegalArgumentException("Maximum capacity must be positive.");
        }
        this.name = name.trim();
        this.maxCapacity = maxCapacity;
        this.registeredAttendees = new ArrayList<>(); // ArrayList implementation
        this.waitingList = new LinkedList<>();       // LinkedList implementation for Queue
    }

    public String getName() {
        return name;
    }

    public int getMaxCapacity() {
        return maxCapacity;
    }

    public List<Attendee> getRegisteredAttendees() {
        // Return a copy to prevent external modification
        return new ArrayList<>(registeredAttendees);
    }

    public Queue<Attendee> getWaitingList() {
         // Return a copy or be careful about exposing the internal queue
         // For printing, iterating over a copy is safer.
         // For operations like poll, we need the actual queue,
         // but returning it directly breaks encapsulation.
         // Let's provide methods for specific queue operations instead.
         return new LinkedList<>(waitingList); // Return a copy for viewing
    }

    // Method to check if an attendee (by ID) exists in registered or waiting list
    private boolean isAttendeePresent(String attendeeId) {
        for (Attendee a : registeredAttendees) {
            if (a.getId().equals(attendeeId)) {
                return true;
            }
        }
        for (Attendee a : waitingList) {
            if (a.getId().equals(attendeeId)) {
                return true;
            }
        }
        return false;
    }

    // Register an attendee
    public String registerAttendee(Attendee attendee) {
        if (isAttendeePresent(attendee.getId())) {
            return "Attendee with ID " + attendee.getId() + " is already registered or on the waiting list for " + name + ".";
        }

        if (registeredAttendees.size() < maxCapacity) {
            registeredAttendees.add(attendee);
            return "Attendee " + attendee.getId() + " (" + attendee.getName() + ") registered for " + name + ".";
        } else {
            waitingList.offer(attendee); // Add to the end of the queue
            return "Event '" + name + "' is full. Attendee " + attendee.getId() + " (" + attendee.getName() + ") added to waiting list.";
        }
    }

    // Check-in an attendee
    public String checkInAttendee(String attendeeId) {
        Attendee foundAttendee = null;
        // Find attendee in registered list
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId().equals(attendeeId)) {
                foundAttendee = attendee;
                break;
            }
        }

        if (foundAttendee == null) {
            // Also check waiting list, though typically check-in is only for registered
            // For this problem, let's assume check-in is only from the registered list.
            // If found on waiting list, indicate they cannot check in yet.
             for (Attendee attendee : waitingList) {
                 if (attendee.getId().equals(attendeeId)) {
                     return "Attendee " + attendeeId + " is on the waiting list for " + name + " and cannot check in yet.";
                 }
             }
             return "Attendee with ID " + attendeeId + " not found in the registered list for " + name + ".";
        }

        if (foundAttendee.isCheckedIn()) {
             return "Attendee " + attendeeId + " is already checked in for " + name + ".";
        }

        // Mark as checked in
        foundAttendee.setCheckedIn(true);

        // Process waiting list if a spot "conceptually" opens up
        // (In this model, marking checkedIn doesn't reduce registeredAttendees.size(),
        // but we can still implement the waiting list promotion logic after a check-in
        // as per requirement 3).
        String waitingListMessage = "";
        if (!waitingList.isEmpty()) {
            // Move first person from waiting list to registered list
            Attendee promotedAttendee = waitingList.poll(); // Get and remove head of queue
            if (promotedAttendee != null) {
                 // Need to ensure they aren't somehow already in registered (shouldn't happen with logic)
                 if (!isAttendeePresent(promotedAttendee.getId())) {
                      registeredAttendees.add(promotedAttendee);
                      waitingListMessage = "\nWaiting list processed: Attendee " + promotedAttendee.getId() + " (" + promotedAttendee.getName() + ") moved from waiting list to registered.";
                 } else {
                      waitingListMessage = "\nWaiting list processed: Head of waiting list was already present in registered list (unexpected state).";
                 }
            }
        } else {
             waitingListMessage = "\nWaiting list processed: No attendees on waiting list for " + name + ".";
        }

        return "Attendee " + attendeeId + " checked in for " + name + "." + waitingListMessage;
    }

    // Find attendee by ID in registered list (used internally or for lookup)
    public Attendee findRegisteredAttendee(String attendeeId) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId().equals(attendeeId)) {
                return attendee;
            }
        }
        return null;
    }
}

// Main class managing multiple events
public class EventManager {
    private List<Event> events; // Using List interface, implemented by ArrayList
    private Scanner scanner;

    public EventManager() {
        this.events = new ArrayList<>(); // ArrayList implementation
        this.scanner = new Scanner(System.in);
    }

    // Find an event by name
    private Event findEvent(String eventName) {
        if (eventName == null || eventName.trim().isEmpty()) {
            return null; // Cannot search for empty name
        }
        for (Event event : events) {
            if (event.getName().equalsIgnoreCase(eventName.trim())) {
                return event;
            }
        }
        return null;
    }

    // Add a new event
    public void addEvent() {
        System.out.print("Enter event name: ");
        String name = scanner.nextLine();

        if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Event name cannot be empty.");
             return;
        }

        if (findEvent(name) != null) {
            System.err.println("Error: Event '" + name + "' already exists.");
            return;
        }

        int capacity = -1;
        System.out.print("Enter maximum capacity: ");
        try {
            capacity = Integer.parseInt(scanner.nextLine());
            Event newEvent = new Event(name, capacity);
            events.add(newEvent);
            System.out.println("Event '" + newEvent.getName() + "' added with capacity " + newEvent.getMaxCapacity() + ".");
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid capacity entered. Please enter a positive integer.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating event: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while adding the event: " + e.getMessage());
        }
    }

    // Register attendee for an event
    public void registerAttendee() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine();

        Event event = findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        System.out.print("Enter attendee ID: ");
        String attendeeId = scanner.nextLine();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        try {
            Attendee attendee = new Attendee(attendeeId, attendeeName);
            String result = event.registerAttendee(attendee);
            System.out.println(result);
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating attendee: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred during registration: " + e.getMessage());
        }
    }

    // Check-in attendee for an event
    public void checkInAttendee() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine();

        Event event = findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        System.out.print("Enter attendee ID: ");
        String attendeeId = scanner.nextLine();

        try {
            String result = event.checkInAttendee(attendeeId);
            System.out.println(result);
        } catch (Exception e) {
            System.err.println("An unexpected error occurred during check-in: " + e.getMessage());
        }
    }

    // View details of an event
    public void viewEventDetails() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine();

        Event event = findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        System.out.println("\n--- Event Details ---");
        System.out.println("Event: " + event.getName() + " (Capacity: " + event.getMaxCapacity() + ")");

        System.out.println("Registered Attendees:");
        List<Attendee> registered = event.getRegisteredAttendees(); // Get a copy
        if (registered.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (Attendee attendee : registered) {
                System.out.println("- " + attendee); // Attendee's toString() handles checkedIn status
            }
        }

        System.out.println("Waiting List:");
        Queue<Attendee> waiting = event.getWaitingList(); // Get a copy
         if (waiting.isEmpty()) {
             System.out.println("(Empty)");
         } else {
             // Iterate over the copy of the queue
             for (Attendee attendee : waiting) {
                 System.out.println("- " + attendee);
             }
         }
         System.out.println("---------------------\n");
    }

    // Display the main menu
    private void displayMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Add New Event");
        System.out.println("2. Register Attendee for Event");
        System.out.println("3. Check-In Attendee for Event");
        System.out.println("4. View Event Details");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Process user input loop
    public void processUserInput() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Read the integer choice
                choice = Integer.parseInt(scanner.nextLine());

                // Use switch for flow control based on choice
                switch (choice) {
                    case 1:
                        addEvent();
                        break;
                    case 2:
                        registerAttendee();
                        break;
                    case 3:
                        checkInAttendee();
                        break;
                    case 4:
                        viewEventDetails();
                        break;
                    case 5:
                        System.out.println("Exiting Event Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
        }
        scanner.close(); // Close the scanner when done
    }

    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.processUserInput();
    }
}
