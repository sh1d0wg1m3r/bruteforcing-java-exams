/*
 * Exam Question #254
 * Generated on: 2025-05-11 22:39:48
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Delivery Route Management Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulator for a small package delivery hub. The hub receives packages, sorts them into an incoming queue, assigns them to a single delivery route, and then processes the route for delivery. Your program should allow a user to interact with this system via a console interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates the package delivery hub with the following features:
 * 
 * 1.  **Package Representation:** Create a `Package` class with private fields for `packageId` (String), `destinationAddress` (String), and `status` (String, e.g., "Waiting", "Assigned", "Delivered"). Include a constructor and public getter methods.
 * 2.  **Hub Management:** Implement a main class (e.g., `DeliveryHub`) that manages the package flow. This class should contain:
 *     *   A `Queue<Package>` to hold packages that have arrived but are not yet assigned to a route.
 *     *   A `List<Package>` (specifically using `ArrayList` implementation but declared as `List`) to hold packages currently assigned to the active delivery route.
 * 3.  **User Interface:** Provide a console menu using `Scanner` for user interaction. The menu should offer the following options:
 *     *   `1. Add Incoming Package`: Prompt the user for package ID and destination address. Create a `Package` object with status "Waiting" and add it to the incoming queue.
 *     *   `2. Assign Next Package to Route`: Take the package at the head of the incoming queue, change its status to "Assigned", and add it to the delivery route list. Handle the case where the queue is empty.
 *     *   `3. View Incoming Queue`: Display details (ID, Address, Status) of all packages currently in the incoming queue.
 *     *   `4. View Delivery Route`: Display details (ID, Address, Status) of all packages currently in the delivery route list.
 *     *   `5. Process Delivery Route`: Simulate delivering packages from the route. Iterate through the route list, change each package's status to "Delivered", and remove it from the route list. Handle the case where the route is empty.
 *     *   `6. Exit`: Terminate the program.
 * 4.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 5.  **Input Handling:** Use `Scanner` to read user input. Validate user input for the menu choice.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages when an operation cannot be performed (e.g., trying to assign a package when the queue is empty, trying to process a route when the route is empty, invalid menu choice).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main program loop to catch unexpected runtime errors and provide a graceful exit message.
 * 7.  **Output:** Use `System.out` for displaying the menu, prompts, and package details.
 * 8.  **Best Practices:** Adhere to best practices including:
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Clean code structure.
 * 
 * **Expected Output Structure:**
 * 
 * The program should continuously display the menu and process user input until the user chooses to exit. Output for viewing queues/routes should list packages clearly. Error messages should go to `System.err`.
 * 
 * ```
 * --- Delivery Hub Menu ---
 * 1. Add Incoming Package
 * 2. Assign Next Package to Route
 * 3. View Incoming Queue
 * 4. View Delivery Route
 * 5. Process Delivery Route
 * 6. Exit
 * Enter your choice: [user input]
 * 
 * // Example interactions:
 * 
 * Enter package ID: P101
 * Enter destination address: 123 Main St
 * Package P101 added to incoming queue.
 * 
 * Assigning package from queue...
 * Package P101 assigned to route.
 * 
 * --- Incoming Queue ---
 * (Empty)
 * 
 * --- Delivery Route ---
 * Package ID: P101, Address: 123 Main St, Status: Assigned
 * 
 * Processing delivery route...
 * Delivering package P101...
 * Route processed.
 * 
 * --- Delivery Route ---
 * (Empty)
 * 
 * // Error example:
 * Enter your choice: 2
 * Error: Incoming queue is empty. Cannot assign package to route. [Printed to System.err]
 * 
 * Enter your choice: 99
 * Error: Invalid menu choice. Please enter a number between 1 and 6. [Printed to System.err]
 * 
 * // Unexpected error example:
 * [...some operation causes a RuntimeException...]
 * An unexpected error occurred: [Exception details] [Printed to System.err]
 * Program terminated.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Assessment Criteria:**
 * 
 * *   Correct implementation of all required features.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for exception handling.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability, comments, and meaningful names.
 * *   Correct handling of edge cases (empty collections).
 *
 * EXPLANATION:
 * This solution implements the `DeliveryHub` simulator as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   Represents a single package with `packageId`, `destinationAddress`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A constructor initializes the package, setting the initial status to "Waiting".
 *     *   A `setStatus` method allows controlled modification of the status.
 *     *   `toString()` provides a convenient way to print package details.
 * 
 * 2.  **`DeliveryHub` Class:**
 *     *   Contains the main logic and the collection objects.
 *     *   `incomingQueue`: Declared as `Queue<Package>` and instantiated as `LinkedList`. This fulfills the `Queue` requirement. `LinkedList` is a common implementation for `Queue` due to efficient `offer` and `poll` operations at the ends. It holds packages waiting to be assigned.
 *     *   `deliveryRoute`: Declared as `List<Package>` and instantiated as `ArrayList`. This fulfills both the `List` interface and `ArrayList` implementation requirements. It holds packages currently on the delivery route.
 *     *   `scanner`: An instance of `Scanner` is used for reading user input from `System.in`.
 *     *   **Encapsulation:** The collections (`incomingQueue`, `deliveryRoute`) and the `scanner` are private fields, accessed and modified only through the class's methods.
 * 
 * 3.  **User Interface and Control Flow (`startSimulation`, `printMenu`, `switch`):**
 *     *   The `startSimulation` method runs the main loop.
 *     *   `printMenu` displays the available options.
 *     *   A `while` loop keeps the program running until the user chooses to exit (option 6).
 *     *   A `switch` statement inside the loop processes the `choice` variable, directing execution to the appropriate method based on the user's input. This fulfills the `switch` requirement.
 *     *   `System.out.println` is used for displaying the menu and general information, fulfilling the `System.out` requirement.
 * 
 * 4.  **Input Handling (`Scanner`, `InputMismatchException`):**
 *     *   `scanner.nextInt()` reads the integer menu choice.
 *     *   `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   A `try-catch (InputMismatchException e)` block is specifically used within the loop to handle cases where the user enters non-integer input for the menu choice, providing a specific error message and preventing the program from crashing.
 * 
 * 5.  **Error Handling (`System.err`, `try-catch`):**
 *     *   `System.err.println` is used for printing error messages when operations fail due to empty collections (e.g., trying to poll from an empty queue, trying to process an empty route) or invalid menu input. This fulfills the `System.err` requirement.
 *     *   A broader `try-catch (Exception e)` block wraps the *entire* `while` loop in `startSimulation`. This provides class-wide exception handling, catching any unexpected runtime errors that might occur during program execution (e.g., null pointer exceptions, array index out of bounds, etc.) and printing an error message and stack trace to `System.err` before the program terminates gracefully via the `finally` block. This fulfills the class-wide `try-catch` requirement.
 * 
 * 6.  **Core Logic Methods (`addIncomingPackage`, `assignNextPackageToRoute`, `viewIncomingQueue`, `viewDeliveryRoute`, `processDeliveryRoute`):**
 *     *   `addIncomingPackage`: Reads input, creates a `Package` object, and adds it to the `incomingQueue` using `offer()`. Includes basic validation for empty input strings.
 *     *   `assignNextPackageToRoute`: Uses `incomingQueue.poll()` to retrieve and remove the head of the queue. If a package is returned (i.e., queue was not empty), its status is updated, and it's added to the `deliveryRoute` list using `add()`. Handles the empty queue case with an error message to `System.err`.
 *     *   `viewIncomingQueue` and `viewDeliveryRoute`: Iterate through the respective collections and print the `toString()` representation of each `Package`. They check if the collection is empty and print a message if so. Iterating directly over the `Queue` or `List` using a for-each loop is safe here as there are no concurrent modifications within these methods.
 *     *   `processDeliveryRoute`: Iterates through the `deliveryRoute`, updates the status of each package to "Delivered", and then clears the list. A temporary list is used to demonstrate how you might handle packages *after* processing if needed, and `deliveryRoute.clear()` efficiently removes all elements. Handles the empty route case with an error message to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Meaningful names are used for classes, methods, and variables (`incomingQueue`, `deliveryRoute`, `addIncomingPackage`, `packageId`, `destinationAddress`).
 *     *   Comments and Javadoc (`/** ... */`) explain the purpose of classes and methods.
 *     *   Input validation is included for package details and menu choices.
 *     *   Error handling is specific (InputMismatchException) and general (catch all Exception).
 *     *   The code is structured logically into methods corresponding to menu options.
 *     *   Coding to the `List` interface for `deliveryRoute` is demonstrated, although the specific implementation `ArrayList` is used.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simplified, simulation, demonstrating understanding of data structures, control flow, input/output, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Import for scanner input validation

/**
 * Represents a package in the delivery system.
 */
class Package {
    private String packageId;
    private String destinationAddress;
    private String status; // e.g., "Waiting", "Assigned", "Delivered"

    /**
     * Constructs a new Package object.
     *
     * @param packageId The unique identifier for the package.
     * @param destinationAddress The delivery address for the package.
     */
    public Package(String packageId, String destinationAddress) {
        this.packageId = packageId;
        this.destinationAddress = destinationAddress;
        this.status = "Waiting"; // Initial status
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (for status updates) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the package.
     *
     * @return A formatted string describing the package.
     */
    @Override
    public String toString() {
        return "Package ID: " + packageId + ", Address: " + destinationAddress + ", Status: " + status;
    }
}

/**
 * Simulates a package delivery hub managing incoming packages and a delivery route.
 */
public class DeliveryHub {

    // Use LinkedList for Queue as it provides efficient additions/removals from ends
    private Queue<Package> incomingQueue;
    // Use ArrayList for List as it provides efficient access by index (though not strictly needed here,
    // it fulfills the ArrayList requirement while using the List interface)
    private List<Package> deliveryRoute;
    private Scanner scanner;

    /**
     * Constructs a new DeliveryHub.
     */
    public DeliveryHub() {
        incomingQueue = new LinkedList<>(); // LinkedList implements Queue
        deliveryRoute = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Starts the delivery hub simulation menu loop.
     */
    public void startSimulation() {
        int choice = -1;

        // Class-wide exception handling around the main loop
        try {
            while (choice != 6) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addIncomingPackage();
                            break;
                        case 2:
                            assignNextPackageToRoute();
                            break;
                        case 3:
                            viewIncomingQueue();
                            break;
                        case 4:
                            viewDeliveryRoute();
                            break;
                        case 5:
                            processDeliveryRoute();
                            break;
                        case 6:
                            System.out.println("Exiting Delivery Hub Simulator. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 6.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to prevent accidental exit if 6 was entered before mismatch
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Delivery Hub Menu ---");
        System.out.println("1. Add Incoming Package");
        System.out.println("2. Assign Next Package to Route");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Delivery Route");
        System.out.println("5. Process Delivery Route");
        System.out.println("6. Exit");
    }

    /**
     * Prompts the user for package details and adds a new package to the incoming queue.
     */
    private void addIncomingPackage() {
        System.out.print("Enter package ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter destination address: ");
        String address = scanner.nextLine();

        // Basic input validation
        if (id == null || id.trim().isEmpty() || address == null || address.trim().isEmpty()) {
             System.err.println("Error: Package ID and destination address cannot be empty.");
             return;
        }

        Package newPackage = new Package(id.trim(), address.trim());
        incomingQueue.offer(newPackage); // offer is generally preferred over add for queues
        System.out.println("Package " + id.trim() + " added to incoming queue.");
    }

    /**
     * Takes the next package from the incoming queue and assigns it to the delivery route.
     */
    private void assignNextPackageToRoute() {
        System.out.println("Assigning package from queue...");
        Package packageToAssign = incomingQueue.poll(); // retrieve and remove the head

        if (packageToAssign != null) {
            packageToAssign.setStatus("Assigned");
            deliveryRoute.add(packageToAssign);
            System.out.println("Package " + packageToAssign.getPackageId() + " assigned to route.");
        } else {
            System.err.println("Error: Incoming queue is empty. Cannot assign package to route.");
        }
    }

    /**
     * Displays the details of all packages currently in the incoming queue.
     */
    private void viewIncomingQueue() {
        System.out.println("--- Incoming Queue ---");
        if (incomingQueue.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate without removing elements. Creating a temporary list or using iterator is safer
            // than some direct stream operations if queue is concurrently modified (not the case here, but good practice)
            // Or simply iterate:
            for (Package pkg : incomingQueue) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Displays the details of all packages currently in the delivery route list.
     */
    private void viewDeliveryRoute() {
        System.out.println("--- Delivery Route ---");
        if (deliveryRoute.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (Package pkg : deliveryRoute) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Simulates processing (delivering) packages from the delivery route.
     */
    private void processDeliveryRoute() {
        System.out.println("Processing delivery route...");
        if (deliveryRoute.isEmpty()) {
            System.err.println("Error: Delivery route is empty. Nothing to process.");
            return;
        }

        // Create a temporary list to hold packages as they are processed
        // We cannot modify the list while iterating over it directly
        List<Package> processedPackages = new ArrayList<>(deliveryRoute.size());

        // Iterate and process packages
        for (Package pkg : deliveryRoute) {
            pkg.setStatus("Delivered");
            System.out.println("Delivering package " + pkg.getPackageId() + "...");
            processedPackages.add(pkg); // Add to temp list for later removal
        }

        // Clear the route after processing
        deliveryRoute.clear();
        System.out.println("Route processed. " + processedPackages.size() + " packages delivered.");
    }

    /**
     * Main method to start the DeliveryHub simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliveryHub hub = new DeliveryHub();
        hub.startSimulation();
    }
}
