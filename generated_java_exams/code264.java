/*
 * Exam Question #264
 * Generated on: 2025-05-11 22:46:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Task Management System with Queue, List, and Exception Handling**
 * 
 * You are tasked with developing a simple command-line based Task Management System for a small project team. The system should allow users to add new tasks, process the next task waiting in a queue, and view lists of pending and completed tasks.
 * 
 * Your implementation must adhere to the following specific Java requirements and best practices:
 * 
 * 1.  **Task Representation:**
 *     *   Create a class `Task` with private fields for `id` (int, unique), `description` (String), `priority` (using an enum `Priority`: HIGH, MEDIUM, LOW), and `status` (using an enum `Status`: PENDING, PROCESSING, COMPLETED).
 *     *   Implement a constructor, public getters for all fields, and a public setter for `status` (to be used by the management system).
 *     *   Override the `toString()` method to provide a clear representation of a task.
 *     *   Ensure proper encapsulation.
 * 
 * 2.  **Task Management Logic:**
 *     *   Create a class `TaskManagementSystem` to manage tasks.
 *     *   Use a `java.util.Queue<Task>` (specifically, instantiate a `LinkedList`) to store tasks that are currently pending processing. Tasks should be processed in a FIFO (First-In, First-Out) manner from this queue.
 *     *   Use a `java.util.List<Task>` (specifically, instantiate an `ArrayList`) to store tasks that have been completed. Declare the field using the `List` interface type.
 *     *   Maintain an internal counter for assigning unique task IDs, starting from 1.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task` with the next available ID, sets its status to `PENDING`, and adds it to the pending task queue. Print a confirmation message to `System.out`.
 *         *   `processNextTask()`: Retrieves the task at the head of the pending queue, updates its status to `PROCESSING`, then immediately to `COMPLETED` (simulating instant processing), and moves it from the queue to the completed tasks list. If the pending queue is empty, print an error message to `System.err`. Print informative messages to `System.out` during the process.
 *         *   `listPendingTasks()`: Prints details of all tasks currently in the pending queue to `System.out`. If the queue is empty, print a message indicating so to `System.out`.
 *         *   `listCompletedTasks()`: Prints details of all tasks in the completed tasks list to `System.out`. If the list is empty, print a message indicating so to `System.out`.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   In the `main` method, create a command-line interface using `java.util.Scanner` to interact with the `TaskManagementSystem`.
 *     *   Display a menu with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  List Pending Tasks
 *         4.  List Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's integer menu choice.
 * 
 * 4.  **Exception Handling and Error Reporting:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main loop that processes user commands. This should handle potential `InputMismatchException` if the user enters non-integer input for the menu choice, and a general `Exception` for any other unexpected issues.
 *     *   When adding a task, validate the priority input string (e.g., "HIGH", "MEDIUM", "LOW" case-insensitive). If the input is invalid, catch the resulting exception (e.g., `IllegalArgumentException` from `valueOf()`) and print an error message to `System.err` without adding the task.
 *     *   Use `System.err` exclusively for error messages.
 *     *   Use `System.out` for all normal output, including the menu, prompts, confirmations, and task listings.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful names for classes, methods, and variables.
 *     *   Include comments or Javadoc where appropriate.
 *     *   Ensure clean code structure.
 * 
 * Your solution should be provided as a single `.java` file. You may use static nested classes for `Task`, `Priority`, `Status`, and `TaskManagementSystem` within the main class containing the `main` method.
 * 
 * **Expected Interaction and Output Examples:**
 * 
 * ```
 * --- Task Management System ---
 * 
 * Choose an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * INFO: Added Task [ID=1, Desc='Implement feature X', Priority=HIGH, Status=PENDING]
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter priority (HIGH, MEDIUM, LOW): low
 * INFO: Added Task [ID=2, Desc='Write documentation', Priority=LOW, Status=PENDING]
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Desc='Implement feature X', Priority=HIGH, Status=PENDING]
 * Task [ID=2, Desc='Write documentation', Priority=LOW, Status=PENDING]
 * ---------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * INFO: Starting processing for Task [ID=1, Desc='Implement feature X', Priority=HIGH, Status=PENDING]
 * INFO: Completed Task [ID=1, Desc='Implement feature X', Priority=HIGH, Status=COMPLETED]
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task [ID=2, Desc='Write documentation', Priority=LOW, Status=PENDING]
 * ---------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task [ID=1, Desc='Implement feature X', Priority=HIGH, Status=COMPLETED]
 * -----------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * INFO: Starting processing for Task [ID=2, Desc='Write documentation', Priority=LOW, Status=PENDING]
 * INFO: Completed Task [ID=2, Desc='Write documentation', Priority=LOW, Status=COMPLETED]
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * ERROR: No tasks are pending for processing.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 1
 * Enter task description: Refactor code
 * Enter priority (HIGH, MEDIUM, LOW): URGENT
 * ERROR: Invalid priority entered. Please use HIGH, MEDIUM, or LOW.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: abc
 * ERROR: Invalid input. Please enter a number.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 6
 * ERROR: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Representation:** The `Task` class encapsulates task data (`id`, `description`, `priority`, `status`) using private fields and provides public getters. A setter is provided only for the `status` as it's managed by the `TaskManagementSystem`. Enums `Priority` and `Status` provide type-safe representations for these properties. The `toString()` method facilitates printing task details.
 * 
 * 2.  **Task Management Logic:** The `TaskManagementSystem` class holds the core logic.
 *     *   `pendingTasks`: Declared as `Queue<Task>` and instantiated as `LinkedList`. This fulfills the requirement to use `Queue` and `LinkedList`. `LinkedList` implements the `Queue` interface, providing FIFO behavior suitable for processing tasks in the order they were added. The `offer()` method is used for adding, and `poll()` for retrieving and removing the head element.
 *     *   `completedTasks`: Declared as `List<Task>` and instantiated as `ArrayList`. This fulfills the requirement to use the `List` interface and `ArrayList`. It's used to store completed tasks for review.
 *     *   `nextTaskId`: A simple integer counter ensures unique IDs are assigned to new tasks.
 *     *   Methods like `addTask`, `processNextTask`, `listPendingTasks`, and `listCompletedTasks` implement the system's functionality, interacting with the `pendingTasks` queue and `completedTasks` list. `processNextTask` specifically checks if the queue is empty before attempting to poll.
 * 
 * 3.  **User Interface and Control Flow:** The `main` method in `TaskManagementExam` creates a `Scanner` for reading user input from the console and an instance of `TaskManagementSystem`. A `while` loop keeps the program running until the user chooses to exit. Inside the loop, a menu is printed, the user's choice is read, and a `switch` statement directs the program flow to the appropriate method in the `TaskManagementSystem` or handles the exit command. This demonstrates the use of `Scanner` and a `switch` statement.
 * 
 * 4.  **Exception Handling and Error Reporting:**
 *     *   **Class-wide Try-Catch:** The main `while` loop containing the user interaction logic is wrapped in a `try-catch` block. This block specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when an integer (the menu choice) is expected. It also includes a general `catch (Exception e)` block to handle any other unexpected runtime errors that might occur within the loop, fulfilling the requirement for class-wide exception handling. Using `scanner.next()` inside the `InputMismatchException` catch block is crucial to consume the invalid input and prevent an infinite loop.
 *     *   **Priority Input Validation:** When adding a task (case 1 in the switch), an inner `try-catch` block is used around `Priority.valueOf(priorityStr)`. If the user enters a string that does not match any enum constant name (case-insensitive conversion is handled before `valueOf`), `valueOf` throws an `IllegalArgumentException`. This specific `catch` block handles that validation error.
 *     *   **System.err and System.out:** As required, `System.err.println()` is used exclusively for printing error messages (invalid choice, invalid priority, empty queue error), while `System.out.println()` is used for all normal messages, prompts, and task listings.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names are used (e.g., `pendingTasks`, `processNextTask`, `listCompletedTasks`).
 *     *   Comments and Javadoc explain the purpose of classes, methods, and key logic sections.
 *     *   The code is structured logically with separate concerns handled by the `Task` and `TaskManagementSystem` classes, organized as static nested classes within the main class for exam simplicity.
 *     *   Basic input validation is performed for menu choices and task priority.
 *     *   The `Scanner` is closed in a `finally` block to ensure resource cleanup.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, menu-driven application structure, demonstrating key advanced Java concepts and best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Main class containing the Task Management System solution
public class TaskManagementExam {

    // Enum for Task Priority
    private enum Priority {
        HIGH, MEDIUM, LOW
    }

    // Enum for Task Status
    private enum Status {
        PENDING, PROCESSING, COMPLETED
    }

    // Class representing a Task (static nested class)
    private static class Task {
        private int id;
        private String description;
        private Priority priority;
        private Status status;

        /**
         * Constructs a new Task.
         * @param id The unique task ID.
         * @param description The task description.
         * @param priority The task priority.
         */
        public Task(int id, String description, Priority priority) {
            this.id = id;
            this.description = description;
            this.priority = priority;
            this.status = Status.PENDING; // New tasks are pending by default
        }

        // --- Getters ---
        public int getId() {
            return id;
        }

        public String getDescription() {
            return description;
        }

        public Priority getPriority() {
            return priority;
        }

        public Status getStatus() {
            return status;
        }

        // --- Setter ---
        // Used by the management system to update task status
        public void setStatus(Status status) {
            this.status = status;
        }

        /**
         * Provides a string representation of the Task.
         * @return Formatted string of task details.
         */
        @Override
        public String toString() {
            return String.format("Task [ID=%d, Desc='%s', Priority=%s, Status=%s]",
                                 id, description, priority, status);
        }
    }

    // Class managing the tasks (static nested class)
    private static class TaskManagementSystem {
        // Queue for tasks waiting to be processed (FIFO order)
        private Queue<Task> pendingTasks;
        // List to store completed tasks
        private List<Task> completedTasks;
        // Counter for assigning unique task IDs
        private int nextTaskId;

        /**
         * Constructs a new TaskManagementSystem.
         * Initializes the pending tasks queue and completed tasks list.
         */
        public TaskManagementSystem() {
            // Requirement: Use LinkedList as a Queue implementation
            this.pendingTasks = new LinkedList<>();
            // Requirement: Use ArrayList as a List implementation
            this.completedTasks = new ArrayList<>();
            this.nextTaskId = 1; // Start task IDs from 1
        }

        /**
         * Adds a new task to the pending queue.
         * Assigns a unique ID and sets initial status to PENDING.
         * @param description The task description.
         * @param priority The task priority.
         */
        public void addTask(String description, Priority priority) {
            Task newTask = new Task(nextTaskId++, description, priority);
            // offer() is generally preferred over add() for queues as it handles capacity constraints (though LinkedList is unbounded)
            pendingTasks.offer(newTask);
            System.out.println("INFO: Added " + newTask); // Requirement: Use System.out
        }

        /**
         * Processes the next task in the pending queue (FIFO).
         * Moves the task from pending to completed list after processing.
         * Handles the case where the pending queue is empty.
         */
        public void processNextTask() {
            if (pendingTasks.isEmpty()) {
                // Requirement: Use System.err for error messages
                System.err.println("ERROR: No tasks are pending for processing.");
                return;
            }

            // poll() retrieves and removes the head of this queue
            Task taskToProcess = pendingTasks.poll();
            System.out.println("INFO: Starting processing for " + taskToProcess); // Requirement: Use System.out

            // Simulate processing - update status
            taskToProcess.setStatus(Status.PROCESSING);
            // In a real system, there might be a delay or complex logic here.
            // For this simulation, we transition immediately to COMPLETED.

            taskToProcess.setStatus(Status.COMPLETED);
            completedTasks.add(taskToProcess); // Add to the completed list (Requirement: Use List/ArrayList)
            System.out.println("INFO: Completed " + taskToProcess); // Requirement: Use System.out
        }

        /**
         * Lists all tasks currently in the pending queue.
         * Prints to System.out.
         */
        public void listPendingTasks() {
            System.out.println("\n--- Pending Tasks ---"); // Requirement: Use System.out
            if (pendingTasks.isEmpty()) {
                System.out.println("No tasks are pending."); // Requirement: Use System.out
            } else {
                // Iterate over the queue elements without removing them
                pendingTasks.forEach(System.out::println); // Requirement: Use System.out
            }
            System.out.println("---------------------\n"); // Requirement: Use System.out
        }

        /**
         * Lists all tasks in the completed tasks list.
         * Prints to System.out.
         */
        public void listCompletedTasks() {
            System.out.println("\n--- Completed Tasks ---"); // Requirement: Use System.out
            if (completedTasks.isEmpty()) {
                System.out.println("No tasks have been completed yet."); // Requirement: Use System.out
            } else {
                // Iterate over the list elements
                completedTasks.forEach(System.out::println); // Requirement: Use System.out
            }
            System.out.println("-----------------------\n"); // Requirement: Use System.out
        }
    }

    // Main method - application entry point
    public static void main(String[] args) {
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        TaskManagementSystem system = new TaskManagementSystem();
        boolean running = true;

        System.out.println("--- Task Management System ---"); // Requirement: Use System.out

        // Requirement: Class-wide exception handling with try-catch blocks
        // Wrap the main operational loop in a try-catch
        try {
            while (running) {
                printMenu(); // Print the menu options

                int choice = -1; // Default invalid choice

                // Inner try-catch specifically for reading the integer choice
                try {
                    System.out.print("Enter your choice: "); // Requirement: Use System.out
                    choice = scanner.nextInt(); // Read integer input
                    scanner.nextLine(); // Consume the newline character left after nextInt()

                    // Requirement: Use Switch statement for flow control
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task description: "); // Requirement: Use System.out
                            String description = scanner.nextLine();
                            System.out.print("Enter priority (HIGH, MEDIUM, LOW): "); // Requirement: Use System.out
                            String priorityStr = scanner.nextLine().trim().toUpperCase();

                            // Input validation and specific exception handling for priority
                            try {
                                Priority priority = Priority.valueOf(priorityStr); // Convert string to enum
                                system.addTask(description, priority);
                            } catch (IllegalArgumentException e) {
                                // Handle invalid priority string input
                                System.err.println("ERROR: Invalid priority entered. Please use HIGH, MEDIUM, or LOW."); // Requirement: Use System.err
                            }
                            break;

                        case 2: // Process Next Task
                            system.processNextTask();
                            break;

                        case 3: // List Pending Tasks
                            system.listPendingTasks();
                            break;

                        case 4: // List Completed Tasks
                            system.listCompletedTasks();
                            break;

                        case 5: // Exit
                            System.out.println("Exiting Task Management System. Goodbye!"); // Requirement: Use System.out
                            running = false; // Set flag to exit loop
                            break;

                        default: // Handle choices outside 1-5
                            System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 5."); // Requirement: Use System.err
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Requirement: Handle non-integer input for the menu choice
                    System.err.println("ERROR: Invalid input. Please enter a number."); // Requirement: Use System.err
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                }
                // Note: Other potential exceptions within the switch block (like NullPointerException
                // if methods weren't carefully written) would be caught by the outer catch block.

            } // End while loop
        } catch (Exception e) {
            // Requirement: Catch any other unexpected exceptions in the main loop
            System.err.println("An unexpected system error occurred: " + e.getMessage()); // Requirement: Use System.err
            // e.printStackTrace(); // Optional: uncomment for detailed debugging
        } finally {
             // Ensure scanner is closed even if an exception occurs
             if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed."); // Requirement: Use System.out
             }
        }
    }

    /**
     * Prints the main menu options to System.out.
     * Requirement: Use System.out.
     */
    private static void printMenu() {
        System.out.println("\nChoose an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
    }
}
