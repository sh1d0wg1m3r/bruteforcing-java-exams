/*
 * Exam Question #222
 * Generated on: 2025-05-11 22:34:39
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Task Scheduler Simulation
 * 
 * **Objective:** Design and implement a simple command-line Task Scheduler system that manages a queue of pending tasks and a history of processed tasks. This task requires you to demonstrate proficiency in using various core Java data structures, control flow mechanisms, and exception handling techniques.
 * 
 * **Scenario:** You are building a simplified backend system for managing computational tasks. Tasks arrive and are placed in a queue. A separate process picks tasks from the queue, attempts to execute them (simulated), and records the outcome (success or failure) in a history log.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following properties:
 *     *   `name` (String): A descriptive name for the task.
 *     *   `type` (int): Represents the task type, influencing its processing outcome (e.g., 1 for high reliability, 2 for moderate, 3 for low).
 *     *   `success` (boolean): Indicates whether the task processing was successful (initialized to `false`).
 *     *   Implement appropriate encapsulation (private fields, public getters).
 *     *   Include a `toString()` method for easy printing.
 * 
 * 2.  **Task Scheduler Logic:** Create a `TaskScheduler` class that manages the tasks.
 *     *   It must have a `Queue` to hold tasks waiting to be processed (pending tasks).
 *     *   It must have a `List` (specifically using an `ArrayList` implementation) to store tasks *after* they have been processed, regardless of success or failure.
 *     *   Implement the following methods:
 *         *   `addTask(String name, int type)`: Adds a new `Task` to the pending queue. Include validation to ensure `type` is within a valid range (e.g., 1 to 3). Use `System.err` for invalid input messages.
 *         *   `processNextTask()`: Removes the task at the head of the pending queue. Simulate processing based on the task `type`:
 *             *   Type 1: Always succeeds. Print a success message to `System.out`.
 *             *   Type 2: Succeeds with a 70% probability. Print success to `System.out` or failure to `System.err` based on the outcome.
 *             *   Type 3: Always fails. Print a failure message to `System.err`.
 *             *   If the pending queue is empty, print a message indicating no tasks are pending.
 *             *   After processing (success or failure), add the task object to the processed tasks list.
 *         *   `viewPendingTasks()`: Prints the details of all tasks currently in the pending queue. If the queue is empty, print a message.
 *         *   `viewProcessedTasks()`: Prints the details (including success status) of all tasks in the processed tasks list. If the list is empty, print a message.
 *         *   `run()`: This method should contain the main application loop. It should:
 *             *   Display a menu of options (Add Task, Process Task, View Pending, View Processed, Exit).
 *             *   Use `Scanner` to read user input (menu choice and task details).
 *             *   Use a `switch` statement to handle the different menu options.
 *             *   Implement input validation for the menu choice (handling non-integer input) and task type. Use `System.err` for invalid input.
 *             *   Wrap the main command processing loop (the `while` loop handling menu choices) in a `try-catch` block to demonstrate class-wide exception handling for unexpected errors. Print a generic error message to `System.err` in the catch block.
 *             *   Ensure the `Scanner` is closed properly upon exiting.
 * 
 * 3.  **Component Usage:** You *must* use all the following components at least once in your solution:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as the declared type for the processed tasks list)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   Class-wide `try-catch` block
 * 
 * 4.  **Best Practices:** Adhere to best practices including:
 *     *   Proper encapsulation.
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc is encouraged).
 *     *   Clear and informative output messages.
 *     *   Robust error handling for expected inputs (validation) and unexpected issues (exceptions).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and respond to user commands. Output should be clear, indicating actions taken, task details, and processing outcomes. Error messages for invalid input or processing failures should go to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter choice: 1
 * Enter task name: Backup Database
 * Enter task type (1-3): 1
 * Task 'Backup Database' (Type 1) added to pending queue.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 1
 * Enter task name: Generate Report
 * Enter task type (1-3): 2
 * Task 'Generate Report' (Type 2) added to pending queue.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 2
 * Processing next task...
 * Task 'Backup Database' (Type 1) processed successfully.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 2
 * Processing next task...
 * Task 'Generate Report' (Type 2) processing failed randomly.  <-- (This might go to System.err)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 3
 * Pending Tasks:
 * (Queue is empty)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 4
 * Processed Tasks:
 * - Task: Backup Database, Type: 1, Success: true
 * - Task: Generate Report, Type: 2, Success: false
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5. <-- (This goes to System.err)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: abc
 * Invalid input. Please enter a number. <-- (This goes to System.err, handle InputMismatchException)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * **Submission:** Provide the complete Java code for the `Task` and `TaskScheduler` classes, including the `main` method within `TaskScheduler` or a separate class to start the `run()` method.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskScheduler` system as requested, demonstrating the required Java concepts and best practices.
 * 
 * **1. Task Class:**
 * *   The `Task` class is a simple Plain Old Java Object (POJO) representing a task.
 * *   It uses `private` fields (`name`, `type`, `success`) to enforce encapsulation.
 * *   Public getter methods provide controlled access to the task's state.
 * *   A `setSuccess` method is added to update the status after processing.
 * *   The `toString()` method provides a convenient way to display task information.
 * 
 * **2. TaskScheduler Class:**
 * *   This class orchestrates the task management.
 * *   **`pendingTasks`:** A `Queue<Task>` is used here, specifically implemented by `LinkedList`. The `Queue` interface is ideal for managing tasks in a First-In, First-Out (FIFO) manner, representing tasks waiting to be processed. `offer()` is used for adding and `poll()` for removing elements, which are standard `Queue` operations.
 * *   **`processedTasks`:** A `List<Task>` is used, implemented by `ArrayList`. The `List` interface is used as the declared type, promoting good practice by coding to the interface rather than the implementation. `ArrayList` is suitable here as it provides dynamic resizing and efficient access/addition of processed tasks.
 * *   **`scanner`:** An instance of `Scanner` reads user input from `System.in`.
 * *   **`random`:** An instance of `Random` is used to simulate the probabilistic success of Type 2 tasks.
 * *   **`addTask(String name, int type)`:** Takes task details, validates the `type` input (must be 1-3), and adds a new `Task` object to the `pendingTasks` queue using `offer()`. Invalid type input results in an error message to `System.err`.
 * *   **`processNextTask()`:**
 *     *   Uses `pendingTasks.poll()` to retrieve and remove the task at the front of the queue.
 *     *   Checks if `poll()` returned `null`, indicating an empty queue.
 *     *   Uses a `switch` statement based on `taskToProcess.getType()` to simulate processing logic.
 *     *   `System.out` is used for success messages (Type 1 and Type 2 success).
 *     *   `System.err` is used for failure messages (Type 2 failure, Type 3 failure, invalid type).
 *     *   The `success` status of the task object is updated.
 *     *   The processed task object is added to the `processedTasks` `List` using `add()`.
 * *   **`viewPendingTasks()`:** Iterates through the `pendingTasks` queue to display tasks without removing them. Checks for emptiness. Output goes to `System.out`.
 * *   **`viewProcessedTasks()`:** Iterates through the `processedTasks` `List` to display all processed tasks and their status using the `Task`'s `toString()` method. Checks for emptiness. Output goes to `System.out`.
 * *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 * *   **`run()`:**
 *     *   This method contains the main application loop (`while (choice != 5)`).
 *     *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)`. This demonstrates catching any unexpected runtime exception that might occur anywhere within the loop's execution, providing a robust outer layer of error handling. A generic error message and the stack trace are printed to `System.err`.
 *     *   **Input Handling & Validation:** Inside the loop, another `try-catch(InputMismatchException e)` is used specifically around `scanner.nextInt()` when reading the main menu choice. This handles cases where the user enters non-integer input, prints an error to `System.err`, and consumes the invalid input from the scanner buffer to prevent an infinite loop.
 *     *   A `switch` statement is used to direct the program flow based on the valid menu choice.
 *     *   Input for task type in case 1 also has a `try-catch(InputMismatchException)` for specific validation.
 *     *   **`finally` block:** Ensures `scanner.close()` is called whether the loop finishes normally (choice 5) or exits due to an unhandled exception caught by the outer `try-catch`.
 * 
 * **3. Component Usage Summary:**
 * *   `Queue`: Used for `pendingTasks` (implemented by `LinkedList`).
 * *   `ArrayList`: Used as the implementation for `processedTasks`.
 * *   `List`: Used as the declared type for `processedTasks`.
 * *   `Scanner`: Used in the `run()` method to read user input.
 * *   `switch` statement: Used in `run()` to process menu choices and in `processNextTask()` to simulate task outcomes based on type.
 * *   `System.err`: Used for error messages (invalid input, processing failures, unexpected exceptions).
 * *   `System.out`: Used for normal output (menu, prompts, success messages, task lists).
 * *   Class-wide `try-catch`: The outer `try-catch` block in the `run()` method.
 * 
 * **4. Best Practices:**
 * *   Encapsulation is used in the `Task` class.
 * *   Variable names (`pendingTasks`, `processedTasks`, `taskToProcess`, `currentTaskSuccess`) and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `run`) are descriptive.
 * *   Comments explain the purpose of classes, methods, and key logic sections.
 * *   Input validation is performed for task type and menu choices.
 * *   Error handling distinguishes between specific input errors (`InputMismatchException`) and general unexpected errors (`Exception`). `System.err` is used appropriately for errors.
 * *   The code is structured into two classes (`Task` and `TaskScheduler`) with a clear separation of concerns.
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a practical scenario, demonstrating advanced understanding of data structures, control flow, and exception handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

/**
 * Represents a single task with a name, type, and processing status.
 */
class Task {
    private String name;
    private int type;
    private boolean success;

    /**
     * Constructs a new Task.
     * @param name The name of the task.
     * @param type The type of the task (e.g., 1, 2, 3).
     */
    public Task(String name, int type) {
        this.name = name;
        this.type = type;
        this.success = false; // Initially not processed successfully
    }

    // --- Getters ---
    public String getName() {
        return name;
    }

    public int getType() {
        return type;
    }

    public boolean isSuccess() {
        return success;
    }

    // --- Setter for success status ---
    public void setSuccess(boolean success) {
        this.success = success;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation of the Task.
     */
    @Override
    public String toString() {
        return "Task: " + name + ", Type: " + type + ", Success: " + success;
    }
}

/**
 * Manages a queue of pending tasks and a list of processed tasks.
 */
public class TaskScheduler { // Using public class for main method entry point

    private Queue<Task> pendingTasks;
    private List<Task> processedTasks; // Declared as List interface type
    private Scanner scanner;
    private Random random; // For simulating probabilistic success

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.processedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue after validation.
     * @param name The name of the task.
     * @param type The type of the task.
     */
    public void addTask(String name, int type) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Task name cannot be empty.");
            return;
        }
        if (type < 1 || type > 3) {
            System.err.println("Error: Invalid task type. Type must be between 1 and 3.");
            return;
        }

        Task newTask = new Task(name.trim(), type);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task '" + newTask.getName() + "' (Type " + newTask.getType() + ") added to pending queue.");
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates success/failure based on task type.
     */
    public void processNextTask() {
        System.out.println("Processing next task...");
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess == null) {
            System.out.println("No tasks currently pending.");
            return;
        }

        boolean currentTaskSuccess = false; // Assume failure initially

        // Simulate processing based on task type
        switch (taskToProcess.getType()) {
            case 1:
                currentTaskSuccess = true;
                System.out.println("Task '" + taskToProcess.getName() + "' (Type 1) processed successfully.");
                break;
            case 2:
                // 70% chance of success
                if (random.nextDouble() < 0.7) {
                    currentTaskSuccess = true;
                    System.out.println("Task '" + taskToProcess.getName() + "' (Type 2) processed successfully.");
                } else {
                    currentTaskSuccess = false;
                    System.err.println("Task '" + taskToProcess.getName() + "' (Type 2) processing failed randomly.");
                }
                break;
            case 3:
                currentTaskSuccess = false;
                System.err.println("Task '" + taskToProcess.getName() + "' (Type 3) processing failed intentionally.");
                break;
            default:
                // This case should ideally not be reached due to addTask validation
                currentTaskSuccess = false;
                System.err.println("Task '" + taskToProcess.getName() + "' has an invalid type (" + taskToProcess.getType() + "). Processing failed.");
                break;
        }

        taskToProcess.setSuccess(currentTaskSuccess);
        processedTasks.add(taskToProcess); // Add the processed task to the history list
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println("- " + task.getName() + " (Type: " + task.getType() + ")");
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the processed tasks list, including their status.
     */
    public void viewProcessedTasks() {
        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("(No tasks have been processed yet)");
        } else {
            // Iterate over the list
            for (Task task : processedTasks) {
                System.out.println("- " + task.toString()); // Using the Task's toString method
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch block for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for main menu control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task name: ");
                            String name = scanner.nextLine();
                            int type = -1;
                            System.out.print("Enter task type (1-3): ");
                            try {
                                type = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                addTask(name, type);
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid input for task type. Please enter a number.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewProcessedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Scheduler.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input for the main menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                }
            }
        } catch (Exception e) {
            // Generic catch for any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected error occurred during program execution:");
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when exiting the loop or due to an exception
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run(); // Start the main application loop
    }
}
