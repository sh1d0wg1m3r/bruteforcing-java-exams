/*
 * Exam Question #1043
 * Generated on: 2025-05-12 17:16:59
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Assembly Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a manufacturing assembly line. Parts arrive and are placed in an input queue. When a processing command is issued, the next part from the queue is processed. Processing has a chance of success or failure. Successfully processed parts are moved to a 'completed' list, while failed parts are moved to a 'rejected' list. The system should allow users to add new parts, process parts, view the current status of the line, and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:** Create at least two classes:
 *     *   `ProductPart`: Represents a single part with a unique integer ID and a status (e.g., "Waiting", "Completed", "Rejected").
 *     *   `AssemblyLineSimulator`: Manages the simulation logic, including the queues, lists, and user interaction.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store parts waiting to be processed (the input queue).
 *     *   Use a `java.util.List` (implemented by `java.util.ArrayList`) to store successfully completed parts.
 *     *   Use a `java.util.List` (implemented by `java.util.ArrayList`) to store rejected parts.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   The program should repeatedly prompt the user for a command until 'EXIT' is entered.
 *     *   Supported commands:
 *         *   `ADD <partId>`: Adds a new `ProductPart` with the given `partId` to the input queue. `partId` must be a positive integer.
 *         *   `PROCESS`: Takes the next part from the input queue, simulates processing, and moves it to the appropriate list.
 *         *   `STATUS`: Displays the current number of parts in the input queue, completed list, and rejected list.
 *         *   `EXIT`: Terminates the program.
 * 4.  **Processing Logic (`PROCESS` command):**
 *     *   If the input queue is empty, print an error message.
 *     *   If the queue is not empty, take the part from the front of the queue.
 *     *   Simulate processing: Generate a random number (e.g., between 0.0 and 1.0). If the number is less than 0.8 (80% chance), the processing is successful; otherwise (20% chance), it fails.
 *     *   Update the part's status.
 *     *   Add the part to the `completedParts` list if successful, or `rejectedParts` list if failed.
 *     *   Print a message indicating the result (Part X processed successfully/failed).
 * 5.  **Flow Control:** Use a `switch` statement to handle the different user commands.
 * 6.  **Output:**
 *     *   Use `System.out.println()` for normal messages (prompts, successful operations, status reports).
 *     *   Use `System.err.println()` for error messages (invalid command, invalid part ID, processing empty queue).
 * 7.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `AssemblyLineSimulator`'s main loop to catch potential runtime errors (e.g., related to Scanner input, although specific input validation should also be done).
 *     *   Implement input validation for the `ADD` command (`partId` must be a positive integer). Handle invalid input gracefully using `System.err`.
 * 8.  **Best Practices:**
 *     *   Use private fields and public methods for encapsulation.
 *     *   Choose meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resource cleanup (e.g., closing the `Scanner`).
 * 
 * **Expected Interaction Example:**
 * 
 * ```
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): ADD 101
 * Part 101 added to input queue.
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): ADD 102
 * Part 102 added to input queue.
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): STATUS
 * Current Status:
 * Input Queue: 2 parts
 * Completed: 0 parts
 * Rejected: 0 parts
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): PROCESS
 * Processing part 101...
 * Part 101 processed successfully. (or Part 101 processing failed.)
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): PROCESS
 * Processing part 102...
 * Part 102 processing failed. (or Part 102 processed successfully.)
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): STATUS
 * Current Status:
 * Input Queue: 0 parts
 * Completed: 1 parts
 * Rejected: 1 parts (counts may vary based on random outcome)
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): ADD -5
 * Error: Invalid part ID. Must be a positive integer.
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): PROCESS
 * Processing part from input queue...
 * Error: Input queue is empty.
 * Enter command (ADD <partId>, PROCESS, STATUS, EXIT): EXIT
 * Exiting simulation.
 * ```
 * 
 * Implement the Java code for the `ProductPart` and `AssemblyLineSimulator` classes to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements the `AssemblyLineSimulation` problem, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`ProductPart` Class:**
 *     *   This class encapsulates the data for a single part (`id` and `status`).
 *     *   It uses `private` fields for encapsulation and provides public getter methods. A setter is provided for the status, as the status changes during processing.
 *     *   A `toString()` method is included for easy debugging/printing of part details.
 * 
 * 2.  **`AssemblyLineSimulator` Class:**
 *     *   This is the main class that orchestrates the simulation.
 *     *   **Data Structures:**
 *         *   `private Queue<ProductPart> incomingParts;`: Declared as `Queue` and instantiated as `LinkedList`. This structure is perfect for the input queue because parts are added to the end (`offer`) and processed from the front (`poll`), adhering to the First-In, First-Out (FIFO) principle.
 *         *   `private List<ProductPart> completedParts;`: Declared as `List` and instantiated as `ArrayList`. This stores parts that successfully finished processing. `ArrayList` provides dynamic resizing and efficient adding.
 *         *   `private List<ProductPart> rejectedParts;`: Declared as `List` and instantiated as `ArrayList`. Similar to `completedParts`, this stores parts that failed processing. Using `List` as the type emphasizes the interface rather than the specific implementation where possible, promoting flexibility.
 *     *   **User Input:**
 *         *   `private Scanner scanner;`: Used to read command lines from `System.in`.
 *     *   **Simulation Logic:**
 *         *   `private Random random;`: Used in the `processNextPart` method to simulate a random outcome (success or failure).
 *     *   **`startSimulation()` Method:**
 *         *   Contains the main application loop that continuously prompts the user for input.
 *         *   It reads the entire line using `scanner.nextLine()`, then splits it to get the command and any arguments.
 *         *   **Class-wide Exception Handling:** The core `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected runtime exceptions that might occur within the loop, printing an error to `System.err`, and continuing or terminating gracefully. A `finally` block ensures the `scanner` is closed.
 *         *   **Switch Statement:** A `switch` statement is used on the command string (`ADD`, `PROCESS`, `STATUS`, `EXIT`) to direct the program flow to the appropriate private method. This fulfills the requirement for using a `switch` statement for flow control.
 *     *   **`addPart(int partId)` Method:**
 *         *   Takes the `partId` as input.
 *         *   Includes **Input Validation**: It checks if `partId` is positive. If not, it prints an error message to `System.err` and returns.
 *         *   Creates a new `ProductPart` and adds it to the `incomingParts` queue using `offer()`.
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextPart()` Method:**
 *         *   Attempts to retrieve and remove the head of the `incomingParts` queue using `poll()`. `poll()` is safe as it returns `null` if the queue is empty, which is checked immediately.
 *         *   If the queue is empty, it prints an error message to `System.err`.
 *         *   If a part is retrieved, it simulates processing using `random.nextDouble()`.
 *         *   Based on the random outcome, it updates the part's status (`setStatus`) and adds the part to either the `completedParts` list or the `rejectedParts` list using `add()`.
 *         *   Prints the outcome (success or failure) to `System.out`.
 *     *   **`displayStatus()` Method:**
 *         *   Prints the current size of each collection (`incomingParts`, `completedParts`, `rejectedParts`) to `System.out`, providing a clear status report.
 *     *   **`closeScanner()` Method:**
 *         *   A utility method called in the `finally` block of `startSimulation` to ensure the `Scanner` resource is closed, preventing resource leaks.
 *     *   **`main()` Method:**
 *         *   The standard entry point of the application. It creates an instance of `AssemblyLineSimulator` and calls `startSimulation()`.
 * 
 * 3.  **Error Handling and Output:**
 *     *   `System.err.println()` is used specifically for error messages (invalid commands, validation failures, empty queue processing).
 *     *   `System.out.println()` is used for all standard output (prompts, successful actions, status reports).
 *     *   Input validation for `ADD` command's part ID is handled with an `if` check and a `System.err` message.
 *     *   `NumberFormatException` is caught specifically when trying to parse the part ID from the input string, printing an error to `System.err`.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is used throughout (`private` fields, public/private methods).
 *     *   Variable and method names are descriptive (e.g., `incomingParts`, `processNextPart`, `completedParts`).
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation is performed.
 *     *   Error handling distinguishes between normal output and errors using `System.out` and `System.err`.
 *     *   Resource cleanup (`scanner.close()`) is handled.
 *     *   The code structure is clean, with methods dedicated to specific tasks (`addPart`, `processNextPart`, `displayStatus`).
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical simulation scenario, demonstrating advanced understanding of Java programming principles.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

/**
 * Represents a single product part in the assembly line simulation.
 */
class ProductPart {
    private int id;
    private String status; // e.g., "Waiting", "Completed", "Rejected"

    /**
     * Constructs a ProductPart with a given ID.
     * Initially, the status is "Waiting".
     *
     * @param id The unique identifier for the part.
     */
    public ProductPart(int id) {
        this.id = id;
        this.status = "Waiting";
    }

    /**
     * Gets the ID of the part.
     *
     * @return The part ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the current status of the part.
     *
     * @return The part status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the part.
     *
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Part{" +
               "id=" + id +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Simulates a simple assembly line managing parts.
 */
public class AssemblyLineSimulator { // Changed to public for main method entry point
    private Queue<ProductPart> incomingParts;
    private List<ProductPart> completedParts;
    private List<ProductPart> rejectedParts;
    private Scanner scanner;
    private Random random; // For simulating processing success/failure

    /**
     * Constructs an AssemblyLineSimulator, initializing data structures and scanner.
     */
    public AssemblyLineSimulator() {
        // Use LinkedList as a concrete implementation of Queue
        this.incomingParts = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedParts = new ArrayList<>();
        this.rejectedParts = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.random = new Random();
    }

    /**
     * Starts the assembly line simulation loop.
     * Handles user input and commands.
     */
    public void startSimulation() {
        System.out.println("Assembly Line Simulation Started.");

        // Class-wide exception handling loop
        try {
            while (true) {
                System.out.print("Enter command (ADD <partId>, PROCESS, STATUS, EXIT): ");
                String inputLine = scanner.nextLine().trim();
                String[] parts = inputLine.split(" ");
                String command = parts[0].toUpperCase();

                // Using switch for flow control
                switch (command) {
                    case "ADD":
                        if (parts.length == 2) {
                            try {
                                int partId = Integer.parseInt(parts[1]);
                                addPart(partId);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid part ID format. Must be an integer.");
                            }
                        } else {
                            System.err.println("Error: ADD command requires a part ID. Usage: ADD <partId>");
                        }
                        break;

                    case "PROCESS":
                        processNextPart();
                        break;

                    case "STATUS":
                        displayStatus();
                        break;

                    case "EXIT":
                        System.out.println("Exiting simulation.");
                        return; // Exit the method and thus the program

                    default:
                        System.err.println("Error: Unknown command. Please use ADD, PROCESS, STATUS, or EXIT.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            closeScanner();
        }
    }

    /**
     * Adds a new product part to the incoming queue.
     * Validates that the part ID is positive.
     *
     * @param partId The ID of the part to add.
     */
    private void addPart(int partId) {
        // Input validation
        if (partId <= 0) {
            System.err.println("Error: Invalid part ID. Must be a positive integer.");
            return;
        }

        ProductPart newPart = new ProductPart(partId);
        incomingParts.offer(newPart); // offer is generally preferred over add for queues
        System.out.println("Part " + partId + " added to input queue.");
    }

    /**
     * Processes the next part from the incoming queue.
     * Simulates success or failure and moves the part to the appropriate list.
     */
    private void processNextPart() {
        System.out.println("Processing part from input queue...");
        ProductPart partToProcess = incomingParts.poll(); // poll retrieves and removes the head

        if (partToProcess == null) {
            System.err.println("Error: Input queue is empty. No parts to process.");
            return;
        }

        // Simulate processing outcome (80% success chance)
        boolean success = random.nextDouble() < 0.8;

        if (success) {
            partToProcess.setStatus("Completed");
            completedParts.add(partToProcess);
            System.out.println("Part " + partToProcess.getId() + " processed successfully.");
        } else {
            partToProcess.setStatus("Rejected");
            rejectedParts.add(partToProcess);
            System.out.println("Part " + partToProcess.getId() + " processing failed.");
        }
    }

    /**
     * Displays the current status of the assembly line.
     */
    private void displayStatus() {
        System.out.println("Current Status:");
        System.out.println("Input Queue: " + incomingParts.size() + " parts");
        System.out.println("Completed: " + completedParts.size() + " parts");
        System.out.println("Rejected: " + rejectedParts.size() + " parts");
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulator simulator = new AssemblyLineSimulator();
        simulator.startSimulation();
    }
}
