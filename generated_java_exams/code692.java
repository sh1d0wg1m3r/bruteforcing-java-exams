/*
 * Exam Question #692
 * Generated on: 2025-05-12 16:26:32
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam: Assembly Line Simulation System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation of a manufacturing assembly line. The system should manage incoming "Work Orders" that need processing and store "Finished Products" once processed.
 * 
 * A Work Order has a unique ID, a type (e.g., "Electronics", "Mechanical", "Packaging"), and a quantity of items to process.
 * 
 * The system should interact with the user via the console, providing a menu of operations.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to hold incoming `WorkOrder` objects waiting to be processed (the "work queue").
 *     *   Use a `List` (specifically, an `ArrayList` implementation) to store `WorkOrder` objects that have been processed (the "finished products list").
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Work Order
 *         2.  Process Next Work Order
 *         3.  View Work Queue
 *         4.  View Finished Products
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 3.  **Functionality:**
 *     *   **Add New Work Order:** Prompt the user for the work order type (String) and quantity (integer). Assign a unique ID (you can use a simple counter starting from 1). Create a `WorkOrder` object and add it to the work queue.
 *     *   **Process Next Work Order:** Take the next `WorkOrder` from the front of the work queue. Simulate processing by moving it to the finished products list. If the queue is empty, inform the user.
 *     *   **View Work Queue:** Display all work orders currently in the queue, in the order they will be processed.
 *     *   **View Finished Products:** Display all work orders that have been processed and are in the finished products list.
 *     *   **Exit:** Terminate the program.
 * 4.  **Error Handling:**
 *     *   Implement input validation:
 *         *   Ensure menu selection is a valid integer within the range of options.
 *         *   Ensure the quantity entered for a work order is a positive integer.
 *     *   Use `try-catch` blocks to handle potential exceptions, such as `InputMismatchException` for invalid input types or handling operations on an empty queue.
 *     *   Use `System.err.println()` to output error messages.
 *     *   Use `System.out.println()` for normal output (menu, prompts, successful operations, list contents).
 *     *   Implement *class-wide* exception handling by wrapping the main program loop or critical sections within a `try-catch` block in your main simulation class.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `WorkOrder` class to represent work orders with appropriate fields (private) and methods (public getters, `toString()`).
 *     *   Create a main class (e.g., `AssemblyLineSimulation`) to manage the queue, list, and user interaction. This class should have private fields for the queue and list and public methods for the operations.
 *     *   Adhere to principles of encapsulation.
 * 6.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., JavaDocs for classes and methods).
 *     *   Structure the code logically.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interactions might look like this:
 * 
 * ```
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 1
 * Enter Work Order Type: Electronics
 * Enter Quantity: 15
 * Work Order #1 (Type: Electronics, Qty: 15) added to queue.
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 1
 * Enter Work Order Type: Packaging
 * Enter Quantity: 100
 * Work Order #2 (Type: Packaging, Qty: 100) added to queue.
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 3
 * --- Work Queue ---
 * Work Order #1 (Type: Electronics, Qty: 15)
 * Work Order #2 (Type: Packaging, Qty: 100)
 * ------------------
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 2
 * Processing Work Order #1 (Type: Electronics, Qty: 15)... Moved to finished products.
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 3
 * --- Work Queue ---
 * Work Order #2 (Type: Packaging, Qty: 100)
 * ------------------
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: 4
 * --- Finished Products ---
 * Work Order #1 (Type: Electronics, Qty: 15)
 * -------------------------
 * 
 * Assembly Line Simulation Menu:
 * 1. Add New Work Order
 * 2. Process Next Work Order
 * 3. View Work Queue
 * 4. View Finished Products
 * 5. Exit
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * Assembly Line Simulation Menu:
 * ... (user enters 2 again) ...
 * Error: Work queue is empty. No orders to process.
 * 
 * Assembly Line Simulation Menu:
 * ... (user enters 5) ...
 * Exiting simulation. Goodbye!
 * ```
 * 
 * Your solution should consist of one or more `.java` files containing the necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct logic for adding, processing, and viewing work orders.
 * *   Robust input validation and error handling.
 * *   Adherence to OOP principles and best practices (encapsulation, naming, comments).
 * *   Clean and readable code structure.
 *
 * EXPLANATION:
 * The provided solution implements a simple Assembly Line Simulation system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`WorkOrder` Class:**
 *     *   This class represents a single work unit.
 *     *   It has `private` fields (`id`, `type`, `quantity`) to ensure encapsulation.
 *     *   `public` getter methods provide controlled access to the data.
 *     *   The `toString()` method provides a convenient way to display work order information.
 * 
 * 2.  **`AssemblyLineSimulation` Class:**
 *     *   This is the main class that orchestrates the simulation.
 *     *   **`private Queue<WorkOrder> workQueue;`**: Declares a field using the `Queue` interface. It is initialized with a `LinkedList`, a common class that implements `Queue`. This queue holds `WorkOrder` objects waiting to be processed, adhering to the FIFO (First-In, First-Out) principle.
 *     *   **`private List<WorkOrder> finishedProducts;`**: Declares a field using the `List` interface. It is initialized with an `ArrayList`, a concrete implementation of `List`. This list stores `WorkOrder` objects after they have been processed.
 *     *   **`private int nextWorkOrderId;`**: A simple counter to generate unique IDs for new work orders.
 *     *   **`private Scanner scanner;`**: An instance of `Scanner` for reading user input. Declared as a class field and initialized in the constructor, it's closed in the `finally` block to release resources.
 *     *   **`displayMenu()`**: A helper method to print the menu options to `System.out`.
 *     *   **`addWorkOrder()`**:
 *         *   Prompts the user for type and quantity using `System.out`.
 *         *   Reads input using the `scanner`.
 *         *   Includes basic validation for type (not empty) and quantity (positive integer).
 *         *   Uses a `try-catch` block specifically for reading the quantity to handle `InputMismatchException` if the user enters non-integer input.
 *         *   Creates a new `WorkOrder` object.
 *         *   Adds the new work order to the `workQueue` using `offer()`. `offer()` is preferred over `add()` for bounded queues as it returns `false` if the element cannot be added, though `LinkedList` is unbounded. For this simulation, it behaves like `add()`.
 *         *   Prints a success message to `System.out`.
 *         *   Uses `System.err.println()` for validation errors.
 *     *   **`processNextWorkOrder()`**:
 *         *   Checks if the `workQueue` is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns.
 *         *   If not empty, it removes the next `WorkOrder` from the queue using `poll()`. `poll()` retrieves and removes the head of the queue, returning `null` if the queue is empty (handled by the `isEmpty()` check).
 *         *   Adds the processed order to the `finishedProducts` `ArrayList` using `add()`.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewWorkQueue()`**:
 *         *   Prints a header to `System.out`.
 *         *   Checks if the queue is empty.
 *         *   If not empty, it iterates through the `workQueue` using an enhanced for loop. Iterating directly over a `Queue` typically processes elements in the correct order (FIFO) without removing them.
 *         *   Prints each `WorkOrder`'s `toString()` representation to `System.out`.
 *     *   **`viewFinishedProducts()`**:
 *         *   Prints a header to `System.out`.
 *         *   Checks if the list is empty.
 *         *   If not empty, iterates through the `finishedProducts` `ArrayList` using an enhanced for loop.
 *         *   Prints each `WorkOrder`'s `toString()` representation to `System.out`.
 *     *   **`runSimulation()`**:
 *         *   Contains the main application loop (`while(running)`).
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a large `try-catch(Exception e)` block. This demonstrates catching unexpected errors that might occur anywhere within the simulation loop, printing an error message and the stack trace to `System.err`.
 *         *   A smaller `try-catch(InputMismatchException)` is used specifically around reading the menu choice to handle non-integer input gracefully without crashing the program or entering an infinite loop.
 *         *   Reads the user's choice using `scanner.nextInt()`.
 *         *   **`switch (choice)`**: Controls the program flow based on the user's input, calling the appropriate method for each menu option.
 *         *   Includes a `default` case in the `switch` to handle valid integer inputs that are not valid menu options, printing an error to `System.err`.
 *         *   The `finally` block ensures that the `scanner` is closed regardless of whether an exception occurred or the loop finished normally.
 *     *   **`main()`**: The entry point of the application. It creates an instance of `AssemblyLineSimulation` and calls its `runSimulation()` method.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields are private, access is via public methods (`WorkOrder` getters, `AssemblyLineSimulation` public methods like `runSimulation`).
 * *   **Meaningful Names:** Variables and methods are named clearly (e.g., `workQueue`, `processNextWorkOrder`, `nextWorkOrderId`).
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods.
 * *   **Input Validation:** Checks for empty type, non-positive quantity, and non-integer menu input.
 * *   **Error Handling:** Uses `try-catch` for anticipated (input) and unanticipated (general `Exception`) errors, printing messages to `System.err`. Handles empty queue gracefully.
 * *   **Clean Structure:** Logic is separated into distinct methods based on functionality. The `main` method is minimal, delegating control to the simulation object.
 * 
 * This solution effectively uses all required components in a cohesive, practical scenario while adhering to good programming practices, making it a challenging yet solvable exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single work order for the assembly line.
 */
class WorkOrder {
    private int id;
    private String type;
    private int quantity;

    /**
     * Constructs a new WorkOrder.
     * @param id The unique identifier for the work order.
     * @param type The type of work order (e.g., "Electronics", "Mechanical").
     * @param quantity The number of items to process for this order.
     */
    public WorkOrder(int id, String type, int quantity) {
        this.id = id;
        this.type = type;
        this.quantity = quantity;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public int getQuantity() {
        return quantity;
    }

    /**
     * Returns a string representation of the WorkOrder.
     * @return A formatted string describing the work order.
     */
    @Override
    public String toString() {
        return "Work Order #" + id + " (Type: " + type + ", Qty: " + quantity + ")";
    }
}

/**
 * Simulates an assembly line managing a queue of work orders and a list of finished products.
 */
public class AssemblyLineSimulation {

    private Queue<WorkOrder> workQueue;
    private List<WorkOrder> finishedProducts;
    private int nextWorkOrderId;
    private Scanner scanner;

    /**
     * Constructs a new AssemblyLineSimulation.
     */
    public AssemblyLineSimulation() {
        // Use LinkedList as a concrete implementation of Queue
        this.workQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.finishedProducts = new ArrayList<>();
        this.nextWorkOrderId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nAssembly Line Simulation Menu:");
        System.out.println("1. Add New Work Order");
        System.out.println("2. Process Next Work Order");
        System.out.println("3. View Work Queue");
        System.out.println("4. View Finished Products");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new work order based on user input.
     */
    private void addWorkOrder() {
        System.out.print("Enter Work Order Type: ");
        String type = scanner.nextLine().trim();

        if (type.isEmpty()) {
            System.err.println("Error: Work order type cannot be empty.");
            return;
        }

        System.out.print("Enter Quantity: ");
        int quantity = -1;
        try {
            quantity = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for quantity. Please enter a number.");
            // Consume the invalid input
            scanner.nextLine();
            return;
        }

        if (quantity <= 0) {
            System.err.println("Error: Quantity must be a positive integer.");
            return;
        }

        WorkOrder newOrder = new WorkOrder(nextWorkOrderId++, type, quantity);
        workQueue.offer(newOrder); // offer() is generally preferred over add() for queues
        System.out.println(newOrder + " added to queue.");
    }

    /**
     * Processes the next work order from the queue.
     */
    private void processNextWorkOrder() {
        if (workQueue.isEmpty()) {
            System.err.println("Error: Work queue is empty. No orders to process.");
            return;
        }

        WorkOrder orderToProcess = workQueue.poll(); // poll() retrieves and removes the head
        System.out.println("Processing " + orderToProcess + "... Moved to finished products.");
        finishedProducts.add(orderToProcess);
    }

    /**
     * Displays the current work queue contents.
     */
    private void viewWorkQueue() {
        System.out.println("--- Work Queue ---");
        if (workQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (WorkOrder order : workQueue) {
                System.out.println(order);
            }
        }
        System.out.println("------------------");
    }

    /**
     * Displays the current finished products list contents.
     */
    private void viewFinishedProducts() {
        System.out.println("--- Finished Products ---");
        if (finishedProducts.isEmpty()) {
            System.out.println("(No products finished yet)");
        } else {
            for (WorkOrder order : finishedProducts) {
                System.out.println(order);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main simulation loop.
     * Contains class-wide exception handling.
     */
    public void runSimulation() {
        int choice = 0;
        boolean running = true;

        // Class-wide try-catch block for the main simulation loop
        try {
            while (running) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    // Consume the newline character after reading the integer choice
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration
                }

                // Use a switch statement for menu control
                switch (choice) {
                    case 1:
                        addWorkOrder();
                        break;
                    case 2:
                        processNextWorkOrder();
                        break;
                    case 3:
                        viewWorkQueue();
                        break;
                    case 4:
                        viewFinishedProducts();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulation. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred during simulation:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulation simulation = new AssemblyLineSimulation();
        simulation.runSimulation();
    }
}
