/*
 * Exam Question #1086
 * Generated on: 2025-05-12 17:23:10
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Hospital Appointment Scheduling System
 * 
 * You are tasked with developing a simplified Hospital Appointment Scheduling System. This system will manage appointment requests submitted by patients and schedule them based on available time slots. The system should be interactive, accepting commands from the user via the console.
 * 
 * **System Requirements:**
 * 
 * 1.  **Appointment Requests:** Patients submit requests containing their name, desired doctor, and preferred time. These requests are placed in a queue to be processed in the order they are received.
 * 2.  **Available Slots:** The system maintains a list of pre-defined available time slots, each associated with a doctor and a specific time.
 * 3.  **Scheduling Process:** The system should be able to process the next request from the queue. When processing a request, it attempts to find an *available* slot that matches the requested doctor and time. If a match is found, the slot is marked as booked, and the patient is scheduled. If no matching *available* slot is found, the request remains in the queue (or is perhaps logged as unscheduled, for simplicity in this exam, we'll just indicate failure). If the queue is empty, the scheduling action should report that.
 * 4.  **User Interface:** The system should present a menu-driven interface allowing the user to perform the following actions:
 *     *   Submit a new appointment request.
 *     *   Schedule the next request from the queue.
 *     *   View all pending appointment requests in the queue.
 *     *   View all currently available time slots.
 *     *   Exit the application.
 * 
 * **Technical Requirements:**
 * 
 * Your Java solution must adhere to the following technical specifications:
 * 
 * 1.  Use `java.util.Queue` (specifically, an implementation like `LinkedList` is suitable for a queue) to manage appointment requests.
 * 2.  Use `java.util.ArrayList` to store the collection of available time slots.
 * 3.  Use the `java.util.List` interface type where appropriate (e.g., for method parameters or variable declarations) to demonstrate understanding of interface-based programming.
 * 4.  Use `java.util.Scanner` to read user input from the console.
 * 5.  Employ a `switch` statement to handle the user's menu selection.
 * 6.  Use `System.err.println()` exclusively for printing error messages (e.g., invalid input, scheduling failure due to no available slot or empty queue).
 * 7.  Use `System.out.println()` for all normal output (menu, prompts, success messages, list views).
 * 8.  Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, particularly related to user input (e.g., non-integer input for menu options).
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation by declaring fields as `private` and providing `public` methods for interaction.
 * *   Use meaningful names for variables, methods, and classes.
 * *   Include comments or Javadoc to explain complex parts or class/method purpose.
 * *   Include basic input validation (e.g., ensuring menu input is an integer).
 * *   Handle edge cases like an empty request queue or no available slots.
 * *   Structure the code clearly with separate classes for data (requests, slots) and the main scheduling logic.
 * 
 * **Data Structure Details:**
 * 
 * *   Create a simple class `AppointmentRequest` with fields: `patientName` (String), `desiredDoctor` (String), `requestedTime` (String).
 * *   Create a simple class `AvailableSlot` with fields: `doctor` (String), `time` (String), `isAvailable` (boolean). Initialize a list of `AvailableSlot` objects at the start of the application (e.g., few slots for "Dr. Smith" and "Dr. Jones" at different times).
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a menu. Based on user input, it should perform the requested action, print appropriate messages (`System.out` for success/info, `System.err` for errors), and loop back to the menu until the user chooses to exit.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Appointment Scheduler Menu ---
 * 1. Submit Appointment Request
 * 2. Schedule Next Request
 * 3. View Pending Requests
 * 4. View Available Slots
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter desired doctor (e.g., Dr. Smith): Dr. Smith
 * Enter requested time (e.g., 10:00 AM): 10:00 AM
 * Appointment request submitted for Alice.
 * 
 * --- Appointment Scheduler Menu ---
 * 1. Submit Appointment Request
 * 2. Schedule Next Request
 * 3. View Pending Requests
 * 4. View Available Slots
 * 5. Exit
 * Enter your choice: 2
 * Attempting to schedule next request...
 * Scheduled Alice with Dr. Smith at 10:00 AM.
 * 
 * --- Appointment Scheduler Menu ---
 * 1. Submit Appointment Request
 * 2. Schedule Next Request
 * 3. View Pending Requests
 * 4. View Available Slots
 * 5. Exit
 * Enter your choice: 4
 * --- Available Slots ---
 * Doctor: Dr. Smith, Time: 11:00 AM (Available)
 * Doctor: Dr. Jones, Time: 2:00 PM (Available)
 * Doctor: Dr. Jones, Time: 3:00 PM (Available)
 * 
 * --- Appointment Scheduler Menu ---
 * ... (etc.)
 * ```
 * 
 * **Constraints:**
 * 
 * *   Do not use any external libraries beyond the standard Java SE API.
 * *   Adhere strictly to the required Java components and their specified usage (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * 
 * This task requires you to integrate multiple core Java concepts into a functional, well-structured, and robust application. Good luck!
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Scheduling System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `AppointmentRequest`: A simple Plain Old Java Object (POJO) to hold the details of a patient's request. It has private fields (`patientName`, `desiredDoctor`, `requestedTime`) and public getter methods, demonstrating encapsulation. The `toString()` method provides a convenient way to print request details.
 *     *   `AvailableSlot`: A POJO representing a time slot. It includes `doctor`, `time`, and a `boolean` `isAvailable` flag. It also uses encapsulation with private fields and public methods (`isAvailable()`, `bookSlot()`).
 *     *   `AppointmentScheduler`: This is the main class containing the application logic. It holds the `Queue` of requests and the `List` of available slots.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: The `requestQueue` is declared as `Queue<AppointmentRequest>` and initialized with `new LinkedList<>()`. This correctly uses a `Queue` implementation (`LinkedList`) to manage requests in a First-In, First-Out (FIFO) manner. Methods like `offer()` (to add requests) and `poll()` (to retrieve and remove the head for scheduling) are used.
 *     *   `ArrayList`: The `availableSlots` list is initialized with `new ArrayList<>()`. This provides a dynamic, index-based collection to store and manage the `AvailableSlot` objects.
 *     *   `List interface`: The `viewAvailableSlots(List<AvailableSlot> slotsToView)` method signature uses the `List` interface type. While the primary `availableSlots` field is an `ArrayList`, using `List` in method signatures or variable declarations promotes flexibility and coding against interfaces rather than concrete implementations, fulfilling this requirement. (Note: An overloaded `viewAvailableSlots()` is also provided for simplicity in the main menu, but the method using `List` is present).
 *     *   `Scanner`: A `Scanner` object is created to read user input from `System.in` for menu choices and appointment details.
 *     *   `Switch statement`: The `run()` method uses a `switch` statement based on the user's integer `choice` to direct the program flow to the appropriate action (`submitRequest`, `scheduleNextRequest`, `viewRequestQueue`, `viewAvailableSlots`, or exit).
 *     *   `System.err`: Used specifically for printing error messages, such as when the queue is empty during scheduling (`scheduleNextRequest`) or when invalid input is detected in the menu loop.
 *     *   `System.out`: Used for all other output, including the menu display, prompts for input, success messages, and listing the contents of the queue and available slots.
 *     *   `try-catch blocks`:
 *         *   A `try-catch (InputMismatchException)` block is used within the main loop (`run()`) specifically around the `scanner.nextInt()` call. This handles cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt the user again with an error message on `System.err`.
 *         *   A broader `try-catch (Exception e)` block wraps the entire `while` loop in the `run()` method. This serves as a class-wide handler to catch any unexpected runtime exceptions that might occur elsewhere and haven't been handled specifically. It prints an error message and the stack trace to `System.err` before the program potentially terminates (or attempts to continue if possible). A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** All data fields in `AppointmentRequest`, `AvailableSlot`, and `AppointmentScheduler` are `private`. Public getter methods are provided where necessary.
 *     *   **Meaningful Names:** Class names (`AppointmentScheduler`, `AppointmentRequest`, `AvailableSlot`), variable names (`requestQueue`, `availableSlots`, `patientName`, `isAvailable`), and method names (`submitRequest`, `scheduleNextRequest`, `viewRequestQueue`, `displayMenu`) are descriptive and indicate their purpose.
 *     *   **Comments/Documentation:** Basic comments explain the purpose of classes, methods, and key code sections (like `try-catch` blocks and component usage).
 *     *   **Input Validation:** The `try-catch (InputMismatchException)` handles the specific case of invalid integer input for the menu.
 *     *   **Error Handling:** Error conditions like an empty queue or no matching available slot during scheduling are explicitly checked and reported using `System.err`.
 *     *   **Clean Code Structure:** The code is divided into logical classes. The `AppointmentScheduler` class orchestrates the operations. The `run()` method encapsulates the main application loop and menu handling.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating error handling, input processing, data structure manipulation, and control flow using best practices suitable for an advanced programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient's appointment request
class AppointmentRequest {
    private String patientName;
    private String desiredDoctor;
    private String requestedTime;

    public AppointmentRequest(String patientName, String desiredDoctor, String requestedTime) {
        this.patientName = patientName;
        this.desiredDoctor = desiredDoctor;
        this.requestedTime = requestedTime;
    }

    public String getPatientName() {
        return patientName;
    }

    public String getDesiredDoctor() {
        return desiredDoctor;
    }

    public String getRequestedTime() {
        return requestedTime;
    }

    @Override
    public String toString() {
        return "Patient: " + patientName + ", Doctor: " + desiredDoctor + ", Time: " + requestedTime;
    }
}

// Represents an available time slot for a doctor
class AvailableSlot {
    private String doctor;
    private String time;
    private boolean isAvailable;

    public AvailableSlot(String doctor, String time) {
        this.doctor = doctor;
        this.time = time;
        this.isAvailable = true; // Slots start as available
    }

    public String getDoctor() {
        return doctor;
    }

    public String getTime() {
        return time;
    }

    public boolean isAvailable() {
        return isAvailable;
    }

    public void bookSlot() {
        this.isAvailable = false;
    }

    @Override
    public String toString() {
        return "Doctor: " + doctor + ", Time: " + time + " (" + (isAvailable ? "Available" : "Booked") + ")";
    }
}

// Main class for the appointment scheduling system
public class AppointmentScheduler {

    // Queue to hold pending appointment requests
    private Queue<AppointmentRequest> requestQueue;
    // List to hold available time slots
    private List<AvailableSlot> availableSlots;
    private Scanner scanner;

    // Constructor to initialize the system
    public AppointmentScheduler() {
        // Use LinkedList as a Queue implementation
        this.requestQueue = new LinkedList<>();
        // Use ArrayList for flexible storage of slots
        this.availableSlots = new ArrayList<>();
        this.scanner = new Scanner(System.in);

        // Initialize some sample available slots
        initializeSlots();
    }

    // Method to populate initial available slots
    private void initializeSlots() {
        availableSlots.add(new AvailableSlot("Dr. Smith", "10:00 AM"));
        availableSlots.add(new AvailableSlot("Dr. Smith", "11:00 AM"));
        availableSlots.add(new AvailableSlot("Dr. Jones", "2:00 PM"));
        availableSlots.add(new AvailableSlot("Dr. Jones", "3:00 PM"));
        System.out.println("System initialized with " + availableSlots.size() + " available slots.");
    }

    // Method to submit a new appointment request
    public void submitRequest() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine();
        System.out.print("Enter desired doctor (e.g., Dr. Smith): ");
        String desiredDoctor = scanner.nextLine();
        System.out.print("Enter requested time (e.g., 10:00 AM): ");
        String requestedTime = scanner.nextLine();

        AppointmentRequest newRequest = new AppointmentRequest(patientName, desiredDoctor, requestedTime);
        // Add the request to the end of the queue
        requestQueue.offer(newRequest);
        System.out.println("Appointment request submitted for " + patientName + ".");
    }

    // Method to schedule the next request from the queue
    public void scheduleNextRequest() {
        System.out.println("Attempting to schedule next request...");
        // Retrieve and remove the head of the queue
        AppointmentRequest request = requestQueue.poll();

        if (request == null) {
            // Use System.err for error condition (queue empty)
            System.err.println("Error: No pending requests in the queue.");
            return;
        }

        boolean scheduled = false;
        // Iterate through the list of available slots
        for (AvailableSlot slot : availableSlots) {
            // Check if the slot matches the request and is available
            if (slot.isAvailable() &&
                slot.getDoctor().equalsIgnoreCase(request.getDesiredDoctor()) &&
                slot.getTime().equalsIgnoreCase(request.getRequestedTime())) {

                slot.bookSlot(); // Mark the slot as booked
                System.out.println("Scheduled " + request.getPatientName() +
                                   " with " + slot.getDoctor() +
                                   " at " + slot.getTime() + ".");
                scheduled = true;
                break; // Exit loop once slot is found and booked
            }
        }

        if (!scheduled) {
            // Use System.err for error condition (no suitable slot found)
            System.err.println("Error: Could not schedule " + request.getPatientName() +
                               " (requested " + request.getDesiredDoctor() + " at " + request.getRequestedTime() +
                               "). No matching available slot found.");
            // Optionally, re-add the request or log it elsewhere. For this exam, just report failure.
        }
    }

    // Method to view all pending requests in the queue
    public void viewRequestQueue() {
        System.out.println("--- Pending Requests ---");
        if (requestQueue.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (AppointmentRequest request : requestQueue) {
                System.out.println(request);
            }
        }
    }

    // Method to view all available (and booked) time slots
    // Demonstrates using the List interface type for iteration
    public void viewAvailableSlots(List<AvailableSlot> slotsToView) {
        System.out.println("--- All Time Slots ---");
        if (slotsToView.isEmpty()) {
            System.out.println("No slots defined.");
        } else {
            for (AvailableSlot slot : slotsToView) {
                System.out.println(slot);
            }
        }
    }

     // Overloaded method to view only available slots
    public void viewAvailableSlots() {
        System.out.println("--- Available Time Slots ---");
        boolean foundAvailable = false;
        for (AvailableSlot slot : availableSlots) {
            if (slot.isAvailable()) {
                 System.out.println(slot);
                 foundAvailable = true;
            }
        }
        if (!foundAvailable) {
             System.out.println("No available slots at this time.");
        }
    }


    // Method to display the main menu
    private void displayMenu() {
        System.out.println("\n--- Appointment Scheduler Menu ---");
        System.out.println("1. Submit Appointment Request");
        System.out.println("2. Schedule Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Available Slots");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the scheduler
    public void run() {
        int choice = -1;

        // Class-wide try-catch block for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    // Read integer input for menu choice
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Use System.err for input errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line
                    choice = -1; // Reset choice to avoid processing invalid input
                    continue; // Skip to the next loop iteration
                }

                // Use switch statement for menu control flow
                switch (choice) {
                    case 1:
                        submitRequest();
                        break;
                    case 2:
                        scheduleNextRequest();
                        break;
                    case 3:
                        viewRequestQueue();
                        break;
                    case 4:
                         // Call the overloaded method to view only available slots
                        viewAvailableSlots();
                        // Or call the other version to view all slots (demonstrating List interface use)
                        // viewAvailableSlots(availableSlots);
                        break;
                    case 5:
                        System.out.println("Exiting Appointment Scheduler. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid menu options
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might bubble up
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        AppointmentScheduler scheduler = new AppointmentScheduler();
        scheduler.run();
    }
}
