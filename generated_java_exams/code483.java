/*
 * Exam Question #483
 * Generated on: 2025-05-11 23:17:50
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Server Task Scheduler**
 * 
 * **Scenario:**
 * You are tasked with developing a simple simulation of a server's task scheduler. Tasks arrive and are placed in a queue waiting to be processed. Once a task is processed, it is moved to a history log. Your program should allow a user to interact with this scheduler via a console menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with:
 *     *   A unique integer ID (automatically generated starting from 1).
 *     *   A String description.
 *     *   Appropriate constructor, getters, and a `toString()` method.
 * 
 * 2.  **Scheduler Logic:** Create a `TaskScheduler` class responsible for managing tasks. It must contain:
 *     *   A `java.util.Queue` to hold tasks waiting for processing (use a suitable implementation like `LinkedList`).
 *     *   A `java.util.List` (specifically, use `java.util.ArrayList`) to store tasks that have been processed.
 *     *   A method `addTask(String description)` that creates a new `Task` and adds it to the waiting queue. Perform basic validation (e.g., description is not empty).
 *     *   A method `processNextTask()` that removes the next task from the waiting queue and adds it to the completed tasks list. This method should handle the case where the queue is empty by throwing a custom exception.
 *     *   Methods `getWaitingTasks()` and `getCompletedTasks()` that return the current list of waiting and completed tasks, respectively. These methods should return read-only views or copies of the internal collections to prevent external modification.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `TaskSchedulerApp`) with a `main` method that provides a console menu using `java.util.Scanner` for user input. The menu should include options for:
 *     *   Add New Task
 *     *   Process Next Task
 *     *   View Waiting Tasks
 *     *   View Completed Tasks
 *     *   Exit
 * 
 * 4.  **Control Flow and Output:**
 *     *   Use a `switch` statement to handle the menu options.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task listings.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue, invalid task description).
 * 
 * 5.  **Exception Handling:**
 *     *   Create a custom exception class (e.g., `EmptyQueueException`) for the case when `processNextTask()` is called on an empty queue.
 *     *   Implement robust exception handling in the `main` method using `try-catch` blocks to catch:
 *         *   `InputMismatchException` when reading the menu choice.
 *         *   Your custom `EmptyQueueException`.
 *         *   A general `Exception` catch for any other unexpected errors during the main loop operations.
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement input validation where appropriate (e.g., task description).
 * 
 * **Expected Output:**
 * 
 * Your program should run continuously until the user chooses to exit. The output should be clear, presenting the menu, prompting for input, and displaying results or error messages based on the user's actions.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ---------------------------
 * Enter your choice: 1
 * Enter task description: Backup important files
 * Added task: Task [ID=1, Description='Backup important files']
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Run daily report
 * Added task: Task [ID=2, Description='Run daily report']
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Waiting Tasks Queue ---
 * Task [ID=1, Description='Backup important files']
 * Task [ID=2, Description='Run daily report']
 * ---------------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task [ID=1, Description='Backup important files']
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Waiting Tasks Queue ---
 * Task [ID=2, Description='Run daily report']
 * ---------------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks History ---
 * Task [ID=1, Description='Backup important files']
 * -------------------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task [ID=2, Description='Run daily report']
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Error processing task: Cannot process task: Queue is empty. // Output to System.err
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: abc // Invalid input
 * Invalid input. Please enter a number. // Output to System.err
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler. Goodbye!
 * ```
 * 
 * Your solution should be provided as complete, runnable Java code.
 *
 * EXPLANATION:
 * This solution implements the Server Task Scheduler scenario, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** A simple class representing a task with an auto-incrementing ID and a description. It encapsulates task data and provides a useful `toString` method for easy printing.
 * 
 * 2.  **`EmptyQueueException`:** A custom checked exception is created to specifically signal the error condition when attempting to process a task from an empty queue. This provides a clear and type-safe way to handle this specific error.
 * 
 * 3.  **`TaskScheduler` Class:** This class manages the core logic.
 *     *   It uses a `java.util.Queue` (specifically `LinkedList`) for the waiting tasks, naturally implementing a FIFO (First-In, First-Out) order. `LinkedList` is a common choice for `Queue` as it efficiently supports adding to the end (`add`) and removing from the beginning (`poll`).
 *     *   It uses a `java.util.ArrayList` to store the completed tasks. `ArrayList` is suitable here as completed tasks are typically accessed by index or iterated through, and elements are only added (not frequently removed from the middle). The field is typed as `List` to program to the interface.
 *     *   `addTask`: Creates a `Task` object and adds it to the queue using `queue.add()`. Includes basic validation for the description.
 *     *   `processNextTask`: Uses `queue.poll()` to remove and return the head of the queue. If the queue is empty, `poll()` returns `null`, but the implementation checks `queue.isEmpty()` *before* calling `poll()` and throws the custom `EmptyQueueException`, fulfilling the requirement. The processed task is then added to the `completedTasks` list.
 *     *   `getWaitingTasks` and `getCompletedTasks`: These methods return `List` views of the internal collections. Crucially, `Collections.unmodifiableList()` is used to wrap a *copy* of the queue's contents (for `getWaitingTasks`) or the list itself (for `getCompletedTasks`). This prevents external code from modifying the scheduler's internal state directly, adhering to encapsulation principles.
 * 
 * 4.  **`TaskSchedulerApp` Class:** This is the main entry point.
 *     *   The `main` method contains the application loop and user interaction logic.
 *     *   `Scanner` is used to read user input from the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement branches the execution based on the user's integer choice.
 *     *   `System.out` is used for all standard output, including the menu, prompts, success messages, and task listings.
 *     *   `System.err` is specifically used for printing error messages, such as invalid menu input, empty queue errors caught from `processNextTask`, and other unexpected exceptions.
 * 
 * 5.  **Exception Handling:**
 *     *   The `main` method demonstrates robust exception handling.
 *     *   An inner `try-catch` block within the `while` loop handles exceptions that might occur during a single iteration (reading input, performing an action).
 *     *   `InputMismatchException` is caught specifically when `scanner.nextInt()` fails to read an integer. The invalid input is consumed using `scanner.nextLine()` within the catch block to prevent an infinite loop.
 *     *   The custom `EmptyQueueException` thrown by `processNextTask` is caught, and its message is printed to `System.err`.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unforeseen runtime errors during the operation, printing the error message and stack trace to `System.err`.
 *     *   An outer `try-finally` block ensures that the `Scanner` resource is always closed when the application finishes or exits due to an uncaught exception outside the inner loop's handling. This prevents resource leaks.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods (`Task`, `TaskScheduler`) ensure data encapsulation.
 *     *   Variable names (`taskQueue`, `completedTasks`, `description`, `choice`) and method names (`addTask`, `processNextTask`, `getWaitingTasks`) are descriptive.
 *     *   Javadoc comments explain the purpose of classes and methods.
 *     *   Basic input validation for the task description is included in `addTask`.
 *     *   Error handling is specific (`EmptyQueueException`, `InputMismatchException`) where possible and general (`Exception`) as a fallback, directing errors to `System.err`.
 *     *   The code is organized into separate classes, promoting modularity and readability. The menu logic is extracted into a private helper method `printMenu`.
 * 
 * This solution effectively integrates all required components in a practical scenario while demonstrating key object-oriented principles and robust error management techniques.
 */

import java.util.InputMismatchException;
import java.util.List;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable lists

// Custom exception for an empty queue
class EmptyQueueException extends Exception {
    /**
     * Constructs a new EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;

    /**
     * Constructs a new Task with an auto-generated ID and description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string for the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "']";
    }
}

// Manages the task queue and history
class TaskScheduler {
    private Queue<Task> taskQueue; // Tasks waiting to be processed
    private List<Task> completedTasks; // Tasks that have been processed

    /**
     * Constructs a new TaskScheduler with empty queue and history.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the waiting queue.
     * Performs basic validation on the description.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        taskQueue.add(newTask);
        System.out.println("Added task: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the queue and adds it to the completed list.
     * @return The processed task.
     * @throws EmptyQueueException if the task queue is empty.
     */
    public Task processNextTask() throws EmptyQueueException {
        if (taskQueue.isEmpty()) {
            throw new EmptyQueueException("Cannot process task: Queue is empty.");
        }
        Task processedTask = taskQueue.poll(); // Retrieves and removes the head of the queue
        completedTasks.add(processedTask);
        System.out.println("Processed task: " + processedTask);
        return processedTask;
    }

    /**
     * Gets an unmodifiable list of tasks currently in the waiting queue.
     * Returns a copy to prevent external modification of the internal queue state.
     * @return An unmodifiable list of waiting tasks.
     */
    public List<Task> getWaitingTasks() {
        // Create a new ArrayList from the queue's elements and wrap it in an unmodifiable list
        return Collections.unmodifiableList(new ArrayList<>(taskQueue));
    }

    /**
     * Gets an unmodifiable list of tasks that have been completed.
     * Returns an unmodifiable view to prevent external modification of the internal history list.
     * @return An unmodifiable list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Wrap the internal completedTasks list in an unmodifiable list
        return Collections.unmodifiableList(completedTasks);
    }
}

// Main application class for the Task Scheduler
public class TaskSchedulerApp {

    /**
     * Main method to run the Task Scheduler application.
     * Manages user input, menu display, and interacts with the TaskScheduler.
     * Implements class-wide exception handling for core operations.
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Outer try-finally block to ensure scanner is closed
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Inner try-catch block for handling exceptions within each menu iteration
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left after nextInt()

                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            scheduler.addTask(description); // addTask handles basic validation
                            break;
                        case 2: // Process Next Task
                            try {
                                scheduler.processNextTask();
                            } catch (EmptyQueueException e) {
                                // Catch specific exception for empty queue and print to System.err
                                System.err.println("Error processing task: " + e.getMessage());
                            }
                            break;
                        case 3: // View Waiting Tasks
                            List<Task> waiting = scheduler.getWaitingTasks();
                            System.out.println("\n--- Waiting Tasks Queue ---");
                            if (waiting.isEmpty()) {
                                System.out.println("Queue is empty.");
                            } else {
                                waiting.forEach(System.out::println); // Use lambda for printing
                            }
                            System.out.println("---------------------------");
                            break;
                        case 4: // View Completed Tasks
                            List<Task> completed = scheduler.getCompletedTasks();
                            System.out.println("\n--- Completed Tasks History ---");
                            if (completed.isEmpty()) {
                                System.out.println("No tasks completed yet.");
                            } else {
                                completed.forEach(System.out::println); // Use lambda for printing
                            }
                            System.out.println("-------------------------------");
                            break;
                        case 5: // Exit
                            System.out.println("Exiting Task Scheduler. Goodbye!");
                            running = false;
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to error stream for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
            // Ensure the scanner is closed when the application exits or encounters a critical error
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("---------------------------");
    }
}
