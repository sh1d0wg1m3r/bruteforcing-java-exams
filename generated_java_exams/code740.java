/*
 * Exam Question #740
 * Generated on: 2025-05-12 16:33:54
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Software Deployment Pipeline Simulator**
 * 
 * You are tasked with building a simplified simulation of a software deployment pipeline. This system will manage a queue of deployment tasks (like "Build", "Test", "Deploy") and track completed tasks. The user will interact with the system via a command-line interface to add tasks, process the next task, view the status of the pipeline, or exit.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a list of pending deployment tasks in a queue.
 *     *   Maintain a list of completed deployment tasks in a history.
 *     *   Allow the user to add a new task to the end of the pending queue.
 *     *   Allow the user to process the next task from the front of the pending queue, moving it to the completed history.
 *     *   Allow the user to view the current pending queue and the completed history.
 *     *   Allow the user to exit the application.
 * 
 * 2.  **Required Java Components:**
 *     *   Use `java.util.Queue` to manage the pending tasks.
 *     *   Use `java.util.ArrayList` to store the completed task history.
 *     *   Use `java.util.List` as the declared type for the history list variable (demonstrating programming to the interface).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement to handle the different user menu choices.
 *     *   Use `System.err` to print error messages (e.g., invalid input, attempting to process an empty queue).
 *     *   Use `System.out` for printing the menu, status information, task lists, and normal program output.
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input processing and potential runtime issues.
 * 
 * 3.  **Design and Best Practices:**
 *     *   Create a `DeploymentTask` class to represent a single task (at least a task name).
 *     *   Create a `DeploymentPipeline` class to encapsulate the queue and history logic. This class should have private fields for the queue and history and public methods for adding, processing, viewing, etc.
 *     *   Implement input validation where necessary (e.g., ensuring task names are not empty, handling non-integer menu input).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper resource management (closing the `Scanner`).
 * 
 * **User Interaction Flow:**
 * 
 * The program should display a menu like this:
 * 
 * ```
 * Deployment Pipeline Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pipeline Status
 * 4. Exit
 * Enter your choice:
 * ```
 * 
 * *   If the user enters '1', prompt for the task name, create a `DeploymentTask`, and add it to the queue.
 * *   If the user enters '2', remove the next task from the queue, print a message indicating it's being processed, and add it to the history list. If the queue is empty, print an error message using `System.err`.
 * *   If the user enters '3', print the current contents of the pending queue and the completed history list.
 * *   If the user enters '4', print an exit message and terminate the program.
 * *   If the user enters anything else (invalid integer or non-integer), print an error message using `System.err` and re-display the menu.
 * 
 * **Expected Output Format (Example):**
 * 
 * ```
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 1
 * Enter task name: Build
 * Task 'Build' added to the pipeline.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 1
 * Enter task name: Test
 * Task 'Test' added to the pipeline.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 3
 * --- Pipeline Status ---
 * Pending Tasks (Queue):
 * - Build
 * - Test
 * Completed Tasks (History):
 * (Empty)
 * -----------------------
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Build
 * Task 'Build' completed and moved to history.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 3
 * --- Pipeline Status ---
 * Pending Tasks (Queue):
 * - Test
 * Completed Tasks (History):
 * - Build
 * -----------------------
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Test
 * Task 'Test' completed and moved to history.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 2
 * Error: The pipeline is empty. No tasks to process.
 * 
 * Deployment Pipeline Menu:
 * ...
 * Enter your choice: 4
 * Exiting Deployment Pipeline Simulator.
 * ```
 * 
 * Your solution should consist of the `DeploymentTask` class, the `DeploymentPipeline` class, and a main class containing the `main` method to run the simulation.
 *
 * EXPLANATION:
 * The solution provides a command-line simulation of a deployment pipeline, fulfilling all the requirements of the exam task.
 * 
 * **Class Structure:**
 * 1.  `DeploymentTask`: A simple class representing a task with a `name` field. It includes a constructor and a getter, demonstrating basic encapsulation. The `toString()` method is overridden for easy printing.
 * 2.  `DeploymentPipeline`: This class encapsulates the core logic and data structures of the pipeline.
 *     *   It holds a `Queue<DeploymentTask>` named `pendingTasks` for tasks waiting to be processed. A `LinkedList` is used as a concrete implementation of the `Queue` interface.
 *     *   It holds a `List<DeploymentTask>` named `completedHistory` for tasks that have been processed. An `ArrayList` is used as a concrete implementation, but the field is declared as `List` to demonstrate programming to the interface.
 *     *   Public methods (`addTask`, `processNextTask`, `viewStatus`) provide controlled access to the internal state, adhering to encapsulation principles.
 *     *   `addTask` uses `offer()` which is the standard way to add to a queue, returning `false` if the queue is full (though `LinkedList` doesn't have a capacity limit).
 *     *   `processNextTask` uses `poll()` which retrieves and removes the head of the queue, returning `null` if the queue is empty. This `null` return is explicitly checked to handle the empty pipeline error.
 *     *   `viewStatus` iterates through both the queue and the list to display their contents.
 * 3.  `PipelineSimulator`: This class contains the `main` method and drives the user interaction loop.
 * 
 * **Required Component Usage:**
 * *   `Queue`: Used in `DeploymentPipeline` (`pendingTasks`) to manage tasks in a FIFO (First-In, First-Out) manner. `offer()` adds to the tail, `poll()` removes from the head.
 * *   `ArrayList`: Used in `DeploymentPipeline` to instantiate the `completedHistory` list.
 * *   `List`: Used as the declared type for the `completedHistory` field, showing how to use the interface rather than the specific implementation type in the class definition.
 * *   `Scanner`: Used in the `main` method of `PipelineSimulator` to read user input (`nextInt()` for the menu choice, `nextLine()` for task names).
 * *   `Switch statement`: Used in the `main` method to dispatch actions based on the user's integer menu choice.
 * *   `System.err`: Used for printing error messages, such as invalid menu choices, empty task names, or attempting to process an empty queue.
 * *   `System.out`: Used for printing the menu, prompts, success messages, and the pipeline status display.
 * *   `Class-wide exception handling (try-catch)`:
 *     *   A `try-catch(InputMismatchException)` block specifically handles cases where the user enters non-integer input for the menu choice. It catches the exception, prints an error to `System.err`, consumes the invalid input using `scanner.next()`, and continues the loop.
 *     *   A `try-catch(Exception)` block wraps the entire main `while` loop. This serves as a broader catch-all for any other unexpected runtime errors that might occur during program execution, printing the error details to `System.err`.
 *     *   A `finally` block ensures the `Scanner` is closed when the program exits, whether normally or due to an exception.
 * 
 * **Best Practices:**
 * *   **Encapsulation:** The `DeploymentPipeline` and `DeploymentTask` classes hide their internal data (`private` fields) and expose functionality through public methods.
 * *   **Meaningful Names:** Class, variable, and method names clearly indicate their purpose (e.g., `DeploymentTask`, `pendingTasks`, `processNextTask`).
 * *   **Comments and Documentation:** Basic Javadoc comments are included for classes and methods to explain their purpose.
 * *   **Input Validation:** The code checks if the entered task name is empty and handles non-integer input gracefully using `try-catch`.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for different failure conditions (invalid input, empty queue, empty task name). A broader `try-catch` handles unexpected errors.
 * *   **Clean Code Structure:** The code is divided into logical classes, and the `main` method focuses on user interaction and calling pipeline methods. The menu printing is extracted into a separate helper method.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, albeit simplified, application scenario, making it a suitable challenge for an exam.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single deployment task.
 */
class DeploymentTask {
    private String name;

    /**
     * Constructs a new DeploymentTask with the given name.
     * @param name The name of the task.
     */
    public DeploymentTask(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the task.
     * @return The task name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Manages the deployment pipeline, including pending tasks and history.
 */
class DeploymentPipeline {
    private Queue<DeploymentTask> pendingTasks;
    private List<DeploymentTask> completedHistory; // Declared as List, initialized with ArrayList

    /**
     * Constructs a new DeploymentPipeline.
     */
    public DeploymentPipeline() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedHistory = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a task to the end of the pending queue.
     * @param task The task to add.
     */
    public void addTask(DeploymentTask task) {
        if (task != null) {
            pendingTasks.offer(task); // offer is preferred over add for queues
            System.out.println("Task '" + task.getName() + "' added to the pipeline.");
        }
    }

    /**
     * Processes the next task from the front of the queue.
     * Moves the completed task to the history.
     * Prints an error if the queue is empty.
     */
    public void processNextTask() {
        DeploymentTask nextTask = pendingTasks.poll(); // poll retrieves and removes the head
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask.getName());
            // Simulate processing time or logic here if needed
            completedHistory.add(nextTask);
            System.out.println("Task '" + nextTask.getName() + "' completed and moved to history.");
        } else {
            System.err.println("Error: The pipeline is empty. No tasks to process.");
        }
    }

    /**
     * Displays the current status of the pipeline (pending queue and history).
     */
    public void viewStatus() {
        System.out.println("--- Pipeline Status ---");
        System.out.println("Pending Tasks (Queue):");
        if (pendingTasks.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (DeploymentTask task : pendingTasks) {
                System.out.println("- " + task.getName());
            }
        }

        System.out.println("Completed Tasks (History):");
        if (completedHistory.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (DeploymentTask task : completedHistory) {
                System.out.println("- " + task.getName());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Checks if the pending task queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isPipelineEmpty() {
        return pendingTasks.isEmpty();
    }
}

/**
 * Main class to run the Deployment Pipeline Simulator.
 * Handles user interaction and menu loop.
 */
public class PipelineSimulator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DeploymentPipeline pipeline = new DeploymentPipeline();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Try-catch for input reading
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Ensure the newline character after nextInt() is consumed
                     // This is important before the next nextLine() call
                     scanner.nextLine();
                }

                // Switch statement for menu handling
                switch (choice) {
                    case 1:
                        System.out.print("Enter task name: ");
                        String taskName = scanner.nextLine().trim();
                        if (taskName.isEmpty()) {
                            System.err.println("Error: Task name cannot be empty.");
                        } else {
                            pipeline.addTask(new DeploymentTask(taskName));
                        }
                        break;
                    case 2:
                        pipeline.processNextTask();
                        break;
                    case 3:
                        pipeline.viewStatus();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting Deployment Pipeline Simulator.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Deployment Pipeline Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pipeline Status");
        System.out.println("4. Exit");
    }
}
