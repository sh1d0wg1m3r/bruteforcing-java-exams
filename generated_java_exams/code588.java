/*
 * Exam Question #588
 * Generated on: 2025-05-12 16:11:19
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Assembly Line Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation for a manufacturing assembly line. The line processes "parts" one by one in the order they arrive. Parts waiting for processing are held in a queue. Once a part is processed, it is moved to a list of completed parts. The system should allow a user to interact with the assembly line through a command-line interface.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this assembly line. Your program should consist of at least three classes:
 * 
 * 1.  `Part`: Represents an item being processed. It should have a unique integer ID and a status (e.g., "Pending", "Completed").
 * 2.  `AssemblyLine`: Manages the processing queue and the list of completed parts. It should provide methods to add parts, process the next part, and retrieve the current state of the queue and completed list.
 * 3.  `AssemblyLineManager`: Contains the `main` method and handles user interaction via the console. It should present a menu and call the appropriate methods in the `AssemblyLine` class based on user input.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the `Part` class:**
 *     *   Private fields for ID (int) and status (String).
 *     *   A constructor that takes the ID and initializes the status to "Pending".
 *     *   Input validation in the constructor to ensure the ID is a positive integer. Throw `IllegalArgumentException` if not.
 *     *   Public getter methods for ID and status.
 *     *   A method to update the status to "Completed". Ensure status can only be set to "Completed" from "Pending".
 *     *   Override `toString()` to provide a clear string representation (e.g., "Part [ID=123, Status=Pending]").
 * 
 * 2.  **Implement the `AssemblyLine` class:**
 *     *   Private fields:
 *         *   A `Queue<Part>` to hold parts waiting for processing. Use a concrete implementation from `java.util`.
 *         *   A `List<Part>` to hold completed parts. Use a concrete implementation from `java.util`.
 *     *   A constructor to initialize the queue and list.
 *     *   `public void addPart(Part part)`: Adds a `Part` to the processing queue.
 *     *   `public Part processNextPart()`:
 *         *   Removes the next `Part` from the front of the queue.
 *         *   Updates the part's status to "Completed".
 *         *   Adds the processed part to the list of completed parts.
 *         *   Return the processed `Part` object, or `null` if the queue was empty.
 *     *   `public Queue<Part> getProcessingQueue()`: Returns the processing queue.
 *     *   `public List<Part> getCompletedParts()`: Returns the list of completed parts.
 * 
 * 3.  **Implement the `AssemblyLineManager` class:**
 *     *   Contains the `main` method.
 *     *   Uses `java.util.Scanner` to read user input from the console.
 *     *   Presents the following menu loop until the user chooses to exit:
 *         ```
 *         --- Assembly Line Menu ---
 *         1. Add New Part
 *         2. Process Next Part
 *         3. View Processing Queue
 *         4. View Completed Parts
 *         5. Exit
 *         Enter your choice:
 *         ```
 *     *   Uses a `switch` statement to handle the user's menu choice.
 *     *   **MUST** use a **class-wide `try-catch` block** within the main interaction loop to handle potential exceptions that might occur during user input processing or method calls (e.g., `NumberFormatException` when parsing input, `IllegalArgumentException` from `Part` constructor).
 *     *   Use `System.out` for menu display, prompts, success messages, and displaying queue/list contents.
 *     *   Use `System.err` to print error messages (e.g., invalid input, empty queue when trying to process, invalid Part ID).
 * 
 * 4.  **General Requirements:**
 *     *   Use ALL of the following Java components: `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, class-wide `try-catch` block.
 *     *   Adhere to best practices: proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments (Javadocs are recommended), input validation, and proper error handling.
 *     *   Ensure the `Scanner` is closed properly when the application exits.
 * 
 * **Example Interaction:**
 * 
 * ```
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 1
 * Enter new Part ID: 101
 * Part ID 101 added to the processing queue.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 1
 * Enter new Part ID: abc
 * Error: Invalid ID format. Please enter an integer.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 1
 * Enter new Part ID: -5
 * Error adding part: Part ID must be positive.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Processing Queue ---
 * Part [ID=101, Status=Pending]
 * -----------------------
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 2
 * Successfully processed Part [ID=101, Status=Completed]
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Processing Queue ---
 * Queue is empty.
 * -----------------------
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Parts ---
 * Part [ID=101, Status=Completed]
 * -----------------------
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 2
 * Processing queue is currently empty. No parts to process.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Part
 * 2. Process Next Part
 * 3. View Processing Queue
 * 4. View Completed Parts
 * 5. Exit
 * Enter your choice: 5
 * Exiting Assembly Line system. Goodbye!
 * ```
 * 
 * Your code should produce output similar to this example, handling both valid and invalid inputs and operations.
 *
 * EXPLANATION:
 * The solution implements the Assembly Line Management System using three classes: `Part`, `AssemblyLine`, and `AssemblyLineManager`, fulfilling the problem requirements.
 * 
 * 1.  **`Part` Class:**
 *     *   Represents a single part with a unique `id` and a `status`.
 *     *   Fields are `private` (`id`, `status`) demonstrating encapsulation.
 *     *   The constructor validates that the `id` is positive, throwing an `IllegalArgumentException` for invalid input. This is a form of input validation at the object creation level.
 *     *   Provides public getters (`getId`, `getStatus`).
 *     *   `setStatusToCompleted()` method controls how the status can be changed, ensuring it only transitions to "Completed".
 *     *   `toString()` provides a user-friendly representation for printing.
 * 
 * 2.  **`AssemblyLine` Class:**
 *     *   Manages the two core data structures: `processingQueue` and `completedParts`.
 *     *   `processingQueue` is declared as a `Queue<Part>` and instantiated as a `java.util.LinkedList`. The `Queue` interface ensures FIFO (First-In, First-Out) behavior, crucial for simulating an assembly line where items are processed in the order they arrive. Methods like `offer()` (for adding) and `poll()` (for removing from the head) are used, which are standard `Queue` operations.
 *     *   `completedParts` is declared as a `List<Part>` and instantiated as a `java.util.ArrayList`. The `List` interface, implemented by `ArrayList`, allows storing the completed parts in a dynamic, ordered collection, easily allowing iteration and viewing.
 *     *   `addPart()` uses `queue.offer()` to add a part to the end of the queue.
 *     *   `processNextPart()` uses `queue.poll()` to retrieve and remove the part at the front of the queue. It handles the case where the queue is empty by returning `null`. If a part is retrieved, its status is updated, and it's added to the `completedParts` list.
 *     *   `getProcessingQueue()` and `getCompletedParts()` provide access to the internal data structures for viewing.
 * 
 * 3.  **`AssemblyLineManager` Class:**
 *     *   Contains the `main` method, serving as the application's entry point.
 *     *   Uses `java.util.Scanner` (`scanner`) to read user input from `System.in`. Reading the entire line (`nextLine()`) before parsing is generally safer when mixing line-based and token-based input.
 *     *   The core application logic resides in the `run()` method, which contains a `while(running)` loop for continuous user interaction.
 *     *   A `displayMenu()` method uses `System.out` to show the user options.
 *     *   A `switch` statement is used within the loop to direct the program flow based on the user's integer choice.
 *     *   **Class-wide Exception Handling:** The `run()` method features a `try-catch` block that wraps the core logic for processing a single menu choice (reading input, parsing, executing the `switch` case). This block catches potential `NumberFormatException` (if the main menu input isn't an integer) and `IllegalArgumentException` (which might be thrown by the `Part` constructor when adding a part, and allowed to propagate up). Error messages caught by this main block, or specific errors handled within helper methods like `addPartAction`, are printed to `System.err`. This demonstrates handling errors at a higher level in the application's main loop.
 *     *   Helper methods (`addPartAction`, `processPartAction`, `viewQueueAction`, `viewCompletedAction`) encapsulate the logic for each menu option, improving code organization. `addPartAction` includes specific `try-catch` blocks for parsing the Part ID and handling the `IllegalArgumentException` from the `Part` constructor, demonstrating more granular error handling before potentially falling back to the main catch in `run()`.
 *     *   `System.out` is used for all standard output, including the menu, prompts, success messages, and displaying the contents of the queue and list.
 *     *   `System.err` is specifically used for printing error messages, distinguishing them from normal program output.
 *     *   The `scanner.close()` call in the `run()` method ensures the `Scanner` resource is released when the application exits.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, demonstrating advanced concepts like object-oriented design, data structure usage, input validation, and robust error handling.
 */

package com.example.assemblyline;

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although using nextLine and parseInt avoids this directly

/**
 * Represents a part processed on the assembly line.
 */
class Part {
    private int id;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Part with the given ID and initial status "Pending".
     *
     * @param id The unique identifier for the part. Must be positive.
     * @throws IllegalArgumentException if the part ID is not positive.
     */
    public Part(int id) {
        if (id <= 0) {
            throw new IllegalArgumentException("Part ID must be positive.");
        }
        this.id = id;
        this.status = "Pending";
    }

    /**
     * Gets the ID of the part.
     *
     * @return The part ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the current status of the part.
     *
     * @return The part status ("Pending" or "Completed").
     */
    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the part to "Completed".
     * This method only allows setting the status to "Completed" if it's not already "Completed".
     */
    public void setStatusToCompleted() {
        if (!"Completed".equals(this.status)) {
            this.status = "Completed";
        }
        // Optionally add a log/error if trying to set to non-completed or already completed
    }

    /**
     * Provides a string representation of the Part.
     *
     * @return A formatted string showing the part ID and status.
     */
    @Override
    public String toString() {
        return "Part [ID=" + id + ", Status=" + status + "]";
    }
}

/**
 * Manages the assembly line process, holding parts in a queue and completed parts in a list.
 */
class AssemblyLine {
    // Queue to hold parts waiting for processing (FIFO)
    private Queue<Part> processingQueue;
    // List to hold parts that have been processed
    private List<Part> completedParts;

    /**
     * Constructs an AssemblyLine with empty processing queue and completed parts list.
     */
    public AssemblyLine() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedParts = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new part to the end of the processing queue.
     *
     * @param part The Part object to add.
     */
    public void addPart(Part part) {
        if (part == null) {
            System.err.println("Cannot add a null part.");
            return; // Or throw an exception
        }
        this.processingQueue.offer(part); // offer is standard for adding to queue
        System.out.println("Part ID " + part.getId() + " added to the processing queue.");
    }

    /**
     * Processes the next part from the front of the queue.
     * Removes the part, updates its status to "Completed", and adds it to the completed list.
     *
     * @return The processed Part object, or null if the queue was empty.
     */
    public Part processNextPart() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Part nextPart = processingQueue.poll();

        if (nextPart != null) {
            // Simulate processing: update status
            nextPart.setStatusToCompleted();
            // Add to the list of completed parts
            completedParts.add(nextPart);
            return nextPart;
        } else {
            // Queue was empty
            return null;
        }
    }

    /**
     * Gets the current processing queue.
     * Note: Returning the direct reference allows external modification.
     * For a real application, consider returning an unmodifiable view.
     *
     * @return The Queue of parts waiting processing.
     */
    public Queue<Part> getProcessingQueue() {
        return processingQueue;
    }

    /**
     * Gets the list of completed parts.
     * Note: Returning the direct reference allows external modification.
     * For a real application, consider returning an unmodifiable view.
     *
     * @return The List of parts that have been processed.
     */
    public List<Part> getCompletedParts() {
        return completedParts;
    }
}

/**
 * Main class to manage the Assembly Line system via user interaction.
 * Provides a command-line interface using Scanner and a switch statement.
 * Includes class-wide exception handling.
 */
public class AssemblyLineManager {

    private AssemblyLine assemblyLine;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs the AssemblyLineManager, initializing the line and scanner.
     */
    public AssemblyLineManager() {
        assemblyLine = new AssemblyLine();
        scanner = new Scanner(System.in);
        running = true;
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Assembly Line Menu ---");
        System.out.println("1. Add New Part");
        System.out.println("2. Process Next Part");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Completed Parts");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main user interaction loop.
     * Includes a class-wide try-catch block covering the core menu operations.
     * Handles input parsing and calls appropriate AssemblyLine methods.
     */
    public void run() {
        while (running) {
            displayMenu();

            // --- Class-wide try-catch block ---
            // This block attempts to handle potential exceptions that occur during
            // the processing of a single menu interaction loop iteration.
            try {
                String choiceStr = scanner.nextLine(); // Read the entire line to avoid issues with nextInt/nextDouble
                int choice = Integer.parseInt(choiceStr); // Potential NumberFormatException

                // --- Switch statement for flow control ---
                switch (choice) {
                    case 1:
                        addPartAction(); // This method has its own inner try-catch for specific input errors
                        break;
                    case 2:
                        processPartAction();
                        break;
                    case 3:
                        viewQueueAction();
                        break;
                    case 4:
                        viewCompletedAction();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Assembly Line system. Goodbye!");
                        break;
                    default:
                        System.out.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch specific error for non-integer input for the main menu choice
                System.err.println("Error: Invalid input for menu choice. Please enter a number.");
                // Optionally log the error: e.printStackTrace();
            } catch (IllegalArgumentException e) {
                 // Catch validation errors that might propagate from Part constructor
                 System.err.println("Error during operation: " + e.getMessage());
                 // This catch demonstrates handling specific exceptions that might bubble up
            }
            // A general 'catch (Exception e)' could be added here to catch any other unexpected errors,
            // but it's often better to catch more specific exceptions.
            // catch (Exception e) {
            //     System.err.println("An unexpected error occurred: " + e.getMessage());
            //     e.printStackTrace(); // Print stack trace for debugging
            // }
        }
        scanner.close(); // Ensure the scanner is closed when the application exits
    }

    /**
     * Handles the "Add New Part" action. Prompts user for Part ID and adds it.
     * Includes specific error handling for ID input.
     */
    private void addPartAction() {
        System.out.print("Enter new Part ID: ");
        String idStr = scanner.nextLine();
        try {
            int partId = Integer.parseInt(idStr); // Potential NumberFormatException
            // Part constructor throws IllegalArgumentException if ID is not positive
            Part newPart = new Part(partId);
            assemblyLine.addPart(newPart);
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid ID format. Please enter an integer.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding part: " + e.getMessage());
        }
    }

    /**
     * Handles the "Process Next Part" action. Calls AssemblyLine to process.
     */
    private void processPartAction() {
        Part processedPart = assemblyLine.processNextPart();
        if (processedPart != null) {
            System.out.println("Successfully processed " + processedPart);
        } else {
            System.out.println("Processing queue is currently empty. No parts to process.");
        }
    }

    /**
     * Handles the "View Processing Queue" action. Prints the queue contents.
     */
    private void viewQueueAction() {
        Queue<Part> queue = assemblyLine.getProcessingQueue();
        System.out.println("\n--- Processing Queue ---");
        if (queue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate and print queue elements using forEach and Part's toString()
            queue.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Handles the "View Completed Parts" action. Prints the completed list contents.
     */
    private void viewCompletedAction() {
        List<Part> completed = assemblyLine.getCompletedParts();
        System.out.println("\n--- Completed Parts ---");
        if (completed.isEmpty()) {
            System.out.println("No parts have been completed yet.");
        } else {
            // Iterate and print list elements using forEach and Part's toString()
            completed.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Main method to start the Assembly Line Management application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineManager manager = new AssemblyLineManager();
        manager.run(); // Start the main interaction loop
    }
}
