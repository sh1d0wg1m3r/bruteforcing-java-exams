/*
 * Exam Question #275
 * Generated on: 2025-05-11 22:48:19
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified hospital appointment scheduling system. The system needs to manage a list of all registered patients and maintain a queue of patients currently waiting for their appointments. The system should allow receptionists to register new patients, add registered patients to the waiting queue, and doctors to call the next patient from the queue.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Patient Representation:** Create a simple `Patient` class with fields for patient ID (an integer) and name (a String). Include appropriate constructor, getters, and a `toString()` method.
 * 2.  **HospitalScheduler Class:** Create a `HospitalScheduler` class that manages the patients and the appointment queue.
 *     *   It must have a private field to store all registered patients. This field must be declared using the `java.util.List` interface and implemented using `java.util.ArrayList`.
 *     *   It must have a private field to store patients currently waiting in the appointment queue. This field must be declared using the `java.util.Queue` interface and implemented using `java.util.LinkedList` (which implements `Queue`).
 *     *   Include a simple mechanism to generate unique patient IDs (e.g., an auto-incrementing counter).
 *     *   Implement public methods for the following operations:
 *         *   `registerPatient(String name)`: Registers a new patient with a unique ID and adds them to the list of registered patients. Should print confirmation to `System.out`.
 *         *   `addPatientToQueue(int patientId)`: Finds a registered patient by ID and adds them to the appointment queue. Must validate that the patient ID exists in the registered patients list. Print confirmation to `System.out`.
 *         *   `callNextPatient()`: Removes and returns the patient at the front of the queue (the next patient to be seen). Must handle the case where the queue is empty and print an error message to `System.err`. Otherwise, print which patient is being called to `System.out`.
 *         *   `displayRegisteredPatients()`: Prints a list of all registered patients to `System.out`. Indicate if the list is empty.
 *         *   `displayAppointmentQueue()`: Prints the current list of patients in the waiting queue (without removing them) to `System.out`. Indicate if the queue is empty.
 *     *   Include a private helper method `findPatientById(int patientId)` to search for a patient in the registered patients list.
 * 3.  **Main Program Flow:**
 *     *   In the `main` method of the `HospitalScheduler` class (or a separate main class), create an instance of `HospitalScheduler`.
 *     *   Use `java.util.Scanner` to interact with the user via the console.
 *     *   Present a menu of options to the user:
 *         1.  Register New Patient
 *         2.  Add Patient to Appointment Queue (by ID)
 *         3.  Call Next Patient from Queue
 *         4.  Display Registered Patients
 *         5.  Display Appointment Queue
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement basic input validation for the menu choice (ensure it's a number within the valid range). Handle non-integer input gracefully using `Scanner` methods and print an error to `System.err`.
 *     *   Handle potential errors during operations (e.g., patient not found, queue empty) by printing informative messages to `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch any unexpected runtime exceptions and print an error message and stack trace to `System.err`. Include a `finally` block to ensure the `Scanner` is closed.
 * 4.  **Best Practices:**
 *     *   Use appropriate access modifiers (private fields, public methods where needed).
 *     *   Use meaningful variable and method names.
 *     *   Include comments or Javadoc for clarity.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Based on user input, it should perform the requested actions, printing confirmations, lists, or error messages to the console using `System.out` for normal output and `System.err` for errors.
 * 
 * Example interaction snippets:
 * 
 * ```
 * --- Hospital Appointment Scheduler ---
 * 
 * Choose an action:
 * 1. Register New Patient
 * ...
 * Enter choice: 1
 * Enter patient name: Alice
 * Patient registered: Patient{ID=1, Name='Alice'}
 * 
 * Choose an action:
 * ...
 * Enter choice: 4
 * 
 * --- Registered Patients ---
 * Patient{ID=1, Name='Alice'}
 * ---------------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Enter patient ID to add to queue: 1
 * Patient Alice (ID: 1) added to the appointment queue.
 * 
 * Choose an action:
 * ...
 * Enter choice: 5
 * 
 * --- Appointment Queue ---
 * Patient{ID=1, Name='Alice'}
 * -------------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * Calling next patient: Alice (ID: 1). Removed from queue.
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * Error: The appointment queue is empty. No patients waiting.
 * 
 * Choose an action:
 * ...
 * Enter choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Choose an action:
 * ...
 * Enter choice: 6
 * Exiting scheduler. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Effective input validation and error handling.
 * *   Clean and readable code.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment scheduler demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Patient Class:** A simple POJO (`Patient`) is created to encapsulate patient data (ID and name) with private fields and public getters, demonstrating encapsulation. The `toString()` method provides a convenient way to print patient information.
 * 
 * 2.  **HospitalScheduler Class:**
 *     *   **Data Structures:**
 *         *   `registeredPatients`: Declared as `List<Patient>` and initialized as `new ArrayList<>()`. This demonstrates using the `List` interface for flexibility while using `ArrayList` as the concrete implementation. `ArrayList` is suitable here for storing a dynamic list of all patients, allowing efficient access by index (though not used directly in this solution) and iteration.
 *         *   `appointmentQueue`: Declared as `Queue<Patient>` and initialized as `new LinkedList<>()`. This uses the `Queue` interface, correctly representing a waiting list where elements are added at one end (`offer`) and removed from the other (`poll`), following the FIFO (First-In, First-Out) principle. `LinkedList` is a common implementation of the `Queue` interface.
 *     *   **Methods:** Public methods like `registerPatient`, `addPatientToQueue`, `callNextPatient`, `displayRegisteredPatients`, and `displayAppointmentQueue` provide the core functionality, adhering to the principle of exposing necessary operations while keeping internal data (`registeredPatients`, `appointmentQueue`, `nextPatientId`) private. A private helper method `findPatientById` is used internally, hiding implementation details.
 *     *   **Patient ID:** A simple `nextPatientId` counter is used to generate unique IDs for new patients, incrementing each time a patient is registered.
 * 
 * 3.  **Main Method (`main`):**
 *     *   **Scanner:** A `Scanner` object is created to read user input from `System.in`.
 *     *   **Main Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **Menu and Switch:** A menu of options is printed to `System.out`. The user's integer input is read, and a `switch` statement is used to direct the program flow to the corresponding method call in the `HospitalScheduler` instance. This demonstrates using `switch` for multi-way branching based on discrete values.
 *     *   **Input Validation:** Basic validation is performed for the menu choice (`scanner.hasNextInt()` and checking the range in the `default` case) and for the patient ID input in case 2. If invalid input is detected, an error message is printed to `System.err`, and the invalid input is consumed using `scanner.next()` to prevent issues in subsequent reads. `scanner.nextLine()` is used after reading integers to consume the leftover newline character.
 *     *   **System.out and System.err:** `System.out.println()` is used for printing the menu, prompts, success messages, and lists of patients/queue contents. `System.err.println()` is specifically used for printing error messages (e.g., invalid input, patient not found, queue empty), directing error output to the standard error stream as required.
 *     *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the entire `while` loop in the `main` method. This provides a form of "class-wide" handling for any unexpected `Exception` that might occur during the execution of the main application logic. If an exception is caught, an informative message and the stack trace are printed to `System.err`.
 *     *   **Finally Block:** A `finally` block is included after the `try-catch` to ensure that the `scanner.close()` method is called regardless of whether an exception occurred or the loop finished normally. This is crucial for releasing system resources associated with the `Scanner`.
 * 
 * 4.  **Error Handling:** Specific error conditions like attempting to add a non-existent patient to the queue or calling a patient from an empty queue are checked within the `HospitalScheduler` methods, printing relevant messages to `System.err`. Input validation in `main` also uses `System.err`.
 * 
 * 5.  **Best Practices:** The code uses private fields, public methods, meaningful names (`registeredPatients`, `appointmentQueue`, `callNextPatient`), includes basic comments, and is structured into logical classes and methods.
 * 
 * This solution effectively integrates all required Java components to solve a practical problem, demonstrating understanding of collection interfaces and implementations, input handling, control flow, encapsulation, and error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String name;
    private int id;

    /**
     * Constructs a new Patient object.
     * @param name The name of the patient.
     * @param id The unique ID of the patient.
     */
    public Patient(String name, int id) {
        this.name = name;
        this.id = id;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the ID of the patient.
     * @return The patient's ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Returns a string representation of the Patient object.
     * @return A formatted string containing patient ID and name.
     */
    @Override
    public String toString() {
        return "Patient{ID=" + id + ", Name='" + name + "'}";
    }
}

/**
 * Manages hospital appointments using a patient registry and a waiting queue.
 */
public class HospitalScheduler {

    // Private fields using required interfaces and implementations
    private List<Patient> registeredPatients; // Stores all registered patients
    private Queue<Patient> appointmentQueue; // Stores patients waiting for appointment
    private int nextPatientId = 1; // Simple counter for generating unique patient IDs

    /**
     * Constructs a new HospitalScheduler.
     * Initializes the patient registry (ArrayList) and the appointment queue (LinkedList).
     */
    public HospitalScheduler() {
        registeredPatients = new ArrayList<>();
        appointmentQueue = new LinkedList<>();
    }

    /**
     * Registers a new patient in the system.
     * Assigns a unique ID and adds the patient to the registered patients list.
     * @param name The name of the patient to register. Must not be null or empty.
     */
    public void registerPatient(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty or just whitespace.");
            return;
        }
        Patient newPatient = new Patient(name.trim(), nextPatientId++);
        registeredPatients.add(newPatient);
        System.out.println("Patient registered successfully: " + newPatient);
    }

    /**
     * Adds a registered patient to the appointment waiting queue.
     * Finds the patient by ID and adds them to the end of the queue.
     * Prints an error to System.err if the patient ID is not found.
     * @param patientId The ID of the registered patient to add to the queue.
     */
    public void addPatientToQueue(int patientId) {
        Patient patientToAdd = findPatientById(patientId);
        if (patientToAdd == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found in registered patients. Cannot add to queue.");
            return;
        }
        // offer is generally preferred over add for queues as it handles capacity issues gracefully (though LinkedList doesn't have capacity limit)
        appointmentQueue.offer(patientToAdd);
        System.out.println("Patient " + patientToAdd.getName() + " (ID: " + patientId + ") added to the appointment queue.");
    }

    /**
     * Calls the next patient from the appointment queue.
     * Removes the patient at the front of the queue.
     * Prints an error to System.err if the queue is empty.
     */
    public void callNextPatient() {
        if (appointmentQueue.isEmpty()) {
            System.err.println("Error: The appointment queue is empty. No patients waiting to be called.");
            return;
        }
        // poll retrieves and removes the head of this queue, or returns null if this queue is empty.
        // We already checked isEmpty, so poll won't return null here.
        Patient nextPatient = appointmentQueue.poll();
        System.out.println("Calling next patient: " + nextPatient.getName() + " (ID: " + nextPatient.getId() + "). Removed from queue.");
    }

    /**
     * Displays all registered patients in the system.
     * Prints "No patients registered yet." if the list is empty.
     */
    public void displayRegisteredPatients() {
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients registered yet.");
            return;
        }
        System.out.println("\n--- Registered Patients ---");
        // Iterate through the List to display patients
        for (Patient patient : registeredPatients) {
            System.out.println(patient);
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays the current appointment waiting queue.
     * Prints the patients currently in the queue without removing them.
     * Prints "The appointment queue is empty." if the queue is empty.
     */
    public void displayAppointmentQueue() {
        if (appointmentQueue.isEmpty()) {
            System.out.println("The appointment queue is empty.");
            return;
        }
        System.out.println("\n--- Appointment Queue ---");
        // Iterate through the Queue (e.g., using forEach or an iterator) to display patients without removing
        appointmentQueue.forEach(patient -> System.out.println(patient));
        System.out.println("-------------------------");
    }

    /**
     * Finds a registered patient by their unique ID.
     * This is a private helper method as it's only used internally.
     * @param patientId The ID to search for.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientById(int patientId) {
        // Search through the ArrayList of registered patients
        for (Patient patient : registeredPatients) {
            if (patient.getId() == patientId) {
                return patient;
            }
        }
        return null; // Patient not found
    }

    /**
     * Main method to run the Hospital Appointment Scheduler application.
     * Handles user interaction, menu display, and calls scheduler methods.
     * Includes class-wide exception handling with try-catch-finally.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use Scanner for user input from System.in
        Scanner scanner = new Scanner(System.in);
        HospitalScheduler scheduler = new HospitalScheduler();
        boolean running = true;

        System.out.println("--- Hospital Appointment Scheduler ---");

        // Class-wide exception handling using a try-catch block
        try {
            while (running) {
                System.out.println("\nChoose an action:");
                System.out.println("1. Register New Patient");
                System.out.println("2. Add Patient to Appointment Queue (by ID)");
                System.out.println("3. Call Next Patient from Queue");
                System.out.println("4. Display Registered Patients");
                System.out.println("5. Display Appointment Queue");
                System.out.println("6. Exit");
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice
                // Input validation: Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number (1-6).");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }
                // Consume the rest of the line after reading the integer
                // This is important to clear the buffer for the next nextLine() calls
                scanner.nextLine();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter patient name: ");
                        String name = scanner.nextLine();
                        scheduler.registerPatient(name);
                        break;
                    case 2:
                        System.out.print("Enter patient ID to add to queue: ");
                        // Input validation for patient ID
                        if (scanner.hasNextInt()) {
                            int id = scanner.nextInt();
                            scheduler.addPatientToQueue(id);
                        } else {
                            System.err.println("Invalid input. Please enter a valid patient ID (a number).");
                            scanner.next(); // Consume invalid input
                        }
                        scanner.nextLine(); // Consume newline
                        break;
                    case 3:
                        scheduler.callNextPatient();
                        break;
                    case 4:
                        scheduler.displayRegisteredPatients();
                        break;
                    case 5:
                        scheduler.displayAppointmentQueue();
                        break;
                    case 6:
                        System.out.println("Exiting scheduler. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("\nAn unexpected error occurred during application execution:");
            System.err.println("Error details: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure resources are cleaned up, specifically the Scanner
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }
}
