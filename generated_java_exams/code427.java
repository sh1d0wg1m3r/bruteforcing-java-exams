/*
 * Exam Question #427
 * Generated on: 2025-05-11 23:09:54
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Document Processing Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a document processing workflow for a small office. Documents arrive and are placed in a queue to await processing. An operator can process the next document in the queue, moving it to a list of completed documents. The operator can also view the current queue and the list of processed documents. The system should handle user commands via the console.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this document processing system. Your solution must demonstrate advanced understanding of core Java concepts by adhering to the following specific requirements and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to represent the processing queue (First-In, First-Out).
 *     *   Use `java.util.List` (specifically implemented with `java.util.ArrayList`) to store completed documents.
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands from the console (`System.in`).
 *     *   Use `System.out` for displaying normal program output (status messages, list contents, prompts).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty when processing).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle different user commands.
 *     *   Implement a loop to continuously accept commands until an "exit" command is received.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to manage potential runtime errors during command processing or input validation.
 *     *   Implement input validation for commands (e.g., checking for required arguments, non-empty document ID).
 *     *   Handle the specific case where the "process" command is issued but the queue is empty.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `Document` class to represent a document (at least with an ID and description).
 *     *   Create a `DocumentProcessor` class that encapsulates the processing logic and data structures (`Queue`, `List`).
 *     *   Use private fields and public methods (`addDocument`, `processNextDocument`, `viewQueue`, `viewCompleted`, `runInteractionLoop`) for proper encapsulation.
 * 6.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Structure the code cleanly.
 * 
 * **Commands:**
 * 
 * The program should accept the following commands (case-insensitive):
 * 
 * *   `add <id> <description>`: Adds a new document with the given ID and description to the processing queue. The ID must not be empty. The description can contain spaces.
 * *   `process`: Processes the next document from the front of the queue, moving it to the completed list.
 * *   `view queue`: Displays the documents currently in the processing queue in order.
 * *   `view completed`: Displays the documents in the completed list.
 * *   `exit`: Terminates the program.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Document Processing System
 * Available commands: add <id> <description>, process, view queue, view completed, exit
 * > add doc1 Report for Q1
 * Document added to queue: [doc1] Report for Q1
 * > add doc2 Analysis of Data
 * Document added to queue: [doc2] Analysis of Data
 * > view queue
 * 
 * --- Processing Queue ---
 * 1. [doc1] Report for Q1
 * 2. [doc2] Analysis of Data
 * ------------------------
 * 
 * > process
 * Document processed: doc1
 * > view queue
 * 
 * --- Processing Queue ---
 * 1. [doc2] Analysis of Data
 * ------------------------
 * 
 * > view completed
 * 
 * --- Completed Documents ---
 * 1. [doc1] Report for Q1
 * ---------------------------
 * 
 * > process
 * Document processed: doc2
 * > process
 * Processing queue is empty. No documents to process.  (This message should go to System.err)
 * > view completed
 * 
 * --- Completed Documents ---
 * 1. [doc1] Report for Q1
 * 2. [doc2] Analysis of Data
 * ---------------------------
 * 
 * > add doc3 Final Summary
 * Document added to queue: [doc3] Final Summary
 * > view queue
 * 
 * --- Processing Queue ---
 * 1. [doc3] Final Summary
 * ------------------------
 * 
 * > exit
 * Exiting Document Processing System.
 * ```
 * 
 * Invalid command format or empty ID should result in an error message printed to `System.err`.
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Document Processing Simulation according to the requirements, demonstrating the use of various core Java concepts.
 * 
 * 1.  **`Document` Class:** A simple class `Document` is defined to hold the data for each document: a `private String id` and a `private String description`. It includes a constructor and public getter methods (`getId`, `getDescription`), following encapsulation principles. The `toString()` method is overridden for easy printing of document details.
 * 
 * 2.  **`DocumentProcessor` Class:** This is the main class containing the application logic.
 *     *   **Data Structures:** It holds two private member variables:
 *         *   `private Queue<Document> processingQueue;`: Declared as `Queue` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing the necessary FIFO behavior.
 *         *   `private List<Document> completedDocuments;`: Declared as `List` and initialized with `new ArrayList<>()`. `ArrayList` is a standard resizable array implementation of the `List` interface, suitable for storing processed documents.
 *     *   **Input:** `private Scanner scanner;` is initialized in the constructor to read input from `System.in`.
 *     *   **Encapsulation:** All data fields (`processingQueue`, `completedDocuments`, `scanner`) are private. The core operations are exposed through public methods (`addDocument`, `processNextDocument`, `viewQueue`, `viewCompleted`, `runInteractionLoop`). Helper logic like command parsing is in a private method (`processCommand`).
 *     *   **Methods:**
 *         *   `addDocument(String docId, String description)`: Adds a new `Document` object to the `processingQueue` using `offer()`. It includes input validation to ensure the `docId` is not empty, throwing an `IllegalArgumentException` if it is. Success is reported via `System.out`.
 *         *   `processNextDocument()`: Checks if the `processingQueue` is empty. If so, it prints an error to `System.err`. Otherwise, it removes the head of the queue using `poll()` and adds it to the `completedDocuments` list using `add()`. Success is reported via `System.out`.
 *         *   `viewQueue()`: Iterates through the `processingQueue` (without removing elements) and prints each document to `System.out`. It checks if the queue is empty and prints an appropriate message.
 *         *   `viewCompleted()`: Iterates through the `completedDocuments` list and prints each document to `System.out`. It checks if the list is empty and prints an appropriate message.
 *         *   `runInteractionLoop()`: This method contains the main application loop. It prompts the user for input, reads the command line using `scanner.nextLine()`, and calls `processCommand` to handle it. It includes the loop control to `break` when the "exit" command is entered.
 *         *   `processCommand(String commandLine)`: This private helper method parses the input string. It splits the command line and uses a `switch` statement to determine which action to perform (`add`, `process`, `view`, or unknown command). Inside the `view` case, a nested `switch` handles "queue" and "completed" sub-commands. Input validation for command formats is performed, throwing `IllegalArgumentException` if the format is incorrect. Unknown commands result in an error message to `System.err`.
 * 
 * 3.  **Control Flow (`switch` and Loop):** The `runInteractionLoop` method contains the `while(true)` loop that keeps the program running until explicitly exited. The `processCommand` method uses a `switch` statement based on the first word of the command line to dispatch execution to the appropriate logic (`add`, `process`, `view`, etc.). The `view` command uses a nested `switch` for the second word ("queue" or "completed").
 * 
 * 4.  **Input/Output (`Scanner`, `System.out`, `System.err`):** `Scanner` is used to read full lines of input. `System.out.println` is used for prompts, success messages, and displaying the contents of the queues/lists. `System.err.println` is used specifically for error messages, such as an empty queue during processing, invalid command formats, or unknown commands.
 * 
 * 5.  **Exception Handling (`try-catch`):** The `runInteractionLoop` method includes a `try-catch` block surrounding the call to `processCommand`. This block catches `IllegalArgumentException` (thrown by `addDocument` or `processCommand` for validation errors) and also catches a general `Exception` to handle any other unexpected runtime issues that might occur during command execution. Error messages from caught exceptions are printed to `System.err`, fulfilling the requirement for class-wide exception handling within the main processing logic. Specific methods like `processNextDocument` handle their own expected error conditions (like an empty queue) by printing directly to `System.err` rather than throwing exceptions, as per the requirement description for that specific case.
 * 
 * 6.  **Best Practices:**
 *     *   **Meaningful Names:** Variables (`processingQueue`, `completedDocuments`, `docId`, `description`, `commandLine`, `viewType`) and methods (`addDocument`, `processNextDocument`, `viewQueue`, `viewCompleted`, `runInteractionLoop`, `processCommand`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods, explaining their purpose, parameters, and potential exceptions. Inline comments clarify specific logic points (e.g., using `offer` vs `add`, `poll` vs `remove`, splitting logic).
 *     *   **Input Validation:** Checks are explicitly made for empty document IDs and correct command argument counts/formats.
 *     *   **Error Handling:** Both expected errors (empty queue) and unexpected errors (via `try-catch`) are handled, with output directed to the appropriate stream (`System.err`).
 *     *   **Clean Code Structure:** The code is organized into logical classes (`Document`, `DocumentProcessor`) and methods, separating data representation from processing logic and user interaction.
 * 
 * This solution effectively integrates the required Java components and demonstrates key object-oriented design and error-handling principles in a practical simulation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a document with an ID and description.
 */
class Document {
    private String id;
    private String description;

    /**
     * Constructs a new Document.
     * @param id The unique identifier for the document.
     * @param description A brief description of the document.
     */
    public Document(String id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the document ID.
     * @return The document ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the document description.
     * @return The document description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the document.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + description;
    }
}

/**
 * Manages the document processing workflow using a queue and a completed list.
 */
public class DocumentProcessor {
    // Processing queue (FIFO) using LinkedList which implements Queue
    private Queue<Document> processingQueue;
    // List of completed documents using ArrayList which implements List
    private List<Document> completedDocuments;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new DocumentProcessor, initializing data structures and scanner.
     */
    public DocumentProcessor() {
        this.processingQueue = new LinkedList<>(); // Queue implementation
        this.completedDocuments = new ArrayList<>(); // List implementation
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new document to the processing queue.
     * @param docId The unique identifier for the document. Must not be null or empty.
     * @param description A brief description of the document. Can be empty.
     * @throws IllegalArgumentException if docId is null or empty.
     */
    public void addDocument(String docId, String description) {
        if (docId == null || docId.trim().isEmpty()) {
            throw new IllegalArgumentException("Document ID cannot be empty.");
        }
        // Create new Document object
        Document newDoc = new Document(docId.trim(), description != null ? description.trim() : "");
        // Add to the end of the queue
        processingQueue.offer(newDoc); // offer is preferred over add for queues, returns false on failure (rare)
        System.out.println("Document added to queue: " + newDoc);
    }

    /**
     * Processes the next document from the front of the queue.
     * Removes the document from the processing queue and adds it to the completed list.
     * Prints an error message to System.err if the queue is empty.
     */
    public void processNextDocument() {
        if (processingQueue.isEmpty()) {
            System.err.println("Processing queue is empty. No documents to process.");
            return;
        }
        // Retrieve and remove the head of the queue
        Document processedDoc = processingQueue.poll();
        if (processedDoc != null) { // poll returns null if queue is empty, but we checked isEmpty()
            completedDocuments.add(processedDoc); // Add to the completed list
            System.out.println("Document processed: " + processedDoc.getId());
        } else {
            // This case is highly unlikely after the isEmpty() check, but included for robustness
            System.err.println("An unexpected error occurred while retrieving document from queue.");
        }
    }

    /**
     * Displays the documents currently waiting in the processing queue.
     * Prints a message to System.out.
     */
    public void viewQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Document doc : processingQueue) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("------------------------\n");
    }

    /**
     * Displays the documents that have been processed and moved to the completed list.
     * Prints a message to System.out.
     */
    public void viewCompleted() {
        System.out.println("\n--- Completed Documents ---");
        if (completedDocuments.isEmpty()) {
            System.out.println("No documents have been processed yet.");
        } else {
            // Iterate through the completed list
            int index = 1;
            for (Document doc : completedDocuments) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Runs the main interaction loop, reading commands from the user and executing them.
     * Includes class-wide exception handling for command processing.
     */
    public void runInteractionLoop() {
        System.out.println("Document Processing System");
        System.out.println("Available commands: add <id> <description>, process, view queue, view completed, exit");

        String commandLine;
        // Loop to continuously accept commands
        while (true) {
            System.out.print("> ");
            try {
                // Check if there is input available before attempting to read
                if (!scanner.hasNextLine()) {
                     break; // Exit loop if input stream is closed
                }
                commandLine = scanner.nextLine().trim();

                // Handle the exit command directly
                if (commandLine.equalsIgnoreCase("exit")) {
                    System.out.println("Exiting Document Processing System.");
                    break; // Exit the command loop
                }

                // Use a try-catch block to handle potential exceptions during command execution
                try {
                    processCommand(commandLine);
                } catch (IllegalArgumentException e) {
                    // Catch specific input validation errors and print to System.err
                    System.err.println("Input error: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions during command processing
                    System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging during development/exam
                }

            } catch (NoSuchElementException | IllegalStateException e) {
                 // Handle potential issues with the scanner itself (e.g., stream closed unexpectedly)
                 System.err.println("Error reading input: " + e.getMessage());
                 break; // Exit loop on scanner error
            }
        }
        // In a simple console app like this, closing System.in via scanner.close()
        // can interfere with other parts of the system or testing frameworks.
        // Relying on JVM exit to close System.in is common practice for exam questions.
        // If explicit closing was required, a separate close method would be needed.
    }

    /**
     * Parses the user command line and calls the appropriate method.
     * @param commandLine The full command string entered by the user.
     * @throws IllegalArgumentException if the command format is invalid.
     * @throws Exception For unexpected errors during command processing.
     */
    private void processCommand(String commandLine) throws Exception {
        // Split the command line into the command and the rest of the arguments
        String[] parts = commandLine.split(" ", 2);
        String command = parts[0].toLowerCase(); // Get the command part (case-insensitive)

        // Use a switch statement to handle different commands
        switch (command) {
            case "add":
                // Validate 'add' command format
                if (parts.length < 2) {
                    throw new IllegalArgumentException("Invalid add command format. Use: add <id> <description>");
                }
                // Split the arguments part into ID and description
                String[] addArgs = parts[1].split(" ", 2);
                String docId;
                String description = "";

                if (addArgs.length > 0) {
                    docId = addArgs[0];
                    if (addArgs.length > 1) {
                        description = addArgs[1];
                    }
                } else {
                     throw new IllegalArgumentException("Invalid add command format. Use: add <id> <description>");
                }

                addDocument(docId, description); // Call the addDocument method
                break;

            case "process":
                // Validate 'process' command format (should have no arguments)
                if (parts.length > 1 && !parts[1].trim().isEmpty()) {
                     System.err.println("Warning: 'process' command takes no arguments. Ignoring extra input: " + parts[1]);
                }
                processNextDocument(); // Call the processNextDocument method
                break;

            case "view":
                // Validate 'view' command format
                if (parts.length < 2) {
                    throw new IllegalArgumentException("Invalid view command format. Use: view queue or view completed");
                }
                String viewType = parts[1].trim().toLowerCase();
                // Use a nested switch for view types
                switch (viewType) {
                    case "queue":
                        viewQueue(); // Call viewQueue method
                        break;
                    case "completed":
                        viewCompleted(); // Call viewCompleted method
                        break;
                    default:
                        // Handle unknown view types
                        throw new IllegalArgumentException("Unknown view type '" + viewType + "'. Use: view queue or view completed");
                }
                break;

            case "": // Handle empty input line gracefully
                 break; // Do nothing for empty lines

            default:
                // Handle unknown commands
                System.err.println("Unknown command: " + command);
                System.out.println("Available commands: add <id> <description>, process, view queue, view completed, exit");
                break;
        }
    }

    /**
     * Main method to start the Document Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DocumentProcessor processor = new DocumentProcessor();
        processor.runInteractionLoop();
        // The scanner connected to System.in is not explicitly closed here.
        // It will be closed when the JVM exits.
    }
}
