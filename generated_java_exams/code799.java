/*
 * Exam Question #799
 * Generated on: 2025-05-12 16:42:27
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Sorting and Processing System
 * 
 * **Objective:** Design and implement a simple console-based system for managing packages that arrive, are scanned, categorized, and processed. This task requires demonstrating proficiency in using core Java collections, control flow, user input handling, and exception management.
 * 
 * **Scenario:**
 * A small distribution center receives packages. Each package needs to be added to a queue for scanning. Once scanned, its category (Standard, Express, Hazardous) is determined, and it is then processed based on this category. The system should allow users to interact via a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a `Package` class with private fields for `id` (String), `description` (String), `status` (enum: `PENDING_SCAN`, `SCANNED`, `PROCESSED`), and `category` (enum: `STANDARD`, `EXPRESS`, `HAZARDOUS`). Include a constructor, appropriate getters, and methods to update status and category.
 * 2.  **System Class:** Create a `PackageProcessingSystem` class that manages the workflow.
 *     *   It must contain a `Queue<Package>` to hold packages awaiting scanning.
 *     *   It must contain a `List<Package>` (implemented by `ArrayList<Package>`) to store packages that have been fully processed.
 *     *   Use a `Scanner` object to read user input from the console.
 *     *   Implement methods for the following operations:
 *         *   `addPackageToQueue()`: Prompts the user for package ID and description, creates a `Package` object with status `PENDING_SCAN`, and adds it to the scanning queue.
 *         *   `scanNextPackage()`: Removes a package from the front of the scanning queue. If successful, updates its status to `SCANNED` and holds it temporarily (e.g., in a class field) for categorization/processing. If the queue is empty, print an error message.
 *         *   `processScannedPackage()`: Prompts the user to enter the category for the currently scanned package. Uses a `switch` statement to handle different categories. Updates the package's status to `PROCESSED` and moves it to the list of processed packages. Handles cases where no package has been scanned or the entered category is invalid.
 *         *   `viewProcessedPackages()`: Iterates through the list of processed packages and prints their details.
 *         *   `runMenu()`: Displays a menu of options (Add Package, Scan Package, Process Scanned Package, View Processed Packages, Exit), reads user input using `Scanner`, and uses a `switch` statement to call the appropriate method. This method should run in a loop until the user chooses to exit.
 * 3.  **Input and Output:**
 *     *   Use `Scanner` for all user inputs.
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and package details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty, no package scanned).
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential issues like `NumberFormatException` if you were to parse numbers (though not strictly required by the problem, demonstrate general handling), and potential issues with collection operations (e.g., trying to remove from an empty queue, although `poll` handles this gracefully, explicit checks are good). Handle invalid menu options and invalid package categories entered by the user.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/setters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc is a plus).
 *     *   Validate user input where necessary (e.g., category).
 *     *   Ensure the `Scanner` resource is closed properly.
 *     *   Structure the code into logical classes and methods.
 * 
 * **Expected Output Structure (Example Interactions):**
 * 
 * ```
 * --- Package Processing Menu ---
 * 1. Add Package to Queue
 * 2. Scan Next Package
 * 3. Process Scanned Package
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P101
 * Enter Package Description: Small Box
 * Package P101 added to scanning queue.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 2
 * Package P101 scanned. Status: SCANNED. Ready for processing.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 3
 * Currently scanned package: P101 (Small Box)
 * Enter Package Category (STANDARD, EXPRESS, HAZARDOUS): STANDARD
 * Package P101 processed as STANDARD.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Packages ---
 * ID: P101, Description: Small Box, Category: STANDARD, Status: PROCESSED
 * --------------------------
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 2
 * Scanning queue is empty. No packages to scan.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 3
 * Error: No package currently scanned. Scan a package first.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 3
 * Currently scanned package: P101 (Small Box)
 * Enter Package Category (STANDARD, EXPRESS, HAZARDOUS): URGENT
 * Error: Invalid category 'URGENT'. Please enter STANDARD, EXPRESS, or HAZARDOUS.
 * Currently scanned package P101 remains SCANNED.
 * 
 * --- Package Processing Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * **Grading:** Assessed on correctness, adherence to all requirements (including use of specified components), code structure, error handling, and best practices.
 *
 * EXPLANATION:
 * This solution implements a `PackageProcessingSystem` that simulates a basic workflow of receiving, scanning, categorizing, and processing packages. It effectively demonstrates the use of all required Java components and follows best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`PackageStatus` and `PackageCategory` Enums:** Define the possible states and types of a package, improving code readability and preventing invalid string values.
 * 2.  **`Package` Class:** Represents a single package. It uses private fields (`id`, `description`, `status`, `category`) and public getters, adhering to encapsulation principles. The constructor validates basic input, and methods like `setStatus` and `setCategory` control state changes. `toString()` provides a convenient way to print package details.
 * 3.  **`PackageProcessingSystem` Class:** This is the core class managing the system's state and logic.
 *     *   It holds the `Queue<Package> scanningQueue` using a `LinkedList` implementation, which is suitable for queue operations (`offer` for adding, `poll` for removing from the head).
 *     *   It holds the `List<Package> processedPackages` using an `ArrayList` implementation, providing dynamic resizing and easy iteration for viewing.
 *     *   A `Scanner` instance reads user input.
 *     *   `currentScannedPackage` field acts as a temporary holding area for a package that has been scanned but not yet categorized/processed.
 * 
 * **Component Usage:**
 * 
 * *   **`Queue` (`LinkedList`)**: Used for the `scanningQueue`. Packages are added to the end (`offer`) and removed from the front (`poll`), simulating a first-in, first-out scanning process.
 * *   **`List` (`ArrayList`)**: Used for the `processedPackages`. Packages are added to this list (`add`) after being fully processed, and the list is iterated through to display processed items (`viewProcessedPackages`). Declaring `processedPackages` as `List<Package>` rather than `ArrayList<Package>` demonstrates programming to an interface.
 * *   **`Scanner`**: Used in `runMenu`, `addPackageToQueue`, and `processScannedPackage` to read user input from `System.in`. The use of `nextLine()` after reading integers (by parsing the whole line) avoids common `Scanner` pitfalls. The `Scanner` is closed when the system exits using `scanner.close()`.
 * *   **`Switch statement`**: Used prominently in `runMenu` to navigate between different system operations based on the user's numeric choice. It is also used in `processScannedPackage` to potentially implement different logic based on the package category (though here it's primarily for demonstration; actual different logic could be added).
 * *   **`System.err`**: Used exclusively for printing error messages (e.g., invalid input, queue empty, no package scanned), distinguishing them from normal program output.
 * *   **`System.out`**: Used for displaying the menu, prompts, success messages, and the list of processed packages.
 * *   **`try-catch` blocks**: Implemented in `addPackageToQueue` to catch `IllegalArgumentException` during package creation, in `processScannedPackage` to catch `IllegalArgumentException` if the user enters an invalid category string for `PackageCategory.valueOf()`, and in `runMenu` to handle `NumberFormatException` if the user enters non-integer input for the menu choice. A general `catch (Exception e)` is also included in `runMenu` and other methods as a form of class-wide handling for unexpected errors, printing the error and stack trace to `System.err`. This demonstrates robust error handling within the class's methods and main loop.
 * 
 * **Workflow and Logic:**
 * 
 * 1.  Packages are added to the `scanningQueue` (`addPackageToQueue`).
 * 2.  `scanNextPackage` moves a package from the queue to the `currentScannedPackage` slot, changing its status to `SCANNED`. It checks if the queue is empty or if a package is already waiting.
 * 3.  `processScannedPackage` takes the `currentScannedPackage`, prompts for a category, validates it using `PackageCategory.valueOf()` and a `switch` statement, updates the package's status to `PROCESSED`, adds it to the `processedPackages` list, and clears the `currentScannedPackage` slot. It handles cases where no package is scanned or the category is invalid.
 * 4.  `viewProcessedPackages` simply iterates through the `processedPackages` list and prints each package's details.
 * 5.  `runMenu` drives the application, displaying options, reading input in a loop, and calling the appropriate methods via a `switch` statement. It includes the main error handling for invalid menu input.
 * 
 * **Best Practices:**
 * 
 * *   Encapsulation is used effectively in the `Package` class.
 * *   Method and variable names are descriptive (`scanningQueue`, `processScannedPackage`, `runMenu`).
 * *   Basic comments explain the purpose of classes, enums, and key methods.
 * *   Input validation occurs for package creation (non-empty ID/description) and category input (`valueOf` and the `catch` block).
 * *   Error handling is implemented using `try-catch` for specific expected errors (`NumberFormatException`, `IllegalArgumentException`) and general `Exception` catches for unexpected issues. `System.err` is used for errors.
 * *   The code is structured into logical units (`Package` class, `PackageProcessingSystem` class with distinct methods).
 * *   The `Scanner` resource is managed.
 * 
 * This solution meets all specified requirements and demonstrates a solid understanding of fundamental and intermediate Java concepts in a practical context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum for package status
enum PackageStatus {
    PENDING_SCAN,
    SCANNED,
    PROCESSED
}

// Enum for package category
enum PackageCategory {
    STANDARD,
    EXPRESS,
    HAZARDOUS
}

// Represents a package in the system
class Package {
    private String id;
    private String description;
    private PackageStatus status;
    private PackageCategory category; // Null until processed

    public Package(String id, String description) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Package description cannot be null or empty.");
        }
        this.id = id;
        this.description = description;
        this.status = PackageStatus.PENDING_SCAN;
        this.category = null; // Category is determined during processing
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public PackageStatus getStatus() {
        return status;
    }

    public PackageCategory getCategory() {
        return category;
    }

    // Methods to update status and category
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    public void setCategory(PackageCategory category) {
        if (category == null) {
             throw new IllegalArgumentException("Package category cannot be null.");
        }
        this.category = category;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description +
               ", Category: " + (category != null ? category : "N/A") +
               ", Status: " + status;
    }
}

// Main system class to manage packages
public class PackageProcessingSystem {

    // Required components
    private Queue<Package> scanningQueue; // Packages waiting to be scanned
    private List<Package> processedPackages; // Packages that have been fully processed
    private Scanner scanner; // For user input

    private Package currentScannedPackage; // Holds the package currently scanned and awaiting processing

    public PackageProcessingSystem() {
        // Initialize required collections
        this.scanningQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedPackages = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.currentScannedPackage = null; // No package scanned initially
    }

    // Method to add a package to the scanning queue
    public void addPackageToQueue() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Package Description: ");
        String description = scanner.nextLine();

        try {
            Package newPackage = new Package(id, description);
            scanningQueue.offer(newPackage); // offer is preferred over add for queues
            System.out.println("Package " + newPackage.getId() + " added to scanning queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding package: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during package creation/addition
             System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
        }
    }

    // Method to scan the next package from the queue
    public void scanNextPackage() {
        if (currentScannedPackage != null) {
             System.err.println("Error: A package (" + currentScannedPackage.getId() + ") is already scanned and waiting for processing.");
             System.err.println("Please process the currently scanned package first.");
             return;
        }

        Package packageToScan = scanningQueue.poll(); // poll returns null if queue is empty

        if (packageToScan == null) {
            System.err.println("Scanning queue is empty. No packages to scan.");
        } else {
            packageToScan.setStatus(PackageStatus.SCANNED);
            currentScannedPackage = packageToScan; // Hold the scanned package
            System.out.println("Package " + packageToScan.getId() + " scanned. Status: " + packageToScan.getStatus() + ". Ready for processing.");
        }
    }

    // Method to process the currently scanned package
    public void processScannedPackage() {
        if (currentScannedPackage == null) {
            System.err.println("Error: No package currently scanned. Scan a package first.");
            return;
        }

        System.out.println("Currently scanned package: " + currentScannedPackage.getId() + " (" + currentScannedPackage.getDescription() + ")");
        System.out.print("Enter Package Category (STANDARD, EXPRESS, HAZARDOUS): ");
        String categoryInput = scanner.nextLine().trim().toUpperCase();

        try {
            PackageCategory category = PackageCategory.valueOf(categoryInput); // Throws IllegalArgumentException if invalid

            // Use switch statement for processing logic based on category
            switch (category) {
                case STANDARD:
                    System.out.println("Processing Standard package " + currentScannedPackage.getId() + "...");
                    // Add specific standard processing logic here if needed
                    break;
                case EXPRESS:
                    System.out.println("Processing Express package " + currentScannedPackage.getId() + "...");
                    // Add specific express processing logic here if needed
                    break;
                case HAZARDOUS:
                    System.out.println("Processing Hazardous package " + currentScannedPackage.getId() + "...");
                    // Add specific hazardous processing logic here if needed (might require extra steps)
                    break;
                default:
                    // This case should theoretically not be reached if valueOf succeeds,
                    // but included for completeness.
                    System.err.println("Internal error: Unhandled category.");
                    return; // Prevent status update and moving to processed list
            }

            currentScannedPackage.setCategory(category);
            currentScannedPackage.setStatus(PackageStatus.PROCESSED);
            processedPackages.add(currentScannedPackage); // Add to the list of processed packages
            System.out.println("Package " + currentScannedPackage.getId() + " processed as " + category + ".");

            currentScannedPackage = null; // Clear the currently scanned package slot

        } catch (IllegalArgumentException e) {
            // Handle invalid category input from valueOf()
            System.err.println("Error: Invalid category '" + categoryInput + "'. Please enter STANDARD, EXPRESS, or HAZARDOUS.");
             System.err.println("Currently scanned package " + currentScannedPackage.getId() + " remains SCANNED.");
        } catch (Exception e) {
             // Catch any other unexpected errors during processing
             System.err.println("An unexpected error occurred while processing package: " + e.getMessage());
             // Decide if you want to keep or discard the currentScannedPackage in case of error
             // For this example, let's keep it scanned so the user can try processing again.
        }
    }

    // Method to view all processed packages
    public void viewProcessedPackages() {
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
            return;
        }

        System.out.println("--- Processed Packages ---");
        for (Package pkg : processedPackages) { // Iterate through the List
            System.out.println(pkg);
        }
        System.out.println("--------------------------");
    }

    // Displays the menu and handles user interaction loop
    public void runMenu() {
        int choice = -1; // Initialize with an invalid choice
        while (choice != 5) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                // Use hasNextLine() and nextLine() to consume the whole line,
                // preventing issues with nextInt() leaving newline characters.
                if (scanner.hasNextLine()) {
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine); // Attempt to parse input as integer

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addPackageToQueue();
                            break;
                        case 2:
                            scanNextPackage();
                            break;
                        case 3:
                            processScannedPackage();
                            break;
                        case 4:
                            viewProcessedPackages();
                            break;
                        case 5:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                    }
                } else {
                     // Handle case where there's no more input (e.g., redirected input ends)
                     System.err.println("No more input available. Exiting.");
                     choice = 5; // Exit the loop
                }

            } catch (NumberFormatException e) {
                // Catch specific exception for invalid integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                choice = -1; // Reset choice to continue the loop
            } catch (Exception e) {
                // Class-wide catch-all for unexpected exceptions in the menu loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream for debugging
                choice = -1; // Reset choice
            }
            System.out.println(); // Add a newline for better readability between operations
        }

        // Close the scanner when exiting
        scanner.close();
    }

    // Helper method to print the menu
    private void printMenu() {
        System.out.println("--- Package Processing Menu ---");
        System.out.println("1. Add Package to Queue");
        System.out.println("2. Scan Next Package");
        System.out.println("3. Process Scanned Package");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        PackageProcessingSystem system = new PackageProcessingSystem();
        system.runMenu(); // Start the main menu loop
    }
}
