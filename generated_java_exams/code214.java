/*
 * Exam Question #214
 * Generated on: 2025-05-11 22:33:12
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Queue System
 * 
 * **Objective:** Design and implement a console-based application that simulates a simple task management system for a small team. The system should allow adding tasks to a queue, viewing the next task, completing tasks, and listing all tasks or just the pending ones in queue order.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   A unique integer `taskId` (auto-generated by the system).
 *     *   A `String description`.
 *     *   A `TaskPriority` (use an `enum` for `HIGH`, `MEDIUM`, `LOW`).
 *     *   A `TaskStatus` (use an `enum` for `PENDING`, `COMPLETED`).
 *     *   Implement appropriate constructors, getters, and a method `markCompleted()`.
 *     *   Override `toString()` for easy printing of task details.
 * 
 * 2.  **Task Management System:** Create a `TeamTaskQueue` class that manages the tasks. It should use:
 *     *   A `java.util.List<Task>` (specifically, an `ArrayList`) to store *all* tasks ever created.
 *     *   A `java.util.Queue<Task>` (you can use `LinkedList` as an implementation) to store tasks that are currently `PENDING` and ready for processing, in the order they are added (FIFO for simplicity).
 *     *   A mechanism to generate unique task IDs.
 * 
 * 3.  **Functionality:** The `TeamTaskQueue` class should provide methods for:
 *     *   `addTask(String description, TaskPriority priority)`: Creates a new task, adds it to the list of all tasks, and adds it to the pending task queue.
 *     *   `getNextPendingTask()`: Returns the next task in the pending queue without removing it (peek). Returns `null` if the queue is empty.
 *     *   `completeNextPendingTask()`: Removes the next task from the pending queue (poll), updates its status to `COMPLETED` in the master list (since the object reference is shared), and returns the completed task. Returns `null` if the queue is empty.
 *     *   `getAllTasks()`: Returns a `java.util.List` containing all tasks created (both pending and completed).
 *     *   `getPendingTasksInQueueOrder()`: Returns a `java.util.List` containing only the tasks currently in the pending queue, in their queue order, without removing them from the queue.
 * 
 * 4.  **User Interface:** Implement a console interface using `java.util.Scanner` in the `main` method (or a dedicated `run` method within `TeamTaskQueue`) to interact with the user. The system should accept the following commands:
 *     *   `add <description> <priority>`: Adds a new task. `<priority>` must be one of `HIGH`, `MEDIUM`, or `LOW` (case-insensitive input, but use enum constants internally). The description can contain spaces.
 *     *   `next`: Displays the details of the next task in the pending queue (using `getNextPendingTask`).
 *     *   `complete`: Completes the next task in the pending queue (using `completeNextPendingTask`).
 *     *   `list all`: Displays all tasks created, including their ID, description, priority, and status.
 *     *   `list pending`: Displays all tasks currently in the pending queue, in the order they would be processed.
 *     *   `exit`: Terminates the application.
 * 
 * 5.  **Error Handling and Best Practices:**
 *     *   Use a `switch` statement to process user commands.
 *     *   Use `System.out` for normal output and prompts.
 *     *   Use `System.err` for error messages (e.g., invalid command, incorrect arguments, invalid priority, empty queue for `complete` command).
 *     *   Implement input validation (check command format, valid priority).
 *     *   Use `try-catch` block(s) to handle potential exceptions during program execution, especially around user input processing and operations that might fail (like parsing priority). A general `try-catch` around the command processing loop is acceptable for catching unexpected errors.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, accepting commands and printing results or error messages.
 * 
 * Example Interaction:
 * 
 * ```
 * Team Task Queue System
 * Available commands: add <description> <priority>, next, complete, list all, list pending, exit
 * > add Write report HIGH
 * Task added: ID: 1, Desc: "Write report", Priority: HIGH, Status: PENDING
 * > add Plan meeting MEDIUM
 * Task added: ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: PENDING
 * > list pending
 * --- Pending Tasks (Queue Order) ---
 * ID: 1, Desc: "Write report", Priority: HIGH, Status: PENDING
 * ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: PENDING
 * -----------------
 * > next
 * Next pending task: ID: 1, Desc: "Write report", Priority: HIGH, Status: PENDING
 * > complete
 * Task completed: ID: 1, Desc: "Write report", Priority: HIGH, Status: COMPLETED
 * > next
 * Next pending task: ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: PENDING
 * > list all
 * --- All Tasks ---
 * ID: 1, Desc: "Write report", Priority: HIGH, Status: COMPLETED
 * ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: PENDING
 * -----------------
 * > list pending
 * --- Pending Tasks (Queue Order) ---
 * ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: PENDING
 * -----------------
 * > complete
 * Task completed: ID: 2, Desc: "Plan meeting", Priority: MEDIUM, Status: COMPLETED
 * > complete
 * No pending tasks to complete.
 * > list pending
 * No tasks currently in the pending queue.
 * > add Review code LOW
 * Task added: ID: 3, Desc: "Review code", Priority: LOW, Status: PENDING
 * > exit
 * Exiting Team Task Queue System.
 * ```
 * 
 * **Assessment:** Your solution will be assessed on correctness, adherence to all requirements (including the use of specified Java components), code quality, error handling, and overall design.
 *
 * EXPLANATION:
 * This solution implements a `TeamTaskQueue` system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, `priority`, and `status`.
 *     *   Uses `enum` for `TaskPriority` and `TaskStatus` for type safety and readability.
 *     *   `markCompleted()` method encapsulates the state change logic.
 *     *   `toString()` provides a convenient formatted output.
 *     *   Fields are `private`, and access is provided via `public` getters, adhering to encapsulation.
 * 
 * 2.  **`TeamTaskQueue` Class:**
 *     *   `private List<Task> allTasks = new ArrayList<>();`: An `ArrayList` is used to store a persistent record of *all* tasks created. It is declared using the `List` interface type.
 *     *   `private Queue<Task> pendingTaskQueue = new LinkedList<>();`: A `Queue` is used to manage tasks that are currently pending and ready for processing. `LinkedList` is a common implementation of the `Queue` interface that supports FIFO operations (`offer`, `poll`, `peek`).
 *     *   `nextTaskId`: A simple counter ensures unique IDs for new tasks.
 *     *   `scanner`: A `Scanner` object is used to read user input from the console (`System.in`).
 *     *   **`addTask(String description, TaskPriority priority)`:** Creates a new `Task` object, adds it to the `allTasks` list, and adds it to the `pendingTaskQueue` using `offer()`.
 *     *   **`getNextPendingTask()`:** Uses `peek()` on the `pendingTaskQueue` to look at the head element without removing it. Returns `null` if the queue is empty.
 *     *   **`completeNextPendingTask()`:** Uses `poll()` on the `pendingTaskQueue` to retrieve and remove the head element. If a task is retrieved, its `markCompleted()` method is called. Because the `Task` objects stored in `allTasks` and `pendingTaskQueue` are the same instances (references), modifying the object via the reference obtained from the queue updates the status of the task object stored in the `allTasks` list as well. This method prints a success message or an informative message if the queue is empty.
 *     *   **`getAllTasks()`:** Returns the `allTasks` list. `Collections.unmodifiableList()` is used to return a read-only view, preventing external code from modifying the internal list state directly.
 *     *   **`getPendingTasksInQueueOrder()`:** Creates a *new* `ArrayList` initialized with the elements of the `pendingTaskQueue`. This provides a snapshot of the pending tasks in their current queue order without altering the queue itself.
 *     *   **`run()` Method:** This is the main application loop.
 *         *   It uses a `while` loop to keep the system running until the user types `exit`.
 *         *   `scanner.nextLine()` reads the entire line of user input.
 *         *   A `try-catch (Exception e)` block wraps the command processing logic within the loop. This provides class-wide exception handling for unexpected errors that might occur during command execution. Specific expected errors (like invalid input format) are handled with checks and `System.err` messages *before* potentially throwing exceptions or attempting operations that would fail.
 *         *   Input is parsed to determine the command and its arguments.
 *         *   A `switch` statement is used to direct execution based on the command.
 *         *   **Input Validation:** Inside the `switch` cases (especially `add` and `list`), checks are performed to ensure the correct number and format of arguments. Invalid priority input for the `add` command is specifically caught using `try-catch (IllegalArgumentException e)` around `TaskPriority.valueOf()`.
 *         *   **Output:** `System.out` is used for prompts, success messages, and listing tasks. `System.err` is used exclusively for error messages reported to the user.
 *         *   The `scanner` is closed when the `exit` command is processed to release system resources.
 * 
 * 3.  **Main Method:**
 *     *   The `main` method simply creates an instance of `TeamTaskQueue` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical task management simulation, demonstrating collection usage, object state management via references, user interaction, command processing, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Collections;

// Enum for Task Priority
enum TaskPriority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum TaskStatus {
    PENDING, COMPLETED
}

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private TaskPriority priority;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int taskId, String description, TaskPriority priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING; // Tasks are pending when created
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskPriority getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Marks the task's status as COMPLETED.
     */
    public void markCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including ID, description, priority, and status.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Desc: \"%s\", Priority: %s, Status: %s",
                             taskId, description, priority, status);
    }
}

/**
 * Manages a collection of tasks using a list for all tasks and a queue for pending tasks.
 */
public class TeamTaskQueue { // Changed to public class for main method
    private List<Task> allTasks; // Stores all tasks created
    private Queue<Task> pendingTaskQueue; // Stores tasks ready for processing (FIFO)
    private int nextTaskId; // Counter for generating unique task IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TeamTaskQueue system.
     */
    public TeamTaskQueue() {
        allTasks = new ArrayList<>(); // Use ArrayList for the master list
        pendingTaskQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        nextTaskId = 1; // Start task IDs from 1
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the system.
     * Creates a Task object, adds it to the list of all tasks, and enqueues it.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, TaskPriority priority) {
        // Input validation is handled in the run method before calling this
        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask); // Add to the master list
        pendingTaskQueue.offer(newTask); // Add to the pending queue (FIFO)
        System.out.println("Task added: " + newTask.toString());
    }

    /**
     * Gets the next task from the pending queue without removing it.
     * @return The next Task in the queue, or null if the queue is empty.
     */
    public Task getNextPendingTask() {
        return pendingTaskQueue.peek(); // peek() returns null if empty
    }

    /**
     * Completes the next task in the pending queue.
     * Removes the task from the queue, marks it as completed in the master list,
     * and prints confirmation.
     * @return The completed Task, or null if the queue was empty.
     */
    public Task completeNextPendingTask() {
        Task taskToComplete = pendingTaskQueue.poll(); // poll() removes and returns head, or null if empty
        if (taskToComplete != null) {
            // Since the Task object in allTasks and pendingTaskQueue is the same reference,
            // marking it complete via the object from the queue updates it in the list too.
            taskToComplete.markCompleted();
            System.out.println("Task completed: " + taskToComplete.toString());
        } else {
            // Use System.out for informative messages like this, not System.err
            System.out.println("No pending tasks to complete.");
        }
        return taskToComplete; // Return the completed task or null
    }

    /**
     * Gets an unmodifiable list of all tasks created in the system.
     * @return A read-only list of all tasks.
     */
    public List<Task> getAllTasks() {
        return Collections.unmodifiableList(allTasks); // Return a read-only view
    }

    /**
     * Gets a list of tasks currently in the pending queue, in queue order.
     * Creates a new list from the queue elements without modifying the queue.
     * @return A list of pending tasks in their current queue order.
     */
    public List<Task> getPendingTasksInQueueOrder() {
        // Create a new ArrayList from the Queue's elements.
        // This iterates the queue without removing elements.
        return new ArrayList<>(pendingTaskQueue);
    }

    /**
     * Runs the main command-line interface loop for the task management system.
     * Handles user input, command parsing, and calls appropriate methods.
     * Includes error handling for input and operations.
     */
    public void run() {
        System.out.println("Team Task Queue System");
        System.out.println("Available commands: add <description> <priority>, next, complete, list all, list pending, exit");

        boolean running = true;
        while (running) {
            System.out.print("> ");
            String inputLine = scanner.nextLine().trim();

            // Class-wide exception handling for the main command processing loop
            try {
                if (inputLine.isEmpty()) {
                    continue; // Skip empty input
                }

                // Basic command parsing: split by first space to get the command
                int firstSpaceIndex = inputLine.indexOf(' ');
                String command;
                String commandArgs = ""; // Arguments part of the input

                if (firstSpaceIndex == -1) {
                    command = inputLine.toLowerCase();
                } else {
                    command = inputLine.substring(0, firstSpaceIndex).toLowerCase();
                    commandArgs = inputLine.substring(firstSpaceIndex + 1).trim();
                }


                switch (command) {
                    case "add":
                        // Expected format: add <description> <priority>
                        // Priority is the last word, description is everything in between.
                        int lastSpaceIndex = commandArgs.lastIndexOf(' ');
                        if (lastSpaceIndex == -1 || commandArgs.isEmpty() || lastSpaceIndex == commandArgs.length() - 1) {
                            System.err.println("Error: 'add' command requires description and priority. Usage: add <description> <priority>");
                        } else {
                            String priorityStr = commandArgs.substring(lastSpaceIndex + 1).trim().toUpperCase();
                            String description = commandArgs.substring(0, lastSpaceIndex).trim();

                            if (description.isEmpty()) {
                                System.err.println("Error: Task description cannot be empty. Usage: add <description> <priority>");
                            } else {
                                try {
                                    TaskPriority priority = TaskPriority.valueOf(priorityStr);
                                    addTask(description, priority);
                                } catch (IllegalArgumentException e) {
                                    // Catch if TaskPriority.valueOf fails (invalid enum name)
                                    System.err.println("Error: Invalid priority '" + priorityStr + "'. Valid priorities: HIGH, MEDIUM, LOW.");
                                }
                            }
                        }
                        break;

                    case "next":
                        Task nextTask = getNextPendingTask();
                        if (nextTask != null) {
                            System.out.println("Next pending task: " + nextTask.toString());
                        } else {
                            System.out.println("No pending tasks in the queue.");
                        }
                        break;

                    case "complete":
                        completeNextPendingTask(); // Method handles its own output
                        break;

                    case "list":
                        if (commandArgs.equalsIgnoreCase("all")) {
                            List<Task> tasks = getAllTasks();
                            if (tasks.isEmpty()) {
                                System.out.println("No tasks have been created yet.");
                            } else {
                                System.out.println("--- All Tasks ---");
                                tasks.forEach(System.out::println);
                                System.out.println("-----------------");
                            }
                        } else if (commandArgs.equalsIgnoreCase("pending")) {
                            List<Task> pending = getPendingTasksInQueueOrder();
                            if (pending.isEmpty()) {
                                System.out.println("No tasks currently in the pending queue.");
                            } else {
                                 System.out.println("--- Pending Tasks (Queue Order) ---");
                                 pending.forEach(System.out::println);
                                 System.out.println("-----------------");
                            }
                        } else {
                            System.err.println("Error: Invalid list type '" + commandArgs + "'. Usage: list all or list pending");
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Team Task Queue System.");
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        System.out.println("Available commands: add <description> <priority>, next, complete, list all, list pending, exit");
                        break;
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions during command processing
                System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                // Optional: e.printStackTrace(); // Uncomment for detailed debugging output
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Main method to start the Team Task Queue application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TeamTaskQueue system = new TeamTaskQueue();
        system.run();
    }
}
