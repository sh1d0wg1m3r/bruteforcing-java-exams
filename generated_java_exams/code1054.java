/*
 * Exam Question #1054
 * Generated on: 2025-05-12 17:18:47
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam: Service Request Dispatcher System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a console-based system to manage service requests for a small organization. The system should allow users to add new service requests, view requests currently waiting to be processed, process the next available request, and view requests that have been completed.
 * 
 * Requests are processed in the order they are received (First-In, First-Out). Completed requests should be stored for historical viewing.
 * 
 * Your solution must be written in Java and adhere to the following specific requirements and best practices.
 * 
 * **System Functionality:**
 * 
 * 1.  **Add Request:** Allows the user to input a description for a new service request. The system should automatically assign a unique ID to each request. New requests are added to a waiting queue.
 * 2.  **View Pending Requests:** Displays all requests currently in the waiting queue without removing them.
 * 3.  **Process Next Request:** Removes the request at the front of the waiting queue, marks it as completed, and moves it to a list of completed requests. If the queue is empty, an appropriate error message should be displayed.
 * 4.  **View Completed Requests:** Displays all requests that have been processed and are in the completed list.
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution code **must** use all of the following Java components:
 * 
 * *   `java.util.Queue` (as the interface type for the pending requests collection)
 * *   `java.util.ArrayList` (as the concrete implementation for the completed requests collection)
 * *   `java.util.List` ( as the interface type for the completed requests collection)
 * *   `java.util.Scanner` (for reading user input from the console)
 * *   `switch` statement (for handling the main menu options)
 * *   `System.err` (for printing error messages, e.g., invalid input, attempting to process an empty queue)
 * *   `System.out` (for printing normal output, e.g., menu, request lists, success messages)
 * *   Class-wide exception handling using `try-catch` blocks (e.g., around the main application loop or critical operations to catch unexpected errors).
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation using private fields and public methods.
 * *   Use meaningful variable, method, and class names.
 * *   Include appropriate comments and Javadoc documentation for clarity.
 * *   Implement basic input validation (e.g., checking if the user enters a valid menu option).
 * *   Provide clear error handling messages using `System.err`.
 * *   Structure your code into logical classes (e.g., a class for the Service Request and a class for the Dispatcher system).
 * 
 * **Expected Output/Interaction:**
 * 
 * The program should present a menu to the user, prompt for input, and perform the corresponding action. Output should be clear and informative, indicating success or failure. Error messages should be distinct (using `System.err`).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Fix network printer
 * Request added: [ID: 1] Fix network printer
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Setup new laptop for user A
 * Request added: [ID: 2] Setup new laptop for user A
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Requests ---
 * [ID: 1] Fix network printer
 * [ID: 2] Setup new laptop for user A
 * --------------------------
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * Processing request: [ID: 1] Fix network printer
 * Request [ID: 1] processed successfully.
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Requests ---
 * [ID: 2] Setup new laptop for user A
 * --------------------------
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Requests ---
 * [ID: 1] Fix network printer
 * --------------------------
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * Processing request: [ID: 2] Setup new laptop for user A
 * Request [ID: 2] processed successfully.
 * 
 * --- Service Request Dispatcher ---
 * 1. Add New Request
 * 2. View Pending Requests
 * 3. Process Next Request
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * Error: No pending requests to process.
 * ```
 * 
 * Your code should be complete and runnable.
 *
 * EXPLANATION:
 * This solution implements a simple Service Request Dispatcher system using the required Java components and best practices.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`ServiceRequest` Class:** A simple class representing a request with an auto-generated ID and a description. It demonstrates encapsulation with private fields and public getter methods. The static `nextId` ensures unique IDs for each request instance. The `toString()` method provides a convenient way to print request details.
 * 
 * 2.  **`RequestDispatcher` Class:** This is the main class managing the system state and logic.
 *     *   **`Queue<ServiceRequest> pendingRequests`**: Declared using the `Queue` interface and initialized with a `LinkedList`. This collection stores requests waiting to be processed, ensuring they are handled in a FIFO (First-In, First-Out) manner as required by the "Process Next Request" functionality. `offer()` is used for adding (preferred for queues), and `poll()` is used for retrieving and removing the head element.
 *     *   **`List<ServiceRequest> completedRequests`**: Declared using the `List` interface and initialized with an `ArrayList`. This collection stores requests after they have been processed. `ArrayList` is suitable here as completed requests are typically viewed sequentially or accessed by index, and its dynamic resizing works well for an unknown number of completed items. The `List` interface allows for flexibility if a different list implementation were needed later.
 *     *   **`Scanner scanner`**: Used within the `runDispatcher` method to read user input from the console (`System.in`). It's initialized once and closed in the `finally` block to prevent resource leaks.
 *     *   **`switch` statement**: Located in the `runDispatcher` method, it controls the main application flow by directing execution based on the user's numerical choice from the menu.
 *     *   **`System.err`**: Used for printing error messages, such as when the user enters an invalid menu option or attempts to process a request when the `pendingRequests` queue is empty. This distinguishes error output from normal program messages.
 *     *   **`System.out`**: Used for all standard output, including displaying the menu, prompting for input, confirming actions, and listing the contents of the pending and completed request collections.
 *     *   **Class-wide `try-catch` block**: A `try-catch` block wraps the main `while(running)` loop in the `runDispatcher` method. This serves as a class-wide handler for any unexpected `Exception` that might occur during the program's execution, preventing the program from crashing abruptly. A more specific `try-catch` is also used around `Integer.parseInt` to handle `NumberFormatException` specifically for input parsing, although the default case in the switch handles the resulting invalid `choice` value effectively. The `finally` block ensures the `Scanner` is closed regardless of whether an exception occurs or the loop terminates normally.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Both `ServiceRequest` and `RequestDispatcher` classes have private fields accessed only through public methods (`getters`, `addRequest`, `processNextRequest`, etc.).
 * *   **Meaningful Names:** Class names (`ServiceRequest`, `RequestDispatcher`), method names (`addRequest`, `viewPendingRequests`, `processNextRequest`, `runDispatcher`), and variable names (`pendingRequests`, `completedRequests`, `description`, `choice`) are descriptive of their purpose.
 * *   **Comments and Documentation:** Javadoc comments are used for classes and public methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 * *   **Input Validation:** The code checks if the user's menu choice is within the valid range (1-5) using the `switch` statement's `default` case. It also checks if the request description is empty before adding it.
 * *   **Error Handling:** Specific error conditions like an empty queue during processing are explicitly checked, and informative error messages are printed to `System.err`. Invalid menu input is also reported via `System.err`. The main `try-catch` provides a fallback for unexpected errors.
 * *   **Clean Code Structure:** The code is divided into two logical classes, separating the data structure for a request from the system logic that manages collections of requests and user interaction. Methods are kept relatively short and focused on a single task.
 * 
 * This solution effectively integrates the required Java features into a practical, albeit simplified, application, demonstrating understanding of collections, control flow, input/output, and error handling in Java.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single service request.
 */
class ServiceRequest {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;

    /**
     * Constructs a new ServiceRequest with an auto-generated ID.
     * @param description The description of the request.
     */
    public ServiceRequest(String description) {
        this.id = nextId++;
        this.description = description;
    }

    /**
     * Gets the unique ID of the request.
     * @return The request ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the request.
     * @return The request description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the request.
     * @return Formatted string including ID and description.
     */
    @Override
    public String toString() {
        return "[ID: " + id + "] " + description;
    }
}

/**
 * Manages the queue of pending service requests and a list of completed requests.
 */
public class RequestDispatcher {
    // Use Queue interface, LinkedList implementation for FIFO pending requests
    private Queue<ServiceRequest> pendingRequests;
    // Use List interface, ArrayList implementation for completed requests
    private List<ServiceRequest> completedRequests;
    private Scanner scanner;

    /**
     * Constructs a new RequestDispatcher.
     * Initializes the pending and completed request collections.
     */
    public RequestDispatcher() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.completedRequests = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new service request to the pending queue.
     * @param description The description of the request.
     */
    public void addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Request description cannot be empty.");
             return;
        }
        ServiceRequest newRequest = new ServiceRequest(description);
        pendingRequests.offer(newRequest); // offer is preferred over add for queues
        System.out.println("Request added: " + newRequest);
    }

    /**
     * Displays all requests currently in the pending queue.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (ServiceRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Processes the next request from the pending queue, moving it to completed.
     */
    public void processNextRequest() {
        System.out.println("Processing next request...");
        ServiceRequest requestToProcess = pendingRequests.poll(); // poll retrieves and removes the head

        if (requestToProcess == null) {
            System.err.println("Error: No pending requests to process.");
        } else {
            completedRequests.add(requestToProcess);
            System.out.println("Request " + requestToProcess.toString() + " processed successfully.");
        }
    }

    /**
     * Displays all requests in the completed list.
     */
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            for (ServiceRequest request : completedRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Service Request Dispatcher ---");
        System.out.println("1. Add New Request");
        System.out.println("2. View Pending Requests");
        System.out.println("3. Process Next Request");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and dispatching actions.
     * Includes class-wide exception handling.
     */
    public void runDispatcher() {
        boolean running = true;
        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();
                String input = scanner.nextLine();
                int choice = -1; // Default invalid choice

                try {
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // Handled below by the switch default case
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        addRequest(description);
                        break;
                    case 2:
                        viewPendingRequests();
                        break;
                    case 3:
                        processNextRequest();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        System.out.println("Exiting Service Request Dispatcher. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Input validation error message using System.err
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the application execution
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RequestDispatcher dispatcher = new RequestDispatcher();
        dispatcher.runDispatcher();
    }
}
