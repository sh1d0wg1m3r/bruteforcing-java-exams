/*
 * Exam Question #215
 * Generated on: 2025-05-11 22:33:22
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a warehouse order fulfillment process. The system should manage incoming orders, process them sequentially, and keep track of completed orders. The user interacts with the system via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Order Representation:** Create a class `Order` to represent a single order. Each `Order` should have a unique integer `orderId`, a `productName` (String), a `quantity` (int), and a `status` (String, e.g., "Pending", "Completed"). Ensure proper encapsulation (private fields, public getters).
 * 2.  **Warehouse Management:** Create a class `WarehouseManager` that manages the orders.
 *     *   It must use a `java.util.Queue` to hold incoming/pending orders.
 *     *   It must use a `java.util.List` (specifically an `ArrayList` instance assigned to a `List` reference) to store completed orders.
 *     *   Implement methods within `WarehouseManager` for the following operations:
 *         *   `addOrder(String productName, int quantity)`: Creates a new `Order` object with status "Pending" and adds it to the pending queue. Assign a unique `orderId` (you can use a simple static counter).
 *         *   `processNextOrder()`: Removes the next order from the pending queue, changes its status to "Completed", and adds it to the completed list. If the pending queue is empty, report an error.
 *         *   `viewPendingOrders()`: Displays details of all orders currently in the pending queue.
 *         *   `viewCompletedOrders()`: Displays details of all orders currently in the completed list.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in the `main` method or a dedicated `run` method within `WarehouseManager`.
 *     *   Present a menu of options: Add Order, Process Next Order, View Pending Orders, View Completed Orders, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Prompt the user for necessary input (product name, quantity) when adding an order.
 *     *   Implement input validation for menu choices (must be an integer within the valid range) and quantity (must be a positive integer).
 * 4.  **Error Handling:**
 *     *   Use `System.err.println()` to report errors, such as an empty queue when trying to process, invalid menu choices, or invalid input for quantity.
 *     *   Use `System.out.println()` for all normal output, including the menu, order details, and success messages.
 *     *   Implement exception handling using `try-catch` blocks. At a minimum, wrap the main user interaction loop or critical input processing to catch potential exceptions (e.g., `InputMismatchException` from `Scanner`).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts.
 *     *   Ensure classes and methods follow standard Java conventions.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and display results or errors. Examples:
 * 
 * ```
 * --- Warehouse Order Management ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter product name: Laptop
 * Enter quantity: 5
 * Order 1 (Laptop, Qty: 5) added to pending.
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 2
 * Processing order 1...
 * Order 1 (Laptop, Qty: 5) moved to completed.
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 3
 * --- Pending Orders ---
 * Order ID: 2, Product: Keyboard, Quantity: 10, Status: Pending
 * --- End Pending Orders ---
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 2
 * Error: No pending orders to process.
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 1
 * Enter product name: Monitor
 * Enter quantity: -2
 * Error: Quantity must be a positive integer.
 * 
 * --- Warehouse Order Management ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the warehouse logic (adding, processing, viewing orders).
 * *   Robustness of input validation and error handling.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 *
 * EXPLANATION:
 * This solution implements the Warehouse Order Fulfillment Simulation as required, demonstrating the use of the specified Java components and adhering to best practices.
 * 
 * 1.  **Order Class:** The `Order` class encapsulates the data for a single order (`orderId`, `productName`, `quantity`, `status`). It uses a `static` variable `nextOrderId` to ensure each new order receives a unique sequential ID. Getters provide controlled access to the data, and a `setStatus` method allows updating the order's status. The `toString` method provides a convenient way to display order information.
 * 
 * 2.  **WarehouseManager Class:** This class is the core of the simulation.
 *     *   `Queue<Order> pendingOrders`: A `LinkedList` is used here because it implements the `Queue` interface and provides efficient FIFO (First-In, First-Out) operations needed for processing orders in the order they are received. `offer()` is used to add elements, and `poll()` is used to remove them.
 *     *   `List<Order> completedOrders`: An `ArrayList` is used here, assigned to a `List` reference. `ArrayList` is suitable for storing completed orders as we might need to iterate through them or potentially access them by index later (though not required in this specific problem, `ArrayList` is a common and efficient `List` implementation). `add()` is used to add completed orders.
 *     *   `addOrder()`: Prompts the user for product name and quantity. It includes input validation within a `while` loop and `try-catch` block to ensure a positive integer quantity is entered, handling `InputMismatchException` and consuming invalid input using `scanner.next()`. Once validated, a new `Order` is created and added to the `pendingOrders` queue using `offer()`.
 *     *   `processNextOrder()`: Checks if `pendingOrders` is empty using `isEmpty()`. If not empty, it uses `poll()` to retrieve and remove the head of the queue. The retrieved order's status is updated to "Completed", and it's added to the `completedOrders` list. An error message is printed to `System.err` if the queue is empty.
 *     *   `viewPendingOrders()` and `viewCompletedOrders()`: These methods iterate through the respective collections (`pendingOrders` and `completedOrders`) and print the details of each order using the `Order` class's `toString()` method. They check for emptiness and print appropriate messages.
 *     *   `displayMenu()`: A helper method to print the available options to `System.out`.
 *     *   `run()`: This method contains the main application loop. It continuously displays the menu, reads user input using `scanner.nextInt()`, and uses a `switch` statement to call the appropriate `WarehouseManager` method based on the user's `choice`.
 *         *   Input validation for the menu choice is done by checking `scanner.hasNextInt()` and handling the `InputMismatchException` if the input is not an integer. Invalid tokens are consumed using `scanner.next()`.
 *         *   A general `try-catch` block surrounds the core logic within the loop to catch any unexpected exceptions that might occur during execution, printing an error to `System.err`.
 *         *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls (like the one in `addOrder`).
 *         *   The loop continues until the user chooses option 5, setting the `running` flag to `false`.
 *         *   The `Scanner` is closed when the loop exits to release system resources.
 * 
 * 3.  **Main Class (`WarehouseApp`):** This simple class contains the `main` method, which is the entry point of the application. It creates an instance of `WarehouseManager` and calls its `run()` method to start the simulation.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Effective use of `Queue` for managing a waiting list (FIFO) and `List` (`ArrayList`) for storing processed items.
 * *   **Encapsulation:** The `Order` class demonstrates encapsulation with private fields and public methods.
 * *   **Control Flow:** `switch` statement for multi-way branching based on user input, `while` loop for the main application flow and input validation loops.
 * *   **Input/Output:** Using `Scanner` for user input, `System.out` for standard messages, and `System.err` for error reporting.
 * *   **Exception Handling:** Using `try-catch` blocks to handle potential runtime errors, specifically `InputMismatchException` during input parsing and a general catch for unexpected errors.
 * *   **Object-Oriented Programming:** Structuring the code into classes (`Order`, `WarehouseManager`, `WarehouseApp`) with clear responsibilities.
 * *   **Static Members:** Using a static variable (`nextOrderId`) in the `Order` class to maintain state across all instances for generating unique IDs.
 * *   **Polymorphism:** Using the `List` interface type for `completedOrders` while instantiating it as an `ArrayList`.
 * 
 * The solution provides a practical example of how these core Java concepts and components can be combined to build an interactive, stateful application with basic error handling and input validation.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single order in the system
class Order {
    private static int nextOrderId = 1; // Static counter for unique IDs

    private int orderId;
    private String productName;
    private int quantity;
    private String status;

    // Constructor
    public Order(String productName, int quantity) {
        this.orderId = nextOrderId++; // Assign unique ID and increment counter
        this.productName = productName;
        this.quantity = quantity;
        this.status = "Pending"; // New orders are pending by default
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public String getProductName() {
        return productName;
    }

    public int getQuantity() {
        return quantity;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Order ID: %d, Product: %s, Quantity: %d, Status: %s",
                             orderId, productName, quantity, status);
    }
}

// Manages the warehouse operations: pending and completed orders
class WarehouseManager {
    // Use Queue for pending orders (FIFO)
    private Queue<Order> pendingOrders;
    // Use List for completed orders
    private List<Order> completedOrders;
    private Scanner scanner; // Scanner for user input

    // Constructor
    public WarehouseManager() {
        // LinkedList is a common implementation for Queue
        this.pendingOrders = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.completedOrders = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Adds a new order to the pending queue
    public void addOrder() {
        System.out.print("Enter product name: ");
        String productName = scanner.nextLine();

        int quantity = -1; // Initialize with an invalid value
        boolean validQuantity = false;
        while (!validQuantity) {
            System.out.print("Enter quantity: ");
            try {
                quantity = scanner.nextInt();
                if (quantity > 0) {
                    validQuantity = true;
                } else {
                    System.err.println("Error: Quantity must be a positive integer.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter an integer for quantity.");
                scanner.next(); // Consume the invalid input
            } finally {
                 // Consume the rest of the line after nextInt()
                 // This is important to prevent issues with nextLine() in the next iteration
                 // if nextInt() successfully read an integer but there was trailing whitespace/newline
                 if (validQuantity) {
                      scanner.nextLine();
                 }
            }
        }

        Order newOrder = new Order(productName, quantity);
        pendingOrders.offer(newOrder); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
        System.out.println("Order " + newOrder.getOrderId() + " (" + productName + ", Qty: " + quantity + ") added to pending.");
    }

    // Processes the next order from the pending queue
    public void processNextOrder() {
        if (pendingOrders.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
            return;
        }

        Order orderToProcess = pendingOrders.poll(); // poll() removes and returns the head of the queue, or null if empty
        if (orderToProcess != null) {
            orderToProcess.setStatus("Completed");
            completedOrders.add(orderToProcess);
            System.out.println("Processing order " + orderToProcess.getOrderId() + "...");
            System.out.println("Order " + orderToProcess.getOrderId() + " (" + orderToProcess.getProductName() + ", Qty: " + orderToProcess.getQuantity() + ") moved to completed.");
        }
        // Note: poll() returns null if empty, but we already checked isEmpty().
        // This structure handles it robustly.
    }

    // Displays all orders in the pending queue
    public void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("--- End Pending Orders ---");
    }

    // Displays all orders in the completed list
    public void viewCompletedOrders() {
        System.out.println("--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            // Iterate through the list
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("--- End Completed Orders ---");
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Warehouse Order Management ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the simulation
    public void run() {
        int choice = 0;
        boolean running = true;

        while (running) {
            displayMenu();
            try {
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    // Handle non-integer input
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid token
                    continue; // Skip to the next iteration of the loop
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        addOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewPendingOrders();
                        break;
                    case 4:
                        viewCompletedOrders();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }
}

// Main class to start the application
public class WarehouseApp {
    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        manager.run(); // Start the simulation
    }
}
