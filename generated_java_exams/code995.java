/*
 * Exam Question #995
 * Generated on: 2025-05-12 17:10:15
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Cloud Task Scheduler Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line simulation of a cloud task scheduler. This system manages tasks submitted by users, placing them in a queue for processing and maintaining a record of completed tasks. Your program should allow users to interact with the scheduler via a menu-driven interface.
 * 
 * **Functional Requirements:**
 * 
 * 1.  **Add Task:** Allow the user to add a new task by providing a description. Each task should be assigned a unique sequential ID automatically by the system. New tasks are added to a queue of pending tasks.
 * 2.  **Process Next Task:** Take the next task from the front of the pending task queue, mark it as completed, and move it to a list of completed tasks. If the queue is empty, inform the user.
 * 3.  **View Pending Tasks:** Display all tasks currently in the pending queue, in the order they would be processed.
 * 4.  **View Completed Tasks:** Display all tasks that have been processed and moved to the completed list.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Constraints:**
 * 
 * Your solution **must** use and demonstrate understanding of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the pending tasks (First-In, First-Out).
 * *   `java.util.ArrayList`: To store the completed tasks.
 * *   `java.util.List` interface: Use `List` as the type for variables or method return types where appropriate (e.g., when returning collections of tasks).
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the different menu options selected by the user.
 * *   `System.err`: To display error messages (e.g., invalid input, attempting to process an empty queue).
 * *   `System.out`: To display normal output (menu, prompts, task lists, confirmations).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, including handling potential issues like invalid user input format or unexpected runtime errors. A general `try-catch` around the main application loop is required, in addition to specific handling where necessary (e.g., input reading).
 * 
 * **Implementation Details & Best Practices:**
 * 
 * *   Design your solution using appropriate classes (e.g., a `Task` class and a `TaskScheduler` class).
 * *   Use proper encapsulation (private fields, public methods).
 * *   Choose meaningful variable and method names.
 * *   Include appropriate comments and JavaDocs to explain your code.
 * *   Implement input validation (e.g., ensure task description is not empty).
 * *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * --- Cloud Task Scheduler Simulation ---
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the user's choice, the program should perform the corresponding action and provide feedback using `System.out` or `System.err`.
 * 
 * *   Adding a task: Prompts for description, confirms task added with ID.
 * *   Processing a task: Confirms which task was processed or indicates if the queue was empty (`System.err`).
 * *   Viewing tasks: Lists tasks with their ID, status, and description, or indicates if the list is empty.
 * *   Invalid input: Prints an error message using `System.err`.
 * *   Unexpected errors: Caught by the general `try-catch` and reported using `System.err`.
 * 
 * Your code should be a single compilable unit (can be in separate classes within the same file for exam purposes).
 * 
 * **Grading Focus:**
 * 
 * Your solution will be evaluated on:
 * *   Correctness of implementation according to functional requirements.
 * *   Proper and effective usage of ALL required Java components.
 * *   Robustness of error handling and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 *
 * EXPLANATION:
 * This solution implements a simple Cloud Task Scheduler simulation, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Class:** A simple class representing a task with an ID, description, and status. It demonstrates encapsulation with private fields and public getters/methods (`markCompleted`). The constructor includes basic input validation for the description.
 * 
 * 2.  **TaskScheduler Class:** This class manages the core logic.
 *     *   `pendingTasks`: A `Queue<Task>` (implemented using `LinkedList`) is used to store tasks waiting to be processed, ensuring FIFO order.
 *     *   `completedTasks`: A `List<Task>` (implemented using `ArrayList`) is used to store tasks that have finished processing. `ArrayList` is suitable here as we might need to iterate or simply store completed items without strict FIFO/LIFO requirements for retrieval.
 *     *   `nextTaskId`: A simple integer counter generates unique IDs for new tasks.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. Includes `try-catch` to handle potential `IllegalArgumentException` from the `Task` constructor if the description is invalid, printing the error using `System.err`.
 *     *   `processNextTask()`: Retrieves and removes the head of the `pendingTasks` queue using `poll()`. If a task is retrieved, its status is updated, and it's added to the `completedTasks` list. If the queue is empty, an informative message is printed to `System.err`. Includes a general `try-catch` for unexpected errors during processing.
 *     *   `getPendingTasks()`: Returns a `List<Task>` representation of the pending queue. A new `ArrayList` is created from the queue's elements to avoid exposing the internal queue structure and allowing external modification that would break the queue's behavior. The return type is the `List` interface.
 *     *   `getCompletedTasks()`: Returns the `List<Task>` containing completed tasks. The return type is the `List` interface, hiding the underlying `ArrayList` implementation.
 * 
 * 3.  **SchedulerApp Class:** This class contains the `main` method and handles the user interface.
 *     *   `Scanner`: Used to read user input from `System.in`.
 *     *   Main Loop: A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   Menu: `printMenu()` displays options using `System.out`.
 *     *   Input Handling: Reads the user's choice. A `try-catch(InputMismatchException)` specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and preventing a crash or infinite loop. `scanner.nextLine()` is used after `nextInt()` to consume the remaining newline character.
 *     *   `switch` Statement: Controls the program flow based on the valid integer input, directing execution to the corresponding logic for adding, processing, viewing, or exiting. The `default` case handles valid integer inputs that don't match any menu option, printing an error to `System.err`.
 *     *   `System.out` and `System.err`: Used consistently for normal output (`System.out`) and error/warning messages (`System.err`) as required.
 *     *   Class-wide Exception Handling: A large `try-catch(Exception e)` block wraps the main `while` loop. This provides a safety net to catch any unexpected runtime exceptions that might occur during the execution of the menu logic or calls to the `TaskScheduler`, printing an error to `System.err` and the stack trace.
 *     *   Resource Management: The `finally` block ensures that the `Scanner` object is closed properly when the program exits or an unexpected exception occurs, preventing resource leaks.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, simulation. It demonstrates good object-oriented design principles (encapsulation) and includes essential error handling and input validation for a robust application.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 * Demonstrates encapsulation with private fields and public getters/methods.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(int taskId, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.status = "Pending"; // Initial status
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including ID, status, and description.
     */
    @Override
    public String toString() {
        return String.format("Task [ID=%d, Status=%s, Description='%s']",
                             taskId, status, description);
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 * Demonstrates usage of Queue, List, and ArrayList.
 */
class TaskScheduler {
    // Queue to hold tasks waiting for processing (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been processed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskScheduler, initializing the task collections.
     */
    public TaskScheduler() {
        // Using LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            // Task constructor includes validation for description
            Task newTask = new Task(nextTaskId++, description);
            pendingTasks.offer(newTask); // offer is preferred over add for queues, returns false on failure (rare)
            System.out.println("Task added: " + newTask.getDescription() + " (ID: " + newTask.getTaskId() + ")");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor
            System.err.println("Error adding task: " + e.getMessage()); // Using System.err for error message
            // nextTaskId is not incremented if Task creation fails
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation/addition
             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
             // In a real app, you might log the full stack trace
        }
    }

    /**
     * Processes the next task in the queue.
     * Moves the task from pending to completed list.
     */
    public void processNextTask() {
        try {
            // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
            Task taskToProcess = pendingTasks.poll();
            if (taskToProcess != null) {
                taskToProcess.markCompleted(); // Update task status
                completedTasks.add(taskToProcess); // Add to completed list
                System.out.println("Task processed: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getTaskId() + ")");
            } else {
                // Using System.err when no task is available to process
                System.err.println("No pending tasks to process.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during processing
            System.err.println("An unexpected error occurred while processing task: " + e.getMessage());
            // In a real app, you might log the full stack trace
        }
    }

    /**
     * Gets a list of all pending tasks.
     * Returns a new list to prevent external modification of the internal queue state.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList from the elements currently in the queue.
        // This iterates over the queue without removing elements.
        // Returning List interface type.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     * @return A List of completed tasks (the internal ArrayList reference).
     */
    public List<Task> getCompletedTasks() {
        // Returning the internal List reference.
        // For a simple exam, this is acceptable. In production, might return
        // Collections.unmodifiableList(completedTasks) for better immutability.
        // Returning List interface type.
        return completedTasks;
    }
}

/**
 * Main application class for the Task Scheduler simulation.
 * Provides a command-line interface using Scanner and switch statement.
 * Includes class-wide exception handling.
 */
public class SchedulerApp {

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        // Using Scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Cloud Task Scheduler Simulation ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read user's menu choice
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option."); // Using System.err
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Using switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        scheduler.addTask(description); // Call scheduler method
                        break;
                    case 2:
                        scheduler.processNextTask(); // Call scheduler method
                        break;
                    case 3:
                        System.out.println("\n--- Pending Tasks ---"); // Using System.out
                        List<Task> pending = scheduler.getPendingTasks(); // Get List of pending tasks
                        if (pending.isEmpty()) {
                            System.out.println("No tasks pending."); // Using System.out
                        } else {
                            // Iterate and print pending tasks (demonstrates List usage)
                            for (Task task : pending) {
                                System.out.println(task); // Uses Task.toString()
                            }
                        }
                        System.out.println("---------------------"); // Using System.out
                        break;
                    case 4:
                        System.out.println("\n--- Completed Tasks ---"); // Using System.out
                        List<Task> completed = scheduler.getCompletedTasks(); // Get List of completed tasks (ArrayList internally)
                        if (completed.isEmpty()) {
                            System.out.println("No tasks completed yet."); // Using System.out
                        } else {
                             // Iterate and print completed tasks (demonstrates List usage)
                             for (Task task : completed) {
                                System.out.println(task); // Uses Task.toString()
                            }
                        }
                        System.out.println("-----------------------"); // Using System.out
                        break;
                    case 5:
                        System.out.println("Exiting scheduler. Goodbye!"); // Using System.out
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Using System.err
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that occur during the main program flow
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage()); // Using System.err
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
