/*
 * Exam Question #1111
 * Generated on: 2025-05-12 17:26:17
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Objective:** Design and implement a simple command-line Task Management System that allows users to add, view, and process tasks. This system should demonstrate a solid understanding of core Java data structures, user input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are building a basic system for managing tasks that need to be processed in the order they are received. Some tasks might be "Urgent" but still follow the first-in, first-out processing rule in this simplified system.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are pending processing. The tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare the completed tasks collection using the `java.util.List` interface.
 * 
 * 2.  **Task Representation:**
 *     *   Create a `Task` class (or similar) with private fields for `id` (unique integer, auto-generated), `description` (String), `type` (String, e.g., "General", "Urgent"), and `status` (String, e.g., "Pending", "Completed").
 *     *   Include appropriate public getter methods and a method to update the status.
 *     *   Implement a `toString()` method for easy printing of task details.
 * 
 * 3.  **Task Management Logic:**
 *     *   Create a `TaskManager` class (or similar) to encapsulate the task management logic.
 *     *   This class should contain the `Queue` for pending tasks and the `List` for completed tasks as private instance variables.
 *     *   Implement methods within `TaskManager` for:
 *         *   Adding a new task to the pending queue.
 *         *   Processing the next task: This involves taking the task from the front of the pending queue, updating its status to "Completed", and moving it to the completed list. Handle the case where the queue is empty.
 *         *   Retrieving/displaying the list of pending tasks.
 *         *   Retrieving/displaying the list of completed tasks.
 * 
 * 4.  **User Interface (Command Line):**
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Present a menu of options to the user (e.g., Add Task, Process Next Task, View Pending Tasks, View Completed Tasks, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The program should run in a loop until the user chooses to exit.
 * 
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for normal program output (menu, prompts, success messages, task lists).
 *     *   Use `System.err` to display error messages (e.g., invalid menu input, attempting to process an empty queue).
 *     *   Implement class-wide exception handling (using `try-catch`) within the main program loop or input reading method to gracefully handle potential input errors (e.g., user entering non-numeric input for the menu choice).
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to Java naming conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include basic input validation where appropriate (e.g., check if description is empty).
 *     *   Add comments to explain complex parts of the code (if any).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * **Expected Output:**
 * 
 * The program should start, display a menu, and respond to user input. Example interaction:
 * 
 * ```
 * --- Task Management System ---
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Enter task type (e.g., General, Urgent): General
 * Task added: Write exam question (ID: 1)
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Grade student papers
 * Enter task type (e.g., General, Urgent): Urgent
 * Task added: Grade student papers (ID: 2)
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task{id=1, description='Write exam question', type='General', status='Pending'}
 * Task{id=2, description='Grade student papers', type='Urgent', status='Pending'}
 * ---------------------
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Task processed: Write exam question (ID: 1)
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task{id=2, description='Grade student papers', type='Urgent', status='Pending'}
 * ---------------------
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task{id=1, description='Write exam question', type='General', status='Completed'}
 * -----------------------
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * **Submission:** Provide the complete Java code for all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System adhering to all specified requirements.
 * 
 * 1.  **Class Structure:**
 *     *   `Task` class: Encapsulates the data for a single task (ID, description, type, status) with appropriate getters and a status setter. It also includes a static counter (`nextId`) to ensure unique IDs for each task instance and an overridden `toString()` for easy printing.
 *     *   `TaskManager` class: Manages the collections of tasks. It holds the `pendingTasks` (a `Queue<Task>`) and `completedTasks` (a `List<Task>`, implemented as `ArrayList<Task>`). This class contains the core logic methods (`addTask`, `processNextTask`, `displayPendingTasks`, `displayCompletedTasks`). Using a `Queue` (specifically `LinkedList` in this case) for pending tasks ensures FIFO processing, while a `List` (`ArrayList`) is suitable for storing completed tasks where order of completion is relevant and random access might be needed later (though not explicitly used in this example).
 *     *   `ExamTaskSystem` class: The main class that contains the `main` method. It handles the user interaction loop, displays the menu, reads user input using `Scanner`, and delegates the task management operations to an instance of `TaskManager`.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: Used for `pendingTasks` to maintain the order of tasks waiting to be processed (FIFO). The `offer()` method is used to add tasks, and `poll()` is used to retrieve and remove the next task.
 *     *   `java.util.ArrayList`: Used as the concrete implementation for the `completedTasks` list.
 *     *   `java.util.List`: The `completedTasks` collection is declared using the `List` interface, demonstrating polymorphism and good practice.
 *     *   `java.util.Scanner`: Used in the `ExamTaskSystem` class to read user input from `System.in`.
 *     *   `switch` statement: Used in the `main` method of `ExamTaskSystem` to control the program flow based on the user's menu choice.
 *     *   `System.err`: Used in `TaskManager.processNextTask()` when there are no pending tasks and in `ExamTaskSystem.getUserChoice()` and `main`'s `default` case for displaying error messages to the standard error stream.
 *     *   `System.out`: Used throughout the `ExamTaskSystem` and `TaskManager` classes for displaying menus, prompts, success messages, and task lists to the standard output stream.
 *     *   `try-catch` blocks: A `try-catch` block is specifically used in the `getUserChoice()` method within `ExamTaskSystem` to catch `InputMismatchException`, which occurs if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. This handles potential input errors gracefully.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, accessed via `public` methods where necessary.
 *     *   **Naming:** Classes, variables, and methods have descriptive names (`Task`, `TaskManager`, `pendingTasks`, `processNextTask`, `getUserChoice`).
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** Basic validation is performed in `addTask` to ensure the description is not empty or just whitespace. The `getUserChoice` method handles non-numeric input validation.
 *     *   **Error Handling:** `try-catch` is used for input errors. `System.err` is used for logical errors (like processing an empty queue).
 *     *   **Clean Code Structure:** The logic is separated into distinct classes with specific responsibilities (`Task` for data, `TaskManager` for logic, `ExamTaskSystem` for UI/orchestration). Helper methods like `displayMenu` and `getUserChoice` improve readability and modularity. The `Scanner` is properly closed upon exiting.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, albeit simplified, application context, providing a solid foundation for assessing an advanced student's understanding. The use of `Queue` for FIFO processing and `List`/`ArrayList` for storage, combined with robust input handling and error reporting, covers key aspects of Java programming.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private static int nextId = 1; // Auto-incrementing ID for tasks
    private int id;
    private String description;
    private String type; // e.g., "General", "Urgent"
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task with a generated ID and initial status "Pending".
     *
     * @param description The description of the task.
     * @param type The type of the task (e.g., "General", "Urgent").
     */
    public Task(String description, String type) {
        this.id = nextId++;
        this.description = description;
        this.type = type;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task object.
     * @return String representation including ID, description, type, and status.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", type='" + type + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Manages the collection of pending and completed tasks.
 * Uses a Queue for pending tasks (FIFO) and a List for completed tasks.
 */
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Performs basic validation on the description.
     *
     * @param description The description for the new task.
     * @param type The type for the new task.
     */
    public void addTask(String description, String type) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }
        // Create a new Task object and add it to the end of the queue
        Task newTask = new Task(description.trim(), type != null ? type.trim() : "General");
        pendingTasks.offer(newTask); // offer is the preferred way to add to a queue
        System.out.println("Task added: " + newTask.getDescription() + " (ID: " + newTask.getId() + ")");
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue, updates its status, and adds it to the completed list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess != null) {
            taskToProcess.setStatus("Completed"); // Update status
            completedTasks.add(taskToProcess); // Add to completed list
            System.out.println("Task processed: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");
        } else {
            // Use System.err for error message
            System.err.println("Error: No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void displayPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate through the queue without removing elements
            pendingTasks.forEach(task -> System.out.println(task));
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void displayCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the list
            completedTasks.forEach(task -> System.out.println(task));
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main class for the Task Management System.
 * Handles user interaction and orchestrates the TaskManager.
 */
public class ExamTaskSystem {

    // Use a single Scanner for the application
    private static Scanner scanner = new Scanner(System.in);
    private static TaskManager taskManager = new TaskManager(); // Instance of the TaskManager

    /**
     * Main method to run the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("--- Task Management System ---");

        boolean running = true;
        // Main application loop
        while (running) {
            displayMenu();
            int choice = getUserChoice(); // Get user input with validation

            // Use switch statement for menu navigation
            switch (choice) {
                case 1: // Add Task
                    System.out.print("Enter task description: ");
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                    String description = scanner.nextLine();
                    System.out.print("Enter task type (e.g., General, Urgent): ");
                    String type = scanner.nextLine();
                    taskManager.addTask(description, type);
                    break;
                case 2: // Process Next Task
                    taskManager.processNextTask();
                    break;
                case 3: // View Pending Tasks
                    taskManager.displayPendingTasks();
                    break;
                case 4: // View Completed Tasks
                    taskManager.displayCompletedTasks();
                    break;
                case 5: // Exit
                    System.out.println("Exiting Task Management System. Goodbye!");
                    running = false; // Set running to false to exit the loop
                    break;
                case -1: // Indicates invalid input handled by getUserChoice
                    // Error message already printed in getUserChoice
                    break;
                default: // Handles integer choices outside the valid range
                    System.err.println("Invalid choice. Please enter a number between 1 and 5.");
            }
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\nSelect an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads the user's integer choice from the console.
     * Includes exception handling for non-integer input.
     *
     * @return The valid integer choice, or -1 if input was invalid.
     */
    private static int getUserChoice() {
        try {
            // Attempt to read an integer
            int choice = scanner.nextInt();
            return choice;
        } catch (InputMismatchException e) {
            // Catch exception if input is not an integer
            System.err.println("Invalid input. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
            return -1; // Return a sentinel value indicating an error
        }
    }
}
