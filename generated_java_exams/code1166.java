/*
 * Exam Question #1166
 * Generated on: 2025-05-12 17:34:00
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Event Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Event Management System for a popular event with limited capacity. The system needs to manage registered attendees and a waiting list for potential attendees who couldn't get a spot initially.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your program must:
 * 
 * 1.  Define an `Attendee` class with a private field for the attendee's name and appropriate methods (constructor, getter, `toString`).
 * 2.  Define an `EventManager` class that manages the attendees. This class must have:
 *     *   A private `List` (specifically using `ArrayList`) to store registered attendees.
 *     *   A private `Queue` (using any suitable `java.util.Queue` implementation like `ArrayDeque`) to store attendees on the waiting list.
 *     *   A private field for the maximum capacity of the event.
 *     *   A constructor to initialize the lists/queue and set the maximum capacity.
 *     *   A public method `addAttendee(Attendee attendee)`: If capacity is available, add the attendee to the registered list and print a success message to `System.out`. If full, add the attendee to the waiting list and print a message to `System.out` indicating they are on the waiting list.
 *     *   A public method `processWaitingList(int numSpots)`: Simulates opening up `numSpots` in the event. This method should move attendees from the waiting list to the registered list, up to `numSpots` or until the waiting list is empty, *whichever is less*, and respecting the event's maximum capacity. Print details of attendees moved to `System.out`. Return the number of attendees actually moved.
 *     *   Public methods `displayRegisteredAttendees()` and `displayWaitingList()` to print the contents of each list/queue to `System.out`.
 *     *   Public methods to get the current count of registered attendees and waiting list attendees.
 * 3.  Implement a main application class (`EventApp`) with a `main` method that provides a command-line interface using `Scanner`.
 * 4.  The `main` method should:
 *     *   Prompt the user for the maximum event capacity upon startup. Validate that the capacity is a positive integer. Use `try-catch` for input validation.
 *     *   Create an `EventManager` instance with the specified capacity.
 *     *   Present a menu to the user with options:
 *         1.  Add Attendee
 *         2.  Process Waiting List Spots
 *         3.  View Registered Attendees
 *         4.  View Waiting List
 *         5.  View Event Status
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement the logic for each menu option by calling the appropriate methods in the `EventManager`.
 *     *   For options requiring numerical input (capacity, number of spots to process), use `try-catch` blocks to handle `java.util.InputMismatchException` and other potential input errors.
 *     *   Display error messages for invalid input or actions (e.g., processing negative spots) using `System.err`.
 *     *   Use `System.out` for all normal output (menu, success messages, list displays).
 *     *   Ensure the program handles the case where the waiting list is empty when processing spots.
 *     *   Ensure the program handles the case where there are fewer available spots than requested when processing the waiting list.
 *     *   Implement class-wide exception handling where appropriate (e.g., around the main input loop or specific input operations).
 *     *   Close the `Scanner` resource properly.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying menus, prompts, success messages, list contents, and error messages as described above. The output should be clear and formatted for readability.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Enter maximum event capacity: 3
 * Event capacity set to 3.
 * 
 * Event Management Menu:
 * 1. Add Attendee
 * 2. Process Waiting List Spots
 * 3. View Registered Attendees
 * 4. View Waiting List
 * 5. View Event Status
 * 6. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Bob registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: Charlie
 * Charlie registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: David
 * Event is full. David added to waiting list.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 5
 * Event Status:
 * Capacity: 3
 * Registered: 3
 * Waiting List: 1
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 2
 * Enter number of spots to process: 1
 * Processing 1 spot from waiting list...
 * Moved David from waiting list to registered attendees.
 * Successfully moved 1 attendee(s) from waiting list.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 3
 * Registered Attendees:
 * 1. Alice
 * 2. Bob
 * 3. Charlie
 * 4. David
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 4
 * Waiting List:
 * (Empty)
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 2
 * Enter number of spots to process: 1
 * Processing 1 spot from waiting list...
 * Waiting list is empty. No attendees moved.
 * Successfully moved 0 attendee(s) from waiting list.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 6
 * Exiting Event Management System.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Follow object-oriented principles (encapsulation).
 * *   Include basic input validation and error handling.
 * *   Provide clear output.
 * 
 * ```java
 * // Solution code goes here
 * ```
 *
 * EXPLANATION:
 * The provided solution implements the Event Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Structure:**
 * 
 * 1.  **`Attendee` Class:** A simple class encapsulating the attendee's name. It includes a constructor with basic validation and a `toString` method for convenient printing.
 * 2.  **`EventManager` Class:** This is the core class managing the event state.
 *     *   It uses a `java.util.ArrayList` (`registeredAttendees`) to store attendees who have successfully registered. `ArrayList` is suitable here as we might need to iterate through the list or access elements by index (though index access isn't strictly used in this version, `ArrayList` is a common `List` implementation). The field is declared as `List` to program to the interface.
 *     *   It uses a `java.util.Queue` (`waitingList`), specifically implemented with `java.util.ArrayDeque`. `Queue` is the appropriate data structure for a waiting list because it enforces a First-In, First-Out (FIFO) order, meaning the person who has been waiting longest is the first one to get a spot when available. `ArrayDeque` is an efficient implementation of a `Queue`.
 *     *   It stores the `maxCapacity` as a private integer.
 *     *   Methods like `addAttendee`, `processWaitingList`, `displayRegisteredAttendees`, and `displayWaitingList` encapsulate the system's logic, operating on the private data structures.
 * 3.  **`EventApp` Class:** This class contains the `main` method, serving as the application's entry point and handling user interaction.
 *     *   It initializes the `Scanner` for input.
 *     *   It handles the initial capacity input and validation using a `try-catch` block for `InputMismatchException` and a check for positive capacity.
 *     *   It creates the `EventManager` instance.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, it displays a menu and reads the user's choice.
 *     *   A `switch` statement directs the program flow based on the user's integer input.
 *     *   Each case in the `switch` calls the relevant method in the `EventManager`.
 *     *   Input operations (`scanner.nextInt()`, `scanner.nextLine()`) are wrapped in `try-catch` blocks to handle invalid input gracefully. `InputMismatchException` is specifically caught for numerical inputs. `scanner.next()` or `scanner.nextLine()` is used after catching `InputMismatchException` to consume the invalid token from the scanner's buffer, preventing infinite loops.
 *     *   A general `Exception` catch is included in the main loop for robustness against unexpected errors.
 *     *   `System.err.println()` is used exclusively for printing error messages, while `System.out.println()` is used for all normal program output (menu, prompts, success messages, list contents, status).
 *     *   The `Scanner` is closed using `scanner.close()` after the main loop terminates.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures (`List`, `ArrayList`, `Queue`, `ArrayDeque`):** Correct usage of `ArrayList` for a dynamic list of registered items and `ArrayDeque` as a `Queue` for managing a waiting list based on FIFO principle. Demonstrates programming to the `List` and `Queue` interfaces.
 * *   **Object-Oriented Programming:** Encapsulation through private fields and public methods in `Attendee` and `EventManager` classes. Separation of concerns (data representation in `Attendee`, business logic in `EventManager`, user interface in `EventApp`).
 * *   **User Input (`Scanner`):** Reading various types of input (`int`, `String`) from the console.
 * *   **Control Flow (`switch`, `while`):** Using a `while` loop for the main application loop and a `switch` statement for handling multiple menu options based on an integer choice.
 * *   **Error Handling (`try-catch`, `System.err`):** Implementing robust input validation and handling potential exceptions (`InputMismatchException`, `IllegalArgumentException`). Using `System.err` for clear error reporting distinct from normal output.
 * *   **Input Validation:** Checking for positive capacity and positive number of spots to process. Validating attendee name is not empty.
 * *   **Resource Management:** Closing the `Scanner` to prevent resource leaks.
 * *   **Best Practices:** Meaningful variable and method names, comments where necessary, clear output formatting.
 * 
 * This solution effectively combines these elements to create a functional and relatively complex program that tests a student's understanding of fundamental and intermediate Java concepts in a practical context.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.ArrayDeque; // A common Queue implementation
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an attendee for the event
class Attendee {
    private String name;

    // Constructor
    public Attendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return name;
    }
}

// Manages the event attendees and waiting list
class EventManager {
    private List<Attendee> registeredAttendees;
    private Queue<Attendee> waitingList;
    private int maxCapacity;

    // Constructor
    public EventManager(int maxCapacity) {
        if (maxCapacity <= 0) {
            throw new IllegalArgumentException("Maximum capacity must be a positive integer.");
        }
        this.maxCapacity = maxCapacity;
        this.registeredAttendees = new ArrayList<>();
        this.waitingList = new ArrayDeque<>(); // Using ArrayDeque as a Queue implementation
    }

    // Adds an attendee to the event or waiting list
    public void addAttendee(Attendee attendee) {
        if (attendee == null) {
             System.err.println("Error: Cannot add a null attendee.");
             return;
        }

        if (registeredAttendees.size() < maxCapacity) {
            registeredAttendees.add(attendee);
            System.out.println(attendee.getName() + " registered successfully.");
        } else {
            waitingList.offer(attendee); // offer() is Queue's add() variant
            System.out.println("Event is full. " + attendee.getName() + " added to waiting list.");
        }
    }

    // Processes a given number of spots from the waiting list
    public int processWaitingList(int numSpots) {
        if (numSpots <= 0) {
            System.err.println("Error: Number of spots to process must be positive.");
            return 0;
        }

        int availableSpots = maxCapacity - registeredAttendees.size();
        if (availableSpots <= 0) {
            System.out.println("No spots available in the event.");
            return 0;
        }

        int attendeesMoved = 0;
        System.out.println("Processing " + numSpots + " spot(s) from waiting list...");

        // Move attendees from waiting list up to numSpots or availableSpots, whichever is less,
        // and only if the waiting list is not empty.
        while (attendeesMoved < numSpots && availableSpots > 0 && !waitingList.isEmpty()) {
            Attendee nextAttendee = waitingList.poll(); // poll() removes and returns the head
            registeredAttendees.add(nextAttendee);
            System.out.println("Moved " + nextAttendee.getName() + " from waiting list to registered attendees.");
            attendeesMoved++;
            availableSpots--; // Decrement available spots
        }

        if (attendeesMoved == 0) {
             System.out.println("Waiting list is empty or no spots became available. No attendees moved.");
        } else {
             System.out.println("Successfully moved " + attendeesMoved + " attendee(s) from waiting list.");
        }
        return attendeesMoved;
    }

    // Displays all registered attendees
    public void displayRegisteredAttendees() {
        System.out.println("\nRegistered Attendees:");
        if (registeredAttendees.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (int i = 0; i < registeredAttendees.size(); i++) {
                System.out.println((i + 1) + ". " + registeredAttendees.get(i).getName());
            }
        }
    }

    // Displays all attendees on the waiting list
    public void displayWaitingList() {
        System.out.println("\nWaiting List:");
        if (waitingList.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Attendee attendee : waitingList) {
                System.out.println((i++) + ". " + attendee.getName());
            }
        }
    }

    // Get current count of registered attendees
    public int getRegisteredCount() {
        return registeredAttendees.size();
    }

    // Get current count of waiting list attendees
    public int getWaitingCount() {
        return waitingList.size();
    }

    // Get maximum capacity
    public int getCapacity() {
        return maxCapacity;
    }
}

// Main application class
public class EventApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = null;

        // Get and validate event capacity
        while (eventManager == null) {
            System.out.print("Enter maximum event capacity: ");
            try {
                int capacity = scanner.nextInt();
                if (capacity <= 0) {
                    System.err.println("Error: Capacity must be a positive integer.");
                } else {
                    eventManager = new EventManager(capacity);
                    System.out.println("Event capacity set to " + capacity + ".");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                 System.err.println("Error: " + e.getMessage());
            }
        }

        boolean running = true;
        while (running) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1: // Add Attendee
                        System.out.print("Enter attendee name: ");
                        String name = scanner.nextLine();
                         try {
                             Attendee newAttendee = new Attendee(name);
                             eventManager.addAttendee(newAttendee);
                         } catch (IllegalArgumentException e) {
                             System.err.println("Error adding attendee: " + e.getMessage());
                         }
                        break;

                    case 2: // Process Waiting List Spots
                        System.out.print("Enter number of spots to process: ");
                        try {
                            int numSpots = scanner.nextInt();
                            eventManager.processWaitingList(numSpots);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a number for spots.");
                            scanner.next(); // Consume invalid input
                        }
                        break;

                    case 3: // View Registered Attendees
                        eventManager.displayRegisteredAttendees();
                        break;

                    case 4: // View Waiting List
                        eventManager.displayWaitingList();
                        break;

                    case 5: // View Event Status
                        System.out.println("\nEvent Status:");
                        System.out.println("Capacity: " + eventManager.getCapacity());
                        System.out.println("Registered: " + eventManager.getRegisteredCount());
                        System.out.println("Waiting List: " + eventManager.getWaitingCount());
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Event Management System.");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a newline for better readability between interactions
        }

        scanner.close(); // Close the scanner resource
    }

    // Prints the main menu options
    private static void printMenu() {
        System.out.println("Event Management Menu:");
        System.out.println("1. Add Attendee");
        System.out.println("2. Process Waiting List Spots");
        System.out.println("3. View Registered Attendees");
        System.out.println("4. View Waiting List");
        System.out.println("5. View Event Status");
        System.out.println("6. Exit");
    }
}
