/*
 * Exam Question #1115
 * Generated on: 2025-05-12 17:26:53
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:**
 * 
 * Design and implement a console-based application that simulates a simple print job management system. The system should handle print jobs with different priorities, process them sequentially based on priority, and allow users to view waiting and completed jobs. This task requires demonstrating proficiency in core Java data structures, control flow, user input handling, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Project Structure:** Implement the system using at least two classes: `PrintJob` and `PrintJobManager`.
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage print jobs that are waiting to be processed. Implement a priority mechanism where jobs submitted as "High" priority are processed before jobs submitted as "Low" priority. You may use one or more Queue instances to achieve this.
 *     *   Use `java.util.ArrayList` to store a history of print jobs that have been successfully processed.
 *     *   Utilize the `java.util.List` interface when defining method return types that provide views of collections (e.g., listing waiting or completed jobs).
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read commands and input from the user via the console.
 *     *   The system should support the following commands (case-insensitive for the command word):
 *         *   `submit <jobName> <priority>`: Creates a new print job with the given name and priority ("High" or "Low"). Adds the job to the appropriate waiting queue. The system should assign a unique ID to each job.
 *         *   `process`: Processes the next available job from the waiting queue. High-priority jobs must be processed before low-priority jobs. If a job is processed, remove it from the waiting queue and add it to the list of completed jobs.
 *         *   `list_waiting`: Displays all jobs currently in the waiting queues, indicating their ID, name, priority, and status ("Waiting"). List high-priority jobs first, then low-priority jobs.
 *         *   `list_completed`: Displays all jobs that have been processed, indicating their ID, name, priority, and status ("Completed").
 *         *   `exit`: Terminates the application.
 * 4.  **Control Flow:** Use a `switch` statement within your main command processing loop to handle the different user commands.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying welcome messages, command prompts, confirmations of actions (like job submission or processing), and listing job details.
 *     *   Use `System.err` to display error messages (e.g., invalid command format, invalid priority, trying to process when no jobs are waiting).
 * 6.  **Error Handling:**
 *     *   Implement input validation for user commands and arguments (e.g., check for the correct number of arguments, validate the priority string).
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main command processing loop to catch and report unexpected runtime errors gracefully.
 * 7.  **Best Practices:**
 *     *   Apply encapsulation by making class fields private and providing public methods to access/modify them where necessary.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include brief comments to explain complex logic or class purpose.
 *     *   Ensure the code structure is clean and readable.
 * 
 * **Expected Output Format (Examples):**
 * 
 * ```
 * Print Job Management System
 * Commands: submit <name> <priority (High/Low)>, process, list_waiting, list_completed, exit
 * > submit Document High
 * High priority job submitted: Job ID: 1, Name: Document, Priority: High, Status: Waiting
 * > submit Image Low
 * Low priority job submitted: Job ID: 2, Name: Image, Priority: Low, Status: Waiting
 * > process
 * Processed job: Job ID: 1, Name: Document, Priority: High, Status: Completed
 * > list_waiting
 * --- Waiting Jobs ---
 * Job ID: 2, Name: Image, Priority: Low, Status: Waiting
 * --------------------
 * > list_completed
 * --- Completed Jobs ---
 * Job ID: 1, Name: Document, Priority: High, Status: Completed
 * ----------------------
 * > invalid_cmd
 * Unknown command: invalid_cmd
 * Commands: submit <name> <priority (High/Low)>, process, list_waiting, list_completed, exit
 * > exit
 * Exiting Print Job Management System.
 * ```
 * 
 * Your solution should be a complete, runnable Java program.
 *
 * EXPLANATION:
 * This solution implements a `PrintJob Management System` as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print job.
 *     *   Uses `private` fields (`id`, `name`, `priority`, `status`) to enforce encapsulation.
 *     *   Provides `public` getter methods and a `setStatus` setter for controlled access.
 *     *   Includes a `toString()` method for easy printing of job details.
 * 
 * 2.  **`PrintJobManager` Class:**
 *     *   Manages the collection of jobs.
 *     *   **`Queue` Usage:** It uses two `java.util.Queue` instances (`highPriorityQueue` and `lowPriorityQueue`), implemented by `java.util.LinkedList`, to store jobs waiting to be processed. `offer()` is used to add jobs to the end of the queue, and `poll()` is used to retrieve and remove the job from the head (the next job to be processed). This structure naturally handles FIFO within each priority level and allows prioritizing high-priority jobs by checking that queue first.
 *     *   **`ArrayList` Usage:** A `java.util.ArrayList` (`completedJobs`) is used to store jobs once they have been processed. Jobs are added to this list using the `add()` method.
 *     *   **`List` Interface Usage:** The methods `getWaitingJobs()` and `getCompletedJobs()` are declared to return `java.util.List<PrintJob>`. Although they return instances of `ArrayList`, using the `List` interface promotes good practice by programming to the interface rather than the specific implementation. `getWaitingJobs()` creates a *new* `ArrayList` and copies elements from both queues into it using iteration (which does not remove elements from the queues), thus providing a snapshot view.
 *     *   **`Scanner` Usage:** A `java.util.Scanner` is used in the `main` method to read user input line by line from `System.in`.
 *     *   **`Switch` Statement:** The `main` method uses a `switch` statement on the lowercased first word of the input line to determine which command the user wants to execute (`submit`, `process`, `list_waiting`, `list_completed`, `exit`). This provides clear and efficient control flow based on discrete command values.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for standard output, such as prompts, success messages, and job listings. `System.err.println()` is used specifically for displaying error messages, making them distinct from regular output (often displayed in red in many console environments).
 *     *   **Class-wide Exception Handling:** A `try-catch` block is wrapped around the entire `while (true)` loop in the `main` method. This provides a form of "class-wide" or "application-level" exception handling for the interactive session. It catches potential `NoSuchElementException` or `IllegalStateException` related to `Scanner` usage and a general `Exception` for any other unexpected runtime errors that might occur within the command processing logic, preventing the program from crashing abruptly. The `finally` block ensures the `Scanner` is closed.
 *     *   **Input Validation:** The code checks if the `submit` command has the correct number of arguments and validates the priority string ("High" or "Low", case-insensitive). It also checks if `process` or list commands have unexpected arguments.
 *     *   **Best Practices:** Encapsulation is used in `PrintJob`. Meaningful names like `highPriorityQueue`, `processNextJob`, `completedJobs` are used. Basic comments explain the purpose of classes and key methods. The code is structured logically with methods for different operations.
 * 
 * This solution effectively integrates the required Java components to build a functional and robust simulation of a print job management system, demonstrating advanced understanding of their practical application, error handling, and object-oriented design principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a single print job with properties like ID, name, priority, and status.
 * Demonstrates encapsulation.
 */
class PrintJob {
    private int id;
    private String name;
    private String priority; // "High" or "Low"
    private String status; // "Waiting", "Completed"

    /**
     * Constructs a new PrintJob.
     * @param id The unique ID for the job.
     * @param name The name of the job.
     * @param priority The priority of the job ("High" or "Low").
     */
    public PrintJob(int id, String name, String priority) {
        this.id = id;
        this.name = name;
        this.priority = priority;
        this.status = "Waiting"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the print job.
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, Name: %s, Priority: %s, Status: %s",
                             id, name, priority, status);
    }
}

/**
 * Manages the print job queues and completed jobs list.
 * Handles job submission, processing, and listing.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch, System.out, System.err, try-catch.
 */
public class PrintJobManager {

    // Use Queues for waiting jobs - LinkedList is a common implementation of Queue
    private Queue<PrintJob> highPriorityQueue;
    private Queue<PrintJob> lowPriorityQueue;

    // Use ArrayList to store completed jobs - ArrayList implements List
    private List<PrintJob> completedJobs;

    private int nextJobId; // Counter for assigning unique job IDs

    /**
     * Constructs a new PrintJobManager, initializing data structures.
     */
    public PrintJobManager() {
        this.highPriorityQueue = new LinkedList<>();
        this.lowPriorityQueue = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new print job to the appropriate waiting queue.
     * Performs input validation for name and priority.
     * @param name The name of the job.
     * @param priority The priority of the job ("High" or "Low").
     */
    public void submitJob(String name, String priority) {
        // Input validation for job name
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Job name cannot be empty.");
            return;
        }

        // Input validation and normalization for priority
        String normalizedPriority = priority.trim();
        boolean isHighPriority = "High".equalsIgnoreCase(normalizedPriority);
        boolean isLowPriority = "Low".equalsIgnoreCase(normalizedPriority);

        if (!isHighPriority && !isLowPriority) {
            System.err.println("Error: Invalid priority specified. Use 'High' or 'Low'.");
            return; // Do not create job if priority is invalid
        }

        // Create the new job
        PrintJob job = new PrintJob(nextJobId++, name.trim(), isHighPriority ? "High" : "Low");

        // Add job to the correct queue
        if (isHighPriority) {
            highPriorityQueue.offer(job); // offer is safe and preferred over add for queues
            System.out.println("High priority job submitted: " + job);
        } else { // Must be low priority based on validation above
            lowPriorityQueue.offer(job);
            System.out.println("Low priority job submitted: " + job);
        }
    }

    /**
     * Processes the next available job based on priority (High first, then Low).
     * Moves the processed job to the completed list.
     * Uses System.err if no jobs are waiting.
     */
    public void processNextJob() {
        PrintJob jobToProcess = null;

        // Check high priority queue first
        if (!highPriorityQueue.isEmpty()) {
            jobToProcess = highPriorityQueue.poll(); // poll retrieves and removes the head
        } else if (!lowPriorityQueue.isEmpty()) {
            // If high priority queue is empty, check low priority queue
            jobToProcess = lowPriorityQueue.poll();
        }

        // Process the job if one was found
        if (jobToProcess != null) {
            jobToProcess.setStatus("Completed"); // Update status
            completedJobs.add(jobToProcess); // Add to completed list (ArrayList)
            System.out.println("Processed job: " + jobToProcess);
        } else {
            // Use System.err for operational errors
            System.err.println("No jobs waiting to be processed.");
        }
    }

    /**
     * Returns a list of all jobs currently waiting in the queues.
     * High-priority jobs are listed before low-priority jobs.
     * Returns a List interface type.
     * @return A List of waiting PrintJob objects.
     */
    public List<PrintJob> getWaitingJobs() {
        List<PrintJob> waiting = new ArrayList<>(); // Use ArrayList which implements List

        // Iterate through high priority queue and add to the list
        // Iterating over a Queue does NOT remove elements
        for (PrintJob job : highPriorityQueue) {
            waiting.add(job);
        }

        // Iterate through low priority queue and add to the list
        for (PrintJob job : lowPriorityQueue) {
            waiting.add(job);
        }

        return waiting; // Return the list (as List interface)
    }

    /**
     * Returns a list of all jobs that have been completed.
     * Returns a List interface type.
     * @return A List of completed PrintJob objects.
     */
    public List<PrintJob> getCompletedJobs() {
        return completedJobs; // completedJobs is already declared as List<PrintJob>
    }

    /**
     * Main method to run the Print Job Management System application.
     * Handles user input loop, command parsing, and delegates tasks to the manager.
     * Includes class-wide exception handling using try-catch.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        Scanner scanner = new Scanner(System.in); // Use Scanner for user input

        System.out.println("Print Job Management System");
        System.out.println("Commands: submit <name> <priority (High/Low)>, process, list_waiting, list_completed, exit");

        // --- Class-wide Exception Handling ---
        // Wrap the main application loop in a try-catch block
        try {
            while (true) {
                System.out.print("> ");
                String commandLine = scanner.nextLine().trim(); // Read entire line and trim whitespace

                if (commandLine.isEmpty()) {
                    continue; // Skip empty input
                }

                // Split the command line into parts: command and arguments
                // Limit split to 3 parts: command, arg1, arg2 (for submit)
                String[] parts = commandLine.split("\\s+", 3);
                String command = parts[0].toLowerCase(); // Get the command, convert to lowercase

                // --- Switch Statement for Flow Control ---
                switch (command) {
                    case "submit":
                        // Expected format: submit <name> <priority>
                        if (parts.length == 3) {
                            String name = parts[1];
                            String priority = parts[2];
                            manager.submitJob(name, priority);
                        } else {
                            System.err.println("Invalid submit command format. Use: submit <name> <priority (High/Low)>");
                        }
                        break; // End of submit case

                    case "process":
                        // Expected format: process
                        if (parts.length == 1) {
                            manager.processNextJob();
                        } else {
                             System.err.println("Invalid process command format. Use: process");
                        }
                        break; // End of process case

                    case "list_waiting":
                        // Expected format: list_waiting
                        if (parts.length == 1) {
                            List<PrintJob> waitingJobs = manager.getWaitingJobs(); // Get list via List interface
                            if (waitingJobs.isEmpty()) {
                                System.out.println("No jobs currently waiting.");
                            } else {
                                System.out.println("--- Waiting Jobs ---");
                                for (PrintJob job : waitingJobs) { // Iterate and print using System.out
                                    System.out.println(job);
                                }
                                System.out.println("--------------------");
                            }
                        } else {
                            System.err.println("Invalid list_waiting command format. Use: list_waiting");
                        }
                        break; // End of list_waiting case

                    case "list_completed":
                         // Expected format: list_completed
                         if (parts.length == 1) {
                            List<PrintJob> completedJobs = manager.getCompletedJobs(); // Get list via List interface
                            if (completedJobs.isEmpty()) {
                                System.out.println("No jobs have been completed yet.");
                            } else {
                                System.out.println("--- Completed Jobs ---");
                                for (PrintJob job : completedJobs) { // Iterate and print using System.out
                                    System.out.println(job);
                                }
                                System.out.println("----------------------");
                            }
                         } else {
                            System.err.println("Invalid list_completed command format. Use: list_completed");
                         }
                        break; // End of list_completed case

                    case "exit":
                        System.out.println("Exiting Print Job Management System.");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method, terminating the program

                    default:
                        // Handle unknown commands using System.err
                        System.err.println("Unknown command: " + command);
                        System.err.println("Commands: submit <name> <priority (High/Low)>, process, list_waiting, list_completed, exit");
                        break; // End of default case
                }
            }
        } catch (NoSuchElementException e) {
            // Catches exceptions related to Scanner if input is exhausted unexpectedly
            System.err.println("Error reading input: Input stream closed unexpectedly.");
        } catch (IllegalStateException e) {
             // Catches exceptions if the scanner is used after being closed
             System.err.println("Error reading input: Scanner is in an invalid state.");
        } catch (Exception e) {
            // Generic catch-all for any other unexpected runtime exceptions
            // Using System.err to report the error
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // For debugging, you might print the stack trace: e.printStackTrace();
        } finally {
             // Ensure the scanner is closed even if an exception occurs
             if (scanner != null) {
                 scanner.close();
             }
        }
    }
}
