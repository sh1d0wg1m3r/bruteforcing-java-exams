/*
 * Exam Question #315
 * Generated on: 2025-05-11 22:53:45
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Conference Session Registration System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for managing attendee registrations for multiple sessions at a conference. Each session has a limited capacity. When a session is full, subsequent registration requests for that session should place the attendee on a waitlist. If a registered attendee cancels, the first person on the waitlist (if any) should be automatically registered.
 * 
 * Your system should allow users to:
 * 1.  Register an attendee for a session.
 * 2.  Cancel an attendee's registration or waitlist position.
 * 3.  View the current status of a specific session (registered attendees and waitlist).
 * 4.  Exit the system.
 * 
 * **Initial Setup:**
 * 
 * Your system should start with at least two pre-defined sessions, each with a name and a capacity.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.ArrayList` to store the list of all conference sessions.
 *     *   Within each session object, use `java.util.List` (specifically implemented by `ArrayList`) to store the list of registered attendees.
 *     *   Within each session object, use `java.util.Queue` (specifically implemented by `LinkedList`) to manage the waitlist for attendees.
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input (menu choice, session name, attendee name).
 *     *   Use `System.out` for all standard output (menu, prompts, successful operations, session status).
 *     *   Use `System.err` for all error messages (e.g., invalid input, session not found, attendee not found, already registered).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options selected by the user.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically to gracefully handle potential input errors (e.g., user entering non-integer input for the menu choice).
 *     *   Implement logical error handling for scenarios like trying to register for a non-existent session, cancelling a non-existent registration, etc., reporting these errors using `System.err`.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `Session` class to encapsulate the data and behavior related to a single session (name, capacity, registered attendees list, waitlist queue).
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 * 6.  **Best Practices:**
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., checking if session exists).
 *     *   Ensure clean and readable code structure.
 * 
 * **User Interaction Flow:**
 * 
 * The program should repeatedly display a menu like this:
 * 
 * ```
 * Conference Registration System
 * 1. Register Attendee
 * 2. Cancel Registration
 * 3. View Session Status
 * 4. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the choice, the program should prompt for necessary details (session name, attendee name) and perform the requested action, printing the outcome or errors. Session names should be matched case-insensitively for user input.
 * 
 * **Expected Output:**
 * 
 * *   **Successful Registration (within capacity):** `Attendee [Name] successfully registered for session [Session Name].`
 * *   **Successful Registration (waitlisted):** `Session [Session Name] is full. Attendee [Name] added to waitlist.`
 * *   **Successful Cancellation (registered, no waitlist):** `Attendee [Name] successfully cancelled registration for session [Session Name].`
 * *   **Successful Cancellation (registered, waitlist promoted):** `Attendee [Name] successfully cancelled registration for session [Session Name]. Attendee [Promoted Name] from waitlist is now registered.`
 * *   **Successful Cancellation (waitlisted):** `Attendee [Name] successfully removed from waitlist for session [Session Name].`
 * *   **View Session Status:**
 *     ```
 *     --- Session Status: [Session Name] ---
 *     Capacity: [Capacity]
 *     Registered: [Number Registered]
 *     Attendees: [List of Registered Attendees, comma-separated]
 *     Waitlist: [Number on Waitlist]
 *     Waitlist Queue: [List of Waitlist Attendees in order, comma-separated]
 *     -------------------------------------
 *     ```
 * *   **Exit:** `Exiting system. Goodbye!`
 * *   **Error (Invalid Menu Choice):** `System.err.println("Invalid choice. Please enter a number between 1 and 4.");`
 * *   **Error (Input Mismatch):** `System.err.println("Invalid input. Please enter a number.");` (and clear scanner buffer)
 * *   **Error (Session Not Found):** `System.err.println("Error: Session '[Session Name]' not found.");`
 * *   **Error (Already Registered/Waitlisted):** `System.err.println("Error: Attendee '[Name]' is already registered or on the waitlist for session '[Session Name]'.");`
 * *   **Error (Attendee Not Found for Cancellation):** `System.err.println("Error: Attendee '[Name]' not found in registered attendees or waitlist for session '[Session Name]'.");`
 * 
 * Your solution should be a single Java file containing the `Session` class and the main class with the `main` method (e.g., `ConferenceSystem`).
 *
 * EXPLANATION:
 * This solution implements a simplified conference session registration system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure (`Session` and `ConferenceSystem`):**
 *     *   The `Session` class encapsulates the details and behavior of a single session: its name, capacity, a `List` (`ArrayList`) of registered attendees, and a `Queue` (`LinkedList`) for the waitlist. This promotes good encapsulation by keeping session data private and exposing functionality through public methods (`registerAttendee`, `cancelRegistration`, `printSessionStatus`).
 *     *   The `ConferenceSystem` class acts as the main controller. It holds a `List` (`ArrayList`) of `Session` objects and manages the user interaction loop, directing requests to the appropriate `Session` object.
 * 
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`):**
 *     *   `List<Session> sessions = new ArrayList<>();`: An `ArrayList` is used to dynamically store the collection of `Session` objects managed by the system. It's declared as a `List` to demonstrate programming to the interface.
 *     *   `List<String> registeredAttendees = new ArrayList<>();`: Inside the `Session` class, an `ArrayList` is used for `registeredAttendees`. `ArrayList` provides efficient access by index and dynamic resizing, suitable for managing a list of attendees. It's declared as `List` to adhere to the requirement and good practice.
 *     *   `Queue<String> waitlist = new LinkedList<>();`: Inside the `Session` class, a `LinkedList` is used to implement the `Queue` interface for the waitlist. A `Queue` (specifically FIFO - First-In, First-Out) is the ideal data structure for a waitlist, ensuring that attendees are processed in the order they joined. `LinkedList` is a common implementation of `Queue` that supports efficient additions to the tail (`offer`) and removals from the head (`poll`).
 * 
 * 3.  **Input (`Scanner`):**
 *     *   `Scanner scanner = new Scanner(System.in);` is used in the `ConferenceSystem` class to read user input from the console.
 *     *   `scanner.nextInt()` reads the integer menu choice.
 *     *   `scanner.nextLine()` is used to read string inputs (session name, attendee name) and importantly, to consume the leftover newline character after `nextInt()`, preventing input issues in subsequent `nextLine()` calls.
 * 
 * 4.  **Control Flow (`Switch`):**
 *     *   A `switch` statement in the `run` method of `ConferenceSystem` is used to handle the different menu options selected by the user, directing the program flow to the corresponding handler methods (`handleRegistration`, `handleCancellation`, `handleViewStatus`).
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, successful operation messages, and session status information as required.
 *     *   `System.err.println()` is used exclusively for printing error messages, such as invalid menu choices, input mismatches, session not found errors, or logical errors like trying to register someone who is already registered. This distinguishes error output from normal program output.
 * 
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch (InputMismatchException e)` block is placed around the `scanner.nextInt()` call within the main loop. This handles cases where the user enters non-integer input for the menu choice, preventing the program from crashing. The `catch` block prints an error message to `System.err` and consumes the invalid input using `scanner.nextLine()` to clear the buffer.
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing an error message and the stack trace to `System.err`.
 *     *   Logical error handling (e.g., session not found, attendee already registered) is implemented within the handler methods (`handleRegistration`, `handleCancellation`, `handleViewStatus`) using `if` checks and printing specific error messages to `System.err`.
 * 
 * 7.  **Registration and Cancellation Logic:**
 *     *   The `registerAttendee` method in `Session` checks capacity. If space is available, the attendee is added to the `registeredAttendees List`. If full, they are added to the `waitlist Queue` using `waitlist.add()`. It also checks for duplicate registrations/waitlist entries.
 *     *   The `cancelRegistration` method attempts to remove the attendee from the `registeredAttendees List` first. If successful and the `waitlist Queue` is not empty, it uses `waitlist.poll()` to get and remove the first attendee from the queue and adds them to the `registeredAttendees List`, simulating promotion. If the attendee is not registered, it checks the `waitlist Queue` and removes them if found. It returns a custom `CancellationResult` object to convey the outcome status and the name of the promoted attendee, if any.
 * 
 * 8.  **Best Practices:**
 *     *   Private fields and public methods ensure encapsulation.
 *     *   Method names like `registerAttendee`, `cancelRegistration`, `printSessionStatus`, `findSessionByName`, `displayMenu`, `run` are descriptive. Variable names like `registeredAttendees`, `waitlist`, `sessionName`, `attendeeName` are clear.
 *     *   Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 *     *   Input validation is performed for empty strings and session existence.
 *     *   Error handling is present for both input format and logical errors.
 *     *   The code is structured logically with distinct methods for handling different operations and a dedicated class for the `Session` object.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating an understanding of core Java data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single conference session with capacity, registered attendees, and a waitlist.
 */
class Session {
    private String name;
    private int capacity;
    private List<String> registeredAttendees;
    private Queue<String> waitlist;

    /**
     * Enum to represent the outcome of a registration attempt.
     */
    public enum RegistrationStatus {
        REGISTERED, WAITLISTED, ALREADY_REGISTERED
    }

    /**
     * Enum to represent the outcome of a cancellation attempt.
     */
    public enum CancellationStatus {
        CANCELLED_REGISTERED, CANCELLED_REGISTERED_PROMOTED, CANCELLED_WAITLISTED, NOT_FOUND
    }

    /**
     * Constructs a new Session.
     *
     * @param name     The name of the session.
     * @param capacity The maximum number of registered attendees.
     */
    public Session(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Use ArrayList for registered attendees
        this.waitlist = new LinkedList<>(); // Use LinkedList for the Queue waitlist
    }

    /**
     * Gets the name of the session.
     * @return The session name.
     */
    public String getName() {
        return name;
    }

    /**
     * Registers an attendee for the session.
     * If capacity is available, adds to registered attendees.
     * If full, adds to the waitlist.
     * Checks if attendee is already registered or waitlisted.
     *
     * @param attendeeName The name of the attendee to register.
     * @return The status of the registration attempt.
     */
    public RegistrationStatus registerAttendee(String attendeeName) {
        // Check if already registered or on waitlist (case-insensitive check for attendee name)
        boolean alreadyInRegistered = registeredAttendees.stream()
                                        .anyMatch(a -> a.equalsIgnoreCase(attendeeName));
        boolean alreadyInWaitlist = waitlist.stream()
                                        .anyMatch(a -> a.equalsIgnoreCase(attendeeName));

        if (alreadyInRegistered || alreadyInWaitlist) {
            return RegistrationStatus.ALREADY_REGISTERED;
        }

        // Check capacity
        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(attendeeName);
            return RegistrationStatus.REGISTERED;
        } else {
            waitlist.add(attendeeName);
            return RegistrationStatus.WAITLISTED;
        }
    }

    /**
     * Cancels an attendee's registration or waitlist position.
     * If a registered attendee cancels and the waitlist is not empty,
     * the first person on the waitlist is promoted.
     *
     * @param attendeeName The name of the attendee to cancel.
     * @return The status of the cancellation attempt.
     */
    public CancellationStatus cancelRegistration(String attendeeName) {
        // Check if registered (case-insensitive check)
        boolean removedFromRegistered = registeredAttendees.removeIf(a -> a.equalsIgnoreCase(attendeeName));

        if (removedFromRegistered) {
            // If removed from registered, check waitlist for promotion
            if (!waitlist.isEmpty()) {
                String promotedAttendee = waitlist.poll(); // Get and remove the first from waitlist
                registeredAttendees.add(promotedAttendee); // Add to registered
                return CancellationStatus.CANCELLED_REGISTERED_PROMOTED;
            } else {
                return CancellationStatus.CANCELLED_REGISTERED;
            }
        } else {
            // Check if on waitlist (case-insensitive check)
            boolean removedFromWaitlist = waitlist.removeIf(a -> a.equalsIgnoreCase(attendeeName));
            if (removedFromWaitlist) {
                return CancellationStatus.CANCELLED_WAITLISTED;
            } else {
                // Attendee not found
                return CancellationStatus.NOT_FOUND;
            }
        }
    }

    /**
     * Gets the name of the attendee promoted from the waitlist, if any.
     * This method is intended to be called immediately after a
     * CANCELLED_REGISTERED_PROMOTED status is returned by cancelRegistration.
     * It assumes the waitlist was polled in the previous operation.
     * Note: A more robust design might return the promoted attendee name
     * directly from cancelRegistration, but for this exam structure,
     * we'll rely on the state change and potentially need to re-poll
     * (or preferably, modify cancelRegistration to return the name).
     * Let's modify cancelRegistration to return the promoted name.
     *
     * Refactoring cancelRegistration to return a pair or a custom result object
     * would be better, but to keep it simple and use the enum return,
     * we'll rely on the fact that the first person *was* polled.
     * A safer approach for the exam is to just report *that* someone was promoted,
     * not *who* exactly without re-polling or storing the polled name.
     * Let's stick to the enum and report that *someone* was promoted.
     *
     * // Re-checking the waitlist head would give the *new* head, not the promoted one.
     * // The promoted attendee name was the result of the poll() operation.
     * // We need to capture that name when polling occurs in cancelRegistration.
     * // Let's adjust the return value or add an output parameter.
     * // For simplicity in the exam, let's make cancelRegistration return a String
     * // representing the outcome message directly, or a simple status and
     * // handle the message printing in the main class.
     * // The original plan of returning an enum status is fine, the main method
     * // can print the appropriate message based on the enum.
     * // How to get the promoted name? The poll() operation returns it.
     * // We need to capture that in cancelRegistration and perhaps pass it back
     * // alongside the status. A custom result class is ideal.
     * // Let's make cancelRegistration return a simple String message for the exam.
     * // This simplifies handling in the main loop.
     */

     // Let's revert cancelRegistration to return an enum and capture the promoted name
     // within the method to be used in the status string *if* we print there,
     // or return a custom object containing status and promoted name.
     // A custom object is better practice. Let's define a simple one.

    /**
     * Represents the result of a cancellation attempt.
     */
    public static class CancellationResult {
        public CancellationStatus status;
        public String promotedAttendeeName; // Name of attendee promoted from waitlist, if any

        public CancellationResult(CancellationStatus status, String promotedAttendeeName) {
            this.status = status;
            this.promotedAttendeeName = promotedAttendeeName;
        }
    }

    /**
     * Cancels an attendee's registration or waitlist position.
     * If a registered attendee cancels and the waitlist is not empty,
     * the first person on the waitlist is promoted.
     *
     * @param attendeeName The name of the attendee to cancel.
     * @return A CancellationResult object indicating the status and potentially the promoted attendee's name.
     */
    public CancellationResult cancelRegistration(String attendeeName) {
        // Check if registered (case-insensitive check)
        String attendeeToRemove = registeredAttendees.stream()
                                    .filter(a -> a.equalsIgnoreCase(attendeeName))
                                    .findFirst()
                                    .orElse(null);

        if (attendeeToRemove != null) {
            registeredAttendees.remove(attendeeToRemove);
            // If removed from registered, check waitlist for promotion
            if (!waitlist.isEmpty()) {
                String promotedAttendee = waitlist.poll(); // Get and remove the first from waitlist
                registeredAttendees.add(promotedAttendee); // Add to registered
                return new CancellationResult(CancellationStatus.CANCELLED_REGISTERED_PROMOTED, promotedAttendee);
            } else {
                return new CancellationResult(CancellationStatus.CANCELLED_REGISTERED, null);
            }
        } else {
            // Check if on waitlist (case-insensitive check)
             attendeeToRemove = waitlist.stream()
                                    .filter(a -> a.equalsIgnoreCase(attendeeName))
                                    .findFirst()
                                    .orElse(null);

            if (attendeeToRemove != null) {
                waitlist.remove(attendeeToRemove);
                return new CancellationResult(CancellationStatus.CANCELLED_WAITLISTED, null);
            } else {
                // Attendee not found
                return new CancellationResult(CancellationStatus.NOT_FOUND, null);
            }
        }
    }


    /**
     * Prints the current status of the session to System.out.
     */
    public void printSessionStatus() {
        System.out.println("--- Session Status: " + name + " ---");
        System.out.println("Capacity: " + capacity);
        System.out.println("Registered: " + registeredAttendees.size());
        System.out.print("Attendees: ");
        if (registeredAttendees.isEmpty()) {
            System.out.println("None");
        } else {
            System.out.println(String.join(", ", registeredAttendees));
        }
        System.out.println("Waitlist: " + waitlist.size());
        System.out.print("Waitlist Queue: ");
         if (waitlist.isEmpty()) {
            System.out.println("Empty");
        } else {
             // Convert queue to list for easy printing without modifying the queue
            System.out.println(String.join(", ", new ArrayList<>(waitlist)));
        }
        System.out.println("-------------------------------------");
    }
}

/**
 * Main class for the Conference Registration System.
 * Manages multiple sessions and handles user interaction.
 */
public class ConferenceSystem {

    private List<Session> sessions;
    private Scanner scanner;

    /**
     * Constructs the ConferenceSystem and initializes sessions.
     */
    public ConferenceSystem() {
        sessions = new ArrayList<>(); // Use ArrayList for the list of sessions
        // Initialize with some sample sessions
        sessions.add(new Session("Java Fundamentals", 5));
        sessions.add(new Session("Advanced Spring", 3));
        sessions.add(new Session("Cloud Deployment", 4));

        scanner = new Scanner(System.in);
    }

    /**
     * Finds a session by its name (case-insensitive).
     *
     * @param name The name of the session to find.
     * @return The Session object if found, otherwise null.
     */
    private Session findSessionByName(String name) {
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(name)) {
                return session;
            }
        }
        return null;
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nConference Registration System");
        System.out.println("1. Register Attendee");
        System.out.println("2. Cancel Registration");
        System.out.println("3. View Session Status");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 4) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline left-over after nextInt()

                switch (choice) {
                    case 1:
                        handleRegistration();
                        break;
                    case 2:
                        handleCancellation();
                        break;
                    case 3:
                        handleViewStatus();
                        break;
                    case 4:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) { // Catch any other unexpected exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Handles the attendee registration process.
     */
    private void handleRegistration() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine().trim();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine().trim();

        if (sessionName.isEmpty() || attendeeName.isEmpty()) {
            System.err.println("Session name and attendee name cannot be empty.");
            return;
        }

        Session session = findSessionByName(sessionName);

        if (session == null) {
            System.err.println("Error: Session '" + sessionName + "' not found.");
            return;
        }

        Session.RegistrationStatus status = session.registerAttendee(attendeeName);

        switch (status) {
            case REGISTERED:
                System.out.println("Attendee " + attendeeName + " successfully registered for session " + sessionName + ".");
                break;
            case WAITLISTED:
                System.out.println("Session " + sessionName + " is full. Attendee " + attendeeName + " added to waitlist.");
                break;
            case ALREADY_REGISTERED:
                System.err.println("Error: Attendee '" + attendeeName + "' is already registered or on the waitlist for session '" + sessionName + "'.");
                break;
        }
    }

    /**
     * Handles the registration cancellation process.
     */
    private void handleCancellation() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine().trim();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine().trim();

         if (sessionName.isEmpty() || attendeeName.isEmpty()) {
            System.err.println("Session name and attendee name cannot be empty.");
            return;
        }

        Session session = findSessionByName(sessionName);

        if (session == null) {
            System.err.println("Error: Session '" + sessionName + "' not found.");
            return;
        }

        Session.CancellationResult result = session.cancelRegistration(attendeeName);

        switch (result.status) {
            case CANCELLED_REGISTERED:
                System.out.println("Attendee " + attendeeName + " successfully cancelled registration for session " + sessionName + ".");
                break;
            case CANCELLED_REGISTERED_PROMOTED:
                System.out.println("Attendee " + attendeeName + " successfully cancelled registration for session " + sessionName + ".");
                System.out.println("Attendee " + result.promotedAttendeeName + " from waitlist is now registered.");
                break;
            case CANCELLED_WAITLISTED:
                System.out.println("Attendee " + attendeeName + " successfully removed from waitlist for session " + sessionName + ".");
                break;
            case NOT_FOUND:
                System.err.println("Error: Attendee '" + attendeeName + "' not found in registered attendees or waitlist for session '" + sessionName + "'.");
                break;
        }
    }

    /**
     * Handles displaying the status of a session.
     */
    private void handleViewStatus() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine().trim();

        if (sessionName.isEmpty()) {
            System.err.println("Session name cannot be empty.");
            return;
        }

        Session session = findSessionByName(sessionName);

        if (session == null) {
            System.err.println("Error: Session '" + sessionName + "' not found.");
        } else {
            session.printSessionStatus();
        }
    }

    /**
     * Main method to start the conference registration system.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ConferenceSystem system = new ConferenceSystem();
        system.run();
    }
}
