/*
 * Exam Question #1116
 * Generated on: 2025-05-12 17:27:02
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Priority Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for a small team to manage their tasks. The system needs to distinguish between urgent tasks, which should be prioritized, and regular tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **`Task` Class:**
 *     *   Create a class named `Task`.
 *     *   It must have `private` fields: a unique integer `id`, a `String` `description`, and a boolean `isUrgent`.
 *     *   The `id` should be automatically generated starting from 1 for each new task.
 *     *   Provide a constructor to initialize `description` and `isUrgent`.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (including ID, description, and priority).
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Create a class named `TaskManager` with a `main` method.
 *     *   This class will manage the collections of tasks.
 *     *   Use a `java.util.Queue<Task>` to store urgent tasks. Choose an appropriate implementation (e.g., `LinkedList`).
 *     *   Use a `java.util.List<Task>` to store regular tasks. Use `java.util.ArrayList` as the implementation.
 *     *   Use a `java.util.Scanner` to read user input from the console.
 * 
 * 3.  **Menu-Driven Interface:**
 *     *   Implement a loop in the `main` method (or a dedicated `run` method called from `main`) that presents the user with the following options:
 *         1.  Add New Task
 *         2.  View All Tasks
 *         3.  Complete Task
 *         4.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Functionality:**
 *     *   **Add New Task:**
 *         *   Prompt the user for the task description.
 *         *   Prompt the user if the task is urgent (e.g., "yes" or "no").
 *         *   Create a new `Task` object.
 *         *   If urgent, add it to the `Queue`. If regular, add it to the `List`.
 *         *   Print a confirmation message using `System.out`.
 *     *   **View All Tasks:**
 *         *   Display all tasks currently in the system.
 *         *   **Crucially:** List all tasks from the urgent `Queue` first, followed by all tasks from the regular `List`. Do *not* remove tasks from the collections when viewing.
 *         *   Print informative headers (e.g., "--- Urgent Tasks ---", "--- Regular Tasks ---").
 *         *   If a collection is empty, print a message indicating that. Use `System.out`.
 *     *   **Complete Task:**
 *         *   Prompt the user for the ID of the task to mark as complete.
 *         *   Search for the task with the given ID in **both** the urgent `Queue` and the regular `List`.
 *         *   If found, remove the task from its collection and print a success message using `System.out`.
 *         *   If the ID is not found in either collection, print an error message using `System.err`.
 *         *   Handle the specific logic required for removing elements from a `Queue` vs. a `List`.
 *     *   **Exit:** Terminate the program.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for the menu choice and the task ID for completion (ensure they are integers). Use `System.err` for invalid input messages.
 *     *   Include a `try-catch` block in the `TaskManager` class (e.g., around the main menu loop in `run` or `main`) to catch and report any unexpected exceptions that might occur during program execution. Use `System.err` to print the error message from the caught exception.
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation principles (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments to explain complex parts of the code.
 *     *   Ensure `Scanner` is properly closed.
 * 
 * **Expected Output Structure (Example Interaction):**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Write exam question
 * Is this task urgent? (yes/no): yes
 * Urgent task added: ID: 1, Desc: "Write exam question", Priority: URGENT
 * 
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Grade assignments
 * Is this task urgent? (yes/no): no
 * Regular task added: ID: 2, Desc: "Grade assignments", Priority: Regular
 * 
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 2
 * --- All Tasks ---
 * --- Urgent Tasks ---
 * ID: 1, Desc: "Write exam question", Priority: URGENT
 * --- Regular Tasks ---
 * ID: 2, Desc: "Grade assignments", Priority: Regular
 * -----------------
 * 
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 3
 * Enter the ID of the task to complete: 1
 * Completed urgent task: ID: 1, Desc: "Write exam question", Priority: URGENT
 * 
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 3
 * Enter the ID of the task to complete: 5
 * Invalid input. Please enter a numeric Task ID. // Example of invalid input handling
 * Enter the ID of the task to complete: 5
 * Task with ID 5 not found. // Example of task not found
 * 
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Complete Task
 * 4. Exit
 * Enter choice: 4
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Your solution should compile and run, demonstrating all the required features and handling errors gracefully as specified.
 *
 * EXPLANATION:
 * This solution implements a simple priority-based task management system using core Java collections and control structures as required.
 * 
 * 1.  **`Task` Class:**
 *     *   This class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It demonstrates **encapsulation** by keeping its fields (`id`, `description`, `isUrgent`) `private` and providing `public` getter methods.
 *     *   A `static` counter `nextId` ensures each task gets a unique, auto-incrementing ID, simulating a common database primary key behavior.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the main class containing the application logic.
 *     *   It declares `urgentTasks` as a `Queue<Task>` and initializes it with a `LinkedList`. A `Queue` is suitable for urgent tasks because it naturally supports First-In, First-Out (FIFO) access, implying that tasks added earlier are conceptually processed sooner (though our `view` and `complete` logic iterate differently).
 *     *   It declares `regularTasks` as a `List<Task>` and initializes it with an `ArrayList`. A `List` is suitable for regular tasks as it allows easy storage, retrieval, and removal by index or object, and maintains insertion order.
 *     *   A `Scanner` is used for reading user input from `System.in`.
 * 
 * 3.  **Menu and `switch`:**
 *     *   The `run()` method contains the main application loop (`while (choice != 4)`).
 *     *   Inside the loop, `printMenu()` displays the options.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer input, fulfilling the requirement for `switch` usage.
 * 
 * 4.  **Functionality Implementation:**
 *     *   **`addTask()`:** Reads description and urgency. Based on urgency, the task is added to either the `urgentTasks` `Queue` using `offer()` or the `regularTasks` `List` using `add()`. `offer()` is generally preferred for Queues as it handles potential capacity limits (though `LinkedList` doesn't have one).
 *     *   **`viewTasks()`:** Iterates through the `urgentTasks` `Queue` first using an enhanced for loop (which doesn't remove elements) and prints them. Then, it iterates through the `regularTasks` `List` and prints them. This satisfies the requirement to list urgent tasks before regular ones without altering the collections.
 *     *   **`completeTask()`:** This is the most complex method due to the difference in how `Queue` and `List` handle arbitrary element removal.
 *         *   For the `Queue`, removing an element that isn't at the head (`poll()`) is not a standard Queue operation. The solution demonstrates one approach: polling all elements, checking their ID, adding non-matching elements to a temporary queue, and finally transferring elements back from the temporary queue to the original. This effectively rebuilds the queue without the completed task.
 *         *   For the `List`, removing elements while iterating is best done using an `Iterator`'s `remove()` method to avoid `ConcurrentModificationException`. The code iterates using an `Iterator`, finds the task by ID, and uses `iterator.remove()` to safely remove it.
 *         *   It checks if the task was found in either collection and prints success or error messages accordingly using `System.out` or `System.err`.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Input validation is performed using `scanner.hasNextInt()` before attempting to read integer inputs (menu choice, task ID). If the input is not an integer, an error message is printed to `System.err`, and the invalid input is consumed (`scanner.next()`) to prevent an infinite loop.
 *     *   A `try-catch(Exception e)` block is placed around the main `while` loop in the `run()` method. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might occur during the program's execution within that loop and printing an error message to `System.err`.
 *     *   The `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Method names (`addTask`, `viewTasks`, `completeTask`, `printMenu`) clearly indicate their purpose. Variable names are descriptive (`urgentTasks`, `regularTasks`, `taskId`).
 *     *   Basic comments explain the purpose of classes, methods, and key logic sections.
 *     *   The `Scanner` is closed in a `finally` block.
 *     *   `System.out` is used for normal program output (menu, task lists, success messages).
 *     *   `System.err` is used for error messages (invalid input, task not found, unexpected exceptions).
 * 
 * This solution effectively integrates all the required Java components in a practical scenario, demonstrating understanding of collection differences, user input handling, control flow, and basic error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator;

// Represents a single task with an ID, description, and urgency status.
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private boolean isUrgent;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param isUrgent True if the task is urgent, false otherwise.
     */
    public Task(String description, boolean isUrgent) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.isUrgent = isUrgent;
    }

    // Public getter methods for accessing task properties.
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isUrgent() {
        return isUrgent;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including ID, description, and priority.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Desc: \"" + description + "\", Priority: " + (isUrgent ? "URGENT" : "Regular");
    }
}

// Manages collections of tasks (urgent and regular) and user interaction.
public class TaskManager {

    private Queue<Task> urgentTasks;
    private List<Task> regularTasks;
    private Scanner scanner;

    /**
     * Constructs a TaskManager, initializing task collections and scanner.
     */
    public TaskManager() {
        // LinkedList is a common implementation of Queue
        urgentTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        regularTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main task management application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");
        int choice = -1;

        // Class-wide exception handling wrapping the main execution loop.
        try {
            // Loop until the user chooses to exit (option 4)
            while (choice != 4) {
                printMenu();
                System.out.print("Enter choice: ");

                // Validate if the input is an integer
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number from the menu.");
                    scanner.next(); // Consume the invalid input (e.g., a string)
                    continue; // Skip the rest of the loop and show menu again
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the leftover newline character after reading int

                // Process user choice using a switch statement
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewTasks();
                        break;
                    case 3:
                        completeTask();
                        break;
                    case 4:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
                System.out.println(); // Add a blank line for readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner is closed when the application finishes or errors out
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Complete Task");
        System.out.println("4. Exit");
    }

    /**
     * Prompts user for task details and adds the task to the appropriate collection.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Is this task urgent? (yes/no): ");
        String urgencyInput = scanner.nextLine().trim().toLowerCase();
        boolean isUrgent = urgencyInput.equals("yes"); // Task is urgent if input is exactly "yes"

        Task newTask = new Task(description, isUrgent);

        if (isUrgent) {
            urgentTasks.offer(newTask); // Use offer() for queues, better than add() as it handles capacity limits (though LinkedList is unbounded)
            System.out.println("Urgent task added: " + newTask);
        } else {
            regularTasks.add(newTask); // Use add() for Lists
            System.out.println("Regular task added: " + newTask);
        }
    }

    /**
     * Displays all tasks, urgent tasks first, then regular tasks.
     */
    private void viewTasks() {
        System.out.println("--- All Tasks ---");

        // Check if there are any tasks at all
        if (urgentTasks.isEmpty() && regularTasks.isEmpty()) {
            System.out.println("No tasks available.");
            System.out.println("-----------------");
            return; // Exit the method if no tasks
        }

        // Display Urgent Tasks from the Queue
        System.out.println("--- Urgent Tasks ---");
        if (urgentTasks.isEmpty()) {
            System.out.println("No urgent tasks.");
        } else {
            // Iterate through the Queue without removing elements
            for (Task task : urgentTasks) {
                 System.out.println(task);
            }
        }

        // Display Regular Tasks from the List
        System.out.println("--- Regular Tasks ---");
        if (regularTasks.isEmpty()) {
            System.out.println("No regular tasks.");
        } else {
            // Iterate through the List
            for (Task task : regularTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Prompts user for a task ID and removes the corresponding task from its collection.
     */
    private void completeTask() {
        System.out.print("Enter the ID of the task to complete: ");

        // Validate if the input is an integer ID
        if (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a numeric Task ID.");
            scanner.next(); // Consume invalid input
            scanner.nextLine(); // Consume leftover newline
            return; // Exit the method
        }

        int taskId = scanner.nextInt();
        scanner.nextLine(); // Consume the leftover newline character

        boolean taskFoundAndRemoved = false;
        Task completedTask = null; // To store the task object that was removed

        // --- Attempt to remove from Urgent Tasks (Queue) ---
        // Removing an arbitrary element from a Queue efficiently is tricky.
        // A common approach is to iterate, remove the matching element, and potentially
        // rebuild the queue with the remaining elements.
        Queue<Task> tempQueue = new LinkedList<>(); // Temporary queue to hold tasks not being removed
        while (!urgentTasks.isEmpty()) {
            Task currentTask = urgentTasks.poll(); // Remove from head
            if (currentTask.getId() == taskId) {
                completedTask = currentTask; // Found the task to complete
                taskFoundAndRemoved = true;
                // Do NOT add this task to tempQueue, effectively removing it
                // Continue polling the rest to add to tempQueue, just in case (though not strictly needed if only one removal)
            } else {
                tempQueue.offer(currentTask); // Add task back to temp queue if it's not the one to remove
            }
        }
        // Restore the remaining tasks from the temporary queue back to the original queue
        urgentTasks.addAll(tempQueue);

        if (taskFoundAndRemoved) {
            System.out.println("Completed urgent task: " + completedTask);
            return; // Task was found and removed from urgent queue, exit method
        }

        // --- Attempt to remove from Regular Tasks (List) ---
        // Removing from a List by value or index is straightforward.
        // Iterate and find the task by ID, then remove it.
        // Using an Iterator is the safest way to remove elements while iterating a List.
        Iterator<Task> regularIterator = regularTasks.iterator();
        while (regularIterator.hasNext()) {
            Task currentTask = regularIterator.next();
            if (currentTask.getId() == taskId) {
                completedTask = currentTask; // Found the task to complete
                regularIterator.remove(); // Safely remove the current element using the iterator
                taskFoundAndRemoved = true;
                break; // Found and removed from list, can stop searching
            }
        }

        if (taskFoundAndRemoved) {
            System.out.println("Completed regular task: " + completedTask);
        } else {
            // Task was not found in either collection
            System.err.println("Task with ID " + taskId + " not found.");
        }
    }


    /**
     * Main method to start the TaskManager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application loop
    }
}
