/*
 * Exam Question #866
 * Generated on: 2025-05-12 16:52:26
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Restaurant Order Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified console-based system for managing customer orders in a small restaurant. The system needs to handle placing new orders, fulfilling the oldest pending order, viewing the list of waiting orders, and displaying the menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items.
 *     *   Maintain a queue of pending customer orders.
 * 2.  **Functionality:**
 *     *   **Display Menu:** Show the available menu items with their IDs, names, and prices.
 *     *   **Place Order:**
 *         *   Prompt the user to enter the ID and quantity for one or more menu items.
 *         *   Allow adding multiple items to a single order.
 *         *   Validate that the entered item ID exists on the menu.
 *         *   Validate that the quantity is positive.
 *         *   Create an `Order` object containing the selected items and a unique order ID.
 *         *   Add the new order to the queue of pending orders.
 *         *   Display a confirmation message with the order ID and total.
 *     *   **Fulfill Order:**
 *         *   Remove the oldest order from the queue.
 *         *   Display a message indicating which order ID was fulfilled.
 *         *   Handle the case where the queue is empty.
 *     *   **View Pending Orders:**
 *         *   Display the IDs of all orders currently in the queue, from oldest to newest.
 *         *   Handle the case where the queue is empty.
 *     *   **Exit:** Terminate the program.
 * 3.  **Mandatory Java Components:** Your solution *must* explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as an interface type)
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for handling menu choices
 *     *   `System.err` for outputting error messages
 *     *   `System.out` for outputting normal messages and prompts
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., for input errors, handling empty queue operations gracefully).
 * 4.  **Best Practices:**
 *     *   Use appropriate class design with private fields and public methods (encapsulation).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments or Javadoc where necessary to explain complex logic.
 *     *   Implement robust input validation and error handling as described in the functionality requirements and using `System.err` and `try-catch`.
 *     *   Ensure clean code structure.
 * 
 * **Classes to Consider (Recommended):**
 * 
 * *   `MenuItem`: Represents a single item on the menu (ID, name, price).
 * *   `Order`: Represents a customer order (unique ID, list of `MenuItem`s, total price).
 * *   `RestaurantSystem`: Contains the main logic, menu list, order queue, and handles user interaction.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu of options (Display Menu, Place Order, Fulfill Order, View Pending Orders, Exit). Based on user input, it should perform the requested action, displaying relevant information (`System.out`) or error messages (`System.err`).
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 1
 * --- Menu ---
 * ID: 1, Name: Burger, Price: 8.99
 * ID: 2, Name: Fries, Price: 3.49
 * ID: 3, Name: Soda, Price: 1.99
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 2
 * Enter item ID to add (0 to finish): 1
 * Enter quantity for Burger: 2
 * Item(s) added to order.
 * Enter item ID to add (0 to finish): 2
 * Enter quantity for Fries: 1
 * Item(s) added to order.
 * Enter item ID to add (0 to finish): 5
 * Error: Invalid item ID. Please try again.
 * Enter item ID to add (0 to finish): 0
 * Order 1 placed. Total: $21.47
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 4
 * --- Pending Orders ---
 * Order ID: 1
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 3
 * Order 1 fulfilled.
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 4
 * --- Pending Orders ---
 * No pending orders.
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number.
 * 
 * --- Restaurant Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Fulfill Order
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 5
 * Exiting Restaurant Management System.
 * ```
 * 
 * **Constraint:** Solve this problem within a reasonable exam timeframe (e.g., 45-60 minutes), focusing on correct implementation and adherence to all requirements.
 *
 * EXPLANATION:
 * This solution implements a simplified restaurant order management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple Plain Old Java Object (POJO) representing an item on the menu. It uses `private` fields (`id`, `name`, `price`) and public getter methods, adhering to encapsulation. It includes a constructor with basic validation and an overridden `toString()` for easy printing.
 *     *   `OrderItem`: A helper class to represent an item *within* an order, including the quantity. This is necessary because an order might contain multiple quantities of the same `MenuItem`. It also uses encapsulation.
 *     *   `Order`: Represents a customer's order. It has a unique `orderId` generated using a static counter (`nextOrderId`). It uses a `List<OrderItem>` (implemented by `ArrayList`) to store the items in the order. It provides methods to add items and calculate the total. Encapsulation is maintained.
 *     *   `RestaurantSystem`: This is the main class that orchestrates the application. It holds the `List<MenuItem>` for the menu and the `Queue<Order>` for pending orders. It contains methods for each action (displaying menu, placing orders, fulfilling orders, viewing the queue) and the main application loop (`run`).
 * 
 * 2.  **Data Structures Usage:**
 *     *   `List<MenuItem> menu = new ArrayList<>();`: An `ArrayList` is used to store the menu items. `ArrayList` is a suitable `List` implementation here because we need to access items by index or iterate through them, and the size is dynamic. Using the `List` interface for the variable type (`List<MenuItem>`) demonstrates coding to the interface, which is a good practice.
 *     *   `Queue<Order> orderQueue = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface for storing pending orders. `Queue` is perfect for this scenario because orders are processed in a First-In, First-Out (FIFO) manner (the oldest order is fulfilled first). `LinkedList` efficiently supports adding to the end (`offer`) and removing from the beginning (`poll`).
 * 
 * 3.  **Required Component Usage:**
 *     *   `Scanner`: An instance is created in the `RestaurantSystem` constructor (`new Scanner(System.in)`) to read input from the console. It's used in the `run` method for the main menu choice and within `placeOrder` for reading item IDs and quantities. The scanner is closed when the application exits.
 *     *   `switch`: Used in the `run` method to direct the program flow based on the user's integer input for the main menu selection.
 *     *   `System.out`: Used for all standard output, including displaying the menu, prompts to the user, confirmation messages (like order placed or fulfilled), and displaying the queue contents.
 *     *   `System.err`: Used specifically for outputting error messages, such as invalid menu choices, invalid input types, item not found, invalid quantity, or attempting to fulfill an order when the queue is empty. This helps distinguish errors from normal program output.
 *     *   `try-catch`:
 *         *   A `try-catch(InputMismatchException)` block is used in the `run` method around `scanner.nextInt()` to handle cases where the user enters non-integer input for the main menu choice.
 *         *   `try-catch(InputMismatchException)` blocks are also used within the `placeOrder` method when reading item ID and quantity inputs, ensuring that non-integer input doesn't crash the program and allows the user to retry.
 *         *   A general `catch(Exception e)` is included in the `run` method's main loop as a "class-wide" safety net to catch any other unexpected runtime exceptions that might occur during the execution of the chosen action, preventing the program from abruptly terminating.
 *         *   Checks for empty queue (`orderQueue.isEmpty()`) in `fulfillOrder` and `viewOrderQueue` and handling the `null` return from `orderQueue.poll()` are forms of graceful error handling specific to the queue operations.
 * 
 * 4.  **Best Practices Implementation:**
 *     *   **Encapsulation:** All class fields (`id`, `name`, `price`, `orderId`, `items`, `menu`, `orderQueue`, `scanner`) are `private`. Access and modification are done through public methods (constructors, getters, `addItem`, `getTotal`).
 *     *   **Meaningful Names:** Class names (`MenuItem`, `Order`, `RestaurantSystem`), method names (`displayMenu`, `placeOrder`, `fulfillOrder`, `viewOrderQueue`, `run`), and variable names (`itemId`, `quantity`, `selectedItem`, `newOrder`) are descriptive and indicate their purpose.
 *     *   **Comments/Documentation:** Javadoc-style comments are used for classes and key methods. Inline comments explain specific logic steps, especially in `placeOrder` and `run`.
 *     *   **Input Validation:**
 *         *   Checks for item existence (`findMenuItemById` returning null) in `placeOrder`.
 *         *   Checks for positive quantity in `placeOrder`.
 *         *   Handles `InputMismatchException` for non-integer inputs using `try-catch`.
 *         *   Validates menu choice range in the `switch` statement's `default` case.
 *     *   **Error Handling:** Uses `try-catch` for input errors, checks for empty collections before attempting operations that would fail (like `poll` on an empty queue, though `poll` handles this gracefully by returning `null`, which is then checked), and uses `System.err` to clearly indicate errors.
 *     *   **Clean Code Structure:** The code is organized into separate classes with distinct responsibilities. The `run` method provides a clear application loop, delegating specific tasks to other well-named methods.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating key object-oriented principles and robust error handling techniques suitable for an advanced programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    // Constructor
    public MenuItem(int id, String name, double price) {
        if (id <= 0 || name == null || name.trim().isEmpty() || price < 0) {
            throw new IllegalArgumentException("Invalid MenuItem data.");
        }
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // Getters (Encapsulation)
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Price: %.2f", id, name, price);
    }
}

// Represents an item within an order (includes quantity)
class OrderItem {
    private MenuItem menuItem;
    private int quantity;

    public OrderItem(MenuItem menuItem, int quantity) {
        if (menuItem == null || quantity <= 0) {
            throw new IllegalArgumentException("Invalid OrderItem data.");
        }
        this.menuItem = menuItem;
        this.quantity = quantity;
    }

    public MenuItem getMenuItem() {
        return menuItem;
    }

    public int getQuantity() {
        return quantity;
    }

    public double getSubtotal() {
        return menuItem.getPrice() * quantity;
    }

    @Override
    public String toString() {
        return String.format("%s x%d (%.2f)", menuItem.getName(), quantity, getSubtotal());
    }
}


// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique IDs
    private int orderId;
    private List<OrderItem> items; // Using List interface

    // Constructor
    public Order() {
        this.orderId = nextOrderId++; // Assign unique ID and increment counter
        this.items = new ArrayList<>(); // Using ArrayList implementation
    }

    public int getOrderId() {
        return orderId;
    }

    // Method to add an item to the order
    public void addItem(MenuItem item, int quantity) {
        if (item != null && quantity > 0) {
            this.items.add(new OrderItem(item, quantity));
        } else {
             // This validation should ideally happen before calling addItem,
             // but adding a check here for robustness is also fine.
            System.err.println("Error adding item: Invalid item or quantity.");
        }
    }

    // Calculate the total price of the order
    public double getTotal() {
        double total = 0;
        for (OrderItem item : items) {
            total += item.getSubtotal();
        }
        return total;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        sb.append("Items:\n");
        if (items.isEmpty()) {
            sb.append("  (Empty Order)");
        } else {
            for (OrderItem item : items) {
                sb.append("  - ").append(item).append("\n");
            }
        }
        sb.append(String.format("Total: %.2f", getTotal()));
        return sb.toString();
    }
}

// Main class managing the restaurant system
public class RestaurantSystem {

    // Using List interface, implemented by ArrayList
    private List<MenuItem> menu;
    // Using Queue interface, implemented by LinkedList (common choice for queues)
    private Queue<Order> orderQueue;
    private Scanner scanner;

    // Constructor: Initialize menu, queue, and scanner
    public RestaurantSystem() {
        // Initialize data structures
        this.menu = new ArrayList<>(); // ArrayList for menu items
        this.orderQueue = new LinkedList<>(); // LinkedList as Queue implementation
        this.scanner = new Scanner(System.in);

        // Populate the menu (example items)
        initializeMenu();
    }

    // Populate the initial menu
    private void initializeMenu() {
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Fries", 3.49));
        menu.add(new MenuItem(3, "Soda", 1.99));
        menu.add(new MenuItem(4, "Pizza Slice", 4.50));
        menu.add(new MenuItem(5, "Salad", 7.00));
    }

    // Display the main menu options to the user
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Management ---");
        System.out.println("1. Display Menu");
        System.out.println("2. Place Order");
        System.out.println("3. Fulfill Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Find a menu item by its ID
    private MenuItem findMenuItemById(int id) {
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Handles placing a new order
    private void placeOrder() {
        Order newOrder = new Order();
        System.out.println("\n--- Placing Order ---");
        System.out.println("Enter item ID to add (0 to finish):");

        while (true) {
            int itemId = -1;
            try {
                System.out.print("Item ID: ");
                itemId = scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for item ID.");
                scanner.next(); // Consume the invalid input
                continue; // Ask for item ID again
            }

            if (itemId == 0) {
                break; // Finish adding items
            }

            MenuItem selectedItem = findMenuItemById(itemId);

            if (selectedItem == null) {
                System.err.println("Error: Invalid item ID. Please try again.");
                continue; // Ask for item ID again
            }

            int quantity = -1;
            try {
                System.out.print("Enter quantity for " + selectedItem.getName() + ": ");
                quantity = scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for quantity.");
                scanner.next(); // Consume the invalid input
                continue; // Ask for quantity again
            }

            if (quantity <= 0) {
                System.err.println("Error: Quantity must be positive. Please try again.");
                continue; // Ask for quantity again
            }

            // Add item to the current order being built
            newOrder.addItem(selectedItem, quantity);
            System.out.println("Item(s) added to order.");
            System.out.println("Enter item ID to add (0 to finish):"); // Prompt for next item
        }

        // After loop, check if any items were added
        if (newOrder.getItems().isEmpty()) {
            System.out.println("No items added to order. Order cancelled.");
        } else {
            // Add the completed order to the queue
            orderQueue.offer(newOrder); // offer is preferred over add in queues as it doesn't throw exception on failure
            System.out.printf("Order %d placed. Total: $%.2f\n", newOrder.getOrderId(), newOrder.getTotal());
        }
    }

    // Handles fulfilling the oldest order in the queue
    private void fulfillOrder() {
        System.out.println("\n--- Fulfilling Order ---");
        // poll() retrieves and removes the head of the queue, returns null if empty
        Order fulfilledOrder = orderQueue.poll();

        if (fulfilledOrder == null) {
            System.out.println("No pending orders to fulfill.");
        } else {
            System.out.println("Order " + fulfilledOrder.getOrderId() + " fulfilled.");
            // Optionally display order details here
            // System.out.println(fulfilledOrder);
        }
    }

    // Handles displaying the pending orders in the queue
    private void viewOrderQueue() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            // Using the Queue's iterator maintains order
            for (Order order : orderQueue) {
                System.out.println("Order ID: " + order.getOrderId());
                // To show more details, you could call order.toString() or iterate its items
                // System.out.println(order); // Uncomment to show full order details
            }
        }
    }

    // Handles displaying the menu
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item); // Uses MenuItem's toString()
            }
        }
    }

    // Main application loop
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMainMenu();
            try {
                choice = scanner.nextInt(); // Read user input for menu choice

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        fulfillOrder();
                        break;
                    case 4:
                        viewOrderQueue();
                        break;
                    case 5:
                        System.out.println("Exiting Restaurant Management System.");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                // Catch any other unexpected runtime errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
