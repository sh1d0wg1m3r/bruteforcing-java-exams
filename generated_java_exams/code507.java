/*
 * Exam Question #507
 * Generated on: 2025-05-11 23:21:52
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Problem Description:**
 * 
 * You are required to develop a simplified command-line application for managing tasks within a small team. The system should allow users to add tasks to a queue for processing, process the next task from the queue, and view a history of completed tasks. The application should interact with the user through a menu interface.
 * 
 * **Functionality Requirements:**
 * 
 * 1.  **Add New Task:** Prompt the user to enter a description for a new task. Create a `Task` object with this description and add it to a queue of pending tasks.
 * 2.  **Process Next Task:** Take the task at the front of the pending queue, remove it, and add it to a list of completed tasks. If the queue is empty, display an appropriate error message.
 * 3.  **List Completed Tasks:** Display all tasks currently in the completed tasks list, along with their descriptions.
 * 4.  **Exit:** Terminate the application gracefully.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate understanding and correct usage of the following Java components:
 * 
 * -   `java.util.Queue`: Must be used to store tasks that are waiting to be processed (the pending tasks).
 * -   `java.util.ArrayList`: Must be used as the concrete implementation for storing completed tasks.
 * -   `java.util.List`: The completed tasks storage must be declared using the `List` interface type.
 * -   `java.util.Scanner`: Must be used to read user input from the console for menu choices and task descriptions.
 * -   `switch` statement: Must be used to control the program flow based on the user's menu selection.
 * -   `System.err`: Must be used exclusively for printing all error messages (e.g., invalid input, operation errors like processing an empty queue, unexpected exceptions).
 * -   `System.out`: Must be used exclusively for printing all normal output (menu display, prompts, success messages, task listings).
 * -   Class-wide exception handling: Implement `try-catch` blocks in the main operational method (e.g., a `run` method driving the application loop) to catch potential runtime exceptions. Include specific handling for expected input issues (like non-integer input for menu) and a general catch for unexpected errors.
 * 
 * **Best Practices:**
 * 
 * -   Implement proper encapsulation by making class fields private and providing public methods for interaction.
 * -   Use meaningful variable and method names that clearly indicate their purpose.
 * -   Include appropriate comments and documentation (Javadocs are encouraged) to explain the code.
 * -   Implement input validation where necessary (e.g., non-empty task description, valid menu choice, handling non-integer input).
 * -   Ensure error handling provides informative messages via `System.err`.
 * -   Structure the code cleanly, potentially using a separate class for the `Task` object.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. Exit
 * ---------------------------
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * 
 * SUCCESS: Task added to the queue: Task: "Implement Task Class"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * 
 * SUCCESS: Task processed and moved to completed: Task: "Implement Task Class"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- COMPLETED TASKS ---
 * 1. Task: "Implement Task Class"
 * -----------------------
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * 
 * OPERATION ERROR: No tasks in the queue to process.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: abc
 * 
 * INPUT ERROR: Invalid input. Please enter a number.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * 
 * INPUT ERROR: Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * 
 * Exiting Task Processor. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the complete Java code for this system, adhering to all requirements.
 * 
 * **Note:** You can structure your code using multiple classes (e.g., `Task.java`, `TaskProcessor.java`) within a package, but the final solution should be provided as a single code block for the exam.
 *
 * EXPLANATION:
 * This solution implements the `Team Task Management System` as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`java.util.Queue`**: The `pendingTasksQueue` field is declared as a `Queue<Task>` and initialized with a `LinkedList`. This correctly uses the Queue interface to represent the waiting line of tasks, where tasks are added at the back (`offer`) and removed from the front (`poll`), ensuring FIFO (First-In, First-Out) processing.
 * 2.  **`java.util.ArrayList`**: The `completedTasksList` field is initialized as an `ArrayList<Task>`. This provides a dynamic array implementation suitable for storing the completed tasks, allowing efficient access by index and dynamic resizing as more tasks are completed.
 * 3.  **`java.util.List`**: The `completedTasksList` is declared using the `List<Task>` interface type, even though it is implemented by `ArrayList`. This follows the best practice of programming to the interface, making the code more flexible if a different `List` implementation were needed in the future.
 * 4.  **`java.util.Scanner`**: The `scanner` field is used throughout the `run` method to read user input from `System.in`, including the menu choice (`nextInt`) and the task description (`nextLine`).
 * 5.  **`switch` statement**: A `switch` statement in the `run` method is used to control the main application flow, directing execution to the appropriate method (`addTask`, `processNextTask`, `listCompletedTasks`) based on the integer value of the user's menu choice. The `default` case handles invalid integer inputs.
 * 6.  **`System.err`**: `System.err` is used exclusively for printing error messages. This includes specific errors like an empty queue during processing, invalid menu input (non-integer or out of range), and messages from the general `catch` block for unexpected exceptions. This separates error output from normal application output.
 * 7.  **`System.out`**: `System.out` is used for all normal application output: displaying the menu, prompting the user for input, printing success messages after adding or processing tasks, and listing the completed tasks.
 * 8.  **Class-wide exception handling with `try-catch`**: A comprehensive `try-catch` block wraps the core logic inside the `while` loop in the `run` method. This serves as a class-wide handler for runtime exceptions that might occur during the processing of a single user command. Specific `catch` blocks handle `InputMismatchException` (for non-integer menu input) and `IllegalArgumentException` (from the `Task` constructor), providing user-friendly error messages via `System.err`. A general `catch (Exception e)` block is included to catch any other unexpected runtime errors, printing a generic error message and allowing the loop to potentially continue (unless a critical error occurs).
 * 
 * **Best Practices Demonstrated:**
 * 
 * -   **Encapsulation:** The `Task` and `TaskProcessor` classes have private fields (`description`, `pendingTasksQueue`, `completedTasksList`, `scanner`) and provide public methods (`getDescription`, `addTask`, `processNextTask`, `listCompletedTasks`, `run`, `main`) to interact with their state.
 * -   **Meaningful Names:** Variable names like `pendingTasksQueue`, `completedTasksList`, `processedTask`, and method names like `addTask`, `processNextTask`, `listCompletedTasks`, `displayMenu`, `run` are descriptive and indicate their purpose.
 * -   **Comments and Documentation:** Basic Javadoc comments are included for classes and methods, explaining their function, parameters, and return values or exceptions. Inline comments clarify specific logic points.
 * -   **Input Validation:** Validation is performed in the `Task` constructor to ensure the description is not empty. The `run` method handles non-integer input for the menu choice and checks for valid integer ranges in the `switch` statement's `default` case.
 * -   **Error Handling:** Error conditions like an empty queue during processing are explicitly checked, and informative error messages are printed to `System.err`. The `try-catch` blocks provide robust handling for both expected input errors and unexpected runtime issues.
 * -   **Clean Code Structure:** The problem is divided into two classes (`Task` and `TaskProcessor`) with clear responsibilities. Methods are kept relatively short and focused on a single task. Resource management (closing the `Scanner`) is handled explicitly.
 * 
 * This solution effectively integrates the required Java concepts into a practical scenario, demonstrating robust implementation and adherence to standard coding practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 * Demonstrates basic encapsulation.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation for task description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a user-friendly string representation of the Task.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return "Task: \"" + description + "\"";
    }
}

/**
 * Manages the workflow of tasks using a queue for pending tasks
 * and a list for completed tasks. Provides a command-line interface.
 */
public class TaskProcessor {

    // Private fields demonstrating encapsulation
    private Queue<Task> pendingTasksQueue; // Uses Queue interface
    private List<Task> completedTasksList; // Uses List interface, implemented by ArrayList
    private Scanner scanner; // For user input

    /**
     * Constructor initializes the task data structures and the scanner.
     */
    public TaskProcessor() {
        // Using LinkedList as a common and efficient implementation for Queue
        this.pendingTasksQueue = new LinkedList<>();
        // Using ArrayList as the concrete implementation for the List of completed tasks
        this.completedTasksList = new ArrayList<>();
        // Scanner for reading input from standard input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Handles potential errors during task creation (validation).
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the full line for description

        try {
            Task newTask = new Task(description);
            // offer() is preferred over add() in queues as it handles capacity-constrained queues gracefully (though LinkedList is not capacity-constrained)
            if (pendingTasksQueue.offer(newTask)) {
                System.out.println(System.lineSeparator() + "SUCCESS: Task added to the queue: " + newTask);
            } else {
                 // This else block is primarily for capacity-constrained queues, but good practice
                System.err.println(System.lineSeparator() + "ERROR: Failed to add task to the queue.");
            }
        } catch (IllegalArgumentException e) {
            // Catching specific validation error from Task constructor
            System.err.println(System.lineSeparator() + "INPUT ERROR: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation/addition
            System.err.println(System.lineSeparator() + "UNEXPECTED ERROR while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue, moving it to the completed list.
     * Displays error if queue is empty.
     */
    private void processNextTask() {
        // Check if the queue is empty before attempting to poll
        if (pendingTasksQueue.isEmpty()) {
            System.err.println(System.lineSeparator() + "OPERATION ERROR: No tasks in the queue to process.");
            return; // Exit method if queue is empty
        }

        // poll() retrieves and removes the head of the queue. Returns null if empty, but we checked already.
        Task processedTask = pendingTasksQueue.poll();

        // add() for ArrayList always returns true unless memory is exhausted
        if (completedTasksList.add(processedTask)) {
             System.out.println(System.lineSeparator() + "SUCCESS: Task processed and moved to completed: " + processedTask);
        } else {
            // This case is very rare for ArrayList under normal conditions
             System.err.println(System.lineSeparator() + "ERROR: Failed to add processed task to the completed list.");
        }
    }

    /**
     * Lists all tasks that have been completed by iterating through the completedTasksList.
     */
    private void listCompletedTasks() {
        System.out.println(System.lineSeparator() + "--- COMPLETED TASKS ---");
        // Check if the list is empty
        if (completedTasksList.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the List and print each completed task
            for (int i = 0; i < completedTasksList.size(); i++) {
                 Task completedTask = completedTasksList.get(i);
                 System.out.println((i + 1) + ". " + completedTask);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println(System.lineSeparator() + "--- Task Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Completed Tasks");
        System.out.println("4. Exit");
        System.out.println("---------------------------");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main interactive loop for the Task Processor application.
     * Includes class-wide exception handling for robustness.
     */
    public void run() {
        boolean running = true;
        // Main application loop
        while (running) {
            // Class-wide exception handling for the core loop operations
            try {
                displayMenu();

                // Read user choice (expecting an integer)
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Using switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        processNextTask(); // Call method to process a task
                        break;
                    case 3:
                        listCompletedTasks(); // Call method to list completed tasks
                        break;
                    case 4:
                        System.out.println(System.lineSeparator() + "Exiting Task Processor. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle invalid menu choices using System.err
                        System.err.println(System.lineSeparator() + "INPUT ERROR: Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (InputMismatchException e) {
                // Specific handling for non-integer input when reading menu choice
                System.err.println(System.lineSeparator() + "INPUT ERROR: Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input line to prevent infinite loop
            } catch (Exception e) {
                // General catch block for any other unexpected runtime errors
                // Prints error message to System.err
                System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage());
                // Optional: print stack trace for debugging purposes
                // e.printStackTrace(System.err);
            }
        }
        // Ensure scanner is closed when the application loop finishes
        closeScanner();
    }

    /**
     * Closes the scanner resource to prevent resource leaks.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed."); // Indicate resource closure
        }
    }

    /**
     * Main method to start the Task Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run(); // Start the main application loop
    }
}
