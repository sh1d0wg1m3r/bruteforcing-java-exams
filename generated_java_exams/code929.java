/*
 * Exam Question #929
 * Generated on: 2025-05-12 17:01:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Implement a console-based Task Management System that allows users to manage pending and completed tasks. This task requires demonstrating proficiency with core Java data structures, user input handling, control flow, and exception management, adhering to best practices.
 * 
 * **Scenario:** You are building a simple system for a team to track tasks. Tasks are added to a queue and processed in a First-In, First-Out (FIFO) manner. Once completed, tasks are moved to a history list.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task`.
 *     *   It must have private fields: `description` (String), `priority` (int), and `isCompleted` (boolean).
 *     *   Include a constructor to initialize `description` and `priority`, setting `isCompleted` to `false`.
 *     *   Provide public getter methods for all fields.
 *     *   Include a public method `markComplete()` that sets the `isCompleted` field to `true`.
 *     *   Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Task Manager Class:** Create a class named `TaskManager` containing the main logic and data structures.
 *     *   Use a `java.util.Queue<Task>` to store tasks that are pending. Choose an appropriate concrete implementation (e.g., `LinkedList`). Tasks should be added to the queue and completed from the front of the queue.
 *     *   Use a `java.util.List<Task>` (declared as the interface type `List`) to store tasks that have been completed. Choose an appropriate concrete implementation (e.g., `ArrayList`).
 *     *   Use a `java.util.Scanner` object to read user input from the console (`System.in`).
 * 
 * 3.  **User Interface & Control Flow:**
 *     *   Implement a main loop in the `TaskManager` class that repeatedly displays a menu and processes user input.
 *     *   The menu should present the following options:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  Complete Next Task
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's integer choice for menu navigation.
 * 
 * 4.  **Input Handling and Validation:**
 *     *   Use the `Scanner` to read the user's menu choice, task description, and task priority.
 *     *   Validate user input:
 *         *   Ensure the task description is not empty.
 *         *   Ensure priority is an integer.
 *         *   Handle cases where the user enters non-integer input for menu choices or priority.
 * 
 * 5.  **Output:**
 *     *   Use `System.out` exclusively for displaying the menu, success messages (e.g., "Task added"), and the lists of pending and completed tasks.
 *     *   Use `System.err` exclusively for displaying *all* error messages (e.g., invalid menu choice, invalid input format, attempting to complete a task when the queue is empty, attempting to view completed tasks when the list is empty).
 * 
 * 6.  **Exception Handling:**
 *     *   Implement `try-catch` blocks to handle specific expected exceptions, such as `InputMismatchException` when reading integer input.
 *     *   Implement "class-wide" exception handling by wrapping the main menu loop or core execution logic within a `try-catch` block that catches broader exceptions (`Exception`) to prevent the program from crashing unexpectedly and to report the error to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Ensure proper encapsulation in the `Task` class by using private fields and public methods.
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include comments to explain the purpose of classes, methods, and key logic sections.
 *     *   Ensure the `Scanner` resource is closed properly when the program exits.
 * 
 * **Expected Behavior:**
 * 
 * *   The program should start, display the menu, and prompt for input.
 * *   Selecting '1' should prompt for description and priority, validate, create a `Task` object, and add it to the pending queue (`System.out` confirmation, `System.err` on validation failure).
 * *   Selecting '2' should print all tasks currently in the pending queue (`System.out`), or print a message if the queue is empty (`System.out`).
 * *   Selecting '3' should remove the task at the front of the pending queue, mark it complete, and add it to the completed list (`System.out` confirmation). If the queue is empty, it should print an error message (`System.err`).
 * *   Selecting '4' should print all tasks in the completed list (`System.out`), or print a message if the list is empty (`System.out`).
 * *   Selecting '5' should exit the program cleanly (`System.out` exit message).
 * *   Entering any other number for the menu choice should print an error message (`System.err`).
 * *   Entering non-numeric input when a number is expected (menu choice, priority) should print an error message (`System.err`) and allow the program to continue.
 * *   Any unexpected runtime error should be caught and reported to `System.err`.
 * 
 * **Deliverable:** Provide the complete Java code for the `Task` and `TaskManager` classes.
 *
 * EXPLANATION:
 * This solution implements the requested Task Management System using the specified Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `description`, `priority`, and `isCompleted` as private fields, demonstrating encapsulation.
 *     *   Public getter methods provide controlled access to the task's state.
 *     *   `markComplete()` is a simple method to change the task's status.
 *     *   `toString()` is overridden for convenient printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `LinkedList`. This correctly uses the `Queue` interface and a common implementation suitable for FIFO behavior, fulfilling the `Queue` and `LinkedList` implicit requirements.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `ArrayList`. This fulfills the `List` interface and `ArrayList` requirements.
 *     *   **`Scanner`:** A single `Scanner` instance is created and used throughout the class for reading user input. It is closed in a `finally` block in the `run()` method to release system resources.
 *     *   **`run()` Method:** This is the core of the application loop.
 *         *   It uses a `while` loop (`while(running)`) to keep the application active until the user chooses to exit.
 *         *   **Class-wide Exception Handling:** A broad `try-catch(Exception e)` block wraps the main `while` loop. This serves as a safety net to catch any unexpected runtime errors that might occur anywhere within the loop's execution, printing an error message and stack trace to `System.err` before allowing the `finally` block to close the scanner and shut down.
 *         *   **Menu and `switch`:** The `printMenu()` method displays options using `System.out`. User input for the menu choice is read using `scanner.nextInt()`. A `switch` statement directs the program flow based on the user's selection, fulfilling the `switch` requirement.
 *         *   **Input-Specific Exception Handling:** A nested `try-catch(InputMismatchException e)` is used specifically around `scanner.nextInt()` calls (for menu choice and priority input). This catches non-integer input, prints a user-friendly error message to `System.err`, and uses `scanner.nextLine()` to consume the invalid input, preventing an infinite loop caused by `nextInt()` not reading the line break or the invalid token. The `finally` block after reading integers is crucial to consume the newline character left behind, ensuring subsequent `scanner.nextLine()` calls in methods like `addTask()` work correctly.
 *     *   **Task Management Methods (`addTask`, `viewPendingTasks`, `completeNextTask`, `viewCompletedTasks`):**
 *         *   These methods implement the core logic for each menu option.
 *         *   `addTask`: Reads description (using `nextLine()`) and priority (using `nextInt()`), includes validation for empty description and uses a `try-catch` for priority input. Uses `pendingTasks.offer()` to add to the queue (standard Queue method). Output uses `System.out` for success and `System.err` for validation errors.
 *         *   `viewPendingTasks`: Checks if the queue is empty before iterating. Iterates through the `pendingTasks` queue using an enhanced for loop (iteration does not remove elements from a Queue) and prints task details using `System.out`. Prints a message to `System.out` if empty.
 *         *   `completeNextTask`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` is the standard Queue method for this operation and gracefully returns `null` if the queue is empty. This null check is used to handle the empty queue case, printing an error to `System.err`. If a task is retrieved, it calls `markComplete()` and adds the task to the `completedTasks` list using `completedTasks.add()`. Success message goes to `System.out`.
 *         *   `viewCompletedTasks`: Checks if the `completedTasks` list is empty before iterating. Iterates through the list and prints task details using `System.out`. Prints a message to `System.out` if empty.
 *     *   **Error Handling (`System.err`):** `System.err` is consistently used for all error conditions: invalid menu choice (in `switch` default), `InputMismatchException` (in nested try-catch blocks), attempting operations on empty collections (in `completeNextTask` and `viewCompletedTasks`), and the general unexpected exception (in the outer try-catch in `run()`). This fulfills the `System.err` requirement and good practice of separating error output.
 *     *   **Output (`System.out`):** All non-error output, including the menu, prompts, success confirmations, and task listings, is directed to `System.out`, fulfilling this requirement.
 * 
 * 3.  **Best Practices:**
 *     *   Encapsulation is demonstrated in the `Task` class.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `completeNextTask`, `viewCompletedTasks`).
 *     *   Comments explain the purpose of classes, methods, fields, and key logic points like exception handling and input consumption.
 *     *   Input validation is performed for description and priority.
 *     *   Error handling is implemented using `try-catch` and `System.err`.
 *     *   The code structure is clean, separating task representation from management logic.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating an understanding of data structures, user interaction, control flow, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for input type mismatch

// Class representing a single task
class Task {
    private String description;
    private int priority; // Lower number indicates higher priority
    private boolean isCompleted;

    /**
     * Constructor for creating a new Task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(String description, int priority) {
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Tasks are not completed upon creation
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markComplete() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string with task details.
     */
    @Override
    public String toString() {
        return String.format("Task [Desc: \"%s\", Priority: %d, Completed: %b]",
                             description, priority, isCompleted);
    }
}

// Class managing the collection of tasks
public class TaskManager {
    // Queue to hold tasks that are pending (waiting)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner to read input from the console
    private Scanner scanner;

    /**
     * Constructor to initialize the TaskManager.
     * Sets up the data structures and the scanner.
     */
    public TaskManager() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }

    /**
     * Runs the main application loop, displaying the menu and processing choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        System.out.println("--- Task Manager Application Started ---");

        // Class-wide exception handling for unexpected errors during the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default value for invalid choice

                // Try block specifically for reading the menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Handle case where input is not an integer
                    System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
                    // Consume the invalid input line to prevent infinite loops
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show menu again
                } finally {
                     // Consume the newline character left by nextInt()
                     // This is crucial before the next nextLine() call in other methods
                     if (scanner.hasNextLine()) { // Check if there's a line feed to consume
                         scanner.nextLine();
                     }
                }

                // Switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        completeNextTask();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu numbers using System.err
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between menu cycles
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions in the main loop
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            // Optionally print stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure scanner is closed when the application finishes or crashes
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("--- Task Manager Application Shut Down ---");
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Complete Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("-------------------------");
    }

    /**
     * Prompts user for task details, validates input, creates a Task,
     * and adds it to the pending tasks queue.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read the whole line for description

        // Input validation for description
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }

        int priority = -1; // Default value for invalid priority
        System.out.print("Enter priority (integer, lower number = higher priority): ");

        // Try block specifically for reading priority input
        try {
            priority = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle case where input is not an integer
            System.err.println("Error: Invalid priority input. Please enter an integer.");
            // Consume the invalid input line
            scanner.nextLine();
            return; // Exit method if validation fails
        } finally {
             // Consume the newline character left by nextInt()
             if (scanner.hasNextLine()) {
                scanner.nextLine();
             }
        }

        // Create the task and add it to the pending queue
        Task newTask = new Task(description, priority);
        pendingTasks.offer(newTask); // offer() is the standard way to add to a Queue

        System.out.println("Success: Task added: \"" + description + "\" with priority " + priority);
    }

    /**
     * Displays all tasks currently in the pending queue to System.out.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        // Check if the queue is empty
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
            return;
        }

        // Iterate through the queue and print each task
        // Iteration does NOT remove elements from the Queue
        int i = 1;
        for (Task task : pendingTasks) {
            System.out.println(i++ + ". " + task);
        }
    }

    /**
     * Completes the next task in the pending queue (FIFO), removes it,
     * and adds it to the completed tasks list.
     */
    private void completeNextTask() {
        System.out.println("--- Complete Next Task ---");
        // Retrieve and remove the head of the queue using poll()
        Task completedTask = pendingTasks.poll(); // poll() returns null if the queue is empty

        // Check if the queue was empty
        if (completedTask == null) {
            System.err.println("Error: No tasks in the queue to complete.");
            return;
        }

        // Mark the task as complete and add it to the completed list
        completedTask.markComplete();
        completedTasks.add(completedTask); // Add to the end of the completed list

        System.out.println("Success: Completed task: \"" + completedTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks currently in the completed tasks list to System.out.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        // Check if the completed tasks list is empty
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }

        // Iterate through the list and print each completed task
        int i = 1;
        for (Task task : completedTasks) {
            System.out.println(i++ + ". " + task);
        }
    }
}
