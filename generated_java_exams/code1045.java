/*
 * Exam Question #1045
 * Generated on: 2025-05-12 17:17:15
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Process Scheduler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a process scheduler for a small operating system. The scheduler manages tasks that arrive, wait in a queue, are processed one by one, and then moved to a list of completed tasks. The system should interact with the user via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this process scheduler. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold tasks that are waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare the completed tasks collection using the `java.util.List` interface.
 * 
 * 2.  **Classes:**
 *     *   Create a `Task` class to represent individual tasks. It should have:
 *         *   A unique integer ID.
 *         *   A String description.
 *         *   A String status (e.g., "Waiting", "Running", "Completed").
 *         *   Private fields with public getter methods.
 *         *   Methods to update the status (e.g., `markAsRunning()`, `markAsCompleted()`).
 *         *   A meaningful `toString()` method for easy printing.
 *     *   Create a `ProcessScheduler` class to manage the task queue and completed task list. It should have:
 *         *   Private fields for the queue and list.
 *         *   A method to add a new task to the waiting queue.
 *         *   A method to process the next task from the queue (move from waiting to completed).
 *         *   Methods to display the tasks in the waiting queue and the completed tasks list.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Waiting Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Prompt the user for necessary input (e.g., task description).
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for all normal program output (menu, prompts, task lists, confirmations).
 *     *   Use `System.err` to print error messages related to invalid user input or unexpected issues.
 *     *   Implement input validation:
 *         *   Ensure the user enters an integer for the menu choice.
 *         *   Ensure the task description is not empty.
 *     *   Implement operational checks:
 *         *   Inform the user via `System.out` if they try to process a task when the queue is empty.
 *     *   Include a class-wide `try-catch` block in your main execution logic to catch any unexpected exceptions and print an error message to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation where necessary.
 *     *   Structure your code logically.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Process Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Task 1 'Implement feature X' added to the waiting queue.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * Task ID: 1, Description: Implement feature X, Status: Waiting
 * --- End Waiting Tasks ---
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processing task 1 'Implement feature X'...
 * Task 1 'Implement feature X' completed.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * (Queue is empty)
 * --- End Waiting Tasks ---
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 1, Description: Implement feature X, Status: Completed
 * --- End Completed Tasks ---
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * No tasks in the waiting queue to process.
 * 
 * --- Process Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * **Grading:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use and integration of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Input validation and error handling robustness.
 * *   Code clarity, structure, comments, and adherence to best practices.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * The provided solution implements a simplified process scheduler simulation in Java, fulfilling all the requirements of the exam task.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `taskQueue` field in the `ProcessScheduler` class is declared as a `Queue<Task>` and initialized with a `LinkedList`. `LinkedList` is chosen because it efficiently implements the `Queue` interface methods (`add`, `poll`, `peek`). The `addTask` method uses `add` to enqueue new tasks, and `processNextTask` uses `poll` to dequeue the next task for processing.
 * 2.  **`java.util.ArrayList`**: The `completedTasks` field is initialized as an `ArrayList<Task>`. This dynamic array is used to store tasks after they have been processed and completed.
 * 3.  **`java.util.List`**: The `completedTasks` field is *declared* using the `List<Task>` interface (`private List<Task> completedTasks;`). This demonstrates programming to an interface, a key best practice that allows for flexibility (e.g., easily switching to a `LinkedList` or other `List` implementation later if needed) without changing the code that uses the list methods.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used in the `main` method of `SchedulerApp` to read user input from `System.in`. It's used to read both integer choices (`nextInt`) and String task descriptions (`nextLine`). Crucially, `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 * 5.  **`switch` statement**: The `main` method uses a `switch` statement based on the user's integer choice to navigate between the different scheduler operations (Add Task, Process, View Waiting, View Completed, Exit).
 * 6.  **`System.err`**: `System.err.println()` is used specifically for reporting error conditions related to user input validation (non-integer input, invalid choice number) and for printing the message from the caught exception in the main `try-catch` block. This correctly separates error output from normal program output.
 * 7.  **`System.out`**: `System.out.println()` is used for all standard program communication with the user: displaying the menu, prompting for input, confirming actions (task added, task completed), and listing tasks in the waiting queue or completed list.
 * 8.  **Class-wide `try-catch`**: The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level catch-all for any unexpected runtime exceptions that might occur during the program's execution, preventing the program from crashing abruptly and printing an error message to `System.err`.
 * 
 * **Class Design and Encapsulation:**
 * 
 * *   **`Task` Class:** Represents a single unit of work. It has `private` fields (`taskId`, `description`, `status`) and provides `public` getter methods to access this information. Methods like `markAsRunning()` and `markAsCompleted()` encapsulate the logic for changing the task's state. The `toString()` method provides a convenient string representation.
 * *   **`ProcessScheduler` Class:** Manages the collections (`taskQueue`, `completedTasks`) and the logic for scheduler operations. Its fields are `private`, and the operations are exposed via `public` methods (`addTask`, `processNextTask`, `viewWaitingTasks`, `viewCompletedTasks`). This separation of concerns and encapsulation keeps the data safe and controlled.
 * *   **`SchedulerApp` Class:** Contains the `main` method, responsible for the user interface, reading input, and calling the appropriate methods on the `ProcessScheduler` instance. This separates the UI logic from the core scheduler logic.
 * 
 * **Error Handling and Validation:**
 * 
 * *   **Input Type Validation:** `scanner.hasNextInt()` is used before `scanner.nextInt()` to check if the next token is an integer. If not, an error is printed to `System.err`, the invalid input is consumed, and the loop continues.
 * *   **Input Value Validation:** The `switch` statement handles valid menu choices (1-5). The `default` case catches invalid integer choices, printing an error to `System.err`. The `addTask` method checks if the description is null or empty, printing an error to `System.err` if invalid.
 * *   **Operational Checks:** `processNextTask` uses `taskQueue.poll()` which returns `null` if the queue is empty. This allows the code to check for an empty queue and print an informative message to `System.out` (as this is an expected operational state, not an error condition) instead of throwing an exception.
 * 
 * **Best Practices:**
 * 
 * *   Meaningful names (`taskQueue`, `completedTasks`, `processNextTask`, `viewWaitingTasks`, etc.) improve code readability.
 * *   Comments explain the purpose of classes and methods.
 * *   Using the `List` interface for `completedTasks` demonstrates good design.
 * *   The code is structured into logical classes (`Task`, `ProcessScheduler`, `SchedulerApp`).
 * *   Resource management: The `Scanner` is closed in a `finally` block to ensure it's released even if an exception occurs.
 * 
 * This solution effectively integrates the required Java components within a practical simulation, demonstrating an understanding of data structures, object-oriented design, input/output, control flow, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the process scheduler.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Waiting", "Running", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Waiting"; // Tasks start in Waiting status
    }

    // Public getter methods
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task status as Running.
     */
    public void markAsRunning() {
        this.status = "Running";
    }

    /**
     * Marks the task status as Completed.
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the queue of waiting tasks and the list of completed tasks.
 */
class ProcessScheduler {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Declared using List interface
    private int nextTaskId;

    /**
     * Constructs a new ProcessScheduler.
     */
    public ProcessScheduler() {
        // LinkedList implements the Queue interface
        this.taskQueue = new LinkedList<>();
        // ArrayList implements the List interface
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the waiting queue.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.add(newTask);
        System.out.println("Task " + newTask.getTaskId() + " '" + newTask.getDescription() + "' added to the waiting queue.");
    }

    /**
     * Processes the next task from the waiting queue.
     * Moves the task to the completed list after processing.
     */
    public void processNextTask() {
        // Use poll() which returns null if the queue is empty,
        // safer than remove() which throws an exception.
        Task taskToProcess = taskQueue.poll();

        if (taskToProcess == null) {
            System.out.println("No tasks in the waiting queue to process.");
            return;
        }

        // Simulate processing
        taskToProcess.markAsRunning();
        System.out.println("Processing task " + taskToProcess.getTaskId() + " '" + taskToProcess.getDescription() + "'...");

        // Simulate completion
        taskToProcess.markAsCompleted();
        completedTasks.add(taskToProcess); // Add to the list of completed tasks
        System.out.println("Task " + taskToProcess.getTaskId() + " '" + taskToProcess.getDescription() + "' completed.");
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    public void viewWaitingTasks() {
        System.out.println("--- Waiting Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Waiting Tasks ---");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Completed Tasks ---");
    }
}

/**
 * Main application class for the Process Scheduler.
 * Handles user interaction and delegates to ProcessScheduler.
 */
public class SchedulerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProcessScheduler scheduler = new ProcessScheduler();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1; // Default invalid choice
                System.out.print("Enter your choice: ");

                // Input validation for integer choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input to prevent infinite loop
                    String invalidInput = scanner.next();
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration
                }

                // Consume the rest of the line after reading the integer
                scanner.nextLine();

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        scheduler.addTask(description);
                        break;
                    case 2: // Process Next Task
                        scheduler.processNextTask();
                        break;
                    case 3: // View Waiting Tasks
                        scheduler.viewWaitingTasks();
                        break;
                    case 4: // View Completed Tasks
                        scheduler.viewCompletedTasks();
                        break;
                    case 5: // Exit
                        System.out.println("Exiting scheduler.");
                        running = false;
                        break;
                    default: // Invalid choice number
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Process Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
