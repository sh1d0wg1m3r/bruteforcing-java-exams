/*
 * Exam Question #647
 * Generated on: 2025-05-12 16:19:36
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Scenario:**
 * You are tasked with developing a simplified appointment scheduling system for a small clinic. The system needs to manage a queue of patients waiting to be scheduled and a list of appointments that have been scheduled. Some patients may be marked as "urgent" and should be prioritized at the front of the waiting queue.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides the following functionalities via a command-line interface:
 * 
 * 1.  **Add Patient to Queue:**
 *     *   Prompt the user for the patient's name and whether they are urgent (yes/no).
 *     *   Assign a unique ID to the patient (e.g., using a counter).
 *     *   If urgent, add the patient to the front of the waiting queue.
 *     *   If not urgent, add the patient to the end of the waiting queue.
 *     *   Confirm the patient has been added.
 * 2.  **Schedule Next Patient:**
 *     *   Check if the waiting queue is empty. If so, display an error.
 *     *   If not empty, take the next patient from the front of the queue.
 *     *   Find the first available time slot from a predefined list of slots (e.g., "09:00", "10:00", "11:00", "13:00", "14:00").
 *     *   If no slots are available, return the patient to the front of the queue and display an error.
 *     *   If a slot is available, create an appointment for the patient with the available slot.
 *     *   Add the appointment to the list of scheduled appointments.
 *     *   Remove the time slot from the list of available slots.
 *     *   Display the scheduled appointment details.
 * 3.  **View Waiting Queue:**
 *     *   Display the details of all patients currently in the waiting queue, in order.
 *     *   If the queue is empty, display a message indicating this.
 * 4.  **View Scheduled Appointments:**
 *     *   Display the details of all scheduled appointments.
 *     *   If no appointments are scheduled, display a message indicating this.
 * 5.  **Cancel Appointment:**
 *     *   Prompt the user for the time slot of the appointment to cancel.
 *     *   Find the appointment with the specified time slot in the scheduled list.
 *     *   If found, remove the appointment from the scheduled list.
 *     *   Add the time slot back to the list of available slots.
 *     *   Display a confirmation message.
 *     *   If not found, display an error message.
 * 6.  **Exit:**
 *     *   Terminate the program.
 * 
 * **Constraints & Implementation Details:**
 * 
 * *   You **MUST** use the following Java components:
 *     *   `java.util.Queue` (specifically `LinkedList` which implements `Queue` and allows adding to front) for the waiting list.
 *     *   `java.util.ArrayList` for the list of scheduled appointments.
 *     *   `java.util.List` interface (use it for variable declarations where appropriate, e.g., `List<Appointment> scheduledAppointments`).
 *     *   `java.util.Scanner` for reading user input.
 *     *   `switch` statement for handling the main menu options.
 *     *   `System.err` for displaying error messages (e.g., queue empty, slot unavailable, invalid input, appointment not found).
 *     *   `System.out` for displaying menus, prompts, success messages, and list contents.
 *     *   Class-wide exception handling using `try-catch` blocks wrapping the main program loop to catch unexpected errors. Implement specific `try-catch` for input validation where necessary (e.g., non-integer menu input).
 * *   Implement proper encapsulation (private fields, public methods) for any classes you create (e.g., `Patient`, `Appointment`).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and basic documentation.
 * *   Implement input validation (e.g., for menu choices, urgent status yes/no).
 * *   Ensure proper error handling using `System.err`.
 * *   Maintain a clean code structure.
 * *   Predefine a fixed set of available time slots at the start of the program.
 * *   Patient IDs should be unique integers.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu of options. Based on the user's input, it should perform the requested action, display relevant information to `System.out`, and display error messages to `System.err` when necessary.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Hospital Scheduler Menu ---
 * 1. Add Patient to Queue
 * 2. Schedule Next Patient
 * 3. View Waiting Queue
 * 4. View Scheduled Appointments
 * 5. Cancel Appointment
 * 6. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Is Alice urgent? (yes/no): no
 * Patient Alice (ID: 1) added to the waiting queue.
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 1
 * Enter patient name: Bob
 * Is Bob urgent? (yes/no): yes
 * Patient Bob (ID: 2) added to the front of the waiting queue.
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Waiting Queue:
 * ID: 2, Name: Bob, Urgent: true
 * ID: 1, Name: Alice, Urgent: false
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Scheduled appointment for Bob (ID: 2) at 09:00.
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * Scheduled Appointments:
 * Time: 09:00, Patient: Bob (ID: 2)
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Scheduled appointment for Alice (ID: 1) at 10:00.
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Enter time slot to cancel: 09:00
 * Appointment at 09:00 for Bob (ID: 2) cancelled. Slot 09:00 is now available.
 * 
 * --- Hospital Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Enter time slot to cancel: 15:00
 * Error: No appointment found for time slot 15:00.
 * ```
 * 
 * This task requires you to integrate multiple core Java concepts into a functional, well-structured program.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment scheduler, demonstrating the required Java concepts in a practical scenario.
 * 
 * **Class Structure:**
 * *   `Patient`: A simple class to hold patient data (`id`, `name`, `isUrgent`). It uses a static counter (`nextId`) to ensure unique IDs for each patient. Encapsulation is maintained with private fields and public getters.
 * *   `Appointment`: A simple class to represent a scheduled appointment, linking a `Patient` object to a `timeSlot` string. Encapsulation is used here as well.
 * *   `HospitalScheduler`: The main class that orchestrates the application logic. It holds the data structures (`waitingQueue`, `scheduledAppointments`, `availableTimeSlots`) and contains the methods for each menu option (`addPatientToQueue`, `scheduleNextPatient`, etc.), the `displayMenu` method, the main `run` loop, and the `main` method.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `waitingQueue` is declared as `Queue<Patient>`. We specifically instantiate it as `LinkedList<Patient>` because `LinkedList` implements `Queue` and provides the `addFirst()` method required to add urgent patients to the front, which is not a standard `Queue` operation but is necessary for this problem's priority requirement. `offer()` is used for non-urgent patients (standard `Queue` add). `peek()` is used to look at the next patient without removing, and `poll()` is used to remove and get the next patient when scheduling.
 * 2.  **`java.util.ArrayList`:** The `scheduledAppointments` list is instantiated as `new ArrayList<>()`. This provides dynamic resizing and allows easy addition (`add`), removal (`remove`), and iteration. The `availableTimeSlots` list is also implemented using `ArrayList` for similar reasons.
 * 3.  **`java.util.List` interface:** The `scheduledAppointments` and `availableTimeSlots` are declared using the `List` interface (`List<Appointment> scheduledAppointments`, `List<String> availableTimeSlots`). This demonstrates programming to the interface, which is a good practice for flexibility.
 * 4.  **`java.util.Scanner`:** A `Scanner` object (`scanner`) is used to read all user input from `System.in`. It's used in `addPatientToQueue`, `cancelAppointment`, and the main `run` loop for reading the menu choice. Care is taken to consume the newline character after `scanner.nextInt()` using `scanner.nextLine()`.
 * 5.  **`switch` statement:** A `switch` statement in the `run` method is used to control the program flow based on the user's integer input for the main menu selection.
 * 6.  **`System.err`:** `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, invalid input for urgency, queue empty, no slots available, or appointment not found during cancellation.
 * 7.  **`System.out`:** `System.out.println()` is used for all normal output, including displaying the menu, prompts, confirmation messages, and the contents of the waiting queue and scheduled appointments lists.
 * 8.  **Class-wide exception handling with `try-catch`:** A `try-catch(Exception e)` block wraps the entire `while` loop in the `run` method. This serves as a general catch-all for any unexpected runtime exceptions that might occur within the application logic. Specific `try-catch(InputMismatchException e)` is also used when reading the menu choice to handle cases where the user enters non-integer input, preventing program crashes and allowing the user to try again. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Other Best Practices:**
 * 
 * *   **Encapsulation:** Private fields and public getters/methods are used in `Patient`, `Appointment`, and `HospitalScheduler`.
 * *   **Meaningful Names:** Variable names (`waitingQueue`, `scheduledAppointments`, `patientToSchedule`, `timeSlotToCancel`) and method names (`addPatientToQueue`, `scheduleNextPatient`, `viewWaitingQueue`) clearly indicate their purpose.
 * *   **Comments:** Javadoc-style comments are used for methods, and inline comments explain specific logic points (like using `LinkedList`'s `addFirst`).
 * *   **Input Validation:** The code checks if the urgent input is "yes" or "no" and prompts the user again if invalid. It also uses `try-catch` for integer input validation.
 * *   **Error Handling:** Specific error conditions (empty queue, no slots, not found) are checked, and informative messages are printed to `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical methods, and the main `run` method handles the user interaction loop and menu dispatching via the `switch` statement.
 * 
 * This solution effectively integrates all the required components into a functional program that simulates a real-world scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in Java.
 */

import java.util.*;
import java.util.Queue; // Explicit import for clarity

// Represents a patient waiting for an appointment
class Patient {
    private static int nextId = 1; // Class-level counter for unique IDs

    private int id;
    private String name;
    private boolean isUrgent;

    public Patient(String name, boolean isUrgent) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.name = name;
        this.isUrgent = isUrgent;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isUrgent() {
        return isUrgent;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Urgent: " + isUrgent;
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private String timeSlot;

    public Appointment(Patient patient, String timeSlot) {
        this.patient = patient;
        this.timeSlot = timeSlot;
    }

    public Patient getPatient() {
        return patient;
    }

    public String getTimeSlot() {
        return timeSlot;
    }

    @Override
    public String toString() {
        return "Time: " + timeSlot + ", Patient: " + patient.getName() + " (ID: " + patient.getId() + ")";
    }
}

// Main class for the Hospital Appointment Scheduler
public class HospitalScheduler {

    // Using LinkedList as it implements Queue and allows adding to the front
    private Queue<Patient> waitingQueue = new LinkedList<>();
    // Using ArrayList as required for the scheduled appointments list
    private List<Appointment> scheduledAppointments = new ArrayList<>();
    // Using ArrayList for available time slots
    private List<String> availableTimeSlots = new ArrayList<>();

    private Scanner scanner = new Scanner(System.in);

    // Constructor to initialize available time slots
    public HospitalScheduler() {
        // Predefine available slots
        availableTimeSlots.add("09:00");
        availableTimeSlots.add("10:00");
        availableTimeSlots.add("11:00");
        availableTimeSlots.add("13:00");
        availableTimeSlots.add("14:00");
        // Sort slots to make scheduling predictable (first available)
        Collections.sort(availableTimeSlots);
    }

    // --- Core Functionalities ---

    /**
     * Adds a new patient to the waiting queue.
     * Urgent patients are added to the front, others to the back.
     */
    public void addPatientToQueue() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

        boolean isUrgent = false;
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Is " + name + " urgent? (yes/no): ");
            String urgentInput = scanner.nextLine().trim().toLowerCase();
            if (urgentInput.equals("yes")) {
                isUrgent = true;
                validInput = true;
            } else if (urgentInput.equals("no")) {
                isUrgent = false;
                validInput = true;
            } else {
                System.err.println("Error: Invalid input. Please enter 'yes' or 'no'.");
            }
        }

        Patient newPatient = new Patient(name, isUrgent);

        // Using LinkedList methods for specific queue behavior
        if (isUrgent) {
            // Cast to LinkedList to access addFirst for urgent patients
            ((LinkedList<Patient>) waitingQueue).addFirst(newPatient);
            System.out.println("Patient " + newPatient.getName() + " (ID: " + newPatient.getId() + ") added to the front of the waiting queue.");
        } else {
            waitingQueue.offer(newPatient); // offer is standard Queue method
            System.out.println("Patient " + newPatient.getName() + " (ID: " + newPatient.getId() + ") added to the waiting queue.");
        }
    }

    /**
     * Schedules the next patient from the waiting queue to the first available slot.
     */
    public void scheduleNextPatient() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting queue is empty. No patients to schedule.");
            return;
        }

        if (availableTimeSlots.isEmpty()) {
            System.err.println("Error: No time slots available for scheduling.");
            // Optionally, could put the patient back if already polled, but requirement implies check before polling.
            return;
        }

        // Get the next patient without removing yet, in case scheduling fails
        Patient patientToSchedule = waitingQueue.peek();
        String scheduledSlot = null;

        // Find the first available slot
        if (!availableTimeSlots.isEmpty()) {
             scheduledSlot = availableTimeSlots.get(0); // Get the first available slot
        }

        if (scheduledSlot != null) {
            // Slot found, now poll the patient
            patientToSchedule = waitingQueue.poll();
            Appointment newAppointment = new Appointment(patientToSchedule, scheduledSlot);
            scheduledAppointments.add(newAppointment);
            availableTimeSlots.remove(0); // Remove the used slot

            System.out.println("Scheduled appointment for " + patientToSchedule.getName() + " (ID: " + patientToSchedule.getId() + ") at " + scheduledSlot + ".");
        } else {
             // This case should ideally not be reached if availableTimeSlots.isEmpty() check is done first,
             // but as a safeguard:
             System.err.println("Error: Could not find an available time slot.");
             // If patient was already polled, return them to the front:
             // ((LinkedList<Patient>) waitingQueue).addFirst(patientToSchedule); // Requires polling first
        }
    }

    /**
     * Displays all patients currently in the waiting queue.
     */
    public void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Patient patient : waitingQueue) {
                System.out.println(patient);
            }
        }
    }

    /**
     * Displays all scheduled appointments.
     */
    public void viewScheduledAppointments() {
        System.out.println("--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments are currently scheduled.");
        } else {
            // Iterate through the list
            for (Appointment appt : scheduledAppointments) {
                System.out.println(appt);
            }
        }
    }

    /**
     * Cancels an appointment based on the time slot.
     * Makes the time slot available again.
     */
    public void cancelAppointment() {
        System.out.print("Enter time slot of appointment to cancel (e.g., 09:00): ");
        String timeSlotToCancel = scanner.nextLine().trim();

        Appointment foundAppointment = null;
        // Find the appointment by time slot
        for (Appointment appt : scheduledAppointments) {
            if (appt.getTimeSlot().equals(timeSlotToCancel)) {
                foundAppointment = appt;
                break; // Found it, exit loop
            }
        }

        if (foundAppointment != null) {
            scheduledAppointments.remove(foundAppointment); // Remove from scheduled list
            availableTimeSlots.add(timeSlotToCancel); // Add slot back to available list
            Collections.sort(availableTimeSlots); // Keep slots sorted

            System.out.println("Appointment at " + timeSlotToCancel + " for " + foundAppointment.getPatient().getName() + " (ID: " + foundAppointment.getPatient().getId() + ") cancelled. Slot " + timeSlotToCancel + " is now available.");
        } else {
            System.err.println("Error: No appointment found for time slot " + timeSlotToCancel + ".");
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Scheduler Menu ---");
        System.out.println("1. Add Patient to Queue");
        System.out.println("2. Schedule Next Patient");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Scheduled Appointments");
        System.out.println("5. Cancel Appointment");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu selection.
     */
    public void run() {
        int choice = -1;
        // Class-wide try-catch wrapping the main application loop
        try {
            while (choice != 6) {
                displayMenu();

                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 6.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop and show menu again
                    continue; // Skip the switch and go to the next iteration
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addPatientToQueue();
                        break;
                    case 2:
                        scheduleNextPatient();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewScheduledAppointments();
                        break;
                    case 5:
                        cancelAppointment();
                        break;
                    case 6:
                        System.out.println("Exiting Hospital Scheduler. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
            System.err.println("The program will now exit.");
        } finally {
            // Ensure the scanner is closed when the program ends
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
