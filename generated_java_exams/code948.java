/*
 * Exam Question #948
 * Generated on: 2025-05-12 17:03:54
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Support Ticket Management System
 * 
 * **Objective:** Design and implement a simplified support ticket management system that allows users (simulating support agents) to add new tickets, process the next pending ticket, and view tickets. This task requires the application of various core Java concepts and data structures.
 * 
 * **Scenario:**
 * 
 * You are building the backend logic for a basic support system. When a customer issue is reported, a new support ticket is created and added to a queue of pending issues. Support agents process tickets from this queue in the order they were received (First-In, First-Out). The system also needs to maintain a complete record of all tickets ever created, regardless of their status.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the *pending* support tickets.
 *     *   Use a `java.util.List` (specifically, its implementation `java.util.ArrayList`) to maintain a record of *all* tickets ever created (both pending and resolved).
 * 
 * 2.  **Ticket Class:**
 *     *   Create a `Ticket` class with the following private fields:
 *         *   `id` (int): A unique identifier for the ticket.
 *         *   `description` (String): A brief description of the issue.
 *         *   `status` (enum `TicketStatus`): The current status of the ticket (e.g., `PENDING`, `RESOLVED`).
 *     *   Include a constructor, public getter methods for all fields, and a method to update the status (e.g., `resolve()`).
 *     *   Override the `toString()` method to provide a clear representation of the ticket.
 * 
 * 3.  **TicketStatus Enum:**
 *     *   Create an enum `TicketStatus` with at least two states: `PENDING` and `RESOLVED`.
 * 
 * 4.  **SupportSystem Class:**
 *     *   Create a `SupportSystem` class that encapsulates the `Queue` of pending tickets and the `List` of all tickets. These data structures must be private fields.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `Ticket` with a unique ID, adds it to both the pending queue and the list of all tickets.
 *         *   `processNextTicket()`: Removes the next ticket from the pending queue (if any), updates its status to `RESOLVED` in the list of all tickets, and prints a success message. If the queue is empty, print an appropriate error message.
 *         *   `viewPendingTickets()`: Prints the details of all tickets currently in the pending queue.
 *         *   `viewResolvedTickets()`: Prints the details of all tickets in the list of all tickets that have a status of `RESOLVED`.
 *         *   `viewAllTickets()`: Prints the details of all tickets in the list of all tickets, regardless of status.
 * 
 * 5.  **Main Application Logic:**
 *     *   In the `main` method of a separate class (e.g., `SupportApp`), create an instance of `SupportSystem`.
 *     *   Use `java.util.Scanner` to interact with the user via a command-line menu.
 *     *   The menu should offer options to:
 *         *   Add a new ticket.
 *         *   Process the next pending ticket.
 *         *   View pending tickets.
 *         *   View resolved tickets.
 *         *   View all tickets.
 *         *   Exit the application.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for normal output (menu, prompts, success messages, ticket details).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, attempting to process a ticket when none are pending).
 * 
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle potential issues, such as the user entering non-numeric input for the menu choice (`InputMismatchException`). Include a general `catch` block for unexpected errors.
 * 
 * 7.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement basic input validation (e.g., handle empty ticket description, although the prompt doesn't explicitly require *throwing* an exception for this, just adding a check is good). The primary validation focus is on menu input and attempting to process an empty queue.
 *     *   Ensure proper resource management (close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors. Example interaction:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. View All Tickets
 * 0. Exit
 * ----------------------------------
 * Enter your choice: 1
 * Enter ticket description: My internet is down
 * 
 * Ticket added successfully. ID: 1
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Cannot log in
 * 
 * Ticket added successfully. ID: 2
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: My internet is down, Status: PENDING
 * Ticket ID: 2, Description: Cannot log in, Status: PENDING
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processing ticket ID: 1 - My internet is down
 * 
 * Ticket ID 1 resolved successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket ID: 2, Description: Cannot log in, Status: PENDING
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Resolved Tickets ---
 * Ticket ID: 1, Description: My internet is down, Status: RESOLVED
 * --------------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- All Tickets ---
 * Ticket ID: 1, Description: My internet is down, Status: RESOLVED
 * Ticket ID: 2, Description: Cannot log in, Status: PENDING
 * -------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 9
 * 
 * Error: Invalid menu choice. Please try again.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processing ticket ID: 2 - Cannot log in
 * 
 * Ticket ID 2 resolved successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Error: No pending tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 0
 * 
 * Exiting Support Ticket System.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`TicketStatus.java`, `Ticket.java`, `SupportSystem.java`, `SupportApp.java` or combined into one file for the exam). Ensure the code compiles and runs according to the requirements.
 *
 * EXPLANATION:
 * The solution implements a basic Support Ticket Management System using the required Java components and best practices.
 * 
 * 1.  **`TicketStatus` Enum:** A simple enum is used to represent the distinct states a ticket can be in (`PENDING` or `RESOLVED`), providing type safety and readability compared to using plain integers or strings for status.
 * 
 * 2.  **`Ticket` Class:** This class models a single support ticket.
 *     *   It uses `private` fields (`id`, `description`, `status`) to enforce encapsulation.
 *     *   The constructor initializes a new ticket with a given ID and description, defaulting the status to `PENDING`.
 *     *   Public getter methods provide controlled access to the ticket's data.
 *     *   The `resolve()` method is a specific public method to change the ticket's status, demonstrating a controlled state transition.
 *     *   `toString()` is overridden for easy printing of ticket details.
 * 
 * 3.  **`SupportSystem` Class:** This is the core class managing the tickets.
 *     *   It has two `private` data structure fields: `pendingTickets` (declared as `Queue<Ticket>`) and `allTickets` (declared as `List<Ticket>`).
 *     *   Crucially, both are instantiated using a single `LinkedList` object (`LinkedList<Ticket> ticketStorage`). `LinkedList` implements both the `Queue` and `List` interfaces. This allows the *same collection* of `Ticket` objects to be viewed and manipulated in two different ways:
 *         *   `pendingTickets` uses `Queue` methods (`offer`, `poll`, `peek`) to manage the FIFO processing of tickets.
 *         *   `allTickets` uses `List` methods (`add`, iteration) to keep a complete, ordered record of every ticket ever added.
 *     *   `nextTicketId` is a private counter to ensure each new ticket gets a unique ID.
 *     *   **`addTicket(String description)`:** Creates a `Ticket` object, adds it to the end of the `pendingTickets` queue using `offer()`, and also adds it to the `allTickets` list using `add()`. Includes basic validation for the description.
 *     *   **`processNextTicket()`:** Checks if the `pendingTickets` queue is empty using `isEmpty()`. If not, it removes the head of the queue using `poll()`. Since the removed ticket object is the *same* object reference that's also in the `allTickets` list, calling `ticketToProcess.resolve()` updates its status in *both* views (queue and list, although it's immediately removed from the queue view). Prints an error to `System.err` if the queue is empty.
 *     *   **`viewPendingTickets()`:** Iterates through the `pendingTickets` queue. Because `LinkedList` (used for the queue) is also `Iterable`, a simple enhanced for loop works to view elements without removing them.
 *     *   **`viewResolvedTickets()`:** Iterates through the `allTickets` list and checks the status of each ticket, printing only those that are `RESOLVED`.
 *     *   **`viewAllTickets()`:** Iterates through the `allTickets` list and prints every ticket.
 *     *   All methods use `System.out` for normal output and `System.err` for error messages as required.
 * 
 * 4.  **`SupportApp` Class (`main` method):** This class contains the application entry point and user interaction logic.
 *     *   It creates an instance of `SupportSystem`.
 *     *   A `Scanner` is used for reading user input. A `try-with-resources` block ensures the `Scanner` is properly closed when the application finishes or an error occurs.
 *     *   A `while` loop keeps the application running until the user chooses to exit (option 0).
 *     *   The `printMenu()` method displays the available options using `System.out`.
 *     *   A `try-catch` block wraps the core input reading and `switch` logic.
 *         *   It specifically catches `InputMismatchException` which occurs if the user enters non-numeric input when an integer is expected (`scanner.nextInt()`). The `catch` block prints an error to `System.err` and consumes the invalid input (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   A general `catch (Exception e)` block is included as a fallback for any other unexpected runtime errors, demonstrating robust error handling. It prints an error message to `System.err` and the stack trace for debugging.
 *     *   A `switch` statement handles the user's valid numeric input, calling the appropriate `SupportSystem` methods.
 *     *   The `default` case in the `switch` handles invalid *numeric* choices, printing an error to `System.err`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (via `LinkedList` implementing `List`), `List` interface, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical scenario, following best practices like encapsulation, meaningful naming, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements both List and Queue, convenient here
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Ticket Status
enum TicketStatus {
    PENDING,
    RESOLVED
}

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.PENDING; // New tickets are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    /**
     * Marks the ticket as resolved.
     */
    public void resolve() {
        this.status = TicketStatus.RESOLVED;
    }

    /**
     * Provides a string representation of the ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: %s, Status: %s",
                             id, description, status);
    }
}

// Manages the collection of support tickets
class SupportSystem {
    // Use LinkedList as it implements both Queue and List, allowing easy access
    // to both queue operations (for pending) and list operations (for all)
    private Queue<Ticket> pendingTickets;
    private List<Ticket> allTickets; // Use List interface, implemented by LinkedList

    private int nextTicketId; // Counter for unique ticket IDs

    /**
     * Constructs a new SupportSystem.
     */
    public SupportSystem() {
        // Initialize both Queue and List using the same LinkedList instance
        // This works because pendingTickets will only use Queue methods (offer, poll, peek)
        // and allTickets will use List methods (add, get, iterate)
        LinkedList<Ticket> ticketStorage = new LinkedList<>();
        this.pendingTickets = ticketStorage; // Queue view
        this.allTickets = ticketStorage;     // List view

        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the system.
     * @param description The description of the issue.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.offer(newTicket); // Add to the end of the pending queue
        allTickets.add(newTicket);      // Add to the list of all tickets
        System.out.println("\nTicket added successfully. ID: " + newTicket.getId());
    }

    /**
     * Processes the next ticket in the pending queue.
     */
    public void processNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("\nError: No pending tickets to process.");
            return;
        }

        // Get and remove the ticket from the front of the queue
        Ticket ticketToProcess = pendingTickets.poll();

        // Update the status of the ticket (it's already in the allTickets list)
        ticketToProcess.resolve();

        System.out.println("\nProcessing ticket ID: " + ticketToProcess.getId() + " - " + ticketToProcess.getDescription());
        System.out.println("Ticket ID " + ticketToProcess.getId() + " resolved successfully.");
    }

    /**
     * Views all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets are pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Views all tickets that have been resolved.
     */
    public void viewResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
        boolean foundResolved = false;
        // Iterate through the list of all tickets and check status
        for (Ticket ticket : allTickets) {
            if (ticket.getStatus() == TicketStatus.RESOLVED) {
                System.out.println(ticket);
                foundResolved = true;
            }
        }
        if (!foundResolved) {
            System.out.println("No tickets have been resolved yet.");
        }
        System.out.println("--------------------------");
    }

    /**
     * Views all tickets in the system, regardless of status.
     */
    public void viewAllTickets() {
        System.out.println("\n--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets in the system.");
        } else {
            // Iterate through the list of all tickets
            for (Ticket ticket : allTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------");
    }
}

// Main application class
public class SupportApp {

    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();

        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1; // Default choice to enter the loop

            while (choice != 0) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer input
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            system.addTicket(description);
                            break;
                        case 2:
                            system.processNextTicket();
                            break;
                        case 3:
                            system.viewPendingTickets();
                            break;
                        case 4:
                            system.viewResolvedTickets();
                            break;
                        case 5:
                            system.viewAllTickets();
                            break;
                        case 0:
                            System.out.println("\nExiting Support Ticket System.");
                            break;
                        default:
                            System.err.println("\nError: Invalid menu choice. Please try again.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("\nError: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in the loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("\nAn unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                    choice = 0; // Exit on unexpected error
                }
                System.out.println(); // Add a blank line for better readability
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. View All Tickets");
        System.out.println("0. Exit");
        System.out.println("----------------------------------");
    }
}
