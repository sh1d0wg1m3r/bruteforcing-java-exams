/*
 * Exam Question #360
 * Generated on: 2025-05-11 23:00:15
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** Priority Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based Priority Task Management System. This system will handle incoming requests, triage them into prioritized tasks, and allow processing of the highest-priority pending tasks.
 * 
 * The system operates in two stages:
 * 1.  **Incoming Requests:** New requests are added to an incoming queue.
 * 2.  **Active Tasks:** Requests are moved from the incoming queue to an active task list during a "triage" process, where they are assigned a priority. Tasks in the active list are then processed based on their priority.
 * 
 * Your implementation must demonstrate a strong understanding of core Java data structures, control flow, user input handling, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `Priority` enum: Define priority levels (e.g., HIGH, MEDIUM, LOW).
 *     *   `Status` enum: Define task statuses (PENDING, COMPLETED).
 *     *   `IncomingRequest` class: Represents a request entering the system. Should have a unique ID and a description.
 *     *   `Task` class: Represents an active task. Should have a unique ID, description, assigned `Priority`, and current `Status`.
 *     *   `TaskManager` class: Manages the collections of requests and tasks and provides the system's functionality.
 *     *   `Main` class: Contains the `main` method to run the application, handle user interaction, and manage the `TaskManager`.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<IncomingRequest>` to store incoming requests.
 *     *   Use a `java.util.List<Task>` (implemented as `java.util.ArrayList`) to store active tasks.
 * 
 * 3.  **Functionality:** Implement the following commands via user input in the `Main` class:
 *     *   `add <description>`: Creates a new `IncomingRequest` with the given description and adds it to the incoming queue.
 *     *   `triage <priority>`: Takes the next request from the incoming queue, prompts the user for a priority (using the provided `<priority>` argument, e.g., "HIGH", "MEDIUM", "LOW"), creates a `Task` with this priority, and adds it to the active tasks list. Handles cases where the queue is empty or the priority input is invalid.
 *     *   `process`: Finds the highest-priority *pending* task in the active tasks list and marks its status as `COMPLETED`. Priority order: HIGH > MEDIUM > LOW. If multiple tasks have the same highest priority, process the one that was added to the active list earliest (simple iteration order is acceptable for ties). Handles cases where there are no active tasks or no pending tasks.
 *     *   `list`: Displays all active tasks (ID, Description, Priority, Status).
 *     *   `list incoming`: Displays all incoming requests (ID, Description).
 *     *   `exit`: Terminates the application.
 * 
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands and arguments from the console.
 *     *   Use `System.out` for all normal output (prompts, success messages, list displays).
 *     *   Use `System.err` for all error messages (e.g., invalid command, invalid priority, queue empty, no tasks to process).
 * 
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement in the `Main` class to handle the different user commands.
 * 
 * 6.  **Error Handling:**
 *     *   Implement robust input validation (e.g., checking if priority string is valid during triage).
 *     *   Handle scenarios where operations cannot be performed (e.g., triaging from an empty queue, processing when no pending tasks exist).
 *     *   Implement class-wide exception handling using `try-catch` blocks. A single `try-catch (Exception e)` block around the main application loop in `main` is sufficient for this requirement, catching unexpected errors. Specific error conditions (like empty queue) should be handled gracefully with `System.err` messages *without* throwing exceptions unless truly unexpected.
 * 
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful names for classes, methods, variables, and enums.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 *     *   Close the `Scanner` resource properly.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Enter command (add, triage, process, list, list incoming, exit): add Fix database connection
 * Incoming request added with ID: 1
 * Enter command (add, triage, process, list, list incoming, exit): add Update documentation
 * Incoming request added with ID: 2
 * Enter command (add, triage, process, list, list incoming, exit): list incoming
 * Incoming Requests:
 * [ID: 1, Description: Fix database connection]
 * [ID: 2, Description: Update documentation]
 * Enter command (add, triage, list, list incoming, exit): triage HIGH
 * Request ID 1 triaged to Task ID 1 with Priority: HIGH
 * Enter command (add, triage, list, list incoming, exit): triage LOW
 * Request ID 2 triaged to Task ID 2 with Priority: LOW
 * Enter command (add, triage, list, list incoming, exit): list
 * Active Tasks:
 * [ID: 1, Description: Fix database connection, Priority: HIGH, Status: PENDING]
 * [ID: 2, Description: Update documentation, Priority: LOW, Status: PENDING]
 * Enter command (add, triage, list, list incoming, exit): process
 * Processing Task ID: 1 (Fix database connection)
 * Task ID 1 marked as COMPLETED.
 * Enter command (add, triage, list, list incoming, exit): list
 * Active Tasks:
 * [ID: 1, Description: Fix database connection, Priority: HIGH, Status: COMPLETED]
 * [ID: 2, Description: Update documentation, Priority: LOW, Status: PENDING]
 * Enter command (add, triage, list, list incoming, exit): process
 * Processing Task ID: 2 (Update documentation)
 * Task ID 2 marked as COMPLETED.
 * Enter command (add, triage, list, list incoming, exit): process
 * System.err: No pending tasks found to process.
 * Enter command (add, triage, list, list incoming, exit): exit
 * Exiting Task Management System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of functionality.
 * *   Adherence to all specified requirements (use of all required components).
 * *   Proper implementation of data structures and algorithms.
 * *   Robustness of error handling and input validation.
 * *   Quality of code structure, encapsulation, naming, and comments.
 * 
 * **Deliverable:** A single Java source file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements the Priority Task Management System as described in the exam question, fulfilling all requirements and demonstrating the specified Java concepts.
 * 
 * **Structure:**
 * The system is organized into several classes and enums:
 * *   `Priority` and `Status` enums define the possible states for tasks.
 * *   `IncomingRequest` and `Task` classes represent the data entities, using private fields for encapsulation and public getters/setters (where necessary, like for `Status`).
 * *   `TaskManager` is the core logic class, holding the data structures and implementing the operations.
 * *   `Main` provides the command-line interface, handles user input, and orchestrates calls to `TaskManager`.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`Queue (java.util.Queue)`:**
 *     *   A `java.util.Queue<IncomingRequest>` named `incomingRequests` is used in the `TaskManager`.
 *     *   It is implemented using `java.util.LinkedList`, which is a common `Queue` implementation.
 *     *   `addIncomingRequest` uses `queue.add()` to add new requests (FIFO).
 *     *   `triageNextRequest` uses `queue.poll()` to retrieve and remove the next request from the head of the queue.
 * 
 * 2.  **`ArrayList (java.util.ArrayList)`:**
 *     *   The collection of active tasks is implemented using `new ArrayList<>()`.
 * 
 * 3.  **`List interface (java.util.List)`:**
 *     *   The active tasks collection is declared using the `List` interface: `private List<Task> activeTasks;`. This promotes coding to interfaces, which is a good practice.
 * 
 * 4.  **`Scanner for user input (java.util.Scanner)`:**
 *     *   A `Scanner` is used in the `Main` class to read commands and arguments from `System.in`.
 *     *   `scanner.nextLine()` reads the entire line of input.
 *     *   The scanner is closed in a `finally` block to release the system resource.
 * 
 * 5.  **`Switch statement for flow control`:**
 *     *   The `Main` class uses a `switch` statement on the command string (`parts[0].toLowerCase()`) to determine which action to perform based on user input.
 * 
 * 6.  **`System.err for error messages`:**
 *     *   `System.err.println()` is used throughout the code (primarily in `TaskManager` and `Main`) to output error messages for invalid commands, missing arguments, empty queues/lists, invalid input (like priority), etc.
 * 
 * 7.  **`System.out for normal output`:**
 *     *   `System.out.println()` is used for prompts, success messages, and displaying the lists of tasks and requests.
 * 
 * 8.  **`Class-wide exception handling with try-catch blocks`:**
 *     *   A `try-catch (Exception e)` block is placed around the main `while(running)` loop in the `main` method. This provides a top-level catch-all for any unexpected runtime exceptions that might occur during the program's execution, printing a generic error message using `System.err` before the program terminates or attempts the next loop iteration. Specific, expected error conditions (like an empty queue) are handled gracefully within the methods using `if` checks and `System.err` without necessarily throwing exceptions.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Class fields (`id`, `description`, `priority`, `status`, collections, counters) are `private`. Access is provided through public methods (constructors, getters, and a specific setter for status).
 * *   **Meaningful Names:** Class names (`TaskManager`, `IncomingRequest`, `Task`), enum names (`Priority`, `Status`), method names (`addIncomingRequest`, `triageNextRequest`, `processHighestPriorityTask`, `listAllTasks`, `listIncomingRequests`), and variable names (`incomingRequests`, `activeTasks`, `nextRequestId`, `taskToProcess`) are descriptive.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and public methods explaining their purpose. Inline comments clarify specific logic where needed.
 * *   **Input Validation:** The `triageNextRequest` method validates the provided priority string using the `Priority.fromString` helper method. The `Main` class checks for missing arguments for `add` and `triage` commands and validates the argument for the `list` command.
 * *   **Proper Error Handling:** Specific error conditions (empty queue/list, no pending tasks) are checked and reported to `System.err` with informative messages. Invalid priority input is handled.
 * *   **Clean Code Structure:** The code is divided into logical classes, methods are kept relatively focused, and the `main` method clearly handles user interaction and command dispatching.
 * 
 * **Priority Processing Logic:**
 * The `processHighestPriorityTask` method iterates through the `activeTasks` list. It searches for the first `PENDING` task. It keeps track of the highest priority encountered so far (`highestPriorityFound`) and the corresponding task (`taskToProcess`). The `compareTo` method of the `Priority` enum is used to compare priorities (enum constants are ordered by declaration order, so `HIGH.compareTo(MEDIUM)` is negative, indicating HIGH is "less than" MEDIUM in enum order, which we invert or use `task.getPriority().compareTo(highestPriorityFound) < 0` to find the *highest* priority according to our desired order HIGH > MEDIUM > LOW). Once the iteration is complete, if a pending task was found, it's marked as `COMPLETED`.
 * 
 * This solution effectively combines the required data structures and control flow mechanisms to build a functional system, addressing the complexity through object-oriented design and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // To handle case-insensitive priority input

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW;

    /**
     * Converts a string to a Priority enum, case-insensitive.
     * @param priorityString The string to convert.
     * @return The corresponding Priority enum, or null if invalid.
     */
    public static Priority fromString(String priorityString) {
        if (priorityString == null) {
            return null;
        }
        try {
            return Priority.valueOf(priorityString.toUpperCase(Locale.US));
        } catch (IllegalArgumentException e) {
            return null; // Not a valid priority string
        }
    }
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

// Represents an incoming request before triage
class IncomingRequest {
    private int id;
    private String description;

    /**
     * Constructs an IncomingRequest.
     * @param id The unique ID for the request.
     * @param description The description of the request.
     */
    public IncomingRequest(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Description: " + description + "]";
    }
}

// Represents a task after triage with assigned priority
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The assigned priority.
     */
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setters (only for status change) ---
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Description: " + description + ", Priority: " + priority + ", Status: " + status + "]";
    }
}

// Manages the collection of incoming requests and active tasks
class TaskManager {
    private Queue<IncomingRequest> incomingRequests;
    private List<Task> activeTasks; // Using List interface, implemented by ArrayList
    private int nextRequestId;
    private int nextTaskId;

    /**
     * Constructs a TaskManager.
     */
    public TaskManager() {
        this.incomingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.activeTasks = new ArrayList<>(); // ArrayList implements List
        this.nextRequestId = 1;
        this.nextTaskId = 1;
    }

    /**
     * Adds a new incoming request to the queue.
     * @param description The description of the request.
     */
    public void addIncomingRequest(String description) {
        IncomingRequest request = new IncomingRequest(nextRequestId++, description);
        incomingRequests.add(request); // Add to the queue
        System.out.println("Incoming request added with ID: " + request.getId());
    }

    /**
     * Triages the next incoming request, converting it to a Task with specified priority.
     * @param priorityString The priority string (e.g., "HIGH") for the new task.
     */
    public void triageNextRequest(String priorityString) {
        IncomingRequest nextRequest = incomingRequests.poll(); // Get and remove from queue

        if (nextRequest == null) {
            System.err.println("Error: No incoming requests to triage.");
            return;
        }

        Priority priority = Priority.fromString(priorityString);
        if (priority == null) {
            // Put the request back if priority is invalid? Or discard? Let's discard for simplicity
            // incomingRequests.add(nextRequest); // Option to put back
            System.err.println("Error: Invalid priority '" + priorityString + "'. Request ID " + nextRequest.getId() + " not triaged.");
            return;
        }

        Task newTask = new Task(nextTaskId++, nextRequest.getDescription(), priority);
        activeTasks.add(newTask); // Add to the list
        System.out.println("Request ID " + nextRequest.getId() + " triaged to Task ID " + newTask.getId() + " with Priority: " + priority);
    }

    /**
     * Finds and processes the highest-priority pending task.
     */
    public void processHighestPriorityTask() {
        if (activeTasks.isEmpty()) {
            System.err.println("Error: No active tasks to process.");
            return;
        }

        Task taskToProcess = null;
        Priority highestPriorityFound = null;

        // Iterate through active tasks to find the highest priority PENDING task
        for (Task task : activeTasks) {
            if (task.getStatus() == Status.PENDING) {
                if (taskToProcess == null || task.getPriority().compareTo(highestPriorityFound) < 0) {
                    // This task has a higher priority than the current highest found
                    taskToProcess = task;
                    highestPriorityFound = task.getPriority();
                }
            }
        }

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks found to process.");
        } else {
            System.out.println("Processing Task ID: " + taskToProcess.getId() + " (" + taskToProcess.getDescription() + ")");
            taskToProcess.setStatus(Status.COMPLETED);
            System.out.println("Task ID " + taskToProcess.getId() + " marked as COMPLETED.");
        }
    }

    /**
     * Displays all active tasks.
     */
    public void listAllTasks() {
        if (activeTasks.isEmpty()) {
            System.out.println("No active tasks.");
            return;
        }
        System.out.println("Active Tasks:");
        for (Task task : activeTasks) {
            System.out.println(task);
        }
    }

    /**
     * Displays all incoming requests in the queue.
     */
    public void listIncomingRequests() {
        if (incomingRequests.isEmpty()) {
            System.out.println("No incoming requests.");
            return;
        }
        System.out.println("Incoming Requests:");
        // Iterating over a Queue is generally safe for just viewing elements
        for (IncomingRequest request : incomingRequests) {
            System.out.println(request);
        }
    }
}

// Main application class
public class Main {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for unexpected errors
        try {
            System.out.println("Priority Task Management System");

            while (running) {
                System.out.print("\nEnter command (add, triage, process, list, list incoming, exit): ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Ignore empty lines
                }

                // Split command and arguments
                String[] parts = inputLine.split(" ", 2);
                String command = parts[0].toLowerCase(Locale.US);
                String argument = parts.length > 1 ? parts[1].trim() : "";

                // Use switch for flow control
                switch (command) {
                    case "add":
                        if (argument.isEmpty()) {
                            System.err.println("Error: 'add' command requires a description.");
                        } else {
                            taskManager.addIncomingRequest(argument);
                        }
                        break;

                    case "triage":
                        if (argument.isEmpty()) {
                            System.err.println("Error: 'triage' command requires a priority (HIGH, MEDIUM, LOW).");
                        } else {
                            taskManager.triageNextRequest(argument);
                        }
                        break;

                    case "process":
                        taskManager.processHighestPriorityTask();
                        break;

                    case "list":
                        if (argument.isEmpty()) {
                            taskManager.listAllTasks();
                        } else if (argument.equals("incoming")) {
                            taskManager.listIncomingRequests();
                        } else {
                            System.err.println("Error: Invalid 'list' argument. Use 'list' or 'list incoming'.");
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging details
        } finally {
            // Ensure scanner is closed regardless of how the program exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
