/*
 * Exam Question #1047
 * Generated on: 2025-05-12 17:17:26
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a manufacturing production line. The line processes tasks one by one from an incoming queue. Once a task is completed, the resulting item is added to a list of finished goods. The system should allow a supervisor to interact with the production line through a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Maintain a queue of incoming tasks waiting to be processed. Each task can be represented by a simple `String` (e.g., "Assemble Unit A", "Paint Component B").
 *     *   Maintain a list of completed items. Each completed item can also be represented by a `String` (e.g., "Completed Unit A", "Completed Component B").
 * 2.  **Functionality:**
 *     *   **Add Task:** Allow the user to add a new task description to the end of the incoming task queue.
 *     *   **Process Task:** Take the next task from the front of the queue, simulate processing (print a message), and add a corresponding "Completed: [task description]" string to the list of completed items.
 *     *   **View Status:** Display the current number of tasks waiting in the queue and list all completed items.
 *     *   **Exit:** Terminate the simulation.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from standard input.
 *     *   Implement a command loop that repeatedly prompts the user for input until the "exit" command is given.
 *     *   Recognize commands like "add", "process", "status", "exit".
 *     *   Use a `switch` statement to handle the different user commands.
 * 4.  **Input Validation and Error Handling:**
 *     *   If the user tries to "add" a task with an empty description, print an error message to `System.err`.
 *     *   If the user tries to "process" a task when the queue is empty, print an error message to `System.err`.
 *     *   If the user enters an unknown command, print an error message to `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential unexpected runtime errors during the simulation loop. Print a general error message to `System.err` if an exception occurs.
 *     *   Use `System.out` for all normal output (prompts, status updates, successful operations).
 * 5.  **Java Concepts:**
 *     *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * 6.  **Best Practices:**
 *     *   Use appropriate data types and meaningful variable/method names.
 *     *   Structure your code logically within a single class for this exam task.
 *     *   Add comments where necessary to explain complex parts.
 *     *   Ensure proper encapsulation for the data structures (make them private).
 * 
 * **Expected Output (Example Interaction):**
 * 
 * ```
 * Production Line Simulator
 * Enter command (add, process, status, exit): add
 * Enter task description: Assemble Unit A
 * Task "Assemble Unit A" added to queue.
 * Enter command (add, process, status, exit): add
 * Enter task description: Paint Component B
 * Task "Paint Component B" added to queue.
 * Enter command (add, process, status, exit): status
 * Queue size: 2
 * Completed Items:
 * Enter command (add, process, status, exit): process
 * Processing task: Assemble Unit A
 * Item "Completed: Assemble Unit A" added to completed list.
 * Enter command (add, process, status, exit): status
 * Queue size: 1
 * Completed Items:
 * - Completed: Assemble Unit A
 * Enter command (add, process, status, exit): process
 * Processing task: Paint Component B
 * Item "Completed: Paint Component B" added to completed list.
 * Enter command (add, process, status, exit): process
 * Error: The task queue is empty. Cannot process.
 * Enter command (add, process, status, exit): status
 * Queue size: 0
 * Completed Items:
 * - Completed: Assemble Unit A
 * - Completed: Paint Component B
 * Enter command (add, process, status, exit): invalid_command
 * Error: Unknown command. Please use add, process, status, or exit.
 * Enter command (add, process, status, exit): exit
 * Exiting simulator.
 * ```
 * 
 * Implement the `ProductionLineSimulator` class to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements a `ProductionLineSimulator` class that manages a queue of tasks and a list of completed items, interacting with the user via the console.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The core data structures (`taskQueue`, `completedItems`, `scanner`) are declared as private instance variables, demonstrating encapsulation.
 *     *   Public methods (`start`, `main`) provide the entry points and control flow, while private methods (`addTask`, `processNextTask`, `viewStatus`) handle specific operations, hiding internal details.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `taskQueue` is declared as a `Queue<String>` and initialized with a `LinkedList`. `LinkedList` is commonly used as a `Queue` implementation. Methods like `offer()` (to add to the end) and `poll()` (to remove from the front) are used, demonstrating typical queue operations.
 *     *   `java.util.ArrayList`: The `completedItems` is initialized as an `ArrayList<String>`.
 *     *   `java.util.List`: The `completedItems` variable is declared using the `List` interface type, promoting good practice of programming to interfaces.
 *     *   `java.util.Scanner`: A `Scanner` object reads user input from `System.in`. It's closed in the `finally` block to release system resources.
 *     *   `switch`: The main command loop uses a `switch` statement to efficiently dispatch execution based on the user's input command string.
 *     *   `System.err`: Used specifically for printing error messages related to invalid input (empty task description, empty queue processing) or unknown commands.
 *     *   `System.out`: Used for all standard output, including prompts, confirmation messages, and the status display.
 *     *   `try-catch`: A `try-catch` block wraps the main command processing loop (`while (true)`). This demonstrates class-wide exception handling, catching any unexpected `Exception` that might occur during the interaction and printing an error message to `System.err`. A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop exited normally.
 * 
 * 3.  **Functionality Implementation:**
 *     *   **Add Task:** Reads a line, validates it's not empty, and uses `taskQueue.offer()` to add it.
 *     *   **Process Task:** Checks if the queue is empty (`taskQueue.isEmpty()`). If not, it uses `taskQueue.poll()` to get and remove the next task, then adds a formatted string to the `completedItems` list using `completedItems.add()`.
 *     *   **View Status:** Prints the size of the queue (`taskQueue.size()`) and iterates through the `completedItems` list to print each item.
 *     *   **Exit:** The "exit" case in the `switch` uses `return` to break out of the `start()` method, effectively ending the program.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   `addTask` checks `taskDescription.isEmpty()`.
 *     *   `processNextTask` checks `taskQueue.isEmpty()`.
 *     *   The `default` case in the `switch` handles unknown commands.
 *     *   All these specific errors use `System.err`.
 *     *   The outer `try-catch` handles any other runtime exceptions.
 * 
 * 5.  **Best Practices:**
 *     *   Variable names (`taskQueue`, `completedItems`, `scanner`, `command`, `taskDescription`) are descriptive.
 *     *   Method names (`start`, `addTask`, `processNextTask`, `viewStatus`) clearly indicate their purpose.
 *     *   Comments explain the class and methods.
 *     *   The code structure is clean and follows a standard command loop pattern.
 * 
 * This solution effectively demonstrates the required Java components and programming concepts in a practical, albeit simplified, simulation context.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Simulates a simple production line with task queue and completed items list.
 */
public class ProductionLineSimulator {

    private Queue<String> taskQueue;
    private List<String> completedItems;
    private Scanner scanner;

    /**
     * Constructor to initialize the simulator.
     */
    public ProductionLineSimulator() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedItems = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the simulation loop.
     */
    public void start() {
        System.out.println("Production Line Simulator");

        // Use try-with-resources for Scanner (requires Java 7+) or ensure close()
        // Wrapping the main loop in a try-catch for general runtime exceptions
        try {
            String command;
            while (true) {
                System.out.print("Enter command (add, process, status, exit): ");
                command = scanner.nextLine().trim().toLowerCase();

                // Use a switch statement for command handling
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "status":
                        viewStatus();
                        break;
                    case "exit":
                        System.out.println("Exiting simulator.");
                        return; // Exit the start method and thus the program
                    default:
                        // Use System.err for invalid commands
                        System.err.println("Error: Unknown command. Please use add, process, status, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Class-wide exception handling for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Optional: print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Adds a new task to the queue based on user input.
     * Performs input validation.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String taskDescription = scanner.nextLine().trim();

        // Input validation: Check if task description is empty
        if (taskDescription.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
        } else {
            taskQueue.offer(taskDescription); // Add task to the end of the queue
            System.out.println("Task \"" + taskDescription + "\" added to queue.");
        }
    }

    /**
     * Processes the next task from the queue.
     * Handles empty queue condition.
     */
    private void processNextTask() {
        // Check if the queue is empty before processing
        if (taskQueue.isEmpty()) {
            System.err.println("Error: The task queue is empty. Cannot process.");
        } else {
            String taskToProcess = taskQueue.poll(); // Get and remove task from the front
            System.out.println("Processing task: " + taskToProcess);

            String completedItem = "Completed: " + taskToProcess;
            completedItems.add(completedItem); // Add completed item to the list
            System.out.println("Item \"" + completedItem + "\" added to completed list.");
        }
    }

    /**
     * Displays the current status of the queue and completed items.
     */
    private void viewStatus() {
        System.out.println("Queue size: " + taskQueue.size());
        System.out.println("Completed Items:");

        // Iterate through the completed items list
        if (completedItems.isEmpty()) {
            System.out.println("  None.");
        } else {
            for (String item : completedItems) {
                System.out.println("  - " + item);
            }
        }
    }

    /**
     * Main method to run the simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.start();
    }
}
