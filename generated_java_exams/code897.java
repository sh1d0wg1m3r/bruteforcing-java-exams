/*
 * Exam Question #897
 * Generated on: 2025-05-12 16:56:35
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Task Management System**
 * 
 * You are tasked with developing a simple command-line based Task Management System. This system should allow users to add new tasks to a queue for processing, process the next available task from the queue, and view a history of tasks that have already been processed.
 * 
 * The system should handle user interactions through the console and manage tasks efficiently using appropriate data structures.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple class `Task` to represent a task. Each task should have a `type` (String, e.g., "PRINT", "ANALYZE", "SAVE") and `data` (String, representing the task details).
 * 2.  **Task Management Logic:** Create a class `TaskProcessor` that encapsulates the core logic.
 *     *   It must use a `java.util.Queue` to store tasks waiting to be processed.
 *     *   It must use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store the history of processed tasks.
 *     *   Implement methods to:
 *         *   Add a new task to the queue.
 *         *   Process the next task from the queue (remove it from the queue, simulate processing, and add it to the history list).
 *         *   Retrieve the list of processed tasks (history).
 * 3.  **User Interface:** Implement the main application logic in a class with a `main` method.
 *     *   Use `java.util.Scanner` to read user commands and task details from the console.
 *     *   Present a menu of options to the user: Add Task, Process Next Task, View History, Exit.
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Display appropriate messages using `System.out` for prompts, successful operations, and results (like history).
 *     *   Use `System.err` to report errors, such as invalid menu choices, attempting to process a task when the queue is empty, or invalid task input.
 * 4.  **Error Handling:** Implement robust error handling.
 *     *   Use `try-catch` blocks to handle potential exceptions, especially around user input (e.g., non-integer input for menu choice) and operations that might fail (e.g., processing an empty queue).
 *     *   Ensure graceful handling of errors and provide informative error messages using `System.err`.
 *     *   The application should not crash due to user input errors or attempts to perform invalid operations.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Validate user input where appropriate (e.g., ensure task type and data are not empty, ensure menu choice is valid).
 *     *   Structure your code clearly.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform actions based on the input.
 * *   Adding a task should confirm the task was added.
 * *   Processing a task should indicate which task was processed or report if the queue is empty.
 * *   Viewing history should list all processed tasks or indicate if the history is empty.
 * *   Invalid input or errors should result in an error message on `System.err` and the program should return to the menu.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Task Management System
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 1
 * Enter task type (e.g., PRINT): PRINT
 * Enter task data: Document.pdf
 * Task added to queue.
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 1
 * Enter task type (e.g., PRINT): ANALYZE
 * Enter task data: Data_Set_1.csv
 * Task added to queue.
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 2
 * Processing task: Type=PRINT, Data=Document.pdf
 * Task processed.
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 3
 * --- Processed Task History ---
 * 1: Type=PRINT, Data=Document.pdf
 * ------------------------------
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 2
 * Processing task: Type=ANALYZE, Data=Data_Set_1.csv
 * Task processed.
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 2
 * Error: The task queue is empty.
 * (Output on System.err)
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 3
 * --- Processed Task History ---
 * 1: Type=PRINT, Data=Document.pdf
 * 2: Type=ANALYZE, Data=Data_Set_1.csv
 * ------------------------------
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * (Output on System.err)
 * 
 * Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View History
 * 4. Exit
 * Enter your choice: 4
 * Exiting Task Management System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single unit of work with `type` and `data`.
 *     *   Uses private fields (`type`, `data`) and public getter methods (`getType`, `getData`) for proper encapsulation.
 *     *   The constructor includes basic validation to ensure type and data are not null or empty, throwing an `IllegalArgumentException` if validation fails.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the core logic of the system.
 *     *   Uses a `Queue<Task>` (`taskQueue`) implemented with `LinkedList` to hold tasks waiting for processing. `LinkedList` is a common `Queue` implementation that supports efficient adding to the end and removing from the beginning.
 *     *   Uses a `List<Task>` (`processedHistory`) implemented with `ArrayList` to store tasks after they have been processed. `ArrayList` provides efficient access to historical items by index.
 *     *   `addTask(Task task)`: Adds a task to the `taskQueue` using `offer()`, which is the preferred method for adding to a queue as it handles capacity constraints (though `LinkedList` is unbounded). Includes a null check.
 *     *   `processNextTask()`: Removes the next task from the `taskQueue` using `poll()`. `poll()` returns `null` if the queue is empty, which is handled gracefully with an error message on `System.err`. If a task is retrieved, it simulates processing (by printing) and then adds the task to the `processedHistory` list.
 *     *   `getHistory()`: Returns a *new* `ArrayList` containing the elements from `processedHistory`. This is a good practice to prevent external code from modifying the internal history list directly, maintaining encapsulation.
 *     *   `isQueueEmpty()`: A helper method to check the state of the queue.
 * 
 * 3.  **`TaskManagementSystem` Class (Main):**
 *     *   Contains the `main` method where execution begins.
 *     *   Uses `Scanner` to read user input from `System.in`.
 *     *   Creates an instance of `TaskProcessor`.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   `printMenu()`: A helper method to display the options to the user using `System.out`.
 *     *   **Input Handling and Validation:**
 *         *   A `try-catch (InputMismatchException)` block is used specifically for reading the integer menu choice to handle cases where the user enters non-numeric input. An error message is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and `scanner.nextLine()` consumes the rest of the line before the loop continues.
 *         *   `scanner.nextLine()` is used to read the task type and data to correctly capture strings that may contain spaces.
 *         *   The `Task` constructor's `IllegalArgumentException` is caught when adding a task to handle empty type/data input, printing an error to `System.err`.
 *     *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the user's valid menu choice (1, 2, 3, or 4). The `default` case handles invalid numeric choices, printing an error to `System.err`.
 *     *   **System.out and System.err:** `System.out` is used for displaying the menu, prompts, confirmation messages, and the processed history. `System.err` is used exclusively for reporting errors (invalid input, empty queue, invalid choice, exceptions).
 *     *   **Class-wide Exception Handling (`try-catch` in main):** The main `while` loop is wrapped in a `try-catch (Exception e)` block. This serves as a safety net to catch any unexpected exceptions that might occur during the program's execution and weren't handled by more specific `try-catch` blocks (like the `InputMismatchException` or `IllegalArgumentException`). It prints an error message to `System.err` and the stack trace for debugging.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to ensure the resource is released regardless of whether an exception occurred or the loop finished normally.
 * 
 * This solution effectively combines the required data structures (`Queue`, `ArrayList`, `List`), control flow (`switch`, `while`), input/output (`Scanner`, `System.out`, `System.err`), and error handling (`try-catch`, input validation) within a structured, object-oriented design following best practices like encapsulation and meaningful naming.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private String type;
    private String data;

    public Task(String type, String data) {
        // Basic input validation
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Task type cannot be null or empty.");
        }
        if (data == null || data.trim().isEmpty()) {
             throw new IllegalArgumentException("Task data cannot be null or empty.");
        }
        this.type = type.trim();
        this.data = data.trim();
    }

    public String getType() {
        return type;
    }

    public String getData() {
        return data;
    }

    @Override
    public String toString() {
        return "Type=" + type + ", Data=" + data;
    }
}

// Manages the task queue and history
class TaskProcessor {
    private Queue<Task> taskQueue;
    private List<Task> processedHistory;

    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedHistory = new ArrayList<>();
    }

    /**
     * Adds a task to the processing queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            taskQueue.offer(task); // offer is generally preferred over add in queues
            System.out.println("Task added to queue.");
        } else {
            // This case should ideally be prevented by validation in Task constructor/creation
            System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task from the queue.
     * @return The processed task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll retrieves and removes the head of the queue
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            // Simulate processing (e.g., based on task type)
            // In a real system, this would involve more complex logic
            try {
                // Simulate potential processing error for certain types if needed
                // if ("FAIL".equals(taskToProcess.getType())) {
                //     throw new RuntimeException("Simulated processing failure");
                // }
                System.out.println("Task processed.");
                processedHistory.add(taskToProcess); // Add to history upon successful (simulated) processing
                return taskToProcess;
            } catch (Exception e) {
                System.err.println("Error processing task: " + e.getMessage());
                // Decide whether to re-queue, log, etc. For this example, it's lost.
                return null; // Indicate processing failed
            }
        } else {
            System.err.println("Error: The task queue is empty.");
            return null; // Indicate no task was processed
        }
    }

    /**
     * Gets the list of tasks that have been processed.
     * @return An immutable list of processed tasks.
     */
    public List<Task> getHistory() {
        // Return a copy or an unmodifiable list to prevent external modification
        return new ArrayList<>(processedHistory); // Return a new ArrayList containing history elements
    }

    /**
     * Checks if the task queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return taskQueue.isEmpty();
    }
}

// Main class for user interaction
public class TaskManagementSystem {

    private static void printMenu() {
        System.out.println("\nTask Management System");
        System.out.println("Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View History");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor processor = new TaskProcessor();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task type (e.g., PRINT): ");
                        String type = scanner.nextLine();
                        System.out.print("Enter task data: ");
                        String data = scanner.nextLine();
                        try {
                            Task newTask = new Task(type, data);
                            processor.addTask(newTask);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        } catch (Exception e) {
                             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
                             // Log or handle other potential exceptions during Task creation/addition
                        }
                        break;

                    case 2: // Process Next Task
                        processor.processNextTask();
                        break;

                    case 3: // View History
                        List<Task> history = processor.getHistory();
                        if (history.isEmpty()) {
                            System.out.println("--- Processed Task History ---");
                            System.out.println("No tasks processed yet.");
                            System.out.println("------------------------------");
                        } else {
                            System.out.println("--- Processed Task History ---");
                            for (int i = 0; i < history.size(); i++) {
                                System.out.println((i + 1) + ": " + history.get(i));
                            }
                            System.out.println("------------------------------");
                        }
                        break;

                    case 4: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default: // Invalid Choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unhandled exceptions from the main loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }
}
