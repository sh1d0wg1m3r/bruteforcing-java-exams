/*
 * Exam Question #751
 * Generated on: 2025-05-12 16:35:33
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple Task Management System in Java. This system should allow users to add tasks to a queue, process tasks one by one from the front of the queue, and view both pending and processed tasks. The system should interact with the user through a command-line menu interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a task. It should have:
 *     *   A unique integer `id`.
 *     *   A `String` description.
 *     *   A `String` status (e.g., "Pending", "Processed").
 *     *   Appropriate private fields, a constructor, and public getter methods.
 *     *   An overridden `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a class `TaskManager` to handle the task operations. This class must:
 *     *   Use a `java.util.Queue` (specifically, an implementation like `LinkedList` is suitable, but reference it as `Queue`) to store tasks that are waiting to be processed.
 *     *   Use a `java.util.List` (specifically, an `ArrayList` implementation is suitable, but reference it as `List`) to store tasks that have been processed.
 *     *   Maintain a counter for generating unique task IDs.
 *     *   Provide a method `addTask(String description)` that creates a new task with status "Pending" and adds it to the waiting queue.
 *     *   Provide a method `processNextTask()` that removes the task at the front of the waiting queue, updates its status to "Processed", and adds it to the processed tasks list. This method must handle the case where the queue is empty.
 *     *   Provide methods `getPendingTasks()` and `getProcessedTasks()` that return the respective collections (you can return the collection directly or a copy/view).
 * 3.  **User Interface:** Implement a main application class (e.g., `TaskApp`) with a `main` method that provides a command-line menu using `java.util.Scanner`. The menu should offer the following options:
 *     *   1: Add New Task
 *     *   2: Process Next Task
 *     *   3: View Pending Tasks
 *     *   4: View Processed Tasks
 *     *   5: Exit
 * 4.  **Flow Control:** Use a `switch` statement in the main application loop to handle the user's menu choice.
 * 5.  **Input Handling & Validation:**
 *     *   Use `Scanner` to read user input (menu choice, task description).
 *     *   Validate that the menu input is an integer. If not, handle the error gracefully.
 *     *   Ensure task descriptions are not empty.
 * 6.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, specifically `InputMismatchException` when reading integer input from `Scanner`.
 *     *   If the user attempts to process a task when the queue is empty, display an appropriate error message.
 *     *   Use `System.err.println()` to display error messages (e.g., invalid input, empty queue).
 *     *   Use `System.out.println()` for all other output (menu, task details, success messages).
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Structure the code clearly into separate classes.
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * Your program should display a menu, accept input, perform actions, and display results or errors. Examples:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Complete Java Exam
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task [ID: 1, Description: Complete Java Exam, Status: Pending]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task [ID: 1, Description: Complete Java Exam, Status: Pending]
 * Task processed successfully.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * (Queue is empty)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Tasks ---
 * Task [ID: 1, Description: Complete Java Exam, Status: Processed]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * System.err: Error: Task queue is empty. Cannot process task.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * System.err: Invalid input. Please enter an integer choice.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** A basic POJO (`Plain Old Java Object`) representing a task with `id`, `description`, and `status`. It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **TaskManager Class:** This class encapsulates the core logic of the system.
 *     *   It uses a `Queue<Task>` (`LinkedList` implementation) to store tasks waiting for processing. The `offer()` method is used to add tasks, and `poll()` is used to retrieve and remove the next task, which gracefully handles an empty queue by returning `null`.
 *     *   It uses a `List<Task>` (`ArrayList` implementation) to store tasks once they are processed. Tasks are added using the `add()` method.
 *     *   The `addTask()` method creates a new `Task` object with a unique ID and adds it to the queue. It includes basic input validation for the description.
 *     *   The `processNextTask()` method demonstrates queue processing. It checks if the queue is empty using the result of `poll()`. If not empty, it updates the task's status and moves it to the processed list. Error messages for an empty queue are printed to `System.err`.
 *     *   `getPendingTasks()` and `getProcessedTasks()` provide access to the underlying collections.
 * 
 * 3.  **TaskApp Class:** This class contains the `main` method and handles user interaction.
 *     *   It initializes a `TaskManager` and a `Scanner`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, `printMenu()` displays the options using `System.out.println()`.
 *     *   A `try-catch` block is used around the code that reads the user's integer choice (`scanner.nextInt()`). This specifically catches `InputMismatchException` if the user enters non-integer input, printing an error message to `System.err` and consuming the invalid input to prevent an infinite loop. A general `catch(Exception e)` is also included as a fallback for any other unexpected runtime issues within the loop iteration, demonstrating class-wide exception handling.
 *     *   A `switch` statement is used to execute the appropriate `TaskManager` method or application logic based on the valid integer input.
 *     *   Case 1 reads the task description using `scanner.nextLine()` (important to call after `nextInt()` to consume the newline).
 *     *   Cases 3 and 4 iterate through the respective collections (`Queue` and `List`) to display task details using `System.out.println()`. Note that iterating a `Queue` using a for-each loop or iterator does *not* remove elements, which is the desired behavior for viewing pending tasks.
 *     *   Case 5 sets the `running` flag to `false` to exit the loop.
 *     *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   Finally, the `scanner.close()` method is called outside the loop to release the system resource, which is good practice.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical, menu-driven application, adhering to best practices like encapsulation and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private int id;
    private String description;
    private String status;

    // Constructor
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used by TaskManager)
    public void setStatus(String status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Task [ID: " + id + ", Description: " + description + ", Status: " + status + "]";
    }
}

// Manages the collection of tasks
class TaskManager {
    // Queue for tasks waiting to be processed
    private Queue<Task> taskQueue;
    // List for tasks that have been processed
    private List<Task> processedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    // Constructor
    public TaskManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return true if the task was added successfully, false otherwise.
     */
    public boolean addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Added task: " + newTask);
        return true;
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue, updates its status, and adds it to the processed list.
     * @return true if a task was processed, false if the queue was empty.
     */
    public boolean processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll retrieves and removes the head of the queue, returns null if empty
        if (taskToProcess == null) {
            System.err.println("Error: Task queue is empty. Cannot process task.");
            return false;
        }

        System.out.println("Processing task: " + taskToProcess);
        taskToProcess.setStatus("Processed"); // Update status
        processedTasks.add(taskToProcess); // Add to processed list
        System.out.println("Task processed successfully.");
        return true;
    }

    /**
     * Returns the queue of pending tasks.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        // Returning the direct queue allows external iteration, but modifying it externally is risky.
        // For this exam, returning the direct reference is acceptable per common practice in simple scenarios.
        return taskQueue;
    }

    /**
     * Returns the list of processed tasks.
     * @return The List of processed tasks.
     */
    public List<Task> getProcessedTasks() {
        // Returning the direct list allows external iteration and modification.
        // For this exam, returning the direct reference is acceptable.
        return processedTasks;
    }
}

// Main application class with the user interface
public class TaskApp {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Task Management System ---");

        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over after nextInt()

                // Using switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;

                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        Queue<Task> pending = taskManager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("(Queue is empty)");
                        } else {
                            // Iterating through the queue without removing elements
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // View Processed Tasks
                        System.out.println("\n--- Processed Tasks ---");
                        List<Task> processed = taskManager.getProcessedTasks();
                        if (processed.isEmpty()) {
                            System.out.println("(No tasks processed yet)");
                        } else {
                            for (Task task : processed) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter an integer choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a newline for better readability between menu iterations
        }

        // Close the scanner resource
        scanner.close();
        System.out.println("Scanner closed.");
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
    }
}
