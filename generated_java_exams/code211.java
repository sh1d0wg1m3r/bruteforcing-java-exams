/*
 * Exam Question #211
 * Generated on: 2025-05-11 22:32:43
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Clinic Appointment Management System**
 * 
 * You are tasked with developing a simplified console-based application for managing patient appointments in a small clinic. The system should allow staff to check in patients, call the next patient from the waiting list, view the current waiting list, view the history of patients already seen, and exit the application.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Patient Representation:** Create a `Patient` class to represent a patient. It should store at least the patient's name. Use proper encapsulation (private fields, public getters).
 * 2.  **Appointment Management Logic:** Create a class (e.g., `ClinicAppointmentManager`) that handles the core logic. This class must maintain:
 *     *   A **waiting list** of patients using `java.util.Queue`. Patients are added to the end of the queue when they check in and removed from the front when called.
 *     *   A **history** of patients who have been seen using `java.util.List`. Use `java.util.ArrayList` as the concrete implementation for this list.
 * 3.  **User Interface:** Implement a console-based interface in your main class.
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   The application should present a menu of options:
 *         *   `checkin <patient_name>`: Adds a new patient to the waiting queue.
 *         *   `callnext`: Removes the patient at the front of the queue and adds them to the history.
 *         *   `viewqueue`: Displays the names of patients currently in the waiting queue.
 *         *   `viewhistory`: Displays the names of patients who have been seen.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to process user commands.
 *     *   Commands should be case-insensitive (e.g., "CheckIn", "CHECKIN", "checkin" should all work).
 * 4.  **Input Validation and Error Handling:**
 *     *   Validate input for the `checkin` command: Ensure a patient name is provided and is not empty.
 *     *   Handle cases where `callnext` is attempted when the queue is empty.
 *     *   Use `System.err` to print error messages (e.g., invalid command, missing patient name, empty queue).
 *     *   Use `System.out` for normal output (prompts, success messages, list displays).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected runtime errors during the application's execution loop.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but simple comments are acceptable for the exam).
 *     *   Structure your code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The application should loop, prompting the user for input and displaying results or errors.
 * 
 * Example Interaction:
 * 
 * ```
 * Clinic Appointment System
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * checkin Alice
 * Alice checked in and added to the waiting queue.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * checkin Bob
 * Bob checked in and added to the waiting queue.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * viewqueue
 * Waiting Queue:
 * 1. Alice
 * 2. Bob
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * callnext
 * Calling next patient: Alice. Alice moved to history.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * viewqueue
 * Waiting Queue:
 * 1. Bob
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * viewhistory
 * Seen Patients:
 * 1. Alice
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * callnext
 * Calling next patient: Bob. Bob moved to history.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * callnext
 * Error: No patients in the waiting queue.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * viewhistory
 * Seen Patients:
 * 1. Alice
 * 2. Bob
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * invalid_command
 * Error: Unknown command. Please use checkin <name>, callnext, viewqueue, viewhistory, or exit.
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * checkin
 * Error: Patient name required for checkin command. Usage: checkin <name>
 * Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit):
 * exit
 * Exiting Clinic Appointment System.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a basic Clinic Appointment Management System demonstrating the required Java concepts.
 * 
 * 1.  **Patient Class:** The `Patient` class is a simple Plain Old Java Object (POJO) with a private `name` field and a public getter `getName()`, adhering to encapsulation principles. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **ClinicAppointmentManager Class:**
 *     *   It holds the core data structures: `waitingQueue` (declared as `Queue<Patient>`, implemented with `LinkedList`) and `seenPatients` (declared as `List<Patient>`, implemented with `ArrayList`). Using the interface types (`Queue`, `List`) promotes flexibility.
 *     *   `waitingQueue` uses `offer()` to add patients (safer than `add` for capacity-constrained queues, though `LinkedList` is not capacity-constrained) and `remove()` to get and remove the head patient.
 *     *   `seenPatients` uses `add()` to append patients who have been called.
 *     *   Methods like `addPatientToQueue`, `callNextPatient`, `viewQueue`, and `viewHistory` encapsulate the logic for managing these lists.
 *     *   `callNextPatient` uses a `try-catch` block specifically for `NoSuchElementException`, which is thrown by `waitingQueue.remove()` if the queue is empty. This demonstrates targeted exception handling within a method.
 *     *   `viewQueue` iterates over a *copy* of the queue (`new ArrayList<>(waitingQueue)`) to display elements without removing them, which is a common pattern for inspecting a queue.
 * 
 * 3.  **AppointmentSystemApp Class (Main Application):**
 *     *   The `main` method serves as the entry point. It contains a `try-catch(Exception e)` block that wraps the call to `runSystem()`. This fulfills the "class-wide exception handling" requirement by providing a top-level handler for any uncaught exceptions that might escape the main application loop, preventing the program from crashing abruptly due to unexpected errors.
 *     *   The `runSystem()` method contains the main application loop.
 *     *   A `Scanner` is used to read user input line by line.
 *     *   The input line is split into a command and a potential argument.
 *     *   The command is converted to lowercase to ensure case-insensitivity.
 *     *   A `switch` statement is used to direct the program flow based on the command. This directly addresses the `switch` statement requirement.
 *     *   **Input Validation:** Inside the `checkin` case, it checks if the `argument` (patient name) is empty. If so, it prints an error message using `System.err`.
 *     *   **Error Handling:**
 *         *   The `default` case of the `switch` handles unknown commands, printing an error via `System.err`.
 *         *   The `callnext` logic relies on the `ClinicAppointmentManager`'s method, which handles the `NoSuchElementException` (empty queue) and prints an error to `System.err`.
 *         *   The top-level `try-catch` in `main` catches any other unexpected `Exception`.
 *     *   **Output:** `System.out.println` is used for prompts, success messages, and displaying the contents of the queue and history. `System.err.println` is used exclusively for error messages, making them distinct.
 *     *   The `Scanner` is closed when the application exits the loop, which is good practice for resource management.
 * 
 * 4.  **Best Practices:**
 *     *   Meaningful names: `Patient`, `ClinicAppointmentManager`, `waitingQueue`, `seenPatients`, `addPatientToQueue`, `callNextPatient`, `runSystem`, `inputLine`, `command`, `argument` are all descriptive.
 *     *   Encapsulation is used in the `Patient` and `ClinicAppointmentManager` classes.
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   The code is structured into logical classes, separating data representation (`Patient`), core logic (`ClinicAppointmentManager`), and the main application loop (`AppointmentSystemApp`).
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical scenario, demonstrating understanding of basic data structures, control flow, object-oriented principles, and error handling in Java.
 */

import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Used by Queue methods when empty

/**
 * Represents a patient in the clinic.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Manages the patient waiting queue and history.
 */
class ClinicAppointmentManager {
    // Use LinkedList as a concrete implementation of Queue
    private Queue<Patient> waitingQueue;
    // Use ArrayList as a concrete implementation of List
    private List<Patient> seenPatients;

    /**
     * Constructs a new ClinicAppointmentManager.
     */
    public ClinicAppointmentManager() {
        this.waitingQueue = new LinkedList<>();
        this.seenPatients = new ArrayList<>();
    }

    /**
     * Adds a patient to the waiting queue.
     * @param patient The patient to add.
     */
    public void addPatientToQueue(Patient patient) {
        if (patient != null) {
            waitingQueue.offer(patient); // offer is safer than add, returns false on failure (rare for LinkedList)
            System.out.println(patient.getName() + " checked in and added to the waiting queue.");
        }
    }

    /**
     * Calls the next patient from the waiting queue and moves them to the seen history.
     * @return The patient who was called, or null if the queue was empty.
     */
    public Patient callNextPatient() {
        try {
            Patient nextPatient = waitingQueue.remove(); // remove throws NoSuchElementException if empty
            seenPatients.add(nextPatient);
            System.out.println("Calling next patient: " + nextPatient.getName() + ". " + nextPatient.getName() + " moved to history.");
            return nextPatient;
        } catch (NoSuchElementException e) {
            System.err.println("Error: No patients in the waiting queue.");
            return null;
        }
    }

    /**
     * Displays the current waiting queue.
     */
    public void viewQueue() {
        System.out.println("Waiting Queue:");
        if (waitingQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing elements. Copying to a list is one way.
            List<Patient> queueList = new ArrayList<>(waitingQueue);
            for (int i = 0; i < queueList.size(); i++) {
                System.out.println((i + 1) + ". " + queueList.get(i).getName());
            }
        }
    }

    /**
     * Displays the history of seen patients.
     */
    public void viewHistory() {
        System.out.println("Seen Patients:");
        if (seenPatients.isEmpty()) {
            System.out.println("(History is empty)");
        } else {
            for (int i = 0; i < seenPatients.size(); i++) {
                System.out.println((i + 1) + ". " + seenPatients.get(i).getName());
            }
        }
    }
}

/**
 * Main application class for the Clinic Appointment System.
 */
public class AppointmentSystemApp {

    public static void main(String[] args) {
        // Class-wide exception handling wrapper for the main logic loop
        try {
            runSystem();
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        }
    }

    /**
     * Contains the main application logic loop.
     */
    private static void runSystem() {
        Scanner scanner = new Scanner(System.in);
        ClinicAppointmentManager manager = new ClinicAppointmentManager();
        boolean running = true;

        System.out.println("Clinic Appointment System");
        printMenu();

        while (running) {
            System.out.print("Enter command (checkin <name>, callnext, viewqueue, viewhistory, exit): ");
            String inputLine = scanner.nextLine().trim();

            if (inputLine.isEmpty()) {
                continue; // Skip empty input
            }

            // Split command and arguments
            String[] parts = inputLine.split(" ", 2);
            String command = parts[0].toLowerCase(); // Make command case-insensitive
            String argument = parts.length > 1 ? parts[1] : "";

            switch (command) {
                case "checkin":
                    if (argument.isEmpty()) {
                        System.err.println("Error: Patient name required for checkin command. Usage: checkin <name>");
                    } else {
                        Patient newPatient = new Patient(argument);
                        manager.addPatientToQueue(newPatient);
                    }
                    break;
                case "callnext":
                    manager.callNextPatient(); // Error handling for empty queue is inside the manager method
                    break;
                case "viewqueue":
                    manager.viewQueue();
                    break;
                case "viewhistory":
                    manager.viewHistory();
                    break;
                case "exit":
                    System.out.println("Exiting Clinic Appointment System.");
                    running = false;
                    break;
                default:
                    System.err.println("Error: Unknown command. Please use checkin <name>, callnext, viewqueue, viewhistory, or exit.");
                    break;
            }
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the available commands.
     */
    private static void printMenu() {
        // In this simple version, the menu is printed within the main loop prompt.
        // A more complex version might have a separate 'help' command.
        // For this exam, the prompt itself serves as a minimal menu display.
    }
}
