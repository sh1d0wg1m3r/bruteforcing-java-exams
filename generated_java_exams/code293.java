/*
 * Exam Question #293
 * Generated on: 2025-05-11 22:50:43
 * Generated by: Account 2
 * 
 * QUESTION:
 * You are tasked with building a simple command-line based Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting to be processed, process the next task in line (following a first-in, first-out approach), and view tasks that have been completed.
 * 
 * The system operates based on a queue for pending tasks and a list for completed tasks.
 * 
 * Your Java program must implement this system and adhere to the following requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields: `taskId` (an integer, auto-generated), `description` (a String), and `status` (a String, e.g., "PENDING", "COMPLETED"). The class should have a constructor to initialize `taskId` and `description`, setting the initial status to "PENDING". Include public getter methods for all fields and a public setter method for the `status` field. Override the `toString()` method for easy printing of Task details.
 * 2.  **System Class:** Create a class named `TaskManagementSystem` containing the main logic of the application.
 * 3.  **Data Structures:**
 *     *   Use `java.util.Queue<Task>` to store tasks that are pending. Choose an appropriate implementation (e.g., `LinkedList`).
 *     *   Use `java.util.List<Task>` to store tasks that have been completed. Instantiate it using `java.util.ArrayList` but declare the variable using the `List` interface.
 * 4.  **User Interface:** Implement a command-line interface using `java.util.Scanner` to interact with the user. The system should present a menu with the following options:
 *     *   1. Add New Task
 *     *   2. View Pending Tasks
 *     *   3. Process Next Task
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 5.  **Flow Control:** Use a `switch` statement within a loop to handle the user's menu choice and direct execution to the appropriate operation.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, task information, success messages, and general program output.
 *     *   Use `System.err` for displaying error messages (e.g., invalid user input, attempting an operation on an empty collection).
 * 7.  **Error Handling:** Implement exception handling using `try-catch` blocks. This must include:
 *     *   A "class-wide" `try-catch` block (e.g., wrapping the main loop or execution logic in the `run` method) to catch and report any unexpected exceptions that occur during the system's operation.
 *     *   Specific error handling for attempting to process a task when the pending queue is empty.
 * 8.  **Input Validation:** Validate user input where necessary. For example, check if the menu choice is a valid integer and within the acceptable range, and ensure the task description is not empty.
 * 9.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Proper encapsulation (private fields, public/private methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments or basic documentation explaining the purpose of classes and methods.
 *     *   Clean code structure with methods separating different functionalities.
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output:**
 * The program should run continuously, displaying the menu and processing user input until the user selects the Exit option. It should correctly manage tasks using the specified data structures, display informative messages using `System.out` or `System.err` as appropriate, and handle errors gracefully without crashing.
 * 
 * Example Interaction Snippet:
 * ```
 * --- Task Management System ---
 * 
 * Select an option:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter choice: 1
 * --- Add New Task ---
 * Enter task description: Prepare presentation slides
 * Task added: Task [ID=1, Desc='Prepare presentation slides', Status=PENDING]
 * 
 * Select an option:
 * ...
 * Enter choice: 1
 * --- Add New Task ---
 * Enter task description: Schedule meeting with team
 * Task added: Task [ID=2, Desc='Schedule meeting with team', Status=PENDING]
 * 
 * Select an option:
 * ...
 * Enter choice: 2
 * --- Pending Tasks ---
 * Task [ID=1, Desc='Prepare presentation slides', Status=PENDING]
 * Task [ID=2, Desc='Schedule meeting with team', Status=PENDING]
 * Total pending tasks: 2
 * 
 * Select an option:
 * ...
 * Enter choice: 3
 * --- Processing Next Task ---
 * Task ID 1 processed and moved to completed tasks.
 * 
 * Select an option:
 * ...
 * Enter choice: 2
 * --- Pending Tasks ---
 * Task [ID=2, Desc='Schedule meeting with team', Status=PENDING]
 * Total pending tasks: 1
 * 
 * Select an option:
 * ...
 * Enter choice: 4
 * --- Completed Tasks ---
 * Task [ID=1, Desc='Prepare presentation slides', Status=COMPLETED]
 * Total completed tasks: 1
 * 
 * Select an option:
 * ...
 * Enter choice: 3
 * --- Processing Next Task ---
 * Task ID 2 processed and moved to completed tasks.
 * 
 * Select an option:
 * ...
 * Enter choice: 3
 * --- Processing Next Task ---
 * Error: No tasks are currently pending to process.
 * 
 * Select an option:
 * ...
 * Enter choice: invalid_input
 * Invalid input. Please enter a number.
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ...
 * Enter choice: 5
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`taskId`, `description`, `status`) enforcing encapsulation. Public getters provide read access, and a public setter allows modifying the status. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **TaskManagementSystem Class:** This class contains the core logic.
 *     *   **Data Structures:**
 *         *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and a common implementation (`LinkedList`) which maintains insertion order (FIFO), suitable for processing tasks in the order they were added.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This demonstrates programming to the `List` interface while using `ArrayList` as the concrete implementation, providing dynamic resizing and easy iteration over completed tasks.
 *     *   **Scanner:** A `Scanner` instance is used to read user input from the console (`System.in`). It's a class-level field, initialized in the constructor.
 *     *   **`run()` Method:** This method contains the main application loop (`while(running)`). It repeatedly displays the menu, gets user input, and processes the choice.
 *     *   **Class-wide Exception Handling:** The main `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This serves as the "class-wide" exception handler, catching any unexpected runtime exceptions that might occur during the execution of the menu options and printing an error message to `System.err`. The `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop finished normally.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   `displayMenu()`: A private helper method to print the menu options to `System.out`.
 *     *   `getUserChoice()`: A private helper method that prompts the user for input and includes input validation (`while (!scanner.hasNextInt())`). If the input is not an integer, an error message is printed to `System.err`, and the invalid input is consumed using `scanner.next()` before prompting again. `scanner.nextLine()` is used after `nextInt()` to consume the remaining newline character.
 *     *   **`switch` Statement:** Inside the `run()` method's loop, a `switch` statement is used to direct the program flow based on the integer returned by `getUserChoice()`. Each case corresponds to a menu option, calling the relevant private method. The `default` case handles invalid menu numbers, printing an error to `System.err`.
 * 
 * 4.  **Operations:**
 *     *   `addTask()`: Prompts for a task description, validates that it's not empty (using `System.err` for the error message), creates a new `Task` object with an auto-incremented ID, and adds it to the `pendingTasks` queue using `pendingTasks.add()`. Success message is printed to `System.out`.
 *     *   `viewPendingTasks()`: Checks if the `pendingTasks` queue is empty. If so, prints a message to `System.out`. Otherwise, it iterates through the queue (using an enhanced for loop, which doesn't remove elements) and prints each task using `System.out`.
 *     *   `processNextTask()`: This method demonstrates interaction with the `Queue`. It uses a `try-catch` block specifically to handle the case where the `pendingTasks` queue is empty. `pendingTasks.remove()` is called, which removes and returns the head of the queue. If the queue is empty, `remove()` throws `NoSuchElementException`, which is caught, and an error message is printed to `System.err`. If successful, the task's status is updated, and it's added to the `completedTasks` list using `completedTasks.add()`. Success or error messages are printed to `System.out` or `System.err` respectively. A general `catch(Exception e)` is also included for any other unexpected errors during processing.
 *     *   `viewCompletedTasks()`: Checks if the `completedTasks` list is empty. If so, prints a message to `System.out`. Otherwise, it iterates through the `List` (using an enhanced for loop) and prints each completed task using `System.out`.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Variable names (`pendingTasks`, `completedTasks`, `nextTaskId`) and method names (`addTask`, `processNextTask`, `getUserChoice`) are meaningful.
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   The code is structured into small, focused methods.
 *     *   Input validation is performed for menu choice and task description.
 *     *   Error handling uses both specific (`NoSuchElementException`) and general (`Exception`) `try-catch` blocks, directing error output to `System.err`.
 *     *   The `Scanner` is closed in a `finally` block to release the system resource.
 * 
 * This solution effectively uses all the required Java components in a practical scenario, demonstrating understanding of collections, user interaction, control flow, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages tasks using a pending queue and a completed list.
 */
public class TaskManagementSystem {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared as List, instantiated as ArrayList
    private Scanner scanner;
    private int nextTaskId;
    private boolean running;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes data structures and scanner.
     */
    public TaskManagementSystem() {
        // Use LinkedList as a Queue implementation
        pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation
        completedTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
        nextTaskId = 1; // Start task IDs from 1
        running = true; // System is running initially
    }

    /**
     * Starts the task management system's main loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");

        // Class-wide try-catch block for general unexpected errors
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();

                // Inner try-catch can be used for operation-specific errors,
                // or let them propagate to the outer catch if not handled specifically.
                // For this problem, we handle NoSuchElementException specifically
                // and let other potential exceptions be caught by the outer block.
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Exit the loop
                        break;
                    default:
                        // Use System.err for invalid input message
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the system's operation
            System.err.println("A critical error occurred in the system: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging purposes
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation message
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Gets a valid integer choice from the user.
     * Handles non-integer input using System.err.
     * @return The user's integer choice.
     */
    private int getUserChoice() {
        // Input validation loop
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input (e.g., a String)
            System.out.print("Enter choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return choice;
    }

    /**
     * Adds a new task based on user input.
     * Validates that the task description is not empty.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read the whole line and trim whitespace

        // Input validation for task description
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.add(newTask); // Add task to the pending queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Does not remove tasks from the queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
            return;
        }

        // Iterate through the Queue (order depends on Queue implementation)
        int count = 0;
        for (Task task : pendingTasks) {
             System.out.println(task);
             count++;
        }
        System.out.println("Total pending tasks: " + count);
    }

    /**
     * Processes the next task from the pending queue (FIFO).
     * Moves the processed task to the completed list.
     * Includes specific exception handling for an empty queue.
     */
    private void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");
        try {
            // remove() retrieves and removes the head of the queue.
            // Throws NoSuchElementException if the queue is empty.
            Task taskToProcess = pendingTasks.remove();
            taskToProcess.setStatus("COMPLETED"); // Update task status
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task ID " + taskToProcess.getTaskId() + " processed and moved to completed tasks.");

        } catch (NoSuchElementException e) {
            // Specific error handling for an empty queue
            System.err.println("Error: No tasks are currently pending to process.");
        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging purposes
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }

        // Iterate through the List (ArrayList)
        for (Task task : completedTasks) {
            System.out.println(task);
        }
        System.out.println("Total completed tasks: " + completedTasks.size());
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
