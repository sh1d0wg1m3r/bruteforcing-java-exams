/*
 * Exam Question #138
 * Generated on: 2025-05-11 22:20:06
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line task processing system. This system simulates a queue of incoming tasks that need to be processed sequentially. Once processed, tasks are moved to a history log. The system should allow users to add new tasks, process the next task in the queue, view the current task queue, and view the history of processed tasks.
 * 
 * **System Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. Each task must have:
 *     *   A unique integer ID.
 *     *   A String representing the task type (e.g., "DATA_PROCESSING", "REPORT_GENERATION", "USER_REQUEST").
 *     *   A String describing the task details.
 *     *   A String representing the task status (e.g., "PENDING", "PROCESSED").
 *     *   Proper encapsulation (private fields, public getters).
 * 
 * 2.  **System Management:** Create a main class (e.g., `TaskProcessingSystem`) that manages the task queue and processed task history.
 *     *   Maintain a queue of `Task` objects that are pending processing.
 *     *   Maintain a list of `Task` objects that have been processed.
 *     *   Generate unique IDs for new tasks starting from 1.
 * 
 * 3.  **User Interaction:** The system should interact with the user via the console. It should continuously prompt the user for commands until an "EXIT" command is given.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Implement the following commands using a `switch` statement:
 *         *   `ADD <type> <description>`: Creates a new `Task` with the given type and description, assigns a unique ID, sets status to "PENDING", and adds it to the end of the pending queue.
 *         *   `PROCESS`: Takes the task at the front of the pending queue, changes its status to "PROCESSED", and moves it to the processed history list. If the queue is empty, print an error message.
 *         *   `VIEW_QUEUE`: Prints the details of all tasks currently in the pending queue, from front to back. If the queue is empty, indicate so.
 *         *   `VIEW_HISTORY`: Prints the details of all tasks in the processed history list. If the history is empty, indicate so.
 *         *   `EXIT`: Terminates the program.
 *     *   Handle invalid commands (commands not recognized) by printing an error message.
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, queue empty for processing).
 *     *   Use `System.out` for all normal output (prompts, success messages, task details).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues during input processing or task operations (e.g., unexpected input format, although the primary focus is on command/logic errors).
 * 
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate the use of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as the type for the history list)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks
 * 
 * 6.  **Best Practices:** Adhere to best practices including:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining logic.
 *     *   Input validation (checking command format, checking if queue is empty before processing).
 *     *   Clean code structure.
 * 
 * **Task Details Output Format:**
 * 
 * When viewing the queue or history, print each task on a new line in the format:
 * `Task ID: <ID>, Type: <Type>, Description: <Description>, Status: <Status>`
 * 
 * **Example Interaction (User Input in Bold):**
 * 
 * ```
 * Enter command: ADD DATA_PROCESSING Process customer records
 * Task 1 added to queue.
 * Enter command: ADD REPORT_GENERATION Generate monthly sales report
 * Task 2 added to queue.
 * Enter command: VIEW_QUEUE
 * Pending Tasks:
 * Task ID: 1, Type: DATA_PROCESSING, Description: Process customer records, Status: PENDING
 * Task ID: 2, Type: REPORT_GENERATION, Description: Generate monthly sales report, Status: PENDING
 * Enter command: PROCESS
 * Processed task: Task ID: 1, Type: DATA_PROCESSING, Description: Process customer records, Status: PROCESSED
 * Enter command: VIEW_QUEUE
 * Pending Tasks:
 * Task ID: 2, Type: REPORT_GENERATION, Description: Generate monthly sales report, Status: PENDING
 * Enter command: VIEW_HISTORY
 * Processed Tasks:
 * Task ID: 1, Type: DATA_PROCESSING, Description: Process customer records, Status: PROCESSED
 * Enter command: PROCESS
 * Processed task: Task ID: 2, Type: REPORT_GENERATION, Description: Generate monthly sales report, Status: PROCESSED
 * Enter command: PROCESS
 * Error: Task queue is empty. Cannot process.
 * Enter command: VIEW_QUEUE
 * Pending Tasks: Queue is empty.
 * Enter command: VIEW_HISTORY
 * Processed Tasks:
 * Task ID: 1, Type: DATA_PROCESSING, Description: Process customer records, Status: PROCESSED
 * Task ID: 2, Type: REPORT_GENERATION, Description: Generate monthly sales report, Status: PROCESSED
 * Enter command: INVALID_COMMAND
 * Error: Unknown command. Type 'EXIT' to quit.
 * Enter command: EXIT
 * Exiting Task Processing System.
 * ```
 * 
 * Implement the `Task` and `TaskProcessingSystem` classes to fulfill these requirements.
 *
 * EXPLANATION:
 * The solution provides a command-line `TaskProcessingSystem` that manages tasks using a queue and a history list, fulfilling all the requirements of the problem.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (ID, type, description, status). It uses private fields and public getter methods (`getId`, `getType`, `getDescription`, `getStatus`) to adhere to encapsulation principles. A setter (`setStatus`) is provided specifically for changing the task's status upon processing. The `toString()` method is overridden for convenient printing of task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core class managing the system state and logic.
 *     *   **`Queue<Task> taskQueue`**: A `java.util.Queue` is used to store tasks that are waiting to be processed. The `LinkedList` class is used as a concrete implementation of the `Queue` interface, providing efficient FIFO (First-In, First-Out) behavior suitable for a processing queue.
 *     *   **`List<Task> processedTasks`**: A `java.util.List` is used to store tasks after they have been processed. `ArrayList` is chosen as the concrete implementation, providing dynamic array capabilities suitable for storing a history of processed items. Programming to the `List` interface here is a good practice.
 *     *   **`int nextTaskId`**: A simple counter ensures each new task receives a unique ID.
 *     *   **`Scanner scanner`**: An instance of `java.util.Scanner` is used to read commands and arguments from standard input (`System.in`).
 * 
 * 3.  **User Interaction and Command Processing:**
 *     *   The `run()` method contains the main application loop.
 *     *   Inside the loop, `scanner.nextLine()` reads the entire line of user input.
 *     *   `inputLine.split(" ", 3)` is used to parse the command and its potential arguments. Splitting into at most 3 parts handles the `ADD` command format (`ADD type description`) correctly, where the description might contain spaces.
 *     *   A `switch` statement is used to determine which command was entered based on the first part of the input line (converted to uppercase for case-insensitive matching). This fulfills the requirement for using a `switch` statement for flow control.
 * 
 * 4.  **Command Implementations:**
 *     *   **`addTask(String type, String description)`**: Creates a new `Task` object with the next available ID, sets its status to "PENDING", and adds it to the `taskQueue` using `offer()`. `offer()` is preferred over `add()` in queues as it returns `false` on failure rather than throwing an exception, though for `LinkedList` it behaves like `add()`.
 *     *   **`processNextTask()`**: Uses `taskQueue.poll()` to retrieve and remove the task at the head of the queue. `poll()` returns `null` if the queue is empty, which is checked to provide an appropriate error message using `System.err`. If a task is retrieved, its status is updated to "PROCESSED" using the setter, and it's added to the `processedTasks` `ArrayList`.
 *     *   **`viewQueue()`**: Iterates through the `taskQueue` using an enhanced for loop. This allows viewing elements without removing them. It prints the details of each task using its `toString()` method. Checks if the queue is empty and reports accordingly.
 *     *   **`viewHistory()`**: Iterates through the `processedTasks` `ArrayList` and prints the details of each task. Checks if the list is empty and reports accordingly.
 *     *   **`EXIT`**: Sets the `running` flag to `false`, causing the main loop to terminate.
 * 
 * 5.  **Error Handling:**
 *     *   `System.err.println()` is used for printing error messages, specifically when a command requires arguments that are missing (`ADD` command validation) or when attempting to `PROCESS` an empty queue.
 *     *   `System.out.println()` is used for all normal messages, prompts, task additions, processing confirmations, and viewing queue/history contents.
 *     *   A `try-catch (Exception e)` block surrounds the command processing logic within the main loop. This demonstrates class-wide exception handling as required. While the primary logic errors (like empty queue) are handled explicitly, this block catches any unforeseen runtime exceptions that might occur during input parsing or command execution, printing a general error message using `System.err`. The specific handling of `NoSuchElementException` is implicitly covered by the `poll()` method returning `null` and the subsequent check, but the general `try-catch` provides a fallback.
 *     *   Input validation for the `ADD` command checks if enough arguments are provided.
 * 
 * 6.  **Best Practices:**
 *     *   Variable names (`taskQueue`, `processedTasks`, `nextTaskId`, `scanner`, `inputLine`, `command`, etc.) are descriptive.
 *     *   Methods (`addTask`, `processNextTask`, `viewQueue`, `viewHistory`, `run`) break down the functionality logically.
 *     *   Comments explain the purpose of classes, fields, and key logic sections.
 *     *   Encapsulation is used in the `Task` class.
 *     *   Programming to interfaces (`Queue`, `List`) is demonstrated.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured program that simulates a real-world task processing flow, while adhering to best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Import for potential queue poll/remove issues

// Represents a task in the system
class Task {
    private int id;
    private String type;
    private String description;
    private String status; // e.g., "PENDING", "PROCESSED"

    // Constructor
    public Task(int id, String type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.status = "PENDING"; // Default status for new tasks
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Task ID: " + id + ", Type: " + type + ", Description: " + description + ", Status: " + status;
    }
}

// Main class for the Task Processing System
public class TaskProcessingSystem {

    // Use Queue for pending tasks (FIFO)
    private Queue<Task> taskQueue;
    // Use List for processed tasks history
    private List<Task> processedTasks;
    // Counter for unique task IDs
    private int nextTaskId;
    // Scanner for user input
    private Scanner scanner;

    // Constructor
    public TaskProcessingSystem() {
        // Initialize the queue using LinkedList as an implementation
        this.taskQueue = new LinkedList<>();
        // Initialize the history list using ArrayList
        this.processedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    // Method to add a new task to the queue
    private void addTask(String type, String description) {
        Task newTask = new Task(nextTaskId++, type, description);
        taskQueue.offer(newTask); // offer() is generally preferred over add() for queues as it doesn't throw exception on failure
        System.out.println("Task " + newTask.getId() + " added to queue.");
    }

    // Method to process the next task from the queue
    private void processNextTask() {
        // Use poll() to retrieve and remove the head of the queue, returns null if queue is empty
        Task taskToProcess = taskQueue.poll();

        if (taskToProcess == null) {
            System.err.println("Error: Task queue is empty. Cannot process.");
        } else {
            taskToProcess.setStatus("PROCESSED");
            processedTasks.add(taskToProcess); // Add to history list
            System.out.println("Processed task: " + taskToProcess);
        }
    }

    // Method to view tasks in the pending queue
    private void viewQueue() {
        System.out.println("Pending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            // Creating a temporary list or iterating with an enhanced for loop
            // is common practice for viewing queues without modifying them.
            // Let's use an enhanced for loop for simplicity here.
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    // Method to view tasks in the processed history
    private void viewHistory() {
        System.out.println("Processed Tasks:");
        if (processedTasks.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            // Iterate through the history list
            for (Task task : processedTasks) {
                System.out.println(task);
            }
        }
    }

    // Method to run the main system loop
    public void run() {
        boolean running = true;
        System.out.println("Task Processing System started. Type 'EXIT' to quit.");

        // Main loop for processing commands
        while (running) {
            System.out.print("Enter command: ");
            String inputLine = scanner.nextLine().trim();

            // Use try-catch for robust input handling, although specific exceptions
            // might depend on the command structure. A general catch is used here
            // as required, covering potential issues within the switch logic.
            try {
                // Split the input line into command and arguments
                String[] parts = inputLine.split(" ", 3); // Split into at most 3 parts: command, type, description
                String command = parts[0].toUpperCase(); // Get the command and convert to uppercase

                // Use switch statement for command processing
                switch (command) {
                    case "ADD":
                        if (parts.length >= 3) {
                            String type = parts[1];
                            String description = parts[2];
                            addTask(type, description);
                        } else {
                            System.err.println("Error: ADD command requires type and description. Usage: ADD <type> <description>");
                        }
                        break;
                    case "PROCESS":
                        processNextTask();
                        break;
                    case "VIEW_QUEUE":
                        viewQueue();
                        break;
                    case "VIEW_HISTORY":
                        viewHistory();
                        break;
                    case "EXIT":
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        // Handle unknown commands
                        System.err.println("Error: Unknown command. Type 'EXIT' to quit.");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(); for debugging
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
