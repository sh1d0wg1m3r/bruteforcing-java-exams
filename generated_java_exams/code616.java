/*
 * Exam Question #616
 * Generated on: 2025-05-12 16:15:27
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team. The system should allow users to add new tasks, process the next pending task, view all pending tasks, and view all completed tasks.
 * 
 * The system should manage tasks using a queue for pending items (processed in First-In, First-Out order) and a list for completed items. User interaction will be via the console. The system must be robust against invalid user input and handle operational errors gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following properties:
 *     *   `taskId` (String): A unique identifier for the task (can be a simple counter-based string).
 *     *   `description` (String): A description of the task.
 *     *   `category` (String): A category for the task (e.g., "Development", "Testing", "Meeting").
 *     *   `status` (enum or String): The current status of the task (e.g., "Pending", "Completed").
 *     *   Implement a constructor and appropriate getter methods. Ensure properties are private.
 * 
 * 2.  **Task Manager:** Create a class `TaskManager` that manages the task collections and operations.
 *     *   It should have a private field for pending tasks using `java.util.Queue<Task>`.
 *     *   It should have a private field for completed tasks using `java.util.List<Task>` (specifically, an `ArrayList` instance).
 *     *   Implement the following public methods:
 *         *   `addTask(String description, String category)`: Creates a new `Task` with status "Pending", assigns a unique ID, and adds it to the pending task queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, changes its status to "Completed", and adds it to the completed tasks list. This method should handle the case where the pending queue is empty.
 *         *   `getPendingTasks()`: Returns a `List<Task>` containing all tasks currently in the pending queue. (Note: Return a *copy* or use stream operations if modifying the returned list should not affect the internal queue, but for this exam, returning a direct view/iteration is acceptable if clearly documented). Iterating over the queue is sufficient for display.
 *         *   `getCompletedTasks()`: Returns the `List<Task>` of completed tasks.
 *         *   `getPendingTaskCount()`: Returns the number of tasks in the pending queue.
 *         *   `getCompletedTaskCount()`: Returns the number of tasks in the completed list.
 * 
 * 3.  **Main Application:** Create a class `TaskManagementApp` with the `main` method.
 *     *   Initialize a `TaskManager` instance and a `Scanner` for user input.
 *     *   Implement a console-based menu loop with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice and task details (e.g., description/category should not be empty). Use `System.err` for invalid input messages.
 *     *   Use `System.out` for the menu, prompts, and successful operation messages/output.
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main loop to gracefully handle potential runtime errors during operations (e.g., issues with input reading, unexpected nulls, etc.). Specific error messages should be printed to `System.err`.
 * 
 * 4.  **Required Java Components:** Your solution MUST utilize ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks for exception handling.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc where applicable).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display relevant information or error messages. Examples:
 * 
 * *   Adding a task: Prompt for description and category, confirm task added.
 * *   Processing a task: Indicate which task was processed, or state if the queue is empty.
 * *   Viewing tasks: List tasks with their details (ID, description, category, status).
 * *   Invalid input: Print an error message to `System.err`.
 * *   Operational error (e.g., processing empty queue): Print an error message to `System.err`.
 * 
 * **Constraint:** The solution should be a single cohesive program demonstrating the interaction of these components.
 *
 * EXPLANATION:
 * 
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Requirement 1: Task Representation
class Task {
    private String taskId;
    private String description;
    private String category;
    private String status; // Using String for simplicity as per requirement, enum is also good.

    // Constructor
    public Task(String taskId, String description, String category) {
        if (taskId == null || taskId.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        if (category == null || category.trim().isEmpty()) {
             throw new IllegalArgumentException("Task category cannot be null or empty.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.category = category.trim();
        this.status = "Pending"; // Initial status
    }

    // Getters (Requirement 5: Encapsulation)
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getCategory() {
        return category;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status (used by TaskManager)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %s, Desc: %s, Category: %s, Status: %s",
                             taskId, description, category, status);
    }
}

// Requirement 2: Task Manager
class TaskManager {
    // Requirement 4: Queue for pending tasks
    private Queue<Task> pendingTasks;
    // Requirement 4: List (ArrayList implementation) for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId = 1; // Simple counter for unique IDs

    // Constructor
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // Requirement 4: ArrayList
    }

    /**
     * Adds a new task to the pending queue.
     * Requirement 2: addTask method
     * Requirement 5: Meaningful names, Documentation
     */
    public void addTask(String description, String category) {
        // Basic validation handled in Task constructor
        String taskId = "TASK-" + nextTaskId++;
        try {
            Task newTask = new Task(taskId, description, category);
            pendingTasks.offer(newTask); // offer is safer than add (returns false on failure instead of throwing)
            System.out.println("Task added: " + newTask.getDescription());
        } catch (IllegalArgumentException e) {
            // Requirement 4: System.err for errors
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Requirement 2: processNextTask method
     * Requirement 5: Meaningful names, Documentation
     */
    public void processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll is safer than remove (returns null if queue is empty)
        if (nextTask != null) {
            nextTask.setStatus("Completed");
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask.getDescription());
        } else {
            // Requirement 4: System.err for errors
            System.err.println("No pending tasks to process.");
        }
    }

    /**
     * Returns a list of all pending tasks.
     * Requirement 2: getPendingTasks method
     * Requirement 4: List interface
     * Requirement 5: Meaningful names, Documentation
     */
    public List<Task> getPendingTasks() {
        // Returning a new ArrayList containing pending tasks to avoid external modification of the queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns the list of all completed tasks.
     * Requirement 2: getCompletedTasks method
     * Requirement 4: List interface (return type)
     * Requirement 5: Meaningful names, Documentation
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Returning the internal list reference is acceptable per requirement
    }

    /**
     * Returns the count of pending tasks.
     * Requirement 2: getPendingTaskCount method
     * Requirement 5: Meaningful names, Documentation
     */
    public int getPendingTaskCount() {
        return pendingTasks.size();
    }

    /**
     * Returns the count of completed tasks.
     * Requirement 2: getCompletedTaskCount method
     * Requirement 5: Meaningful names, Documentation
     */
    public int getCompletedTaskCount() {
        return completedTasks.size();
    }
}

// Requirement 3: Main Application
public class TaskManagementApp {

    // Requirement 4: Scanner
    private static Scanner scanner = new Scanner(System.in);
    private static TaskManager taskManager = new TaskManager();

    public static void main(String[] args) {
        // Requirement 4: System.out for normal output
        System.out.println("--- Task Management System ---");

        boolean running = true;
        while (running) {
            printMenu();
            int choice = -1;

            // Requirement 4: Class-wide exception handling with try-catch
            try {
                // Read user choice
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Requirement 4: Switch statement
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Requirement 4: System.err for errors
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Requirement 4: System.err for errors
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                // Requirement 4: System.err for errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks (" + taskManager.getPendingTaskCount() + ")");
        System.out.println("4. View Completed Tasks (" + taskManager.getCompletedTaskCount() + ")");
        System.out.println("5. Exit");
    }

    private static void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        System.out.print("Enter task category: ");
        String category = scanner.nextLine().trim();

        // Requirement 5: Input validation
        if (description.isEmpty() || category.isEmpty()) {
            // Requirement 4: System.err for errors
            System.err.println("Description and category cannot be empty.");
            return;
        }

        taskManager.addTask(description, category);
    }

    private static void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        List<Task> pending = taskManager.getPendingTasks();
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Requirement 4: System.out for normal output
            pending.forEach(System.out::println);
        }
    }

    private static void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        List<Task> completed = taskManager.getCompletedTasks();
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Requirement 4: System.out for normal output
            completed.forEach(System.out::println);
        }
    }
}
