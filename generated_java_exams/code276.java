/*
 * Exam Question #276
 * Generated on: 2025-05-11 22:48:30
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * Your team needs a simple console-based system to manage tasks. New tasks are initially placed in a queue awaiting assignment or processing. All tasks, regardless of their current state, are tracked in a central list. You need to build this system demonstrating your understanding of core Java collections, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for a unique integer ID, a String description, and a String status (e.g., "PENDING", "IN_PROGRESS", "COMPLETED"). Include a constructor and public getter methods.
 * 2.  **Task Management Logic:** Create a class `TaskManager` to handle the task operations.
 *     *   It must use a `java.util.Queue<Task>` (e.g., implemented by `LinkedList`) to hold tasks that are newly added and waiting for initial processing.
 *     *   It must use a `java.util.List<Task>` (specifically an `ArrayList<Task>`) to store *all* tasks created in the system.
 *     *   Include methods for:
 *         *   `addTask(String description)`: Creates a new `Task`, assigns a unique ID, adds it to the `allTasks` list (with status "PENDING"), and offers it to the `taskQueue`. Returns the created `Task`.
 *         *   `processNextQueuedTask()`: Retrieves and removes the head task from the `taskQueue`. If a task is retrieved, find it in the `allTasks` list and update its status to "IN_PROGRESS". Returns the processed `Task` or `null` if the queue was empty.
 *         *   `completeTask(int taskId)`: Finds the task with the given ID in the `allTasks` list and updates its status to "COMPLETED".
 *         *   `listAllTasks()`: Prints details (ID, description, status) of all tasks currently in the `allTasks` list.
 *         *   `listQueuedTasks()`: Prints details of tasks currently in the `taskQueue` (without removing them).
 *         *   `viewTask(int taskId)`: Finds and prints details of a specific task from the `allTasks` list by its ID.
 * 3.  **User Interface:** Create a main application class (e.g., `TaskManagerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user (Add Task, Process Next, Complete Task, List All, List Queued, View Task, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task listings.
 *     *   Use `System.err` for displaying all error messages.
 * 4.  **Exception Handling:**
 *     *   Implement a custom exception class `TaskNotFoundException` that extends `Exception`.
 *     *   The `completeTask` and `viewTask` methods in `TaskManager` should throw `TaskNotFoundException` if the specified task ID does not exist in the `allTasks` list.
 *     *   Implement a class-wide `try-catch` block in the `main` application logic (around the main menu loop) to handle exceptions, specifically:
 *         *   `InputMismatchException` (for non-integer input when expecting numbers).
 *         *   `TaskNotFoundException`.
 *         *   A general `Exception` catch for any other unexpected errors.
 *     *   Print appropriate error messages to `System.err` when exceptions are caught. Ensure the application doesn't crash due to these errors and allows the user to continue.
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation (`private` fields, public getters/setters where appropriate).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc for classes and methods.
 *     *   Perform basic input validation (e.g., checking for empty description, handling non-numeric input).
 *     *   Handle edge cases like trying to process an empty queue or completing an already completed task.
 *     *   Structure your code logically into classes.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user through the console, displaying a menu, accepting input, and printing results or error messages. Demonstrate adding tasks, processing the queue, completing tasks, listing tasks, and viewing tasks, including examples showing error messages for invalid input or task IDs.
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Queued Task
 * 3. Complete Task by ID
 * 4. List All Tasks
 * 5. List Queued Tasks
 * 6. View Task by ID
 * 7. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task 1: Write report [PENDING]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Queued Tasks ---
 * Task 1: Write report [PENDING]
 * --------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task 1: Write report [IN_PROGRESS]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- All Tasks ---
 * Task 1: Write report [IN_PROGRESS]
 * -----------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter ID of task to complete: 1
 * Task 1 marked as COMPLETED.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Enter ID of task to view: 99
 * Error: Task with ID 99 not found.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a valid number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 7
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for the `Task`, `TaskNotFoundException`, `TaskManager`, and `TaskManagerApp` classes within the provided code block. Ensure all required imports are present.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class serves as the data model for a single task. It encapsulates the task's `id`, `description`, and `status` using private fields and provides public getter methods. The `toString()` method provides a convenient formatted output for task details. Encapsulation ensures that the internal state of a `Task` object can only be modified through defined methods (like `setStatus`), promoting data integrity.
 * 
 * 2.  **`TaskNotFoundException` Class:** This is a custom checked exception. It's used by the `TaskManager` methods (`completeTask`, `viewTask`) to signal specifically when a requested task ID does not correspond to any existing task. Using a custom exception makes the error handling clearer than using a generic exception type.
 * 
 * 3.  **`TaskManager` Class:** This is the core logic class.
 *     *   It uses a `Queue<Task>` (`taskQueue`) implemented by `LinkedList`. The `Queue` is used to manage tasks that are newly added and waiting for their initial processing. `offer()` is used to add to the queue, and `poll()` is used to retrieve and remove the head of the queue.
 *     *   It uses a `List<Task>` (`allTasks`) implemented by `ArrayList`. This list maintains a record of *all* tasks ever created in the system, regardless of their current status. `ArrayList` provides dynamic resizing and efficient element access (though we iterate for finding by ID in this specific implementation as required by the problem structure).
 *     *   The methods (`addTask`, `processNextQueuedTask`, `completeTask`, `listAllTasks`, `listQueuedTasks`, `viewTask`) implement the required business logic. `addTask` adds to both the list and the queue. `processNextQueuedTask` removes from the queue and updates the status in the list. `completeTask` and `viewTask` operate on the `allTasks` list, leveraging the helper `findTaskById` method which iterates through the `ArrayList`.
 *     *   Private fields and public methods demonstrate encapsulation. Meaningful names are used for variables and methods.
 * 
 * 4.  **`TaskManagerApp` Class:** This is the entry point of the application.
 *     *   The `main` method creates an instance of `TaskManagerApp` and calls its `run` method.
 *     *   The `run` method contains the main application loop. It repeatedly displays a menu using `System.out` and reads user input using `java.util.Scanner`.
 *     *   A `switch` statement is used to direct the program flow based on the user's numerical choice, calling the appropriate methods in the `TaskManager`.
 *     *   **Class-wide Exception Handling:** A `try-catch` block is wrapped around the main `while` loop's inner logic (`try { choice = scanner.nextInt(); ... switch(...) } catch(...)`). This structure allows the program to catch exceptions occurring during input reading or method execution within that iteration of the loop, print an error message using `System.err`, and then continue the loop, presenting the menu again.
 *     *   Specific `catch` blocks are included for `InputMismatchException` (handling non-integer input for choices/IDs) and the custom `TaskNotFoundException`. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime issues, ensuring the program doesn't terminate abruptly. Error messages are printed to `System.err` as required.
 *     *   Input validation includes checking for empty task descriptions and consuming the newline character after `nextInt()` calls to prevent issues with subsequent `nextLine()`.
 *     *   A `finally` block is used to ensure the `Scanner` is closed when the application loop terminates, releasing system resources.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical application, while adhering to best practices like encapsulation, clear naming, documentation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task in the task management system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "IN_PROGRESS", "COMPLETED"

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the task.
     * @return A formatted string including task ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task " + id + ": " + description + " [" + status + "]";
    }
}

/**
 * Custom exception for when a task ID is not found.
 */
class TaskNotFoundException extends Exception {
    /**
     * Constructs a new TaskNotFoundException with the specified detail message.
     * @param message The detail message.
     */
    public TaskNotFoundException(String message) {
        super(message);
    }
}

/**
 * Manages tasks using a queue for pending items and a list for all tasks.
 */
class TaskManager {
    private Queue<Task> taskQueue; // Tasks waiting for initial processing
    private List<Task> allTasks;    // All tasks ever created
    private int nextTaskId;         // Counter for unique task IDs

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the system.
     * The task is added to the list of all tasks and offered to the processing queue.
     * @param description The description of the new task.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        int taskId = nextTaskId++;
        Task newTask = new Task(taskId, description);
        allTasks.add(newTask);
        taskQueue.offer(newTask); // Add to the end of the queue
        return newTask;
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue and updates its status to "IN_PROGRESS".
     * @return The Task being processed, or null if the queue is empty.
     */
    public Task processNextQueuedTask() {
        Task taskToProcess = taskQueue.poll(); // Get and remove head of queue
        if (taskToProcess != null) {
            // Find the task in the allTasks list to update its status
            // Using findTaskById to demonstrate list iteration/search
            Task taskInList = findTaskById(taskToProcess.getId());
            if (taskInList != null) {
                 taskInList.setStatus("IN_PROGRESS");
            }
            // Note: In this specific design, taskToProcess is the same object
            // reference as the one in allTasks, so taskToProcess.setStatus(...)
            // would also work directly. Using findTaskById explicitly shows list usage.
        }
        return taskToProcess;
    }

    /**
     * Marks a task as completed by its ID.
     * Updates the task's status in the allTasks list.
     * @param taskId The ID of the task to complete.
     * @throws TaskNotFoundException if the task ID does not exist.
     */
    public void completeTask(int taskId) throws TaskNotFoundException {
        Task task = findTaskById(taskId);
        if (task == null) {
            throw new TaskNotFoundException("Task with ID " + taskId + " not found.");
        }
        if ("COMPLETED".equals(task.getStatus())) {
            System.out.println("Task " + taskId + " is already completed.");
        } else {
            task.setStatus("COMPLETED");
            System.out.println("Task " + taskId + " marked as COMPLETED.");
        }
    }

    /**
     * Lists all tasks in the system with their details.
     */
    public void listAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system.");
            return;
        }
        System.out.println("\n--- All Tasks ---");
        for (Task task : allTasks) {
            System.out.println(task);
        }
        System.out.println("-----------------\n");
    }

    /**
     * Lists tasks currently waiting in the processing queue.
     * Iterating over the queue does not remove elements.
     */
    public void listQueuedTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks currently in the queue.");
            return;
        }
        System.out.println("\n--- Queued Tasks ---");
        // Iterate over the queue elements
        for (Task task : taskQueue) {
            System.out.println(task); // Status will be PENDING as they haven't been processed yet
        }
        System.out.println("--------------------\n");
    }

    /**
     * Views details of a specific task by its ID.
     * @param taskId The ID of the task to view.
     * @throws TaskNotFoundException if the task ID does not exist.
     */
    public void viewTask(int taskId) throws TaskNotFoundException {
        Task task = findTaskById(taskId);
        if (task == null) {
            throw new TaskNotFoundException("Task with ID " + taskId + " not found.");
        }
        System.out.println("\n--- Task Details ---");
        System.out.println(task);
        System.out.println("--------------------\n");
    }

    /**
     * Helper method to find a task by its ID in the allTasks list.
     * Iterates through the ArrayList to find the task.
     * @param taskId The ID to search for.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        // Iterate through the ArrayList to find the task
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }
}

/**
 * Main application class for the console-based Task Management System.
 * Demonstrates usage of Queue, List, Scanner, Switch, Exception Handling.
 */
public class TaskManagerApp {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs the TaskManagerApp.
     */
    public TaskManagerApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Queued Task");
        System.out.println("3. Complete Task by ID");
        System.out.println("4. List All Tasks");
        System.out.println("5. List Queued Tasks");
        System.out.println("6. View Task by ID");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling for the user interaction loop.
     */
    public void run() {
        int choice = 0;
        // Class-wide exception handling using try-catch around the main loop
        try {
            while (choice != 7) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over after reading int

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            // Basic input validation
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Task description cannot be empty.");
                            } else {
                                Task newTask = taskManager.addTask(description.trim());
                                System.out.println("Task added: " + newTask);
                            }
                            break;
                        case 2:
                            Task processedTask = taskManager.processNextQueuedTask();
                            if (processedTask != null) {
                                System.out.println("Processing task: " + processedTask);
                            } else {
                                System.out.println("No tasks in the queue to process.");
                            }
                            break;
                        case 3:
                            System.out.print("Enter ID of task to complete: ");
                            int completeId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.completeTask(completeId); // completeTask throws TaskNotFoundException
                            break;
                        case 4:
                            taskManager.listAllTasks();
                            break;
                        case 5:
                            taskManager.listQueuedTasks();
                            break;
                        case 6:
                            System.out.print("Enter ID of task to view: ");
                            int viewId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.viewTask(viewId); // viewTask throws TaskNotFoundException
                            break;
                        case 7:
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            // Error message for invalid menu choice using System.err
                            System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                    }
                } catch (InputMismatchException e) {
                    // Catching specific input errors using System.err
                    System.err.println("Invalid input. Please enter a valid number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    choice = 0; // Reset choice to 0 to re-display menu and prevent exiting
                } catch (TaskNotFoundException e) {
                    // Catching custom exception using System.err
                    System.err.println("Error: " + e.getMessage());
                } catch (Exception e) {
                    // Catching any other unexpected exceptions using System.err
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging
                }
            }
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run();
    }
}
