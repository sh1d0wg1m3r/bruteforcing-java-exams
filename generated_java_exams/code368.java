/*
 * Exam Question #368
 * Generated on: 2025-05-11 23:01:07
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a console-based system to manage tasks in a simple processing pipeline. Tasks are added to a queue for pending work and, once processed, are moved to a list of completed tasks. The system should provide a menu-driven interface for user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **`Task` Class:**
 *     *   Create a class named `Task` to represent a single task.
 *     *   It must have private fields: `id` (an integer, unique identifier), `description` (a String), and `status` (a String, e.g., "Pending", "Completed").
 *     *   Include a constructor `Task(int id, String description)` that initializes the `id`, `description`, and sets the initial `status` to "Pending".
 *     *   Include public getter methods for `id`, `description`, and `status`.
 *     *   Include a public method `markAsCompleted()` that changes the task's status to "Completed".
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., "[ID] Description - Status").
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Create a class named `TaskProcessor` to manage the collections of tasks.
 *     *   It must have a private field `pendingTasks` of type `java.util.Queue<Task>`. Initialize it using a suitable `Queue` implementation (e.g., `LinkedList`).
 *     *   It must have a private field `completedTasks` of type `java.util.List<Task>`. Initialize it using `java.util.ArrayList`.
 *     *   Include a private integer field `nextTaskId` initialized to 1, used to generate unique task IDs.
 *     *   Include a public method `addTask(String description)`:
 *         *   Validates that the description is not null or empty. If invalid, print an error using `System.err` and return.
 *         *   Creates a new `Task` object using `nextTaskId` and the provided description.
 *         *   Adds the new task to the `pendingTasks` queue.
 *         *   Increments `nextTaskId`.
 *         *   Prints a confirmation message using `System.out`.
 *     *   Include a public method `processNextTask()`:
 *         *   Removes the task at the front of the `pendingTasks` queue.
 *         *   If the queue is empty, print an error message using `System.err` and return.
 *         *   Calls `markAsCompleted()` on the retrieved task.
 *         *   Adds the completed task to the `completedTasks` list.
 *         *   Prints a confirmation message using `System.out`, showing the processed task.
 *     *   Include a public method `viewPendingTasks()`:
 *         *   Iterates through the `pendingTasks` queue (without removing elements) and prints each task's `toString()` representation using `System.out`.
 *         *   If the queue is empty, print a message indicating that.
 *     *   Include a public method `viewCompletedTasks()`:
 *         *   Iterates through the `completedTasks` list and prints each task's `toString()` representation using `System.out`.
 *         *   If the list is empty, print a message indicating that.
 *     *   Ensure proper encapsulation for all fields.
 * 
 * 3.  **`Main` Class:**
 *     *   Create a class named `Main` with the standard `public static void main(String[] args)` method.
 *     *   Inside `main`, create an instance of `TaskProcessor`.
 *     *   Use `java.util.Scanner` to read user input from the console. Ensure the `Scanner` is properly closed.
 *     *   Implement a main application loop that continues until the user chooses to exit.
 *     *   Inside the loop, display a menu of options to the user using `System.out`:
 *         *   1: Add New Task
 *         *   2: Process Next Task
 *         *   3: View Pending Tasks
 *         *   4: View Completed Tasks
 *         *   5: Exit
 *     *   Read the user's menu choice using the `Scanner`.
 *     *   Use a `switch` statement based on the user's choice to call the appropriate methods on the `TaskProcessor` instance or exit the program.
 *     *   Implement class-wide exception handling within the main loop using `try-catch` blocks. Specifically, handle `java.util.InputMismatchException` if the user enters non-integer input for the menu choice, and catch a general `Exception` for any other unexpected errors during the loop iteration. Use `System.err` to print error messages for caught exceptions. The loop should continue after catching an exception.
 *     *   Handle the "Add New Task" option: prompt the user for the task description using `System.out`, read the line using `Scanner`, and pass it to the `addTask` method.
 *     *   Handle the "Exit" option to terminate the loop and the program.
 *     *   Include necessary comments and documentation (Javadoc where appropriate).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, and printing status messages, task lists, or error messages based on the user's actions.
 * 
 * *   Adding a task should show a confirmation.
 * *   Processing a task should show which task was processed.
 * *   Viewing queues/lists should display the current contents or indicate if they are empty.
 * *   Attempting to process an empty queue should result in an error message on `System.err`.
 * *   Entering invalid menu input should result in an error message on `System.err` and the menu being redisplayed.
 * *   Entering an empty task description should result in an error message on `System.err`.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all requirements.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Input validation and error handling.
 * *   Code clarity, readability, and documentation.
 * *   Correct output formatting.
 *
 * EXPLANATION:
 * This solution implements a simple task processing system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a task with `id`, `description`, and `status`.
 *     *   Uses private fields and public getters for encapsulation.
 *     *   Includes a method `markAsCompleted` to change the state, demonstrating object behavior.
 *     *   Overrides `toString` for easy printing.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Acts as the controller for managing tasks.
 *     *   Uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to maintain tasks in a First-In, First-Out (FIFO) order, simulating a processing queue.
 *     *   Uses a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store completed tasks, allowing dynamic resizing and access to the history. The use of the `List` interface for the variable type demonstrates polymorphism.
 *     *   `addTask` uses `queue.offer()` which is the preferred method for adding to a queue as it returns `false` if the add fails (though `LinkedList` doesn't typically fail unless memory is exhausted). It includes basic input validation for the description.
 *     *   `processNextTask` uses `queue.poll()` which retrieves and removes the head of the queue, returning `null` if the queue is empty. This null return is explicitly checked to handle the empty queue scenario gracefully using `System.err`.
 *     *   `viewPendingTasks` iterates through the `Queue` using an enhanced for loop, which utilizes the queue's iterator without removing elements.
 *     *   `viewCompletedTasks` iterates through the `List` using an enhanced for loop.
 *     *   `nextTaskId` ensures each task gets a unique ID.
 * 
 * 3.  **`Main` Class:**
 *     *   The entry point of the application.
 *     *   Creates instances of `TaskProcessor` and `Scanner`.
 *     *   The core logic is within a `while` loop, running until the `running` flag is set to `false`.
 *     *   A `try-catch` block wraps the main loop's operations. This provides class-wide exception handling.
 *         *   `InputMismatchException` is caught specifically for errors when reading the integer menu choice, preventing the program from crashing and consuming the invalid input line to avoid an infinite loop.
 *         *   A general `Exception` catch block is included as a fallback for any other unexpected errors that might occur during an iteration, demonstrating robust error handling. Error messages are printed to `System.err`.
 *     *   A `switch` statement is used to direct control flow based on the valid user input, calling the appropriate methods on the `TaskProcessor`.
 *     *   `System.out` is used for displaying the menu, prompts, and successful operation messages. `System.err` is reserved for error output as required.
 *     *   The `Scanner` is closed outside the loop to release system resources.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, object-oriented structure, demonstrating understanding of data structures, control flow, input/output, error handling, and basic OOP principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the processing system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Tasks start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string showing task details.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + description + " - " + status;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessor {
    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List for completed tasks (ArrayList implementation)
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessor, initializing task collections.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        // --- Input Validation ---
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add in queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     */
    public void processNextTask() {
        // --- Handle Empty Queue ---
        Task taskToProcess = pendingTasks.poll(); // poll returns null if queue is empty

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        taskToProcess.markAsCompleted();
        completedTasks.add(taskToProcess);
        System.out.println("Task processed: " + taskToProcess);
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate without removing using the Queue's iterator
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main class to run the Task Processing System.
 * Handles user interaction via console menu.
 */
public class Main {

    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // --- Main Application Loop with Class-wide Exception Handling ---
        while (running) {
            try {
                printMenu();
                System.out.print("Enter your choice: ");

                // --- Read Menu Choice ---
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // --- Process Menu Choice using Switch ---
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(description);
                        break;
                    case 2:
                        processor.processNextTask();
                        break;
                    case 3:
                        processor.viewPendingTasks();
                        break;
                    case 4:
                        processor.viewCompletedTasks();
                        break;
                    case 5:
                        running = false; // Exit the loop
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break;
                    default:
                        // --- Handle Invalid Menu Option ---
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // --- Handle Non-integer Input ---
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // --- Catch Any Other Unexpected Exceptions ---
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
            System.out.println(); // Add a blank line for better readability
        }

        // --- Close Scanner ---
        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }
}
