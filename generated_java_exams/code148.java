/*
 * Exam Question #148
 * Generated on: 2025-05-11 22:21:36
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Appointment Scheduling System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified appointment scheduling system for a small hospital clinic. The system needs to manage patient appointment bookings with doctors. Due to limited resources, there's a maximum number of appointments the clinic can handle at any given time. If the maximum capacity is reached, new appointment requests are placed on a waiting list.
 * 
 * Your program should provide a command-line interface for users (clinic staff) to interact with the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.List` (specifically implemented as `java.util.ArrayList`) to store currently booked appointments.
 *     *   Use a `java.util.Queue` (specifically implemented as `java.util.LinkedList`) to manage the waiting list of appointment requests.
 * 2.  **Appointment Representation:**
 *     *   Create a simple `Appointment` class (or equivalent structure) to hold details like `patientName`, `doctorName`, `appointmentDate`, and `appointmentTime`. Ensure proper encapsulation.
 * 3.  **Core Functionality:**
 *     *   **Book Appointment:** Allow the user to enter details for a new appointment.
 *         *   If the number of currently booked appointments is less than a predefined maximum capacity (e.g., 5), add the appointment to the booked list.
 *         *   If the booked list is at maximum capacity, add the appointment request to the waiting list queue.
 *     *   **View Booked Appointments:** Display all currently booked appointments.
 *     *   **View Waiting List:** Display all appointment requests currently in the waiting list queue.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Book, View Booked, View Waiting, Exit).
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, successful operations (booking confirmed, added to waiting list, listing appointments/waiting list), and general information.
 *     *   Use `System.err` for displaying error messages, such as invalid menu options or issues during input processing (e.g., empty required fields).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during the program execution loop.
 *     *   Include input validation for appointment details (e.g., ensure patient name is not empty).
 * 6.  **Best Practices:**
 *     *   Employ meaningful variable and method names.
 *     *   Add comments where necessary to explain complex logic.
 *     *   Maintain a clean code structure.
 *     *   Ensure proper encapsulation for data fields.
 * 
 * **Maximum Capacity:** Define a constant for the maximum number of booked appointments (e.g., `private static final int MAX_CAPACITY = 5;`).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it should display a menu. Based on user input, it should perform the requested action, printing results to `System.out` or errors to `System.err`. The program should continue until the user chooses the "Exit" option.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Appointment Scheduling System ---
 * 1. Book Appointment
 * 2. View Booked Appointments
 * 3. View Waiting List
 * 4. Exit
 * Enter your choice: 1
 * Enter Patient Name: Alice
 * Enter Doctor Name: Dr. Smith
 * Enter Date (YYYY-MM-DD): 2023-12-15
 * Enter Time (HH:MM): 10:00
 * Appointment booked successfully for Alice with Dr. Smith on 2023-12-15 at 10:00.
 * 
 * --- Appointment Scheduling System ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter Patient Name: Bob
 * ... (details) ...
 * Appointment booked successfully for Bob ...
 * 
 * --- Appointment Scheduling System ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter Patient Name: Charlie
 * ... (details) ...
 * Added Charlie to the waiting list for appointment with Dr. Jones on 2023-12-16 at 11:00.
 * 
 * --- Appointment Scheduling System ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * --- Booked Appointments ---
 * Patient: Alice, Doctor: Dr. Smith, Date: 2023-12-15, Time: 10:00
 * Patient: Bob, Doctor: Dr. Brown, Date: 2023-12-15, Time: 10:30
 * --- End of Booked Appointments ---
 * 
 * --- Appointment Scheduling System ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * --- Waiting List ---
 * Patient: Charlie, Doctor: Dr. Jones, Date: 2023-12-16, Time: 11:00
 * --- End of Waiting List ---
 * 
 * --- Appointment Scheduling System ---
 * ... (menu repeats) ...
 * Enter your choice: 4
 * Exiting system.
 * ```
 * 
 * Implement the solution in a single Java file named `AppointmentScheduler.java`.
 *
 * EXPLANATION:
 * This solution implements a basic hospital appointment scheduling system demonstrating the required Java concepts.
 * 
 * 1.  **`Appointment` Class:** A simple class to encapsulate appointment details (`patientName`, `doctorName`, `appointmentDate`, `appointmentTime`). It has a constructor and getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to print appointment information.
 * 
 * 2.  **`AppointmentScheduler` Class:** This is the main class containing the system logic.
 *     *   **Data Structures:**
 *         *   `private List<Appointment> bookedAppointments = new ArrayList<>();`: Declares a field using the `List` interface type, but initializes it with an `ArrayList`. This demonstrates programming to the interface, while using a concrete implementation (`ArrayList`) which is suitable for storing and iterating over booked appointments.
 *         *   `private Queue<Appointment> waitingList = new LinkedList<>();`: Declares a field using the `Queue` interface type, initialized with a `LinkedList`. `LinkedList` is a common implementation for `Queue` in Java and is suitable for managing a waiting list where elements are added to the end and processed from the beginning (though in this simplified version, we only add and view).
 *     *   **`MAX_CAPACITY` Constant:** A `private static final int` is used to define the maximum number of appointments allowed in the `bookedAppointments` list, making the code readable and easy to modify.
 *     *   **`Scanner`:** A `Scanner` object is created to read input from `System.in`. It's declared as a class field and closed in a `finally` block to ensure resource cleanup.
 *     *   **`main` Method:** The entry point of the program. It creates an `AppointmentScheduler` instance and calls the `run()` method. It includes a top-level `try-catch-finally` block for class-wide exception handling, ensuring that any unexpected errors are caught and reported to `System.err`, and the scanner is closed.
 *     *   **`run()` Method:** Contains the main program loop (`do-while`).
 *         *   It repeatedly prints the menu (`printMenu()`).
 *         *   It reads the user's choice using `scanner.nextLine()` and attempts to parse it as an integer. Reading the entire line and then parsing is safer than `nextInt()` as it consumes the newline character.
 *         *   A nested `try-catch` is used specifically for handling `NumberFormatException` if the user enters non-integer input for the menu choice, printing an error to `System.err`.
 *         *   A `switch` statement is used to direct program flow based on the valid integer choice.
 *         *   A general `catch` block inside the loop handles any other exceptions that might occur during the execution of the chosen action (e.g., within `bookAppointment`).
 *         *   The loop continues until the user enters `4`.
 *     *   **`printMenu()`:** A simple private helper method to display the menu options using `System.out`.
 *     *   **`bookAppointment()`:**
 *         *   Prompts the user for appointment details using `System.out`.
 *         *   Reads input using `scanner.nextLine()`.
 *         *   Includes basic input validation using `isEmpty()` and `trim()`. If validation fails, an error is printed to `System.err`, and the method returns.
 *         *   Creates a new `Appointment` object.
 *         *   Checks the size of the `bookedAppointments` list against `MAX_CAPACITY`.
 *         *   If capacity is available, the appointment is added to the `bookedAppointments` `List` using `add()`, and a success message is printed to `System.out`.
 *         *   If capacity is full, the appointment is added to the `waitingList` `Queue` using `offer()` (a standard Queue method for adding). A message indicating addition to the waiting list is printed to `System.out`.
 *     *   **`viewBookedAppointments()`:** Iterates through the `bookedAppointments` `List` using an enhanced for loop and prints each `Appointment` object (using its `toString()` method) to `System.out`. Includes a check for an empty list.
 *     *   **`viewWaitingList()`:** Iterates through the `waitingList` `Queue` using an enhanced for loop. This iteration uses the `Iterable` nature of `Queue` but does *not* remove elements, which is appropriate for simply viewing the list contents. Includes a check for an empty queue. Prints details to `System.out`.
 *     *   **`closeScanner()`:** A private helper method called in the `finally` block to close the `Scanner` resource, preventing resource leaks.
 * 
 * This solution effectively combines the required data structures (`List`, `Queue`, `ArrayList`), input handling (`Scanner`), flow control (`switch`), output streams (`System.out`, `System.err`), exception handling (`try-catch`), and object-oriented principles (encapsulation, methods) to solve the problem.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single appointment
class Appointment {
    private String patientName;
    private String doctorName;
    private String appointmentDate; // Simple String representation for date/time
    private String appointmentTime; // Simple String representation for date/time

    // Constructor
    public Appointment(String patientName, String doctorName, String appointmentDate, String appointmentTime) {
        this.patientName = patientName;
        this.doctorName = doctorName;
        this.appointmentDate = appointmentDate;
        this.appointmentTime = appointmentTime;
    }

    // Getters (no setters needed for this problem's scope)
    public String getPatientName() {
        return patientName;
    }

    public String getDoctorName() {
        return doctorName;
    }

    public String getAppointmentDate() {
        return appointmentDate;
    }

    public String getAppointmentTime() {
        return appointmentTime;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Patient: " + patientName + ", Doctor: " + doctorName +
               ", Date: " + appointmentDate + ", Time: " + appointmentTime;
    }
}

// Main class for the Appointment Scheduling System
public class AppointmentScheduler {

    // Maximum number of simultaneously booked appointments
    private static final int MAX_CAPACITY = 5;

    // List to store currently booked appointments (using List interface)
    private List<Appointment> bookedAppointments;

    // Queue to store appointment requests on the waiting list
    private Queue<Appointment> waitingList;

    // Scanner for user input (declared as a field to be closed properly)
    private Scanner scanner;

    // Constructor
    public AppointmentScheduler() {
        // Use ArrayList as the concrete implementation for List
        this.bookedAppointments = new ArrayList<>();
        // Use LinkedList as the concrete implementation for Queue
        this.waitingList = new LinkedList<>();
        this.scanner = new Scanner(System.in);
    }

    // Main method to run the system
    public static void main(String[] args) {
        AppointmentScheduler scheduler = new AppointmentScheduler();
        // Class-wide exception handling around the main interaction loop
        try {
            scheduler.run();
        } catch (Exception e) {
            // Catch any unexpected exceptions and print to System.err
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed even if an exception occurs
            scheduler.closeScanner();
        }
    }

    // Main loop for the scheduler
    public void run() {
        int choice;
        do {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use a nested try-catch for reading the choice to handle non-integer input
            try {
                choice = Integer.parseInt(scanner.nextLine()); // Read line to avoid issues with nextInt()

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        bookAppointment();
                        break;
                    case 2:
                        viewBookedAppointments();
                        break;
                    case 3:
                        viewWaitingList();
                        break;
                    case 4:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Use System.err for invalid menu options
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (NumberFormatException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                choice = 0; // Set choice to 0 to continue the loop
            } catch (Exception e) {
                // Catch any other exceptions within the loop iteration
                System.err.println("An error occurred during operation: " + e.getMessage());
                e.printStackTrace();
                choice = 0; // Set choice to 0 to continue the loop
            }
            System.out.println(); // Add a newline for better readability
        } while (choice != 4);
    }

    // Prints the main menu
    private void printMenu() {
        System.out.println("--- Appointment Scheduling System ---");
        System.out.println("1. Book Appointment");
        System.out.println("2. View Booked Appointments");
        System.out.println("3. View Waiting List");
        System.out.println("4. Exit");
    }

    // Handles the process of booking a new appointment
    private void bookAppointment() {
        System.out.println("Enter Patient Name: ");
        String patientName = scanner.nextLine().trim(); // Use trim() to remove leading/trailing spaces

        // Input validation
        if (patientName.isEmpty()) {
            System.err.println("Error: Patient Name cannot be empty.");
            return; // Exit the method if input is invalid
        }

        System.out.println("Enter Doctor Name: ");
        String doctorName = scanner.nextLine().trim();
        if (doctorName.isEmpty()) {
             System.err.println("Error: Doctor Name cannot be empty.");
             return;
        }

        System.out.println("Enter Date (YYYY-MM-DD): ");
        String appointmentDate = scanner.nextLine().trim();
         if (appointmentDate.isEmpty()) {
             System.err.println("Error: Date cannot be empty.");
             return;
        }

        System.out.println("Enter Time (HH:MM): ");
        String appointmentTime = scanner.nextLine().trim();
         if (appointmentTime.isEmpty()) {
             System.err.println("Error: Time cannot be empty.");
             return;
        }


        Appointment newAppointment = new Appointment(patientName, doctorName, appointmentDate, appointmentTime);

        // Check capacity and add to appropriate list/queue
        if (bookedAppointments.size() < MAX_CAPACITY) {
            bookedAppointments.add(newAppointment); // Add to List
            System.out.println("Appointment booked successfully for " + patientName +
                               " with " + doctorName + " on " + appointmentDate + " at " + appointmentTime + ".");
        } else {
            waitingList.offer(newAppointment); // Add to Queue (offer is preferred over add)
            System.out.println("Clinic is at full capacity. Added " + patientName +
                               " to the waiting list for appointment with " + doctorName +
                               " on " + appointmentDate + " at " + appointmentTime + ".");
        }
    }

    // Displays all currently booked appointments
    private void viewBookedAppointments() {
        System.out.println("--- Booked Appointments ---");
        if (bookedAppointments.isEmpty()) {
            System.out.println("No appointments currently booked.");
        } else {
            // Iterate through the List and print each appointment
            for (Appointment app : bookedAppointments) {
                System.out.println(app); // Uses Appointment's toString() method
            }
        }
        System.out.println("--- End of Booked Appointments ---");
    }

    // Displays all appointment requests in the waiting list
    private void viewWaitingList() {
        System.out.println("--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate through the Queue without removing elements (using enhanced for loop)
            for (Appointment app : waitingList) {
                System.out.println(app); // Uses Appointment's toString() method
            }
            // Alternative using iterator:
            // Iterator<Appointment> iterator = waitingList.iterator();
            // while (iterator.hasNext()) {
            //     System.out.println(iterator.next());
            // }
        }
        System.out.println("--- End of Waiting List ---");
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
