/*
 * Exam Question #594
 * Generated on: 2025-05-12 16:12:13
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Objective:** Design and implement a simplified Customer Support Ticket System in Java. This system will manage incoming support requests, allow agents to process them, and maintain an archive of completed tickets. You must demonstrate your understanding of fundamental data structures, user interaction, control flow, exception handling, and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   The system must allow adding new support tickets to a queue.
 *     *   The system must allow processing the next ticket from the queue (FIFO - First-In, First-Out). Processed tickets should be moved to an archive.
 *     *   The system must allow viewing the current queue of incoming tickets.
 *     *   The system must allow viewing the archive of processed tickets.
 *     *   The system must have an option to exit.
 * 
 * 2.  **Required Java Components:** Your solution *must* utilize all of the following components:
 *     *   `java.util.Queue`: To manage incoming support tickets.
 *     *   `java.util.ArrayList`: To store archived tickets.
 *     *   `java.util.List`: Declare the archive variable using the `List` interface type.
 *     *   `java.util.Scanner`: To read user input from the console.
 *     *   `switch` statement: To handle different user commands (add, process, view, exit).
 *     *   `System.err`: To output error messages (e.g., invalid input, trying to process from an empty queue).
 *     *   `System.out`: To output normal messages (e.g., menu, prompts, success messages, list contents).
 *     *   Class-wide exception handling with `try-catch` blocks: Include a general `try-catch` around the main application loop or core processing logic to catch unexpected errors, in addition to specific input handling.
 * 
 * 3.  **Data Structure Design:**
 *     *   Create a simple `Ticket` class with at least a unique ID and a description. Implement appropriate encapsulation (private fields, public getters).
 *     *   Use a `Queue` (e.g., `LinkedList` implementation) for incoming tickets.
 *     *   Use a `List` (e.g., `ArrayList` implementation) for archived tickets.
 * 
 * 4.  **User Interface:**
 *     *   Present a clear menu of options to the user.
 *     *   Prompt the user for input.
 *     *   Provide feedback messages for actions performed (e.g., ticket added, ticket processed).
 * 
 * 5.  **Error Handling & Validation:**
 *     *   Handle invalid user input gracefully (e.g., non-numeric input for menu choice, invalid menu numbers). Use `System.err` for these errors.
 *     *   Handle cases where the user tries to process a ticket when the queue is empty. Use `System.err`.
 *     *   Implement the required class-wide `try-catch` block.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex parts.
 *     *   Maintain a clean and organized code structure (e.g., separate methods for different operations).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. It should display a menu, accept user input, perform the requested action, and print relevant output or error messages. Example flow:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Incoming Queue
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My internet is slow.
 * Ticket #1 added to the queue.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Cannot access my account.
 * Ticket #2 added to the queue.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Incoming Ticket Queue ---
 * 1. Ticket [ID=1, Description='My internet is slow.']
 * 2. Ticket [ID=2, Description='Cannot access my account.']
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processed ticket #1: My internet is slow.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Incoming Ticket Queue ---
 * 1. Ticket [ID=2, Description='Cannot access my account.']
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * --- Archived Tickets ---
 * 1. Ticket [ID=1, Description='My internet is slow.']
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: invalid input
 * Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 6
 * Invalid command. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Support Ticket System...
 * Support system terminated.
 * ```
 * 
 * Your task is to provide the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Customer Support Ticket System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   The `Ticket` class encapsulates the data for a single ticket (ID and description). It uses a static counter (`nextId`) to ensure each ticket gets a unique identifier. Private fields and public getters adhere to encapsulation principles. The `toString()` method provides a convenient way to display ticket information.
 *     *   The `SupportSystem` class contains the main logic. It holds the collections (`Queue` and `List`), the `Scanner`, and the methods for each system operation.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `incomingTickets` variable is declared as `Queue<Ticket>` and instantiated as a `LinkedList`. `offer()` is used to add elements (enqueue), and `poll()` is used to remove elements from the head (dequeue). This correctly implements the FIFO behavior required for a ticket queue.
 *     *   `java.util.ArrayList`: The `archivedTickets` variable is instantiated as an `ArrayList`.
 *     *   `java.util.List`: The `archivedTickets` variable is declared using the `List<Ticket>` interface type, promoting good practice by programming to an interface rather than a specific implementation. `add()` is used to add processed tickets to the archive.
 *     *   `java.util.Scanner`: An instance of `Scanner` reads user input from `System.in`. `nextInt()` is used for reading the menu choice, and `nextLine()` is used for reading the ticket description and consuming the newline character after `nextInt()`.
 *     *   `switch` statement: Located in the `run()` method, the `switch` statement directs the program flow based on the integer command received from the user (`choice`).
 *     *   `System.err`: Used in `getUserChoice()` for invalid non-integer input, in `addTicket()` for empty description, and in `processTicket()` when the queue is empty. Also used in the general `try-catch` for unexpected errors.
 *     *   `System.out`: Used extensively for displaying the menu, prompts, success messages, and the contents of the queue and archive lists.
 *     *   `try-catch`:
 *         *   Specific `try-catch (InputMismatchException e)` is used in `getUserChoice()` to handle cases where the user enters non-numeric input when an integer is expected. This prevents the program from crashing and allows it to prompt the user again.
 *         *   A general `try-catch (Exception e)` wraps the main `while` loop in the `run()` method. This demonstrates class-wide exception handling, catching any unhandled exceptions that might occur during the execution of the main program loop and printing an error message and stack trace to `System.err`.
 * 
 * 3.  **Flow Control and Logic:**
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   Inside the loop, the menu is displayed, user input is obtained, and the `switch` statement executes the corresponding method (`addTicket`, `processTicket`, etc.).
 *     *   The `getUserChoice()` method handles reading the integer input and basic validation (checking for non-integers).
 *     *   Methods like `processTicket()` include checks (`incomingTickets.isEmpty()`) before attempting operations that could fail, providing informative error messages via `System.err`.
 *     *   The `exitSystem()` method simply sets the `running` flag to `false`, causing the main loop to terminate gracefully after the current iteration.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** The `Ticket` class fields are private, accessed via public methods. The `SupportSystem`'s internal state (collections, scanner, running flag) is private, with operations exposed via public/private methods.
 *     *   **Meaningful Names:** Variables like `incomingTickets`, `archivedTickets`, `description`, and methods like `addTicket`, `processTicket`, `viewQueue`, `getUserChoice` are descriptive.
 *     *   **Comments:** Javadoc comments are included for classes and methods, explaining their purpose. Inline comments clarify specific lines or blocks.
 *     *   **Input Validation:** Checks are performed for empty ticket descriptions and non-integer menu input.
 *     *   **Error Handling:** Specific input errors are caught, logical errors (empty queue) are checked, and a general catch handles unexpected issues. Error messages go to `System.err`.
 *     *   **Clean Structure:** Logic is broken down into smaller, focused methods (`addTicket`, `processTicket`, `viewQueue`, `viewArchive`, `getUserChoice`, `displayMenu`).
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block within the `run()` method, ensuring it's closed even if an exception occurs.
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating understanding of data structures, control flow, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList; // Common implementation for List
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs
    private int id;
    private String description;

    /**
     * Constructs a new Ticket with a unique ID and description.
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
    }

    // Getter for ticket ID
    public int getId() {
        return id;
    }

    // Getter for ticket description
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return A formatted string including Ticket ID and Description.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "']";
    }
}

// Main class for the Support Ticket System
public class SupportSystem {

    // Queue to hold incoming tickets (FIFO)
    private Queue<Ticket> incomingTickets = new LinkedList<>();

    // List to archive processed tickets
    private List<Ticket> archivedTickets = new ArrayList<>();

    // Scanner for reading user input
    private Scanner scanner = new Scanner(System.in);

    // Flag to control the main application loop
    private boolean running = true;

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run(); // Start the system's main loop
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide try-catch block to handle unexpected exceptions
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice(); // Get and validate user input

                // Switch statement to control flow based on user choice
                switch (choice) {
                    case 1:
                        addTicket(); // Add a new ticket
                        break;
                    case 2:
                        processTicket(); // Process the next ticket from the queue
                        break;
                    case 3:
                        viewQueue(); // View the incoming ticket queue
                        break;
                    case 4:
                        viewArchive(); // View the archived tickets
                        break;
                    case 5:
                        exitSystem(); // Exit the application
                        break;
                    default:
                        // This case is primarily for numbers outside 1-5 range
                        // InputMismatchException is handled in getUserChoice
                        if (choice != -1) { // Avoid printing error for InputMismatchException already handled
                            System.err.println("Invalid command. Please enter a number between 1 and 5.");
                        }
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed when the application finishes or errors out
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Support system terminated."); // Final message upon exit
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Archived Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles InputMismatchException for non-integer input.
     * @return The valid integer choice, or -1 if input was invalid.
     */
    private int getUserChoice() {
        int choice = -1; // Default to -1 for invalid input
        try {
            choice = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();
        } catch (InputMismatchException e) {
            // Handle cases where the user enters non-integer input
            System.err.println("Invalid input. Please enter a number.");
            // Consume the invalid input from the scanner to prevent infinite loop
            scanner.nextLine();
        }
        return choice;
    }

    /**
     * Prompts the user for a ticket description and adds a new ticket to the queue.
     */
    private void addTicket() {
        System.out.print("Enter ticket description: ");
        // Read the full line for description
        String description = scanner.nextLine();

        // Input validation: Check if description is empty or just whitespace
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Ticket description cannot be empty.");
            return; // Exit the method if input is invalid
        }

        Ticket newTicket = new Ticket(description);
        incomingTickets.offer(newTicket); // Add the ticket to the end of the queue

        System.out.println("Ticket #" + newTicket.getId() + " added to the queue.");
    }

    /**
     * Processes the next ticket in the queue (removes it) and moves it to the archive.
     * Handles the case where the queue is empty.
     */
    private void processTicket() {
        if (incomingTickets.isEmpty()) {
            // Output error message to System.err if queue is empty
            System.err.println("No tickets in the queue to process.");
        } else {
            // Remove the head of the queue (FIFO)
            Ticket processedTicket = incomingTickets.poll();
            // Add the processed ticket to the archive list
            archivedTickets.add(processedTicket);

            System.out.println("Processed ticket #" + processedTicket.getId() + ": " + processedTicket.getDescription());
        }
    }

    /**
     * Displays the current tickets in the incoming queue.
     * Iterates without removing elements.
     */
    private void viewQueue() {
        System.out.println("--- Incoming Ticket Queue ---");
        if (incomingTickets.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue elements
            int count = 1;
            for (Ticket ticket : incomingTickets) {
                System.out.println(count++ + ". " + ticket);
            }
        }
    }

    /**
     * Displays the tickets that have been processed and archived.
     * Iterates through the archive list.
     */
    private void viewArchive() {
        System.out.println("--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("No tickets have been archived yet.");
        } else {
            // Iterate through the archived list elements
            int count = 1;
            for (Ticket ticket : archivedTickets) {
                System.out.println(count++ + ". " + ticket);
            }
        }
    }

    /**
     * Sets the flag to false to exit the main application loop.
     */
    private void exitSystem() {
        System.out.println("Exiting Support Ticket System...");
        running = false; // This will cause the while loop in run() to terminate
        // Scanner is closed in the finally block of run()
    }
}
