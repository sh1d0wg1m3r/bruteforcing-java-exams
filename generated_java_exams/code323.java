/*
 * Exam Question #323
 * Generated on: 2025-05-11 22:55:04
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Process Scheduler Simulation**
 * 
 * **Objective:**
 * Implement a simple command-line process scheduler simulation in Java. The scheduler manages tasks that are in a ready queue waiting to be processed and moves them to a completed list after processing.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `taskId` (int): A unique identifier generated by the scheduler.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (e.g., 1-10, lower number = higher priority, but for this simulation, processing is FIFO from the queue).
 *     *   `state` (enum `TaskState`): An enum with states `READY` and `COMPLETED`.
 *     *   Implement appropriate constructor, getters, and a `toString()` method for easy printing. Ensure proper encapsulation.
 * 
 * 2.  **Scheduler Implementation:** Create a class `ProcessScheduler` that manages the tasks. It should have:
 *     *   A `Queue<Task>` to hold tasks that are ready to be processed. Use `java.util.LinkedList` as the concrete implementation for the Queue.
 *     *   A `List<Task>` to hold tasks that have been completed. Use `java.util.ArrayList` as the concrete implementation for the List.
 *     *   A counter to generate unique `taskId` values starting from 1.
 *     *   Methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` with state `READY`, assigns a unique ID, and adds it to the ready queue. Validate input: description must not be empty, priority must be a positive integer.
 *         *   `processNextTask()`: Removes the task at the front of the ready queue, changes its state to `COMPLETED`, and adds it to the completed tasks list. If the queue is empty, report an error.
 *         *   `listAllTasks()`: Prints all tasks currently in the ready queue followed by all tasks in the completed list. Indicate which list each task belongs to.
 *         *   `run()`: The main loop that interacts with the user via `Scanner`. It should display a menu and process user commands until the user chooses to exit.
 * 
 * 3.  **User Interface:** The `run()` method should present a menu with the following options:
 *     *   `1: Add Task`
 *     *   `2: Process Next Task`
 *     *   `3: List All Tasks`
 *     *   `4: Exit`
 *     *   Read user input using `java.util.Scanner`.
 * 
 * 4.  **Control Flow:** Use a `switch` statement within the `run()` method to handle the user's menu choice.
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   Use `System.err` to report errors such as invalid menu choices, empty task descriptions, invalid priority values, or attempting to process when the queue is empty.
 *     *   Handle potential `InputMismatchException` or `NumberFormatException` when reading user input for menu choice or priority.
 *     *   Implement class-wide exception handling using a `try-catch` block in the `run()` method to catch any unexpected exceptions during the main loop execution, printing an error message to `System.err`.
 * 
 * 6.  **Output:** Use `System.out` for menu prompts, successful operation confirmations (e.g., "Task added successfully"), and listing tasks.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * The program should run interactively. Users enter numbers corresponding to menu options. The output should clearly indicate the result of each operation (task added, task processed, list of tasks). Error messages should be distinct using `System.err`.
 * 
 * **Example Interaction:**
 * 
 * ```
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 1
 * Enter task description: Implement login
 * Enter priority (1-10): 5
 * Task added successfully with ID 1.
 * 
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 1
 * Enter task description: Design database
 * Enter priority (1-10): 8
 * Task added successfully with ID 2.
 * 
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 3
 * --- Ready Queue ---
 * Task{taskId=1, description='Implement login', priority=5, state=READY}
 * Task{taskId=2, description='Design database', priority=8, state=READY}
 * --- Completed Tasks ---
 * (Empty)
 * 
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 2
 * Processing task: Task{taskId=1, description='Implement login', priority=5, state=READY}
 * Task ID 1 processed and moved to completed.
 * 
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 3
 * --- Ready Queue ---
 * Task{taskId=2, description='Design database', priority=8, state=READY}
 * --- Completed Tasks ---
 * Task{taskId=1, description='Implement login', priority=5, state=COMPLETED}
 * 
 * --- Process Scheduler Menu ---
 * 1: Add Task
 * 2: Process Next Task
 * 3: List All Tasks
 * 4: Exit
 * Enter your choice: 4
 * Exiting scheduler.
 * ```
 * 
 * **Submission:** Provide the complete Java code for the `TaskState` enum, `Task` class, and `ProcessScheduler` class (including the `main` method).
 *
 * EXPLANATION:
 * This solution implements a simple process scheduler simulation, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Class:** The `Task` class encapsulates the data for each task (`taskId`, `description`, `priority`, `state`). It uses private fields and public getter methods, demonstrating proper encapsulation. The `TaskState` enum clearly defines the possible states of a task (`READY`, `COMPLETED`). The `setState` method allows controlled modification of the task's state. The `toString()` method provides a convenient way to represent a task as a string for printing.
 * 
 * 2.  **ProcessScheduler Class:**
 *     *   **Data Structures:** It uses `java.util.Queue<Task>` (specifically `LinkedList`) for the `readyQueue`, representing tasks waiting to be processed in a FIFO (First-In, First-Out) manner. It uses `java.util.List<Task>` (specifically `ArrayList`) for the `completedTasks`, allowing easy storage and iteration over finished tasks.
 *     *   **`addTask` Method:** Creates a new `Task` instance, assigns a unique ID using `nextTaskId++`, and adds it to the `readyQueue` using `offer()`. It includes input validation for the description (checking for null or empty) and priority (checking if positive), reporting errors to `System.err`.
 *     *   **`processNextTask` Method:** Retrieves and removes the head of the `readyQueue` using `poll()`. If the queue is empty, `poll()` returns `null`, which is handled with an error message to `System.err`. If a task is retrieved, its state is updated to `COMPLETED`, and it's added to the `completedTasks` list using `add()`.
 *     *   **`listAllTasks` Method:** Iterates through both the `readyQueue` and `completedTasks` list, printing each task's `toString()` representation. It clearly labels which list is being displayed and handles the case where a list is empty.
 *     *   **`run` Method:** This is the main interactive loop. It repeatedly displays the menu, reads user input using `Scanner`, and uses a `switch` statement to direct execution based on the user's choice.
 *     *   **Input Handling:** Inside the `run` method's loop, there's a nested `try-catch` block specifically for handling `InputMismatchException` that might occur if the user enters non-integer input when a number is expected (for menu choice or priority). It also consumes the invalid input from the scanner to prevent an infinite loop.
 *     *   **Error Handling (`System.err`):** `System.err` is used consistently for reporting validation errors (`addTask`), operational errors (processing from an empty queue), and invalid menu choices.
 *     *   **Class-wide Exception Handling:** The entire `while` loop within `run()` is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected runtime exceptions that might occur anywhere within the loop's execution, providing a general error message to `System.err` and preventing the program from crashing abruptly. A `finally` block ensures the `Scanner` resource is closed when the `run` method finishes (either by exiting the loop or due to an exception).
 * 
 * 3.  **Main Method:** The `main` method simply creates an instance of `ProcessScheduler` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical simulation, demonstrating understanding of data structures, object-oriented principles (encapsulation), input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the state of a task.
 */
enum TaskState {
    READY,
    COMPLETED
}

/**
 * Represents a single task in the process scheduler.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // Lower number usually means higher priority, but not used for scheduling logic here
    private TaskState state;

    /**
     * Constructs a new Task.
     *
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.state = TaskState.READY; // Tasks start in the READY state
    }

    // --- Getters ---

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The task priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Gets the current state of the task.
     * @return The task state.
     */
    public TaskState getState() {
        return state;
    }

    // --- State Mutator ---

    /**
     * Sets the state of the task.
     * @param state The new state for the task.
     */
    public void setState(TaskState state) {
        this.state = state;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task{" +
               "taskId=" + taskId +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               ", state=" + state +
               '}';
    }
}

/**
 * Simulates a simple process scheduler managing tasks.
 */
public class ProcessScheduler {

    private Queue<Task> readyQueue;
    private List<Task> completedTasks;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new ProcessScheduler.
     */
    public ProcessScheduler() {
        // Use LinkedList as a concrete implementation for Queue
        this.readyQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation for List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the ready queue.
     *
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String description, int priority) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        if (priority <= 0) {
            System.err.println("Error: Task priority must be a positive integer.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        readyQueue.offer(newTask); // Add task to the end of the ready queue
        System.out.println("Task added successfully with ID " + newTask.getTaskId() + ".");
    }

    /**
     * Processes the next task from the ready queue.
     * Moves the task to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = readyQueue.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: Ready queue is empty. No tasks to process.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);

        // Simulate processing (just change state and move)
        taskToProcess.setState(TaskState.COMPLETED);
        completedTasks.add(taskToProcess); // Add to the completed list

        System.out.println("Task ID " + taskToProcess.getTaskId() + " processed and moved to completed.");
    }

    /**
     * Lists all tasks in the ready queue and completed list.
     */
    public void listAllTasks() {
        System.out.println("--- Ready Queue ---");
        if (readyQueue.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : readyQueue) {
                System.out.println(task);
            }
        }

        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate over the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Process Scheduler Menu ---");
        System.out.println("1: Add Task");
        System.out.println("2: Process Next Task");
        System.out.println("3: List All Tasks");
        System.out.println("4: Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main scheduler loop, interacting with the user.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                    // Use switch statement for menu control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter priority (positive integer): ");
                            int priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            addTask(description, priority);
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            listAllTasks();
                            break;
                        case 4:
                            System.out.println("Exiting scheduler.");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number for the menu choice or priority.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } finally {
            // Ensure scanner is closed when the program exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the process scheduler simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProcessScheduler scheduler = new ProcessScheduler();
        scheduler.run();
    }
}
