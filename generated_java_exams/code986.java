/*
 * Exam Question #986
 * Generated on: 2025-05-12 17:08:56
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Conference Session Management**
 * 
 * You are tasked with building a simple Conference Management System in Java. This system will allow managing attendees for various sessions, including handling session capacity and waiting lists.
 * 
 * Your solution must demonstrate proficiency in using core Java collections and control flow structures, adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the System:** Create a Java program that simulates managing sessions and attendee registrations for a conference.
 * 2.  **Session Management:**
 *     *   Each session should have a name and a maximum capacity.
 *     *   Maintain a list of attendees currently registered for the session.
 *     *   Maintain a waiting list for attendees who try to register when the session is full. The waiting list should operate on a First-In, First-Out (FIFO) basis.
 * 3.  **Attendee Management:**
 *     *   Allow registering an attendee for a session. If the session is full, add the attendee to the waiting list. Prevent duplicate registrations (an attendee cannot be both registered and on the waiting list for the same session, nor can they be added twice to either).
 *     *   Allow deregistering an attendee from a session. If the attendee was registered, remove them. If the session was full and they were removed from the registered list, move the first person from the waiting list into the registered list. If the attendee was on the waiting list, remove them from the waiting list.
 * 4.  **User Interface:** Provide a simple text-based menu for user interaction using `Scanner`. The menu should include options to:
 *     *   View all sessions (list names and capacities).
 *     *   View details of a specific session (show name, capacity, registered attendees, and waiting list).
 *     *   Register an attendee for a session.
 *     *   Deregister an attendee from a session.
 *     *   Exit the program.
 * 5.  **Required Java Components:** Your solution MUST explicitly use ALL of the following:
 *     *   `java.util.Queue` (use a concrete implementation like `LinkedList`) for the waiting list.
 *     *   `java.util.ArrayList` (use a concrete implementation) for storing registered attendees and the list of sessions.
 *     *   `java.util.List` (use the interface type when declaring variables where appropriate) for storing registered attendees and the list of sessions.
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for processing menu choices.
 *     *   `System.err` for printing error messages (e.g., session not found, invalid input, attendee not found during deregistration).
 *     *   `System.out` for printing normal output (menu, session lists, details, success messages).
 *     *   Class-wide exception handling using a `try-catch` block around the main user interaction loop to catch potential runtime errors (e.g., `InputMismatchException`, or exceptions thrown by your logic).
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Implement input validation (e.g., check if a session exists before attempting operations).
 *     *   Implement proper error handling (catching exceptions, printing informative messages).
 *     *   Structure your code into appropriate classes (e.g., `Attendee`, `Session`, `ConferenceManager`). Ensure the `Attendee` class correctly implements `equals` and `hashCode` based on the attendee's name to allow proper comparison and removal from lists/queues.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform the requested operations, printing output to `System.out` for success/information and `System.err` for errors.
 * 
 * Example interaction flow (user input shown in bold):
 * 
 * ```
 * --- Conference Management System ---
 * 1. View All Sessions
 * 2. View Session Details
 * 3. Register Attendee for Session
 * 4. Deregister Attendee from Session
 * 5. Exit
 * Enter your choice: **1**
 * 
 * --- All Sessions ---
 * - Keynote Address (Capacity: 50)
 * - Java Advanced Topics (Capacity: 10)
 * - Frontend Frameworks (Capacity: 15)
 * 
 * --- Conference Management System ---
 * ...
 * Enter your choice: **3**
 * Enter session name to register for: **Java Advanced Topics**
 * Enter attendee name: **Alice**
 * Attendee 'Alice' successfully registered for session 'Java Advanced Topics'.
 * 
 * --- Conference Management System ---
 * ...
 * Enter your choice: **3**
 * Enter session name to register for: **Java Advanced Topics**
 * Enter attendee name: **Bob**
 * Attendee 'Bob' successfully registered for session 'Java Advanced Topics'.
 * 
 * --- Conference Management System ---
 * ...
 * Enter your choice: **2**
 * Enter session name: **Java Advanced Topics**
 * 
 * --- Session Details ---
 * Session: Java Advanced Topics
 * Capacity: 10
 * Registered (2/10): Alice, Bob
 * Waiting List (0): None
 * 
 * --- Conference Management System ---
 * ...
 * Enter your choice: **5**
 * Exiting Conference Management System. Goodbye!
 * ```
 * 
 * *(Note: The exact output for full sessions and waiting lists will vary based on your test data and interactions.)*
 *
 * EXPLANATION:
 * This solution implements a simple conference management system using the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee`: A simple class to represent an attendee with a `name`. It includes overridden `equals` and `hashCode` methods based on the name (case-insensitive) which are crucial for correctly comparing and removing `Attendee` objects from collections like `ArrayList` and `LinkedList` (used for `List` and `Queue`).
 *     *   `Session`: Represents a single conference session. It holds the `name`, `capacity`, a `List<Attendee>` (`registeredAttendees` implemented by `ArrayList`), and a `Queue<Attendee>` (`waitingList` implemented by `LinkedList`).
 *         *   The `registerAttendee` method checks capacity and adds to the appropriate list (`registeredAttendees` or `waitingList`). It throws an `IllegalArgumentException` if the attendee is already in either list.
 *         *   The `deregisterAttendee` method attempts to remove the attendee from the `registeredAttendees` list first. If successful and the waiting list is not empty, it polls (`poll()`) the first attendee from the `waitingList` (`Queue`) and adds them to `registeredAttendees`. If the attendee wasn't registered, it tries to remove them from the `waitingList`. If the attendee is not found in either, it throws an `IllegalArgumentException`.
 *         *   `getDetails` provides a formatted string of the session's state.
 *     *   `ConferenceManager`: The main class that orchestrates the system. It holds a `List<Session>` (`sessions` implemented by `ArrayList`).
 *         *   It contains methods for finding sessions (`findSession`), displaying the menu (`displayMenu`), and handling user commands (`processUserCommands`).
 *         *   The `main` method creates a `ConferenceManager` instance and calls `processUserCommands`.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: Used for the `waitingList` in the `Session` class, specifically implemented by `java.util.LinkedList` to ensure FIFO behavior (`offer` to add, `poll` to remove from head).
 *     *   `java.util.ArrayList`: Used as the concrete implementation for the `registeredAttendees` list in `Session` and the `sessions` list in `ConferenceManager`.
 *     *   `java.util.List`: Used as the interface type for declaring `registeredAttendees` in `Session` and `sessions` in `ConferenceManager`, promoting good practice of programming to interfaces.
 *     *   `java.util.Scanner`: Used in `ConferenceManager.processUserCommands` and helper methods (`viewSessionDetails`, `registerAttendee`, `deregisterAttendee`) to read user input from `System.in`. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character.
 *     *   `switch` statement: Used in `ConferenceManager.processUserCommands` to control the flow based on the user's menu choice.
 *     *   `System.err`: Used to print error messages, such as when a session is not found, input is invalid (`InputMismatchException`), or a business logic error occurs (`IllegalArgumentException`).
 *     *   `System.out`: Used for all normal output, including the menu, lists of sessions, session details, and success messages.
 *     *   Class-wide exception handling: A `try-catch` block wraps the main `while (running)` loop in `ConferenceManager.processUserCommands`. This block catches `InputMismatchException` (for non-integer menu input), `IllegalArgumentException` (thrown by `Session` methods for validation/business logic errors), and a general `Exception` as a fallback for any other unexpected runtime issues. Errors caught here are printed to `System.err`.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Attendee`, `Session`, and `ConferenceManager` are `private`, with public getter methods (`getName`, `getCapacity`, `getDetails`) and methods for operations (`registerAttendee`, `deregisterAttendee`).
 *     *   **Meaningful Names:** Variables (`registeredAttendees`, `waitingList`, `sessionName`, `attendeeName`) and methods (`findSession`, `processUserCommands`, `viewAllSessions`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc-style comments are provided for classes and key methods explaining their purpose, parameters, and exceptions. Inline comments explain specific logic points (like consuming the newline after `nextInt()`).
 *     *   **Input Validation:** The `findSession` method checks if the input name is null or empty. `Attendee` and `Session` constructors validate input. The `try-catch` block in `processUserCommands` handles `InputMismatchException` for the menu choice.
 *     *   **Error Handling:** `IllegalArgumentException` is used for specific business logic errors (e.g., attendee already exists, not found during deregistration) and caught by the main loop's `try-catch`. `System.err` is used consistently for error output.
 *     *   **Clean Code Structure:** The problem is broken down into logical classes (`Attendee`, `Session`, `ConferenceManager`), each with a specific responsibility. The `ConferenceManager` delegates session-specific logic (registration, deregistration, details) to the `Session` objects.
 * 
 * This solution effectively combines various Java concepts and collections to solve a practical problem, demonstrating a strong understanding of object-oriented design, collection usage, error handling, and user interaction in Java.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.Scanner;

// Represents a conference attendee
class Attendee {
    private String name;

    /**
     * Constructs an Attendee with the given name.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Compares Attendee objects based on their name (case-insensitive).
     * Necessary for List.contains/remove and Queue.contains/remove.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return name.equalsIgnoreCase(attendee.name);
    }

    /**
     * Generates a hash code based on the attendee's name (case-insensitive).
     * Necessary for collections when equals is overridden.
     */
    @Override
    public int hashCode() {
        return Objects.hash(name.toLowerCase());
    }

    /**
     * Returns the attendee's name for display.
     * @return The attendee's name.
     */
    @Override
    public String toString() {
        return name;
    }
}

// Represents a conference session with capacity and waiting list
class Session {
    private String name;
    private int capacity;
    // Using List interface, implemented by ArrayList
    private List<Attendee> registeredAttendees;
    // Using Queue interface, implemented by LinkedList for FIFO
    private Queue<Attendee> waitingList;

    /**
     * Constructs a Session with a name and capacity.
     * @param name The name of the session.
     * @param capacity The maximum number of registered attendees.
     * @throws IllegalArgumentException if capacity is non-positive.
     */
    public Session(String name, int capacity) {
        if (name == null || name.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name cannot be null or empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Session capacity must be positive.");
        }
        this.name = name.trim();
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // ArrayList implementation
        this.waitingList = new LinkedList<>();     // LinkedList implementation for Queue
    }

    /**
     * Gets the name of the session.
     * @return The session name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the capacity of the session.
     * @return The session capacity.
     */
    public int getCapacity() {
        return capacity;
    }

    /**
     * Registers an attendee for the session.
     * Adds to registered list if capacity is available, otherwise adds to waiting list.
     * Checks for duplicate registration/waiting list entry.
     * @param attendee The attendee to register.
     * @throws IllegalArgumentException if attendee is already registered or on waiting list.
     */
    public void registerAttendee(Attendee attendee) {
        // Check if already registered or on waiting list
        if (registeredAttendees.contains(attendee)) {
            throw new IllegalArgumentException("Attendee '" + attendee.getName() + "' is already registered for session '" + name + "'.");
        }
        if (waitingList.contains(attendee)) {
             throw new IllegalArgumentException("Attendee '" + attendee.getName() + "' is already on the waiting list for session '" + name + "'.");
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(attendee);
            System.out.println("Attendee '" + attendee.getName() + "' successfully registered for session '" + name + "'.");
        } else {
            waitingList.offer(attendee); // Add to the end of the queue (FIFO)
            System.out.println("Session '" + name + "' is full. Attendee '" + attendee.getName() + "' added to the waiting list.");
        }
    }

    /**
     * Deregisters an attendee from the session.
     * If the attendee was registered, removes them and potentially moves someone from the waiting list.
     * If the attendee was on the waiting list, removes them from the waiting list.
     * @param attendeeName The name of the attendee to deregister.
     * @throws IllegalArgumentException if attendee was not found in either list.
     */
    public void deregisterAttendee(String attendeeName) {
         if (attendeeName == null || attendeeName.trim().isEmpty()) {
             throw new IllegalArgumentException("Attendee name for deregistration cannot be null or empty.");
         }
        Attendee attendeeToRemove = new Attendee(attendeeName); // Create a temporary Attendee object for comparison

        // Try to remove from registered list
        boolean removedFromRegistered = registeredAttendees.remove(attendeeToRemove);

        if (removedFromRegistered) {
            System.out.println("Attendee '" + attendeeName + "' successfully deregistered from session '" + name + "'.");
            // If someone was removed from registered, check waiting list
            if (!waitingList.isEmpty()) {
                Attendee nextAttendee = waitingList.poll(); // Get and remove the head of the queue
                if (nextAttendee != null) { // poll() can return null if queue was empty despite check, defensive
                    registeredAttendees.add(nextAttendee);
                    System.out.println("Attendee '" + nextAttendee.getName() + "' moved from waiting list to registered list for session '" + name + "'.");
                }
            }
        } else {
            // Try to remove from waiting list
            boolean removedFromWaiting = waitingList.remove(attendeeToRemove);
            if (removedFromWaiting) {
                System.out.println("Attendee '" + attendeeName + "' successfully removed from waiting list for session '" + name + "'.");
            } else {
                // Attendee not found in either list
                throw new IllegalArgumentException("Attendee '" + attendeeName + "' not found in session '" + name + "' or its waiting list.");
            }
        }
    }

    /**
     * Gets a string representation of the session details, including registered attendees and waiting list.
     * @return Session details string.
     */
    public String getDetails() {
        StringBuilder sb = new StringBuilder();
        sb.append("Session: ").append(name).append("\n");
        sb.append("Capacity: ").append(capacity).append("\n");
        sb.append("Registered (").append(registeredAttendees.size()).append("/").append(capacity).append("): ");
        if (registeredAttendees.isEmpty()) {
            sb.append("None");
        } else {
            // Iterate through registered attendees
            for (int i = 0; i < registeredAttendees.size(); i++) {
                sb.append(registeredAttendees.get(i).getName());
                if (i < registeredAttendees.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        sb.append("\n");
        sb.append("Waiting List (").append(waitingList.size()).append("): ");
        if (waitingList.isEmpty()) {
            sb.append("None");
        } else {
            boolean first = true;
            // Iterate through queue elements without removing for display
            for (Attendee attendee : waitingList) {
                 if (!first) sb.append(", ");
                 sb.append(attendee.getName());
                 first = false;
            }
        }
        sb.append("\n");
        return sb.toString();
    }
}

// Manages a collection of sessions and handles user interaction
public class ConferenceManager {

    // Using List interface, implemented by ArrayList
    private List<Session> sessions;
    private Scanner scanner;

    /**
     * Constructs a ConferenceManager and initializes with some sample sessions.
     */
    public ConferenceManager() {
        this.sessions = new ArrayList<>(); // ArrayList implementation
        this.scanner = new Scanner(System.in);
        // Add some initial sessions
        try {
            sessions.add(new Session("Keynote Address", 50));
            sessions.add(new Session("Java Advanced Topics", 10));
            sessions.add(new Session("Frontend Frameworks", 15));
            sessions.add(new Session("Cloud Computing Basics", 5));
        } catch (IllegalArgumentException e) {
             // This should not happen with hardcoded valid data, but good practice
             System.err.println("Error initializing sessions: " + e.getMessage());
        }
    }

    /**
     * Finds a session by its name (case-insensitive).
     * @param name The name of the session to find.
     * @return The Session object if found, null otherwise.
     */
    private Session findSession(String name) {
         if (name == null) return null;
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(name.trim())) {
                return session;
            }
        }
        return null;
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Conference Management System ---");
        System.out.println("1. View All Sessions");
        System.out.println("2. View Session Details");
        System.out.println("3. Register Attendee for Session");
        System.out.println("4. Deregister Attendee from Session");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Processes user commands based on menu selection.
     * Uses a switch statement for control flow.
     * Includes class-wide exception handling using try-catch.
     */
    public void processUserCommands() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling loop
        while (running) {
            try {
                displayMenu();
                // Read menu choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for command processing
                switch (choice) {
                    case 1:
                        viewAllSessions();
                        break;
                    case 2:
                        viewSessionDetails();
                        break;
                    case 3:
                        registerAttendee();
                        break;
                    case 4:
                        deregisterAttendee();
                        break;
                    case 5:
                        System.out.println("Exiting Conference Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Handles choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handles non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number for the menu choice.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException e) {
                // Handles specific validation/business logic errors (e.g., attendee already exists, session not found)
                System.err.println("Operation Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(System.err); // Print stack trace for debugging during development/testing
            }
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Displays the names and capacities for all available sessions.
     */
    private void viewAllSessions() {
        System.out.println("\n--- All Sessions ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions available.");
        } else {
            // Use List iteration to display sessions
            for (Session session : sessions) {
                System.out.println("- " + session.getName() + " (Capacity: " + session.getCapacity() + ")");
            }
        }
    }

    /**
     * Prompts the user for a session name and displays its detailed information.
     * Uses System.err if the session is not found.
     */
    private void viewSessionDetails() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();
        Session session = findSession(sessionName);

        if (session != null) {
            System.out.println("\n--- Session Details ---");
            System.out.print(session.getDetails()); // Session class handles formatting details
        } else {
            System.err.println("Error: Session '" + sessionName + "' not found.");
        }
    }

    /**
     * Prompts the user for session and attendee names and attempts to register the attendee.
     * Delegates registration logic to the Session class.
     * Catches IllegalArgumentException from Session.registerAttendee.
     */
    private void registerAttendee() {
        System.out.print("Enter session name to register for: ");
        String sessionName = scanner.nextLine();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session != null) {
            try {
                Attendee attendee = new Attendee(attendeeName);
                // Call Session method to handle registration logic (capacity, waiting list, duplicates)
                session.registerAttendee(attendee);
            } catch (IllegalArgumentException e) {
                 // Re-throw the exception to be caught by the main loop's try-catch
                 throw new IllegalArgumentException(e.getMessage());
            }
        } else {
            System.err.println("Error: Session '" + sessionName + "' not found.");
        }
    }

    /**
     * Prompts the user for session and attendee names and attempts to deregister the attendee.
     * Delegates deregistration logic to the Session class.
     * Catches IllegalArgumentException from Session.deregisterAttendee.
     */
    private void deregisterAttendee() {
        System.out.print("Enter session name to deregister from: ");
        String sessionName = scanner.nextLine();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session != null) {
            try {
                // Call Session method to handle deregistration logic (registered/waiting, moving from waiting list)
                session.deregisterAttendee(attendeeName);
            } catch (IllegalArgumentException e) {
                 // Re-throw the exception to be caught by the main loop's try-catch
                 throw new IllegalArgumentException(e.getMessage());
            }
        } else {
            System.err.println("Error: Session '" + sessionName + "' not found.");
        }
    }

    /**
     * The main entry point of the program.
     * Creates a ConferenceManager and starts the command processing loop.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ConferenceManager manager = new ConferenceManager();
        manager.processUserCommands();
    }
}
