/*
 * Exam Question #746
 * Generated on: 2025-05-12 16:34:56
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Customer Service Request Handling System**
 * 
 * **Scenario:**
 * You are tasked with building a simple console-based system for managing customer service requests. Requests arrive and are placed in a queue to be handled in the order they were received. Once a request is processed, it is moved to a list of completed requests. The system should allow users to add new requests, process the next pending request, view all pending requests, and view all processed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store pending requests. Implement it using a suitable class from the Java Collections Framework.
 *     *   Use `java.util.List` to store processed requests. Implement it using `java.util.ArrayList`.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Add Request, Process Next, View Pending, View Processed, Exit).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, confirmation messages, and list contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. This should include handling potential input mismatches and other unexpected errors during the main program loop.
 *     *   Gracefully handle the case where the user attempts to process a request when the pending queue is empty.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Request` class to represent a customer service request (should have at least an ID and a description).
 *     *   Create a `ServiceSystem` class that encapsulates the `Queue` and `List` and contains methods for adding, processing, and viewing requests.
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for methods).
 *     *   Implement basic input validation (e.g., handle non-integer input for menu choice, check for empty request description).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and perform actions based on the choice. Examples of interactions:
 * 
 * ```
 * --- Customer Service Request Handling System ---
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 1
 * Enter request description: My internet is slow.
 * Request added: Request [ID=1, Description='My internet is slow.']
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 1
 * Enter request description: Cannot log in to my account.
 * Request added: Request [ID=2, Description='Cannot log in to my account.']
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 3
 * 
 * --- Pending Requests ---
 * Request [ID=1, Description='My internet is slow.']
 * Request [ID=2, Description='Cannot log in to my account.']
 * ------------------------
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 2
 * Request processed: Request [ID=1, Description='My internet is slow.']
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 2
 * Request processed: Request [ID=2, Description='Cannot log in to my account.']
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 2
 * Error: No pending requests to process.
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 4
 * 
 * --- Processed Requests ---
 * Request [ID=1, Description='My internet is slow.']
 * Request [ID=2, Description='Cannot log in to my account.']
 * --------------------------
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Processed Requests
 * 0. Exit
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single Java program containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Service Request Handling System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Request` class: A simple POJO (Plain Old Java Object) representing a request with an ID and a description. It follows encapsulation principles with private fields and public getters.
 *     *   `ServiceSystem` class: This class acts as the core logic handler. It manages the two main data structures: `pendingRequests` (a `Queue`) and `processedRequests` (a `List`). It contains methods (`addRequest`, `processNextRequest`, `viewPendingRequests`, `viewProcessedRequests`) that perform the system's operations. This separation of concerns keeps the main class clean.
 *     *   `ExamQuestion` class: This contains the `main` method, which is the entry point of the program. It handles user interaction using `Scanner`, displays the menu, processes user choices via a `switch` statement, and calls the appropriate methods in the `ServiceSystem` instance. It also implements the required exception handling.
 * 
 * 2.  **Data Structures Usage:**
 *     *   `Queue<Request> pendingRequests`: A `LinkedList` is used here because `LinkedList` implements the `Queue` interface and provides efficient FIFO (First-In, First-Out) operations (`offer` for adding to the tail, `poll` for removing from the head). This correctly simulates a waiting line for requests.
 *     *   `List<Request> processedRequests`: An `ArrayList` is used here. `ArrayList` implements the `List` interface and is suitable for storing processed items where access by index or iteration is common, and the order of processing (which is the order they are added to this list) is maintained.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `Scanner`: An instance of `Scanner` reads user input from `System.in`. `scanner.nextInt()` is used for reading the menu choice, and `scanner.nextLine()` is used for reading the request description. The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character.
 *     *   `switch`: The `switch` statement in the `main` method directs the program flow based on the integer menu choice entered by the user.
 * 
 * 4.  **Output Streams:**
 *     *   `System.out`: Used for standard output, such as printing the menu, prompts, confirmation messages (e.g., "Request added"), and the contents of the request lists.
 *     *   `System.err`: Used specifically for error messages, such as when the user enters invalid input or attempts an operation that cannot be performed (e.g., processing an empty queue).
 * 
 * 5.  **Exception Handling:**
 *     *   **Class-wide `try-catch`:** The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This serves as a general catch-all for any unexpected runtime exceptions that might occur within the main operational flow, printing an error message and the stack trace using `System.err`.
 *     *   **Input Validation/Handling:** An inner `try-catch(InputMismatchException e)` block is used specifically around `scanner.nextInt()`. This handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input (`scanner.next()`) to prevent an infinite loop.
 *     *   **Business Logic Error Handling:** The `processNextRequest` method checks if the `pendingRequests` queue is empty before calling `poll()`. If it is empty, it prints a specific error message to `System.err` and returns `false`, indicating that no request was processed. This is graceful handling of a specific operational condition rather than relying solely on exceptions.
 *     *   **`finally` block:** A `finally` block is used with the outer `try-catch` to ensure that the `Scanner` resource is closed regardless of whether the program exits normally or due to an exception.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Request` and `ServiceSystem` are private, and access is provided through public methods.
 *     *   **Meaningful Names:** Variables (`pendingRequests`, `nextRequestId`, `description`) and methods (`addRequest`, `processNextRequest`, `viewPendingRequests`) have names that clearly indicate their purpose.
 *     *   **Comments/Documentation:** Javadoc-style comments are included for classes and methods, explaining their function, parameters, and return values.
 *     *   **Input Validation:** Checks for empty request descriptions and handles non-integer input for menu choices.
 *     *   **Clean Code:** The logic is separated into appropriate classes, and the `main` method is relatively clean, focusing on user interaction and delegation to the `ServiceSystem`.
 * 
 * This solution effectively integrates all the required Java components into a practical simulation, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a customer service request.
 */
class Request {
    private int id;
    private String description;

    /**
     * Constructs a new Request.
     * @param id The unique identifier for the request.
     * @param description A brief description of the request issue.
     */
    public Request(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the request ID.
     * @return The request ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the request description.
     * @return The request description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Request.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Request [ID=" + id + ", Description='" + description + "']";
    }
}

/**
 * Manages pending and processed customer service requests.
 */
class ServiceSystem {
    // Using LinkedList as it implements the Queue interface (FIFO)
    private Queue<Request> pendingRequests;
    // Using ArrayList as it implements the List interface (dynamic array)
    private List<Request> processedRequests;
    private int nextRequestId; // Counter for generating unique request IDs

    /**
     * Constructs a new ServiceSystem.
     */
    public ServiceSystem() {
        this.pendingRequests = new LinkedList<>();
        this.processedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Adds a new request to the pending queue.
     * Validates that the description is not empty.
     * @param description The description of the request.
     */
    public void addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Request description cannot be empty.");
             return; // Do not add request if description is invalid
        }
        // Create a new Request with a unique ID and trimmed description
        Request newRequest = new Request(nextRequestId++, description.trim());
        // Add the request to the end of the pending queue
        pendingRequests.offer(newRequest); // offer is generally preferred over add for queues
        System.out.println("Request added: " + newRequest);
    }

    /**
     * Processes the next request from the head of the pending queue.
     * If the queue is not empty, removes the request, adds it to the processed list, and prints a success message.
     * If the queue is empty, prints an error message to System.err.
     * @return true if a request was successfully processed, false otherwise.
     */
    public boolean processNextRequest() {
        // Check if the pending queue is empty before attempting to poll
        if (pendingRequests.isEmpty()) {
            System.err.println("Error: No pending requests to process.");
            return false; // Indicate failure
        }
        // Remove the request from the head of the queue
        Request processedRequest = pendingRequests.poll(); // poll retrieves and removes the head
        // Add the processed request to the list of processed requests
        processedRequests.add(processedRequest);
        System.out.println("Request processed: " + processedRequest);
        return true; // Indicate success
    }

    /**
     * Displays all requests currently in the pending queue.
     * If the queue is empty, indicates that there are no pending requests.
     */
    public void viewPendingRequests() {
        System.out.println("\n--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            // forEach is a convenient way to print each element
            pendingRequests.forEach(System.out::println);
        }
        System.out.println("------------------------");
    }

    /**
     * Displays all requests that have been processed.
     * If the processed list is empty, indicates that no requests have been processed yet.
     */
    public void viewProcessedRequests() {
        System.out.println("\n--- Processed Requests ---");
        if (processedRequests.isEmpty()) {
            System.out.println("No processed requests.");
        } else {
            // Iterate through the list and print each element
            processedRequests.forEach(System.out::println);
        }
        System.out.println("--------------------------");
    }
}

/**
 * Main class for the Customer Service Request Handling System.
 * Contains the main loop, menu display, user interaction, and overall exception handling.
 */
public class ExamQuestion {

    public static void main(String[] args) {
        // Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        // Instance of the ServiceSystem to manage requests
        ServiceSystem serviceSystem = new ServiceSystem();
        boolean running = true; // Control variable for the main loop

        System.out.println("--- Customer Service Request Handling System ---");

        // Class-wide exception handling: Wrap the main operational loop in a try-catch block
        try {
            while (running) {
                printMenu(); // Display menu options
                int choice = -1; // Initialize choice to an invalid value

                // Inner try-catch block specifically for handling input mismatch
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer input
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement to handle different menu choices
                    switch (choice) {
                        case 1:
                            System.out.print("Enter request description: ");
                            String description = scanner.nextLine();
                            serviceSystem.addRequest(description); // Call method to add request
                            break;
                        case 2:
                            serviceSystem.processNextRequest(); // Call method to process next request
                            break;
                        case 3:
                            serviceSystem.viewPendingRequests(); // Call method to view pending
                            break;
                        case 4:
                            serviceSystem.viewProcessedRequests(); // Call method to view processed
                            break;
                        case 0:
                            System.out.println("Exiting system. Goodbye!");
                            running = false; // Set running to false to exit the loop
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the input is not an integer
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent an infinite loop
                }
                 System.out.println(); // Add a newline for better separation between menu interactions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print the stack trace for debugging purposes
        } finally {
            // Ensure the scanner is closed when the program finishes or encounters an error
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Processed Requests");
        System.out.println("0. Exit");
    }
}
