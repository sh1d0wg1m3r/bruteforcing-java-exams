/*
 * Exam Question #747
 * Generated on: 2025-05-12 16:34:58
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Print Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Print Queue Management System. This system will simulate a print server managing print jobs submitted by users. Jobs are processed in the order they are received. Users should be able to submit new print jobs, trigger the processing of the next job, view the list of jobs currently waiting in the queue, cancel a specific pending job, and review a history of all jobs that have been completed or cancelled.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:** Create a class named `PrintJob` to represent a single print job. It must have private fields for:
 *     *   `jobId` (an integer, uniquely assigned)
 *     *   `documentName` (a String)
 *     *   `pages` (an integer)
 *     *   `status` (a String, e.g., "Pending", "Processing", "Completed", "Cancelled")
 *     Provide a constructor and public getter methods for all fields. Include methods to update the job's status (e.g., `markProcessing()`, `markCompleted()`, `markCancelled()`). Ensure proper encapsulation.
 * 
 * 2.  **`PrintQueueManager` Class:** Create a class named `PrintQueueManager` responsible for managing the print jobs. It must use:
 *     *   A private `java.util.Queue<PrintJob>` to store jobs that are waiting to be printed (pending jobs). Jobs should be processed in First-In, First-Out (FIFO) order.
 *     *   A private `java.util.List<PrintJob>` (implemented using `java.util.ArrayList`) to store jobs that have been completed or cancelled.
 *     *   A mechanism to generate unique `jobId`s (e.g., a counter).
 *     Provide public methods for the following operations:
 *     *   `addJob(String documentName, int pages)`: Creates a new `PrintJob`, assigns a unique ID, adds it to the pending queue, and returns the assigned job ID.
 *     *   `processNextJob()`: Removes the job at the front of the pending queue, updates its status to "Processing" and then "Completed", and moves it to the completed jobs list. Return the processed `PrintJob` object, or `null` if the queue was empty.
 *     *   `viewPendingQueue()`: Returns a `java.util.List<PrintJob>` containing a snapshot of the jobs currently in the pending queue, preserving their order.
 *     *   `cancelJob(int jobId)`: Searches the pending queue for a job with the given `jobId`. If found, remove it from the queue, update its status to "Cancelled", and move it to the completed jobs list. Return the cancelled `PrintJob` object, or `null` if no job with the given ID was found in the pending queue.
 *     *   `viewJobHistory()`: Returns the `java.util.List<PrintJob>` containing all completed and cancelled jobs.
 * 
 * 3.  **`PrintSystemApp` Class (Main Application):** Create a class with a `main` method to run the application.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a command-line menu with options like: Add Job, Process Next Job, View Pending Queue, Cancel Job, View Job History, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out.println()` for displaying the menu, successful operation messages, and job details.
 *     *   Use `System.err.println()` for displaying all error messages (e.g., invalid input, queue empty, job not found).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the main application logic (e.g., around the user input loop and method calls) to gracefully handle potential issues like invalid numeric input (`InputMismatchException`, `NumberFormatException`) or errors reported by the `PrintQueueManager` (like trying to process an empty queue). Do not let unhandled exceptions crash the program during normal user interaction.
 *     *   Validate user input where appropriate (e.g., number of pages should be positive, job ID for cancellation should be a valid number).
 * 
 * 4.  **General Requirements:**
 *     *   Follow best practices: meaningful variable and method names, appropriate comments (especially Javadoc for classes and methods), clean code structure.
 *     *   Ensure all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used correctly and effectively in the solution.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Print Queue Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Queue
 * 4. Cancel Job
 * 5. View Job History
 * 6. Exit
 * Enter choice: 1
 * Enter document name: Report.pdf
 * Enter number of pages: 15
 * Job added with ID: 101
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 1
 * Enter document name: Image.png
 * Enter number of pages: 2
 * Job added with ID: 102
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 3
 * Pending Queue:
 * Job ID: 101 (Doc: Report.pdf, Pages: 15, Status: Pending)
 * Job ID: 102 (Doc: Image.png, Pages: 2, Status: Pending)
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 2
 * Processing job ID: 101 (Document: Report.pdf, Pages: 15)
 * Job 101 completed.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 4
 * Enter Job ID to cancel: 102
 * Job ID 102 cancelled.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 3
 * The print queue is empty.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 2
 * Error: The print queue is empty. No jobs to process. (Printed to System.err)
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 4
 * Enter Job ID to cancel: 999
 * Error: Job ID 999 not found in the pending queue. (Printed to System.err)
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 5
 * Job History:
 * Job ID: 101 (Doc: Report.pdf, Pages: 15, Status: Completed)
 * Job ID: 102 (Doc: Image.png, Pages: 2, Status: Cancelled)
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: invalid_input
 * Error: Invalid input. Please enter a number between 1 and 6. (Printed to System.err)
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter choice: 6
 * Exiting Print Queue System.
 * ```
 * 
 * Your solution must provide all the necessary classes and logic within the provided code block.
 *
 * EXPLANATION:
 * This solution implements a simplified Print Queue Management System demonstrating the required Java concepts.
 * 
 * **1. `PrintJob` Class:**
 * - Follows encapsulation principles with private fields (`jobId`, `documentName`, `pages`, `status`) and public getters.
 * - Includes specific methods (`markProcessing`, `markCompleted`, `markCancelled`) to manage the job's status, making state changes explicit and controlled.
 * - Provides a `toString()` method for easy printing of job details.
 * 
 * **2. `PrintQueueManager` Class:**
 * - Uses a `java.util.Queue<PrintJob>` (`LinkedList` implementation) for the pending print jobs, ensuring FIFO processing as required.
 * - Uses a `java.util.List<PrintJob>` (`ArrayList` implementation) to store completed and cancelled jobs, serving as a history log.
 * - `nextJobId` ensures unique IDs for each job.
 * - `addJob()` correctly creates a job, assigns an ID, and adds it to the `printQueue`. It includes basic input validation for `pages`.
 * - `processNextJob()` uses `queue.poll()` which is the standard way to retrieve and remove the head of a Queue, returning `null` if empty. It updates the job status and moves it to `completedJobs`.
 * - `viewPendingQueue()` iterates through the queue and copies elements into a new `ArrayList`. This fulfills the requirement of returning a `List` representation and prevents external code from modifying the internal queue state directly.
 * - `cancelJob()` iterates through the `printQueue` using an `Iterator`. This is crucial for safely removing an element from the queue while iterating. If the job is found, it's removed, its status updated, and added to `completedJobs`.
 * - `viewJobHistory()` returns the `completedJobs` list, again returning a copy to maintain encapsulation.
 * 
 * **3. `PrintSystemApp` Class:**
 * - Contains the `main` method, acting as the application's entry point and user interface controller.
 * - Uses `java.util.Scanner` to read user input from the console.
 * - A `while` loop keeps the application running until the user chooses to exit.
 * - A `switch` statement effectively directs control flow based on the user's menu choice.
 * - `System.out.println()` is used for displaying the menu, prompts, and successful operation feedback.
 * - `System.err.println()` is used specifically for reporting error conditions (e.g., invalid menu choice, empty queue, job not found, invalid numeric input).
 * - **Class-wide exception handling** is implemented using `try-catch` blocks.
 *     - The main `while` loop has a `try-catch(InputMismatchException)` to handle cases where the user enters non-integer input for the main menu choice.
 *     - Nested `try-catch(InputMismatchException)` blocks are used within the `ADD_JOB` and `CANCEL_JOB` cases to handle non-integer input specifically for the "pages" or "job ID" prompts.
 *     - The `ADD_JOB` case also catches `IllegalArgumentException` thrown by `addJob` for invalid page counts.
 *     - The logic within `PROCESS_JOB` and `CANCEL_JOB` checks the return value (`null`) from the `PrintQueueManager` methods to identify operational errors (empty queue, job not found) and reports them via `System.err`.
 *     - A general `catch(Exception e)` is included in the main loop's `try` block as a fallback for any other unexpected runtime errors, demonstrating a robust handling approach.
 * - Constants (`ADD_JOB`, etc.) are used for menu options for better readability and maintainability.
 * - The `Scanner` is closed when the application exits.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, adhering to best practices like encapsulation, clear naming, and robust error handling, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // Needed for cancelling job efficiently

/**
 * Represents a single print job with details and status.
 */
class PrintJob {
    private int jobId;
    private String documentName;
    private int pages;
    private String status;

    /**
     * Constructs a new PrintJob.
     *
     * @param jobId The unique identifier for the job.
     * @param documentName The name of the document to print.
     * @param pages The number of pages in the document.
     */
    public PrintJob(int jobId, String documentName, int pages) {
        this.jobId = jobId;
        this.documentName = documentName;
        this.pages = pages;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getDocumentName() {
        return documentName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // --- Status Update Methods ---
    public void markProcessing() {
        this.status = "Processing";
    }

    public void markCompleted() {
        this.status = "Completed";
    }

    public void markCancelled() {
        this.status = "Cancelled";
    }

    @Override
    public String toString() {
        return String.format("Job ID: %d (Doc: %s, Pages: %d, Status: %s)",
                             jobId, documentName, pages, status);
    }
}

/**
 * Manages the queue of pending print jobs and a history of completed/cancelled jobs.
 */
class PrintQueueManager {
    private Queue<PrintJob> printQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId; // Counter for assigning unique job IDs

    /**
     * Constructs a new PrintQueueManager.
     */
    public PrintQueueManager() {
        // Using LinkedList as a Queue implementation
        this.printQueue = new LinkedList<>();
        // Using ArrayList for completed job history
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 100; // Starting job IDs from 100 for clarity
    }

    /**
     * Adds a new print job to the pending queue.
     *
     * @param documentName The name of the document.
     * @param pages The number of pages.
     * @return The assigned unique job ID.
     * @throws IllegalArgumentException if pages is less than or equal to 0.
     */
    public int addJob(String documentName, int pages) {
        if (pages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }
        int currentJobId = nextJobId++;
        PrintJob newJob = new PrintJob(currentJobId, documentName, pages);
        printQueue.add(newJob);
        return currentJobId;
    }

    /**
     * Processes the next job in the queue (FIFO).
     *
     * @return The processed PrintJob, or null if the queue is empty.
     */
    public PrintJob processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        PrintJob jobToProcess = printQueue.poll();
        if (jobToProcess != null) {
            jobToProcess.markProcessing();
            // Simulate processing time if needed, then mark completed
            jobToProcess.markCompleted();
            completedJobs.add(jobToProcess); // Move to history
            return jobToProcess;
        }
        return null; // Queue was empty
    }

    /**
     * Returns a list of jobs currently in the pending queue.
     * Creates a new list to avoid external modification of the internal queue.
     *
     * @return A List of pending PrintJobs.
     */
    public List<PrintJob> viewPendingQueue() {
        // Iterate through the queue and add to a new list for display
        return new ArrayList<>(printQueue); // LinkedList is a List, but copying is safer
    }

    /**
     * Cancels a job with the given ID if it's found in the pending queue.
     *
     * @param jobId The ID of the job to cancel.
     * @return The cancelled PrintJob, or null if the job was not found in the pending queue.
     */
    public PrintJob cancelJob(int jobId) {
        Iterator<PrintJob> iterator = printQueue.iterator();
        while (iterator.hasNext()) {
            PrintJob job = iterator.next();
            if (job.getJobId() == jobId) {
                iterator.remove(); // Safely remove job from queue using iterator
                job.markCancelled();
                completedJobs.add(job); // Move to history
                return job;
            }
        }
        return null; // Job not found in the pending queue
    }

    /**
     * Returns a list of all completed and cancelled jobs.
     *
     * @return A List of historical PrintJobs.
     */
    public List<PrintJob> viewJobHistory() {
        // Return a copy to prevent external modification
        return new ArrayList<>(completedJobs);
    }
}

/**
 * Main application class for the Print Queue Management System.
 * Handles user interaction, menu, and delegates operations to PrintQueueManager.
 * Demonstrates class-wide exception handling for user input and operations.
 */
public class PrintSystemApp {

    private static final int ADD_JOB = 1;
    private static final int PROCESS_JOB = 2;
    private static final int VIEW_QUEUE = 3;
    private static final int CANCEL_JOB = 4;
    private static final int VIEW_HISTORY = 5;
    private static final int EXIT = 6;

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Print Queue Menu ---");
        System.out.println(ADD_JOB + ". Add New Job");
        System.out.println(PROCESS_JOB + ". Process Next Job");
        System.out.println(VIEW_QUEUE + ". View Pending Queue");
        System.out.println(CANCEL_JOB + ". Cancel Job");
        System.out.println(VIEW_HISTORY + ". View Job History");
        System.out.println(EXIT + ". Exit");
        System.out.print("Enter choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager queueManager = new PrintQueueManager();
        boolean running = true;

        // Class-wide exception handling loop
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                // --- Input reading for menu choice ---
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // --- Switch statement for flow control based on valid choice ---
                switch (choice) {
                    case ADD_JOB:
                        System.out.print("Enter document name: ");
                        String docName = scanner.nextLine();
                        int pages = -1;
                        try {
                            System.out.print("Enter number of pages: ");
                            pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            int jobId = queueManager.addJob(docName, pages);
                            System.out.println("Job added with ID: " + jobId);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for pages. Please enter a number.");
                            scanner.nextLine(); // Consume the invalid input
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case PROCESS_JOB:
                        PrintJob processedJob = queueManager.processNextJob();
                        if (processedJob != null) {
                            System.out.println("Processing job ID: " + processedJob.getJobId() +
                                               " (Document: " + processedJob.getDocumentName() +
                                               ", Pages: " + processedJob.getPages() + ")");
                            System.out.println("Job " + processedJob.getJobId() + " completed.");
                        } else {
                            System.err.println("Error: The print queue is empty. No jobs to process.");
                        }
                        break;

                    case VIEW_QUEUE:
                        List<PrintJob> pendingJobs = queueManager.viewPendingQueue();
                        if (pendingJobs.isEmpty()) {
                            System.out.println("The print queue is empty.");
                        } else {
                            System.out.println("Pending Queue:");
                            for (PrintJob job : pendingJobs) {
                                System.out.println(job); // Uses PrintJob's toString()
                            }
                        }
                        break;

                    case CANCEL_JOB:
                        int cancelJobId = -1;
                        try {
                            System.out.print("Enter Job ID to cancel: ");
                            cancelJobId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            PrintJob cancelledJob = queueManager.cancelJob(cancelJobId);
                            if (cancelledJob != null) {
                                System.out.println("Job ID " + cancelledJob.getJobId() + " cancelled.");
                            } else {
                                System.err.println("Error: Job ID " + cancelJobId + " not found in the pending queue.");
                            }
                        } catch (InputMismatchException e) {
                             System.err.println("Error: Invalid input for Job ID. Please enter a number.");
                             scanner.nextLine(); // Consume the invalid input
                        }
                        break;

                    case VIEW_HISTORY:
                        List<PrintJob> history = queueManager.viewJobHistory();
                        if (history.isEmpty()) {
                            System.out.println("Job history is empty.");
                        } else {
                            System.out.println("Job History:");
                            for (PrintJob job : history) {
                                System.out.println(job); // Uses PrintJob's toString()
                            }
                        }
                        break;

                    case EXIT:
                        running = false;
                        System.out.println("Exiting Print Queue System.");
                        break;

                    default:
                        // Handles choices outside the 1-6 range after successful int scan
                        System.err.println("Error: Invalid choice. Please enter a number between " + ADD_JOB + " and " + EXIT + ".");
                        break;
                }
            } catch (InputMismatchException e) {
                 // Catches non-integer input for the main menu choice
                 System.err.println("Error: Invalid input. Please enter a number between " + ADD_JOB + " and " + EXIT + ".");
                 scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // General catch-all for unexpected errors during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        } // End while loop

        scanner.close(); // Close the scanner when exiting
    }
}
