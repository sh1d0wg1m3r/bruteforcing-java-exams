/*
 * Exam Question #829
 * Generated on: 2025-05-12 16:47:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line application for a small team's task management. The system should allow team members to add new tasks, process the next available task, view all tasks, view only pending tasks, and find a specific task by its ID.
 * 
 * **Task Definition:**
 * 
 * Each task should have:
 * - A unique integer ID (automatically assigned, starting from 1).
 * - A String description.
 * - A status, which can be one of: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 * 
 * **System Functionality:**
 * 
 * 1.  **Add New Task:**
 *     - Prompt the user for a task description.
 *     - Create a new task with status `PENDING`.
 *     - Add the task to a list containing *all* created tasks.
 *     - Add the task to a queue for pending tasks, ready for processing.
 *     - Report success and the new task details to `System.out`.
 *     - Handle cases where the description is empty or null, reporting an error to `System.err`.
 * 
 * 2.  **Process Next Pending Task:**
 *     - Take the oldest `PENDING` task from the queue (FIFO).
 *     - If the queue is empty, report an error to `System.err`.
 *     - If a task is retrieved, change its status to `PROCESSING`.
 *     - Simulate processing (e.g., using `Thread.sleep`).
 *     - Introduce a chance of failure during processing (e.g., 10% probability using `java.util.Random`).
 *     - If processing succeeds, change the task status to `COMPLETED`. Report success to `System.out`.
 *     - If processing fails (simulated), change the task status to `FAILED`. Report the failure to `System.err`.
 *     - Ensure the task status is updated in the main list of all tasks as well.
 * 
 * 3.  **View All Tasks:**
 *     - Display details (ID, Description, Status) of all tasks ever created, from the complete list.
 *     - Report to `System.out`.
 *     - If no tasks exist, report that.
 * 
 * 4.  **View Pending Tasks:**
 *     - Display details (ID, Description, Status) of tasks currently in the pending queue, in the order they would be processed.
 *     - Report to `System.out`.
 *     - If no tasks are pending, report that.
 * 
 * 5.  **Find Task by ID:**
 *     - Prompt the user for a Task ID.
 *     - Search the list of all tasks for the task with the given ID.
 *     - If found, display its details to `System.out`.
 *     - If not found, report that to `System.out`.
 *     - Handle invalid input for the Task ID (non-numeric), reporting an error to `System.err`.
 * 
 * 6.  **Exit:**
 *     - Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution MUST use ALL of the following Java components:
 * -   `java.util.Queue` (specifically, an implementation like `LinkedList`)
 * -   `java.util.ArrayList`
 * -   `java.util.List` interface (use `List` as the type declaration where appropriate, e.g., for storing all tasks)
 * -   `java.util.Scanner` for user input
 * -   `switch` statement for menu navigation
 * -   `System.err` for all error messages
 * -   `System.out` for all normal output (menu, prompts, success messages, task details)
 * -   Class-wide exception handling using `try-catch` blocks (demonstrate catching potential exceptions from user input and task operations).
 * 
 * **Best Practices:**
 * 
 * -   Implement proper encapsulation (private fields, public methods).
 * -   Use meaningful variable and method names.
 * -   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 * -   Validate user input where necessary (e.g., task description, numeric inputs).
 * -   Implement robust error handling for operations that might fail (e.g., processing an empty queue, invalid task ID).
 * -   Maintain a clean and logical code structure (e.g., separate classes for `Task` and `TaskManager`).
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu, accept user input, perform the requested actions, display results or task details to `System.out`, and print error messages to `System.err` when issues occur (e.g., invalid menu choice, empty description, empty queue processing, simulated processing failure, invalid ID input). The program should loop until the user chooses to exit.
 * 
 * ---
 * **Evaluation Criteria:**
 * 
 * -   Correct implementation of all required functionalities.
 * -   Proper and effective use of ALL specified Java components.
 * -   Adherence to best practices (encapsulation, naming, comments, structure).
 * -   Robust input validation and error handling using `try-catch` and `System.err`.
 * -   Clear and readable code.
 * 
 * ---
 * **Time Limit:** 45-60 minutes (Simulated)
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Team Task Management System, demonstrating the required advanced Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is divided into three classes:
 *     *   `Task`: Represents a single task with its properties (ID, description, status) and an enum `TaskStatus`. It handles its own unique ID generation and state. Encapsulation is maintained with private fields and public getters/setters.
 *     *   `TaskManager`: Manages the collections of tasks and the logic for operations like adding, processing, and viewing. It holds the `Queue` for pending tasks and the `List` for all tasks.
 *     *   `AdvancedTaskManagerApp`: Contains the `main` method, handles user interaction via the `Scanner`, displays the menu using a `switch` statement, and implements the primary application loop and class-wide exception handling.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `Queue<Task> pendingTasks`: A `LinkedList` is used to implement the `Queue` interface. This structure is ideal for managing tasks that need to be processed in the order they were added (FIFO - First-In, First-Out). `offer()` is used for adding to the queue and `poll()` for retrieving and removing the head.
 *     *   `List<Task> allTasks`: An `ArrayList` is used to implement the `List` interface. This structure stores a complete history of all tasks created. It allows easy iteration (for viewing all tasks) and searching (for finding a task by ID). Using `List` as the declared type promotes programming to the interface.
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     *   `Scanner` is used in the `main` method to read user input from the console for menu choices and task details.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used within the loop to direct execution based on the user's numeric menu choice, making the menu navigation clear and efficient.
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard output, including displaying the menu, prompts, success messages (task added, task completed), and task details when viewing or finding.
 *     *   `System.err.println()` is used exclusively for error messages, such as invalid input, operations on empty collections (e.g., processing an empty queue), simulated processing failures, and exceptions caught by the main error handling block. This separation helps distinguish normal program output from errors.
 * 
 * 5.  **Exception Handling (`try-catch`, Class-wide):**
 *     *   The solution demonstrates exception handling at multiple levels.
 *     *   An inner `try-catch` is used specifically around `Integer.parseInt()` calls (for menu choice and task ID) to handle `NumberFormatException` when the user enters non-numeric input.
 *     *   The `TaskManager.processNextTask()` method includes a `try-catch` block to simulate potential processing `Exception` or handle `InterruptedException` from `Thread.sleep()`. It catches these exceptions, updates the task status to `FAILED`, prints an error to `System.err` *within the method*, and then re-throws the exception to be caught by the main application logic.
 *     *   A large `try-catch` block wraps the `switch` statement in the `main` method. This serves as the "class-wide" exception handler for the `AdvancedTaskManagerApp`. It catches specific exceptions like `IllegalArgumentException` (from `addTask` for empty description) and `IllegalStateException` (from `processNextTask` for an empty queue), as well as the general `Exception` re-thrown by `processNextTask`. This centralizes the handling of operational errors, preventing the program from crashing and providing informative messages to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 *     *   **Naming:** Variable names (`pendingTasks`, `allTasks`, `taskIdToFind`), method names (`addTask`, `processNextTask`, `viewAllTasks`, `findTaskById`), and enum constants (`PENDING`, `COMPLETED`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc-style comments explain the purpose of classes, methods, and significant logic blocks.
 *     *   **Input Validation:** Checks for null/empty task descriptions and handles `NumberFormatException` for numeric inputs.
 *     *   **Error Handling:** Specific exceptions are caught, appropriate error messages are printed to `System.err`, and the program continues execution after most errors.
 *     *   **Clean Code Structure:** The separation of concerns into `Task`, `TaskManager`, and the main application class (`AdvancedTaskManagerApp`) makes the code modular and easier to understand.
 * 
 * This solution effectively integrates the required components into a practical scenario, showcasing understanding of data structures, object-oriented principles, user interaction, and robust error handling in Java.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private TaskStatus status;

    // Enum to represent task status
    enum TaskStatus {
        PENDING, PROCESSING, COMPLETED, FAILED
    }

    /**
     * Constructs a new Task with a unique ID and PENDING status.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\", Status: " + status;
    }
}

// Manages collections of tasks and task operations
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to keep track of all tasks ever created
    private List<Task> allTasks; // Using List interface type
    private Random random; // For simulating task processing outcome

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>(); // ArrayList implements List
        this.random = new Random();
    }

    /**
     * Adds a new task to the system.
     * @param description The description of the task.
     * @throws IllegalArgumentException if description is null or empty after trimming.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasks.offer(newTask); // Add to the pending queue (offer is safer)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Retrieves the task, changes its status, simulates work, and updates status based on outcome.
     * @throws IllegalStateException if the pending queue is empty.
     * @throws Exception if a simulated processing failure occurs.
     */
    public void processNextTask() throws Exception {
        // Retrieve and remove the head of the queue
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            throw new IllegalStateException("No tasks are pending in the queue.");
        }

        // The Task object is the same instance in both the queue (before poll) and the allTasks list.
        // Changing its status here directly updates the object referenced in the list.

        System.out.println("Processing task: " + taskToProcess.getId() + " - \"" + taskToProcess.getDescription() + "\"");
        taskToProcess.setStatus(Task.TaskStatus.PROCESSING);

        // Simulate work and potential failure using try-catch
        try {
            Thread.sleep(750); // Simulate work time (milliseconds)
            // Simulate a 10% chance of failure
            if (random.nextDouble() < 0.1) {
                throw new Exception("Simulated processing failure.");
            }
            // If no exception, task completed successfully
            taskToProcess.setStatus(Task.TaskStatus.COMPLETED);
            System.out.println("Task ID " + taskToProcess.getId() + " completed successfully.");

        } catch (InterruptedException e) {
            // Handle interruption during sleep
            taskToProcess.setStatus(Task.TaskStatus.FAILED);
            System.err.println("Task ID " + taskToProcess.getId() + " processing interrupted: " + e.getMessage());
            // Restore interrupt flag
            Thread.currentThread().interrupt();
            throw e; // Re-throw to be caught by the main application's handler
        } catch (Exception e) {
            // Catch the simulated failure exception
            taskToProcess.setStatus(Task.TaskStatus.FAILED);
            System.err.println("Task ID " + taskToProcess.getId() + " processing failed: " + e.getMessage());
            throw e; // Re-throw to be caught by the main application's handler
        }
    }

    /**
     * Displays details of all tasks ever created, retrieved from the allTasks list.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been created yet.");
            return;
        }
        System.out.println("\n--- All Tasks ---");
        for (Task task : allTasks) { // Iterate through the List
            System.out.println(task);
        }
        System.out.println("-----------------");
    }

    /**
     * Displays details of tasks currently in the pending queue, maintaining queue order.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
            return;
        }
        System.out.println("\n--- Pending Tasks (Next to Process) ---");
        // Iterate through the Queue without removing elements
        for (Task task : pendingTasks) {
             System.out.println(task);
        }
        System.out.println("---------------------------------------");
    }

    /**
     * Finds a task by its unique ID in the list of all tasks.
     * @param taskId The ID of the task to find.
     * @return The Task object if found, otherwise null.
     */
    public Task findTaskById(int taskId) {
        for (Task task : allTasks) { // Iterate through the List
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }
}

// Main application class with user interface and class-wide exception handling
public class AdvancedTaskManagerApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Find Task by ID");
        System.out.println("0. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Main method to run the Task Management application.
     * Contains the main loop, menu handling, and class-wide exception handling.
     */
    public static void main(String[] args) {
        System.out.println("--- Advanced Team Task Management System ---");

        boolean running = true;
        while (running) {
            printMenu();
            int choice = -1;

            // Try-catch block specifically for reading and parsing the menu choice
            try {
                System.out.print("Enter your choice: ");
                String input = scanner.nextLine();
                choice = Integer.parseInt(input); // Potential NumberFormatException
            } catch (NumberFormatException e) {
                System.err.println("Invalid input. Please enter a number for the menu choice.");
                continue; // Skip the rest of the loop and show menu again
            } catch (Exception e) {
                 // Catch any other unexpected input errors
                 System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                 continue; // Skip the rest of the loop
            }

            // Class-wide exception handling:
            // This try-catch block wraps the core logic within the switch statement.
            // It catches exceptions that might be thrown by TaskManager methods
            // and handles them gracefully at the application level.
            try {
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description); // Can throw IllegalArgumentException
                        break;

                    case 2:
                        taskManager.processNextTask(); // Can throw IllegalStateException or Exception (simulated failure)
                        break;

                    case 3:
                        taskManager.viewAllTasks();
                        break;

                    case 4:
                        taskManager.viewPendingTasks();
                        break;

                    case 5:
                        System.out.print("Enter Task ID to find: ");
                        try {
                            int taskIdToFind = Integer.parseInt(scanner.nextLine()); // Potential NumberFormatException
                            Task foundTask = taskManager.findTaskById(taskIdToFind);
                            if (foundTask != null) {
                                System.out.println("Found Task: " + foundTask);
                            } else {
                                System.out.println("Task with ID " + taskIdToFind + " not found.");
                            }
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid Task ID format. Please enter a number.");
                        }
                        break;

                    case 0:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Exit the loop
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number corresponding to the menu options (0-5).");
                }
            } catch (IllegalArgumentException e) {
                // Catch specific exceptions from addTask
                System.err.println("Operation failed: " + e.getMessage());
            } catch (IllegalStateException e) {
                 // Catch specific exceptions from processNextTask (e.g., empty queue)
                 System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                 // Catch the simulated processing failure or any other uncaught exceptions
                 // Note: Simulated failure message is already printed in TaskManager.processNextTask
                 // This catches the re-thrown exception to prevent program termination.
                 System.err.println("An unexpected error occurred during task operation: " + e.getMessage());
            }
        }

        scanner.close(); // Close the scanner resource
    }
}
