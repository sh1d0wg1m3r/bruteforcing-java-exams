/*
 * Exam Question #300
 * Generated on: 2025-05-11 22:51:41
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Warehouse Inventory and Shipment Task Processor**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for managing inventory and processing incoming shipment-related tasks in a warehouse. The system should allow a user to interact via a console menu to add new tasks to a processing queue, process the next task in the queue, view the current inventory, and view the pending task queue.
 * 
 * The system needs to manage a list of products in inventory, each with a unique ID, name, and current stock level. Incoming tasks are added to a queue and processed in a First-In, First-Out (FIFO) manner. There are two types of tasks:
 * 1.  **RECEIVE:** Represents receiving new stock for a product. Requires a product ID and quantity. Increases the stock level of the specified product.
 * 2.  **VERIFY:** Represents a stock verification task. Requires a product ID. Simply reports the current stock level of the specified product without changing it.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain the product inventory using an `ArrayList` of `Product` objects.
 *     *   Manage the incoming tasks using a `Queue` of `ShipmentTask` objects.
 * 2.  **Classes:**
 *     *   Create a `Product` class (or equivalent) to represent inventory items with `productId` (String), `name` (String), and `stockLevel` (int). Implement proper encapsulation.
 *     *   Create a `ShipmentTask` class (or equivalent) to represent tasks. It should include a `TaskType` (an enum `RECEIVE` or `VERIFY`), `productId` (String), and `quantity` (int - relevant only for `RECEIVE` tasks). Implement proper encapsulation.
 *     *   Create a main class (e.g., `WarehouseManager`) that contains the `main` method and manages the `ArrayList` of products and the `Queue` of tasks.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Shipment Task
 *         2.  Process Next Task
 *         3.  View Inventory
 *         4.  View Task Queue
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 4.  **Task Management Logic:**
 *     *   **Add Task:** Prompt the user for the task type (`RECEIVE` or `VERIFY`), product ID, and quantity (if `RECEIVE`). Create a `ShipmentTask` object and add it to the `Queue`. Validate that the product ID exists in the inventory. If not, display an error and do not add the task.
 *     *   **Process Task:** Dequeue the next task from the `Queue`. If the queue is empty, inform the user. If a task is retrieved:
 *         *   For `RECEIVE` tasks: Find the product by ID in the inventory and increase its `stockLevel` by the task's quantity.
 *         *   For `VERIFY` tasks: Find the product by ID and display its current stock level.
 *         *   If the product ID specified in the task does not exist in the current inventory, display an error message.
 *     *   **View Inventory:** Iterate through the `ArrayList` of products and print their details (ID, Name, Stock).
 *     *   **View Task Queue:** Iterate through the `Queue` and print details of each pending task. (Hint: You might need to iterate over a copy or use methods that don't remove elements to display without processing).
 * 5.  **Error Handling & Validation:**
 *     *   Implement comprehensive input validation (e.g., ensure menu choices are valid integers, product IDs exist, quantities are positive for RECEIVE tasks).
 *     *   Use `try-catch` blocks for class-wide exception handling, specifically around user input operations and task processing that might encounter issues (like invalid number format, attempting to process an empty queue, or product not found).
 *     *   Use `System.err` to output all error messages.
 *     *   Use `System.out` for all normal output (menu, confirmations, inventory lists, task queue contents).
 * 6.  **Best Practices:**
 *     *   Use the `List` interface type where appropriate (e.g., for the inventory variable).
 *     *   Employ proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Initial State:**
 * 
 * The system should start with a pre-populated inventory of at least 3-5 products. The task queue should be empty initially.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting the menu, accepting input, performing the requested action, and displaying relevant output or error messages until the user chooses to exit.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Warehouse Task Manager ---
 * 1. Add Shipment Task
 * 2. Process Next Task
 * 3. View Inventory
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 3
 * --- Inventory ---
 * ID: P001, Name: Laptop, Stock: 50
 * ID: P002, Name: Keyboard, Stock: 120
 * ID: P003, Name: Mouse, Stock: 200
 * -------------------
 * 
 * --- Warehouse Task Manager ---
 * ...
 * Enter your choice: 1
 * Enter task type (RECEIVE/VERIFY): RECEIVE
 * Enter Product ID: P001
 * Enter Quantity: 10
 * Task added to queue.
 * 
 * --- Warehouse Task Manager ---
 * ...
 * Enter your choice: 4
 * --- Task Queue ---
 * Task Type: RECEIVE, Product ID: P001, Quantity: 10
 * ------------------
 * 
 * --- Warehouse Task Manager ---
 * ...
 * Enter your choice: 2
 * Processing task: RECEIVE for Product P001, Quantity 10.
 * Stock for P001 (Laptop) updated. New stock: 60.
 * 
 * --- Warehouse Task Manager ---
 * ...
 * Enter your choice: 3
 * --- Inventory ---
 * ID: P001, Name: Laptop, Stock: 60
 * ID: P002, Name: Keyboard, Stock: 120
 * ID: P003, Name: Mouse, Stock: 200
 * -------------------
 * ...
 * Enter your choice: 2
 * Task queue is empty. No tasks to process.
 * ...
 * Enter your choice: 5
 * Exiting Warehouse Task Manager.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accuracy of the warehouse logic (adding tasks, processing RECEIVE/VERIFY, updating/viewing inventory).
 * *   Robustness of input validation and error handling.
 * *   Adherence to best practices (encapsulation, naming, comments, interface usage).
 * *   Overall code structure and readability.
 *
 * EXPLANATION:
 * This solution implements a `WarehouseManager` system that demonstrates the required Java concepts and best practices.
 * 
 * 1.  **Scenario Implementation:** The code models a simple warehouse with `Product` objects in an `inventory` (an `ArrayList` implementing the `List` interface) and `ShipmentTask` objects in a `taskQueue` (a `LinkedList` implementing the `Queue` interface). The user interacts via a console menu.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: Used for `taskQueue`. Tasks are added using `offer()` and processed (removed) using `poll()`. `peek()` is used to check if the queue is empty before attempting to process.
 *     *   `java.util.ArrayList`: Used to initialize and hold the `Product` objects in the `inventory`.
 *     *   `java.util.List`: The `inventory` variable is declared as `List<Product>`, demonstrating coding to the interface rather than the specific implementation (`ArrayList`).
 *     *   `java.util.Scanner`: An instance `scanner` is used to read user input from `System.in`.
 *     *   `switch`: Used in the `run()` method to direct program flow based on the user's menu choice.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input, product not found, or exceptions caught in `try-catch` blocks.
 *     *   `System.out`: Used for all normal output, including the menu, confirmations, inventory listings, and task queue contents.
 *     *   `try-catch`: Exception handling is implemented in the `run()` method's main loop to catch `InputMismatchException` (for invalid non-integer input) and general `Exception`s. It's also used within `addShipmentTask` and `processNextTask` to handle potential errors specific to those operations (like `IllegalArgumentException` for invalid enum value or `InputMismatchException` for quantity). This provides class-wide handling by wrapping the core interactive logic.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** `Product` and `ShipmentTask` classes have `private` fields and `public` getter methods. `Product` also has a `public` setter for `stockLevel`. The `inventory` and `taskQueue` in `WarehouseManager` are also `private`.
 *     *   **Meaningful Names:** Class names (`WarehouseManager`, `Product`, `ShipmentTask`), variable names (`inventory`, `taskQueue`, `productId`, `stockLevel`, `type`, `quantity`), method names (`run`, `printMenu`, `addShipmentTask`, `processNextTask`, `viewInventory`, `viewTaskQueue`, `findProductById`) are descriptive.
 *     *   **Comments and Documentation:** Basic inline comments explain key parts, and Javadoc-style comments precede classes and methods explaining their purpose.
 *     *   **Input Validation:** Checks are performed to ensure the task type is valid (`RECEIVE`/`VERIFY`), the product ID exists in the inventory when adding a task, and the quantity for `RECEIVE` tasks is positive. The `try-catch` for `InputMismatchException` handles non-integer input gracefully.
 *     *   **Error Handling:** `try-catch` blocks catch exceptions, and `System.err` is used for error output. Specific error messages are provided for validation failures (e.g., product not found, invalid type/quantity).
 *     *   **Clean Code Structure:** The code is organized into separate classes with distinct responsibilities. The `WarehouseManager` class orchestrates the process with dedicated methods for each menu option. The main loop is kept clean by delegating logic to these methods. The `Scanner` is closed upon exit.
 *     *   **List Interface:** Using `List<Product> inventory` instead of `ArrayList<Product> inventory` allows flexibility if a different `List` implementation were needed later.
 * 
 * 4.  **Complexity:** The problem requires understanding object-oriented design (multiple classes, encapsulation), data structures (`List`, `Queue`), control flow (`switch`, loops), user input handling (`Scanner`), and robust error management (`try-catch`, validation, `System.err`). Processing tasks involves looking up items in the inventory, which adds a layer of interaction between the data structures. Iterating over the queue for viewing without removing elements requires a specific approach (like creating a copy), adding a subtle point of complexity. This combination makes it a suitable challenge for an advanced student within the given time frame.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for task types
enum TaskType {
    RECEIVE, VERIFY
}

// Represents a product in the inventory
class Product {
    private String productId;
    private String name;
    private int stockLevel;

    public Product(String productId, String name, int stockLevel) {
        this.productId = productId;
        this.name = name;
        this.stockLevel = stockLevel;
    }

    public String getProductId() {
        return productId;
    }

    public String getName() {
        return name;
    }

    public int getStockLevel() {
        return stockLevel;
    }

    public void setStockLevel(int stockLevel) {
        this.stockLevel = stockLevel;
    }

    @Override
    public String toString() {
        return "ID: " + productId + ", Name: " + name + ", Stock: " + stockLevel;
    }
}

// Represents a shipment task
class ShipmentTask {
    private TaskType type;
    private String productId;
    private int quantity; // Only relevant for RECEIVE

    public ShipmentTask(TaskType type, String productId, int quantity) {
        this.type = type;
        this.productId = productId;
        this.quantity = quantity;
    }

    public TaskType getType() {
        return type;
    }

    public String getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Task Type: ").append(type).append(", Product ID: ").append(productId);
        if (type == TaskType.RECEIVE) {
            sb.append(", Quantity: ").append(quantity);
        }
        return sb.toString();
    }
}

// Main class managing warehouse operations
public class WarehouseManager {

    // Use List interface for inventory
    private List<Product> inventory;
    // Use Queue interface for tasks
    private Queue<ShipmentTask> taskQueue;
    private Scanner scanner;

    public WarehouseManager() {
        // Initialize inventory using ArrayList
        inventory = new ArrayList<>();
        // Initialize task queue using LinkedList (implements Queue)
        taskQueue = new LinkedList<>();
        scanner = new Scanner(System.in);

        // Pre-populate inventory
        inventory.add(new Product("P001", "Laptop", 50));
        inventory.add(new Product("P002", "Keyboard", 120));
        inventory.add(new Product("P003", "Mouse", 200));
        inventory.add(new Product("P004", "Monitor", 30));
    }

    // Method to find a product by ID
    private Product findProductById(String productId) {
        for (Product product : inventory) {
            if (product.getProductId().equalsIgnoreCase(productId)) {
                return product;
            }
        }
        return null; // Product not found
    }

    // Main loop for the warehouse manager
    public void run() {
        System.out.println("--- Warehouse Task Manager ---");
        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addShipmentTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewInventory();
                        break;
                    case 4:
                        viewTaskQueue();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Warehouse Task Manager.");
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Use System.err for non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err
            }
            System.out.println(); // Add a blank line for readability
        }
        scanner.close(); // Close the scanner when exiting
    }

    private void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add Shipment Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Inventory");
        System.out.println("4. View Task Queue");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    private void addShipmentTask() {
        try {
            System.out.print("Enter task type (RECEIVE/VERIFY): ");
            String typeStr = scanner.nextLine().trim().toUpperCase();
            TaskType type;
            try {
                type = TaskType.valueOf(typeStr);
            } catch (IllegalArgumentException e) {
                System.err.println("Error: Invalid task type. Must be RECEIVE or VERIFY.");
                return;
            }

            System.out.print("Enter Product ID: ");
            String productId = scanner.nextLine().trim();

            // Validate product exists before creating task
            if (findProductById(productId) == null) {
                System.err.println("Error: Product with ID '" + productId + "' not found in inventory.");
                return;
            }

            int quantity = 0; // Default for VERIFY
            if (type == TaskType.RECEIVE) {
                System.out.print("Enter Quantity: ");
                quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive for RECEIVE tasks.");
                    return;
                }
            }

            ShipmentTask newTask = new ShipmentTask(type, productId, quantity);
            taskQueue.offer(newTask); // Use offer() as it's generally preferred for queues
            System.out.println("Task added to queue.");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid quantity entered. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
            System.err.println("An error occurred while adding task: " + e.getMessage());
            e.printStackTrace(System.err);
        }
    }

    private void processNextTask() {
        // Use peek() to check if queue is empty without removing
        ShipmentTask nextTask = taskQueue.peek();
        if (nextTask == null) {
            System.out.println("Task queue is empty. No tasks to process.");
            return;
        }

        // If not empty, poll() to remove the task for processing
        nextTask = taskQueue.poll();
        System.out.println("Processing task: " + nextTask);

        try {
            Product productToUpdate = findProductById(nextTask.getProductId());

            if (productToUpdate == null) {
                System.err.println("Error: Product with ID '" + nextTask.getProductId() + "' specified in task not found. Task discarded.");
                return; // Discard task if product doesn't exist
            }

            switch (nextTask.getType()) {
                case RECEIVE:
                    productToUpdate.setStockLevel(productToUpdate.getStockLevel() + nextTask.getQuantity());
                    System.out.println("Stock for " + productToUpdate.getProductId() + " (" + productToUpdate.getName() + ") updated. New stock: " + productToUpdate.getStockLevel());
                    break;
                case VERIFY:
                    System.out.println("Verification task for " + productToUpdate.getProductId() + " (" + productToUpdate.getName() + "). Current stock: " + productToUpdate.getStockLevel());
                    break;
            }
        } catch (Exception e) {
             System.err.println("An error occurred while processing task: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    private void viewInventory() {
        System.out.println("--- Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product); // Uses Product's toString()
            }
        }
        System.out.println("-------------------");
    }

    private void viewTaskQueue() {
        System.out.println("--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty.");
        } else {
            // Iterate over the queue without removing elements
            // A common way is to convert to an array or stream, or iterate using an iterator
            // Converting to ArrayList for easy iteration for display purposes
            List<ShipmentTask> tasksToDisplay = new ArrayList<>(taskQueue);
            for (ShipmentTask task : tasksToDisplay) {
                System.out.println(task); // Uses ShipmentTask's toString()
            }
        }
        System.out.println("------------------");
    }

    public static void main(String[] args) {
        // Class-wide exception handling is typically done within the main execution flow
        // or by wrapping the core logic method calls in a try-catch.
        // Here, the `run()` method contains the main loop which is wrapped in try-catch.
        WarehouseManager manager = new WarehouseManager();
        manager.run();
    }
}
