/*
 * Exam Question #679
 * Generated on: 2025-05-12 16:24:41
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Engineering Team Task Management System**
 * 
 * **Scenario:**
 * Your task is to develop a simplified command-line application for managing tasks for a small engineering team. The system should allow adding new tasks, viewing pending tasks, processing the next task, and viewing completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private attributes:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing priority (e.g., 1 for high, 5 for low).
 *     *   `status` (String): The current status of the task (e.g., "PENDING", "COMPLETED").
 *     *   Include a constructor, getter methods for all attributes, and a method to update the status (e.g., `markAsCompleted()`). Implement a meaningful `toString()` method for easy display.
 * 
 * 2.  **Task Management System:** Create a class named `TaskScheduler` that manages the tasks. This class must use:
 *     *   A `java.util.Queue<Task>` (specifically, an implementation like `LinkedList`) to hold tasks that are pending. Tasks should be processed in the order they are added (FIFO).
 *     *   A `java.util.List<Task>` (specifically, an `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` object, assigns a unique ID, sets initial status to "PENDING", and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, updates its status to "COMPLETED", and adds it to the completed list. If the queue is empty, it should indicate an error.
 *         *   `getPendingTasks()`: Returns the pending tasks queue (or a safe representation of it for display).
 *         *   `getCompletedTasks()`: Returns the completed tasks list.
 *         *   A private counter for generating unique task IDs.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `TaskApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  Process Next Task
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation:
 *         *   For menu choices, ensure the input is a valid integer within the range of options.
 *         *   For task priority, ensure it's an integer within a reasonable range (e.g., 1-5).
 *         *   For task description, ensure it's not empty.
 *     *   Use `System.out` for displaying the menu, task information, and success messages.
 *     *   Use `System.err` to display error messages, such as invalid input, attempting to process a task when the queue is empty, etc.
 * 
 * 4.  **Exception Handling:** Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle unexpected errors during program execution (e.g., non-integer input where an integer is expected). Also, handle specific errors like attempting to process an empty queue within the `processNextTask` method, reporting it via `System.err`.
 * 
 * 5.  **Best Practices:** Ensure your code follows best practices:
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Add comments to explain complex parts or logic.
 *     *   Structure your code logically into classes and methods.
 * 
 * **Expected Output:**
 * The program should run continuously, presenting the menu, accepting user input, performing the requested action, and displaying results or errors until the user chooses to exit. Output formats for tasks should be clear, leveraging the `Task` class's `toString()` method. Error messages should be distinct (using `System.err`).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter priority (1-5): 1
 * Task added: Task{id=1, description='Implement login feature', priority=1, status='PENDING'}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * Task{id=1, description='Implement login feature', priority=1, status='PENDING'}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Processing task: Task{id=1, description='Implement login feature', priority=1, status='PENDING'}
 * Task 1 marked as COMPLETED.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Implement login feature', priority=1, status='COMPLETED'}
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Error: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * This task requires you to integrate several core Java collection types, handle user interaction robustly, and implement proper error management, demonstrating a solid grasp of practical Java development.
 *
 * EXPLANATION:
 * The solution provides a command-line application for managing tasks, fulfilling all the specified requirements.
 * 
 * 1.  **`Task` Class:** This class represents a single task with its attributes (`id`, `description`, `priority`, `status`). It demonstrates encapsulation with private fields and public getter methods. The `markAsCompleted()` method provides a controlled way to change the status. The `toString()` method is overridden for clear display of task information.
 * 
 * 2.  **`TaskScheduler` Class:** This is the core of the task management logic.
 *     *   It uses a `java.util.Queue<Task>` (implemented by `LinkedList`) called `pendingTasks` to store tasks awaiting processing. The `Queue` interface naturally supports FIFO (First-In, First-Out) behavior, which is suitable for processing tasks in the order they were added. `addTask` uses `add()` to enqueue, and `processNextTask` uses `poll()` to dequeue.
 *     *   It uses a `java.util.List<Task>` (implemented by `java.util.ArrayList`) called `completedTasks` to store tasks once they are finished. `ArrayList` is a common and efficient choice for storing a dynamic list of items.
 *     *   The `addTask` method creates a new `Task` with a unique ID generated by `nextTaskId` and adds it to the `pendingTasks` queue.
 *     *   The `processNextTask` method attempts to remove a task from the `pendingTasks` queue using `poll()`. If `poll()` returns `null`, it means the queue is empty, and an error message is printed to `System.err`. Otherwise, the retrieved task's status is updated, and it's added to the `completedTasks` list.
 *     *   `getPendingTasks` and `getCompletedTasks` provide access to the collections for displaying their contents.
 * 
 * 3.  **`TaskApp` Class (Main):** This class contains the `main` method and handles the user interface.
 *     *   It uses `java.util.Scanner` to read user input from the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to direct the program flow based on the user's menu selection.
 *     *   **Input Validation:** Nested `while` loops and `try-catch(InputMismatchException)` blocks are used to robustly handle user input for both the menu choice and task priority, ensuring only valid integers within the expected range are accepted. Description input is validated to prevent emptiness. Invalid input triggers an error message printed to `System.err` and the user is prompted again.
 *     *   **Output:** `System.out` is used for the menu, prompts, success messages, and displaying task lists. `System.err` is specifically used for printing error messages, making them distinct from normal output.
 *     *   **Viewing Collections:** When viewing pending or completed tasks, the code iterates through the respective `Queue` or `List` using `forEach` and prints each task's `toString()` representation. For the `Queue`, iterating does not remove elements, which is appropriate for just viewing.
 * 
 * 4.  **Exception Handling:**
 *     *   A `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur within the application loop and printing an error message to `System.err` before potentially terminating.
 *     *   Specific error handling for an empty queue is implemented within the `processNextTask` method itself, reporting the "No pending tasks" condition using `System.err` without throwing an exception, as this is a predictable operational state rather than an exceptional error.
 *     *   `InputMismatchException` is specifically caught during `Scanner.nextInt()` calls for robust input validation, preventing the program from crashing on non-integer input.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` and `TaskScheduler` classes.
 *     *   Variable and method names (`pendingTasks`, `processNextTask`, `addTask`, `nextTaskId`, etc.) are descriptive.
 *     *   Comments explain the purpose of classes, methods, and important code blocks.
 *     *   The code is structured logically into separate classes with clear responsibilities.
 *     *   The `finally` block ensures the `Scanner` resource is closed properly when the application exits.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a practical, well-structured, and error-handled application, suitable for evaluating advanced Java understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task with its details and status
class Task {
    private int id;
    private String description;
    private int priority;
    private String status; // e.g., "PENDING", "COMPLETED"

    // Constructor
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Methods to update status ---
    public void markAsCompleted() {
        this.status = "COMPLETED";
    }

    // --- toString method for easy display ---
    @Override
    public String toString() {
        return String.format("Task{id=%d, description='%s', priority=%d, status='%s'}",
                             id, description, priority, status);
    }
}

// Manages the collection of tasks using Queue and List
class TaskScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for unique IDs

    // Constructor
    public TaskScheduler() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start ID from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The task description.
     * @param priority The task priority (e.g., 1-5).
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.add(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task from pending to completed status.
     * Returns true if a task was processed, false if the queue was empty.
     */
    public boolean processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            // Use System.err for error message
            System.err.println("Error: No pending tasks to process.");
            return false;
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.markAsCompleted(); // Update status
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task " + taskToProcess.getId() + " marked as COMPLETED.");
            return true;
        }
    }

    /**
     * Returns a view of the pending tasks queue.
     * Note: Returning the queue directly allows iteration but modifications should be avoided.
     * For simple display, iterating over the queue is fine.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Returns the list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

// Main class to run the application and handle user interaction
public class TaskApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskScheduler scheduler = new TaskScheduler();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Input validation loop for menu choice
                while (choice == -1) {
                    System.out.print("Enter your choice: ");
                    try {
                        choice = scanner.nextInt();
                        // Consume the newline character left by nextInt()
                        scanner.nextLine();
                        if (choice < 1 || choice > 5) {
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                            choice = -1; // Reset to invalid to loop again
                        }
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input
                        choice = -1; // Reset to invalid to loop again
                    }
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        // Input validation for description
                        if (description.isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                            break; // Skip adding task
                        }

                        int priority = -1;
                        // Input validation loop for priority
                        while (priority == -1) {
                            System.out.print("Enter priority (1-5): ");
                            try {
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                if (priority < 1 || priority > 5) {
                                    System.err.println("Error: Priority must be between 1 and 5.");
                                    priority = -1; // Reset
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input. Please enter a number for priority.");
                                scanner.next(); // Consume invalid input
                                priority = -1; // Reset
                            }
                        }
                        scheduler.addTask(description, priority);
                        break;

                    case 2: // View Pending Tasks
                        System.out.println("--- Pending Tasks ---");
                        Queue<Task> pending = scheduler.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate through the queue without removing elements
                            pending.forEach(System.out::println);
                        }
                        break;

                    case 3: // Process Next Task
                        scheduler.processNextTask(); // Handles its own error reporting via System.err
                        break;

                    case 4: // View Completed Tasks
                        System.out.println("--- Completed Tasks ---");
                        List<Task> completed = scheduler.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            // Iterate through the list
                            completed.forEach(System.out::println);
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;

                    default:
                        // This case should ideally not be reached due to the validation loop,
                        // but included for completeness in the switch.
                        System.err.println("Error: Unexpected menu choice.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
