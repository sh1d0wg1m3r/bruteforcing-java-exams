/*
 * Exam Question #484
 * Generated on: 2025-05-11 23:17:58
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Task: Restaurant Order Management System
 * 
 * **Objective:** Design and implement a simplified restaurant order management system using core Java concepts. This task requires you to demonstrate proficiency in data structures, object-oriented programming, user interaction, and robust error handling.
 * 
 * **Scenario:** You are building the backend logic for a small restaurant's order system. Customers place orders, which are then processed by the kitchen in the order they were received.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items.
 *     *   Manage a queue of pending customer orders.
 * 2.  **Classes:**
 *     *   `MenuItem`: Represents a single item on the menu. Should have a name (String) and a price (double). Use proper encapsulation.
 *     *   `Order`: Represents a customer's order. Should contain a list of `MenuItem`s. Generate a unique order number for each order. Provide a method to calculate the total price and a method to display the order details. Use proper encapsulation.
 *     *   `Restaurant`: The main class that orchestrates the system. It should hold the menu and the queue of pending orders.
 * 3.  **Functionality (within the `Restaurant` class):**
 *     *   Display the menu to the user.
 *     *   Allow the user to place a new order by selecting items from the menu. An order can contain multiple items.
 *     *   Allow the kitchen to serve the next pending order (remove it from the queue and display its details).
 *     *   Allow the user to view the list of pending order numbers and their totals without removing them from the queue.
 *     *   Provide a simple text-based menu interface for the user (e.g., 1. Place Order, 2. Serve Next Order, 3. View Pending Orders, 4. Exit).
 * 4.  **Required Java Components:**
 *     *   `java.util.Queue` (for pending orders)
 *     *   `java.util.ArrayList` (to implement the menu list and the list of items within an `Order`)
 *     *   `java.util.List` (as the interface type for menu and order items)
 *     *   `java.util.Scanner` (for user input)
 *     *   `switch` statement (for the main menu selection)
 *     *   `System.err` (for displaying error messages, e.g., invalid input, trying to serve when no orders are pending)
 *     *   `System.out` (for normal output, e.g., menu, prompts, order details)
 *     *   Class-wide exception handling with `try-catch` blocks (e.g., handling invalid user input, potential issues with queue operations).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus, but clear inline comments are sufficient for an exam).
 *     *   Implement input validation (e.g., ensuring menu choices are valid numbers within range).
 *     *   Handle potential errors gracefully using `try-catch`.
 *     *   Structure the code logically into classes and methods.
 * 
 * **User Interaction Flow:**
 * 
 * The program should present a menu of options. Based on the user's selection, it performs the requested action.
 * *   **Place Order:** Prompts the user to select items from the numbered menu one by one until they indicate they are finished. Adds the created `Order` to the pending queue.
 * *   **Serve Next Order:** Removes the oldest order from the queue and displays its contents and total. If no orders are pending, display an appropriate message using `System.out`.
 * *   **View Pending Orders:** Lists the order number and total price for all orders currently in the queue, from oldest to newest. If no orders are pending, display an appropriate message using `System.out`.
 * *   **Exit:** Terminates the program.
 * 
 * **Error Handling Examples:**
 * *   If the user enters non-numeric input when a number is expected (like menu choice), catch the `InputMismatchException`, print an error to `System.err`, and allow them to try again.
 * *   If the user enters a number outside the valid range (e.g., menu item index), print an error to `System.err`.
 * *   If an unexpected error occurs, catch a general `Exception` and print an error to `System.err`.
 * 
 * **Expected Output:**
 * 
 * Clear prompts for user input, well-formatted menu display, detailed order display when served, list of pending orders, and informative error messages using `System.err` when necessary.
 * 
 * **Assessment:** Your solution will be assessed on correctness, adherence to all requirements (especially the use of specified components), code quality, error handling robustness, and clarity of implementation.
 *
 * EXPLANATION:
 * This solution implements a basic restaurant order management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple POJO (Plain Old Java Object) with `name` and `price`. It uses `private` fields and public getters for encapsulation. `toString()` is overridden for convenient printing.
 *     *   `Order`: Represents an order with a unique `orderNumber` (managed by a static counter `nextOrderNumber`) and a `List<MenuItem>` (`items`). It uses an `ArrayList` to store the items. Methods are provided to `addItem`, `calculateTotal`, and `displayOrder`. Encapsulation is maintained.
 *     *   `Restaurant`: The main class containing the application logic. It holds the `List<MenuItem>` (`menu`) representing the available items (implemented using `ArrayList`) and the `Queue<Order>` (`pendingOrders`) representing orders waiting to be served (implemented using `LinkedList`). It also manages the `Scanner` for user input.
 * 
 * 2.  **Data Structures Implementation:**
 *     *   `List<MenuItem> menu = new ArrayList<>();`: An `ArrayList` is used to store the menu items. `ArrayList` is suitable here because we need indexed access to display the menu and retrieve items by number, and the size is relatively small and fixed during runtime.
 *     *   `Queue<Order> pendingOrders = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface for pending orders. `Queue` is appropriate because orders are processed in a First-In, First-Out (FIFO) manner. `LinkedList` provides an efficient implementation for queue operations like `offer()` (add to end) and `poll()` (remove from front).
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner scanner = new Scanner(System.in);`: Used to read user input from the console.
 *     *   `Restaurant.run()`: Contains the main application loop. It repeatedly displays a menu of options.
 *     *   `switch (choice)`: A `switch` statement is used within the main loop to direct execution based on the user's numeric input (1, 2, 3, or 4).
 *     *   Private helper methods (`displayMenu`, `placeOrder`, `serveNextOrder`, `viewPendingOrders`) encapsulate the logic for each menu option, keeping the `run()` method clean.
 * 
 * 4.  **Required Components Usage:**
 *     *   `Queue`: Used for `pendingOrders`. Methods like `offer()` (add to queue) and `poll()` (remove from queue) are used in `placeOrder` and `serveNextOrder` respectively. Iteration over the queue is done in `viewPendingOrders` without removing elements.
 *     *   `ArrayList`: Used to implement the `menu` and the `items` list within the `Order` class.
 *     *   `List`: Used as the interface type for `menu` and `Order.items`, promoting good practice by coding to the interface.
 *     *   `Scanner`: Used in the `Restaurant` class constructor and methods (`run`, `placeOrder`) to read user input.
 *     *   `switch`: Used in the `run` method for the main menu dispatch.
 *     *   `System.err`: Used to print error messages when input validation fails (`InputMismatchException`, invalid menu number) or when unexpected exceptions occur.
 *     *   `System.out`: Used for all normal output, including displaying the menu, prompts, confirmation messages, and order details.
 *     *   `try-catch`: Implemented at multiple levels:
 *         *   A general `try-catch(Exception e)` block wraps the main `run()` loop to catch any unexpected runtime errors in the application flow and print them to `System.err`.
 *         *   Specific `try-catch(InputMismatchException e)` blocks are used when reading integer input (`scanner.nextInt()`) in both the main loop and the `placeOrder` method to handle cases where the user enters non-numeric text. The invalid input is consumed using `scanner.nextLine()` to prevent infinite loops.
 *         *   A `try-catch(Exception e)` block is also included within the item selection loop in `placeOrder` as a general safeguard.
 *         *   Input validation for menu item numbers (`itemChoice > 0 && itemChoice <= menu.size()`) is done *before* accessing the `menu` list, preventing `IndexOutOfBoundsException`. If an invalid number is entered, an error is printed to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** `MenuItem` and `Order` classes have private fields and public methods (getters, adders, calculators, displayers).
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingOrders`, `placeOrder`, `calculateTotal`).
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic sections.
 *     *   **Input Validation:** Checks are performed for both the *type* of input (using `try-catch InputMismatchException`) and the *value* of input (checking bounds for menu item numbers).
 *     *   **Error Handling:** `try-catch` blocks are strategically placed. Specific errors like `InputMismatchException` are handled gracefully, and a general catch block handles unexpected issues. `System.err` is used correctly for error output. The `serveNextOrder` and `viewPendingOrders` methods check `pendingOrders.isEmpty()` *before* attempting operations, preventing `NoSuchElementException` which `remove()` would throw on an empty queue (using `poll()` is also safer as it returns null).
 *     *   **Clean Code:** The code is divided into logical classes and methods. The `run` method provides a clear overview of the program's main loop. Resource management is handled by closing the `Scanner` in a `finally` block.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating understanding of data structures, object-oriented design, user interaction handling, and robust error management, making it suitable for an advanced Java exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the restaurant menu
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    // Getters for encapsulated fields
    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the menu item.
     */
    @Override
    public String toString() {
        return String.format("%s (%.2f)", name, price);
    }
}

// Represents a customer's order
class Order {
    private static int nextOrderNumber = 1; // Static counter for unique order numbers
    private int orderNumber;
    private List<MenuItem> items; // List of items in the order

    /**
     * Constructs a new Order with a unique order number.
     */
    public Order() {
        this.orderNumber = nextOrderNumber++; // Assign unique number and increment counter
        this.items = new ArrayList<>(); // Initialize the list of items
    }

    /**
     * Adds a MenuItem to the order.
     * @param item The item to add.
     */
    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
        }
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double calculateTotal() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    /**
     * Gets the unique order number.
     * @return The order number.
     */
    public int getOrderNumber() {
        return orderNumber;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of MenuItems.
     */
    public List<MenuItem> getItems() {
        return items;
    }

    /**
     * Displays the details of the order, including items and total.
     */
    public void displayOrder() {
        System.out.println("--- Order #" + orderNumber + " ---");
        if (items.isEmpty()) {
            System.out.println("  (Empty Order)");
        } else {
            for (MenuItem item : items) {
                System.out.println("  - " + item.getName() + ": $" + String.format("%.2f", item.getPrice()));
            }
        }
        System.out.println("  Total: $" + String.format("%.2f", calculateTotal()));
        System.out.println("--------------------");
    }
}

// Manages the restaurant's menu and pending orders
public class Restaurant {
    private List<MenuItem> menu; // List of available menu items (using ArrayList)
    private Queue<Order> pendingOrders; // Queue of pending orders (using LinkedList)
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new Restaurant instance.
     * Initializes the menu, pending orders queue, and scanner.
     */
    public Restaurant() {
        this.menu = new ArrayList<>(); // Initialize ArrayList for menu
        initializeMenu(); // Populate the menu
        this.pendingOrders = new LinkedList<>(); // Initialize LinkedList as Queue
        this.scanner = new Scanner(System.in); // Initialize Scanner
    }

    /**
     * Populates the menu with some sample items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza Slice", 3.50));
        menu.add(new MenuItem("Fries", 2.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Salad", 7.50));
    }

    /**
     * Displays the current menu to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menu.size(); i++) {
            System.out.println((i + 1) + ". " + menu.get(i));
        }
        System.out.println("------------");
    }

    /**
     * Handles the process of a customer placing a new order.
     * Prompts user for item selection and adds the order to the queue.
     */
    private void placeOrder() {
        Order currentOrder = new Order();
        boolean addingItems = true;

        System.out.println("\n--- Placing New Order ---");

        while (addingItems) {
            displayMenu();
            System.out.print("Enter item number to add (or 0 to finish order): ");

            try {
                int itemChoice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                if (itemChoice == 0) {
                    addingItems = false; // User wants to finish the order
                } else if (itemChoice > 0 && itemChoice <= menu.size()) {
                    // Valid item selected
                    MenuItem selectedItem = menu.get(itemChoice - 1);
                    currentOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else {
                    // Invalid item number
                    System.err.println("Error: Invalid item number. Please choose from the menu (1-" + menu.size() + ").");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected errors during input
                System.err.println("An unexpected error occurred during item selection: " + e.getMessage());
                // Depending on severity, might need to exit or break the loop
                // For this exam, just print and continue is acceptable.
            }
        }

        // After the loop, if the order has items, add it to the queue
        if (!currentOrder.getItems().isEmpty()) {
            pendingOrders.offer(currentOrder); // Add the order to the end of the queue
            System.out.println("\nOrder #" + currentOrder.getOrderNumber() + " placed successfully!");
            System.out.println("Total: $" + String.format("%.2f", currentOrder.calculateTotal()));
        } else {
            System.out.println("\nNo items added. Order cancelled.");
        }
    }

    /**
     * Handles serving the next order from the queue.
     * Removes the order from the front and displays its details.
     */
    private void serveNextOrder() {
        System.out.println("\n--- Serving Next Order ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No orders pending.");
        } else {
            // Retrieve and remove the head of the queue
            Order servedOrder = pendingOrders.poll();
            System.out.println("Serving order #" + servedOrder.getOrderNumber() + ":");
            servedOrder.displayOrder();
        }
    }

    /**
     * Displays a summary of all orders currently in the pending queue.
     * Does not remove orders from the queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No orders pending.");
        } else {
            // Iterate through the queue without removing elements
            int count = 0;
            for (Order order : pendingOrders) {
                System.out.println("  Order #" + order.getOrderNumber() + " - Total: $" + String.format("%.2f", order.calculateTotal()));
                count++;
            }
            System.out.println("Total pending orders: " + count);
        }
    }

    /**
     * Runs the main interactive loop for the restaurant system.
     */
    public void run() {
        int choice = -1; // Initialize choice outside the loop

        try {
            while (choice != 4) {
                System.out.println("\nRestaurant Management System");
                System.out.println("1. Place New Order");
                System.out.println("2. Serve Next Order");
                System.out.println("3. View Pending Orders");
                System.out.println("4. Exit");
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt();
                    // Consume the newline character
                    scanner.nextLine();

                    // Use a switch statement for menu selection
                    switch (choice) {
                        case 1:
                            placeOrder();
                            break;
                        case 2:
                            serveNextOrder();
                            break;
                        case 3:
                            viewPendingOrders();
                            break;
                        case 4:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            // Handle invalid numeric input for the main menu
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the main menu
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to stay in the loop and re-prompt
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the main loop
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Confirmation
        }
    }

    /**
     * Main method to start the Restaurant application.
     */
    public static void main(String[] args) {
        Restaurant restaurant = new Restaurant();
        restaurant.run(); // Start the main application loop
    }
}
