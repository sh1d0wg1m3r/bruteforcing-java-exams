/*
 * Exam Question #989
 * Generated on: 2025-05-12 17:09:29
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Topic:** Data Structures, Object-Oriented Programming, Exception Handling, I/O
 * **Time Allotment:** 60 minutes
 * 
 * **Task:** Design and implement a simplified **Resource Allocation and Task Processing System**.
 * 
 * This system manages incoming requests that require a certain amount of a shared resource. Requests are queued and processed one by one when the resource is available.
 * 
 * You must create a Java application that fulfills the following requirements:
 * 
 * 1.  **Request Representation:** Create a class `ProcessingRequest` with the following properties:
 *     *   A unique integer `id`.
 *     *   An integer `resourceNeeded` representing the amount of resource this request consumes.
 *     *   A boolean `isProcessed` indicating if the request has been completed.
 *     *   Appropriate constructor, getters, and a method to mark the request as processed.
 * 
 * 2.  **System Management:** Create a class `ResourceProcessor` that manages the system state. It must contain:
 *     *   A `Queue<ProcessingRequest>` to hold incoming requests waiting for processing.
 *     *   A `List<ProcessingRequest>` to store requests that have been successfully processed.
 *     *   An integer representing the `availableResources` in the system.
 *     *   A counter for generating unique request IDs.
 *     *   Methods for:
 *         *   Initializing the system with a given amount of total resources.
 *         *   Adding a new `ProcessingRequest` to the queue. This method should generate a unique ID.
 *         *   Attempting to process the next request from the queue. This method should:
 *             *   Check if the queue is empty.
 *             *   If not empty, peek at the first request.
 *             *   Check if `availableResources` is sufficient for the request's `resourceNeeded`.
 *             *   If sufficient: Dequeue the request, mark it as processed, add it to the processed list, and decrease `availableResources`.
 *             *   If insufficient resources or queue is empty: Print an appropriate message (to `System.out`).
 *         *   Displaying the current system status: Show `availableResources`, the number of requests in the queue, and list the IDs of processed requests.
 * 
 * 3.  **User Interface:** Implement a command-line interface using `Scanner` in the `main` method (or a dedicated `run` method called from main). The interface should present a menu and use a `switch` statement to handle user commands:
 *     *   `1`: Add new request (prompt for resource needed).
 *     *   `2`: Process next request.
 *     *   `3`: View system status.
 *     *   `4`: Exit.
 * 
 * 4.  **Input Validation & Error Handling:**
 *     *   Use `try-catch` blocks to handle potential `NumberFormatException` when parsing user input (resource needed, menu choice). Print error messages using `System.err`.
 *     *   Validate that the resource needed for a new request is a positive integer. Use `System.err` for invalid input.
 *     *   Implement class-wide exception handling where appropriate (e.g., within methods that might fail due to invalid state or input).
 * 
 * 5.  **Constraints & Best Practices:**
 *     *   Use `java.util.Queue` (specifically, you can use `LinkedList` which implements `Queue`).
 *     *   Use `java.util.ArrayList` for the processed requests list.
 *     *   Use the `java.util.List` interface for declaring the processed requests list variable.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts.
 * 
 * **Expected Output:**
 * The program should present a menu, accept user input, perform actions, and display status or error messages as described.
 * 
 * *   Adding a request: Should show the ID of the newly added request.
 * *   Processing: Should indicate if a request was processed or why it couldn't be (queue empty, insufficient resources).
 * *   Status: Should clearly show available resources, queue size, and processed request IDs.
 * *   Errors: Should print messages to `System.err` for invalid input.
 * 
 * ```
 * Resource Allocation System
 * Available Commands:
 * 1. Add Request
 * 2. Process Next Request
 * 3. View Status
 * 4. Exit
 * Enter command:
 * ```
 * 
 * *(... interaction based on user input ...)*
 * 
 * ```
 * Enter command: 1
 * Enter resource needed for the request: 5
 * Request added with ID: 1
 * Enter command: 1
 * Enter resource needed for the request: 3
 * Request added with ID: 2
 * Enter command: 2
 * Processing request ID: 1
 * Enter command: 2
 * Insufficient resources to process request ID: 2 (needs 3, available 5)
 * Enter command: 3
 * --- System Status ---
 * Available Resources: 5
 * Requests in Queue: 1
 * Processed Requests: [1]
 * ---------------------
 * Enter command: 2
 * Processing request ID: 2
 * Enter command: 3
 * --- System Status ---
 * Available Resources: 2
 * Requests in Queue: 0
 * Processed Requests: [1, 2]
 * ---------------------
 * Enter command: 4
 * Exiting system.
 * ```
 * 
 * *(This is an example flow, actual output may vary based on input and implementation details like specific messages)*
 *
 * EXPLANATION:
 * The provided solution implements a `Resource Allocation and Task Processing System` using the required Java components and best practices.
 * 
 * 1.  **`ProcessingRequest` Class:**
 *     *   Represents a single unit of work needing resources.
 *     *   Uses `private` fields (`id`, `resourceNeeded`, `isProcessed`) for encapsulation.
 *     *   Provides `public` getter methods and a `markAsProcessed()` method to control access and state changes.
 * 
 * 2.  **`ResourceProcessor` Class:**
 *     *   This is the core class managing the system state and logic.
 *     *   **`Queue<ProcessingRequest> requestQueue`:** Uses `java.util.Queue` (implemented by `LinkedList`) to store incoming requests in a First-In, First-Out (FIFO) manner, simulating a waiting line. `offer()` is used for adding, and `peek()` and `poll()` for inspecting and removing elements, respectively.
 *     *   **`List<ProcessingRequest> processedRequests`:** Uses `java.util.List` (implemented by `ArrayList`) to store requests that have been successfully processed. `ArrayList` is suitable here as we might need to iterate or simply store completed items.
 *     *   **`availableResources`:** An integer tracking the current resource availability.
 *     *   **`nextRequestId`:** An integer counter to ensure each request gets a unique ID.
 *     *   **`addRequest(int resourceNeeded)`:** Creates a new `ProcessingRequest`, assigns it the next available ID, and adds it to the `requestQueue`. It includes input validation for `resourceNeeded` and uses `System.err` for errors.
 *     *   **`processNextRequest()`:** Implements the core processing logic. It checks the `requestQueue` (using `isEmpty()` and `peek()`), compares `resourceNeeded` with `availableResources`, and if conditions are met, dequeues the request (`poll()`), updates its status, adds it to `processedRequests`, and decrements `availableResources`. Informative messages are printed to `System.out` for success or failure conditions.
 *     *   **`displayStatus()`:** Prints the current state of the system to `System.out`, including resource availability, queue size, and processed request IDs.
 *     *   **`run()`:** Contains the main application loop. It uses `Scanner` to read user commands and input. A `switch` statement directs the flow based on the command. `try-catch` blocks are strategically placed around `Scanner` operations and method calls to handle potential `InputMismatchException` (when the user enters non-numeric input where a number is expected) and other potential runtime errors. Error messages from invalid input or unexpected issues are printed to `System.err`. The loop continues until the user chooses to exit (command 4).
 * 
 * 3.  **`main` Method:**
 *     *   Located in the `ResourceAllocationApp` class, its sole purpose is to create an instance of `ResourceProcessor` and call its `run()` method to start the application.
 * 
 * 4.  **Exception Handling (`try-catch`)**:
 *     *   Used in the `run()` method specifically around the `scanner.nextInt()` calls within the main loop and the 'Add Request' case to catch `InputMismatchException`. This prevents the program from crashing if the user types text instead of a number.
 *     *   A general `catch (Exception e)` is included in `run()` and `processNextRequest()` as a safety net for any other unexpected runtime errors, printing the error message and stack trace to `System.err`.
 *     *   Input validation for positive resource amount is done *within* the `addRequest` method itself, printing an error to `System.err`.
 * 
 * 5.  **System.out vs System.err:**
 *     *   `System.out` is used for normal program output: menu, prompts, success messages, status display.
 *     *   `System.err` is used exclusively for error messages: invalid command, invalid input type, resource needed validation errors, unexpected exceptions.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is maintained throughout.
 *     *   Variable and method names are descriptive (e.g., `resourceNeeded`, `processNextRequest`, `availableResources`).
 *     *   Comments explain the purpose of classes and key methods.
 *     *   Input validation and error handling are implemented as required.
 *     *   The code is structured logically into classes with specific responsibilities.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a cohesive, practical scenario while adhering to good programming practices.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList; // Common List implementation
import java.util.Scanner;
import java.util.InputMismatchException; // Useful for Scanner type mismatches

// Represents a single request for processing
class ProcessingRequest {
    private int id;
    private int resourceNeeded;
    private boolean isProcessed;

    public ProcessingRequest(int id, int resourceNeeded) {
        this.id = id;
        this.resourceNeeded = resourceNeeded;
        this.isProcessed = false;
    }

    // Getters
    public int getId() {
        return id;
    }

    public int getResourceNeeded() {
        return resourceNeeded;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    // Method to mark the request as processed
    public void markAsProcessed() {
        this.isProcessed = true;
    }

    @Override
    public String toString() {
        return "Request [ID=" + id + ", Resource Needed=" + resourceNeeded + ", Processed=" + isProcessed + "]";
    }
}

// Manages the resource allocation and task processing system
class ResourceProcessor {
    private Queue<ProcessingRequest> requestQueue;
    private List<ProcessingRequest> processedRequests;
    private int availableResources;
    private int nextRequestId;

    /**
     * Constructs a ResourceProcessor with a given amount of initial resources.
     * @param initialResources The total amount of resources available.
     */
    public ResourceProcessor(int initialResources) {
        if (initialResources < 0) {
            // Basic validation during construction
            System.err.println("Warning: Initial resources cannot be negative. Setting to 0.");
            this.availableResources = 0;
        } else {
            this.availableResources = initialResources;
        }
        this.requestQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedRequests = new ArrayList<>(); // ArrayList implements List
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Adds a new request to the processing queue.
     * @param resourceNeeded The amount of resource required by the request.
     * @return The ID assigned to the new request, or -1 if input is invalid.
     */
    public int addRequest(int resourceNeeded) {
        if (resourceNeeded <= 0) {
            System.err.println("Error: Resource needed must be a positive integer.");
            return -1; // Indicate failure
        }
        ProcessingRequest newRequest = new ProcessingRequest(nextRequestId++, resourceNeeded);
        requestQueue.offer(newRequest); // offer is safer than add (returns false on failure)
        return newRequest.getId(); // Return the generated ID
    }

    /**
     * Attempts to process the next request in the queue if resources are available.
     */
    public void processNextRequest() {
        // Use try-catch for potential issues, though less likely here with proper checks
        try {
            if (requestQueue.isEmpty()) {
                System.out.println("No requests in the queue.");
                return; // Nothing to process
            }

            ProcessingRequest nextRequest = requestQueue.peek(); // Look at the next request without removing

            if (nextRequest == null) { // Should not happen if isEmpty() is false, but good practice
                 System.err.println("Error: Peeked null from queue unexpectedly.");
                 requestQueue.poll(); // Attempt to clean up potentially bad element
                 return;
            }

            int needed = nextRequest.getResourceNeeded();

            if (availableResources >= needed) {
                ProcessingRequest processed = requestQueue.poll(); // Remove from queue
                if (processed != null) { // Check if poll was successful
                    processed.markAsProcessed();
                    processedRequests.add(processed); // Add to processed list
                    availableResources -= needed; // Decrease available resources
                    System.out.println("Processing request ID: " + processed.getId());
                } else {
                     System.err.println("Error: Failed to poll request from queue.");
                }
            } else {
                System.out.println("Insufficient resources to process request ID: " + nextRequest.getId() +
                                   " (needs " + needed + ", available " + availableResources + ")");
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during processing
            System.err.println("An unexpected error occurred during processing: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        }
    }

    /**
     * Displays the current status of the system.
     */
    public void displayStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Available Resources: " + availableResources);
        System.out.println("Requests in Queue: " + requestQueue.size());

        System.out.print("Processed Request IDs: [");
        if (processedRequests.isEmpty()) {
            System.out.print("None");
        } else {
            // Manually build string to avoid default list format brackets around each element
            for (int i = 0; i < processedRequests.size(); i++) {
                System.out.print(processedRequests.get(i).getId() + (i < processedRequests.size() - 1 ? ", " : ""));
            }
        }
        System.out.println("]");
        System.out.println("---------------------");
    }

    /**
     * Runs the main interaction loop for the system.
     * Handles user input and command execution.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int command = -1;

        System.out.println("Resource Allocation System");

        // Main loop for user interaction
        while (command != 4) {
            printMenu(); // Display command options
            System.out.print("Enter command: ");

            try {
                // Read command input
                command = scanner.nextInt();
                // Consume the rest of the line to prevent issues with nextLine() later
                scanner.nextLine();

                // Use switch for command handling
                switch (command) {
                    case 1:
                        System.out.print("Enter resource needed for the request: ");
                        try {
                            // Read resource needed input
                            int resourceNeeded = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            int newRequestId = addRequest(resourceNeeded);
                            if (newRequestId != -1) {
                                System.out.println("Request added with ID: " + newRequestId);
                            }
                            // Error message is handled inside addRequest
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a positive integer for resource needed.");
                            scanner.nextLine(); // Clear the invalid input from scanner
                        } catch (Exception e) {
                             System.err.println("An unexpected error occurred while adding request: " + e.getMessage());
                             e.printStackTrace();
                        }
                        break;

                    case 2:
                        processNextRequest();
                        break;

                    case 3:
                        displayStatus();
                        break;

                    case 4:
                        System.out.println("Exiting system.");
                        break;

                    default:
                        System.err.println("Invalid command. Please enter a number between 1 and 4.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for command
                System.err.println("Invalid input. Please enter a number for the command.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                command = -1; // Reset command to ensure loop continues
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during command processing
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace();
                 command = -1; // Reset command
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when exiting
    }

    // Helper method to print the command menu
    private void printMenu() {
        System.out.println("Available Commands:");
        System.out.println("1. Add Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
    }
}

// Main class to start the application
public class ResourceAllocationApp {
    public static void main(String[] args) {
        // Example: Initialize system with 10 units of resource
        ResourceProcessor processor = new ResourceProcessor(10);
        processor.run(); // Start the system's main loop
    }
}
