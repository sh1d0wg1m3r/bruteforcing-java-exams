/*
 * Exam Question #992
 * Generated on: 2025-05-12 17:09:48
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a small team. The system needs to handle tasks with descriptions and priorities (HIGH, MEDIUM, LOW). Tasks are processed in a first-in, first-out manner for pending tasks, but users should also be able to view all tasks ever created and mark specific tasks as complete by their ID.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer `id`, `description` (String), `priority` (an enum `Priority`), and `isCompleted` (boolean). Include a constructor, getter methods, a method to mark the task as complete, and an overridden `toString()` method for easy display.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold pending tasks, processed in FIFO order.
 *     *   It must use a `java.util.ArrayList<Task>` to maintain a history of *all* tasks ever added to the system, regardless of their status (pending or completed).
 *     *   Include methods for:
 *         *   `addTask(String description, String priorityStr)`: Creates a new task, adds it to the history list (`ArrayList`), and adds it to the pending queue (`Queue`). The `priorityStr` needs to be parsed into the `Priority` enum.
 *         *   `viewPendingTasks()`: Returns a `java.util.List<Task>` containing the tasks currently in the pending queue.
 *         *   `viewAllTasks()`: Returns a `java.util.List<Task>` containing all tasks from the history list.
 *         *   `completeNextTask()`: Removes and returns the task at the head of the pending queue, and marks that task as complete in the history list. Handles the case where the queue is empty.
 *         *   `completeTaskById(int id)`: Finds a task by its ID in the history list. If found and pending, marks it as complete in the history list and removes it from the pending queue. Handles cases where the task is not found or is already completed.
 *         *   `viewTaskDetails(int id)`: Finds and displays details of a specific task by its ID from the history list. Handles the case where the task is not found.
 *         *   `getStatistics()`: Returns a summary string including the total number of tasks, pending tasks, and completed tasks.
 * 3.  **User Interface:** Create a main application class (`TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View All Tasks
 *         4.  Complete Next Task
 *         5.  Complete Task by ID
 *         6.  View Task Details by ID
 *         7.  View Statistics
 *         8.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Call the appropriate `TaskManager` methods based on the user's selection.
 * 4.  **Error Handling:**
 *     *   Use `System.err` for printing error messages (e.g., invalid menu choice, invalid priority input, task not found, queue empty).
 *     *   Use `System.out` for all normal output (menu, prompts, task listings, confirmations, statistics).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to catch potential exceptions like `InputMismatchException` (for invalid integer input) or custom exceptions (e.g., `TaskNotFoundException`).
 *     *   Create a custom exception `TaskNotFoundException` to be thrown by `TaskManager` methods when a requested task ID does not exist.
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc where necessary.
 *     *   Perform input validation (e.g., for priority string, task ID).
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, displaying a menu, prompting for input, and printing results or error messages based on user actions. Error messages should clearly indicate the problem using `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Team Task Management System
 * Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View All Tasks
 * 4. Complete Next Task
 * 5. Complete Task by ID
 * 6. View Task Details by ID
 * 7. View Statistics
 * 8. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully with ID: 1
 * 
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter priority (HIGH, MEDIUM, LOW): LOW
 * Task added successfully with ID: 2
 * 
 * Enter your choice: 2
 * --- Pending Tasks ---
 * [ID: 1, Priority: HIGH, Description: Implement login feature, Completed: false]
 * [ID: 2, Priority: LOW, Description: Write documentation, Completed: false]
 * 
 * Enter your choice: 4
 * Completed task: [ID: 1, Priority: HIGH, Description: Implement login feature, Completed: true]
 * 
 * Enter your choice: 2
 * --- Pending Tasks ---
 * [ID: 2, Priority: LOW, Description: Write documentation, Completed: false]
 * 
 * Enter your choice: 5
 * Enter task ID to complete: 99
 * Error: Task with ID 99 not found.
 * 
 * Enter your choice: 5
 * Enter task ID to complete: 2
 * Task with ID 2 marked as complete.
 * 
 * Enter your choice: 7
 * --- Statistics ---
 * Total Tasks: 2
 * Pending Tasks: 0
 * Completed Tasks: 2
 * 
 * Enter your choice: 8
 * Exiting system.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** Represents a single task with `id`, `description`, `priority`, and `isCompleted` status. It follows encapsulation principles with private fields and public getters. The `markComplete` method modifies the internal state. `toString()` provides a convenient representation. `equals()` and `hashCode()` are overridden based on `id`, which is crucial for correctly removing tasks from the `Queue` by object reference later.
 * 
 * 2.  **Priority Enum:** Defines the allowed priority levels, making the code more readable and preventing invalid priority values.
 * 
 * 3.  **TaskNotFoundException:** A custom checked exception specific to the application's domain, thrown when a task is requested by an ID that doesn't exist.
 * 
 * 4.  **TaskManager Class:**
 *     *   **`Queue<Task> taskQueue`:** A `java.util.LinkedList` is used here because it implements the `Queue` interface and provides FIFO behavior suitable for processing tasks in the order they were added (unless completed out of sequence by ID). It holds the *pending* tasks.
 *     *   **`List<Task> allTasks`:** A `java.util.ArrayList` is used to store a historical record of *all* tasks ever created. This allows viewing completed tasks and finding tasks by ID regardless of their current status or position in the queue. We use the `List` interface type for the variable declaration, demonstrating polymorphism.
 *     *   **`addTask`:** Creates a new `Task`, adds it to both `allTasks` (history) and `taskQueue` (pending). It includes basic input validation for the priority string using `Priority.valueOf()` and catches `IllegalArgumentException`.
 *     *   **`viewPendingTasks`:** Returns the contents of the `taskQueue`. Returning a *new* `ArrayList` based on the queue's contents is a good practice to prevent external code from modifying the internal queue state directly, although returning the queue's iterator or a direct reference might be acceptable in some contexts (for this exam, a new list is shown).
 *     *   **`viewAllTasks`:** Returns the `allTasks` list, providing access to the complete history.
 *     *   **`completeNextTask`:** Uses `taskQueue.poll()`. `poll()` is safer than `remove()` as it returns `null` if the queue is empty, avoiding `NoSuchElementException`. If a task is retrieved, its `markComplete()` method is called. Crucially, since the same `Task` object reference exists in both `taskQueue` and `allTasks`, modifying the object obtained from `poll()` updates its state in `allTasks` as well.
 *     *   **`completeTaskById`:** This method is more complex. It first finds the task in the `allTasks` list using a helper method `findTaskById`. It throws `TaskNotFoundException` if the ID doesn't exist and `IllegalStateException` if the task is already completed. If the task is found and pending, it calls `markComplete()` on the task object (again, modifying the object in `allTasks`), and then calls `taskQueue.remove(taskToComplete)`. This removes the *specific* task object from the queue, even if it's not at the head, demonstrating removal by object reference which relies on the correct implementation of `equals()` in the `Task` class.
 *     *   **`findTaskById`:** A private helper method to search the `allTasks` list by ID.
 *     *   **`viewTaskDetails`:** Uses `findTaskById` and throws `TaskNotFoundException` if the task isn't found.
 *     *   **`getStatistics`:** Calculates counts based on the sizes of `allTasks` and `taskQueue`.
 * 
 * 5.  **TaskApp Class:**
 *     *   **`main` method:** Contains the main application loop.
 *     *   **`Scanner`:** Used for reading user input from `System.in`.
 *     *   **Menu and `switch`:** A `switch` statement is used to direct the program flow based on the user's integer input, calling the appropriate `TaskManager` methods.
 *     *   **`System.out` and `System.err`:** Used distinctly for normal output (menu, prompts, results) and error messages (invalid input, task not found, etc.).
 *     *   **Class-wide `try-catch`:** The main `while` loop is wrapped in a `try-catch` block. This block catches `InputMismatchException` during integer input (menu choice, task ID) and the custom `TaskNotFoundException` thrown by `TaskManager` methods. It also includes a general `catch (Exception e)` as a fallback for any other unexpected runtime issues, demonstrating robustness. Specific `try-catch` blocks are also used around individual input operations within the switch cases where `InputMismatchException` is expected, allowing for more granular error handling and recovery (like consuming the invalid input line). A `finally` block ensures the `Scanner` is closed.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application with proper structure, encapsulation, and error handling.
 */

import java.util.*;
import java.util.LinkedList;
import java.util.Queue;

// Custom exception for task not found
class TaskNotFoundException extends Exception {
    public TaskNotFoundException(String message) {
        super(message);
    }
}

// Enum for task priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // Method to mark task as complete
    public void markComplete() {
        this.isCompleted = true;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Priority: " + priority + ", Description: " + description + ", Completed: " + isCompleted + "]";
    }

    // Equals and hashCode based on ID for easy searching/removal
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// Manages collections of tasks
class TaskManager {
    // Queue for pending tasks (FIFO processing)
    private Queue<Task> taskQueue;
    // List for all tasks ever created (history)
    private List<Task> allTasks;
    private int nextTaskId; // Counter for unique task IDs

    public TaskManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The task description.
     * @param priorityStr The priority as a string (HIGH, MEDIUM, LOW).
     * @throws IllegalArgumentException if the priority string is invalid.
     */
    public void addTask(String description, String priorityStr) {
        Priority priority;
        try {
            priority = Priority.valueOf(priorityStr.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid priority: " + priorityStr + ". Must be HIGH, MEDIUM, or LOW.");
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask); // Add to history list
        taskQueue.offer(newTask); // Add to pending queue
        System.out.println("Task added successfully with ID: " + newTask.getId());
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     *
     * @return A List of pending tasks.
     */
    public List<Task> viewPendingTasks() {
        // Return a new list containing queue elements to avoid exposing internal queue structure
        return new ArrayList<>(taskQueue);
    }

    /**
     * Returns a list of all tasks ever created.
     *
     * @return A List of all tasks.
     */
    public List<Task> viewAllTasks() {
        return allTasks; // Return the internal list (for simplicity in exam)
    }

    /**
     * Completes the next task from the pending queue.
     *
     * @return The completed task, or null if the queue was empty.
     */
    public Task completeNextTask() {
        Task nextTask = taskQueue.poll(); // Retrieve and remove the head of the queue
        if (nextTask != null) {
            // Find the task in the allTasks list and mark it complete.
            // Since Task equals/hashCode is based on ID, finding the same task object reference isn't strictly needed.
            // We just need to find the task with the same ID in allTasks.
            // However, because we added the *same* Task object to both, marking complete on 'nextTask' directly
            // modifies the object reference that is also in 'allTasks'. This is simpler.
            nextTask.markComplete();
            System.out.println("Completed task: " + nextTask);
        } else {
            System.err.println("Error: No pending tasks to complete.");
        }
        return nextTask;
    }

    /**
     * Completes a specific task by its ID.
     *
     * @param id The ID of the task to complete.
     * @throws TaskNotFoundException if no task with the given ID exists.
     * @throws IllegalStateException if the task is already completed.
     */
    public void completeTaskById(int id) throws TaskNotFoundException, IllegalStateException {
        Task taskToComplete = findTaskById(id);

        if (taskToComplete == null) {
            throw new TaskNotFoundException("Task with ID " + id + " not found.");
        }

        if (taskToComplete.isCompleted()) {
            throw new IllegalStateException("Task with ID " + id + " is already completed.");
        }

        // Mark the task as complete in the allTasks list (modifies the shared object reference)
        taskToComplete.markComplete();

        // Remove the task from the pending queue
        // This relies on Task.equals() being correctly implemented based on ID
        boolean removedFromQueue = taskQueue.remove(taskToComplete);

        if (removedFromQueue) {
            System.out.println("Task with ID " + id + " marked as complete.");
        } else {
             // This case should ideally not happen if the task was found and was pending,
             // as it should have been in the queue. Could indicate a logic error
             // or the task was somehow removed from the queue without being completed via completeNextTask.
             // For exam simplicity, we'll assume it works or print a warning.
             // Let's add a warning for robustness.
             System.out.println("Task with ID " + id + " marked as complete, but was not found in the pending queue.");
        }
    }

    /**
     * Finds a task by its ID in the history list.
     *
     * @param id The ID of the task to find.
     * @return The Task object if found, otherwise null.
     */
    private Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Displays details for a task by its ID.
     *
     * @param id The ID of the task to view.
     * @throws TaskNotFoundException if no task with the given ID exists.
     */
    public void viewTaskDetails(int id) throws TaskNotFoundException {
        Task task = findTaskById(id);
        if (task == null) {
            throw new TaskNotFoundException("Task with ID " + id + " not found.");
        }
        System.out.println("--- Task Details ---");
        System.out.println(task);
    }

    /**
     * Provides statistics about the tasks.
     *
     * @return A formatted string with task counts.
     */
    public String getStatistics() {
        int total = allTasks.size();
        int pending = taskQueue.size(); // Tasks still in the queue are pending
        int completed = total - pending; // Simple calculation based on total and pending

        return String.format("--- Statistics ---\nTotal Tasks: %d\nPending Tasks: %d\nCompleted Tasks: %d",
                total, pending, completed);
    }
}

// Main application class
public class TaskApp {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Team Task Management System");

        // Class-wide exception handling around the main application loop
        try {
            while (true) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                        String priorityStr = scanner.nextLine();
                        try {
                            taskManager.addTask(description, priorityStr);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 2: // View Pending Tasks
                        List<Task> pendingTasks = taskManager.viewPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 3: // View All Tasks
                        List<Task> allTasks = taskManager.viewAllTasks();
                        System.out.println("--- All Tasks ---");
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks created yet.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // Complete Next Task
                        System.out.println("Attempting to complete next task...");
                        taskManager.completeNextTask(); // Handles empty queue internally with System.err
                        break;

                    case 5: // Complete Task by ID
                        System.out.print("Enter task ID to complete: ");
                        try {
                            int taskIdToComplete = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.completeTaskById(taskIdToComplete);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a valid task ID number.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (TaskNotFoundException e) {
                            System.err.println("Error: " + e.getMessage());
                        } catch (IllegalStateException e) {
                             System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 6: // View Task Details by ID
                        System.out.print("Enter task ID to view details: ");
                         try {
                            int taskIdToView = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.viewTaskDetails(taskIdToView);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a valid task ID number.");
                             scanner.nextLine(); // Consume invalid input
                        } catch (TaskNotFoundException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 7: // View Statistics
                        System.out.println(taskManager.getStatistics());
                        break;

                    case 8: // Exit
                        System.out.println("Exiting system.");
                        scanner.close();
                        return; // Exit the main method and terminate the program

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 8.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions not handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
             // Ensure scanner is closed even if an exception occurs before the exit case
             if(scanner != null) {
                 scanner.close();
             }
        }
    }

    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View All Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Complete Task by ID");
        System.out.println("6. View Task Details by ID");
        System.out.println("7. View Statistics");
        System.out.println("8. Exit");
    }
}
