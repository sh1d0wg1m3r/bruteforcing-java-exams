/*
 * Exam Question #882
 * Generated on: 2025-05-12 16:54:36
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Management System in Java. The system needs to manage various sessions within an event, handle attendee registrations, and manage a waiting list for sessions that reach full capacity.
 * 
 * Your system should allow users to:
 * 1.  Add new event sessions with a name and maximum capacity.
 * 2.  Register an attendee for a specific session. If the session is full, the attendee should be added to a waiting list.
 * 3.  Process the waiting list: Attempt to register attendees from the waiting list into any session that currently has available capacity.
 * 4.  Display the current status of all sessions (name, capacity, current attendees) and the waiting list.
 * 5.  Exit the application.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Use of Specific Java Components:**
 *     *   `java.util.Queue`: Must be used to manage the waiting list of attendees.
 *     *   `java.util.ArrayList`: Must be used to store the list of `EventSession` objects.
 *     *   `java.util.List`: Must be used as the type for the collection holding sessions (e.g., `List<EventSession>`).
 *     *   `java.util.Scanner`: Must be used to get user input from the console.
 *     *   `switch` statement: Must be used to handle the main menu options.
 *     *   `System.err`: Must be used exclusively for printing error messages (e.g., invalid input, session not found, registration failure).
 *     *   `System.out`: Must be used for printing normal output (menu, prompts, status information, success messages).
 *     *   Class-wide exception handling: A single `try-catch` block should wrap the main application logic loop to catch potential runtime errors and prevent the application from crashing unexpectedly. Specific input validation should also be performed where necessary *before* potential exceptions occur.
 * 
 * 2.  **Object-Oriented Design:**
 *     *   Create classes: `Attendee`, `EventSession`, and `EventManager`.
 *     *   Use proper encapsulation: All fields should be `private`. Access and modification should be done via public methods (getters, setters where appropriate, or behavior methods like `addAttendee`).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (at least for classes and public methods).
 * 
 * 3.  **Functionality Details:**
 *     *   **Add Session:** Prompt for session name and capacity. Capacity must be a positive integer.
 *     *   **Register Attendee:** Prompt for attendee name, attendee ID, and the name of the session they want to register for. If the session is found and has space, add the attendee. If full, add the attendee to the waiting queue. If the session is not found, report an error.
 *     *   **Process Waiting List:** Iterate through the waiting queue. For each attendee in the queue, attempt to register them into *any* session that has available space. If successfully registered, remove the attendee from the queue. If no session has space, the attendee remains in the queue.
 *     *   **Display Status:** Print details for each session (name, capacity, number of registered attendees, and list of attendee names). Print the current contents of the waiting list (attendee names and IDs).
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Validate user input (e.g., non-empty strings, positive integers).
 *     *   Handle cases where a session is not found.
 *     *   Handle non-integer input when expecting numbers.
 *     *   Use `System.err` for all error messages.
 *     *   The main loop should be robust against unhandled exceptions using a `try-catch`.
 * 
 * **Expected Output:**
 * 
 * The output should be clear and user-friendly, presenting a menu and providing feedback on actions performed. Error messages should be distinct using `System.err`.
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add New Session
 * 2. Register Attendee
 * 3. Process Waiting List
 * 4. Display Status
 * 5. Exit
 * Enter choice: [user input]
 * ... (System output/error based on choice)
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`Attendee`, `EventSession`, `EventManager`, and a main class to run the application).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionality.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for exception handling.
 * *   Good object-oriented design (encapsulation, meaningful names).
 * *   Appropriate input validation and error handling.
 * *   Clean code structure and comments.
 * 
 * *(Assume attendee IDs are unique for simplicity, though the current problem doesn't strictly require enforcing this uniqueness across the system, only storing it per attendee.)*
 *
 * EXPLANATION:
 * This solution implements a basic Event Management System demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `waitingList` field in the `EventManager` class is declared as a `Queue<Attendee>`. A `LinkedList` is used as the concrete implementation because `LinkedList` implements the `Queue` interface and provides efficient adding (`offer`) and removing (`poll` or using an `Iterator` for safe removal during iteration) operations needed for queue behavior. Attendees are added to this queue when their desired session is full (`offer`) and removed from the queue when successfully registered from the waiting list (using `iterator.remove()`).
 * 2.  **`java.util.ArrayList`:** The `sessions` field in the `EventManager` class is initialized as an `ArrayList<EventSession>`. `ArrayList` is suitable here because we primarily need to store and iterate through the sessions, and adding new sessions is a common operation. Random access by index isn't heavily used, but iterating through the list is efficient.
 * 3.  **`java.util.List`:** The `sessions` field in `EventManager` is declared using the `List` interface (`List<EventSession> sessions;`), adhering to the principle of programming to interfaces. This allows for flexibility if a different `List` implementation were needed later. Similarly, the `registeredAttendees` field in the `EventSession` class is declared as `List<Attendee>`, implemented with `ArrayList`.
 * 4.  **`java.util.Scanner`:** An instance of `Scanner` is created in the `main` method of `EventManagementApp` to read user input from `System.in`. It's used within the main loop to get the user's menu choice and subsequent details like session names, capacities, attendee names, and IDs. The `Scanner` is closed in a `finally` block to release system resources.
 * 5.  **`switch` statement:** The main application loop in `EventManagementApp` uses a `switch` statement based on the user's integer input (`choice`) to direct the program flow to the appropriate action (Add Session, Register Attendee, Process Waiting List, Display Status, Exit).
 * 6.  **`System.err`:** All error messages, such as invalid input (non-numeric choice, negative capacity), session not found, or registration failure due to session not existing, are printed using `System.err.println()`. This visually distinguishes error output from normal program output (`System.out`).
 * 7.  **`System.out`:** All normal program output, including the menu, prompts for input, confirmation messages (session added, attendee registered), and status displays, is printed using `System.out.println()`.
 * 8.  **Class-wide exception handling with `try-catch`:** The entire `while(running)` loop in the `main` method of `EventManagementApp` is wrapped in a single `try-catch(Exception e)` block. This provides a safety net for any unexpected runtime exceptions that might occur within the application logic, preventing the program from crashing abruptly. A message is printed to `System.err`, and the stack trace is printed for debugging. Specific input validation (`try-catch` for `NumberFormatException`, checking for empty strings or non-positive numbers) is also performed *before* relying on potentially invalid input.
 * 
 * **Object-Oriented Design and Best Practices:**
 * 
 * *   **Classes:** `Attendee`, `EventSession`, and `EventManager` are distinct classes representing the core entities and the system's manager.
 * *   **Encapsulation:** All fields (`name`, `id`, `capacity`, `registeredAttendees`, `sessions`, `waitingList`) are declared `private`. Public getter methods (`getName`, `getId`, `getCapacity`, `getRegisteredAttendees`) are provided where necessary to access data. Behavior methods (`addAttendee`, `isFull`, `registerAttendee`, `processWaitingList`, `displayStatus`) encapsulate the logic related to each object.
 * *   **Meaningful Names:** Variable and method names (`attendeeName`, `sessionName`, `registerAttendee`, `processWaitingList`, `findSessionByName`) clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are used for classes and public methods to explain their role and parameters. Inline comments clarify specific logic where needed (e.g., using Iterator for safe removal).
 * *   **Input Validation:** Checks are performed for empty strings for names/IDs and non-positive integers for capacity. `try-catch` blocks are used specifically for parsing integer input to handle `NumberFormatException`.
 * *   **Error Handling:** Specific error messages are printed using `System.err` when sessions are not found or input is invalid. The main `try-catch` provides a fallback for unexpected errors.
 * *   **Clean Code:** The code is structured logically with classes separating concerns. Methods are relatively small and focused on a single task.
 * 
 * **Functionality Implementation:**
 * 
 * *   `EventSession.addAttendee`: Correctly checks `isFull()` before adding, returning `false` if capacity is exceeded.
 * *   `EventManager.addSession`: Simply adds the new session to the `sessions` list.
 * *   `EventManager.findSessionByName`: Iterates through the `sessions` list to find a session by name (case-insensitive comparison).
 * *   `EventManager.registerAttendee`: Finds the session, attempts to add the attendee using `session.addAttendee()`. If it fails (returns `false`), the attendee is added to the `waitingList` using `offer()`.
 * *   `EventManager.processWaitingList`: Uses an `Iterator` to safely traverse the `waitingList`. For each waiting attendee, it iterates through *all* sessions, attempting to register them using `session.addAttendee()`. If successful, `iterator.remove()` is called to remove the attendee from the queue, and the inner loop breaks to process the next waiting attendee.
 * *   `EventManager.displayStatus`: Iterates through sessions and the waiting list, printing relevant details using `System.out`.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, input/output, and exception handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during queue processing

/**
 * Represents an attendee for an event.
 */
class Attendee {
    private String name;
    private String id; // Unique identifier for the attendee

    /**
     * Constructs an Attendee object.
     * @param name The name of the attendee.
     * @param id The unique ID of the attendee.
     */
    public Attendee(String name, String id) {
        this.name = name;
        this.id = id;
    }

    // Getters
    public String getName() {
        return name;
    }

    public String getId() {
        return id;
    }

    @Override
    public String toString() {
        return name + " (ID: " + id + ")";
    }

    // Basic equals and hashCode based on ID for potential future use, though not strictly required by problem
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id.equals(attendee.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

/**
 * Represents a session within an event.
 */
class EventSession {
    private String name;
    private int capacity;
    private List<Attendee> registeredAttendees;

    /**
     * Constructs an EventSession object.
     * @param name The name of the session.
     * @param capacity The maximum number of attendees allowed in the session.
     */
    public EventSession(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>();
    }

    // Getters
    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Attendee> getRegisteredAttendees() {
        return registeredAttendees;
    }

    /**
     * Checks if the session has reached its maximum capacity.
     * @return true if the session is full, false otherwise.
     */
    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    /**
     * Attempts to add an attendee to the session.
     * @param attendee The attendee to add.
     * @return true if the attendee was successfully added, false if the session is full.
     */
    public boolean addAttendee(Attendee attendee) {
        if (!isFull()) {
            registeredAttendees.add(attendee);
            return true;
        }
        return false;
    }

    /**
     * Gets the number of available spots in the session.
     * @return The number of remaining spots.
     */
    public int getAvailableCapacity() {
        return capacity - registeredAttendees.size();
    }

    @Override
    public String toString() {
        return "Session: " + name + " | Capacity: " + registeredAttendees.size() + "/" + capacity;
    }
}

/**
 * Manages event sessions and the attendee waiting list.
 */
class EventManager {
    private List<EventSession> sessions;
    private Queue<Attendee> waitingList;

    /**
     * Constructs an EventManager.
     */
    public EventManager() {
        this.sessions = new ArrayList<>(); // Use ArrayList for sessions
        this.waitingList = new LinkedList<>(); // LinkedList is a common Queue implementation
    }

    /**
     * Adds a new session to the event.
     * @param session The session to add.
     */
    public void addSession(EventSession session) {
        sessions.add(session);
        System.out.println("Session '" + session.getName() + "' added with capacity " + session.getCapacity() + ".");
    }

    /**
     * Finds a session by its name.
     * @param sessionName The name of the session to find.
     * @return The EventSession object if found, null otherwise.
     */
    private EventSession findSessionByName(String sessionName) {
        for (EventSession session : sessions) {
            if (session.getName().equalsIgnoreCase(sessionName)) {
                return session;
            }
        }
        return null;
    }

    /**
     * Registers an attendee for a session or adds them to the waiting list if full.
     * @param attendee The attendee to register.
     * @param sessionName The name of the session.
     */
    public void registerAttendee(Attendee attendee, String sessionName) {
        EventSession session = findSessionByName(sessionName);

        if (session == null) {
            System.err.println("Error: Session '" + sessionName + "' not found.");
            return;
        }

        if (session.addAttendee(attendee)) {
            System.out.println("Attendee '" + attendee.getName() + "' registered successfully for session '" + sessionName + "'.");
        } else {
            waitingList.offer(attendee); // Add to the end of the waiting queue
            System.out.println("Session '" + sessionName + "' is full. Attendee '" + attendee.getName() + "' added to the waiting list.");
        }
    }

    /**
     * Attempts to register attendees from the waiting list into available sessions.
     */
    public void processWaitingList() {
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty. Nothing to process.");
            return;
        }

        System.out.println("Processing waiting list...");
        int registeredFromWaiting = 0;
        // Use an iterator for safe removal while iterating
        Iterator<Attendee> iterator = waitingList.iterator();
        while (iterator.hasNext()) {
            Attendee waitingAttendee = iterator.next();
            boolean registered = false;
            // Try to register the waiting attendee into any session with space
            for (EventSession session : sessions) {
                if (session.addAttendee(waitingAttendee)) {
                    System.out.println("Attendee '" + waitingAttendee.getName() + "' registered from waiting list into session '" + session.getName() + "'.");
                    iterator.remove(); // Safely remove the attendee from the waiting list
                    registered = true;
                    registeredFromWaiting++;
                    break; // Move to the next attendee in the waiting list
                }
            }
            if (!registered) {
                // If loop finishes and attendee wasn't registered, they remain in the queue
                // System.out.println("Attendee '" + waitingAttendee.getName() + "' remains on waiting list (no available space found).");
            }
        }
        System.out.println("Waiting list processing complete. " + registeredFromWaiting + " attendee(s) registered from the waiting list.");
    }

    /**
     * Displays the status of all sessions and the waiting list.
     */
    public void displayStatus() {
        System.out.println("\n--- Event Status ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions added yet.");
        } else {
            System.out.println("--- Sessions ---");
            for (EventSession session : sessions) {
                System.out.println(session); // Uses EventSession's toString
                if (session.getRegisteredAttendees().isEmpty()) {
                    System.out.println("  No attendees registered.");
                } else {
                    System.out.println("  Registered Attendees:");
                    for (Attendee attendee : session.getRegisteredAttendees()) {
                        System.out.println("    - " + attendee.getName() + " (ID: " + attendee.getId() + ")");
                    }
                }
            }
        }

        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterating over the queue without removing elements to just display
            for (Attendee attendee : waitingList) {
                System.out.println("  - " + attendee.getName() + " (ID: " + attendee.getId() + ")");
            }
        }
        System.out.println("--------------------");
    }
}

/**
 * Main application class for the Event Management System.
 * Handles user interaction and orchestrates the EventManager.
 */
public class EventManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager();
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");
                String choiceInput = scanner.nextLine();
                int choice = -1;

                // Input validation for menu choice
                try {
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Go back to the start of the loop
                }

                // Switch statement for menu control
                switch (choice) {
                    case 1: // Add New Session
                        System.out.print("Enter session name: ");
                        String sessionName = scanner.nextLine();
                        if (sessionName.trim().isEmpty()) {
                             System.err.println("Session name cannot be empty.");
                             break;
                        }
                        System.out.print("Enter session capacity: ");
                        int capacity = -1;
                        try {
                            capacity = Integer.parseInt(scanner.nextLine());
                            if (capacity <= 0) {
                                System.err.println("Capacity must be a positive integer.");
                                break;
                            }
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid capacity. Please enter a valid number.");
                            break; // Exit case 1, go back to main loop
                        }
                        eventManager.addSession(new EventSession(sessionName, capacity));
                        break;

                    case 2: // Register Attendee
                        System.out.print("Enter attendee name: ");
                        String attendeeName = scanner.nextLine();
                         if (attendeeName.trim().isEmpty()) {
                             System.err.println("Attendee name cannot be empty.");
                             break;
                         }
                        System.out.print("Enter attendee ID: ");
                        String attendeeId = scanner.nextLine();
                         if (attendeeId.trim().isEmpty()) {
                             System.err.println("Attendee ID cannot be empty.");
                             break;
                         }
                        System.out.print("Enter session name to register for: ");
                        String targetSessionName = scanner.nextLine();
                         if (targetSessionName.trim().isEmpty()) {
                             System.err.println("Session name cannot be empty.");
                             break;
                         }
                        Attendee attendee = new Attendee(attendeeName, attendeeId);
                        eventManager.registerAttendee(attendee, targetSessionName);
                        break;

                    case 3: // Process Waiting List
                        eventManager.processWaitingList();
                        break;

                    case 4: // Display Status
                        eventManager.displayStatus();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Event Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Application terminated.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Add New Session");
        System.out.println("2. Register Attendee");
        System.out.println("3. Process Waiting List");
        System.out.println("4. Display Status");
        System.out.println("5. Exit");
    }
}
