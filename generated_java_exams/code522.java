/*
 * Exam Question #522
 * Generated on: 2025-05-11 23:24:00
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Assembly Line Simulator**
 * 
 * Design and implement a Java program that simulates a simplified manufacturing assembly line. The simulator should manage a queue of tasks waiting to be processed and maintain a list of tasks that have been completed.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent an individual task on the assembly line. Each `Task` should have:
 *     *   A unique integer `taskId`.
 *     *   A `String` `description` of the task.
 *     *   A `String` `status` (e.g., "PENDING", "PROCESSING", "COMPLETED").
 *     *   Implement proper encapsulation (private fields, public getters, and a method to update status).
 * 
 * 2.  **Assembly Line Management:** Create a class named `AssemblyLineSimulator` that manages the assembly line. This class should contain:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed. Use a suitable implementation from `java.util`.
 *     *   A `List<Task>` to hold completed tasks. Use `java.util.ArrayList` and declare it using the `List` interface type.
 *     *   Methods to:
 *         *   Add a new task to the queue (`addTask`). Tasks should be automatically assigned a unique ID.
 *         *   Process the next task from the queue (`processNextTask`). This method should move the task from the queue to the completed list and update its status. Handle the case where the queue is empty.
 *         *   Display the current tasks in the queue (`displayQueue`).
 *         *   Display the completed tasks list (`displayCompletedTasks`).
 * 
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` in the `main` method (or a dedicated `run` method called from `main`) of the `AssemblyLineSimulator` class. The interface should present a menu with options:
 *     *   1: Add New Task
 *     *   2: Process Next Task
 *     *   3: View Pending Tasks (Queue)
 *     *   4: View Completed Tasks
 *     *   5: Exit
 * 
 * 4.  **Control Flow:** Use a `switch` statement to handle the user's menu selection.
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu input, attempting to process an empty queue).
 *     *   Use `System.out` for all normal output (menu, task details, success messages).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main simulation loop to catch any unexpected runtime exceptions and report them gracefully.
 * 
 * 6.  **Best Practices:** Ensure your code follows best practices, including meaningful variable/method names, appropriate comments, and clean structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested actions. Output for viewing tasks should list their ID, description, and status. Error messages for invalid operations (like processing an empty queue) should be clearly printed to `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Assembly Line Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Paint chassis
 * Task 1 'Paint chassis' added to the queue.
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task 1 'Paint chassis'
 * Task 1 'Paint chassis' marked as COMPLETED.
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * (Queue is empty)
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 1, Description: Paint chassis, Status: COMPLETED
 * ```
 * 
 * If the user enters invalid input (non-integer or out of range choice), an error should be printed to `System.err`, and the menu should reappear. If they try to process an empty queue, an error should be printed to `System.err`.
 * 
 * ```
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * ```
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 9
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * ```
 * 
 * ```
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Assemble engine
 * Task 2 'Assemble engine' added to the queue.
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Install wheels
 * Task 3 'Install wheels' added to the queue.
 * 
 * Assembly Line Simulator Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 2, Description: Assemble engine, Status: PENDING
 * Task ID: 3, Description: Install wheels, Status: PENDING
 * ```
 * 
 * Your solution should be provided as a single Java code block.
 *
 * EXPLANATION:
 * This solution implements the `AssemblyLineSimulator` as required, demonstrating the use of various Java concepts and following best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Encapsulation is achieved by making fields (`taskId`, `description`, `status`) private and providing public getter methods. A `setStatus` method allows controlled modification of the status.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`AssemblyLineSimulator` Class:**
 *     *   **`Queue<Task> assemblyLine`**: A `LinkedList` is used, which implements the `Queue` interface. This correctly models the assembly line where tasks are processed in the order they arrive (FIFO - First-In, First-Out).
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used and declared with the `List` interface type (`List<Task> completedTasks = new ArrayList<>();`). This stores completed tasks in the order they finished.
 *     *   **`nextTaskId`**: A simple counter ensures each task gets a unique ID.
 *     *   **`addTask(String description)`**: Creates a new `Task` object, assigns the next available ID, and adds it to the `assemblyLine` queue using `queue.add()`.
 *     *   **`processNextTask()`**:
 *         *   Uses `assemblyLine.poll()`. `poll()` is crucial here as it retrieves and removes the head of the queue, but returns `null` if the queue is empty. This is safer than `remove()`, which would throw a `NoSuchElementException`.
 *         *   It checks for the `null` return value to handle the empty queue case gracefully, printing an error to `System.err`.
 *         *   If a task is retrieved, its status is updated (simulating processing), and it's added to the `completedTasks` list.
 *     *   **`displayQueue()`**: Iterates through the `assemblyLine` using an enhanced for loop. This is possible because `LinkedList` (and many Queue implementations) also implement `Iterable`. It prints each task's details. It checks if the queue is empty first.
 *     *   **`displayCompletedTasks()`**: Iterates through the `completedTasks` list using an enhanced for loop and prints each task's details. It checks if the list is empty first.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   The `runSimulation()` method contains the main application loop.
 *     *   `java.util.Scanner` is used to read user input from the console.
 *     *   A `while` loop continues until the user chooses option 5 (Exit).
 *     *   A `switch` statement processes the integer `choice` read from the scanner, directing execution to the appropriate method (`addTask`, `processNextTask`, `displayQueue`, `displayCompletedTasks`, or exit).
 *     *   A `default` case in the `switch` handles invalid integer inputs within the valid range check.
 * 
 * 4.  **Error Handling:**
 *     *   **`System.err`**: Used specifically for reporting error conditions: processing an empty queue, invalid menu choice (outside 1-5), and invalid input type (`InputMismatchException`).
 *     *   **`System.out`**: Used for all successful operations, menu display, and task information.
 *     *   **`try-catch`**:
 *         *   An inner `try-catch(InputMismatchException e)` block is used specifically around reading the integer choice. This catches non-integer input, prints an error to `System.err`, and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   A larger, outer `try-catch(Exception e)` block wraps the entire `while` loop within `runSimulation()`. This fulfills the "class-wide exception handling" requirement by catching any other unexpected runtime exceptions that might occur during the execution of the simulation logic (though this simple simulation is unlikely to throw many). It prints a generic error message and the stack trace to `System.err`.
 *         *   A `finally` block ensures the `Scanner` is closed when the simulation loop terminates (either by exiting gracefully or due to an exception).
 *     *   Input validation is also performed for the task description (checking if it's empty).
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names (`AssemblyLineSimulator`, `assemblyLine`, `processNextTask`, `completedTasks`, etc.) are used.
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   The code is structured into logical classes and methods.
 * 
 * This solution effectively combines the required Java components to create a functional, albeit simple, simulation while demonstrating robust handling of user input and potential errors.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the assembly line.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "PENDING", "PROCESSING", "COMPLETED"

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Tasks start as PENDING
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Simulates a manufacturing assembly line managing tasks.
 */
public class AssemblyLineSimulator {

    // Queue for tasks waiting to be processed
    private Queue<Task> assemblyLine;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs an AssemblyLineSimulator.
     */
    public AssemblyLineSimulator() {
        // Use LinkedList as a Queue implementation
        this.assemblyLine = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the assembly line queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        assemblyLine.add(newTask);
        System.out.println("Task " + newTask.getTaskId() + " '" + newTask.getDescription() + "' added to the queue.");
    }

    /**
     * Processes the next task from the queue.
     * Moves the task from the queue to the completed list and updates its status.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty.
        Task taskToProcess = assemblyLine.poll();

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            // Simulate processing
            taskToProcess.setStatus("PROCESSING"); // Optional: Update status to PROCESSING during simulation
            // In a real system, there would be actual work here
            taskToProcess.setStatus("COMPLETED"); // Set status to COMPLETED after simulation

            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getTaskId() + " '" + taskToProcess.getDescription() + "' marked as COMPLETED.");
        }
    }

    /**
     * Displays the tasks currently waiting in the assembly line queue.
     */
    public void displayQueue() {
        System.out.println("--- Pending Tasks ---");
        if (assemblyLine.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : assemblyLine) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays the tasks that have been completed.
     */
    public void displayCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main simulation loop with user interaction.
     */
    public void runSimulation() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide try-catch block for the main simulation loop
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Inner try-catch for input validation
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Task description cannot be empty.");
                            } else {
                                addTask(description.trim());
                            }
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            displayQueue();
                            break;
                        case 4:
                            displayCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Assembly Line Simulator. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    choice = -1; // Reset choice to stay in loop
                }
                System.out.println(); // Add a newline for better readability between turns
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during simulation execution
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to stderr
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Assembly Line Simulator Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulator simulator = new AssemblyLineSimulator();
        simulator.runSimulation();
    }
}
