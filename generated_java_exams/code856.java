/*
 * Exam Question #856
 * Generated on: 2025-05-12 16:51:06
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Attendance & Waitlist Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple system to manage attendees and a waitlist for an event with a limited capacity. The system should allow users to register for the event, cancel their registration, and view the current lists of confirmed attendees and those on the waitlist.
 * 
 * **Requirements:**
 * 
 * 1.  **Event Capacity:** The event has a fixed maximum capacity, specified when the system starts.
 * 2.  **Registration:**
 *     *   Attendees register by providing their name.
 *     *   If the event capacity has not been reached, the attendee is added to the list of **confirmed attendees**.
 *     *   If the event capacity has been reached, the attendee is added to a **waitlist**.
 *     *   An attendee cannot register if they are already on the confirmed list or the waitlist.
 * 3.  **Cancellation:**
 *     *   Attendees can cancel their registration by providing their name.
 *     *   If the attendee is on the confirmed list, they are removed.
 *     *   If the attendee was removed from the confirmed list AND the waitlist is not empty, the *first* person on the waitlist should be automatically moved to the confirmed list.
 *     *   If the attendee is on the waitlist, they are removed from the waitlist.
 *     *   If the attendee's name is not found on either list, an error message should be displayed.
 * 4.  **Viewing Lists:** Users should be able to view the current list of confirmed attendees and the current list of people on the waitlist.
 * 5.  **User Interface:** The system should provide a simple text-based menu for user interaction using `Scanner`.
 * 6.  **Required Java Components:** Your solution **must** utilize all of the following:
 *     *   `java.util.Queue` (specifically for the waitlist)
 *     *   `java.util.ArrayList` (specifically for the confirmed attendees)
 *     *   `java.util.List` (use `List` as the type for variables or method return types where appropriate, e.g., when returning the confirmed list)
 *     *   `java.util.Scanner` (for user input)
 *     *   `switch` statement (for the main menu logic)
 *     *   `System.err` (for displaying error messages, e.g., invalid input, attendee not found)
 *     *   `System.out` (for displaying menu options, prompts, success messages, and lists)
 *     *   Class-wide exception handling using `try-catch` blocks (at least for handling invalid user input and potential issues during operations).
 * 7.  **Best Practices:**
 *     *   Implement the core logic in a separate class (e.g., `EventManager`) with proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for the class and methods).
 *     *   Perform input validation (e.g., attendee names are not empty, menu choices are valid numbers).
 *     *   Implement robust error handling for invalid operations (e.g., cancelling a non-existent registration) and invalid input.
 *     *   Ensure a clean code structure.
 * 
 * **Menu Options:**
 * 
 * 1.  Register Attendee
 * 2.  Cancel Registration
 * 3.  View Confirmed Attendees
 * 4.  View Waitlist
 * 5.  View Event Status (Capacity, Confirmed Count, Waitlist Count)
 * 6.  Exit
 * 
 * **Expected Output:**
 * 
 * *   Clear prompts for user input.
 * *   Informative messages for successful operations (registration confirmed, added to waitlist, cancellation successful, attendee moved from waitlist).
 * *   Error messages displayed using `System.err` for failures (e.g., invalid menu choice, attendee already registered, attendee not found for cancellation, invalid capacity input).
 * *   Formatted lists when viewing confirmed attendees and the waitlist.
 * 
 * Your solution should be a single Java file containing the `EventManager` class and a `Main` class with the `main` method to run the application loop.
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements the Event Attendance & Waitlist Management system using the required Java components and best practices.
 * 
 * 1.  **Class Structure:** The logic is separated into two classes: `EventManager` handles the core event management operations (registration, cancellation, lists), and `EventManagementSystem` contains the `main` method for user interaction and the application loop. This demonstrates good separation of concerns and encapsulation.
 * 
 * 2.  **Encapsulation:** The `EventManager` class has private fields (`capacity`, `confirmedAttendees`, `waitlist`) that are accessed and modified only through public methods (`register`, `cancelRegistration`, `getConfirmedAttendees`, etc.).
 * 
 * 3.  **Required Java Components:**
 *     *   `Queue`: The `waitlist` is declared as a `Queue<String>` and initialized with `LinkedList<String>`. `LinkedList` is a common implementation of the `Queue` interface and provides the necessary FIFO (First-In, First-Out) behavior required for a waitlist. `offer()` is used to add to the end, and `poll()` is used to remove from the front.
 *     *   `ArrayList`: The `confirmedAttendees` list is declared as `List<String>` and initialized with `ArrayList<String>`. `ArrayList` is suitable for storing and accessing confirmed attendees.
 *     *   `List interface`: The `confirmedAttendees` field is declared using the `List` interface type. The `getConfirmedAttendees()` and `getWaitlist()` methods also return `List<String>`, promoting flexibility if the underlying implementation were to change.
 *     *   `Scanner`: Used in the `main` method to read user input from the console for menu choices, capacity, and attendee names. It's used within a try-with-resources block to ensure it's automatically closed.
 *     *   `switch statement`: Used in the `main` method's main loop to control the flow based on the user's menu choice.
 *     *   `System.err`: Used to print error messages, such as invalid input (caught by `try-catch`) or business logic errors (like an attendee not being found for cancellation, which is handled within `cancelRegistration` and printed to `System.err`).
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, and the lists of attendees.
 *     *   `try-catch blocks`: Used extensively in the `main` method to handle potential exceptions:
 *         *   `InputMismatchException` is caught when the user enters non-integer input where an integer is expected (capacity, menu choice).
 *         *   `IllegalArgumentException` is caught when calling `EventManager` methods, handling errors like providing an empty name or trying to register an attendee who is already present.
 *         *   A general `Exception` catch is included as a fallback for any unexpected runtime errors.
 * 
 * 4.  **Input Validation:**
 *     *   The `EventManager` constructor validates that the capacity is positive.
 *     *   The `register` and `cancelRegistration` methods validate that the provided attendee name is not null or empty.
 *     *   The main loop handles `InputMismatchException` for invalid numeric input.
 * 
 * 5.  **Error Handling:**
 *     *   `IllegalArgumentException` is thrown by `EventManager` methods for invalid operations (e.g., duplicate registration, invalid capacity) and caught in `main`.
 *     *   `System.err` is used for reporting errors to the user.
 *     *   The `cancelRegistration` method specifically checks if an attendee exists before attempting removal and prints an error to `System.err` if not found.
 * 
 * 6.  **Logic Implementation:**
 *     *   **Registration:** Checks capacity first. If space, adds to `confirmedAttendees`. Otherwise, uses `waitlist.offer()` to add to the end of the queue. Checks for existing registration in both lists before adding.
 *     *   **Cancellation:** Attempts to remove from `confirmedAttendees`. If successful, it checks if the `waitlist` is not empty and uses `waitlist.poll()` to get and remove the next person, adding them to `confirmedAttendees`. If not found in confirmed, it attempts to remove from `waitlist`. If not found in either, it reports an error.
 *     *   **Viewing Lists:** `getConfirmedAttendees` returns a copy of the `ArrayList` to prevent external modification. `getWaitlist` converts the `Queue` to a new `ArrayList` for easy iteration and display without altering the queue's state.
 * 
 * 7.  **Code Readability:** Meaningful variable names (`confirmedAttendees`, `waitlist`, `attendeeName`, `capacity`), method names (`register`, `cancelRegistration`, `getConfirmedAttendees`), and comments (including Javadoc) enhance code readability and maintainability. The `printMenu` method keeps the `main` method cleaner.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of collections, control flow, user input handling, and essential error management techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages attendees and a waitlist for an event with limited capacity.
 */
class EventManager {
    private int capacity;
    private List<String> confirmedAttendees; // Use ArrayList for confirmed
    private Queue<String> waitlist; // Use Queue for waitlist

    /**
     * Constructs an EventManager with a specified capacity.
     *
     * @param capacity The maximum number of confirmed attendees. Must be positive.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public EventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Event capacity must be positive.");
        }
        this.capacity = capacity;
        this.confirmedAttendees = new ArrayList<>();
        this.waitlist = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Registers an attendee for the event.
     * Adds to confirmed list if capacity is available, otherwise adds to waitlist.
     *
     * @param attendeeName The name of the attendee to register.
     * @throws IllegalArgumentException if attendeeName is null or empty, or if attendee is already registered.
     */
    public void register(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be empty.");
        }
        String name = attendeeName.trim();

        if (confirmedAttendees.contains(name) || waitlist.contains(name)) {
            throw new IllegalArgumentException("Attendee '" + name + "' is already registered.");
        }

        if (confirmedAttendees.size() < capacity) {
            confirmedAttendees.add(name);
            System.out.println("'" + name + "' successfully registered and confirmed.");
        } else {
            waitlist.offer(name); // offer adds to queue
            System.out.println("'" + name + "' successfully registered and added to waitlist.");
        }
    }

    /**
     * Cancels the registration for an attendee.
     * If the attendee was confirmed and waitlist is not empty, moves the next person from waitlist to confirmed.
     *
     * @param attendeeName The name of the attendee to cancel registration for.
     * @throws IllegalArgumentException if attendeeName is null or empty.
     */
    public void cancelRegistration(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be empty.");
        }
        String name = attendeeName.trim();

        boolean removed = confirmedAttendees.remove(name);

        if (removed) {
            System.out.println("'" + name + "' successfully cancelled confirmed registration.");
            // If someone was removed from confirmed, move the next person from waitlist if available
            if (!waitlist.isEmpty()) {
                String nextAttendee = waitlist.poll(); // poll retrieves and removes the head of the queue
                if (nextAttendee != null) { // Should not be null if waitlist is not empty, but good practice
                    confirmedAttendees.add(nextAttendee);
                    System.out.println("'" + nextAttendee + "' moved from waitlist to confirmed.");
                }
            }
        } else {
            // Not in confirmed, check waitlist
            removed = waitlist.remove(name); // Queue's remove method works like Collection's remove
            if (removed) {
                System.out.println("'" + name + "' successfully cancelled waitlist registration.");
            } else {
                // Not found in either list
                System.err.println("Error: Attendee '" + name + "' not found in confirmed list or waitlist.");
            }
        }
    }

    /**
     * Gets the list of confirmed attendees.
     *
     * @return An unmodifiable list of confirmed attendees.
     */
    public List<String> getConfirmedAttendees() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(confirmedAttendees);
    }

    /**
     * Gets the list of attendees on the waitlist.
     *
     * @return A list representation of the waitlist (order is maintained).
     */
    public List<String> getWaitlist() {
        // Convert Queue to List for easy display
        return new ArrayList<>(waitlist);
    }

    /**
     * Gets the maximum capacity of the event.
     *
     * @return The event capacity.
     */
    public int getCapacity() {
        return capacity;
    }

    /**
     * Gets the current number of confirmed attendees.
     *
     * @return The count of confirmed attendees.
     */
    public int getConfirmedCount() {
        return confirmedAttendees.size();
    }

    /**
     * Gets the current number of attendees on the waitlist.
     *
     * @return The count of waitlist attendees.
     */
    public int getWaitlistCount() {
        return waitlist.size();
    }
}

public class EventManagementSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = null;

        // --- Get Event Capacity ---
        while (eventManager == null) {
            System.out.print("Enter event capacity: ");
            try {
                int capacity = scanner.nextInt();
                scanner.nextLine(); // Consume newline
                eventManager = new EventManager(capacity);
                System.out.println("Event created with capacity: " + capacity);
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for capacity.");
                scanner.nextLine(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                System.err.println("Error: " + e.getMessage());
            }
        }

        // --- Main Menu Loop ---
        boolean running = true;
        while (running) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1: // Register Attendee
                        System.out.print("Enter attendee name to register: ");
                        String nameToRegister = scanner.nextLine();
                        try {
                            eventManager.register(nameToRegister);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Registration Error: " + e.getMessage());
                        }
                        break;

                    case 2: // Cancel Registration
                        System.out.print("Enter attendee name to cancel registration for: ");
                        String nameToCancel = scanner.nextLine();
                        try {
                            eventManager.cancelRegistration(nameToCancel);
                        } catch (IllegalArgumentException e) {
                             // This catch block is technically redundant here based on EventManager implementation,
                             // but demonstrates catching potential exceptions from the manager.
                             // EventManager currently uses System.err internally for not found,
                             // but could be modified to throw for empty name.
                             System.err.println("Cancellation Error: " + e.getMessage());
                        }
                        break;

                    case 3: // View Confirmed Attendees
                        List<String> confirmed = eventManager.getConfirmedAttendees();
                        System.out.println("\n--- Confirmed Attendees ---");
                        if (confirmed.isEmpty()) {
                            System.out.println("No confirmed attendees yet.");
                        } else {
                            for (int i = 0; i < confirmed.size(); i++) {
                                System.out.println((i + 1) + ". " + confirmed.get(i));
                            }
                        }
                        System.out.println("---------------------------");
                        break;

                    case 4: // View Waitlist
                        List<String> waitlist = eventManager.getWaitlist();
                        System.out.println("\n--- Waitlist ---");
                        if (waitlist.isEmpty()) {
                            System.out.println("Waitlist is empty.");
                        } else {
                            for (int i = 0; i < waitlist.size(); i++) {
                                System.out.println((i + 1) + ". " + waitlist.get(i));
                            }
                        }
                        System.out.println("------------------");
                        break;

                    case 5: // View Event Status
                        System.out.println("\n--- Event Status ---");
                        System.out.println("Capacity: " + eventManager.getCapacity());
                        System.out.println("Confirmed: " + eventManager.getConfirmedCount());
                        System.out.println("Waitlist: " + eventManager.getWaitlistCount());
                        System.out.println("--------------------");
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Event Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for the menu choice.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) { // Catch any unexpected exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Event Menu ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Cancel Registration");
        System.out.println("3. View Confirmed Attendees");
        System.out.println("4. View Waitlist");
        System.out.println("5. View Event Status");
        System.out.println("6. Exit");
        System.out.println("------------------");
    }
}
