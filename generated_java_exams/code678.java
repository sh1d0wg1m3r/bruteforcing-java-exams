/*
 * Exam Question #678
 * Generated on: 2025-05-12 16:24:35
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Restaurant Order Management System**
 * 
 * **Objective:** Design and implement a simplified console-based restaurant order management system. This system should allow staff to manage menu items, take customer orders, process orders from a queue, and view the status of pending and completed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Menu Management:**
 *     *   Maintain a list of available dishes. Each dish should have a name and a price.
 *     *   Allow adding new dishes to the menu.
 * 2.  **Order Placement:**
 *     *   Allow creating a new customer order. An order consists of one or more dishes from the menu, with specified quantities.
 *     *   Each order should be assigned a unique ID.
 *     *   New orders are added to a waiting queue for processing.
 * 3.  **Order Processing:**
 *     *   Process the next order from the front of the waiting queue.
 *     *   Move the processed order to a list of completed orders.
 *     *   Handle the case where the queue is empty gracefully.
 * 4.  **Viewing Status:**
 *     *   Display the current waiting order queue (showing order IDs and perhaps a summary).
 *     *   Display the list of completed orders (showing order IDs and details).
 * 5.  **User Interface:**
 *     *   Provide a simple text-based menu for user interaction (add dish, place order, process order, view queue, view completed, exit).
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Use a `switch` statement to handle menu choices.
 * 6.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the waiting orders.
 *     *   Use `java.util.ArrayList` to store menu items and completed orders.
 *     *   Use `java.util.List` interface types where appropriate (e.g., for storing menu items, completed orders, and items within an order).
 * 7.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, invalid input format, processing empty queue).
 *     *   Use `System.out` for normal output (menu, order details, prompts).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during execution, especially related to user input.
 * 8.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs).
 *     *   Validate user input where necessary (e.g., ensuring menu choices are numbers within range, quantities are positive).
 *     *   Structure the code logically into appropriate classes (`Dish`, `Order`, `RestaurantOrderSystem`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu loop. Based on user input, it should perform the requested action, printing relevant information to `System.out` and error messages to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. Add Dish to Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. View Order Queue
 * 5. View Completed Orders
 * 6. Exit
 * Enter your choice: 1
 * Enter dish name: Burger
 * Enter dish price: 8.99
 * Dish 'Burger' added to menu.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 1
 * Enter dish name: Fries
 * Enter dish price: 3.49
 * Dish 'Fries' added to menu.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 2
 * --- Menu ---
 * 1. Burger ($8.99)
 * 2. Fries ($3.49)
 * --- End Menu ---
 * Enter dish number to add to order (0 to finish): 1
 * Enter quantity for Burger: 2
 * Dish 'Burger' (x2) added to order.
 * Enter dish number to add to order (0 to finish): 2
 * Enter quantity for Fries: 1
 * Dish 'Fries' (x1) added to order.
 * Enter dish number to add to order (0 to finish): 0
 * Order #1 placed.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 4
 * --- Order Queue ---
 * Order #1 (PENDING) - Items: Burger (x2), Fries (x1)
 * --- End Order Queue ---
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 3
 * Processing order #1...
 * Order #1 processed and moved to completed.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 4
 * --- Order Queue ---
 * (Queue is empty)
 * --- End Order Queue ---
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 5
 * --- Completed Orders ---
 * Order #1 (COMPLETED) - Items: Burger (x2), Fries (x1)
 * --- End Completed Orders ---
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 3
 * Error: Order queue is empty. No orders to process.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options)
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * **Constraint:** Your solution must use `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * 
 * **Deliverables:** Provide the complete Java code for the `Dish`, `Order`, and `RestaurantOrderSystem` classes (or a single class if preferred, but separate classes are better practice), including the main method to run the system.
 *
 * EXPLANATION:
 * This solution implements a `RestaurantOrderSystem` using multiple classes and the required Java components to simulate a basic order management flow.
 * 
 * 1.  **`Dish` Class:**
 *     *   Represents a menu item with `name` and `price`.
 *     *   Uses private fields and public getter methods for encapsulation.
 *     *   The constructor includes input validation for name and price, throwing `IllegalArgumentException` for invalid data.
 *     *   `toString()` provides a formatted string representation.
 * 
 * 2.  **`OrderItem` Class:**
 *     *   Represents a specific dish *within* an order, along with its `quantity`.
 *     *   Holds a reference to a `Dish` object and an integer quantity.
 *     *   Constructor validates that the dish is not null and the quantity is positive.
 *     *   `getTotalItemPrice()` calculates the cost for this specific item based on quantity.
 *     *   `toString()` provides a formatted string like "Burger (x2)".
 * 
 * 3.  **`Order` Class:**
 *     *   Represents a customer's order.
 *     *   Uses a static counter (`nextOrderId`) to generate unique IDs for each order instance.
 *     *   Contains a `List<OrderItem>` (`items`) to store the various dishes and quantities ordered. `ArrayList` is used as the concrete implementation for the `List` interface.
 *     *   Includes an `OrderStatus` enum (PENDING, COMPLETED) to track the state of the order.
 *     *   `addItem()` method adds an `OrderItem` to the order's list.
 *     *   `markCompleted()` changes the order's status.
 *     *   `getTotalPrice()` calculates the sum of all item prices in the order.
 *     *   `toString()` provides a comprehensive representation of the order, including ID, status, and all items.
 * 
 * 4.  **`RestaurantOrderSystem` Class:**
 *     *   This is the main class that orchestrates the system.
 *     *   **Data Structures:**
 *         *   `List<Dish> menu`: An `ArrayList` is used to store `Dish` objects, representing the menu. The variable is typed as `List` to adhere to the requirement of using the interface.
 *         *   `Queue<Order> orderQueue`: A `LinkedList` (which implements the `Queue` interface) is used to store `Order` objects waiting to be processed, ensuring FIFO (First-In, First-Out) order. The variable is typed as `Queue`.
 *         *   `List<Order> completedOrders`: An `ArrayList` is used to store `Order` objects that have been processed. The variable is typed as `List`.
 *     *   **Input:** A `Scanner` (`scanner`) is used to read user input from `System.in`. It's initialized once and closed in the `finally` block.
 *     *   **Methods:**
 *         *   `addDishToMenu()`: Prompts the user for dish details, reads input using `scanner.nextLine()` (parsed to double), creates a `Dish` object, and adds it to the `menu` `ArrayList`. Includes `try-catch` for `NumberFormatException` during price parsing and `IllegalArgumentException` from the `Dish` constructor. Error messages go to `System.err`.
 *         *   `displayMenu()`: Prints the current menu items with their indices.
 *         *   `placeOrder()`: Guides the user through selecting dishes and quantities from the menu to create a new `Order`. Uses a loop for adding multiple items. Reads choices and quantities using `scanner.nextLine()` and parsing, including `try-catch` for `NumberFormatException`. Validates dish choices and quantities. Creates `OrderItem` objects and adds them to the new `Order`. Finally, adds the completed `Order` object to the `orderQueue` using the `offer()` method (safe add for queues). Error messages go to `System.err`.
 *         *   `processNextOrder()`: Uses `orderQueue.poll()` to retrieve and remove the next `Order` from the queue. `poll()` is used because it returns `null` if the queue is empty, avoiding an exception. If an order is retrieved, its status is updated, and it's added to the `completedOrders` `ArrayList`. If the queue is empty, an error message is printed to `System.err`.
 *         *   `viewOrderQueue()`: Iterates through the `orderQueue` (using a for-each loop, which doesn't remove elements) and prints each order's details to `System.out`. Indicates if the queue is empty.
 *         *   `viewCompletedOrders()`: Iterates through the `completedOrders` `ArrayList` and prints each completed order's details to `System.out`. Indicates if the list is empty.
 *         *   `displayMainMenu()`: Prints the main interaction options to `System.out`.
 *         *   `runSystem()`: Contains the main application loop (`while(running)`). It displays the menu, reads user input, and uses a `switch` statement to call the appropriate method based on the user's choice.
 *     *   **Exception Handling:**
 *         *   Specific `try-catch` blocks are used within methods (`addDishToMenu`, `placeOrder`, `runSystem` for input parsing) to handle expected issues like `NumberFormatException` or `IllegalArgumentException` from object constructors. These print specific error messages to `System.err`.
 *         *   A broad `try-catch(Exception e)` block is wrapped around the main `while` loop within the `runSystem()` method. This serves as the *class-wide* exception handling mechanism, catching any unhandled exception that might occur during the program's execution and printing a generic error message to `System.err` before printing the stack trace.
 *         *   A `finally` block is used to ensure the `Scanner` is closed when the `runSystem` method finishes (either normally or due to an exception).
 *     *   **`main()` Method:** Creates an instance of `RestaurantOrderSystem` and calls `runSystem()` to start the application.
 * 
 * This solution demonstrates the required components in a practical scenario, incorporating input validation, error handling using `System.err` and `try-catch`, proper data structure usage (`Queue`, `ArrayList`, `List`), flow control (`switch`), and object-oriented design principles.
 */

import java.util.*;

/**
 * Represents a single dish on the restaurant menu.
 */
class Dish {
    private String name;
    private double price;

    /**
     * Constructs a new Dish object.
     * @param name The name of the dish.
     * @param price The price of the dish.
     * @throws IllegalArgumentException if name is null/empty or price is negative.
     */
    public Dish(String name, double price) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Dish name cannot be null or empty.");
        }
        if (price < 0) {
            throw new IllegalArgumentException("Dish price cannot be negative.");
        }
        this.name = name.trim();
        this.price = price;
    }

    /**
     * Gets the name of the dish.
     * @return The dish name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the dish.
     * @return The dish price.
     */
    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("%s ($%.2f)", name, price);
    }
}

/**
 * Represents a single item within an order, including quantity.
 */
class OrderItem {
    private Dish dish;
    private int quantity;

    /**
     * Constructs a new OrderItem.
     * @param dish The dish being ordered.
     * @param quantity The quantity of the dish.
     * @throws IllegalArgumentException if dish is null or quantity is not positive.
     */
    public OrderItem(Dish dish, int quantity) {
        if (dish == null) {
            throw new IllegalArgumentException("Dish cannot be null for an order item.");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.dish = dish;
        this.quantity = quantity;
    }

    /**
     * Gets the dish associated with this order item.
     * @return The Dish object.
     */
    public Dish getDish() {
        return dish;
    }

    /**
     * Gets the quantity of the dish in this order item.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Calculates the total price for this order item (price * quantity).
     * @return The total price for the item.
     */
    public double getTotalItemPrice() {
        return dish.getPrice() * quantity;
    }

    @Override
    public String toString() {
        return String.format("%s (x%d)", dish.getName(), quantity);
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<OrderItem> items; // Using List interface type
    private OrderStatus status;

    /**
     * Enum to represent the status of an order.
     */
    public enum OrderStatus {
        PENDING, COMPLETED
    }

    /**
     * Constructs a new Order with a unique ID and PENDING status.
     */
    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Using ArrayList implementation
        this.status = OrderStatus.PENDING;
    }

    /**
     * Gets the unique ID of the order.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return A List of OrderItem objects.
     */
    public List<OrderItem> getItems() {
        return items;
    }

    /**
     * Gets the current status of the order.
     * @return The OrderStatus.
     */
    public OrderStatus getStatus() {
        return status;
    }

    /**
     * Adds an OrderItem to the order.
     * @param item The OrderItem to add.
     * @throws IllegalArgumentException if item is null.
     */
    public void addItem(OrderItem item) {
        if (item == null) {
            throw new IllegalArgumentException("Cannot add null order item to order.");
        }
        this.items.add(item);
    }

    /**
     * Marks the order as completed.
     */
    public void markCompleted() {
        this.status = OrderStatus.COMPLETED;
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotalPrice() {
        double total = 0;
        for (OrderItem item : items) {
            total += item.getTotalItemPrice();
        }
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Order #%d (%s) - Items: ", orderId, status));
        if (items.isEmpty()) {
            sb.append("No items");
        } else {
            for (int i = 0; i < items.size(); i++) {
                sb.append(items.get(i).toString());
                if (i < items.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        sb.append(String.format(" (Total: $%.2f)", getTotalPrice()));
        return sb.toString();
    }
}

/**
 * The main class managing the restaurant's orders.
 */
public class RestaurantOrderSystem {
    // Using List interface type with ArrayList implementation for menu
    private List<Dish> menu;
    // Using Queue interface type with LinkedList implementation for order queue
    private Queue<Order> orderQueue;
    // Using List interface type with ArrayList implementation for completed orders
    private List<Order> completedOrders;
    private Scanner scanner;

    /**
     * Constructs a new RestaurantOrderSystem.
     * Initializes the menu, order queue, completed orders list, and scanner.
     */
    public RestaurantOrderSystem() {
        this.menu = new ArrayList<>();
        this.orderQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedOrders = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new dish to the menu.
     */
    public void addDishToMenu() {
        System.out.print("Enter dish name: ");
        String name = scanner.nextLine();

        double price = -1;
        System.out.print("Enter dish price: ");
        try {
            price = Double.parseDouble(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid price format. Please enter a number.");
            return; // Exit the method if price is invalid
        }

        try {
            Dish newDish = new Dish(name, price);
            menu.add(newDish); // Add to ArrayList
            System.out.println("Dish '" + newDish.getName() + "' added to menu.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding dish: " + e.getMessage());
        }
    }

    /**
     * Displays the current menu with indices.
     */
    private void displayMenu() {
        System.out.println("--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("(Menu is empty)");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
        System.out.println("--- End Menu ---");
    }

    /**
     * Allows placing a new order by selecting items from the menu.
     */
    public void placeOrder() {
        if (menu.isEmpty()) {
            System.err.println("Error: Menu is empty. Cannot place an order.");
            return;
        }

        Order newOrder = new Order();
        System.out.println("Placing order #" + newOrder.getOrderId());

        boolean addingItems = true;
        while (addingItems) {
            displayMenu();
            System.out.print("Enter dish number to add to order (0 to finish): ");
            int dishChoice = -1;
            try {
                dishChoice = Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
                 System.err.println("Error: Invalid input. Please enter a number.");
                 continue; // Continue the loop to prompt again
            }

            if (dishChoice == 0) {
                addingItems = false;
                if (newOrder.getItems().isEmpty()) {
                     System.err.println("Error: Order must contain at least one item. Please add items.");
                     addingItems = true; // Force adding items if none were added
                }
                continue; // Exit item selection loop
            }

            if (dishChoice > 0 && dishChoice <= menu.size()) {
                Dish selectedDish = menu.get(dishChoice - 1);
                System.out.print("Enter quantity for " + selectedDish.getName() + ": ");
                int quantity = -1;
                try {
                    quantity = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid quantity format. Please enter a whole number.");
                    continue; // Continue the loop to prompt again
                }

                try {
                    OrderItem item = new OrderItem(selectedDish, quantity);
                    newOrder.addItem(item);
                    System.out.println("Dish '" + selectedDish.getName() + "' (x" + quantity + ") added to order.");
                } catch (IllegalArgumentException e) {
                    System.err.println("Error adding item: " + e.getMessage());
                }

            } else {
                System.err.println("Error: Invalid dish number. Please select from the menu.");
            }
        }

        if (!newOrder.getItems().isEmpty()) {
            orderQueue.offer(newOrder); // Add order to the Queue
            System.out.println("Order #" + newOrder.getOrderId() + " placed.");
        } else {
             System.out.println("Order cancelled as no items were added.");
        }
    }

    /**
     * Processes the next order in the queue.
     */
    public void processNextOrder() {
        Order orderToProcess = orderQueue.poll(); // Get and remove the head of the queue

        if (orderToProcess == null) {
            System.err.println("Error: Order queue is empty. No orders to process.");
        } else {
            System.out.println("Processing order #" + orderToProcess.getOrderId() + "...");
            orderToProcess.markCompleted();
            completedOrders.add(orderToProcess); // Add to ArrayList
            System.out.println("Order #" + orderToProcess.getOrderId() + " processed and moved to completed.");
        }
    }

    /**
     * Displays the current waiting order queue.
     */
    public void viewOrderQueue() {
        System.out.println("--- Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(order);
            }
        }
        System.out.println("--- End Order Queue ---");
    }

    /**
     * Displays the list of completed orders.
     */
    public void viewCompletedOrders() {
        System.out.println("--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("(No completed orders)");
        } else {
            // Iterate through the ArrayList
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("--- End Completed Orders ---");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order Management ---");
        System.out.println("1. Add Dish to Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Order Queue");
        System.out.println("5. View Completed Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Contains class-wide exception handling.
     */
    public void runSystem() {
        boolean running = true;

        // Class-wide try-catch block for unexpected exceptions
        try {
            while (running) {
                displayMainMenu();
                int choice = -1;
                try {
                    // Use nextLine() and parse to avoid newline issues after nextInt()
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement for flow control
                switch (choice) {
                    case 1:
                        addDishToMenu();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewOrderQueue();
                        break;
                    case 5:
                        viewCompletedOrders();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception that wasn't handled specifically
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the system exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.runSystem();
    }
}
