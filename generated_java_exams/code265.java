/*
 * Exam Question #265
 * Generated on: 2025-05-11 22:46:42
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Conference Session Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system to manage attendees for sessions at a conference. The system should allow users to register attendees for sessions, manage session capacity, handle waiting lists, and check in attendees. This task requires you to demonstrate your understanding of fundamental Java data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Create a `Session` class representing a conference session. It must include:
 *         *   An integer ID.
 *         *   A String title.
 *         *   An integer capacity.
 *         *   A collection to store currently registered attendees. This collection *must* be declared as `java.util.List` and initialized using `java.util.ArrayList`.
 *         *   A collection to store attendees on a waiting list when the session is full. This collection *must* be declared and used as `java.util.Queue`.
 *     *   Create an `Attendee` class with at least a String for the attendee's name. Implement appropriate methods (`equals`, `hashCode`) based on the name for proper collection handling.
 *     *   The main management class (`ConferenceManager`) must hold a collection of `Session` objects, declared as `java.util.List` and initialized using `java.util.ArrayList`.
 * 
 * 2.  **Functionality:**
 *     *   **Display Sessions:** Implement a menu option to list all available sessions, showing their ID, title, capacity, current number of registered attendees, and current waiting list size.
 *     *   **Register Attendee:**
 *         *   Prompt the user for the attendee's name and the session ID they wish to register for.
 *         *   Validate that the session ID exists. If not, report an error.
 *         *   Check if the attendee (by name) is *already* registered or on the waiting list for *that specific session*. If so, report an error.
 *         *   If the session has capacity, add the attendee to the registered list. Report success.
 *         *   If the session is full, add the attendee to the waiting list queue. Report that they have been added to the waiting list.
 *     *   **Check-in Attendee:**
 *         *   Prompt the user for the attendee's name and the session ID they are checking into.
 *         *   Validate that the session ID exists. If not, report an error.
 *         *   Check if the attendee (by name) is in the *registered* list for that session.
 *         *   If found in the registered list, simulate check-in (print a success message).
 *         *   If not found in the registered list (they might be on the waiting list or not registered at all), report an error.
 *     *   **View Session Details:**
 *         *   Prompt the user for a session ID.
 *         *   Validate that the session ID exists. If not, report an error.
 *         *   Display the list of registered attendees and the list of attendees on the waiting list for that session.
 * 
 * 3.  **User Interface & Control Flow:**
 *     *   Implement a simple text-based menu using `java.util.Scanner` in the `main` method or a dedicated `run` method of your management class.
 *     *   Use a `switch` statement to handle the different menu options (e.g., 1 for Register, 2 for Check-in, 3 for View Sessions, 4 for Display All Sessions, 5 for Exit).
 * 
 * 4.  **Error Handling & Best Practices:**
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, session details).
 *     *   Use `System.err` for all error messages (invalid input, session not found, registration/check-in failures, etc.).
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main user interaction loop to gracefully handle unexpected runtime errors (e.g., non-integer input when expecting an integer).
 *     *   Adhere to best practices:
 *         *   Proper encapsulation (private fields, public methods).
 *         *   Meaningful variable and method names.
 *         *   Appropriate comments and documentation (basic inline comments or Javadoc).
 *         *   Perform input validation as described in the functionality requirements.
 * 
 * **Initial Data:**
 * The system should be initialized with the following sessions:
 * *   Session ID: 1, Title: "Keynote Address", Capacity: 100
 * *   Session ID: 2, Title: "Java Deep Dive", Capacity: 3
 * *   Session ID: 3, Title: "Web Development Trends", Capacity: 50
 * 
 * **Expected Output:**
 * The program should display a menu, accept user input via `Scanner`, execute the chosen action using a `switch` statement, and print results to `System.out` or errors to `System.err` until the user selects the exit option.
 * 
 * **Example Interaction Flow (Partial):**
 * ```
 * --- Conference Management Menu ---
 * 1. Register Attendee
 * 2. Check-in Attendee
 * 3. View Session Details
 * 4. Display All Sessions
 * 5. Exit
 * Enter your choice: 4
 * --- All Sessions ---
 * ID: 1, Title: Keynote Address, Registered: 0/100, Waiting List: 0
 * ID: 2, Title: Java Deep Dive, Registered: 0/3, Waiting List: 0
 * ID: 3, Title: Web Development Trends, Registered: 0/50, Waiting List: 0
 * 
 * --- Conference Management Menu ---
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Enter session ID: 2
 * Alice registered successfully for Java Deep Dive.
 * 
 * --- Conference Management Menu ---
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Enter session ID: 2
 * Bob registered successfully for Java Deep Dive.
 * 
 * --- Conference Management Menu ---
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter attendee name: Charlie
 * Enter session ID: 2
 * Charlie registered successfully for Java Deep Dive.
 * 
 * --- Conference Management Menu ---
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter attendee name: David
 * Enter session ID: 2
 * Session 2 (Java Deep Dive) is full. David added to waiting list.
 * 
 * --- Conference Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter session ID: 2
 * --- Session Details: Java Deep Dive (ID: 2) ---
 * Registered Attendees:
 * - Alice
 * - Bob
 * - Charlie
 * Waiting List:
 * - David
 * 
 * ... (User continues interaction or exits)
 * ```
 * 
 * Your solution should implement the classes and logic described above, ensuring all specified components and best practices are used correctly.
 *
 * EXPLANATION:
 * This solution implements the Conference Session Management System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and How They Are Used:**
 * 
 * 1.  **`java.util.Queue`**: The `Session` class uses a `java.util.Queue<Attendee>` named `waitingList`. When a session's capacity is reached, new attendees are added to this queue using `waitingList.offer()`. This correctly simulates a waiting list where attendees are processed in a First-In, First-Out (FIFO) manner (though the current implementation doesn't include logic to promote from the queue when spots open, it correctly uses the Queue structure for waiting). `LinkedList` is used as the concrete implementation for the `Queue`.
 * 2.  **`java.util.ArrayList`**: `ArrayList` is used as the concrete implementation for the `java.util.List` variables.
 * 3.  **`java.util.List` interface**:
 *     *   The `Session` class declares `registeredAttendees` as `List<Attendee>`, initialized with `new ArrayList<>()`.
 *     *   The `ConferenceManager` class declares `sessions` as `List<Session>`, initialized with `new ArrayList<>()`.
 *     *   Methods like `getRegisteredAttendees()` in `Session` return a `List` interface, promoting flexibility.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used in the `ConferenceManager` class to read user input from `System.in` for menu choices, attendee names, and session IDs. Care is taken to handle the newline character after reading integers (`scanner.nextLine()`).
 * 5.  **`switch` statement**: The `run()` method in `ConferenceManager` uses a `switch` statement to dispatch control based on the user's integer menu choice, invoking the appropriate handler method (`handleRegistration`, `handleCheckIn`, etc.).
 * 6.  **`System.err`**: `System.err.println()` is used throughout the `ConferenceManager` and `Session` classes to print error messages. This includes validation failures (e.g., empty name, session not found, already registered) and messages caught by the `try-catch` blocks.
 * 7.  **`System.out`**: `System.out.println()` is used for normal program output, such as displaying the menu, prompts, success messages, session summaries, and detailed session attendee lists.
 * 8.  **Class-wide `try-catch`**: A `try-catch` block is wrapped around the core logic within the `run()` method's `while` loop in `ConferenceManager`. This block catches `InputMismatchException` specifically for invalid numeric input from the `Scanner` and a general `Exception` to catch any other unexpected runtime errors that might occur during command processing. This provides a level of robustness for the main application loop.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields in `Attendee`, `Session`, and `ConferenceManager` are declared `private`. Access and modification are controlled via public methods (getters, `registerAttendee`, `checkInAttendee`).
 * *   **Meaningful Names:** Class names (`Attendee`, `Session`, `ConferenceManager`), variable names (`registeredAttendees`, `waitingList`, `sessionId`, `attendeeName`), and method names (`registerAttendee`, `checkInAttendee`, `findSessionById`, `displayMenu`) are descriptive.
 * *   **Comments and Documentation:** Basic inline comments explain key parts, and method names often serve as self-documentation. Javadoc could be added for more formal documentation.
 * *   **Input Validation:**
 *     *   Attendee name is checked for null or emptiness in the `Attendee` constructor and input handling methods.
 *     *   Session parameters (ID, title, capacity) are validated in the `Session` constructor.
 *     *   Session ID entered by the user is validated by checking if `findSessionById` returns a non-null `Session` object.
 *     *   Input type validation for integers is handled by catching `InputMismatchException` with `Scanner`.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for various failure conditions (session not found, attendee already present, invalid input type). The `try-catch` in `run()` provides a fallback for unexpected errors.
 * *   **Clean Code Structure:** The problem is divided into logical classes (`Attendee`, `Session`, `ConferenceManager`), each responsible for a specific part of the system. Methods are relatively short and focused on a single task.
 * 
 * **Challenging Aspects Addressed:**
 * 
 * *   Integrating multiple data structures (`List`, `Queue`, `ArrayList`, `LinkedList`) within a cohesive system.
 * *   Managing state within the `Session` objects (registered vs. waiting list).
 * *   Implementing distinct logic for registration (capacity check, adding to list/queue) and check-in (checking only registered list).
 * *   Handling user input and potential input errors gracefully using `Scanner` and `try-catch`.
 * *   Using the `switch` statement effectively for menu-driven control flow.
 * *   Ensuring proper error reporting via `System.out` vs. `System.err`.
 * *   Handling attendee equality correctly using `equals` and `hashCode` for collection operations (`contains`).
 * 
 * This solution provides a solid foundation for the conference management system, fulfilling all specified requirements and demonstrating advanced Java programming concepts in a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation of Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues
import java.util.Objects; // For Objects.equals and Objects.hash

// Represents an attendee
class Attendee {
    private String name;

    public Attendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    public String getName() {
        return name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return Objects.equals(name, attendee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a conference session
class Session {
    private int id;
    private String title;
    private int capacity;
    private List<Attendee> registeredAttendees; // Must use List interface, initialized with ArrayList
    private Queue<Attendee> waitingList;     // Must use Queue interface, initialized with LinkedList

    public Session(int id, String title, int capacity) {
        if (id <= 0) throw new IllegalArgumentException("Session ID must be positive.");
        if (title == null || title.trim().isEmpty()) throw new IllegalArgumentException("Session title cannot be null or empty.");
        if (capacity < 0) throw new IllegalArgumentException("Session capacity cannot be negative.");

        this.id = id;
        this.title = title.trim();
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // ArrayList concrete implementation
        this.waitingList = new LinkedList<>();      // LinkedList concrete implementation for Queue
    }

    public int getId() {
        return id;
    }

    public String getTitle() {
        return title;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Attendee> getRegisteredAttendees() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(registeredAttendees);
    }

    public Queue<Attendee> getWaitingList() {
        // Return a copy or unmodifiable queue
        return new LinkedList<>(waitingList);
    }

    public int getRegisteredCount() {
        return registeredAttendees.size();
    }

    public int getWaitingListSize() {
        return waitingList.size();
    }

    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    // Checks if attendee is already in registered list or waiting list
    private boolean isAttendeePresent(Attendee attendee) {
        return registeredAttendees.contains(attendee) || waitingList.contains(attendee);
    }

    // Attempts to register an attendee
    // Returns true if registered, false if added to waiting list, throws exception/prints error if already present
    public void registerAttendee(Attendee attendee) {
        if (attendee == null) {
             System.err.println("Error: Cannot register null attendee.");
             return;
        }
        if (isAttendeePresent(attendee)) {
            System.err.println("Error: Attendee '" + attendee.getName() + "' is already registered or on the waiting list for session " + id + ".");
            return;
        }

        if (!isFull()) {
            registeredAttendees.add(attendee);
            System.out.println(attendee.getName() + " registered successfully for " + title + ".");
        } else {
            waitingList.offer(attendee); // offer is preferred over add for queues when capacity is involved
            System.out.println("Session " + id + " (" + title + ") is full. " + attendee.getName() + " added to waiting list.");
        }
    }

    // Attempts to check in an attendee
    public void checkInAttendee(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Error: Attendee name for check-in cannot be empty.");
            return;
        }
        Attendee attendeeToCheckIn = new Attendee(attendeeName); // Create temp attendee for comparison

        if (registeredAttendees.contains(attendeeToCheckIn)) {
            // In a real system, you might mark them as checked in. Here, we just confirm.
            System.out.println(attendeeName + " successfully checked in for session " + id + " (" + title + ").");
        } else if (waitingList.contains(attendeeToCheckIn)) {
             System.err.println("Error: Attendee '" + attendeeName + "' is on the waiting list for session " + id + ". Cannot check in.");
        }
        else {
            System.err.println("Error: Attendee '" + attendeeName + "' not found in registered list for session " + id + " (" + title + ").");
        }
    }
}

// Manages sessions and user interaction
public class ConferenceManager { // Made public for the main method
    private List<Session> sessions; // Must use List interface, initialized with ArrayList
    private Scanner scanner;

    public ConferenceManager() {
        this.sessions = new ArrayList<>(); // ArrayList concrete implementation
        initializeSessions();
        this.scanner = new Scanner(System.in);
    }

    // Initializes the predefined sessions
    private void initializeSessions() {
        try {
            sessions.add(new Session(1, "Keynote Address", 100));
            sessions.add(new Session(2, "Java Deep Dive", 3));
            sessions.add(new Session(3, "Web Development Trends", 50));
        } catch (IllegalArgumentException e) {
            System.err.println("Error initializing sessions: " + e.getMessage());
            // In a real app, this might require more robust handling or logging
        }
    }

    // Finds a session by its ID
    private Session findSessionById(int id) {
        for (Session session : sessions) {
            if (session.getId() == id) {
                return session;
            }
        }
        return null; // Session not found
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Conference Management Menu ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Check-in Attendee");
        System.out.println("3. View Session Details");
        System.out.println("4. Display All Sessions");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Handles the registration process
    private void handleRegistration() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        int sessionId = -1;
        System.out.print("Enter session ID: ");
        try {
            sessionId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for session ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             // Consume the newline character left by nextInt() or nextLine() after error
             // This is important to prevent issues in the next scanner.nextLine() call
             if (sessionId == -1) { // Only consume if nextInt() failed
                // Already consumed in catch
             } else {
                scanner.nextLine(); // Consume remaining newline after successful nextInt()
             }
        }


        Session session = findSessionById(sessionId);
        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        try {
            Attendee attendee = new Attendee(name); // Attendee constructor validates name
            session.registerAttendee(attendee); // Session method handles registration logic
        } catch (IllegalArgumentException e) {
            // Catching potential errors from Attendee constructor
            System.err.println("Registration failed: " + e.getMessage());
        }
    }

    // Handles the check-in process
    private void handleCheckIn() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim();
         if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        int sessionId = -1;
        System.out.print("Enter session ID: ");
         try {
            sessionId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for session ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             if (sessionId == -1) {
                // Already consumed in catch
             } else {
                scanner.nextLine(); // Consume remaining newline
             }
        }

        Session session = findSessionById(sessionId);
        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        session.checkInAttendee(name); // Session method handles check-in logic
    }

    // Handles viewing session details
    private void handleViewSessionDetails() {
        int sessionId = -1;
        System.out.print("Enter session ID to view details: ");
        try {
            sessionId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for session ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             if (sessionId == -1) {
                // Already consumed in catch
             } else {
                scanner.nextLine(); // Consume remaining newline
             }
        }

        Session session = findSessionById(sessionId);
        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        System.out.println("\n--- Session Details: " + session.getTitle() + " (ID: " + session.getId() + ") ---");
        System.out.println("Capacity: " + session.getCapacity());
        System.out.println("Registered Attendees (" + session.getRegisteredCount() + "):");
        List<Attendee> registered = session.getRegisteredAttendees(); // Get the list copy
        if (registered.isEmpty()) {
            System.out.println("  (None)");
        } else {
            for (Attendee attendee : registered) {
                System.out.println("  - " + attendee.getName());
            }
        }

        System.out.println("Waiting List (" + session.getWaitingListSize() + "):");
        Queue<Attendee> waiting = session.getWaitingList(); // Get the queue copy
         if (waiting.isEmpty()) {
            System.out.println("  (None)");
        } else {
             // Iterate over the queue without removing elements
            for (Attendee attendee : waiting) {
                System.out.println("  - " + attendee.getName());
            }
        }
    }

    // Displays all sessions summary
    private void displayAllSessions() {
        System.out.println("\n--- All Sessions ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions available.");
            return;
        }
        for (Session session : sessions) {
            System.out.println("ID: " + session.getId() + ", Title: " + session.getTitle() +
                               ", Registered: " + session.getRegisteredCount() + "/" + session.getCapacity() +
                               ", Waiting List: " + session.getWaitingListSize());
        }
    }

    // Runs the main conference management loop
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Class-wide exception handling for the main loop's input and processing
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character

                switch (choice) {
                    case 1:
                        handleRegistration();
                        break;
                    case 2:
                        handleCheckIn();
                        break;
                    case 3:
                        handleViewSessionDetails();
                        break;
                    case 4:
                        displayAllSessions();
                        break;
                    case 5:
                        System.out.println("Exiting Conference Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to keep loop running
            } catch (Exception e) {
                // Catch any other unexpected runtime errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
         scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        ConferenceManager manager = new ConferenceManager();
        manager.run();
    }
}
