/*
 * Exam Question #122
 * Generated on: 2025-05-11 22:17:25
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Smart Manufacturing Assembly Line Simulation**
 * 
 * **Problem Description:**
 * 
 * Design and implement a Java program that simulates a simplified assembly line in a smart manufacturing facility. The program should manage a queue of assembly tasks (representing products to be assembled) and a list of available components required for assembly. Users interact with the simulation via a console menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   The program must maintain a queue of product names (`String`) representing tasks waiting for assembly.
 *     *   The program must maintain a list of component names (`String`) representing available parts.
 *     *   The simulation should present a menu of options to the user:
 *         1.  Add a new assembly task to the queue.
 *         2.  Process the next task in the queue.
 *         3.  View the current assembly queue.
 *         4.  View the list of available components.
 *         5.  Exit the simulation.
 * 
 * 2.  **Task Processing Logic:**
 *     *   Processing a task involves taking the next product from the *front* of the queue.
 *     *   For this simulation, assume *any* assembly task requires *one* "Assembly Kit" component.
 *     *   Before processing a task, the program must check if an "Assembly Kit" is available in the list of components.
 *     *   If an "Assembly Kit" is available:
 *         *   Remove *one* "Assembly Kit" from the list of available components.
 *         *   Remove the task from the queue.
 *         *   Print a success message indicating which product was assembled and that a component was consumed.
 *     *   If an "Assembly Kit" is *not* available:
 *         *   Print an error message indicating insufficient components.
 *         *   The task *must remain* at the front of the queue, waiting for components.
 * 
 * 3.  **Required Java Components:** Your solution *must* explicitly use and demonstrate the functionality of **ALL** the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (declared as the type for the components collection)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for menu handling)
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing normal output, menu, success messages, etc.)
 *     *   Class-wide exception handling using `try-catch` blocks (a single `try-catch` block wrapping the main simulation loop or critical operations is acceptable to meet the "class-wide" feel).
 * 
 * 4.  **Best Practices:**
 *     *   Implement the simulation within a class (`ManufacturingSimulation` or similar) with proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for the class and main methods).
 *     *   Implement input validation for user choices (e.g., ensuring an integer is entered for the menu).
 *     *   Handle potential errors gracefully (e.g., trying to process an empty queue, insufficient components).
 *     *   Structure the code cleanly.
 * 
 * **Initial State:**
 * 
 * *   The assembly queue should start empty.
 * *   The components list should be initialized with a few components, including at least two "Assembly Kit" components, and maybe some other types (e.g., "Screw Pack", "Wire Bundle").
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, accepting input, and printing messages based on the chosen option and simulation state. Error messages should go to standard error (`System.err`), while normal output goes to standard output (`System.out`).
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Manufacturing Assembly Line Simulation ---
 * 1. Add Assembly Task
 * 2. Process Next Task
 * 3. View Assembly Queue
 * 4. View Available Components
 * 5. Exit
 * Enter your choice: 1
 * Enter product name to add: Gadget X
 * Task 'Gadget X' added to the queue.
 * 
 * 1. Add Assembly Task
 * 2. Process Next Task
 * 3. View Assembly Queue
 * 4. View Available Components
 * 5. Exit
 * Enter your choice: 3
 * Current Assembly Queue: [Gadget X]
 * 
 * 1. Add Assembly Task
 * 2. Process Next Task
 * 3. View Assembly Queue
 * 4. View Available Components
 * 5. Exit
 * Enter your choice: 2
 * Attempting to process task: Gadget X
 * Successfully assembled 'Gadget X'. One 'Assembly Kit' consumed.
 * 
 * 1. Add Assembly Task
 * 2. Process Next Task
 * ... (continue interaction)
 * ```
 * 
 * If an error occurs (e.g., insufficient components or invalid input), an appropriate message should appear on `System.err`.
 * 
 * ```
 * Enter your choice: 2
 * Assembly queue is empty. No tasks to process.
 * 
 * Enter your choice: 99
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * Enter your choice: 2
 * Attempting to process task: Widget Y
 * Insufficient components to assemble 'Widget Y'. 'Assembly Kit' is required.
 * Task remains in the queue.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of the assembly line logic, including component checking before processing.
 * *   Strict adherence to using ALL required Java components as specified.
 * *   Proper use of `System.out` and `System.err`.
 * *   Effective use of `switch` for menu navigation.
 * *   Implementation of input validation and error handling using `try-catch`.
 * *   Code quality, structure, encapsulation, and readability.
 *
 * EXPLANATION:
 * This solution implements the `ManufacturingSimulation` class to manage assembly tasks and components according to the problem requirements.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The simulation logic is encapsulated within the `ManufacturingSimulation` class.
 *     *   Core data structures (`assemblyQueue`, `availableComponents`) and the input reader (`scanner`) are declared as private fields, enforcing encapsulation.
 *     *   Public methods (`runSimulation`, `main`) provide the entry points, while private helper methods (`displayMenu`, `getUserChoice`, `addTask`, `processNextTask`, `viewQueue`, `viewComponents`, `initializeComponents`) handle specific functionalities, promoting modularity.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `assemblyQueue` is declared as a `Queue<String>` and initialized with a `LinkedList`, which is a common `Queue` implementation. Methods like `offer()` (add to tail), `peek()` (view head), and `poll()` (remove head) are used.
 *     *   `java.util.ArrayList`: The `availableComponents` is initialized as an `ArrayList`, providing a dynamic, list-based storage for components.
 *     *   `java.util.List`: The `availableComponents` field is declared using the `List` interface type, demonstrating programming to interfaces.
 *     *   `java.util.Scanner`: A `Scanner` object is used to read user input from `System.in` for menu choices and task names.
 *     *   `switch` statement: A `switch` statement in `runSimulation()` is used to direct the program flow based on the user's menu choice.
 *     *   `System.err`: Used specifically in `getUserChoice()` for invalid input messages, in `addTask()` for empty product names, and in `processNextTask()` for empty queue or insufficient component errors.
 *     *   `System.out`: Used for displaying the menu, successful operations, queue contents, and component list.
 *     *   Class-wide `try-catch`: A single `try-catch(Exception e)` block wraps the main `while(running)` loop in the `runSimulation()` method. This provides a broad safety net for unexpected exceptions that might occur during the simulation's execution, fulfilling the "class-wide" handling requirement. A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Simulation Logic:**
 *     *   `initializeComponents()` sets up the initial state of available parts.
 *     *   `addTask()` takes user input for a product name and adds it to the end of the `assemblyQueue` using `offer()`. Basic validation checks for an empty product name.
 *     *   `processNextTask()` implements the core logic:
 *         *   It first checks if the queue is empty.
 *         *   It uses `peek()` to look at the next task without removing it.
 *         *   It checks if the `availableComponents` list `contains()` the required `ASSEMBLY_KIT`.
 *         *   Only if the component is present does it use `availableComponents.remove(ASSEMBLY_KIT)` (removing the first occurrence) and then `assemblyQueue.poll()` to remove the task from the queue.
 *         *   Appropriate messages are printed to `System.out` or `System.err` based on the outcome.
 *     *   `viewQueue()` and `viewComponents()` simply print the current state of the respective collections.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   `getUserChoice()` includes a loop (`while (!scanner.hasNextInt())`) to handle cases where the user enters non-integer input for the menu choice, prompting them again using `System.err`. It also consumes the invalid input using `scanner.next()`. `scanner.nextLine()` is used after reading the integer to consume the newline character, preventing issues in subsequent `nextLine()` calls (like in `addTask`).
 *     *   The `switch` `default` case handles integer inputs that are outside the valid menu range (1-5) and prints an error to `System.err`.
 *     *   `addTask()` checks for and rejects empty product names.
 *     *   `processNextTask()` handles the cases of an empty queue and insufficient components, printing specific error messages to `System.err`.
 *     *   The main `try-catch` in `runSimulation()` provides a fallback for any other unexpected exceptions.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names like `assemblyQueue`, `availableComponents`, `processNextTask`, `getUserChoice` are used.
 *     *   The code is structured logically into methods corresponding to menu options and helper functions.
 *     *   Basic comments and Javadoc are included.
 *     *   The `Scanner` is closed in the `finally` block to release system resources.
 * 
 * This solution effectively combines the required Java components in a practical simulation, demonstrating understanding of data structures, control flow, input/output handling, and error management within the constraints of the problem.
 */

import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Simulates a simplified manufacturing assembly line.
 * Manages a queue of assembly tasks and a list of available components.
 */
public class ManufacturingSimulation {

    // Required Java components
    private Queue<String> assemblyQueue;
    private List<String> availableComponents;
    private Scanner scanner;

    // Constant for the required component name
    private static final String ASSEMBLY_KIT = "Assembly Kit";

    /**
     * Constructs a new ManufacturingSimulation.
     * Initializes the queue, components list, and scanner.
     */
    public ManufacturingSimulation() {
        // Use LinkedList as an implementation of Queue
        this.assemblyQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.availableComponents = new ArrayList<>();
        this.scanner = new Scanner(System.in);

        // Initialize with some components
        initializeComponents();
    }

    /**
     * Initializes the list of available components.
     */
    private void initializeComponents() {
        availableComponents.add(ASSEMBLY_KIT);
        availableComponents.add(ASSEMBLY_KIT); // Add multiple kits
        availableComponents.add("Screw Pack");
        availableComponents.add("Wire Bundle");
        availableComponents.add("Plastic Casing");
        System.out.println("Initial components loaded.");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Manufacturing Assembly Line Simulation ---");
        System.out.println("1. Add Assembly Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Assembly Queue");
        System.out.println("4. View Available Components");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads the user's menu choice, handling invalid input.
     * @return The valid integer choice entered by the user.
     */
    private int getUserChoice() {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            System.out.print("Enter your choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the rest of the line after the integer
        return choice;
    }

    /**
     * Adds a new assembly task (product name) to the queue.
     */
    private void addTask() {
        System.out.print("Enter product name to add: ");
        String productName = scanner.nextLine().trim();

        if (productName.isEmpty()) {
            System.err.println("Product name cannot be empty. Task not added.");
            return;
        }

        assemblyQueue.offer(productName); // offer is generally preferred for queues
        System.out.println("Task '" + productName + "' added to the queue.");
    }

    /**
     * Processes the next task in the queue if components are available.
     */
    private void processNextTask() {
        if (assemblyQueue.isEmpty()) {
            System.err.println("Assembly queue is empty. No tasks to process.");
            return;
        }

        String taskToProcess = assemblyQueue.peek(); // Peek to view without removing

        System.out.println("Attempting to process task: " + taskToProcess);

        // Check for required components
        if (availableComponents.contains(ASSEMBLY_KIT)) {
            // Simulate consuming one Assembly Kit
            boolean componentRemoved = availableComponents.remove(ASSEMBLY_KIT); // remove(Object) removes the first occurrence

            if (componentRemoved) {
                String processedTask = assemblyQueue.poll(); // Remove task from queue
                System.out.println("Successfully assembled '" + processedTask + "'. One '" + ASSEMBLY_KIT + "' consumed.");
            } else {
                 // This case is unlikely with ArrayList.remove(Object) if contains() is true
                 System.err.println("Internal error: Component check passed but removal failed.");
            }
        } else {
            System.err.println("Insufficient components to assemble '" + taskToProcess + "'. '" + ASSEMBLY_KIT + "' is required.");
            System.err.println("Task '" + taskToProcess + "' remains in the queue.");
        }
    }

    /**
     * Displays the current contents of the assembly queue.
     */
    private void viewQueue() {
        System.out.println("Current Assembly Queue: " + assemblyQueue);
        if (assemblyQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        }
    }

    /**
     * Displays the current list of available components.
     */
    private void viewComponents() {
        System.out.println("Available Components: " + availableComponents);
        if (availableComponents.isEmpty()) {
            System.out.println("(No components available)");
        }
    }

    /**
     * Runs the main simulation loop.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        boolean running = true;

        // Class-wide exception handling block
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice(); // This method handles InputMismatchException internally

                // Switch statement for menu control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewComponents();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulation.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                // Add a slight pause or newline for better readability between cycles
                System.out.println();
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            // In a real application, you might log the full stack trace
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ManufacturingSimulation simulation = new ManufacturingSimulation();
        simulation.runSimulation();
    }
}
