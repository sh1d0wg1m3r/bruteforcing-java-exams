/*
 * Exam Question #160
 * Generated on: 2025-05-11 22:23:30
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line application simulating a task management system for a small team. The system should allow users to add new tasks to a processing queue, process the next task in line, and view both the pending tasks and the completed tasks.
 * 
 * **Core Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to encapsulate task details (e.g., a unique ID and description). Ensure proper encapsulation.
 * 2.  **Task Management Logic:** Create a class `TaskManager` that will manage the collections of tasks and handle user interactions.
 * 3.  **Pending Tasks:** Use a `java.util.Queue` to store tasks that are waiting to be processed. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 * 4.  **Completed Tasks:** Use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store tasks that have been processed.
 * 5.  **User Interaction:** Interact with the user through the console using `java.util.Scanner` to get input (menu choices and task descriptions).
 * 6.  **Menu and Flow Control:** Present a menu of options to the user. Use a `switch` statement to handle the user's chosen action.
 * 7.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operation confirmations, and lists of tasks.
 *     *   Use `System.err` for displaying error messages and warnings (e.g., invalid input, attempting to process an empty queue).
 * 8.  **Exception Handling:** Implement robust error handling, including:
 *     *   Input validation (e.g., ensure task descriptions are not empty).
 *     *   Handling specific operational errors (e.g., trying to process a task when the queue is empty).
 *     *   Utilize `try-catch` blocks for class-wide exception handling, particularly around user input operations and potentially risky code sections, to gracefully handle unexpected runtime issues (like non-integer input).
 * 9.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc-style comments for classes and methods).
 *     *   Clean code structure (separate classes for `Task`, `TaskManager`, and a main entry point).
 * 
 * **User Interaction Flow:**
 * 
 * The program should continuously display a menu with options:
 * 1.  Add New Task: Prompts the user for a task description and adds a new `Task` object to the pending queue.
 * 2.  Process Next Task: Removes the task at the front of the queue, marks it as completed, and adds it to the completed tasks list. If the queue is empty, display an error.
 * 3.  View Task Queue: Displays all tasks currently in the pending queue, in the order they would be processed.
 * 4.  View Completed Tasks: Displays all tasks that have been processed and are in the completed list.
 * 5.  Exit: Terminates the application.
 * 
 * The system should handle invalid menu choices and incorrect input types gracefully using error messages.
 * 
 * **Expected Output:**
 * 
 * *   A clear, numbered menu displayed.
 * *   Informative messages printed to `System.out` upon successful actions (task added, task processed).
 * *   Lists of pending and completed tasks printed to `System.out` in a readable format.
 * *   Error messages printed to `System.err` for invalid operations (e.g., processing empty queue) or invalid user input (e.g., non-numeric menu choice, empty task description).
 * *   Program terminates when 'Exit' is chosen.
 * 
 * Your solution should consist of the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements a simple command-line task management system, fulfilling all the requirements using the specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents an individual task with a unique `id` and a `description`.
 *     *   Uses a static `nextId` to automatically assign sequential IDs, ensuring uniqueness.
 *     *   The constructor includes input validation for the `description`, throwing an `IllegalArgumentException` if it's null or empty.
 *     *   Provides public getter methods (`getId`, `getDescription`) for encapsulated data.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the core class managing the task flow.
 *     *   **`Queue<Task> taskQueue`**: Declared as a `Queue` interface type and initialized with `java.util.LinkedList`. `LinkedList` is a common implementation of `Queue` and supports FIFO operations efficiently. Tasks waiting to be processed are stored here.
 *     *   **`List<Task> completedTasks`**: Declared as a `List` interface type and initialized with `java.util.ArrayList`. `ArrayList` is suitable for storing completed tasks where indexed access or simple iteration is needed.
 *     *   **`Scanner scanner`**: Used to read input from `System.in`. It's initialized in the constructor and closed when the application exits.
 *     *   **`addTask(String description)`**: Creates a new `Task` object. It wraps the `Task` constructor call in a `try-catch` block to handle the `IllegalArgumentException` if the description is invalid, printing the error to `System.err`. Valid tasks are added to the `taskQueue` using `offer()`.
 *     *   **`processNextTask()`**: Implements the FIFO processing logic. It first checks if the `taskQueue` is empty. If so, it prints an error to `System.err`. Otherwise, it uses `poll()` to remove and retrieve the task at the head of the queue and adds it to the `completedTasks` list using `add()`.
 *     *   **`viewQueue()`**: Iterates through the `taskQueue` using an enhanced for loop (which doesn't remove elements) and prints each task to `System.out`. Handles the case where the queue is empty.
 *     *   **`viewCompletedTasks()`**: Iterates through the `completedTasks` list using a standard for loop with indexed access (`get()`) and prints each completed task to `System.out`. Handles the case where the list is empty.
 *     *   **`displayMenu()`**: A private helper method to print the menu options to `System.out`.
 *     *   **`run()`**: This method contains the main application loop.
 *         *   It repeatedly displays the menu and reads the user's integer choice using `scanner.nextInt()`.
 *         *   `scanner.nextLine()` is crucial after `nextInt()` to consume the remaining newline character, preventing issues with subsequent `nextLine()` calls.
 *         *   A `switch` statement is used to direct the program flow based on the user's `choice`. Each case calls the appropriate method (`addTask`, `processNextTask`, etc.).
 *         *   The `default` case in the `switch` handles invalid integer choices by printing an error to `System.err`.
 *         *   **Class-wide exception handling:** The entire `while` loop body (which includes reading input and executing actions) is wrapped in a `try-catch` block.
 *             *   `catch (InputMismatchException e)` specifically catches errors when the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *             *   `catch (Exception e)` acts as a general catch-all for any other unexpected runtime exceptions that might occur within the loop, printing an error to `System.err`. This demonstrates a broader exception handling strategy within the class's main execution flow.
 * 
 * 3.  **`Main` Class:**
 *     *   Contains the standard `main` method, which is the entry point of the application.
 *     *   It simply creates an instance of `TaskManager` and calls its `run()` method to start the application loop.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Private fields (`id`, `description`, `taskQueue`, `completedTasks`, `scanner`) are accessed only through public methods.
 * *   **Meaningful Names:** Classes (`Task`, `TaskManager`), variables (`taskQueue`, `completedTasks`, `description`, `choice`), and methods (`addTask`, `processNextTask`, `viewQueue`, `run`) have descriptive names.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes, methods, and key parameters. Inline comments clarify specific code logic (like consuming the newline).
 * *   **Input Validation:** The `Task` constructor validates the description. The `TaskManager.run()` method handles invalid menu input type and range.
 * *   **Error Handling:** Specific error conditions (empty queue, empty description) are checked and reported to `System.err`. General `try-catch` blocks handle unexpected exceptions during user interaction.
 * *   **Clean Structure:** The code is organized into logical classes with single responsibilities (`Task` for data, `TaskManager` for logic and interaction, `Main` for starting the application).
 * 
 * This solution effectively uses all required components in a practical scenario, demonstrating understanding of collections, basic I/O, control flow, object-oriented principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // A common implementation of List
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation for task description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description.trim(); // Trim whitespace
    }

    /**
     * Gets the unique ID of the task.
     *
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return Formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task #" + id + ": " + description;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 * Handles user interaction via the console.
 */
public class TaskManager {

    // Use Queue for tasks waiting processing (FIFO)
    private Queue<Task> taskQueue;
    // Use List (ArrayList) for tasks that have been completed
    private List<Task> completedTasks;
    // Use Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing collections and scanner.
     */
    public TaskManager() {
        taskQueue = new LinkedList<>(); // LinkedList implements Queue
        completedTasks = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the end of the processing queue.
     *
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description); // Task constructor validates description
            taskQueue.offer(newTask); // Use offer() for queue, returns false on failure (rare with LinkedList)
            System.out.println(System.lineSeparator() + "Successfully added: " + newTask + System.lineSeparator());
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor
            System.err.println(System.lineSeparator() + "Error adding task: " + e.getMessage() + System.lineSeparator());
        }
    }

    /**
     * Processes the next task from the front of the queue,
     * moving it to the completed tasks list.
     */
    public void processNextTask() {
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.err.println(System.lineSeparator() + "Error: Task queue is empty. No tasks to process." + System.lineSeparator());
            return; // Exit method if nothing to process
        }

        Task processedTask = taskQueue.poll(); // Remove task from the front of the queue
        completedTasks.add(processedTask); // Add task to the completed list
        System.out.println(System.lineSeparator() + "Successfully processed: " + processedTask + System.lineSeparator());
    }

    /**
     * Displays all tasks currently in the processing queue, in order.
     */
    public void viewQueue() {
        if (taskQueue.isEmpty()) {
            System.out.println(System.lineSeparator() + "The task queue is currently empty." + System.lineSeparator());
            return;
        }

        System.out.println(System.lineSeparator() + "--- Current Task Queue ---");
        int index = 1;
        // Iterate through the queue without removing elements
        for (Task task : taskQueue) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("--------------------------" + System.lineSeparator());
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println(System.lineSeparator() + "No tasks have been completed yet." + System.lineSeparator());
            return;
        }

        System.out.println(System.lineSeparator() + "--- Completed Tasks ---");
        // Iterate through the list
        for (int i = 0; i < completedTasks.size(); i++) {
            System.out.println((i + 1) + ". " + completedTasks.get(i));
        }
        System.out.println("-----------------------" + System.lineSeparator());
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and task operations.
     * Includes class-wide exception handling for input and general errors.
     */
    public void run() {
        boolean running = true;
        // Main application loop
        while (running) {
            displayMenu();
            try {
                // Read user's integer choice
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description); // Call method to add task
                        break;
                    case 2:
                        processNextTask(); // Call method to process task
                        break;
                    case 3:
                        viewQueue(); // Call method to view queue
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println(System.lineSeparator() + "Exiting Task Management System. Goodbye!" + System.lineSeparator());
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println(System.lineSeparator() + "Invalid choice. Please enter a number between 1 and 5." + System.lineSeparator());
                        break;
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling: Catch non-integer input for menu choice
                System.err.println(System.lineSeparator() + "Invalid input. Please enter a number corresponding to the menu options." + System.lineSeparator());
                scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
            } catch (Exception e) {
                // Class-wide exception handling: Catch any other unexpected runtime errors
                System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage() + System.lineSeparator());
                // Depending on the application, you might log the error or try to recover
            }
        }
        scanner.close(); // Close the scanner resource when the application exits
    }

    /**
     * Main method to start the Task Management System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
