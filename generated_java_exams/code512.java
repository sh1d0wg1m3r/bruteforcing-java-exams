/*
 * Exam Question #512
 * Generated on: 2025-05-11 23:22:28
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Management System. The system needs to manage appointments, allowing staff to schedule new ones, process patients from a waiting list, and view scheduled appointments.
 * 
 * The system should operate via a command-line interface, presenting a menu of options to the user.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a **waiting list** of appointments to be processed using a `java.util.Queue`. When a new appointment is scheduled, it should be added to this queue.
 *     *   Maintain a **record of all scheduled appointments** (processed or waiting) using a `java.util.ArrayList`.
 *     *   Use the `java.util.List` interface type where appropriate (e.g., when returning the list of appointments).
 * 
 * 2.  **Functionality:**
 *     *   **Schedule Appointment:** Prompt the user for patient name, doctor, and appointment time. Create an `Appointment` object and add it to both the waiting queue and the list of all appointments.
 *     *   **Process Next Appointment:** Remove the appointment at the front of the waiting queue. Indicate which appointment was processed. If the queue is empty, report an error.
 *     *   **View All Appointments:** Display all appointments currently in the system (from the `ArrayList`). Indicate their status (e.g., "Waiting" if still in the queue, "Processed" otherwise - *Hint: You'll need a way to track status or check queue presence, or simply assume items removed from the queue are processed*). For simplicity, you can just list all appointments from the ArrayList.
 *     *   **View Next Appointment:** Display the appointment at the front of the waiting queue *without* removing it. If the queue is empty, report an error.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu with numbered options for each function (Schedule, Process, View All, View Next, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, and lists of appointments.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, trying to process/view next when the queue is empty, invalid input during scheduling).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues, such as invalid input format when reading the menu choice.
 * 
 * 5.  **Best Practices:**
 *     *   Create a separate class for the `Appointment` object with private fields and public getters.
 *     *   Create a separate class (`HospitalScheduler`) to encapsulate the data structures (`Queue`, `List`) and the core scheduling logic.
 *     *   Use meaningful variable and method names.
 *     *   Include basic input validation (e.g., checking if required scheduling fields are empty).
 *     *   Add comments/documentation where necessary.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example flow:
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Schedule Appointment
 * 2. Process Next Appointment
 * 3. View All Appointments
 * 4. View Next Appointment
 * 0. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter doctor: Dr. Smith
 * Enter time (e.g., 10:00 AM): 10:00 AM
 * Appointment scheduled for Alice with Dr. Smith at 10:00 AM.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter patient name: Bob
 * Enter doctor: Dr. Jones
 * Enter time (e.g., 10:30 AM): 10:30 AM
 * Appointment scheduled for Bob with Dr. Jones at 10:30 AM.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * Next appointment in queue: Patient: Alice, Doctor: Dr. Smith, Time: 10:00 AM
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- All Scheduled Appointments ---
 * Patient: Alice, Doctor: Dr. Smith, Time: 10:00 AM
 * Patient: Bob, Doctor: Dr. Jones, Time: 10:30 AM
 * ------------------------------------
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing appointment for Alice with Dr. Smith at 10:00 AM.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * Next appointment in queue: Patient: Bob, Doctor: Dr. Jones, Time: 10:30 AM
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing appointment for Bob with Dr. Jones at 10:30 AM.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * System.err: Waiting queue is empty. Cannot process appointment.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 5
 * System.err: Invalid choice. Please enter a number from the menu.
 * 
 * --- Hospital Appointment System ---
 * ... (menu repeats)
 * Enter your choice: 0
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, error handling).
 * *   Code structure and readability.
 * 
 * You must provide the complete, runnable Java code.
 *
 * EXPLANATION:
 * The solution implements a basic Hospital Appointment Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Appointment` Class:** This simple class encapsulates the data for an appointment (patient name, doctor, time) and includes a flag (`isProcessed`) to track its status. It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`HospitalScheduler` Class:** This class acts as the core logic handler.
 *     *   It holds two private data structures: a `Queue<Appointment>` named `waitingQueue` (implemented using `LinkedList`) and a `List<Appointment>` named `allAppointments` (implemented using `ArrayList`).
 *     *   `waitingQueue` is used to manage the order in which appointments are processed (FIFO - First-In, First-Out).
 *     *   `allAppointments` stores a record of every appointment ever scheduled, regardless of whether it's been processed from the queue.
 *     *   Methods like `scheduleAppointment`, `processNextAppointment`, `viewNextAppointment`, and `viewAllAppointments` encapsulate the operations on these data structures, hiding the implementation details from the main application logic.
 *     *   `scheduleAppointment` adds the new appointment to both the `allAppointments` list and the `waitingQueue`. It includes basic input validation and uses `queue.offer()`, which is the standard way to add to a queue.
 *     *   `processNextAppointment` uses `queue.poll()` to remove and return the head of the queue. It returns `null` if the queue is empty, which the calling code checks.
 *     *   `viewNextAppointment` uses `queue.peek()` to view the head of the queue without removing it, also returning `null` if empty.
 *     *   `viewAllAppointments` simply returns the `allAppointments` list. Returning the `List` interface type adheres to good practice.
 * 
 * 3.  **`HospitalSchedulingApp` Class:** This is the main application class containing the `main` method and the user interface logic.
 *     *   It instantiates `HospitalScheduler` and `Scanner`.
 *     *   The `run()` method contains the main application loop, which continues until the user chooses to exit (option 0).
 *     *   A `displayMenu()` method prints the available options using `System.out`.
 *     *   The user's choice is read using `scanner.nextInt()`. A crucial detail here is to consume the remaining newline character using `scanner.nextLine()` after reading the integer to prevent issues with subsequent `scanner.nextLine()` calls.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer input, calling the appropriate private helper methods (`scheduleAppointment`, `processNextAppointment`, etc.).
 *     *   The `default` case in the `switch` handles invalid menu numbers, printing an error to `System.err`.
 *     *   **Exception Handling:**
 *         *   An inner `try-catch` block around reading the menu choice specifically catches `InputMismatchException`, which occurs if the user enters non-integer input. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A large, outer `try-catch` block wraps the entire `while` loop in the `run()` method. This provides class-wide exception handling as requested. It catches any `Exception` that might occur during the program's execution (beyond the handled `InputMismatchException`). It prints a general error message and the stack trace to `System.err`, fulfilling the requirement to use `System.err` for errors and providing robust handling for unexpected issues.
 *         *   A `finally` block ensures that the `Scanner` object is closed properly when the `run` method finishes, whether normally or due to an exception, preventing resource leaks.
 *     *   Helper methods (`scheduleAppointment`, `processNextAppointment`, etc.) interact with the `HospitalScheduler` and handle user input/output for their specific tasks. They print normal messages to `System.out` and specific operational errors (like queue empty) to `System.err`.
 * 
 * This structure effectively separates data management logic (`HospitalScheduler`) from user interface logic (`HospitalSchedulingApp`) and demonstrates the required components in a practical context with appropriate error handling and best practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single appointment
class Appointment {
    private String patientName;
    private String doctor;
    private String time;
    private boolean isProcessed; // Simple status flag

    public Appointment(String patientName, String doctor, String time) {
        this.patientName = patientName;
        this.doctor = doctor;
        this.time = time;
        this.isProcessed = false; // Initially not processed
    }

    public String getPatientName() {
        return patientName;
    }

    public String getDoctor() {
        return doctor;
    }

    public String getTime() {
        return time;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    public void setProcessed(boolean processed) {
        isProcessed = processed;
    }

    @Override
    public String toString() {
        return "Patient: " + patientName + ", Doctor: " + doctor + ", Time: " + time;
    }
}

// Manages the appointment scheduling logic and data structures
class HospitalScheduler {
    // Queue for appointments waiting to be processed
    private Queue<Appointment> waitingQueue;
    // List of all scheduled appointments
    private List<Appointment> allAppointments;

    public HospitalScheduler() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allAppointments = new ArrayList<>();
    }

    /**
     * Schedules a new appointment.
     * Adds the appointment to the list of all appointments and the waiting queue.
     * @param patientName The name of the patient.
     * @param doctor The doctor for the appointment.
     * @param time The scheduled time.
     * @return The scheduled Appointment object, or null if input is invalid.
     */
    public Appointment scheduleAppointment(String patientName, String doctor, String time) {
        if (patientName == null || patientName.trim().isEmpty() ||
            doctor == null || doctor.trim().isEmpty() ||
            time == null || time.trim().isEmpty()) {
            System.err.println("Error: Patient name, doctor, and time cannot be empty.");
            return null;
        }

        Appointment newAppointment = new Appointment(patientName.trim(), doctor.trim(), time.trim());
        allAppointments.add(newAppointment);
        waitingQueue.offer(newAppointment); // offer() is preferred over add() for queues (returns false on failure)
        return newAppointment;
    }

    /**
     * Processes the next appointment in the waiting queue.
     * Removes the appointment from the queue and updates its status.
     * @return The processed Appointment object, or null if the queue is empty.
     */
    public Appointment processNextAppointment() {
        if (waitingQueue.isEmpty()) {
            return null; // Indicate queue is empty
        }
        Appointment nextAppointment = waitingQueue.poll(); // poll() removes and returns head, or null if empty
        if (nextAppointment != null) {
            nextAppointment.setProcessed(true); // Mark as processed (optional, but good for status tracking)
        }
        return nextAppointment;
    }

    /**
     * Gets the next appointment in the waiting queue without removing it.
     * @return The next Appointment object, or null if the queue is empty.
     */
    public Appointment viewNextAppointment() {
        return waitingQueue.peek(); // peek() returns head without removing, or null if empty
    }

    /**
     * Gets the list of all scheduled appointments.
     * @return A List containing all appointments.
     */
    public List<Appointment> viewAllAppointments() {
        return allAppointments; // Return the reference to the list
    }

    /**
     * Checks if the waiting queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isWaitingQueueEmpty() {
        return waitingQueue.isEmpty();
    }

    /**
     * Checks if the total appointments list is empty.
     * @return true if the list is empty, false otherwise.
     */
    public boolean isAllAppointmentsEmpty() {
        return allAppointments.isEmpty();
    }
}

// Main application class with the user interface
public class HospitalSchedulingApp {

    private HospitalScheduler scheduler;
    private Scanner scanner;

    public HospitalSchedulingApp() {
        scheduler = new HospitalScheduler();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. Process Next Appointment");
        System.out.println("3. View All Appointments");
        System.out.println("4. View Next Appointment");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide try-catch for general error handling.
     */
    public void run() {
        int choice = -1;
        // Class-wide try-catch block for general exceptions during execution
        try {
            while (choice != 0) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            scheduleAppointment();
                            break;
                        case 2:
                            processNextAppointment();
                            break;
                        case 3:
                            viewAllAppointments();
                            break;
                        case 4:
                            viewNextAppointment();
                            break;
                        case 0:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number from the menu.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Handles the scheduling appointment user interaction.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine();
        System.out.print("Enter doctor: ");
        String doctor = scanner.nextLine();
        System.out.print("Enter time (e.g., 10:00 AM): ");
        String time = scanner.nextLine();

        Appointment scheduled = scheduler.scheduleAppointment(patientName, doctor, time);
        if (scheduled != null) {
            System.out.println("Appointment scheduled for " + scheduled.getPatientName() +
                               " with " + scheduled.getDoctor() + " at " + scheduled.getTime() + ".");
        }
        // Error message is printed by scheduler.scheduleAppointment() if validation fails
    }

    /**
     * Handles the processing next appointment user interaction.
     */
    private void processNextAppointment() {
        Appointment processed = scheduler.processNextAppointment();
        if (processed != null) {
            System.out.println("Processing appointment for " + processed.getPatientName() +
                               " with " + processed.getDoctor() + " at " + processed.getTime() + ".");
        } else {
            System.err.println("Waiting queue is empty. Cannot process appointment.");
        }
    }

    /**
     * Handles the viewing all appointments user interaction.
     */
    private void viewAllAppointments() {
        List<Appointment> all = scheduler.viewAllAppointments();
        if (all.isEmpty()) {
            System.out.println("No appointments have been scheduled yet.");
        } else {
            System.out.println("--- All Scheduled Appointments ---");
            for (Appointment appt : all) {
                // Note: This view doesn't explicitly show 'Waiting' vs 'Processed' status
                // based on queue presence, but lists all appointments.
                // A more complex system could check appt.isProcessed() or search the queue.
                System.out.println(appt);
            }
            System.out.println("------------------------------------");
        }
    }

    /**
     * Handles the viewing next appointment user interaction.
     */
    private void viewNextAppointment() {
        Appointment next = scheduler.viewNextAppointment();
        if (next != null) {
            System.out.println("Next appointment in queue: " + next);
        } else {
            System.err.println("Waiting queue is empty. No appointment to view.");
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalSchedulingApp app = new HospitalSchedulingApp();
        app.run();
    }
}
