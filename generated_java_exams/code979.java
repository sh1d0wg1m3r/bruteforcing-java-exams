/*
 * Exam Question #979
 * Generated on: 2025-05-12 17:08:06
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simple Help Desk Ticket System**
 * 
 * You are required to develop a console-based application simulating a basic Help Desk system. The system should allow users to submit support tickets, and a simplified agent process to handle these tickets in the order they are received. The system must also maintain a history of all tickets that have been processed.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java concepts and adhere to specific technical requirements.
 * 
 * **System Functionality:**
 * 
 * 1.  **Ticket Submission:** Users can submit a new ticket by providing a description and selecting a category from a predefined list.
 * 2.  **Ticket Processing:** An agent can process the next available ticket. This involves taking the oldest ticket from the pending list, marking it as processed, and moving it to a history list.
 * 3.  **View History:** Users can view a list of all tickets that have been processed.
 * 4.  **View Pending:** Users can see how many tickets are currently waiting to be processed.
 * 5.  **Exit:** Users can exit the application.
 * 
 * **Technical Requirements:**
 * 
 * Your Java code must explicitly use and demonstrate the proper application of **ALL** of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the incoming (pending) tickets, ensuring they are processed in a First-In, First-Out (FIFO) manner.
 * *   `java.util.ArrayList`: To store the history of processed tickets.
 * *   `java.util.List` interface: Must be used as the declared type for at least one collection (e.g., the history list or the list of valid categories).
 * *   `java.util.Scanner`: To read user input from the console for menu selections and ticket details.
 * *   `switch` statement: To control the flow of the main application menu based on user input.
 * *   `System.err`: To display error messages (e.g., invalid user input, validation failures, unexpected errors).
 * *   `System.out`: To display normal application output (menu, prompts, success messages, ticket details, history, queue size, exit message).
 * *   Class-wide exception handling with `try-catch` blocks: Implement a `try-catch` structure that wraps the main application logic loop to catch and handle unexpected runtime exceptions gracefully, printing error information to `System.err`. You may also use specific `try-catch` blocks for handling expected exceptions (like input validation errors) and report them using `System.err`.
 * 
 * **Design and Best Practices:**
 * 
 * *   Design appropriate classes (e.g., `Ticket`, `HelpDesk` to manage the collections and logic, and a main application class).
 * *   Employ proper encapsulation (private fields with public getter/setter methods where appropriate).
 * *   Use meaningful variable and method names.
 * *   Include basic comments and documentation (like Javadoc for classes and methods).
 * *   Implement input validation (e.g., ensure ticket description is not empty, validate ticket category against a predefined list).
 * *   Handle scenarios gracefully (e.g., processing a ticket when the queue is empty).
 * *   Ensure clean and readable code structure.
 * 
 * **Predefined Valid Ticket Categories:** "Software", "Hardware", "Network", "Other".
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, accept user input via the console, and display appropriate messages or results to `System.out` for successful operations and `System.err` for errors or invalid actions.
 * 
 * Provide the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided Java code implements a simple console-based Help Desk Ticket System, fulfilling all the requirements of the exam task.
 * 
 * **Overall Structure:**
 * The solution is organized into three classes:
 * 1.  `Ticket`: A simple Plain Old Java Object (POJO) representing a single support ticket with properties like ID, description, category, and status. It demonstrates encapsulation with private fields and public getters/setters.
 * 2.  `HelpDesk`: This class acts as the core manager of the system's state. It holds and manipulates the collections of tickets. It contains the business logic for submitting and processing tickets.
 * 3.  `HelpDeskApp`: This is the main application class containing the `main` method. It handles the user interface, reads input using `Scanner`, displays output, and orchestrates calls to the `HelpDesk` class based on user choices.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `HelpDesk` class uses a `Queue<Ticket>` named `incomingTickets`. Specifically, a `LinkedList` is used as the implementation, which is a common choice for queues in Java. New tickets are added using `offer()`, and the next ticket to be processed is retrieved and removed using `poll()`, ensuring FIFO order.
 * 2.  **`java.util.ArrayList`**: The `HelpDesk` class uses an `ArrayList<Ticket>` named `processedTicketsHistory` to store tickets after they have been processed. This list allows for easy storage and iteration over the history.
 * 3.  **`java.util.List` interface**: The `processedTicketsHistory` is declared using the `List` interface type (`List<Ticket> processedTicketsHistory = new ArrayList<>();`), demonstrating programming to interfaces. The list of `validCategories` is also declared as `List<String>`.
 * 4.  **`java.util.Scanner`**: The `HelpDeskApp` class uses a `Scanner` object to read user input from `System.in` for menu choices and ticket details. `nextLine()` is used consistently to avoid common issues with mixing `nextLine()` with other `Scanner` methods.
 * 5.  **`switch` statement**: The `run()` method in `HelpDeskApp` uses a `switch` statement to handle the different menu options selected by the user, directing the program flow accordingly.
 * 6.  **`System.err`**: `System.err` is used in `HelpDeskApp.run()` to display error messages:
 *     *   For invalid menu choices in the `default` case of the `switch`.
 *     *   Specifically catching `IllegalArgumentException` thrown by `HelpDesk.submitTicket()` to inform the user about validation errors (empty description, invalid category).
 *     *   In the main `catch(Exception e)` block to report any unexpected runtime errors.
 * 7.  **`System.out`**: `System.out` is used for all normal application output: displaying the menu, prompts for input, confirmation messages for successful submissions, details of processed tickets, the ticket history list, the pending queue size, and the exit message.
 * 8.  **Class-wide exception handling with `try-catch`**: The `run()` method in `HelpDeskApp` contains a broad `try { ... } catch (Exception e) { ... }` block wrapping the main `while` loop and the `scanner.close()` call in the `finally` block. This structure ensures that if any unhandled exception occurs during the execution of the main application logic, it is caught, an error message is printed to `System.err`, and the application terminates gracefully after closing the `Scanner`. A more specific `try-catch` is also used around the `helpDesk.submitTicket()` call to handle `IllegalArgumentException` and provide user-friendly feedback on validation errors via `System.err`.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** The `Ticket` and `HelpDesk` classes hide their internal state using `private` fields and expose functionality through `public` methods.
 * *   **Meaningful Names:** Variables (`incomingTickets`, `processedTicketsHistory`, `nextTicketId`, `description`, `category`), methods (`submitTicket`, `processNextTicket`, `viewTicketHistory`, `getIncomingQueueSize`, `isValidCategory`), and classes (`Ticket`, `HelpDesk`, `HelpDeskApp`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and key methods explaining their function, parameters, and return values. Inline comments clarify specific logic where needed.
 * *   **Input Validation:** The `HelpDesk.submitTicket()` method explicitly checks if the description is empty and if the category is one of the predefined valid categories, throwing an `IllegalArgumentException` if validation fails. This exception is caught and reported using `System.err` in the `HelpDeskApp`.
 * *   **Error Handling:** Different types of errors (validation errors, invalid user input, unexpected runtime errors) are handled using appropriate mechanisms (`IllegalArgumentException`, `switch default`, main `try-catch`) and reported using `System.err`.
 * *   **Handling Empty Queue:** The `processNextTicket()` method checks if `incomingTickets.poll()` returns `null` (indicating an empty queue) and prints an informative message to `System.out` instead of throwing an error.
 * *   **Clean Code Structure:** The logic is separated into distinct classes with clear responsibilities. The main application loop is clean, using the `switch` statement to delegate tasks to the `HelpDesk` object. The `finally` block ensures resource cleanup (`scanner.close()`).
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating key object-oriented principles, input/output handling, control flow, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays; // To easily create the list of valid categories

/**
 * Represents a support ticket in the Help Desk system.
 */
class Ticket {
    private int id;
    private String description;
    private String category;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description A brief description of the issue.
     * @param category The category of the ticket (e.g., "Software", "Hardware").
     */
    public Ticket(int id, String description, String category) {
        this.id = id;
        this.description = description;
        this.category = category;
        this.status = "Pending"; // New tickets start as Pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getCategory() {
        return category;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Ticket ID: " + id +
               ", Description: '" + description + '\'' +
               ", Category: '" + category + '\'' +
               ", Status: '" + status + '\'';
    }
}

/**
 * Manages the collection of support tickets.
 */
class HelpDesk {
    private Queue<Ticket> incomingTickets;
    private List<Ticket> processedTicketsHistory;
    private List<String> validCategories;
    private int nextTicketId;

    /**
     * Constructs a new HelpDesk instance.
     * Initializes the ticket queues, history, valid categories, and ticket counter.
     */
    public HelpDesk() {
        // Use LinkedList as a Queue implementation for incoming tickets (FIFO)
        this.incomingTickets = new LinkedList<>();
        // Use ArrayList as a List implementation for history
        this.processedTicketsHistory = new ArrayList<>();
        // Use List interface type for valid categories
        this.validCategories = Arrays.asList("Software", "Hardware", "Network", "Other");
        this.nextTicketId = 1;
    }

    /**
     * Submits a new ticket to the help desk.
     * Adds the ticket to the incoming queue if valid.
     * @param description The description of the ticket.
     * @param category The category of the ticket.
     * @throws IllegalArgumentException if description is empty or category is invalid.
     */
    public void submitTicket(String description, String category) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        if (category == null || !isValidCategory(category)) {
            throw new IllegalArgumentException("Invalid ticket category: " + category + ". Valid categories are: " + validCategories);
        }

        Ticket newTicket = new Ticket(nextTicketId++, description.trim(), category.trim());
        incomingTickets.offer(newTicket); // Add to the end of the queue
        System.out.println("Ticket submitted successfully: ID " + newTicket.getId());
    }

    /**
     * Processes the next pending ticket from the queue.
     * Moves the ticket from the pending queue to the processed history.
     * If the queue is empty, prints a message to System.out.
     */
    public void processNextTicket() {
        Ticket ticketToProcess = incomingTickets.poll(); // Retrieve and remove the head of the queue

        if (ticketToProcess == null) {
            System.out.println("No pending tickets to process.");
        } else {
            ticketToProcess.setStatus("Processed");
            processedTicketsHistory.add(ticketToProcess); // Add to the history list
            System.out.println("Processed Ticket: " + ticketToProcess);
        }
    }

    /**
     * Displays the history of all processed tickets to System.out.
     * If history is empty, prints a message.
     */
    public void viewTicketHistory() {
        if (processedTicketsHistory.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            System.out.println("\n--- Processed Ticket History ---");
            for (Ticket ticket : processedTicketsHistory) {
                System.out.println(ticket);
            }
            System.out.println("--------------------------------");
        }
    }

    /**
     * Gets the number of tickets currently waiting in the incoming queue.
     * @return The size of the incoming ticket queue.
     */
    public int getIncomingQueueSize() {
        return incomingTickets.size();
    }

    /**
     * Checks if a given category is valid.
     * @param category The category to validate.
     * @return true if the category is in the list of valid categories, false otherwise.
     */
    private boolean isValidCategory(String category) {
        return validCategories.contains(category);
    }

    /**
     * Gets the list of valid ticket categories.
     * @return An unmodifiable list of valid categories.
     */
    public List<String> getValidCategories() {
         // Return a copy or unmodifiable list to prevent external modification
         return List.copyOf(validCategories);
    }
}

/**
 * Main application class for the Help Desk Ticket System.
 * Handles user interaction and orchestrates the HelpDesk operations.
 */
public class HelpDeskApp {

    private HelpDesk helpDesk;
    private Scanner scanner;

    /**
     * Constructs a new HelpDeskApp instance.
     */
    public HelpDeskApp() {
        this.helpDesk = new HelpDesk();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Help Desk Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Processed History");
        System.out.println("4. View Pending Queue Size");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling using try-catch.
     */
    public void run() {
        // Class-wide try-catch block for general error handling during the main loop
        try {
            while (true) {
                displayMenu();
                String choice = scanner.nextLine(); // Read user input as a line

                // Use a switch statement for menu navigation
                switch (choice) {
                    case "1":
                        // Submit New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter ticket category " + helpDesk.getValidCategories() + ": ");
                        String category = scanner.nextLine();
                        try {
                            // Call the HelpDesk method, handling potential validation errors
                            helpDesk.submitTicket(description, category);
                        } catch (IllegalArgumentException e) {
                            // Use System.err for validation errors reported by HelpDesk
                            System.err.println("Submission failed: " + e.getMessage());
                        }
                        break;

                    case "2":
                        // Process Next Ticket
                        helpDesk.processNextTicket(); // This method handles empty queue internally
                        break;

                    case "3":
                        // View Processed History
                        helpDesk.viewTicketHistory();
                        break;

                    case "4":
                        // View Pending Queue Size
                        System.out.println("Pending tickets in queue: " + helpDesk.getIncomingQueueSize());
                        break;

                    case "5":
                        // Exit
                        System.out.println("Exiting Help Desk System. Goodbye!");
                        return; // Exit the run method and terminate the application

                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the try block
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure scanner is closed regardless of whether an exception occurred or the loop exited normally
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Optional: Indicate scanner is closed
        }
    }

    /**
     * Main method to start the application.
     * Creates and runs an instance of HelpDeskApp.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HelpDeskApp app = new HelpDeskApp();
        app.run();
    }
}
