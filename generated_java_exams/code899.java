/*
 * Exam Question #899
 * Generated on: 2025-05-12 16:56:49
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Print Job Management System**
 * 
 * **Objective:** Design and implement a console-based Print Job Management System that simulates adding, processing, and tracking print jobs. This task requires demonstrating a strong understanding of core Java data structures, control flow, exception handling, and object-oriented principles.
 * 
 * **Scenario:** You are developing a simple backend system for managing print jobs sent to a network printer. Jobs are added to a queue, processed one by one, and then moved to a history log.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `PrintJob`: A class representing a single print job. It should have:
 *         *   A unique integer `jobId`.
 *         *   A `String` `filename`.
 *         *   A status (e.g., `PENDING`, `COMPLETED`). An `enum` is recommended for status.
 *         *   Private fields with public getter methods.
 *         *   A constructor to initialize `jobId` and `filename`, setting initial status to `PENDING`.
 *     *   `PrintManager`: A class responsible for managing the print jobs. It should have:
 *         *   A `Queue<PrintJob>` to hold jobs waiting to be printed (`pendingJobs`).
 *         *   A `List<PrintJob>` to hold jobs that have been processed (`completedJobs`). Use `ArrayList` as the concrete implementation for the `List`.
 *         *   Private fields for the queue and list.
 *         *   A method `addJob(String filename)`: Creates a new `PrintJob` with a unique ID and adds it to the `pendingJobs` queue. Return the job ID.
 *         *   A method `processNextJob()`: Removes the next job from the `pendingJobs` queue, updates its status to `COMPLETED`, and adds it to the `completedJobs` list. Handle the case where the queue is empty.
 *         *   A method `viewPendingJobs()`: Displays the details (ID, filename, status) of all jobs currently in the `pendingJobs` queue.
 *         *   A method `viewCompletedJobs()`: Displays the details (ID, filename, status) of all jobs in the `completedJobs` list.
 *     *   `PrintSystemApp`: The main class containing the `main` method. This class will handle user interaction via the console.
 * 
 * 2.  **User Interaction (`PrintSystemApp`):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu to the user with the following options:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Pending Jobs
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 3.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: MUST be used for `pendingJobs`.
 *     *   `java.util.ArrayList`: MUST be used as the concrete implementation for `completedJobs`.
 *     *   `java.util.List`: MUST be used as the *type* for the `completedJobs` field in `PrintManager`.
 *     *   `java.util.Scanner`: MUST be used for all user input.
 *     *   `switch` statement: MUST be used for menu navigation.
 *     *   `System.err`: MUST be used for displaying error messages (e.g., invalid input, processing empty queue).
 *     *   `System.out`: MUST be used for displaying normal output (menu, job details, confirmations).
 *     *   Class-wide exception handling with `try-catch`: Implement `try-catch` blocks to handle potential exceptions, particularly around user input (e.g., non-integer input for menu choice) and operations that might fail (e.g., processing an empty queue, though this can also be handled with an `if` check and `System.err`). A general `try-catch` around the main application loop is recommended.
 * 
 * 4.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Input validation (e.g., check if filename is empty, handle non-integer input for menu).
 *     *   Proper error handling using `try-catch` and `System.err`.
 *     *   Clean code structure with separate classes.
 * 
 * **Expected Output:**
 * 
 * *   The program should display the menu clearly.
 * *   Adding a job should confirm the job ID.
 * *   Processing a job should indicate which job was processed or state if the queue was empty.
 * *   Viewing jobs should list them with ID, filename, and status.
 * *   Invalid input or errors should be reported using `System.err`.
 * *   Normal output should use `System.out`.
 * 
 * **Grading Criteria:**
 * 
 * *   Correct implementation of all required Java components.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Effective use of data structures (`Queue`, `List`).
 * *   Robust error handling and input validation.
 * *   Clean, readable code with appropriate comments.
 * *   Correct implementation of the menu and user interaction.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The solution provides a console-based Print Job Management System using the required Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `PrintJobStatus` (enum): Defines the possible states of a print job (`PENDING`, `COMPLETED`), improving code readability and preventing invalid status values.
 *     *   `PrintJob`: Represents a single job with `jobId`, `filename`, and `status`. It includes a static `jobCounter` to ensure unique IDs are generated for each new job. Fields are private, with public getters and a setter for status, demonstrating encapsulation.
 *     *   `PrintManager`: This is the core class for managing the job collection.
 *         *   It uses a `Queue<PrintJob>` (`pendingJobs`), specifically implemented with `LinkedList`, to maintain the order of jobs waiting to be processed (FIFO - First-In, First-Out).
 *         *   It uses a `List<PrintJob>` (`completedJobs`), specifically implemented with `ArrayList`, to store the history of jobs that have finished processing. Using `List` as the field type demonstrates programming to an interface.
 *         *   Methods like `addJob`, `processNextJob`, `viewPendingJobs`, and `viewCompletedJobs` encapsulate the logic for interacting with these collections.
 *     *   `PrintSystemApp`: Contains the `main` method and handles the user interface loop, menu display, input reading, and calling methods on the `PrintManager`.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: Used for `pendingJobs` in `PrintManager`. `add()` is used to enqueue, and `poll()` is used to dequeue and retrieve the next job.
 *     *   `java.util.ArrayList`: Used as the concrete implementation for the `completedJobs` `List`.
 *     *   `java.util.List`: Used as the declared type for the `completedJobs` field in `PrintManager`, promoting flexibility.
 *     *   `java.util.Scanner`: Used in `PrintSystemApp` to read menu choices and filenames from `System.in`.
 *     *   `switch` statement: Used in the `main` method of `PrintSystemApp` to direct execution based on the user's menu choice.
 *     *   `System.err`: Used for displaying error messages, such as invalid menu input, empty filename, or attempting to process a job when the queue is empty.
 *     *   `System.out`: Used for all normal output, including the menu, confirmations, and listing job details.
 *     *   Class-wide exception handling with `try-catch`:
 *         *   A `try-catch` block is wrapped around the main `while` loop in `PrintSystemApp` to catch any unexpected exceptions that might occur during the program's execution.
 *         *   An inner `try-catch` block specifically handles `InputMismatchException` when reading the integer menu choice, preventing the program from crashing if the user enters non-numeric input.
 *         *   A `try-catch` is also used around the `printManager.addJob` call to catch the `IllegalArgumentException` thrown if an empty filename is provided.
 *         *   The `finally` block ensures the `Scanner` resource is closed when the application finishes or encounters an unhandled exception.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `PrintJob` and `PrintManager` are private, accessed via public methods.
 *     *   **Meaningful Names:** Classes, variables, and methods have descriptive names (`PrintJob`, `pendingJobs`, `addJob`, `processNextJob`, etc.).
 *     *   **Comments and Documentation:** Javadoc-style comments are included for classes and methods, explaining their purpose. Inline comments clarify specific code sections.
 *     *   **Input Validation:** The `addJob` method validates the filename, and the input reading loop handles non-integer menu input.
 *     *   **Error Handling:** `try-catch` blocks are used strategically, and `System.err` is used for error output, clearly distinguishing it from normal output.
 *     *   **Clean Code Structure:** The code is divided into logical classes, separating data representation (`PrintJob`), business logic (`PrintManager`), and user interface (`PrintSystemApp`).
 * 
 * This solution effectively demonstrates the required Java concepts within a practical, simulated scenario, providing robust handling for user input and potential errors while adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for job status
enum PrintJobStatus {
    PENDING,
    COMPLETED
}

// Class representing a single print job
class PrintJob {
    private int jobId;
    private String filename;
    private PrintJobStatus status;

    // Static counter for generating unique job IDs
    private static int jobCounter = 0;

    public PrintJob(String filename) {
        // Increment counter and assign as unique ID
        this.jobId = ++jobCounter;
        this.filename = filename;
        this.status = PrintJobStatus.PENDING;
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getFilename() {
        return filename;
    }

    public PrintJobStatus getStatus() {
        return status;
    }

    // Setter for status (used by PrintManager)
    public void setStatus(PrintJobStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Job ID: " + jobId + ", Filename: '" + filename + "', Status: " + status;
    }
}

// Class managing the print jobs
class PrintManager {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs; // Use List interface, implement with ArrayList

    public PrintManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedJobs = new ArrayList<>();
    }

    /**
     * Adds a new print job to the pending queue.
     * @param filename The name of the file to print.
     * @return The ID of the newly added job.
     * @throws IllegalArgumentException if filename is null or empty.
     */
    public int addJob(String filename) {
        if (filename == null || filename.trim().isEmpty()) {
            throw new IllegalArgumentException("Filename cannot be empty.");
        }
        PrintJob newJob = new PrintJob(filename.trim());
        pendingJobs.add(newJob);
        return newJob.getJobId();
    }

    /**
     * Processes the next job in the pending queue.
     * Moves the job from pending to completed status and list.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        PrintJob jobToProcess = pendingJobs.poll();
        if (jobToProcess != null) {
            jobToProcess.setStatus(PrintJobStatus.COMPLETED);
            completedJobs.add(jobToProcess);
            return jobToProcess;
        }
        return null; // Queue was empty
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs currently in the pending queue.");
        } else {
            System.out.println("--- Pending Jobs ---");
            // Iterate through the queue without removing elements
            for (PrintJob job : pendingJobs) {
                System.out.println(job);
            }
            System.out.println("--------------------");
        }
    }

    /**
     * Displays all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            System.out.println("--- Completed Jobs ---");
            // Iterate through the list
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
            System.out.println("----------------------");
        }
    }
}

// Main application class
public class PrintSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintManager printManager = new PrintManager();
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                // Inner try-catch for handling non-integer input
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                // Using switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Print Job
                        System.out.print("Enter filename: ");
                        String filename = scanner.nextLine();
                        try {
                            int jobId = printManager.addJob(filename);
                            System.out.println("Job added successfully. Job ID: " + jobId);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding job: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Job
                        System.out.println("Processing next job...");
                        PrintJob processedJob = printManager.processNextJob();
                        if (processedJob != null) {
                            System.out.println("Processed: " + processedJob);
                        } else {
                            System.err.println("No jobs in the pending queue to process.");
                        }
                        break;

                    case 3: // View Pending Jobs
                        printManager.viewPendingJobs();
                        break;

                    case 4: // View Completed Jobs
                        printManager.viewCompletedJobs();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Displays the main menu options.
     */
    private static void printMenu() {
        System.out.println("--- Print Job Management Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("---------------------------------");
    }
}
