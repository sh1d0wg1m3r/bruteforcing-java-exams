/*
 * Exam Question #1063
 * Generated on: 2025-05-12 17:19:52
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Clinic Appointment System**
 * 
 * You are tasked with developing a simplified system for managing patient appointments at a small hospital clinic. The system needs to handle scheduling new appointments, checking in patients upon arrival, processing patients who are ready to see a doctor, and listing patients in different states.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, input/output, and exception handling.
 * 
 * **System Requirements:**
 * 
 * 1.  **Data Storage:** The system must manage two distinct groups of patients:
 *     *   Patients who have an appointment but have *not yet* checked in.
 *     *   Patients who have checked in and are waiting in a queue to see the doctor.
 * 2.  **Patient Information:** For this system, a patient can be identified simply by their name (assume names are unique enough for this exercise). You should create a `Patient` class to hold this information.
 * 3.  **Functionality:** The system must provide the following operations via a command-line menu:
 *     *   **Schedule Appointment (1):** Add a new patient to the list of scheduled patients.
 *     *   **Check In Patient (2):** Find a patient in the scheduled list by name, remove them from the scheduled list, and add them to the waiting queue.
 *     *   **Process Next Patient (3):** Take the next patient from the waiting queue (FIFO order) and indicate they are now seeing the doctor.
 *     *   **List Scheduled Patients (4):** Display all patients currently in the scheduled list.
 *     *   **List Waiting Patients (5):** Display all patients currently in the waiting queue.
 *     *   **Exit (0):** Terminate the application.
 * 4.  **User Interaction:** Use `java.util.Scanner` to read user commands and patient names from the console.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and patient lists.
 *     *   Use `System.err` to report errors (e.g., patient not found, waiting queue is empty, invalid input).
 * 7.  **Error Handling:** Implement robust error handling:
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly for invalid user input (e.g., entering text when a number is expected). The main application loop should include exception handling.
 *     *   Handle specific scenarios like trying to check in a patient who is not scheduled or trying to process a patient when the waiting queue is empty.
 * 8.  **Best Practices:**
 *     *   Use appropriate Java data structures (`Queue`, `List`, `ArrayList`) as specified.
 *     *   Declare variables using interface types where appropriate (`List` instead of `ArrayList`).
 *     *   Implement proper encapsulation in your classes (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., ensure patient name is not empty).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks
 * 
 * **Expected Output Format:**
 * 
 * *   Menu should be clearly displayed.
 * *   Prompts for input should be clear (e.g., "Enter patient name:").
 * *   Lists should clearly label whether they are "Scheduled Patients" or "Waiting Patients".
 * *   Error messages should be informative and printed to `System.err`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Hospital Clinic System ---
 * 1. Schedule Appointment
 * 2. Check In Patient
 * 3. Process Next Patient
 * 4. List Scheduled Patients
 * 5. List Waiting Patients
 * 0. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Alice scheduled successfully.
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 1
 * Enter patient name: Bob
 * Bob scheduled successfully.
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 4
 * --- Scheduled Patients ---
 * Alice
 * Bob
 * --------------------------
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 2
 * Enter patient name: Alice
 * Alice checked in successfully.
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 4
 * --- Scheduled Patients ---
 * Bob
 * --------------------------
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 5
 * --- Waiting Patients ---
 * Alice
 * --------------------------
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 3
 * Processing patient: Alice
 * Alice is now seeing the doctor.
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 5
 * --- Waiting Patients ---
 * (Queue is empty)
 * --------------------------
 * 
 * --- Hospital Clinic System ---
 * ...
 * Enter your choice: 3
 * Error: No patients in the waiting queue.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simplified Hospital Clinic Appointment System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **`Patient` Class:** A simple class `Patient` is created to encapsulate patient data, specifically their `name`. It follows encapsulation principles with a private field and a public getter. The `toString()` method is overridden for convenient printing. Basic `equals()` and `hashCode()` are included for robustness, although searching is primarily done by name string comparison in this solution.
 * 
 * 2.  **`HospitalAppointmentSystem` Class:** This is the main class that orchestrates the system logic.
 *     *   **Data Structures:**
 *         *   `List<Patient> scheduledPatients`: Declared using the `List` interface and instantiated as an `ArrayList`. `ArrayList` is suitable here because we need to efficiently add patients and potentially remove a specific patient by value/object reference during check-in, which `ArrayList` handles reasonably well.
 *         *   `Queue<Patient> waitingPatients`: Declared using the `Queue` interface and instantiated as a `LinkedList`. `LinkedList` is a common and efficient implementation for a `Queue` as it provides O(1) time complexity for adding to the end (`offer`/`add`) and removing from the beginning (`poll`/`remove`), which matches the FIFO nature of a waiting line.
 *     *   **Encapsulation:** Both lists and the `Scanner` object are declared as private fields within the `HospitalAppointmentSystem` class, restricting direct external access.
 *     *   **Constructor:** The constructor initializes the `ArrayList`, `LinkedList`, and `Scanner`.
 *     *   **`run()` Method:** This method contains the main application loop.
 *         *   It repeatedly displays the menu and prompts the user for input.
 *         *   It uses a `while` loop that continues until the user chooses option `0` (Exit).
 *         *   **`try-catch` Block:** The entire core logic inside the `while` loop (reading input and executing the `switch`) is wrapped in a `try-catch` block. This provides "class-wide" exception handling for the main operational flow. It specifically catches `InputMismatchException` for handling non-integer input for the menu choice and a general `Exception` for any other unexpected errors. Error messages are printed to `System.err`.
 *         *   **`Scanner` Usage:** `scanner.nextInt()` reads the menu choice, and `scanner.nextLine()` is used immediately after to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls when reading patient names.
 *         *   **`switch` Statement:** The user's valid integer choice is processed using a `switch` statement, directing the flow to the appropriate private method for each operation. The `default` case handles invalid integer inputs within the valid range (0-5).
 *     *   **Operational Methods (`schedulePatient`, `checkInPatient`, `processNextPatient`, `listScheduledPatients`, `listWaitingPatients`):**
 *         *   These are private methods, callable only from within the `HospitalAppointmentSystem` class, adhering to encapsulation.
 *         *   `schedulePatient`: Creates a new `Patient` object and adds it to the `scheduledPatients` `ArrayList`. Includes basic validation for empty names.
 *         *   `checkInPatient`: Iterates through the `scheduledPatients` `List` to find a patient by name (case-insensitive comparison). If found, it removes the patient from `scheduledPatients` and adds them to the `waitingPatients` `Queue`. If not found (or if the name is empty), it prints an error to `System.err`. An optional check is included to see if the patient is already in the waiting queue.
 *         *   `processNextPatient`: Uses `waitingPatients.poll()` to retrieve and remove the patient at the front of the `Queue`. If the queue is empty, `poll()` returns `null`, which is checked to print an error to `System.err`. Otherwise, it prints a success message to `System.out`.
 *         *   `listScheduledPatients`: Iterates through the `scheduledPatients` `List` and prints each patient's name to `System.out`.
 *         *   `listWaitingPatients`: Iterates through the `waitingPatients` `Queue` and prints each patient's name to `System.out`. Iterating with a for-each loop or iterator is appropriate here as we only need to view the elements, not remove them (removal is done by `poll()` in `processNextPatient`).
 *     *   **`closeScanner()` Method:** A private helper method to close the `Scanner` resource, called after the main loop terminates.
 *     *   **`main()` Method:** The entry point of the application. It creates an instance of `HospitalAppointmentSystem`, calls its `run()` method to start the system, and ensures the scanner is closed afterwards.
 * 
 * 3.  **Input Validation and Error Handling:**
 *     *   Empty name checks are performed in `schedulePatient` and `checkInPatient`, printing errors to `System.err`.
 *     *   The `try-catch` in `run()` handles non-integer menu input (`InputMismatchException`) and other potential exceptions, printing to `System.err`.
 *     *   Specific error conditions like "patient not found in scheduled" or "queue is empty" are checked within the respective methods (`checkInPatient`, `processNextPatient`) and reported using `System.err`.
 * 
 * This solution effectively demonstrates the practical use of `List` (`ArrayList`) for managing a dynamic collection where elements might be added or removed by searching, and `Queue` (`LinkedList`) for managing items in a strict FIFO order. It integrates user input via `Scanner`, uses a `switch` for clear control flow, separates output streams (`System.out` vs. `System.err`), and implements essential exception handling and input validation within a well-structured, encapsulated design.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital clinic system.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient with the given name.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a string representation of the patient (their name).
     * @return The patient's name.
     */
    @Override
    public String toString() {
        return name;
    }

    // Basic equals and hashCode based on name for potential future use
    // Not strictly necessary for finding by name string in this specific solution,
    // but good practice if Patient objects were stored and searched directly.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return name.equals(patient.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

/**
 * Manages patient appointments and waiting queue for the clinic.
 */
public class HospitalAppointmentSystem {

    // List to store patients who have scheduled appointments but not yet checked in
    private List<Patient> scheduledPatients;

    // Queue to store patients who have checked in and are waiting to be processed (FIFO)
    private Queue<Patient> waitingPatients;

    private Scanner scanner;

    /**
     * Constructs a new HospitalAppointmentSystem.
     * Initializes the data structures and scanner.
     */
    public HospitalAppointmentSystem() {
        // Use ArrayList for scheduled patients as we might need to remove from anywhere
        this.scheduledPatients = new ArrayList<>();
        // Use LinkedList as a Queue implementation for waiting patients (FIFO)
        this.waitingPatients = new LinkedList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Clinic System ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. Check In Patient");
        System.out.println("3. Process Next Patient");
        System.out.println("4. List Scheduled Patients");
        System.out.println("5. List Waiting Patients");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Schedules a new patient appointment.
     * @param name The name of the patient to schedule.
     */
    private void schedulePatient(String name) {
        // Basic validation
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        // Check if patient is already scheduled or waiting (optional but good practice)
        // For this exam, we'll allow scheduling the same name again, but check-in
        // will only find the first one if duplicates exist in scheduled.
        // If we wanted unique names system-wide, we'd check both lists/queue.

        Patient newPatient = new Patient(name.trim());
        scheduledPatients.add(newPatient);
        System.out.println(newPatient.getName() + " scheduled successfully.");
    }

    /**
     * Checks in a patient who has a scheduled appointment.
     * Finds the patient in the scheduled list, removes them, and adds to the waiting queue.
     * @param name The name of the patient to check in.
     */
    private void checkInPatient(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        String patientName = name.trim();
        Patient foundPatient = null;
        // Find the patient in the scheduled list
        for (Patient patient : scheduledPatients) {
            if (patient.getName().equalsIgnoreCase(patientName)) { // Case-insensitive search for check-in
                foundPatient = patient;
                break; // Assume first match is sufficient
            }
        }

        if (foundPatient != null) {
            scheduledPatients.remove(foundPatient); // Remove from scheduled
            waitingPatients.add(foundPatient);    // Add to waiting queue
            System.out.println(foundPatient.getName() + " checked in successfully.");
        } else {
            // Check if they might already be in the waiting queue (optional check)
            boolean alreadyWaiting = false;
            for(Patient patient : waitingPatients) {
                 if (patient.getName().equalsIgnoreCase(patientName)) {
                     alreadyWaiting = true;
                     break;
                 }
            }
            if (alreadyWaiting) {
                 System.err.println("Error: Patient '" + patientName + "' is already checked in and waiting.");
            } else {
                 System.err.println("Error: Patient '" + patientName + "' not found in scheduled appointments.");
            }
        }
    }

    /**
     * Processes the next patient in the waiting queue.
     * Removes the patient from the queue.
     */
    private void processNextPatient() {
        Patient nextPatient = waitingPatients.poll(); // Retrieves and removes the head of the queue

        if (nextPatient != null) {
            System.out.println("Processing patient: " + nextPatient.getName());
            System.out.println(nextPatient.getName() + " is now seeing the doctor.");
        } else {
            System.err.println("Error: No patients in the waiting queue.");
        }
    }

    /**
     * Lists all patients currently in the scheduled appointments list.
     */
    private void listScheduledPatients() {
        System.out.println("--- Scheduled Patients ---");
        if (scheduledPatients.isEmpty()) {
            System.out.println("(No scheduled patients)");
        } else {
            for (Patient patient : scheduledPatients) {
                System.out.println(patient.getName());
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Lists all patients currently in the waiting queue.
     */
    private void listWaitingPatients() {
        System.out.println("--- Waiting Patients ---");
        if (waitingPatients.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterating over a Queue typically uses an Iterator or for-each loop
            // poll()/peek() modify/view the head. Iteration shows all elements without removing.
            for (Patient patient : waitingPatients) {
                System.out.println(patient.getName());
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     */
    public void run() {
        int choice = -1; // Initialize with a non-menu value

        // Main application loop with class-wide exception handling
        while (choice != 0) {
            displayMenu();
            try {
                choice = scanner.nextInt(); // Read the integer choice
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        System.out.print("Enter patient name: ");
                        String nameToSchedule = scanner.nextLine();
                        schedulePatient(nameToSchedule);
                        break;
                    case 2:
                        System.out.print("Enter patient name to check in: ");
                        String nameToCheckIn = scanner.nextLine();
                        checkInPatient(nameToCheckIn);
                        break;
                    case 3:
                        processNextPatient();
                        break;
                    case 4:
                        listScheduledPatients();
                        break;
                    case 5:
                        listWaitingPatients();
                        break;
                    case 0:
                        System.out.println("Exiting Hospital Clinic System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 0 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to continue the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalAppointmentSystem system = new HospitalAppointmentSystem();
        system.run();
        system.closeScanner(); // Ensure scanner is closed on exit
    }
}
