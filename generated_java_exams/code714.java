/*
 * Exam Question #714
 * Generated on: 2025-05-12 16:29:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment System
 * 
 * **Objective:**
 * 
 * Design and implement a simple console-based application that simulates a basic warehouse order fulfillment process. The system should manage product inventory and process incoming customer orders using appropriate data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a list of products in inventory, each with a unique ID, name, and current quantity.
 *     *   Handle incoming customer orders, each specifying a product ID and quantity requested.
 *     *   Process orders one by one in the order they were received (FIFO).
 *     *   When processing an order:
 *         *   Check if the requested product exists in inventory.
 *         *   Check if there is sufficient stock of the product to fulfill the order.
 *         *   If sufficient stock exists, deduct the quantity from inventory and mark the order as fulfilled.
 *         *   If the product does not exist or stock is insufficient, report the failure.
 * 
 * 2.  **User Interface:**
 *     *   Provide a menu-driven interface for the user to interact with the system.
 *     *   The menu should include options for:
 *         *   Adding a new order.
 *         *   Processing the next pending order.
 *         *   Viewing the current inventory.
 *         *   Viewing the list of pending orders.
 *         *   Exiting the application.
 * 
 * 3.  **Implementation Details:**
 *     *   Use `java.util.Queue` to store incoming orders (pending orders).
 *     *   Use `java.util.ArrayList` to store the product inventory.
 *     *   Declare variables holding the inventory using the `java.util.List` interface type.
 *     *   Use `java.util.Scanner` to read user input for menu choices and order details.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, inventory status, pending orders, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, product not found, insufficient stock, no pending orders).
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around input operations and order processing logic, to gracefully handle potential issues like invalid input format or attempting operations on empty collections.
 *     *   Design appropriate classes (e.g., `Product`, `Order`, `WarehouseManager`) with private fields and public methods following encapsulation principles.
 *     *   Use meaningful variable and method names.
 *     *   Include comments and documentation (e.g., Javadoc) explaining the purpose of classes, methods, and complex logic.
 *     *   Include input validation where necessary (e.g., ensuring quantities are positive numbers, product IDs exist).
 * 
 * **Initial State:**
 * 
 * The system should start with a pre-defined initial inventory of at least 3 different products.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, displaying the menu, accepting user input, performing actions, and printing results or error messages to the console (`System.out` or `System.err`) based on the chosen action.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Warehouse Management Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Inventory
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter Order ID: 101
 * Enter Product ID for order: P001
 * Enter Quantity: 5
 * Order 101 added to pending queue.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 3
 * Current Inventory:
 * Product ID: P001, Name: Laptop, Quantity: 10
 * Product ID: P002, Name: Keyboard, Quantity: 25
 * Product ID: P003, Name: Mouse, Quantity: 50
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing Order 101...
 * Order 101 fulfilled successfully! Inventory updated.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 3
 * Current Inventory:
 * Product ID: P001, Name: Laptop, Quantity: 5
 * Product ID: P002, Name: Keyboard, Quantity: 25
 * Product ID: P003, Name: Mouse, Quantity: 50
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 2
 * No pending orders to process.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Warehouse Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Warehouse Management System.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the application, including all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * The provided solution implements a basic Warehouse Order Fulfillment System demonstrating the required Java concepts and best practices.
 * 
 * **Core Structure:**
 * 
 * 1.  **`Product` Class:** Represents an item in the warehouse with encapsulated `productId`, `name`, and `quantity`. It includes a `decreaseQuantity` method for safe inventory updates and input validation within its setter.
 * 2.  **`Order` Class:** Represents a customer order with `orderId`, `productId` (referencing the product being ordered), and `quantity` requested. It's a simple data holder.
 * 3.  **`WarehouseManager` Class:** This is the central class managing the state and logic.
 *     *   It holds the inventory using a `List<Product>` (specifically an `ArrayList` instance, but typed as `List` for flexibility) and pending orders using a `Queue<Order>` (specifically a `LinkedList` instance, as `LinkedList` implements `Queue`).
 *     *   `addOrder(Order order)`: Adds a new order to the end of the `pendingOrders` queue using `offer()`.
 *     *   `processNextOrder()`: Retrieves and removes the oldest order from the `pendingOrders` queue using `poll()`. It then attempts to find the corresponding product in the `inventory` list and decrease its quantity. Error messages are printed to `System.err` if the product isn't found or stock is insufficient. An `IllegalStateException` is thrown if the queue is empty, which is caught in the main application loop.
 *     *   `viewInventory()`: Iterates through the `inventory` list and prints each product's details using `System.out`.
 *     *   `viewPendingOrders()`: Iterates through the `pendingOrders` queue (without removing elements) and prints each order's details using `System.out`.
 *     *   `findProductById(String productId)`: A helper method to search the inventory list.
 * 4.  **`WarehouseApp` Class:** Contains the `main` method, which is the entry point of the application.
 *     *   Initializes the `WarehouseManager` with some sample products.
 *     *   Sets up a `Scanner` for user input.
 *     *   Enters a `while` loop to keep the application running until the user chooses to exit.
 *     *   Inside the loop:
 *         *   Calls `printMenu()` to display options using `System.out`.
 *         *   Uses a `try-catch` block specifically for reading the menu choice to handle `InputMismatchException` if the user enters non-integer input.
 *         *   Uses a `switch` statement to execute different code blocks based on the user's integer choice.
 *         *   Each case (`1` through `5`) calls the appropriate method on the `WarehouseManager` or sets the `running` flag to `false`.
 *         *   Case `1` (Add Order) includes a nested `try-catch` block to handle `InputMismatchException` during order detail input and validates that IDs and quantities are positive.
 *         *   Case `2` (Process Order) includes a `try-catch` block to specifically catch the `IllegalStateException` thrown by `WarehouseManager.processNextOrder()` when the queue is empty, printing a user-friendly message to `System.out`. It also catches other potential exceptions during processing.
 *         *   The `default` case of the `switch` handles invalid menu choices, printing an error to `System.err`.
 *     *   A large `try-catch` block surrounds the main `while` loop in `main` to catch any unexpected exceptions that might propagate up, printing a critical error message to `System.err` and the stack trace.
 *     *   A `finally` block ensures the `Scanner` is closed when the application exits (either normally or due to an unhandled exception).
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **`Queue`:** Used effectively to model the FIFO nature of incoming orders waiting to be processed. `offer()` for adding and `poll()` for removing/processing are used.
 * *   **`ArrayList` and `List`:** `ArrayList` is used as the concrete implementation for the inventory, stored in a variable typed as the `List` interface, promoting good design practices.
 * *   **`Scanner`:** Used for reading integer and string input from the console.
 * *   **`Switch` statement:** Provides a clean and readable way to handle multiple menu options based on an integer choice.
 * *   **`System.err`:** Used specifically for outputting error conditions (invalid input, processing failures) distinct from normal program output.
 * *   **`System.out`:** Used for all standard output like menus, prompts, status messages, and successful results.
 * *   **`try-catch`:** Implemented at multiple levels:
 *     *   Around individual input operations within the `switch` cases (`InputMismatchException`).
 *     *   Around the `processNextOrder` call to handle the specific `IllegalStateException` (empty queue) and other potential processing errors.
 *     *   A broad `try-catch` around the main application loop in `main` for class-wide handling of unexpected exceptions.
 * *   **Encapsulation:** Achieved by making class fields `private` and providing public methods (`getters`, `setters`, `decreaseQuantity`, etc.) to control access and modification.
 * *   **Meaningful Names:** Classes (`Product`, `Order`, `WarehouseManager`, `WarehouseApp`), methods (`addOrder`, `processNextOrder`, `viewInventory`, `findProductById`), and variables (`inventory`, `pendingOrders`, `orderId`, `quantity`) have descriptive names.
 * *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic points.
 * *   **Input Validation:** Basic validation is performed for order details (positive IDs and quantities) and menu choices.
 * *   **Error Handling:** Specific errors like invalid input format, empty queue, product not found, and insufficient stock are anticipated and handled with informative messages to the user via `System.err` or `System.out`.
 * 
 * This solution provides a solid foundation for a simple system, integrating the required components in a practical scenario while adhering to fundamental Java programming best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product in the warehouse inventory.
 */
class Product {
    private String productId;
    private String name;
    private int quantity;

    /**
     * Constructs a new Product.
     * @param productId The unique ID of the product.
     * @param name The name of the product.
     * @param quantity The initial quantity in stock.
     */
    public Product(String productId, String name, int quantity) {
        this.productId = productId;
        this.name = name;
        this.quantity = quantity;
    }

    // --- Getters ---
    public String getProductId() {
        return productId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    // --- Setters ---
    // Only allow updating quantity
    public void setQuantity(int quantity) {
        if (quantity >= 0) {
            this.quantity = quantity;
        } else {
            // In a real system, might throw an exception or log a warning
            System.err.println("Warning: Attempted to set negative quantity for product " + productId);
            this.quantity = 0; // Or keep the old value
        }
    }

    /**
     * Decreases the product quantity by the specified amount.
     * @param amount The amount to decrease.
     * @return true if successful, false if amount is invalid or results in negative quantity.
     */
    public boolean decreaseQuantity(int amount) {
        if (amount > 0 && this.quantity >= amount) {
            this.quantity -= amount;
            return true;
        }
        return false; // Cannot decrease by non-positive amount or insufficient stock
    }

    @Override
    public String toString() {
        return "Product ID: " + productId + ", Name: " + name + ", Quantity: " + quantity;
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private int orderId;
    private String productId;
    private int quantity;

    /**
     * Constructs a new Order.
     * @param orderId The unique ID of the order.
     * @param productId The ID of the product requested.
     * @param quantity The quantity of the product requested.
     */
    public Order(int orderId, String productId, int quantity) {
        this.orderId = orderId;
        this.productId = productId;
        this.quantity = quantity;
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public String getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Product ID: " + productId + ", Quantity: " + quantity;
    }
}

/**
 * Manages the warehouse inventory and order processing.
 */
class WarehouseManager {
    // Use List interface type for inventory, implemented by ArrayList
    private List<Product> inventory;
    // Use Queue interface type for pending orders, implemented by LinkedList
    private Queue<Order> pendingOrders;

    /**
     * Constructs a new WarehouseManager with initial inventory.
     * @param initialInventory A list of products to start with.
     */
    public WarehouseManager(List<Product> initialInventory) {
        this.inventory = new ArrayList<>(initialInventory); // Copy to ensure internal list is managed here
        this.pendingOrders = new LinkedList<>();
    }

    /**
     * Finds a product in the inventory by its ID.
     * @param productId The ID of the product to find.
     * @return The Product object if found, null otherwise.
     */
    private Product findProductById(String productId) {
        for (Product product : inventory) {
            if (product.getProductId().equalsIgnoreCase(productId)) {
                return product;
            }
        }
        return null; // Product not found
    }

    /**
     * Adds a new order to the pending queue.
     * @param order The order to add.
     */
    public void addOrder(Order order) {
        if (order != null) {
            pendingOrders.offer(order); // offer is preferred over add for capacity-constrained queues, though LinkedList is not
            System.out.println("Order " + order.getOrderId() + " added to pending queue.");
        }
    }

    /**
     * Processes the next order from the pending queue.
     * Attempts to fulfill the order from inventory.
     * @throws IllegalStateException if there are no pending orders.
     */
    public void processNextOrder() {
        if (pendingOrders.isEmpty()) {
            throw new IllegalStateException("No pending orders to process.");
        }

        // poll() retrieves and removes the head of the queue
        Order currentOrder = pendingOrders.poll();
        System.out.println("Processing Order " + currentOrder.getOrderId() + "...");

        Product productToFulfill = findProductById(currentOrder.getProductId());

        if (productToFulfill == null) {
            System.err.println("Error processing order " + currentOrder.getOrderId() + ": Product with ID " + currentOrder.getProductId() + " not found in inventory.");
            // In a real system, you might re-queue, log, or mark as failed
        } else {
            if (productToFulfill.decreaseQuantity(currentOrder.getQuantity())) {
                System.out.println("Order " + currentOrder.getOrderId() + " fulfilled successfully! Inventory updated.");
            } else {
                System.err.println("Error processing order " + currentOrder.getOrderId() + ": Insufficient stock for product " + productToFulfill.getName() + " (ID: " + productToFulfill.getProductId() + "). Requested: " + currentOrder.getQuantity() + ", Available: " + productToFulfill.getQuantity() + ".");
                // In a real system, you might re-queue, partially fulfill, or mark as failed
            }
        }
    }

    /**
     * Displays the current inventory.
     */
    public void viewInventory() {
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
            return;
        }
        System.out.println("Current Inventory:");
        for (Product product : inventory) {
            System.out.println(product);
        }
    }

    /**
     * Displays the list of pending orders.
     */
    public void viewPendingOrders() {
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
            return;
        }
        System.out.println("Pending Orders:");
        // Iterate without removing using a for-each loop or iterator
        for (Order order : pendingOrders) {
            System.out.println(order);
        }
    }
}

/**
 * Main application class for the Warehouse Order Fulfillment System.
 * Handles user interaction and menu logic.
 */
public class WarehouseApp {

    public static void main(String[] args) {
        // Setup initial inventory
        List<Product> initialInventory = new ArrayList<>();
        initialInventory.add(new Product("P001", "Laptop", 10));
        initialInventory.add(new Product("P002", "Keyboard", 25));
        initialInventory.add(new Product("P003", "Mouse", 50));

        WarehouseManager manager = new WarehouseManager(initialInventory);
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide try-catch block for main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                }

                // Use switch statement for menu handling
                switch (choice) {
                    case 1: // Add New Order
                        try {
                            System.out.print("Enter Order ID: ");
                            int orderId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            System.out.print("Enter Product ID for order: ");
                            String productId = scanner.nextLine();
                            System.out.print("Enter Quantity: ");
                            int quantity = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            if (orderId <= 0 || quantity <= 0) {
                                System.err.println("Error: Order ID and Quantity must be positive numbers.");
                            } else {
                                Order newOrder = new Order(orderId, productId, quantity);
                                manager.addOrder(newOrder);
                            }
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input format for order details. Please enter numbers for ID and quantity.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (Exception e) {
                             System.err.println("An unexpected error occurred while adding order: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Order
                        try {
                            manager.processNextOrder();
                        } catch (IllegalStateException e) {
                            // Specific catch for the case where queue is empty
                            System.out.println(e.getMessage()); // Use System.out for this specific non-critical case message
                        } catch (Exception e) {
                             System.err.println("An unexpected error occurred while processing order: " + e.getMessage());
                        }
                        break;

                    case 3: // View Inventory
                        manager.viewInventory();
                        break;

                    case 4: // View Pending Orders
                        manager.viewPendingOrders();
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Warehouse Management System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unhandled exceptions during the main loop
            System.err.println("A critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Warehouse Management Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Inventory");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
    }
}
