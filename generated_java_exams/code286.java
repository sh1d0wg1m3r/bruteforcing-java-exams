/*
 * Exam Question #286
 * Generated on: 2025-05-11 22:49:48
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Production Line Management System**
 * 
 * You are tasked with developing a simplified system to manage orders on a production line. The system needs to handle incoming orders, queue them for processing, simulate processing on available machines, and track completed orders.
 * 
 * Your solution must demonstrate proficiency in core Java concepts, including data structures, control flow, exception handling, and object-oriented programming principles.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold incoming orders waiting for processing.
 *     *   Use a `java.util.ArrayList` to store orders that have been successfully processed.
 *     *   Use the `java.util.List` interface as the type for variables or method return types where appropriate (e.g., when referring to the completed orders list).
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and order details from standard input.
 *     *   Present a menu of options to the user.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands selected from the menu.
 * 
 * 4.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, prompts, processing success messages, and the contents of the queue and completed orders list.
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, attempting to process when no machines are free or queue is empty, invalid order data).
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input operations and potentially risky business logic calls, to gracefully handle errors like invalid input format.
 *     *   Validate user input (e.g., ensuring numerical input is valid, order details are not empty/invalid).
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create a class `Order` to represent a production order (e.g., with fields for `orderId`, `productName`, `quantity`).
 *     *   Create a class `ProductionLineManager` that encapsulates the system's state and logic (the order queue, completed orders list, machine status).
 *     *   Use private fields and public methods (`addOrder`, `processNextOrder`, `viewQueue`, `viewCompleted`, `viewMachineStatus`) within `ProductionLineManager` to adhere to encapsulation principles.
 * 
 * 7.  **Functionality:**
 *     *   **Add Order:** Allow the user to add a new order to the waiting queue. Validate the input for the order details.
 *     *   **Process Next Order:** Simulate processing the next order from the queue. This should only happen if there is at least one free machine AND the queue is not empty. If successful, remove the order from the queue, mark a machine as busy (for simplicity, you don't need to track which specific machine, just the count/status of busy machines), and add the order to the completed list. If processing fails (no free machine or empty queue), print an error.
 *     *   **View Queue:** Display the current orders waiting in the queue.
 *     *   **View Completed:** Display the list of orders that have been processed.
 *     *   **View Machine Status:** Display how many production machines are currently busy and how many are free. Assume a fixed number of machines (e.g., 3).
 *     *   **Exit:** Terminate the program.
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts of the code.
 *     *   Ensure code is well-formatted and readable.
 * 
 * **Assumptions:**
 * 
 * *   There are a fixed number of production machines (e.g., 3).
 * *   Processing an order takes no simulated time; it's an instantaneous move from queue to completed if resources are available.
 * *   A machine becomes free immediately after processing an order (simplification). In a real system, machines would be busy for a duration. For this exam, a machine is "busy" only during the conceptual "processNextOrder" step and becomes "free" again implicitly before the *next* `processNextOrder` call could potentially use it. A simpler way to track is just the *count* of available machines. Let's track the number of *currently available* machines. Processing uses one, and it's immediately available again for the *next* process call if there's another order and machine capacity. This simplifies the "busy" state to just checking if `availableMachines > 0`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and react to user input.
 * *   Adding an order: Confirm success or print validation error to `System.err`.
 * *   Processing: Confirm success (moving order X to completed) or print error to `System.err` (e.g., "No free machines" or "Queue is empty").
 * *   Viewing Queue/Completed: Print the contents clearly.
 * *   Viewing Machine Status: Print the number of available machines (e.g., "Available Machines: 3/3").
 * *   Invalid menu choice or input: Print an error to `System.err` and re-display the menu.
 * 
 * ---
 * *This task requires careful integration of different Java features. Plan your class structure and data flow before coding.*
 *
 * EXPLANATION:
 * This solution implements a simplified Production Line Management System as requested, demonstrating the required Java concepts.
 * 
 * 1.  **`Order` Class:** A simple Plain Old Java Object (POJO) class is created to encapsulate the data for a production order (`orderId`, `productName`, `quantity`). Basic validation is included in the constructor, throwing `IllegalArgumentException` for invalid data. Getters provide controlled access to the private fields, and `toString()` provides a convenient string representation.
 * 
 * 2.  **`ProductionLineManager` Class:** This class is the core of the system, managing the state and logic.
 *     *   **Encapsulation:** It uses private fields: `orderQueue` (a `Queue`), `completedOrders` (a `List`), `totalMachines`, and `availableMachines`.
 *     *   **Data Structures:**
 *         *   `orderQueue`: Implemented using `java.util.LinkedList`, which is a common `Queue` implementation suitable here as we need FIFO (First-In, First-Out) behavior for orders. `offer()` is used for adding orders, and `poll()` is used for retrieving and removing the next order.
 *         *   `completedOrders`: Implemented using `java.util.ArrayList`, suitable for storing completed orders in a list where order of completion is maintained and can be easily iterated. The `List` interface is used as the return type for `viewCompleted()` and locally in `ProductionLineApp` when receiving the queue view (`viewQueue()`).
 *     *   **Constructor:** Initializes the data structures and sets the total and initially available machines. It includes validation for the number of machines.
 *     *   **`addOrder(Order order)`:** Adds a valid `Order` object to the `orderQueue` using `offer()`. Returns `false` if the input order is null.
 *     *   **`processNextOrder()`:** Implements the core processing logic.
 *         *   It first checks if the `orderQueue` is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns `null`.
 *         *   It then checks if `availableMachines` is greater than 0. In this simplified model, `availableMachines` is decremented right before processing and incremented right after, meaning it will always equal `totalMachines` between calls. The check effectively ensures `totalMachines > 0`. An error is printed to `System.err` if no machines are available (though this specific error path is hard to hit with the instant processing model).
 *         *   If both conditions pass, it retrieves and removes the next order from the queue using `poll()`.
 *         *   It decrements `availableMachines` (conceptually using a machine).
 *         *   The processed order is added to the `completedOrders` `ArrayList`.
 *         *   It increments `availableMachines` back (machine is instantly free).
 *         *   The successfully processed `Order` is returned.
 *     *   **`viewQueue()`:** Returns a *new* `ArrayList` populated with the elements from the `orderQueue`. This provides a snapshot of the queue without exposing the internal `Queue` object itself, preventing external code from modifying the queue's structure directly (a good practice, though returning the raw list for completed orders is accepted for simplicity here). The return type is `List<Order>`.
 *     *   **`viewCompleted()`:** Returns the `completedOrders` `ArrayList`. The return type is `List<Order>`.
 *     *   **`viewMachineStatus()`:** Returns a string indicating the number of available machines out of the total. Due to the instantaneous processing model, this will always show `totalMachines / totalMachines` unless the total is 0.
 * 
 * 3.  **`ProductionLineApp` Class (`main` method):**
 *     *   This class contains the `main` method, serving as the application's entry point and handling user interaction.
 *     *   **`Scanner`:** A `Scanner` object is created to read input from `System.in`.
 *     *   **`ProductionLineManager` Initialization:** An instance of `ProductionLineManager` is created with a fixed number of machines (`NUM_MACHINES`). A `try-catch` block handles potential `IllegalArgumentException` during initialization.
 *     *   **Main Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **Menu:** The `printMenu()` method displays the available options.
 *     *   **User Input & `switch`:** The program prompts the user for input, reads the integer choice using `scanner.nextInt()`, and consumes the leftover newline with `scanner.nextLine()`. A `switch` statement directs the flow based on the user's choice.
 *     *   **Case Handling:** Each `case` corresponds to a menu option, calling the appropriate method on the `manager` object.
 *         *   Case 1 (`Add Order`): Prompts for order details, reads them using `scanner.nextLine()` and `scanner.nextInt()`. It uses a nested `try-catch` block to handle potential `InputMismatchException` if the quantity is not a valid integer, and `IllegalArgumentException` if the `Order` constructor validation fails. Error messages are printed to `System.err`.
 *         *   Case 2 (`Process Order`): Calls `manager.processNextOrder()`. Success is reported via `System.out`, while errors (empty queue, no machines) are handled and printed to `System.err` within the `processNextOrder` method itself.
 *         *   Case 3 (`View Queue`): Calls `manager.viewQueue()`, which returns a `List`. It iterates through this list to print the queue contents using `System.out`. Uses the `List` interface for the variable type.
 *         *   Case 4 (`View Completed`): Calls `manager.viewCompleted()`, which returns the `completedOrders` `List`. It iterates through this list to print the completed orders using `System.out`. Uses the `List` interface for the variable type.
 *         *   Case 5 (`View Machine Status`): Calls `manager.viewMachineStatus()` and prints the returned string to `System.out`.
 *         *   Case 6 (`Exit`): Sets the `running` flag to `false` to terminate the loop.
 *         *   `default`: Handles invalid menu choices, printing an error to `System.err`.
 *     *   **Class-wide Exception Handling:** The main `try-catch` block around the `switch` statement catches `InputMismatchException` for the initial menu choice and a general `Exception` for any other unexpected runtime errors that might occur within the loop, printing error messages to `System.err`. This prevents the program from crashing due to unhandled exceptions during the main execution flow.
 *     *   **Resource Management:** The `Scanner` is closed using `scanner.close()` after the loop terminates.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within an object-oriented design, addressing the problem requirements and demonstrating key Java programming skills.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a production order
class Order {
    private String orderId;
    private String productName;
    private int quantity;

    public Order(String orderId, String productName, int quantity) {
        // Basic validation in constructor
        if (orderId == null || orderId.trim().isEmpty()) {
            throw new IllegalArgumentException("Order ID cannot be null or empty.");
        }
        if (productName == null || productName.trim().isEmpty()) {
            throw new IllegalArgumentException("Product name cannot be null or empty.");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.orderId = orderId.trim();
        this.productName = productName.trim();
        this.quantity = quantity;
    }

    // Getters
    public String getOrderId() {
        return orderId;
    }

    public String getProductName() {
        return productName;
    }

    public int getQuantity() {
        return quantity;
    }

    // For easy printing
    @Override
    public String toString() {
        return "Order [ID=" + orderId + ", Product=" + productName + ", Qty=" + quantity + "]";
    }
}

// Manages the production line state and operations
class ProductionLineManager {
    private Queue<Order> orderQueue;
    private List<Order> completedOrders;
    private int totalMachines;
    private int availableMachines; // Simplified machine status

    /**
     * Constructs a ProductionLineManager with a specified number of machines.
     * @param numberOfMachines The total number of production machines.
     * @throws IllegalArgumentException if numberOfMachines is not positive.
     */
    public ProductionLineManager(int numberOfMachines) {
        if (numberOfMachines <= 0) {
            throw new IllegalArgumentException("Number of machines must be positive.");
        }
        this.orderQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedOrders = new ArrayList<>();
        this.totalMachines = numberOfMachines;
        this.availableMachines = numberOfMachines; // Initially all machines are available
    }

    /**
     * Adds a new order to the waiting queue.
     * @param order The order to add.
     * @return true if the order was successfully added, false otherwise (e.g., null order).
     */
    public boolean addOrder(Order order) {
        if (order == null) {
            System.err.println("Error: Cannot add a null order.");
            return false;
        }
        // Order constructor already handles basic validation (ID, name, quantity)
        return orderQueue.offer(order); // offer is generally preferred over add for capacity-constrained queues, though LinkedList is not capacity-constrained
    }

    /**
     * Simulates processing the next order in the queue using an available machine.
     * @return The processed order if successful, null otherwise.
     */
    public Order processNextOrder() {
        if (orderQueue.isEmpty()) {
            System.err.println("Error: Order queue is empty. Nothing to process.");
            return null;
        }

        if (availableMachines <= 0) {
            System.err.println("Error: No production machines are currently available.");
            return null;
        }

        // If queue is not empty and machines are available
        Order orderToProcess = orderQueue.poll(); // Get and remove the head of the queue

        if (orderToProcess != null) {
            availableMachines--; // Mark a machine as busy (conceptually)
            completedOrders.add(orderToProcess); // Add to completed list
            // In this simplified model, the machine becomes available immediately after processing
            // For a more complex model, you'd manage machine state and processing time
            availableMachines++; // Machine becomes available again instantly after processing
            return orderToProcess;
        }
        // This part should ideally not be reached if orderQueue.isEmpty() check passes,
        // but good practice to handle poll returning null.
        System.err.println("Error: Could not retrieve order from queue.");
        return null;
    }

    /**
     * Returns the current list of orders waiting in the queue.
     * @return A List view of the orders in the queue.
     */
    public List<Order> viewQueue() {
        // Return a new ArrayList containing elements from the queue
        // to prevent external modification of the internal queue structure.
        return new ArrayList<>(orderQueue);
    }

    /**
     * Returns the list of orders that have been completed.
     * @return The List of completed orders.
     */
    public List<Order> viewCompleted() {
        // Return the list directly or a copy depending on whether external modification is allowed.
        // Returning the list directly is simpler for this example.
        return completedOrders;
    }

    /**
     * Gets the current status of the production machines.
     * @return A string describing the machine status.
     */
    public String viewMachineStatus() {
        // In our simplified model, availableMachines is always totalMachines after a process call finishes.
        // A more realistic model would decrement availableMachines and have a separate process completion step.
        // Let's adjust the processing logic slightly: a machine is "used" for a task.
        // A better simplified model: availableMachines count decreases when processing *starts* and increases when it *finishes*.
        // Given the requirement of instantaneous processing, the "busy" state is fleeting.
        // Let's stick to the simplest interpretation for the exam: 'availableMachines' represents how many *slots* are free *right now*.
        // If processNextOrder completes instantly, availableMachines will always equal totalMachines *between* process calls.
        // This makes the 'viewMachineStatus' less dynamic.
        // Let's slightly refine: availableMachines is the pool. Processing uses one. It's returned *immediately* after the 'processNextOrder' method finishes.
        // So, viewMachineStatus will always show totalMachines / totalMachines unless called *during* the brief processing window, which isn't possible with this synchronous model.
        // A more meaningful status in this model: how many items *could* be processed simultaneously if available? It's always totalMachines.
        // Let's redefine: availableMachines is how many are *not currently tied up* by an ongoing task.
        // The current processNextOrder logic doesn't really simulate tying up a machine.
        // Let's revert to the simplest interpretation: availableMachines is the *capacity*. Processing requires 1 unit of capacity.
        // If capacity > 0, process. Capacity doesn't change because processing is instant.
        // This makes the machine status report less interesting.
        // Let's try another angle: availableMachines is the count of idle machines.
        // processNextOrder: if idle > 0 and queue not empty, take from queue, idle--, add to completed, idle++. This is still instant.
        // How about this: availableMachines represents the number of machines *ready* for a *new* task.
        // When processNextOrder is called, if availableMachines > 0, it uses one. It's immediately freed up because the task is instant.
        // The only way for availableMachines to be less than totalMachines is if we had concurrent processing or processing time.
        // Since we don't, the status will always be totalMachines / totalMachines.
        // This feels like a flaw in the simplified requirement vs. the component usage.
        // Let's make the processing logic slightly less instant for the *status* reporting, even if the method finishes quickly.
        // Let's say calling processNextOrder *attempts* to use a machine. If successful, it decrements availableMachines.
        // However, without a background thread or time simulation, we can't increment it later.
        // Okay, simplest exam-friendly interpretation: availableMachines is just the *total* capacity. The check `availableMachines > 0` ensures the system *could* process if it had orders. The status report just shows the total capacity. This is weak.

        // Let's try again: `availableMachines` tracks how many machines are *currently free*.
        // When `processNextOrder` is called:
        // 1. Check queue empty? -> Error
        // 2. Check `availableMachines > 0`? -> Error if not.
        // 3. If OK, `availableMachines--`. Poll order. Add to completed. Print success.
        // 4. Immediately *after* adding to completed, `availableMachines++`.
        // This still results in `availableMachines` always being equal to `totalMachines` *between* calls.
        // The only way `availableMachines` would be less than `totalMachines` is if the processing step itself took time, or if multiple process calls could happen concurrently.

        // Let's redefine for clarity in this exam: `availableMachines` counts how many machines are ready to take on a *new* task.
        // When `processNextOrder` is called and successful, it means one machine *was used*.
        // For the *status report*, let's show `totalMachines - availableMachines` as busy and `availableMachines` as free.
        // The `processNextOrder` method will decrement `availableMachines` if successful.
        // How does it increment? It doesn't, in this simple model. Machines are consumed? No, that doesn't make sense.
        // The only way `availableMachines` can ever be less than `totalMachines` is if we *don't* increment it back to `totalMachines` immediately.
        // Let's try this: `processNextOrder` decrements `availableMachines` if successful. It does NOT increment it back.
        // A separate command/event would be needed to "free up" machines. This adds complexity not explicitly requested.

        // Let's go back to the simplest model that still uses the variable: `availableMachines` is the count of machines ready for a *new* task.
        // `processNextOrder` checks `availableMachines > 0`. If yes, it uses one.
        // The simplest way to model "using one" without complex state is to decrement it.
        // When does it become free? Let's add a command "Free a machine". This wasn't in the original plan but makes machine status meaningful.
        // Reread the assumption: "A machine becomes free immediately after processing an order (simplification)".
        // This implies that right after `completedOrders.add(orderToProcess)`, the machine is free again.
        // This confirms `availableMachines` will always be `totalMachines` between method calls.
        // Okay, let's embrace the simplicity for the exam. The status report will reflect the *capacity* and how many are *potentially* busy if a process call is happening *right now* (which is zero between calls).
        // The check `availableMachines > 0` is still valid as it checks if the system *has the capacity* to process, even if that capacity is always the total.
        // Let's make the status report just show total machines and available capacity.

        // Final simplified model for machine status: `availableMachines` is the count of machines ready for a *new* task.
        // `processNextOrder` checks if `availableMachines > 0`. If yes, it uses one. It decrements `availableMachines`.
        // It then processes the order and adds to completed.
        // It *immediately* increments `availableMachines` back.
        // So `availableMachines` always equals `totalMachines` when `processNextOrder` finishes.
        // This means the `viewMachineStatus` will always show "X/X machines available".
        // The `availableMachines > 0` check is effectively just checking if `totalMachines > 0`.
        // This interpretation makes the `availableMachines` variable somewhat redundant for *status* but still necessary for the *check* in `processNextOrder`.
        // Let's proceed with this. The status message will be simple.

        int busyMachines = totalMachines - availableMachines; // This will always be 0 in this sync model
        return "Machine Status: " + availableMachines + "/" + totalMachines + " machines available.";
    }
}

public class ProductionLineApp {

    private static final int NUM_MACHINES = 3; // Fixed number of machines

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLineManager manager = null;

        try {
            manager = new ProductionLineManager(NUM_MACHINES);
        } catch (IllegalArgumentException e) {
            System.err.println("Failed to initialize Production Line Manager: " + e.getMessage());
            // Cannot proceed if manager fails to initialize
            scanner.close();
            return;
        }


        System.out.println("--- Production Line Management System ---");

        boolean running = true;
        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1: // Add New Order
                        System.out.println("\nEnter Order Details:");
                        System.out.print("Order ID: ");
                        String orderId = scanner.nextLine();
                        System.out.print("Product Name: ");
                        String productName = scanner.nextLine();
                        System.out.print("Quantity: ");
                        int quantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        try {
                            Order newOrder = new Order(orderId, productName, quantity);
                            if (manager.addOrder(newOrder)) {
                                System.out.println("Order '" + orderId + "' added to the queue.");
                            }
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding order: " + e.getMessage());
                        } catch (InputMismatchException e) {
                             System.err.println("Invalid input for quantity. Please enter a number.");
                             scanner.nextLine(); // Clear invalid input
                        }
                        break;

                    case 2: // Process Next Order
                        System.out.println("\nAttempting to process next order...");
                        Order processedOrder = manager.processNextOrder();
                        if (processedOrder != null) {
                            System.out.println("Successfully processed: " + processedOrder);
                        }
                        // Error messages are printed within processNextOrder method
                        break;

                    case 3: // View Order Queue
                        System.out.println("\n--- Current Order Queue ---");
                        List<Order> queueView = manager.viewQueue(); // Using List interface
                        if (queueView.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            queueView.forEach(System.out::println);
                        }
                        System.out.println("---------------------------");
                        break;

                    case 4: // View Completed Orders
                        System.out.println("\n--- Completed Orders ---");
                        List<Order> completedList = manager.viewCompleted(); // Using List interface
                        if (completedList.isEmpty()) {
                            System.out.println("No orders have been completed yet.");
                        } else {
                            completedList.forEach(System.out::println);
                        }
                        System.out.println("------------------------");
                        break;

                    case 5: // View Machine Status
                        System.out.println("\n" + manager.viewMachineStatus());
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Production Line Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for the menu choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging in exam context
            }
             System.out.println(); // Add a newline for better formatting after each action
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Order Queue");
        System.out.println("4. View Completed Orders");
        System.out.println("5. View Machine Status");
        System.out.println("6. Exit");
        System.out.println("------------");
    }
}
