/*
 * Exam Question #129
 * Generated on: 2025-05-11 22:18:42
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Help Desk Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Help Desk Ticket Management System. The system should allow users to submit new support tickets, view existing tickets (categorized by status), and process the next pending ticket. The system should handle user input, manage ticket data efficiently, and provide clear feedback and error messages.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Ticket Representation:** Create a class `Ticket` to represent a help desk ticket. Each ticket must have:
 *     *   A unique integer ID.
 *     *   A String description.
 *     *   A priority level (e.g., LOW, MEDIUM, HIGH). Use an `enum` for priority.
 *     *   A status (e.g., OPEN, IN_PROGRESS, RESOLVED). Use an `enum` for status.
 *     *   Implement appropriate constructors, getters, and a meaningful `toString()` method.
 * 
 * 2.  **System Core:** Create a class `HelpDeskSystem` that manages the tickets. This class must use:
 *     *   A `Queue` (specifically, an implementation like `LinkedList` cast to `Queue`) to store tickets that are currently `OPEN` and waiting to be processed. Tickets should be processed in the order they are added to the queue (FIFO).
 *     *   An `ArrayList` to store *all* tickets created in the system, regardless of their status.
 *     *   Declare the collection holding all tickets using the `List` interface type.
 * 
 * 3.  **Functionality:** The system should provide the following menu-driven operations:
 *     *   **Submit New Ticket:** Prompt the user for a description and priority level. Create a new `Ticket` object with status `OPEN`, add it to both the `ArrayList` of all tickets and the `Queue` of pending tickets. Generate unique ticket IDs (e.g., using a simple counter).
 *     *   **View Open Tickets:** Display all tickets currently in the system that have the status `OPEN`.
 *     *   **View Resolved Tickets:** Display all tickets currently in the system that have the status `RESOLVED`.
 *     *   **Process Next Pending Ticket:** Take the next ticket from the front of the `Queue`. If the queue is not empty, change the status of the dequeued ticket to `IN_PROGRESS` (or `RESOLVED` for simplicity in this exam context - let's change to `RESOLVED` upon processing). Print a message indicating which ticket was processed. If the queue is empty, print an error message.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interaction:** Use `java.util.Scanner` to get user input for menu choices, ticket descriptions, and priorities.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 
 * 6.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input operations that might fail (e.g., non-integer input for menu choice) and operations that might fail under certain conditions (e.g., processing a ticket from an empty queue).
 *     *   Use `System.err` to print error messages (e.g., for invalid input, empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, ticket details, success messages).
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/setters where necessary).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments to explain complex parts of the code.
 *     *   Perform basic input validation (e.g., ensure priority input is valid).
 *     *   Structure the code logically with clear methods for each operation.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept input, perform the requested action, and display results or errors. Examples:
 * 
 * ```
 * --- Help Desk Menu ---
 * 1. Submit New Ticket
 * 2. View Open Tickets
 * 3. View Resolved Tickets
 * 4. Process Next Pending Ticket
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working
 * Enter priority (LOW, MEDIUM, HIGH): HIGH
 * Ticket #1 submitted (HIGH): My printer is not working
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 4
 * Processing ticket #1 (HIGH): My printer is not working. Status changed to RESOLVED.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 4
 * System.err: No tickets pending processing.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 2
 * --- Open Tickets ---
 * (No open tickets)
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 3
 * --- Resolved Tickets ---
 * Ticket #1 (RESOLVED): My printer is not working
 * ```
 * 
 * **Constraint Checklist:**
 * *   [ ] Queue (java.util.Queue) used
 * *   [ ] ArrayList (java.util.ArrayList) used
 * *   [ ] List interface (java.util.List) used
 * *   [ ] Scanner for user input used
 * *   [ ] Switch statement used
 * *   [ ] System.err used for error messages
 * *   [ ] System.out used for normal output
 * *   [ ] Class-wide exception handling (try-catch) used
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for this system, including the `Ticket` class and the `HelpDeskSystem` class with the `main` method. Ensure all requirements and best practices are met.
 *
 * EXPLANATION:
 * This solution implements a simple Help Desk Ticket Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Ticket Class:**
 *     *   The `Ticket` class encapsulates the data for a single ticket: `ticketId`, `description`, `priority`, and `status`.
 *     *   `Priority` and `Status` are defined as enums, providing type safety and clear representation of states.
 *     *   A `static int nextId` ensures each ticket gets a unique, sequential ID.
 *     *   Fields are `private`, adhering to encapsulation. Public getters provide controlled access to the data. A setter is provided only for `status`, as this is the only field that changes after creation during the system's operation.
 *     *   `toString()` is overridden for easy printing of ticket details.
 * 
 * 2.  **HelpDeskSystem Class:**
 *     *   This is the main class managing the system's state and logic.
 *     *   `List<Ticket> allTickets`: An `ArrayList` is used as the underlying implementation, but it is declared using the `List` interface type. This list holds *all* tickets created in the system, allowing for easy viewing of different categories (open, resolved) by iterating through the list and checking the status.
 *     *   `Queue<Ticket> pendingTicketsQueue`: A `LinkedList` is used as the underlying implementation, declared using the `Queue` interface type. This queue specifically holds `OPEN` tickets and is used for processing them in a FIFO manner.
 *     *   `Scanner scanner`: Used to read user input from the console.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `submitNewTicket()`: Prompts for description and priority. Uses `Scanner` to read input. Includes a loop and `try-catch` to validate the priority input against the `Priority` enum. Creates a new `Ticket` object (which defaults to `OPEN` status). Adds the new ticket to *both* `allTickets` (for overall tracking) and `pendingTicketsQueue` (for processing).
 *     *   `viewOpenTickets()` and `viewResolvedTickets()`: These methods iterate through the `allTickets` list and print tickets whose status matches `Status.OPEN` or `Status.RESOLVED`, respectively.
 *     *   `processNextPendingTicket()`: This method demonstrates the use of the `Queue`. It checks if the `pendingTicketsQueue` is `isEmpty()`. If not, it uses `poll()` to retrieve and remove the ticket at the head of the queue. It then changes the status of this ticket object to `RESOLVED`. Since the same `Ticket` object reference exists in the `allTickets` list, changing its status here updates it in both collections simultaneously. If the queue is empty, an error message is printed to `System.err`.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   `run()`: This method contains the main application loop. It repeatedly displays the menu, reads the user's choice using `scanner.nextInt()`, and uses a `switch` statement to delegate the action to the appropriate method (`submitNewTicket`, `viewOpenTickets`, etc.).
 * 
 * 4.  **Control Flow and Error Handling:**
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement elegantly handles the branching based on the user's menu choice.
 *     *   A `try-catch` block wraps the user input reading (`scanner.nextInt()`) and the core logic within the loop.
 *         *   `InputMismatchException` is caught specifically to handle cases where the user enters non-integer input for the menu choice. `System.err` is used for this error message. `scanner.nextLine()` is called in the catch block to consume the invalid input and prevent an infinite loop.
 *         *   A general `Exception` catch block is included as a fallback for any other unexpected runtime errors, printing the error message to `System.err`.
 *     *   `System.out` is used for all successful output, prompts, and menu display.
 *     *   `System.err` is used specifically for error messages (invalid menu input, invalid priority input, empty queue).
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Ticket` class.
 *     *   Meaningful names like `pendingTicketsQueue`, `allTickets`, `submitNewTicket`, `processNextPendingTicket` are used.
 *     *   Comments explain the purpose of classes, methods, and key sections.
 *     *   Input validation is performed for the ticket priority.
 *     *   Error handling is implemented using `try-catch` and `System.err`.
 *     *   The code is structured into logical methods within the `HelpDeskSystem` class.
 *     *   The `Scanner` is closed when the program exits.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional, albeit simplified, help desk system, demonstrating an understanding of fundamental data structures, control flow, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Ticket Priority
enum Priority {
    LOW, MEDIUM, HIGH
}

// Enum for Ticket Status
enum Status {
    OPEN, IN_PROGRESS, RESOLVED
}

// Represents a single help desk ticket
class Ticket {
    private static int nextId = 1; // Static counter for unique IDs

    private int ticketId;
    private String description;
    private Priority priority;
    private Status status;

    // Constructor
    public Ticket(String description, Priority priority) {
        this.ticketId = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
        this.status = Status.OPEN; // New tickets are always OPEN
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(Status status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return String.format("Ticket #%d (%s): %s [Status: %s]",
                             ticketId, priority, description, status);
    }
}

// Manages the collection of tickets and the processing queue
public class HelpDeskSystem {

    // Use List interface type for the collection of all tickets
    private List<Ticket> allTickets;

    // Use Queue interface type for tickets pending processing (OPEN status)
    private Queue<Ticket> pendingTicketsQueue;

    private Scanner scanner; // Scanner for user input

    // Constructor
    public HelpDeskSystem() {
        // Use ArrayList as the implementation for List
        this.allTickets = new ArrayList<>();
        // Use LinkedList as the implementation for Queue
        this.pendingTicketsQueue = new LinkedList<>();
        this.scanner = new Scanner(System.in);
    }

    // --- Core System Operations ---

    /**
     * Submits a new ticket based on user input.
     */
    public void submitNewTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (LOW, MEDIUM, HIGH): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityInput);
                validPriority = true;
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid priority. Please enter LOW, MEDIUM, or HIGH.");
            }
        }

        // Create a new ticket - it's automatically OPEN
        Ticket newTicket = new Ticket(description, priority);

        // Add to both collections
        allTickets.add(newTicket);
        pendingTicketsQueue.add(newTicket); // Add to the queue for processing

        System.out.println("Ticket #" + newTicket.getTicketId() + " submitted (" + newTicket.getPriority() + "): " + newTicket.getDescription());
    }

    /**
     * Displays all tickets with OPEN status.
     */
    public void viewOpenTickets() {
        System.out.println("--- Open Tickets ---");
        boolean foundOpen = false;
        // Iterate through all tickets to find open ones
        for (Ticket ticket : allTickets) {
            if (ticket.getStatus() == Status.OPEN) {
                System.out.println(ticket);
                foundOpen = true;
            }
        }
        if (!foundOpen) {
            System.out.println("(No open tickets)");
        }
    }

    /**
     * Displays all tickets with RESOLVED status.
     */
    public void viewResolvedTickets() {
        System.out.println("--- Resolved Tickets ---");
        boolean foundResolved = false;
        // Iterate through all tickets to find resolved ones
        for (Ticket ticket : allTickets) {
            if (ticket.getStatus() == Status.RESOLVED) {
                System.out.println(ticket);
                foundResolved = true;
            }
        }
        if (!foundResolved) {
            System.out.println("(No resolved tickets)");
        }
    }

    /**
     * Processes the next ticket from the pending queue.
     */
    public void processNextPendingTicket() {
        // Check if the queue is empty
        if (pendingTicketsQueue.isEmpty()) {
            System.err.println("No tickets pending processing.");
        } else {
            // Get and remove the head of the queue
            Ticket ticketToProcess = pendingTicketsQueue.poll();

            // Change the status of the ticket (the object reference is the same in allTickets list)
            ticketToProcess.setStatus(Status.RESOLVED); // Changing to RESOLVED for simplicity

            System.out.println("Processing " + ticketToProcess.toString() + ". Status changed to RESOLVED.");
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Help Desk Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. View Open Tickets");
        System.out.println("3. View Resolved Tickets");
        System.out.println("4. Process Next Pending Ticket");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // --- Main Application Loop ---

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Read user choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline left-over

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        submitNewTicket();
                        break;
                    case 2:
                        viewOpenTickets();
                        break;
                    case 3:
                        viewResolvedTickets();
                        break;
                    case 4:
                        processNextPendingTicket();
                        break;
                    case 5:
                        System.out.println("Exiting Help Desk System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during operation
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run();
    }
}
