/*
 * Exam Question #884
 * Generated on: 2025-05-12 16:54:52
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line Task Management System. The system should allow users to add new tasks, view all tasks, view tasks currently in a processing queue, process the next task from the queue, and update the status of any task by its ID.
 * 
 * Each task should have the following properties:
 * *   Unique Integer ID
 * *   Description (String)
 * *   Status (String: e.g., "PENDING", "IN_PROGRESS", "COMPLETED", "CANCELLED")
 * *   Priority (String: e.g., "HIGH", "MEDIUM", "LOW")
 * *   Assignee (String)
 * 
 * The system should maintain a master list of all tasks ever created and a separate queue specifically for tasks that are pending and awaiting processing via a dedicated "Process Next" action.
 * 
 * **Functionality Requirements:**
 * 
 * 1.  **Add New Task:**
 *     *   Prompt the user for task description, priority, and assignee.
 *     *   Automatically assign a unique integer ID (starting from 1).
 *     *   Set the initial status to "PENDING".
 *     *   Add the new task to both the master list of all tasks and the processing queue.
 * 2.  **View All Tasks:**
 *     *   Display all tasks in the master list with their details.
 * 3.  **View Processing Queue:**
 *     *   Display tasks currently in the processing queue. Do *not* remove them from the queue during viewing.
 * 4.  **Process Next Task from Queue:**
 *     *   Remove the next task from the head of the processing queue.
 *     *   If the queue is empty, report an error.
 *     *   If a task is retrieved, find it in the master list (using its ID) and update its status to "IN_PROGRESS". Report which task was processed.
 * 5.  **Update Task Status by ID:**
 *     *   Prompt the user for a Task ID and a new status string.
 *     *   Find the task in the master list using the provided ID.
 *     *   If the task is found, update its status. Validate that the new status is one of the allowed values ("PENDING", "IN_PROGRESS", "COMPLETED", "CANCELLED").
 *     *   If the task is not found or the status is invalid, report an error.
 *     *   *Note: Updating status manually does NOT remove the task from the processing queue; only the "Process Next" action does.*
 * 6.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must use and demonstrate understanding of the following Java components:
 * *   `java.util.Queue` (specifically, an implementation like `java.util.LinkedList` which implements `Queue`)
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface (declare your master list using the `List` interface type)
 * *   `java.util.Scanner` for all user input
 * *   `switch` statement for handling the user's menu choice
 * *   `System.err` for outputting error messages (e.g., invalid input, queue empty, task not found)
 * *   `System.out` for outputting normal information (menu, task details, success messages)
 * *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues (e.g., unexpected input format).
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation for task properties (private fields, public getters/setters).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments to explain complex parts.
 * *   Perform input validation where necessary (e.g., menu choice, task ID, status string).
 * *   Structure your code into appropriate classes (`Task`, `TaskManager`, `TaskManagementApp`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user and execute the chosen action. Output should be clear, indicating success or failure of operations and displaying task details as requested. Error messages should go to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. View All Tasks
 * 3. View Processing Queue
 * 4. Process Next Task from Queue
 * 5. Update Task Status by ID
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Implement Add Task
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Enter assignee: Alice
 * Task added with ID: 1
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * Processing Queue:
 * Task ID: 1, Description: Implement Add Task, Status: PENDING, Priority: HIGH, Assignee: Alice
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * Processing next task...
 * Processed task ID: 1. Status updated to IN_PROGRESS.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * All Tasks:
 * Task ID: 1, Description: Implement Add Task, Status: IN_PROGRESS, Priority: HIGH, Assignee: Alice
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 5
 * Enter Task ID to update: 1
 * Enter new status (PENDING, IN_PROGRESS, COMPLETED, CANCELLED): COMPLETED
 * Task ID 1 status updated to COMPLETED.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * Processing next task...
 * System.err: Processing queue is empty. No tasks to process.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses `private` fields (`id`, `description`, `status`, `priority`, `assignee`) enforcing encapsulation.
 *     *   Provides public getter methods (`getId`, `getDescription`, etc.) to access the data.
 *     *   Includes a `setStatus` method that performs validation against a predefined list of `ALLOWED_STATUSES` (using `List.of` and `contains`), demonstrating input validation within the object itself.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Acts as the central manager for tasks.
 *     *   `List<Task> allTasks = new ArrayList<>();`: Declares a master list using the `List` interface type and initializes it with an `ArrayList`. This list holds references to *all* tasks ever created, allowing retrieval regardless of their current status or queue presence. `ArrayList` is suitable for dynamic resizing and iterating through all elements.
 *     *   `Queue<Task> processingQueue = new LinkedList<>();`: Declares a queue using the `Queue` interface type and initializes it with a `LinkedList`. `LinkedList` is a common implementation of `Queue` providing FIFO behavior. This queue specifically manages tasks waiting for the "Process Next" action.
 *     *   `nextTaskId`: A simple counter to generate unique integer IDs for new tasks.
 *     *   `addTask()`: Creates a new `Task` object, adds it to both `allTasks` and `processingQueue` using `list.add()` and `queue.offer()`. `offer()` is generally preferred over `add()` for queues as it returns `false` if the element cannot be added (though `LinkedList`'s `offer` won't fail due to capacity).
 *     *   `getAllTasks()`: Returns a *copy* of the `allTasks` list using `List.copyOf()` to prevent external modification of the internal list, adhering to good practice.
 *     *   `getProcessingQueueTasks()`: Creates and returns a *new* `ArrayList` populated from the `processingQueue`. This allows viewing the queue contents without removing elements (`Queue.poll()` or `Queue.remove()` would remove them).
 *     *   `processNextTaskFromQueue()`: Uses `processingQueue.poll()` to retrieve and *remove* the head element from the queue. It checks if the result is `null` (indicating an empty queue) and updates the status of the retrieved task (which is a reference to the object in `allTasks`).
 *     *   `updateTaskStatus()`: Iterates through `allTasks` to find a task by ID. It uses the `Task` object's `setStatus` method to update the status, leveraging the validation built into the `Task` class.
 *     *   `findTaskById()`: A helper method to locate a task in the `allTasks` list by its ID.
 * 
 * 3.  **`TaskManagementApp` Class:**
 *     *   Contains the `main` method where the application execution begins.
 *     *   `Scanner scanner = new Scanner(System.in);`: Initializes a `Scanner` to read user input from the console (`System.in`).
 *     *   The main application logic runs in a `while(running)` loop.
 *     *   `printMenu()`: Displays the available options to the user.
 *     *   `getUserChoice()`: Reads the user's integer input for the menu choice. It includes a `try-catch(InputMismatchException)` block to handle non-integer input gracefully, preventing program crash and consuming the invalid input using `scanner.next()` and `scanner.nextLine()`. The `finally` block ensures `scanner.nextLine()` is called after `scanner.nextInt()` in all cases to consume the newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   `switch (choice)`: A `switch` statement is used to direct the program flow based on the validated user choice, calling the appropriate methods.
 *     *   Methods like `addNewTask`, `viewAllTasks`, `viewProcessingQueue`, `processNextTask`, and `updateTaskStatus` handle the specific user actions, calling methods on the `taskManager` and interacting with the user via `Scanner`, `System.out`, and `System.err`.
 *     *   `System.out.println()`: Used for normal output like menus, task details, and success messages.
 *     *   `System.err.println()`: Used specifically for error messages, such as invalid input, task not found, or attempting to process from an empty queue.
 *     *   Class-wide `try-catch(Exception e)`: The main `while` loop is wrapped in a `try-catch` block. This provides a top-level safety net to catch any unexpected exceptions that might occur during the program's execution, printing an error message and the stack trace to `System.err` before the `finally` block ensures the `Scanner` is closed. This demonstrates class-wide exception handling as required.
 * 
 * This solution effectively combines data structures (`ArrayList`, `Queue`), input/output (`Scanner`, `System.out`, `System.err`), control flow (`switch`), object-oriented principles (encapsulation, separate classes), and robust error handling (`try-catch`, input validation) to solve the problem, meeting all specified requirements in a practical context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single Task
class Task {
    private int id;
    private String description;
    private String status;
    private String priority;
    private String assignee;

    // Allowed statuses for validation
    public static final List<String> ALLOWED_STATUSES = List.of(
        "PENDING", "IN_PROGRESS", "COMPLETED", "CANCELLED"
    );

    public Task(int id, String description, String priority, String assignee) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Initial status
        this.priority = priority;
        this.assignee = assignee;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public String getPriority() {
        return priority;
    }

    public String getAssignee() {
        return assignee;
    }

    // Setter for status with validation
    public boolean setStatus(String status) {
        if (ALLOWED_STATUSES.contains(status.toUpperCase())) {
            this.status = status.toUpperCase();
            return true;
        }
        return false; // Indicate invalid status
    }

    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Status: %s, Priority: %s, Assignee: %s",
                             id, description, status, priority, assignee);
    }
}

// Manages the collection of tasks
class TaskManager {
    // Master list of all tasks created
    private List<Task> allTasks;
    // Queue for tasks awaiting processing via the dedicated action
    private Queue<Task> processingQueue;
    // Counter for generating unique task IDs
    private int nextTaskId;

    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Uses ArrayList
        this.processingQueue = new LinkedList<>(); // Uses LinkedList implementing Queue
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * @param description Task description
     * @param priority Task priority
     * @param assignee Task assignee
     * @return The newly created Task object
     */
    public Task addTask(String description, String priority, String assignee) {
        Task newTask = new Task(nextTaskId++, description, priority, assignee);
        allTasks.add(newTask); // Add to master list
        processingQueue.offer(newTask); // Add to processing queue
        return newTask;
    }

    /**
     * Returns an unmodifiable list of all tasks.
     * @return List of all tasks
     */
    public List<Task> getAllTasks() {
        return List.copyOf(allTasks); // Return a copy to prevent external modification
    }

    /**
     * Returns an unmodifiable list of tasks currently in the processing queue.
     * @return List of tasks in the processing queue
     */
    public List<Task> getProcessingQueueTasks() {
        // Convert queue to list for viewing without removing elements
        return new ArrayList<>(processingQueue);
    }

    /**
     * Processes the next task from the head of the processing queue.
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTaskFromQueue() {
        Task taskToProcess = processingQueue.poll(); // Remove from queue
        if (taskToProcess != null) {
            // Find the task in the master list to update its status
            // (In this simple model, taskToProcess is already a reference to the object in allTasks)
            // A more complex system might need to search allTasks by ID if copies were made.
            taskToProcess.setStatus("IN_PROGRESS"); // Update status
        }
        return taskToProcess;
    }

    /**
     * Finds a task by its ID and updates its status.
     * @param id The ID of the task to update.
     * @param newStatus The new status string.
     * @return true if the task was found and status updated, false otherwise.
     */
    public boolean updateTaskStatus(int id, String newStatus) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                // Use the setter which includes validation
                return task.setStatus(newStatus);
            }
        }
        return false; // Task not found
    }

    /**
     * Finds a task by its ID.
     * @param id The ID of the task.
     * @return The Task object if found, null otherwise.
     */
    public Task findTaskById(int id) {
         for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }
}

// Main application class for user interaction
public class TaskManagementApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Welcome to the Task Management System!");
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        viewProcessingQueue();
                        break;
                    case 4:
                        processNextTask();
                        break;
                    case 5:
                        updateTaskStatus();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    private static void printMenu() {
        System.out.println("Task Management Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Processing Queue");
        System.out.println("4. Process Next Task from Queue");
        System.out.println("5. Update Task Status by ID");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    private static int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Consume the invalid input to prevent infinite loop
            scanner.next();
            choice = -1; // Indicate invalid input
        } finally {
             // Consume the rest of the line after reading the integer
             // This is crucial when mixing nextInt() and nextLine()
             scanner.nextLine();
        }
        return choice;
    }

    private static void addNewTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priority = scanner.nextLine();
        System.out.print("Enter assignee: ");
        String assignee = scanner.nextLine();

        // Basic validation for non-empty fields
        if (description.trim().isEmpty() || priority.trim().isEmpty() || assignee.trim().isEmpty()) {
             System.err.println("Error: Description, priority, and assignee cannot be empty.");
             return;
        }

        Task newTask = taskManager.addTask(description, priority, assignee);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    private static void viewAllTasks() {
        List<Task> tasks = taskManager.getAllTasks();
        if (tasks.isEmpty()) {
            System.out.println("No tasks available.");
        } else {
            System.out.println("All Tasks:");
            for (Task task : tasks) {
                System.out.println(task);
            }
        }
    }

    private static void viewProcessingQueue() {
        List<Task> queueTasks = taskManager.getProcessingQueueTasks();
        if (queueTasks.isEmpty()) {
            System.out.println("Processing Queue is empty.");
        } else {
            System.out.println("Processing Queue:");
            // Iterate through the list created from the queue
            for (Task task : queueTasks) {
                System.out.println(task);
            }
        }
    }

    private static void processNextTask() {
        System.out.println("Processing next task...");
        Task processedTask = taskManager.processNextTaskFromQueue();
        if (processedTask != null) {
            System.out.println("Processed task ID: " + processedTask.getId() + ". Status updated to " + processedTask.getStatus() + ".");
        } else {
            System.err.println("Processing queue is empty. No tasks to process.");
        }
    }

    private static void updateTaskStatus() {
        System.out.print("Enter Task ID to update: ");
        int taskId;
        try {
            taskId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid integer Task ID.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the rest of the line
        }

        System.out.print("Enter new status (PENDING, IN_PROGRESS, COMPLETED, CANCELLED): ");
        String newStatus = scanner.nextLine().trim();

        Task taskToUpdate = taskManager.findTaskById(taskId);

        if (taskToUpdate == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
        } else {
            if (taskToUpdate.setStatus(newStatus)) {
                System.out.println("Task ID " + taskId + " status updated to " + taskToUpdate.getStatus() + ".");
            } else {
                // setStatus returned false, indicating invalid status string
                System.err.println("Error: Invalid status '" + newStatus + "'. Allowed statuses are: " + Task.ALLOWED_STATUSES);
            }
        }
    }
}
