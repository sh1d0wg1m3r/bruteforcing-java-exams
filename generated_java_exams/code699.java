/*
 * Exam Question #699
 * Generated on: 2025-05-12 16:27:25
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Objective:** Design and implement a simple command-line application for managing tasks within a team. Tasks have different priority levels, and the system must process them based on these priorities.
 * 
 * **Scenario:** You are building a simplified task scheduler. Tasks are added with a description and a priority (High, Medium, or Low). The system should allow users to add tasks, view tasks, and complete the next task based on a priority queue system. High-priority tasks are always processed before Medium, and Medium before Low. Within the same priority level, tasks are processed in the order they were added (First-In, First-Out).
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique ID, description, priority (String), and a boolean indicating if it's completed. Include a constructor, appropriate getters, a method to mark the task as completed, and an overridden `toString()` method for easy display. The task ID should be automatically generated (e.g., using a static counter).
 * 2.  **Task Management Logic:** Create a `TeamTaskScheduler` class that manages the tasks.
 *     *   It must maintain separate queues for High, Medium, and Low priority tasks using `java.util.Queue`.
 *     *   It must maintain a single list of *all* tasks ever added (both pending and completed) using `java.util.ArrayList` and declared as `java.util.List`.
 *     *   Implement the following methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task`, adds it to the `allTasks` list, and adds it to the appropriate priority queue based on the provided priority string. This method must validate the priority input (case-insensitive "High", "Medium", "Low"). If invalid, print an error to `System.err` and do not add the task.
 *         *   `viewPendingTasks()`: Prints all tasks currently in the priority queues, grouped by priority (High, then Medium, then Low). Tasks within each group should reflect their order in the queue. If no tasks are pending, print a message. Output should go to `System.out`.
 *         *   `viewAllTasks()`: Prints all tasks from the `allTasks` list (including completed ones). If the list is empty, print a message. Output should go to `System.out`.
 *         *   `completeNextTask()`: Removes and returns the next task to be completed according to the priority rules (High queue first, then Medium, then Low). If a task is retrieved, mark it as completed in the `allTasks` list (the object reference in the list should be the same as the one removed from the queue) and print a success message with the completed task details to `System.out`. If all queues are empty, print an error message to `System.err`.
 * 3.  **User Interface:** Implement a simple command-line interface in the `main` method (or a `run` method called from `main`) using `java.util.Scanner` to interact with the user.
 *     *   Present a menu with options: 1. Add Task, 2. View Pending Tasks, 3. View All Tasks, 4. Complete Next Task, 5. Exit.
 *     *   Use a `switch` statement to handle user choices.
 *     *   Handle user input errors (e.g., non-integer menu choice) using `try-catch` blocks.
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for all normal output (menu, task details, success messages).
 *     *   Use `System.err` for all error messages (invalid input, no tasks to complete, invalid priority).
 *     *   Implement class-wide exception handling using `try-catch` in the main application loop to catch potential unexpected errors and prevent the program from crashing abruptly. Ensure resources like `Scanner` are closed properly (e.g., in a `finally` block or using try-with-resources if applicable - a simple `finally` block is sufficient here).
 * 5.  **Best Practices:** Adhere to Java coding best practices, including:
 *     *   Proper encapsulation (private fields, public/private methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (brief Javadoc for classes/methods).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   The program should start by printing a welcome message.
 * *   Present the menu clearly.
 * *   Adding a task should prompt for description and priority, validate priority, and confirm successful addition to `System.out` with task details. Invalid priority should print an error to `System.err`.
 * *   Viewing pending tasks should list tasks from High, then Medium, then Low queues, showing their details, or indicate if no tasks are pending (`System.out`).
 * *   Viewing all tasks should list all tasks from the `allTasks` list, including completed ones (`System.out`).
 * *   Completing a task should identify the next task by priority, mark it completed, remove it from its queue, and print confirmation (`System.out`). If no tasks are pending, print an error (`System.err`).
 * *   Entering an invalid menu choice should print an error (`System.err`).
 * *   Entering non-integer input for the menu choice should be caught and handled with an error message (`System.err`), allowing the program to continue.
 * *   Selecting 'Exit' should terminate the program gracefully.
 * *   Any unexpected exception during the main loop should be caught by the class-wide handler, printing an error to `System.err` and potentially exiting or attempting to continue depending on the nature of the error (printing stack trace to `System.err` is helpful).
 * 
 * **Time Allotment:** 45-60 minutes. Focus on correctness and meeting all requirements.
 *
 * EXPLANATION:
 * This solution implements a `TeamTaskScheduler` that manages tasks based on priority queues and a comprehensive list of all tasks.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A simple class demonstrating encapsulation with private fields (`id`, `description`, `priority`, `isCompleted`) and public methods (`getters`, `markCompleted`, `toString`). The static `nextId` field shows how to generate unique identifiers for objects.
 * 2.  **`java.util.Queue`:** Three `LinkedList` instances (`highPriorityQueue`, `mediumPriorityQueue`, `lowPriorityQueue`) are used. `LinkedList` implements the `Queue` interface, providing FIFO behavior within each priority level. The `offer()` method is used for adding tasks and `poll()` is used for retrieving and removing the next task. Iterating over the queues in `viewPendingTasks` demonstrates how to inspect queue elements without removing them.
 * 3.  **`java.util.ArrayList` and `java.util.List`:** An `ArrayList` instance (`allTasks`) is used to store a record of every task ever added. It's declared with the `List` interface type, which is a common best practice for flexibility. This list allows viewing both pending and completed tasks.
 * 4.  **`java.util.Scanner`:** Used in the `run()` method to read user input from the console for menu choices, task descriptions, and priorities.
 * 5.  **`switch` Statement:** Used in the `run()` method to control the flow of the program based on the user's integer menu selection, directing execution to the appropriate task management method.
 * 6.  **`System.err`:** Utilized for printing error messages, such as invalid priority input in `addTask`, attempting to complete a task when no pending tasks exist in `completeNextTask`, and handling invalid menu input in the `run` loop. This distinguishes errors from normal output.
 * 7.  **`System.out`:** Used for all standard output, including the menu, success messages when adding or completing tasks, and displaying task details in `viewPendingTasks` and `viewAllTasks`.
 * 8.  **Class-wide Exception Handling with `try-catch`:** The `run()` method contains a `try-catch` block that wraps the main application loop (`while(running)`). This provides a top-level handler for unexpected exceptions that might occur during the program's execution, preventing abrupt termination and printing error details to `System.err`. A more specific `try-catch` is also included inside the loop to handle `InputMismatchException` specifically for the menu choice input, allowing the program to recover from non-integer entries. A `finally` block ensures the `Scanner` resource is closed.
 * 9.  **Input Validation:** The `addTask` method explicitly checks if the entered priority string is one of the expected values ("High", "Medium", "Low"), ignoring case and leading/trailing whitespace.
 * 10. **Error Handling:** Specific error messages are provided for different failure conditions (invalid priority, empty queues, invalid input type/value).
 * 11. **Best Practices:** The code demonstrates encapsulation, uses descriptive names for variables and methods, includes comments explaining the purpose of classes and methods, and maintains a clear structure with dedicated methods for different operations. The interaction between the queues (for processing order) and the list (for historical view) using shared `Task` object references is a subtle but important point.
 * 
 * This solution effectively integrates the required Java components into a functional application that simulates a practical scenario, demonstrating an understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a single task with an ID, description, priority, and completion status.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs

    private int id;
    private String description;
    private String priority; // High, Medium, Low
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (High, Medium, Low).
     */
    public Task(String description, String priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Tasks start as not completed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including ID, description, priority, and status.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: \"%s\", Priority: %s, Status: %s",
                             id, description, priority, isCompleted ? "Completed" : "Pending");
    }
}

/**
 * Manages tasks using priority queues and a list of all tasks.
 */
public class TeamTaskScheduler {

    // Queues for task processing based on priority (FIFO within priority)
    private Queue<Task> highPriorityQueue;
    private Queue<Task> mediumPriorityQueue;
    private Queue<Task> lowPriorityQueue;

    // List to store all tasks ever added, regardless of status or queue
    private List<Task> allTasks;

    /**
     * Constructs a new TeamTaskScheduler, initializing the queues and the task list.
     */
    public TeamTaskScheduler() {
        // LinkedList implements the Queue interface and is suitable for FIFO
        this.highPriorityQueue = new LinkedList<>();
        this.mediumPriorityQueue = new LinkedList<>();
        this.lowPriorityQueue = new LinkedList<>();

        // ArrayList implements the List interface and is suitable for storing all tasks
        this.allTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the system.
     * Validates priority and adds the task to the appropriate queue and the allTasks list.
     * @param description The task description.
     * @param priority The task priority (case-insensitive: "High", "Medium", "Low").
     */
    public void addTask(String description, String priority) {
        // Input validation for priority
        String lowerPriority = priority.trim().toLowerCase();
        Queue<Task> targetQueue = null;

        if ("high".equals(lowerPriority)) {
            targetQueue = highPriorityQueue;
        } else if ("medium".equals(lowerPriority)) {
            targetQueue = mediumPriorityQueue;
        } else if ("low".equals(lowerPriority)) {
            targetQueue = lowPriorityQueue;
        } else {
            // Use System.err for invalid input errors
            System.err.println("Error: Invalid priority '" + priority + "'. Task not added. Please use High, Medium, or Low.");
            return; // Exit method if priority is invalid
        }

        // Create the task object
        Task newTask = new Task(description, priority); // Task class handles ID generation

        // Add the task to the central list of all tasks
        allTasks.add(newTask);

        // Add the task to the appropriate priority queue
        targetQueue.offer(newTask); // offer() is generally preferred over add() for queues as it doesn't throw exceptions on capacity issues (though LinkedList doesn't have capacity limits)

        // Use System.out for successful operations
        System.out.println("Successfully added task:");
        System.out.println(newTask); // Uses Task's toString()
    }

    /**
     * Displays all pending tasks from the priority queues in order of processing priority.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks (High > Medium > Low Priority) ---");

        boolean foundPending = false; // Flag to check if any pending task was found

        // Display tasks from High Priority Queue
        if (!highPriorityQueue.isEmpty()) {
            System.out.println("High Priority:");
            // Iterate through the queue elements without removing them
            for (Task task : highPriorityQueue) {
                System.out.println(task);
                foundPending = true;
            }
        }

        // Display tasks from Medium Priority Queue
        if (!mediumPriorityQueue.isEmpty()) {
            System.out.println("Medium Priority:");
             for (Task task : mediumPriorityQueue) {
                System.out.println(task);
                foundPending = true;
            }
        }

        // Display tasks from Low Priority Queue
        if (!lowPriorityQueue.isEmpty()) {
            System.out.println("Low Priority:");
             for (Task task : lowPriorityQueue) {
                System.out.println(task);
                foundPending = true;
            }
        }

        // If no tasks were found in any queue
        if (!foundPending) {
            System.out.println("No pending tasks.");
        }
        System.out.println("--------------------------------------------------");
    }

    /**
     * Displays all tasks ever added to the system, including completed ones, from the allTasks list.
     */
    public void viewAllTasks() {
        System.out.println("\n--- All Tasks (Pending and Completed) ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            // Iterate through the ArrayList containing all tasks
            for (Task task : allTasks) {
                System.out.println(task); // Uses Task's toString()
            }
        }
        System.out.println("-----------------------------------------");
    }

    /**
     * Completes the next task based on priority (High > Medium > Low, FIFO within priority).
     * Removes the task from its queue and marks it as completed in the allTasks list.
     */
    public void completeNextTask() {
        Task taskToComplete = null;

        // Check queues in priority order (High -> Medium -> Low)
        if (!highPriorityQueue.isEmpty()) {
            taskToComplete = highPriorityQueue.poll(); // Get and remove the head of the queue
        } else if (!mediumPriorityQueue.isEmpty()) {
            taskToComplete = mediumPriorityQueue.poll();
        } else if (!lowPriorityQueue.isEmpty()) {
            taskToComplete = lowPriorityQueue.poll();
        }

        // If a task was found in any queue
        if (taskToComplete != null) {
            // Mark the task as completed. Because the same Task object reference
            // is in both the queue and the allTasks list, modifying it here
            // updates its state in the allTasks list automatically.
            taskToComplete.markCompleted();
            // Use System.out for successful completion
            System.out.println("Completed task:");
            System.out.println(taskToComplete); // Uses updated toString()
        } else {
            // Use System.err when no task is available to complete
            System.err.println("Error: No tasks are pending to be completed.");
        }
    }

    /**
     * Runs the main application loop, handling user input and executing commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Scanner for reading user input from the console
        Scanner scanner = new Scanner(System.in);
        boolean running = true; // Flag to keep the application running

        System.out.println("--- Team Task Management System ---");

        // Class-wide exception handling using try-catch around the main loop
        try {
            while (running) {
                printMenu(); // Display menu options

                // Inner try-catch block specifically for handling input errors (like non-integer)
                try {
                    System.out.print("Enter your choice: ");
                    // Read the integer choice
                    int choice = scanner.nextInt();
                    // Consume the rest of the line (the newline character)
                    scanner.nextLine();

                    // Switch statement to process the user's choice
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter priority (High, Medium, Low): ");
                            String priority = scanner.nextLine();
                            addTask(description, priority); // Call method to add task
                            break;
                        case 2: // View Pending Tasks
                            viewPendingTasks(); // Call method to view pending tasks
                            break;
                        case 3: // View All Tasks
                            viewAllTasks(); // Call method to view all tasks
                            break;
                        case 4: // Complete Next Task
                            completeNextTask(); // Call method to complete a task
                            break;
                        case 5: // Exit
                            System.out.println("Exiting Task Management System. Goodbye!");
                            running = false; // Set running flag to false to exit the loop
                            break;
                        default: // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch exception if the user enters non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input line to prevent an infinite loop
                    scanner.nextLine();
                } catch (NoSuchElementException e) {
                    // Catch exception if the input stream is closed unexpectedly
                    System.err.println("Input stream closed unexpectedly. Exiting.");
                    running = false; // Exit the loop
                }
            }
        } catch (Exception e) {
            // Broad catch for any other unexpected exceptions during the application run
            System.err.println("An unexpected error occurred during system execution.");
            // Print stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View All Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Main method to start the Team Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TeamTaskScheduler scheduler = new TeamTaskScheduler();
        scheduler.run(); // Start the main application loop
    }
}
