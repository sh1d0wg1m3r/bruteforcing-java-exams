/*
 * Exam Question #561
 * Generated on: 2025-05-11 23:29:43
 * Generated by: Account 5
 * 
 * QUESTION:
 * You are tasked with developing a simple command-line Task Management System for a small team. The system should allow users to add tasks, view pending tasks, specifically prioritize and process urgent tasks, and mark tasks as complete.
 * 
 * Each task has a description and a priority level (HIGH, MEDIUM, LOW). High-priority tasks should also be managed in a separate urgent queue for quick processing.
 * 
 * Your solution must demonstrate a strong understanding of Java collections, input handling, control flow, and error management by adhering to the following requirements:
 * 
 * **System Features:**
 * 1.  **Add Task:** Allows adding a new task with a description and a priority (HIGH, MEDIUM, or LOW).
 * 2.  **View All Pending Tasks:** Displays all tasks that have not yet been marked as completed.
 * 3.  **View Urgent Tasks:** Displays only the tasks currently in the urgent queue (which should only contain pending HIGH priority tasks). Tasks should be displayed in the order they would be processed (FIFO).
 * 4.  **Complete Task by ID:** Allows a user to mark a specific pending task as completed by providing its unique ID (or a starting prefix of the ID). If the completed task was in the urgent queue, it must be removed from there as well.
 * 5.  **Process Next Urgent Task:** Automatically completes the next task from the head of the urgent queue.
 * 6.  **Exit:** Terminates the program.
 * 
 * **Implementation Requirements:**
 * *   Use `java.util.Queue` (specifically `java.util.LinkedList` or `java.util.ArrayDeque` which implement `Queue`) to manage the urgent tasks.
 * *   Use `java.util.ArrayList` to store *all* tasks added to the system.
 * *   Declare the collection holding all tasks using the `java.util.List` interface (`List<Task> allTasks = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.err` to display all error messages (e.g., invalid input, task not found, invalid priority, ambiguous ID).
 * *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 * *   Implement robust exception handling using `try-catch` blocks. The main operational loop should be wrapped in a `try-catch` block to handle potential runtime errors, demonstrating class-wide exception handling for the core interaction logic. Handle specific expected exceptions like `InputMismatchException` and `IllegalArgumentException`.
 * *   Create a `Task` class with appropriate private fields (description, priority, completion status, and a unique identifier - e.g., using `java.util.UUID`), public getters, and methods (`markCompleted()`). Implement `equals()` and `hashCode()` in the `Task` class to ensure tasks can be correctly identified and removed from collections like the Queue.
 * *   Use an `enum` for task priority levels (`Priority { HIGH, MEDIUM, LOW }`). Include a helper method in the enum to parse priority from a user-provided string, throwing an `IllegalArgumentException` on invalid input.
 * *   Follow best practices: meaningful variable/method names, proper encapsulation, comments for clarity.
 * *   Input validation should be performed where necessary (e.g., priority string, task ID).
 * 
 * **Expected Output:**
 * The program should present a menu, accept user input for actions and task details, display task lists and messages, and use `System.err` for errors. The output format for tasks should be clear (e.g., showing a truncated ID, description, priority, and completion status).
 * 
 * **Example Interaction Snippet:**
 * ```
 * --- Task Management System ---
 * Choose an action:
 * 1. Add New Task
 * 2. View All Pending Tasks
 * 3. View Urgent Tasks
 * 4. Complete Task by ID
 * 5. Process Next Urgent Task
 * 6. Exit
 * Enter choice: 1
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Added urgent task to queue.
 * Task added successfully.
 * 
 * Choose an action:
 * ... (other tasks added)
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * --- Urgent Tasks (High Priority) ---
 * ID: abcdef..., Desc: Write report, Priority: HIGH, Completed: false
 * 
 * Choose an action:
 * ...
 * Enter choice: 5
 * --- Processing Next Urgent Task ---
 * Processed and completed urgent task: Write report
 * 
 * Choose an action:
 * ...
 * Enter choice: 4
 * Enter the start of the Task ID to complete (e.g., first 6 chars): ghi123
 * Task completed successfully: Review code
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * --- All Pending Tasks ---
 * No pending tasks. // Assuming all tasks were completed
 * 
 * Choose an action:
 * ...
 * Enter choice: 6
 * Exiting...
 * ```
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is organized into two classes: `Task` to represent individual tasks and `TaskManager` to manage the collection of tasks and user interaction.
 * 2.  **Data Structures:**
 *     *   A `List<Task>` named `allTasks` (implemented by `ArrayList`) is used to store every task created, providing easy iteration and access to all tasks regardless of their status or priority. Declaring it as `List` adheres to the requirement of using the interface.
 *     *   A `Queue<Task>` named `urgentTasksQueue` (implemented by `LinkedList`) is used specifically for high-priority tasks that are still pending. The `Queue` interface provides methods like `offer()` (add to tail), `poll()` (remove from head), and supports FIFO processing, suitable for an "urgent" queue.
 * 3.  **Task Class:** The `Task` class encapsulates task data (`id`, `description`, `priority`, `isCompleted`) with private fields and public getters. A unique ID is generated using `UUID`. The `markCompleted()` method updates the task's status. Crucially, `equals()` and `hashCode()` are overridden based on the unique ID. This is essential because the *same* `Task` objects are stored in both `allTasks` and `urgentTasksQueue`. When `urgentTasksQueue.remove(taskObject)` is called (in `completeTaskById`), the `Queue` uses the `equals()` method to find and remove the correct task object instance.
 * 4.  **Priority Enum:** An `enum` `Priority` defines the allowed priority levels, making the code more readable and preventing invalid priority strings. A static `fromString` helper method handles case-insensitive parsing of user input and throws an `IllegalArgumentException` for invalid values, demonstrating input validation.
 * 5.  **User Input (`Scanner`) and Control Flow (`switch`):** The `Scanner` class reads user input for menu choices and task details. A `switch` statement in the main `run` loop directs execution based on the user's integer choice, fulfilling the requirement.
 * 6.  **Output (`System.out` vs. `System.err`):** `System.out.println()` is used for normal program output: displaying the menu, prompts, task lists, and success messages. `System.err.println()` is used exclusively for error messages, including invalid menu choices, input parsing errors, task not found, or ambiguous ID matches, adhering to the requirement.
 * 7.  **Exception Handling (`try-catch`):**
 *     *   The core `while` loop in the `run()` method is wrapped in a `try-catch` block. This demonstrates class-wide exception handling for the main interaction flow.
 *     *   Specific `catch` blocks handle expected exceptions: `InputMismatchException` for non-integer menu input and `IllegalArgumentException` for invalid priority strings (thrown by `Priority.fromString`).
 *     *   A general `catch (Exception e)` is included to catch any other unexpected runtime errors, printing a generic error message using `System.err`. This makes the program more robust.
 * 8.  **Method Implementations:**
 *     *   `addTask()`: Reads input, validates priority using the `Priority.fromString` helper (which handles errors by throwing `IllegalArgumentException`), creates a `Task`, adds it to `allTasks`, and if HIGH priority, also adds the *same task object reference* to `urgentTasksQueue` using `offer()`.
 *     *   `viewAllPendingTasks()`: Iterates `allTasks` and prints tasks where `isCompleted()` is false.
 *     *   `viewUrgentTasks()`: Iterates `urgentTasksQueue` (using the enhanced for loop, which uses the queue's iterator) to view tasks without removing them, demonstrating non-destructive iteration of the queue.
 *     *   `completeTaskById()`: Reads an ID prefix, searches `allTasks` for a matching *pending* task. It handles cases of no match or multiple matches using `System.err`. If a unique pending task is found, it calls `markCompleted()` on the task object. If the completed task was HIGH priority, it attempts to remove it from `urgentTasksQueue` using `remove(taskObject)`. The overridden `equals()` and `hashCode()` in `Task` ensure this removal works correctly.
 *     *   `processNextUrgentTask()`: Uses `urgentTasksQueue.poll()` to retrieve and remove the head task from the queue. If a task is retrieved, it calls `markCompleted()` on that task object. Since the object reference is the same in both the queue and the `allTasks` list, marking it completed in the queue effectively updates its status in the list as well.
 * 9.  **Best Practices:** The code uses meaningful names, enforces encapsulation with private fields and public methods, includes comments to explain key parts, and validates user input where appropriate.
 * 
 * This solution effectively integrates all the required Java components into a practical scenario, demonstrating understanding of collection types, error handling, input processing, and object-oriented principles like encapsulation and overriding `equals`/`hashCode`.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.Scanner;
import java.util.UUID;
import java.util.InputMismatchException;
import java.lang.IllegalArgumentException;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW;

    /**
     * Converts a string representation to a Priority enum.
     * Case-insensitive.
     *
     * @param priorityStr The string to convert.
     * @return The corresponding Priority enum.
     * @throws IllegalArgumentException if the string does not match any priority.
     */
    public static Priority fromString(String priorityStr) {
        if (priorityStr == null) {
            throw new IllegalArgumentException("Priority cannot be null.");
        }
        try {
            return Priority.valueOf(priorityStr.trim().toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException("Invalid priority: '" + priorityStr + "'. Valid priorities are: HIGH, MEDIUM, LOW.");
        }
    }
}

// Task class representing a single task
class Task {
    private String id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * A unique ID is generated automatically.
     *
     * @param description The task description.
     * @param priority    The task priority.
     */
    public Task(String description, Priority priority) {
        this.id = UUID.randomUUID().toString(); // Generate unique ID
        this.description = description;
        this.priority = priority;
        this.isCompleted = false;
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task, including a truncated ID.
     *
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        // Display first 6 characters of the ID for brevity
        String shortId = id.length() > 6 ? id.substring(0, 6) + "..." : id;
        return String.format("ID: %s, Desc: %s, Priority: %s, Completed: %b",
                             shortId, description, priority, isCompleted);
    }

    /**
     * Checks if two Task objects are equal based on their unique ID.
     * This is necessary for methods like Queue.remove(Object).
     *
     * @param o The object to compare with.
     * @return true if the objects are equal (same ID), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id.equals(task.id); // Tasks are equal if their IDs are equal
    }

    /**
     * Generates a hash code for the Task based on its unique ID.
     * Required alongside equals().
     *
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

// Main Task Management System class
public class TaskManager {

    // Use List interface, implemented by ArrayList
    private List<Task> allTasks = new ArrayList<>();
    // Use Queue interface, implemented by LinkedList for FIFO urgent tasks
    private Queue<Task> urgentTasksQueue = new LinkedList<>();
    private Scanner scanner = new Scanner(System.in);

    /**
     * Main method to start the Task Management System.
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }

    /**
     * Runs the main loop of the Task Management System.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");
        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter choice: ");
                // Use nextInt() then nextLine() to handle the newline character
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the rest of the line after the integer

                // Use a switch statement for flow control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllPendingTasks();
                        break;
                    case 3:
                        viewUrgentTasks();
                        break;
                    case 4:
                        completeTaskById();
                        break;
                    case 5:
                        processNextUrgentTask();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting...");
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where input is not an integer for the menu choice
                System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException e) {
                // Handle specific expected errors like invalid priority string
                System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: for debugging purposes
            }
            System.out.println(); // Add a blank line for readability between interactions
        }
        scanner.close(); // Close the scanner when the program exits
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Pending Tasks");
        System.out.println("3. View Urgent Tasks");
        System.out.println("4. Complete Task by ID");
        System.out.println("5. Process Next Urgent Task");
        System.out.println("6. Exit");
    }

    /**
     * Handles adding a new task based on user input.
     * Validates priority input. Adds high priority tasks to the urgent queue.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priorityStr = scanner.nextLine();

        try {
            // Validate and parse priority using the enum helper method
            Priority priority = Priority.fromString(priorityStr);

            Task newTask = new Task(description, priority);
            allTasks.add(newTask); // Add to the main list of all tasks

            // If the task is high priority, add it to the urgent queue as well
            if (priority == Priority.HIGH) {
                urgentTasksQueue.offer(newTask); // Use offer() to add to the tail of the queue
                System.out.println("Added urgent task to queue.");
            }

            System.out.println("Task added successfully.");
        } catch (IllegalArgumentException e) {
            // Catch invalid priority input specifically
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Displays all tasks that are currently not completed.
     */
    private void viewAllPendingTasks() {
        System.out.println("--- All Pending Tasks ---");
        boolean foundPending = false;
        // Iterate through the ArrayList holding all tasks
        for (Task task : allTasks) {
            if (!task.isCompleted()) {
                System.out.println(task); // Use Task's toString() method
                foundPending = true;
            }
        }
        if (!foundPending) {
            System.out.println("No pending tasks.");
        }
    }

    /**
     * Displays tasks currently present in the urgent queue (high priority pending tasks).
     * Iterates without removing elements.
     */
    private void viewUrgentTasks() {
        System.out.println("--- Urgent Tasks (High Priority) ---");
        // Check if the queue is empty
        if (urgentTasksQueue.isEmpty()) {
            System.out.println("No urgent tasks in the queue.");
        } else {
            // Iterate through the Queue using a for-each loop (uses iterator internally)
            // This views elements without removing them
            for (Task task : urgentTasksQueue) {
                System.out.println(task); // Use Task's toString()
            }
        }
    }

    /**
     * Completes a task by matching a provided ID prefix.
     * Removes the task from the urgent queue if it was there.
     */
    private void completeTaskById() {
        System.out.print("Enter the start of the Task ID to complete (e.g., first 6 chars): ");
        String taskIdPrefix = scanner.nextLine().trim();

        List<Task> matchingTasks = new ArrayList<>();
        // Search through all tasks to find matching pending tasks
        for (Task task : allTasks) {
            // Check if the task's full ID starts with the provided prefix and is not completed
            if (task.getId().startsWith(taskIdPrefix) && !task.isCompleted()) {
                matchingTasks.add(task);
            }
        }

        if (matchingTasks.isEmpty()) {
            System.err.println("No pending task found with ID starting with '" + taskIdPrefix + "'.");
        } else if (matchingTasks.size() > 1) {
             // Use System.err to indicate ambiguity and list options
             System.err.println("Multiple pending tasks found matching ID prefix '" + taskIdPrefix + "'. Please be more specific:");
             for(Task task : matchingTasks) {
                 System.err.println(task);
             }
        } else {
            // Exactly one matching pending task found
            Task taskToComplete = matchingTasks.get(0);
            taskToComplete.markCompleted(); // Mark the task as completed

            // If the completed task was high priority, it should be removed from the urgent queue
            // Queue.remove(Object) uses the equals() method of the Task object
            if (taskToComplete.getPriority() == Priority.HIGH) {
                 urgentTasksQueue.remove(taskToComplete);
                 // No need to check the boolean result of remove; it's fine if it wasn't in the queue
                 // (e.g., already processed via processNextUrgentTask)
            }
            System.out.println("Task completed successfully: " + taskToComplete.getDescription());
        }
    }

    /**
     * Processes and completes the next task from the urgent queue (FIFO).
     */
    private void processNextUrgentTask() {
        System.out.println("--- Processing Next Urgent Task ---");
        // Use poll() to retrieve and remove the head of the queue
        Task urgentTask = urgentTasksQueue.poll();

        if (urgentTask == null) {
            System.out.println("No urgent tasks in the queue to process.");
        } else {
            // Mark the task object as completed. Since the object in the queue
            // is the same reference as in the allTasks list, this updates it everywhere.
            urgentTask.markCompleted();
            System.out.println("Processed and completed urgent task: " + urgentTask.getDescription());
        }
    }
}
