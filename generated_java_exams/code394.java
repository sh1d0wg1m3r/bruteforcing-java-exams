/*
 * Exam Question #394
 * Generated on: 2025-05-11 23:04:41
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Package Delivery Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a package delivery system for a small logistics company. The system needs to manage incoming packages, load them onto a delivery truck with limited capacity, and simulate the delivery process.
 * 
 * **Problem Description:**
 * 
 * Implement a Java program that simulates the following workflow:
 * 
 * 1.  **Incoming Packages:** New packages arrive and are placed in a waiting area, represented by a queue.
 * 2.  **Delivery Truck:** A delivery truck is available with a maximum number of packages it can hold at any one time.
 * 3.  **Loading:** The driver loads packages from the waiting area queue onto the truck until the truck is full or the waiting area is empty.
 * 4.  **Delivery:** Once loaded, the truck simulates delivering the packages currently on board. After delivery, the truck becomes empty again.
 * 5.  **System Interaction:** The user interacts with the system via a command-line interface to perform actions like adding packages, loading the truck, initiating delivery, viewing pending packages, and viewing loaded packages.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical constraints:
 * 
 * 1.  Use a `java.util.Queue` (specifically `LinkedList` implementing `Queue`) to manage incoming packages waiting to be loaded.
 * 2.  Use a `java.util.ArrayList` as the concrete implementation for storing packages *currently loaded* on the truck.
 * 3.  Use the `java.util.List` interface as the declared type for the collection of packages loaded on the truck.
 * 4.  Use `java.util.Scanner` to read user input from the console.
 * 5.  Use a `switch` statement to handle the main menu options provided to the user.
 * 6.  Use `System.err` to print all error messages (e.g., invalid input, truck full, truck empty).
 * 7.  Use `System.out` to print all normal output (e.g., menu, prompts, success messages, package details).
 * 8.  Implement robust exception handling using `try-catch` blocks. Include:
 *     *   Handling potential input errors (e.g., non-numeric input where a number is expected).
 *     *   Handling business logic errors (e.g., trying to load a full truck, trying to deliver an empty truck). You may define a custom exception for business logic errors if desired.
 *     *   A general `try-catch` block in the main execution flow to catch unexpected errors and print a generic error message.
 * 9.  Design your classes following best practices:
 *     *   Use private fields and public methods (encapsulation).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and basic Javadoc.
 *     *   Implement input validation where necessary (e.g., package weight, truck capacity).
 * 
 * **Classes to Consider:**
 * 
 * *   `Package`: Represents a single package with attributes like a unique ID, destination address, and weight.
 * *   `DeliveryTruck`: Represents the truck with a maximum capacity and a list of packages currently loaded. It should have methods for loading and delivering.
 * *   `DeliverySystem`: The main class that orchestrates the simulation, holds the queue of incoming packages, manages the truck, and handles user interaction.
 * 
 * **User Interface (Example Interaction Flow):**
 * 
 * ```
 * --- Package Delivery Simulation ---
 * 1. Add New Package to Queue
 * 2. Load Truck from Queue
 * 3. Simulate Delivery
 * 4. View Pending Packages (Queue)
 * 5. View Loaded Packages (Truck)
 * 6. Exit
 * Enter your choice: 1
 * Enter Package ID: 101
 * Enter Destination Address: 123 Main St
 * Enter Weight (kg): 5.5
 * Package 101 added to the queue.
 * 
 * Enter your choice: 1
 * Enter Package ID: 102
 * Enter Destination Address: 456 Oak Ave
 * Enter Weight (kg): 10.0
 * Package 102 added to the queue.
 * 
 * Enter your choice: 2
 * Enter Truck Capacity: 1
 * Truck capacity set to 1.
 * Loading packages onto the truck...
 * Package 101 loaded.
 * Truck is now full or queue is empty.
 * 
 * Enter your choice: 4
 * --- Pending Packages in Queue ---
 * Package ID: 102, Address: 456 Oak Ave, Weight: 10.0 kg
 * -----------------------------------
 * 
 * Enter your choice: 5
 * --- Packages Loaded on Truck ---
 * Package ID: 101, Address: 123 Main St, Weight: 5.5 kg
 * ----------------------------------
 * 
 * Enter your choice: 3
 * Simulating delivery...
 * Delivering Package ID: 101 to 123 Main St (5.5 kg)
 * Delivery simulation complete. Truck is now empty.
 * 
 * Enter your choice: 5
 * --- Packages Loaded on Truck ---
 * (Truck is empty)
 * ----------------------------------
 * 
 * Enter your choice: 6
 * Exiting simulation.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `List`, `ArrayList`, `Scanner`, `switch`.
 * *   Correct usage of `System.out` and `System.err`.
 * *   Effective implementation of exception handling (`try-catch`), including input validation and business logic errors.
 * *   Proper object-oriented design (encapsulation, meaningful names).
 * *   Clear and well-commented code.
 * *   The simulation logic functions correctly according to the requirements.
 *
 * EXPLANATION:
 * This solution implements a basic package delivery simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Package`: A simple Plain Old Java Object (POJO) representing a package with private fields (`packageId`, `destinationAddress`, `weightKg`) and public getters, demonstrating encapsulation. It includes validation for positive weight in its constructor.
 *     *   `DeliveryTruck`: Manages the packages currently loaded. It uses a `List<Package>` (`loadedPackages`) declared as the interface type but instantiated as an `ArrayList`. This adheres to the requirement of using both `List` and `ArrayList`. It has a `maxCapacity` and methods for `loadPackage`, `simulateDelivery`, `isFull`, `isEmpty`, etc. `getLoadedPackages` returns a *copy* of the list to prevent external modification, upholding encapsulation.
 *     *   `DeliverySystem`: The main class that orchestrates the simulation. It holds the `Queue<Package>` (`incomingPackagesQueue`) for packages awaiting loading, instantiated as a `LinkedList`. It also manages the `DeliveryTruck` and the `Scanner` for user input. The `run` method contains the main application loop.
 * 
 * 2.  **Component Usage:**
 *     *   `Queue`: `incomingPackagesQueue` is a `LinkedList` used as a `Queue`. `offer()` is used to add packages (safer than `add` as it doesn't throw an exception if the queue is bounded, though `LinkedList` is unbounded). `poll()` is used to remove packages from the front of the queue when loading the truck. Iteration is done directly on the queue in `viewPendingPackages` to display elements without removing them.
 *     *   `ArrayList` & `List`: `loadedPackages` in `DeliveryTruck` is declared as `List<Package>` and initialized as `new ArrayList<>()`. This demonstrates programming to the interface (`List`) while using a concrete implementation (`ArrayList`) for storing the loaded packages.
 *     *   `Scanner`: Used in `DeliverySystem` to read user input for menu choices, package details, and truck capacity.
 *     *   `Switch`: The `switch` statement in the `run` method handles the different menu options selected by the user.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid input, truck being full, or an empty truck attempt.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, and package details.
 * 
 * 3.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** `try-catch (InputMismatchException e)` blocks are used around `scanner.nextInt()` and `scanner.nextDouble()` calls to catch cases where the user enters non-numeric input when a number is expected.
 *     *   **Business Logic Errors:** A custom exception `DeliveryException` is defined. This exception is thrown by the `Package` constructor (for invalid weight), the `DeliveryTruck` constructor (for invalid capacity), and the `DeliveryTruck.simulateDelivery()` method (if the truck is empty). These are caught in the `DeliverySystem` methods (`addNewPackage`, `setupTruck`, `simulateDelivery`) and an informative message is printed to `System.err`.
 *     *   **General Exception Handling:** The main `while` loop in the `run` method is wrapped in a broad `try-catch (Exception e)`. This serves as a catch-all for any unexpected errors that might occur within the loop's execution, preventing the program from crashing abruptly and printing a generic error message (and stack trace for debugging) to `System.err`.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters/methods are used in `Package` and `DeliveryTruck`. `DeliveryTruck.getLoadedPackages()` returns a copy to protect the internal state.
 *     *   **Meaningful Names:** Class names (`Package`, `DeliveryTruck`, `DeliverySystem`), variable names (`incomingPackagesQueue`, `loadedPackages`, `maxCapacity`), and method names (`addNewPackage`, `loadTruck`, `simulateDelivery`) are descriptive.
 *     *   **Comments and Documentation:** Javadoc-style comments are included for classes and key methods, explaining their purpose, parameters, and potential exceptions. Inline comments clarify specific logic.
 *     *   **Input Validation:** Basic checks are performed for positive weight/capacity and non-empty addresses.
 *     *   **Error Handling:** Differentiated output streams (`System.out` vs. `System.err`) and specific exception types (`InputMismatchException`, `DeliveryException`, general `Exception`) are used.
 *     *   **Clean Code Structure:** The logic is divided into well-defined methods within the relevant classes (`addNewPackage`, `loadTruck`, etc., in `DeliverySystem`; `loadPackage`, `simulateDelivery` in `DeliveryTruck`).
 * 
 * This solution provides a solid foundation demonstrating the required concepts in a practical, albeit simplified, simulation context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for business logic errors
class DeliveryException extends Exception {
    public DeliveryException(String message) {
        super(message);
    }
}

/**
 * Represents a package to be delivered.
 */
class Package {
    private int packageId;
    private String destinationAddress;
    private double weightKg;

    /**
     * Constructs a new Package.
     * @param packageId Unique ID for the package.
     * @param destinationAddress The delivery address.
     * @param weightKg The weight of the package in kilograms.
     * @throws DeliveryException if weight is non-positive.
     */
    public Package(int packageId, String destinationAddress, double weightKg) throws DeliveryException {
        if (weightKg <= 0) {
            throw new DeliveryException("Package weight must be positive.");
        }
        this.packageId = packageId;
        this.destinationAddress = destinationAddress;
        this.weightKg = weightKg;
    }

    // Getters
    public int getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public double getWeightKg() {
        return weightKg;
    }

    @Override
    public String toString() {
        return "Package ID: " + packageId + ", Address: " + destinationAddress + ", Weight: " + weightKg + " kg";
    }
}

/**
 * Represents the delivery truck with a limited capacity.
 */
class DeliveryTruck {
    private int maxCapacity;
    private List<Package> loadedPackages; // Using List interface, implemented by ArrayList

    /**
     * Constructs a DeliveryTruck with a specified capacity.
     * @param maxCapacity The maximum number of packages the truck can hold.
     * @throws DeliveryException if capacity is non-positive.
     */
    public DeliveryTruck(int maxCapacity) throws DeliveryException {
        if (maxCapacity <= 0) {
            throw new DeliveryException("Truck capacity must be positive.");
        }
        this.maxCapacity = maxCapacity;
        this.loadedPackages = new ArrayList<>(); // Concrete implementation is ArrayList
    }

    /**
     * Loads a package onto the truck if there is capacity.
     * @param pkg The package to load.
     * @return true if loaded successfully, false if truck is full.
     */
    public boolean loadPackage(Package pkg) {
        if (loadedPackages.size() < maxCapacity) {
            loadedPackages.add(pkg);
            return true;
        }
        return false; // Truck is full
    }

    /**
     * Gets the list of packages currently loaded on the truck.
     * Returns an unmodifiable list to prevent external modification.
     * @return A List of loaded packages.
     */
    public List<Package> getLoadedPackages() {
        // Return a copy or an unmodifiable list to maintain encapsulation
        return new ArrayList<>(loadedPackages); // Return a copy
    }

    /**
     * Simulates the delivery of all loaded packages.
     * Clears the truck after delivery.
     * @throws DeliveryException if the truck is empty.
     */
    public void simulateDelivery() throws DeliveryException {
        if (loadedPackages.isEmpty()) {
            throw new DeliveryException("Truck is empty. Cannot simulate delivery.");
        }
        System.out.println("Simulating delivery...");
        for (Package pkg : loadedPackages) {
            System.out.println("Delivering " + pkg.toString().replace("Package ", "Package "));
        }
        loadedPackages.clear(); // Clear the truck after delivery
        System.out.println("Delivery simulation complete. Truck is now empty.");
    }

    /**
     * Checks if the truck is full.
     * @return true if full, false otherwise.
     */
    public boolean isFull() {
        return loadedPackages.size() >= maxCapacity;
    }

    /**
     * Checks if the truck is empty.
     * @return true if empty, false otherwise.
     */
    public boolean isEmpty() {
        return loadedPackages.isEmpty();
    }

    /**
     * Gets the current number of packages loaded.
     * @return The number of loaded packages.
     */
    public int getCurrentLoad() {
        return loadedPackages.size();
    }

    /**
     * Gets the maximum capacity of the truck.
     * @return The maximum capacity.
     */
    public int getMaxCapacity() {
        return maxCapacity;
    }
}

/**
 * Main class orchestrating the package delivery simulation.
 */
public class DeliverySystem {

    private Queue<Package> incomingPackagesQueue; // Using Queue interface, implemented by LinkedList
    private DeliveryTruck truck;
    private Scanner scanner;
    private int nextPackageId = 1; // Simple ID generator

    public DeliverySystem() {
        this.incomingPackagesQueue = new LinkedList<>(); // Concrete implementation is LinkedList
        this.scanner = new Scanner(System.in);
    }

    /**
     * Sets up the delivery truck with a specified capacity.
     */
    private void setupTruck() {
        while (this.truck == null) {
            System.out.print("Enter Truck Capacity: ");
            try {
                int capacity = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over
                this.truck = new DeliveryTruck(capacity);
                System.out.println("Truck capacity set to " + capacity + ".");
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a whole number for capacity.");
                scanner.nextLine(); // Consume the invalid input
            } catch (DeliveryException e) {
                System.err.println("Error setting truck capacity: " + e.getMessage());
            }
        }
    }

    /**
     * Adds a new package to the incoming queue based on user input.
     */
    private void addNewPackage() {
        try {
            System.out.print("Enter Destination Address: ");
            String address = scanner.nextLine();

            System.out.print("Enter Weight (kg): ");
            double weight = scanner.nextDouble();
            scanner.nextLine(); // Consume newline left-over

            // Basic input validation
            if (address == null || address.trim().isEmpty()) {
                 throw new DeliveryException("Destination address cannot be empty.");
            }

            Package newPackage = new Package(nextPackageId++, address, weight);
            incomingPackagesQueue.offer(newPackage); // offer is safer than add for queues
            System.out.println("Package " + newPackage.getPackageId() + " added to the queue.");

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid number for weight.");
            scanner.nextLine(); // Consume the invalid input
        } catch (DeliveryException e) {
            System.err.println("Error adding package: " + e.getMessage());
        } catch (Exception e) { // Catch any other unexpected errors during input
             System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace for debugging
        }
    }

    /**
     * Loads packages from the queue onto the truck.
     */
    private void loadTruck() {
        if (truck == null) {
            System.err.println("Truck not set up yet. Please set capacity first.");
            return;
        }

        if (truck.isFull()) {
            System.err.println("Truck is already full.");
            return;
        }

        if (incomingPackagesQueue.isEmpty()) {
            System.out.println("No packages in the queue to load.");
            return;
        }

        System.out.println("Loading packages onto the truck...");
        while (!truck.isFull() && !incomingPackagesQueue.isEmpty()) {
            Package pkg = incomingPackagesQueue.poll(); // Get and remove package from queue
            if (truck.loadPackage(pkg)) {
                System.out.println("Package " + pkg.getPackageId() + " loaded.");
            } else {
                // This case should ideally not happen due to the isFull check,
                // but as a safeguard or if weight limits were added later.
                System.err.println("Failed to load package " + pkg.getPackageId() + ". Truck might be full.");
                // Optionally put the package back if it couldn't be loaded for some reason
                // incomingPackagesQueue.offer(pkg);
            }
        }

        if (truck.isFull()) {
            System.out.println("Truck is now full.");
        } else if (incomingPackagesQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        }
    }

    /**
     * Initiates the delivery simulation for packages on the truck.
     */
    private void simulateDelivery() {
        if (truck == null) {
            System.err.println("Truck not set up yet. Please set capacity first.");
            return;
        }
        try {
            truck.simulateDelivery();
        } catch (DeliveryException e) {
            System.err.println("Error during delivery simulation: " + e.getMessage());
        } catch (Exception e) { // Catch any other unexpected errors during delivery
             System.err.println("An unexpected error occurred during delivery: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace for debugging
        }
    }

    /**
     * Displays packages currently waiting in the queue.
     */
    private void viewPendingPackages() {
        System.out.println("--- Pending Packages in Queue ---");
        if (incomingPackagesQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing using the queue's iterator
            for (Package pkg : incomingPackagesQueue) {
                System.out.println(pkg);
            }
        }
        System.out.println("-----------------------------------");
    }

    /**
     * Displays packages currently loaded on the truck.
     */
    private void viewLoadedPackages() {
        System.out.println("--- Packages Loaded on Truck ---");
        if (truck == null || truck.isEmpty()) {
            System.out.println("(Truck is empty)");
        } else {
            // Get the list from the truck and iterate
            List<Package> loaded = truck.getLoadedPackages();
            for (Package pkg : loaded) {
                System.out.println(pkg);
            }
        }
        System.out.println("----------------------------------");
    }

    /**
     * Displays the main menu and gets user choice.
     * @return The user's choice.
     */
    private int displayMenuAndGetChoice() {
        System.out.println("\n--- Package Delivery Simulation ---");
        System.out.println("1. Add New Package to Queue");
        System.out.println("2. Load Truck from Queue");
        System.out.println("3. Simulate Delivery");
        System.out.println("4. View Pending Packages (Queue)");
        System.out.println("5. View Loaded Packages (Truck)");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
        try {
            int choice = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over
            return choice;
        } catch (InputMismatchException e) {
            scanner.nextLine(); // Consume the invalid input
            return -1; // Indicate invalid input
        }
    }

    /**
     * Runs the main simulation loop.
     */
    public void run() {
        setupTruck(); // Setup truck capacity at the start

        boolean running = true;
        while (running) {
            // Class-wide exception handling for the main loop
            try {
                int choice = displayMenuAndGetChoice();

                switch (choice) {
                    case 1:
                        addNewPackage();
                        break;
                    case 2:
                        loadTruck();
                        break;
                    case 3:
                        simulateDelivery();
                        break;
                    case 4:
                        viewPendingPackages();
                        break;
                    case 5:
                        viewLoadedPackages();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting simulation.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (Exception e) {
                // Catch any unhandled exceptions that bubble up
                System.err.println("An unexpected fatal error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace for debugging
                // Optionally, set running = false to exit on fatal error
                // running = false;
            }
        }
        scanner.close(); // Close the scanner when done
    }

    public static void main(String[] args) {
        DeliverySystem system = new DeliverySystem();
        system.run();
    }
}
