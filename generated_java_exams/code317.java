/*
 * Exam Question #317
 * Generated on: 2025-05-11 22:54:16
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based application to manage tasks for a small team. New tasks arrive and are placed in an incoming queue to be processed one by one. A complete history of all tasks, regardless of their current status, must also be maintained.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. It must have:
 *     *   A unique integer `id`.
 *     *   A `String` `description`.
 *     *   A `String` `status` (e.g., "PENDING", "COMPLETED").
 *     *   Private fields with public getter methods.
 *     *   A method to set the status.
 *     *   A meaningful `toString()` method for display.
 * 2.  **Task Management Logic:** Create a class `TaskManager` to handle task operations. It must contain:
 *     *   A `java.util.Queue<Task>` to hold tasks that are waiting to be processed (incoming tasks). Use `java.util.LinkedList` as the concrete implementation for the Queue.
 *     *   A `java.util.List<Task>` (declared as `List`, implemented as `java.util.ArrayList`) to store a history of all tasks ever created.
 *     *   A mechanism to generate unique task IDs starting from 1.
 *     *   A public method `addTask(String description)`: Creates a new `Task` object, assigns a unique ID, sets its status to "PENDING", adds it to both the incoming queue and the history list, and returns the created task.
 *     *   A public method `processNextIncomingTask()`: Removes the task at the head of the incoming queue. It must update the status of this task object (which is also present in the history list) to "COMPLETED". If the incoming queue is empty, it should throw a custom exception (e.g., `EmptyQueueException`). Returns the processed task.
 *     *   A public method `viewAllTasks()`: Returns the complete list of all tasks from the history list.
 * 3.  **Console Application:** Create a main class (e.g., `TaskApp`) with a `main` method that provides a console interface for the user.
 *     *   Use `java.util.Scanner` to read user input (menu choices and task descriptions).
 *     *   Implement a loop that presents a menu with the following options:
 *         1.  Add New Task
 *         2.  Process Next Incoming Task
 *         3.  View All Tasks
 *         4.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, successful operation messages, and task details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, errors during task processing).
 *     *   Implement exception handling using `try-catch` blocks within the main application loop to gracefully handle potential issues like invalid numeric input (`NumberFormatException`) when reading the menu choice or attempting to process a task from an empty queue (`EmptyQueueException`).
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments for clarity.
 *     *   Perform basic input validation (e.g., handling non-numeric input for menu choice).
 *     *   Implement proper error handling as described above.
 *     *   Structure the code into separate classes logically.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, allowing them to perform the operations described. Example interaction flows should demonstrate adding tasks, processing tasks, viewing the history, and handling errors (like trying to process when the queue is empty or entering non-numeric input).
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Buy groceries
 * 
 * Task added: Buy groceries (ID: 1)
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Prepare presentation
 * 
 * Task added: Prepare presentation (ID: 2)
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 3
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: Buy groceries, Status: PENDING
 * Task ID: 2, Description: Prepare presentation, Status: PENDING
 * -----------------
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 2
 * 
 * Processed task: Buy groceries (ID: 1)
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 3
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: Buy groceries, Status: COMPLETED
 * Task ID: 2, Description: Prepare presentation, Status: PENDING
 * -----------------
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 2
 * 
 * Processed task: Prepare presentation (ID: 2)
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 2
 * 
 * Error: No tasks in the incoming queue.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: abc
 * 
 * Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 5
 * 
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Incoming Task
 * 3. View All Tasks
 * 4. Exit
 * Enter choice: 4
 * 
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * **Assessment:**
 * 
 * Your solution will be assessed on:
 * *   Correct implementation and usage of all required Java components (Queue, ArrayList, List, Scanner, Switch, System.err, System.out, try-catch).
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Logical correctness of task management operations (adding, processing, viewing).
 * *   Robustness of error handling for invalid input and empty queue scenarios.
 * *   Code clarity, readability, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** Represents a single task with an ID, description, and status. Fields are private, adhering to encapsulation. Getters provide controlled access. `setStatus` allows modifying the status. `toString` provides a convenient way to print task details. Constants are used for status strings for clarity and maintainability.
 * 
 * 2.  **`EmptyQueueException` Class:** A simple custom checked exception is created to specifically signal the condition when `processNextIncomingTask` is called but the incoming queue is empty.
 * 
 * 3.  **`TaskManager` Class:**
 *     *   Uses a `java.util.Queue<Task>` (`incomingTasks`) implemented by `java.util.LinkedList` to manage tasks waiting for processing in a FIFO (First-In, First-Out) manner.
 *     *   Uses a `java.util.List<Task>` (`allTasks`) declared using the interface and implemented by `java.util.ArrayList` to store a historical record of all tasks created.
 *     *   `nextTaskId` ensures unique IDs for tasks.
 *     *   `addTask`: Creates a new `Task`, adds it to *both* the `allTasks` list and the `incomingTasks` queue, and increments the ID counter.
 *     *   `processNextIncomingTask`: Checks if the queue is empty and throws `EmptyQueueException` if it is. Otherwise, it uses `queue.poll()` to remove and return the head of the queue. Crucially, since both the queue and the list hold references to the *same* `Task` objects, updating the status of the task object obtained from `poll()` automatically updates its status as seen when viewing the `allTasks` list.
 *     *   `viewAllTasks`: Simply returns the `allTasks` list.
 * 
 * 4.  **`TaskApp` Class (Main Application):**
 *     *   The `main` method contains the core application loop.
 *     *   `java.util.Scanner` is used to get user input from the console.
 *     *   A `while(true)` loop keeps the application running until the user chooses to exit.
 *     *   `displayMenu()` is a helper method using `System.out` to print the menu options.
 *     *   A large `try-catch` block wraps the input reading (`scanner.nextLine()`, `Integer.parseInt`) and the `switch` statement that calls the `TaskManager` methods. This provides class-wide (within the scope of `main`) exception handling.
 *     *   `Integer.parseInt(input)` is enclosed within the `try` block because it can throw a `NumberFormatException` if the user enters non-numeric text. This exception is caught and an error message is printed to `System.err`.
 *     *   The call to `taskManager.processNextIncomingTask()` is also within the `try` block because it is declared to throw `EmptyQueueException`. This custom exception is caught and an informative error message is printed to `System.err`.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime exceptions, printing a generic error message to `System.err`.
 *     *   A `switch` statement controls the program flow based on the validated integer choice.
 *     *   `System.out` is used for all normal output, such as confirming task additions, showing processed tasks, and listing all tasks.
 *     *   `System.err` is used specifically for error conditions, such as invalid menu choices (handled in the `default` case of the switch) and exceptions caught by the `catch` blocks.
 *     *   Option 4 closes the `Scanner` resource and exits the application using `System.exit(0)`.
 *     *   Basic input validation for the task description (checking if empty) is included.
 * 
 * This solution effectively integrates all required components in a practical scenario, demonstrates proper object-oriented design principles, and includes robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Custom exception for empty queue scenario
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private String status;

    // Constants for task status
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_COMPLETED = "COMPLETED";

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = STATUS_PENDING; // New tasks are pending by default
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status (e.g., STATUS_PENDING, STATUS_COMPLETED).
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages collections of tasks and operations
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> incomingTasks;
    // List for all tasks created (history)
    private List<Task> allTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // Initialize collections
        incomingTasks = new LinkedList<>(); // LinkedList implements Queue
        allTasks = new ArrayList<>();     // ArrayList implements List
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Adds the task to both the incoming queue and the history list.
     * @param description The description of the new task.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        incomingTasks.offer(newTask); // Add to the end of the queue
        allTasks.add(newTask);       // Add to the history list
        return newTask;
    }

    /**
     * Processes the next task from the incoming queue.
     * Removes the task from the queue and updates its status in the history list.
     * @return The task that was processed.
     * @throws EmptyQueueException If the incoming queue is empty.
     */
    public Task processNextIncomingTask() throws EmptyQueueException {
        if (incomingTasks.isEmpty()) {
            // Throw custom exception if queue is empty
            throw new EmptyQueueException("No tasks in the incoming queue.");
        }

        // Poll removes the head of the queue
        Task taskToProcess = incomingTasks.poll();

        // Update the status of the task. Since the List and Queue
        // hold references to the same Task objects, updating the polled
        // object's status also updates it in the 'allTasks' list.
        taskToProcess.setStatus(Task.STATUS_COMPLETED);

        return taskToProcess;
    }

    /**
     * Returns the list of all tasks ever created.
     * @return A List containing all Task objects.
     */
    public List<Task> viewAllTasks() {
        return allTasks;
    }
}

// Main application class with console interface
public class TaskApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Incoming Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. Exit");
    }

    /**
     * Main method to run the Task Management application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {

        // Main application loop
        while (true) {
            displayMenu();
            System.out.print("Enter choice: ");

            // Use a try-catch block to handle potential input errors and exceptions
            try {
                String input = scanner.nextLine();
                // Attempt to parse input as an integer (potential NumberFormatException)
                int choice = Integer.parseInt(input);

                // Use a switch statement to handle different menu choices
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println(System.lineSeparator() + "Task description cannot be empty.");
                        } else {
                            Task newTask = taskManager.addTask(description.trim());
                            // Use System.out for success messages
                            System.out.println(System.lineSeparator() + "Task added: " + newTask.getDescription() + " (ID: " + newTask.getId() + ")");
                        }
                        break;

                    case 2: // Process Next Incoming Task
                        // Call method that might throw EmptyQueueException
                        Task processedTask = taskManager.processNextIncomingTask();
                        // Use System.out for successful processing
                        System.out.println(System.lineSeparator() + "Processed task: " + processedTask.getDescription() + " (ID: " + processedTask.getId() + ")");
                        break;

                    case 3: // View All Tasks
                        List<Task> allTasks = taskManager.viewAllTasks();
                        if (allTasks.isEmpty()) {
                            System.out.println(System.lineSeparator() + "No tasks available.");
                        } else {
                            // Use System.out to display task list
                            System.out.println(System.lineSeparator() + "--- All Tasks ---");
                            for (Task task : allTasks) {
                                System.out.println(task); // Uses Task.toString()
                            }
                            System.out.println("-----------------");
                        }
                        break;

                    case 4: // Exit
                        System.out.println(System.lineSeparator() + "Exiting Task Manager. Goodbye!");
                        scanner.close(); // Close the scanner resource
                        System.exit(0); // Terminate the application
                        break;

                    default:
                        // Use System.err for invalid menu choice
                        System.err.println(System.lineSeparator() + "Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Catch exception if input is not a valid integer
                System.err.println(System.lineSeparator() + "Invalid input. Please enter a number.");
            } catch (EmptyQueueException e) {
                // Catch the custom exception for empty queue
                System.err.println(System.lineSeparator() + "Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions for robustness
                System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
            }

            // Add a blank line for better readability between menu iterations
            System.out.println();
        }
    }
}
