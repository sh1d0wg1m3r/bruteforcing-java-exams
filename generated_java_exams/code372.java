/*
 * Exam Question #372
 * Generated on: 2025-05-11 23:01:36
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Service Desk Ticketing System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified Service Desk application. Users submit support tickets, which are then queued for processing by agents. An agent can pick up the next waiting ticket, work on it, and eventually resolve it. The system needs to manage waiting tickets, the currently handled ticket, and a history of resolved tickets.
 * 
 * **Requirements:**
 * 
 * Implement a Java console application that simulates this Service Desk. The application should provide a menu-driven interface for user interaction.
 * 
 * 1.  **Ticket Management:**
 *     *   Create a `Ticket` class with appropriate fields (e.g., unique ID, description, status).
 *     *   Tickets should be assigned a unique ID automatically upon creation.
 *     *   Status should change as the ticket moves through the system (e.g., "Waiting", "In Progress", "Resolved").
 * 
 * 2.  **Service Desk Core Logic:**
 *     *   Create a `ServiceDesk` class responsible for managing the tickets.
 *     *   Use a `Queue<Ticket>` to hold tickets that are waiting to be picked up (FIFO).
 *     *   Use a `List<Ticket>` (implemented by `ArrayList`) to store tickets that have been resolved.
 *     *   Maintain a reference to the single ticket currently being handled by an agent.
 * 
 * 3.  **Functionality (Menu Options):**
 *     *   **1. Submit New Ticket:** Prompts the user for a ticket description and adds a new ticket to the waiting queue.
 *     *   **2. Pickup Next Ticket:** Removes the next ticket from the waiting queue and sets it as the currently handled ticket. If the queue is empty, display an error. If a ticket is already being handled, display a message indicating that the current ticket must be resolved first.
 *     *   **3. Resolve Current Ticket:** Prompts the user for resolution notes, marks the current ticket as "Resolved", adds it to the resolved tickets list, and clears the currently handled ticket reference. If no ticket is currently being handled, display an error.
 *     *   **4. View Waiting Tickets:** Displays all tickets currently in the waiting queue.
 *     *   **5. View Current Ticket:** Displays the details of the ticket currently being handled, or a message if none is being handled.
 *     *   **6. View Resolved Tickets:** Displays all tickets that have been resolved.
 *     *   **7. Exit:** Terminates the application.
 * 
 * 4.  **Technical Requirements:**
 *     *   Must use `java.util.Queue`.
 *     *   Must use `java.util.ArrayList`.
 *     *   Must use `java.util.List` interface (e.g., declare a variable as `List<Ticket>`).
 *     *   Must use `java.util.Scanner` for all user input.
 *     *   Must use a `switch` statement for handling the main menu choices.
 *     *   Must use `System.err.println()` for all error messages (e.g., queue empty, no current ticket).
 *     *   Must use `System.out.println()` for all normal output (menu, prompts, ticket details, success messages).
 *     *   Must implement class-wide exception handling using `try-catch` blocks, specifically to handle invalid user input (non-numeric menu choice) and potential operational errors (like trying to pickup from an empty queue or resolve when none is active).
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc for classes/public methods).
 *     *   Include input validation (e.g., ticket description should not be empty).
 *     *   Implement proper error handling as specified in technical requirements.
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * The application should display a clear menu. User interactions should lead to appropriate system responses, including success messages, ticket details, and error messages using the correct output stream (`System.out` or `System.err`).
 * 
 * ```
 * --- Service Desk Menu ---
 * 1. Submit New Ticket
 * 2. Pickup Next Ticket
 * 3. Resolve Current Ticket
 * 4. View Waiting Tickets
 * 5. View Current Ticket
 * 6. View Resolved Tickets
 * 7. Exit
 * Enter your choice:
 * ```
 * (Example interaction follows user input and system response based on choices)
 * 
 * **Example Error Output:**
 * ```
 * Error: No tickets currently waiting in the queue.
 * ```
 * ```
 * Error: No ticket is currently being handled.
 * ```
 * ```
 * Error: Invalid input. Please enter a number between 1 and 7.
 * ```
 * 
 * ```
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * **Constraint:** Solve this problem using only standard Java SE libraries.
 *
 * EXPLANATION:
 * This solution implements a simplified Service Desk system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with `ticketId`, `description`, `status`, and `resolutionNotes`.
 *     *   A `static int nextId` ensures each new ticket gets a unique, auto-incrementing ID.
 *     *   Fields are `private` adhering to encapsulation.
 *     *   Public getters provide access to the ticket's state.
 *     *   `markInProgress()` and `markResolved()` methods are used to change the ticket's status, controlling state transitions internally.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`ServiceDesk` Class:**
 *     *   This class encapsulates the core logic and data structures.
 *     *   `private Queue<Ticket> waitingTickets;`: Uses a `Queue` (implemented by `LinkedList`) to store tickets waiting for an agent. `Queue` is appropriate here because tickets are processed in First-In, First-Out (FIFO) order using `offer()` to add and `poll()` to remove.
 *     *   `private List<Ticket> resolvedTickets;`: Uses a `List` (implemented by `ArrayList`) to store tickets that have been resolved. `List` is suitable as it maintains insertion order and allows easy iteration over the history of resolved tickets.
 *     *   `private Ticket currentTicket;`: Stores the single ticket currently being handled. `null` when no ticket is active.
 *     *   `submitTicket(String description)`: Creates a `Ticket` object and adds it to the `waitingTickets` queue using `offer()`. Includes input validation for the description.
 *     *   `pickupNextTicket()`: Uses `poll()` to remove and return the head of the `waitingTickets` queue. It checks if the queue is empty or if a ticket is already active, throwing `IllegalStateException` if conditions aren't met. The picked-up ticket's status is updated to "In Progress".
 *     *   `resolveCurrentTicket(String resolutionNotes)`: Updates the `currentTicket`'s status to "Resolved", adds it to the `resolvedTickets` list, and sets `currentTicket` to `null`. It validates that a ticket is currently active and that resolution notes are provided, throwing exceptions if not.
 *     *   `printWaitingTickets()` and `printResolvedTickets()`: Iterate over the respective collections and print ticket details using `System.out.println()`. These methods provide a controlled way to view the data without exposing the internal collections directly.
 *     *   `getCurrentTicket()`: Provides access to the currently handled ticket.
 * 
 * 3.  **`ServiceDeskApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Creates instances of `ServiceDesk` and `Scanner`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   `printMenu()` displays the options using `System.out.println()`.
 *     *   User input is read using the `Scanner`.
 *     *   A `switch` statement is used to handle the different menu options, calling the appropriate methods on the `ServiceDesk` object.
 *     *   **Exception Handling:**
 *         *   A `try-catch` block surrounds the input reading and the `switch` statement.
 *         *   `InputMismatchException` is caught specifically for cases where the user enters non-integer input for the menu choice. An error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input, preventing an infinite loop.
 *         *   `IllegalArgumentException` (thrown by `submitTicket` and `resolveCurrentTicket` for empty input) and `IllegalStateException` (thrown by `pickupNextTicket` and `resolveCurrentTicket` for invalid state) are caught together. Their error messages are printed to `System.err`.
 *         *   A general `Exception` catch is included as a fallback for any other unexpected errors, printing to `System.err` and showing the stack trace for debugging.
 *     *   `System.out.println()` is used for the menu, prompts, success messages, and ticket listings.
 *     *   `System.err.println()` is used exclusively for error messages as required.
 *     *   The `Scanner` is closed after the main loop terminates.
 * 
 * **Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Ticket`, `ServiceDesk`, `ServiceDeskApp`) with encapsulation (private fields, public methods).
 * *   **Collections Framework:** Effective use of `Queue` (specifically `LinkedList`) for managing a waiting line and `List` (specifically `ArrayList`) for storing a history.
 * *   **Input/Output:** Using `Scanner` for console input, `System.out` for standard output, and `System.err` for error output.
 * *   **Control Flow:** Using a `while` loop for the main application loop and a `switch` statement for menu navigation.
 * *   **Exception Handling:** Implementing robust error handling using `try-catch` blocks to manage specific exceptions (`InputMismatchException`, `IllegalArgumentException`, `IllegalStateException`) and a general `Exception` catch, demonstrating defensive programming.
 * *   **Static Members:** Using a `static` field (`nextId`) for class-level state (unique ID generation).
 * *   **String Manipulation:** Basic usage for descriptions and notes.
 * *   **Best Practices:** Adherence to requirements regarding naming conventions, comments, basic documentation, and input validation within the logic.
 * 
 * This solution integrates multiple fundamental and intermediate Java concepts into a cohesive, practical application, providing a solid challenge for an exam.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single support ticket in the Service Desk system.
 */
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs

    private int ticketId;
    private String description;
    private String status; // e.g., "Waiting", "In Progress", "Resolved"
    private String resolutionNotes;

    /**
     * Constructs a new Ticket.
     *
     * @param description The description of the issue.
     */
    public Ticket(String description) {
        this.ticketId = nextId++;
        this.description = description;
        this.status = "Waiting";
        this.resolutionNotes = null; // No resolution notes initially
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public String getResolutionNotes() {
        return resolutionNotes;
    }

    // --- Setters/Status Updates ---
    /**
     * Marks the ticket as "In Progress".
     */
    public void markInProgress() {
        this.status = "In Progress";
    }

    /**
     * Marks the ticket as "Resolved" and adds resolution notes.
     *
     * @param resolutionNotes The notes on how the ticket was resolved.
     */
    public void markResolved(String resolutionNotes) {
        this.status = "Resolved";
        this.resolutionNotes = resolutionNotes;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Ticket #").append(ticketId)
          .append(" [").append(status).append("]: ")
          .append(description);
        if (resolutionNotes != null) {
            sb.append(" (Resolution: ").append(resolutionNotes).append(")");
        }
        return sb.toString();
    }
}

/**
 * Manages the collection of support tickets.
 */
class ServiceDesk {
    private Queue<Ticket> waitingTickets;
    private List<Ticket> resolvedTickets; // Using List interface, implemented by ArrayList
    private Ticket currentTicket; // Ticket currently being handled

    /**
     * Constructs a new ServiceDesk, initializing ticket queues and lists.
     */
    public ServiceDesk() {
        this.waitingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.resolvedTickets = new ArrayList<>(); // ArrayList implements List
        this.currentTicket = null;
    }

    /**
     * Submits a new ticket to the waiting queue.
     *
     * @param description The description of the new ticket. Must not be null or empty.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public void submitTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(description.trim());
        waitingTickets.offer(newTicket); // Add to the end of the queue
        System.out.println("Ticket #" + newTicket.getTicketId() + " submitted successfully.");
    }

    /**
     * Picks up the next waiting ticket.
     *
     * @return The ticket that was picked up.
     * @throws IllegalStateException if the waiting queue is empty or a ticket is already being handled.
     */
    public Ticket pickupNextTicket() {
        if (currentTicket != null) {
            throw new IllegalStateException("A ticket is already being handled. Please resolve it first.");
        }
        Ticket next = waitingTickets.poll(); // Remove and retrieve the head of the queue
        if (next == null) {
            throw new IllegalStateException("No tickets currently waiting in the queue.");
        }
        next.markInProgress();
        currentTicket = next;
        System.out.println("Picked up ticket #" + currentTicket.getTicketId() + ".");
        return currentTicket;
    }

    /**
     * Resolves the currently handled ticket.
     *
     * @param resolutionNotes The notes on how the ticket was resolved. Must not be null or empty.
     * @throws IllegalStateException if no ticket is currently being handled.
     * @throws IllegalArgumentException if resolutionNotes is null or empty.
     */
    public void resolveCurrentTicket(String resolutionNotes) {
        if (currentTicket == null) {
            throw new IllegalStateException("No ticket is currently being handled.");
        }
        if (resolutionNotes == null || resolutionNotes.trim().isEmpty()) {
             throw new IllegalArgumentException("Resolution notes cannot be empty.");
        }
        currentTicket.markResolved(resolutionNotes.trim());
        resolvedTickets.add(currentTicket); // Add to the list of resolved tickets
        System.out.println("Ticket #" + currentTicket.getTicketId() + " resolved successfully.");
        currentTicket = null; // Clear the currently handled ticket
    }

    /**
     * Prints all tickets currently in the waiting queue.
     */
    public void printWaitingTickets() {
        System.out.println("\n--- Waiting Tickets ---");
        if (waitingTickets.isEmpty()) {
            System.out.println("No tickets waiting.");
        } else {
            // Iterate without removing elements from the queue
            for (Ticket ticket : waitingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Returns the ticket currently being handled.
     *
     * @return The current ticket, or null if none is being handled.
     */
    public Ticket getCurrentTicket() {
        return currentTicket;
    }

    /**
     * Prints all tickets that have been resolved.
     */
    public void printResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
        if (resolvedTickets.isEmpty()) {
            System.out.println("No tickets resolved yet.");
        } else {
            for (Ticket ticket : resolvedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("------------------------");
    }
}

/**
 * Main application class for the Service Desk system.
 */
public class ServiceDeskApp {

    public static void main(String[] args) {
        ServiceDesk serviceDesk = new ServiceDesk();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Welcome to the Service Desk System!");

        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1: // Submit New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        serviceDesk.submitTicket(description);
                        break;
                    case 2: // Pickup Next Ticket
                        serviceDesk.pickupNextTicket();
                        break;
                    case 3: // Resolve Current Ticket
                        System.out.print("Enter resolution notes: ");
                        String resolutionNotes = scanner.nextLine();
                        serviceDesk.resolveCurrentTicket(resolutionNotes);
                        break;
                    case 4: // View Waiting Tickets
                        serviceDesk.printWaitingTickets();
                        break;
                    case 5: // View Current Ticket
                        Ticket current = serviceDesk.getCurrentTicket();
                        System.out.println("\n--- Current Ticket ---");
                        if (current != null) {
                            System.out.println(current);
                        } else {
                            System.out.println("No ticket currently being handled.");
                        }
                        System.out.println("----------------------");
                        break;
                    case 6: // View Resolved Tickets
                        serviceDesk.printResolvedTickets();
                        break;
                    case 7: // Exit
                        running = false;
                        System.out.println("Exiting Service Desk System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid input. Please enter a number between 1 and 7.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException | IllegalStateException e) {
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a newline for better readability between operations
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Service Desk Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Pickup Next Ticket");
        System.out.println("3. Resolve Current Ticket");
        System.out.println("4. View Waiting Tickets");
        System.out.println("5. View Current Ticket");
        System.out.println("6. View Resolved Tickets");
        System.out.println("7. Exit");
        System.out.println("-------------------------");
    }
}
