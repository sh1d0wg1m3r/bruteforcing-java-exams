/*
 * Exam Question #880
 * Generated on: 2025-05-12 16:54:19
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam: Event Capacity Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simple command-line application to manage attendees for an event with a fixed capacity. The system should allow users to register attendees and manage a waiting list if the capacity is reached.
 * 
 * The application should support the following operations:
 * 
 * 1.  **Register Attendee:** Add a new attendee by name. If the current number of confirmed attendees is less than the event capacity, the attendee is added to the list of confirmed attendees. Otherwise, the attendee is added to a waiting list. The system should prevent duplicate registrations (an attendee cannot be on the confirmed list AND the waiting list, nor can they be added if they are already on either list). Names are case-sensitive for uniqueness.
 * 2.  **Finalize Attendee List:** This operation simulates the event starting. It attempts to fill any remaining spots in the confirmed attendee list up to the maximum capacity by moving attendees from the waiting list in the order they were added (first-come, first-served). Once an attendee is moved from the waiting list to the confirmed list, they are removed from the waiting list. This operation can be performed multiple times, but it only moves attendees if there is capacity available and the waiting list is not empty.
 * 3.  **View Status:** Display the current list of confirmed attendees and the current waiting list.
 * 4.  **Exit:** Terminate the application.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java class named `EventManager`. It must adhere to the following:
 * 
 * *   Use a `java.util.Queue` to represent the waiting list.
 * *   Use a `java.util.ArrayList` to store the confirmed attendees.
 * *   Declare the confirmed attendees list using the `java.util.List` interface type (`List<String> attendees = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to read user input from the console (menu choices and attendee names).
 * *   Use a `switch` statement to handle the main menu choices.
 * *   Use `System.err` to print error messages (e.g., invalid menu choice, registration errors).
 * *   Use `System.out` to print normal output (prompts, success messages, status).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during execution (e.g., invalid input format for menu).
 * *   Follow good programming practices:
 *     *   Proper encapsulation (private fields).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (basic Javadoc for methods).
 *     *   Input validation (e.g., non-empty names).
 *     *   Proper error handling for business logic (e.g., duplicate registration).
 * 
 * **Event Capacity:** The system should be initialized with a fixed capacity (e.g., 10).
 * 
 * **Execution:** The program should present a menu to the user, accept input, perform the requested action, and repeat until the user chooses to exit.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Event Capacity: 10
 * Choose an action:
 * 1. Register Attendee
 * 2. Finalize Attendee List
 * 3. View Status
 * 4. Exit
 * Enter choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully. Confirmed.
 * 
 * Choose an action:
 * ...
 * Enter choice: 1
 * Enter attendee name: Bob
 * Bob registered successfully. Confirmed.
 * 
 * ... (after registering 10 people) ...
 * 
 * Enter choice: 1
 * Enter attendee name: Charlie
 * Event capacity reached. Charlie added to waiting list.
 * 
 * Choose an action:
 * ...
 * Enter choice: 1
 * Enter attendee name: Alice
 * Error: Alice is already registered.
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * --- Event Status ---
 * Confirmed Attendees (10/10):
 * - Alice
 * - Bob
 * ...
 * Waiting List (1):
 * - Charlie
 * --------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Finalizing attendee list...
 * No capacity available to move attendees from waiting list.
 * 
 * Choose an action:
 * ... (Imagine 2 confirmed attendees are somehow removed or capacity increases - not required for implementation, just for understanding Finalize) ...
 * Enter choice: 2
 * Finalizing attendee list...
 * Moved Charlie from waiting list to confirmed attendees.
 * Current confirmed attendees: 11 (if capacity allowed) or 10 (if capacity is 10 and 1 spot opened up)
 * 
 * Choose an action:
 * ...
 * Enter choice: 4
 * Exiting Event Manager.
 * ```
 * 
 * **Note:** The "Finalize" step in the example interaction shows a scenario where capacity might become available. Your implementation of `finalizeAttendeeList` should simply fill available spots *up to the initial capacity* from the waiting list. It does not need to handle attendees leaving the confirmed list.
 * 
 * **Expected Output:**
 * 
 * *   Clear menu prompts.
 * *   Descriptive messages for successful operations.
 * *   Informative error messages printed to `System.err`.
 * *   Formatted status output showing both lists with counts relative to capacity.
 *
 * EXPLANATION:
 * This solution implements the `EventManager` class to simulate the event attendee management system as described.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The `EventManager` class encapsulates all the state (`capacity`, `confirmedAttendees`, `waitingList`, `scanner`) and behavior related to managing the event.
 *     *   Fields are declared `private` to enforce encapsulation.
 *     *   Public methods (`run`, `EventManager` constructor) provide the interface, while helper methods (`printMenu`, `registerAttendee`, `finalizeAttendeeList`, `viewStatus`) handle specific tasks.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `waitingList` is declared as a `Queue<String>` and initialized with a `LinkedList` instance (`new LinkedList<>()`), which is a common implementation of the `Queue` interface. `offer()` is used to add elements (preferred over `add` as it handles capacity constraints gracefully, though not strictly necessary here as `LinkedList` is unbounded), and `poll()` is used to retrieve and remove elements from the head of the queue in FIFO order.
 *     *   `java.util.ArrayList`: The `confirmedAttendees` list is initialized as an `ArrayList<String>` (`new ArrayList<>()`).
 *     *   `java.util.List`: The `confirmedAttendees` field is declared using the `List` interface type (`List<String> confirmedAttendees`), demonstrating programming to the interface rather than the specific implementation.
 *     *   `java.util.Scanner`: A `Scanner` instance is used to read input from `System.in` for both menu choices and attendee names. `nextInt()` is used for the integer choice, and `nextLine()` is used for string names and to consume the leftover newline character after `nextInt()`.
 *     *   `switch statement`: A `switch` statement in the `run` method directs program flow based on the user's menu choice.
 *     *   `System.err`: Used for printing error messages, such as invalid menu input, empty names, or duplicate registrations.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and the formatted status display.
 *     *   `try-catch blocks`:
 *         *   A `try-catch(InputMismatchException e)` block is used inside the main loop to specifically handle cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing the loop to continue.
 *         *   A general `try-catch(Exception e)` block is included within the loop to catch any other unexpected exceptions that might occur during the execution of the switch cases.
 *         *   An outer `try-catch(Exception mainException)` block wraps the entire `while` loop within the `run` method. This fulfills the "class-wide exception handling" requirement by providing a fallback catch-all for any exception that might propagate out of the inner loop or operations.
 *         *   A `finally` block ensures the `Scanner` is closed when the `run` method finishes (either by exiting the loop or due to an exception).
 *         *   The `main` method also includes a `try-catch` to handle potential exceptions during object initialization (like the `IllegalArgumentException` from a bad capacity value).
 * 
 * 3.  **Business Logic and Input Validation:**
 *     *   The `registerAttendee` method checks for empty names and duplicate registrations across both the confirmed list and the waiting list before attempting to add. It then decides whether to add to `confirmedAttendees` (using `List.add`) or `waitingList` (using `Queue.offer`) based on the current size relative to capacity.
 *     *   The `finalizeAttendeeList` method uses a `while` loop to repeatedly check if there's space (`confirmedAttendees.size() < capacity`) and if the waiting list has people (`!waitingList.isEmpty()`). Inside the loop, it uses `waitingList.poll()` to get the next person from the waiting list and removes them, then adds them to `confirmedAttendees`.
 *     *   The `viewStatus` method iterates through both the `confirmedAttendees` list and the `waitingList` (using an enhanced for loop on the queue, which iterates without removing elements) to display their contents and sizes.
 * 
 * 4.  **Best Practices:**
 *     *   Meaningful names (`confirmedAttendees`, `waitingList`, `registerAttendee`, `finalizeAttendeeList`, etc.).
 *     *   Basic Javadoc comments explain the purpose of the class and key methods.
 *     *   Input validation for the attendee name (checking for empty string).
 *     *   Error messages are clear and indicate the nature of the problem.
 *     *   The code is structured into logical methods, making it more readable and maintainable.
 * 
 * This solution effectively integrates all the required Java components into a practical scenario, demonstrating understanding of data structures, control flow, user input handling, and exception management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages attendees for an event with fixed capacity and a waiting list.
 */
public class EventManager {

    private final int capacity;
    private List<String> confirmedAttendees;
    private Queue<String> waitingList;
    private Scanner scanner;

    /**
     * Constructs an EventManager with a specified capacity.
     * @param capacity The maximum number of confirmed attendees.
     */
    public EventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.capacity = capacity;
        this.confirmedAttendees = new ArrayList<>();
        this.waitingList = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main command-line interface loop for the EventManager.
     */
    public void run() {
        System.out.println("Event Capacity: " + capacity);

        // Class-wide exception handling wrapping the main execution loop
        try {
            int choice = -1;
            while (choice != 4) {
                printMenu();
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline

                    switch (choice) {
                        case 1:
                            registerAttendee();
                            break;
                        case 2:
                            finalizeAttendeeList();
                            break;
                        case 3:
                            viewStatus();
                            break;
                        case 4:
                            System.out.println("Exiting Event Manager.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception mainException) {
            // This catch block demonstrates the class-wide exception handling requirement
            // It catches any exception that escapes the inner try-catch in the loop
            System.err.println("A critical error occurred in the application loop: " + mainException.getMessage());
            // mainException.printStackTrace(); // Uncomment for debugging critical errors
        } finally {
             // Ensure scanner is closed when the application exits
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Register Attendee");
        System.out.println("2. Finalize Attendee List");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
    }

    /**
     * Handles the process of registering a new attendee.
     * Prompts for name and adds to confirmed list or waiting list.
     */
    private void registerAttendee() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        // Check if already registered (in either list)
        if (confirmedAttendees.contains(name) || waitingList.contains(name)) {
            System.err.println("Error: " + name + " is already registered.");
            return;
        }

        // Add to confirmed list if capacity is available
        if (confirmedAttendees.size() < capacity) {
            confirmedAttendees.add(name);
            System.out.println(name + " registered successfully. Confirmed.");
        } else {
            // Add to waiting list
            waitingList.offer(name); // offer is generally preferred for queues
            System.out.println("Event capacity reached. " + name + " added to waiting list.");
        }
    }

    /**
     * Finalizes the attendee list by moving attendees from the waiting list
     * to the confirmed list until capacity is reached or waiting list is empty.
     */
    private void finalizeAttendeeList() {
        System.out.println("Finalizing attendee list...");
        int movedCount = 0;
        while (confirmedAttendees.size() < capacity && !waitingList.isEmpty()) {
            String attendee = waitingList.poll(); // Get and remove the head of the queue
            if (attendee != null) { // Should not be null if !waitingList.isEmpty()
                 // Double check if somehow already added (shouldn't happen with current logic, but good practice)
                 if (!confirmedAttendees.contains(attendee)) {
                     confirmedAttendees.add(attendee);
                     System.out.println("Moved " + attendee + " from waiting list to confirmed attendees.");
                     movedCount++;
                 } else {
                      // This case implies a logic error or external modification, handle defensively
                      System.err.println("Warning: Attempted to move " + attendee + " from waiting list, but they are already confirmed.");
                 }
            }
        }

        if (movedCount == 0) {
             if (confirmedAttendees.size() >= capacity) {
                 System.out.println("No capacity available to move attendees from waiting list.");
             } else if (waitingList.isEmpty()) {
                 System.out.println("Waiting list is empty. No attendees to move.");
             } else {
                 // This case should not be reachable if confirmedAttendees.size() < capacity and waitingList is not empty
                 System.err.println("Unexpected state: Could not move attendees despite available capacity and non-empty waiting list.");
             }
        } else {
             System.out.println(movedCount + " attendee(s) moved from waiting list.");
        }
    }

    /**
     * Displays the current status of confirmed attendees and the waiting list.
     */
    private void viewStatus() {
        System.out.println("--- Event Status ---");
        System.out.println("Confirmed Attendees (" + confirmedAttendees.size() + "/" + capacity + "):");
        if (confirmedAttendees.isEmpty()) {
            System.out.println("  No confirmed attendees yet.");
        } else {
            for (String attendee : confirmedAttendees) {
                System.out.println("  - " + attendee);
            }
        }

        System.out.println("\nWaiting List (" + waitingList.size() + "):");
        if (waitingList.isEmpty()) {
            System.out.println("  Waiting list is empty.");
        } else {
            // Iterate over the queue without removing elements
            for (String attendee : waitingList) {
                 System.out.println("  - " + attendee);
            }
            // Alternatively, if peek() and poll() were used in a loop here, it would empty the queue.
            // Iterating is better for just viewing.
        }
        System.out.println("--------------------");
    }

    /**
     * Main method to start the EventManager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        try {
            // Initialize with a capacity, e.g., 10
            EventManager manager = new EventManager(10);
            manager.run();
        } catch (IllegalArgumentException e) {
            System.err.println("Failed to initialize Event Manager: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unhandled error occurred during application startup: " + e.getMessage());
        }
    }
}
