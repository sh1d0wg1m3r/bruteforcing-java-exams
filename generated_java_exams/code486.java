/*
 * Exam Question #486
 * Generated on: 2025-05-11 23:18:05
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Automated Production Line Simulator
 * 
 * **Objective:** Design and implement a simplified simulation of an automated production line. The system should manage parts waiting for processing, process them sequentially, allow inspection of the last processed part, and display the state of the line.
 * 
 * **Scenario:**
 * A production line processes different types of parts. Parts arrive and are placed in a queue. A robotic arm (simulated) processes parts one by one from the front of the queue. After processing, the part is moved to a 'processed' area. An inspection station can examine the *last* part that was processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Part Representation:** Create a `Part` class with private fields for `type` (String, e.g., "Gear", "Widget") and `id` (int). Include a constructor and a `toString()` method to represent the part.
 * 2.  **Production Line Management:** Create a `ProductionLine` class that manages the simulation state.
 *     *   It must have a `Queue<Part>` to hold parts waiting for processing. Use a concrete implementation like `java.util.LinkedList`.
 *     *   It must have a `List<Part>` (using `java.util.ArrayList`) to store parts that have been successfully processed. Declare the variable using the `List` interface type.
 *     *   It must keep track of the `lastProcessedPart` (a `Part` object).
 *     *   Implement the following public methods:
 *         *   `addPart(Part part)`: Adds a part to the processing queue.
 *         *   `processNextPart()`: Removes the part at the front of the queue, moves it to the processed list, and updates `lastProcessedPart`. If the queue is empty, it should indicate an error state (see requirement 6).
 *         *   `inspectLastProcessed()`: Displays details of the `lastProcessedPart`. If no part has been processed yet, it should indicate an error state (see requirement 6).
 *         *   `viewProcessingQueue()`: Prints the contents of the processing queue without removing items.
 *         *   `viewProcessedParts()`: Prints the contents of the list of processed parts.
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 3.  **User Interface:** In the `main` method of a separate class (e.g., `ProductionLineSimulator`), create a command-line interface using `java.util.Scanner`.
 *     *   Present a menu of options to the user:
 *         1.  Add Part
 *         2.  Process Next Part
 *         3.  Inspect Last Processed
 *         4.  View Processing Queue
 *         5.  View Processed Parts
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   For "Add Part", prompt the user for the part type and ID. Validate that the ID is a positive integer and the type is not empty. If invalid, display an error and do not add the part.
 * 4.  **Output:**
 *     *   Use `System.out` for menu prompts, successful operation messages, and displaying queue/list contents.
 *     *   Use `System.err` for error messages (e.g., invalid input, trying to process an empty queue, trying to inspect when no part processed).
 * 5.  **Exception Handling:**
 *     *   Implement class-wide exception handling in the `main` method using a `try-catch` block to catch potential runtime errors or custom errors related to production line operations (e.g., attempting an action when the state doesn't allow it). A simple approach is to wrap the main command loop or critical operations within a `try-catch`.
 *     *   Consider creating a simple custom exception (e.g., `ProductionLineException`) or using standard exceptions to signal errors like trying to process an empty queue or inspect when no part is processed. The `processNextPart` and `inspectLastProcessed` methods should signal these errors.
 * 6.  **Error Conditions:**
 *     *   Attempting to `processNextPart` when the queue is empty should be handled gracefully, indicating an error.
 *     *   Attempting to `inspectLastProcessed` when no part has ever been processed should be handled gracefully, indicating an error.
 *     *   Invalid user input (non-integer choice, negative ID, empty type) should be handled using validation and error messages via `System.err`.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs).
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * The program should run interactively. Upon startup, it should display the menu. Based on user input, it should perform the requested action, print relevant information or error messages, and loop back to the menu until the user chooses to exit.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 1
 * Enter Part Type: Gear
 * Enter Part ID: 101
 * Part added to queue.
 * 
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 4
 * Processing Queue: [Gear#101]
 * 
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 2
 * Processing next part...
 * Part processed: Gear#101
 * 
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 3
 * Last processed part: Gear#101
 * 
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 5
 * Processed Parts: [Gear#101]
 * 
 * Production Line Menu:
 * 1. Add Part
 * 2. Process Next Part
 * 3. Inspect Last Processed
 * 4. View Processing Queue
 * 5. View Processed Parts
 * 6. Exit
 * Enter choice: 2
 * Processing next part...
 * Error: Processing queue is empty. Cannot process.
 * 
 * Production Line Menu:
 * ... (continues until exit)
 * ```
 * 
 * Your solution should be contained within a single `.java` file.
 *
 * EXPLANATION:
 * This solution simulates a production line using several core Java concepts as required.
 * 
 * 1.  **`Part` Class:** A simple class representing an item with a `type` and `id`. It includes basic input validation in the constructor, throwing `IllegalArgumentException` if type is invalid or ID is non-positive. The `toString()` method provides a convenient way to display part information.
 * 2.  **`ProductionLine` Class:** This is the core logic class.
 *     *   It uses a `Queue<Part>` (`LinkedList` implementation) for parts waiting (`processingQueue`). The `Queue` interface methods like `offer()` (add) and `poll()` (remove and return head) are used, correctly modeling a FIFO (First-In, First-Out) processing line.
 *     *   It uses a `List<Part>` (`ArrayList` implementation) to store parts that have been processed (`processedParts`). Declaring it as `List` demonstrates polymorphism and good practice. `ArrayList` provides dynamic resizing and efficient storage of processed items.
 *     *   `lastProcessedPart` stores the most recently processed item, allowing for the inspection feature.
 *     *   Methods like `addPart`, `processNextPart`, `inspectLastProcessed`, `viewProcessingQueue`, and `viewProcessedParts` encapsulate the operations.
 *     *   `processNextPart` and `inspectLastProcessed` are designed to throw a custom `ProductionLineException` when an operation is attempted in an invalid state (empty queue or no processed parts, respectively).
 * 3.  **`ProductionLineException`:** A simple custom exception class extending `Exception`. This provides specific error types for production line issues, making the `catch` blocks in the main method more readable and targeted.
 * 4.  **`ProductionLineSimulator` (Main Class):**
 *     *   The `main` method drives the simulation.
 *     *   A `Scanner` is used to read user input from the console.
 *     *   A `boolean running` flag controls the main loop.
 *     *   A `switch` statement handles the different menu choices, directing execution to the appropriate `ProductionLine` methods or program exit.
 *     *   **Input Validation:** Inside the "Add Part" case, there are nested `try-catch` blocks to handle potential `InputMismatchException` if the user enters non-integer input for the ID and `IllegalArgumentException` thrown by the `Part` constructor for invalid type or ID. `scanner.nextLine()` is used after reading an integer to consume the remaining newline character, preventing issues in subsequent `nextLine()` calls. `System.err` is used for these validation errors.
 *     *   **Error Handling (`try-catch`):** The entire `while` loop is wrapped in a large `try-catch(Exception e)` block. This fulfills the "class-wide exception handling" requirement, catching any uncaught exceptions that might occur within the loop (including the custom `ProductionLineException` or other runtime errors). Inside the `switch` cases for "Process Next Part" and "Inspect Last Processed", specific `try-catch(ProductionLineException e)` blocks are used to handle the expected exceptions thrown by the `ProductionLine` methods and print the specific error message using `System.err`.
 *     *   **Output:** `System.out` is used for the menu, prompts, and successful operation messages. `System.err` is strictly used for error messages as required.
 *     *   A `finally` block ensures the `Scanner` is closed when the program exits (either normally or due to an uncaught exception).
 * 
 * This structure demonstrates the use of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical, object-oriented manner with encapsulation, error handling, and input validation. The use of a custom exception and catching different types of exceptions (`InputMismatchException`, `IllegalArgumentException`, `ProductionLineException`, and a general `Exception`) showcases robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom Exception for Production Line errors
class ProductionLineException extends Exception {
    public ProductionLineException(String message) {
        super(message);
    }
}

// Represents a part on the production line
class Part {
    private String type;
    private int id;

    /**
     * Constructs a new Part.
     * @param type The type of the part (e.g., "Gear", "Widget").
     * @param id The unique identifier of the part.
     */
    public Part(String type, int id) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Part type cannot be null or empty.");
        }
        if (id <= 0) {
            throw new IllegalArgumentException("Part ID must be positive.");
        }
        this.type = type.trim();
        this.id = id;
    }

    /**
     * Returns the type of the part.
     * @return The part type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns the ID of the part.
     * @return The part ID.
     */
    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return type + "#" + id;
    }
}

// Manages the state and operations of the production line
class ProductionLine {
    private Queue<Part> processingQueue; // Parts waiting to be processed
    private List<Part> processedParts;   // Parts that have been processed
    private Part lastProcessedPart;     // The last part moved from queue to processed

    /**
     * Constructs a new ProductionLine.
     */
    public ProductionLine() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedParts = new ArrayList<>();   // ArrayList implements List
        this.lastProcessedPart = null;
    }

    /**
     * Adds a part to the end of the processing queue.
     * @param part The part to add.
     */
    public void addPart(Part part) {
        if (part != null) {
            processingQueue.offer(part); // offer() is standard for adding to queue
            System.out.println("Part added to queue: " + part);
        } else {
            System.err.println("Error: Cannot add a null part.");
        }
    }

    /**
     * Processes the next part from the front of the queue.
     * Removes it from the queue, adds it to the processed list,
     * and updates the last processed part.
     * @throws ProductionLineException if the processing queue is empty.
     */
    public void processNextPart() throws ProductionLineException {
        System.out.println("Processing next part...");
        Part partToProcess = processingQueue.poll(); // poll() removes and returns head, or null if empty

        if (partToProcess == null) {
            throw new ProductionLineException("Processing queue is empty. Cannot process.");
        } else {
            processedParts.add(partToProcess);
            lastProcessedPart = partToProcess;
            System.out.println("Part processed: " + partToProcess);
        }
    }

    /**
     * Displays details of the last processed part.
     * @throws ProductionLineException if no part has been processed yet.
     */
    public void inspectLastProcessed() throws ProductionLineException {
        System.out.println("Inspecting last processed part...");
        if (lastProcessedPart == null) {
            throw new ProductionLineException("No part has been processed yet to inspect.");
        } else {
            System.out.println("Last processed part: " + lastProcessedPart);
        }
    }

    /**
     * Prints the current contents of the processing queue.
     * Does not remove parts.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("(empty)");
        } else {
            // Iterate without removing elements
            for (Part part : processingQueue) {
                System.out.println(part);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Prints the current contents of the processed parts list.
     */
    public void viewProcessedParts() {
        System.out.println("--- Processed Parts ---");
        if (processedParts.isEmpty()) {
            System.out.println("(empty)");
        } else {
            for (Part part : processedParts) {
                System.out.println(part);
            }
        }
        System.out.println("-----------------------");
    }
}

// Main class to run the simulation with user interface
public class ProductionLineSimulator {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\nProduction Line Menu:");
        System.out.println("1. Add Part");
        System.out.println("2. Process Next Part");
        System.out.println("3. Inspect Last Processed");
        System.out.println("4. View Processing Queue");
        System.out.println("5. View Processed Parts");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Main method to run the production line simulation.
     * Handles user input and calls ProductionLine methods.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLine line = new ProductionLine();
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1: // Add Part
                        System.out.print("Enter Part Type: ");
                        String type = scanner.nextLine();
                        System.out.print("Enter Part ID: ");
                        int id = -1;
                        try {
                            id = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            Part newPart = new Part(type, id);
                            line.addPart(newPart);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for Part ID. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (IllegalArgumentException e) {
                             System.err.println("Error creating part: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Part
                        try {
                            line.processNextPart();
                        } catch (ProductionLineException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 3: // Inspect Last Processed
                        try {
                            line.inspectLastProcessed();
                        } catch (ProductionLineException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 4: // View Processing Queue
                        line.viewProcessingQueue();
                        break;

                    case 5: // View Processed Parts
                        line.viewProcessedParts();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Production Line Simulator. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
