/*
 * Exam Question #497
 * Generated on: 2025-05-11 23:19:58
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Technical Support Request Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified technical support request management system. Users can submit new support requests, and support staff can process the requests in the order they were received. The system should maintain a list of pending requests and a history of completed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending support requests. Requests should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically instantiated as a `java.util.ArrayList`) to store completed support requests.
 * 
 * 2.  **Classes:**
 *     *   Create a `SupportRequest` class to represent a single support request. This class should encapsulate:
 *         *   A unique integer `id`.
 *         *   A `String` `description` of the problem.
 *         *   An `enum` `Status` (e.g., `PENDING`, `COMPLETED`).
 *         *   An `enum` `Priority` (e.g., `LOW`, `MEDIUM`, `HIGH`).
 *         *   Implement appropriate constructors, getters, and a `toString()` method for easy display. All fields should be private.
 *     *   Create a `SupportSystem` class to manage the requests. This class should contain the `Queue` of pending requests and the `List` of completed requests as private members.
 * 
 * 3.  **Functionality (Implemented in `SupportSystem`):**
 *     *   **Add New Request:** Prompt the user for the request description and priority level (e.g., 1 for LOW, 2 for MEDIUM, 3 for HIGH). Create a `SupportRequest` object with a unique ID (starting from 1 and incrementing), set its status to `PENDING`, and add it to the pending requests queue.
 *     *   **Process Next Request:** Take the next request from the front of the pending queue. If the queue is not empty, update its status to `COMPLETED` and move it to the completed requests list. If the queue is empty, display an appropriate message.
 *     *   **View Pending Requests:** Display all requests currently in the pending queue without removing them.
 *     *   **View Completed Requests:** Display all requests in the completed requests list.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input for menu choices and request details.
 *     *   Present a menu to the user with options for the functionalities listed above.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, request details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process an empty queue).
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for user menu choices and request priority levels. Handle non-integer input gracefully.
 *     *   Use `try-catch` blocks for exception handling, particularly around input operations and potentially around core system operations. Include a general `try-catch` around the main application loop to catch unexpected errors.
 *     *   Provide informative error messages using `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation (`private` fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested actions, and display results or errors clearly using `System.out` or `System.err` as appropriate.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Printer not working
 * Enter priority (1: LOW, 2: MEDIUM, 3: HIGH): 2
 * Request ID 1 added successfully.
 * 
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Requests ---
 * [ID: 1, Description: Printer not working, Status: PENDING, Priority: MEDIUM]
 * --------------------------
 * 
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 2
 * Processing request ID 1: Printer not working
 * Request ID 1 completed.
 * 
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Requests ---
 * (Queue is empty)
 * --------------------------
 * 
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Requests ---
 * [ID: 1, Description: Printer not working, Status: COMPLETED, Priority: MEDIUM]
 * --------------------------
 * 
 * --- Support Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support Request System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Error: No pending requests to process.
 * 
 * --- Support Request System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Exiting Support Request System.
 * ```
 *
 * EXPLANATION:
 * This solution implements the technical support request management system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **SupportRequest Class:**
 *     *   Encapsulates request data (`id`, `description`, `status`, `priority`) with `private` fields and public getter/setter methods.
 *     *   Uses `enum`s (`Status`, `Priority`) for type safety and readability, which is better than using raw strings or integers for status and priority. The `Priority` enum includes a `fromLevel` helper method to easily convert integer input (1, 2, 3) into the corresponding enum constant, handling invalid input by returning `null`.
 *     *   The `toString()` method provides a convenient way to display request details.
 * 
 * 2.  **SupportSystem Class:**
 *     *   Manages the core logic and data structures.
 *     *   `private Queue<SupportRequest> pendingRequests;`: Declared as `Queue` interface type, instantiated with `LinkedList` (`new LinkedList<>()`). `LinkedList` is a common implementation of `Queue` that supports FIFO operations efficiently.
 *     *   `private List<SupportRequest> completedRequests;`: Declared as `List` interface type, instantiated with `ArrayList` (`new ArrayList<>()`). `ArrayList` is suitable for storing processed items where random access or iteration is needed.
 *     *   `private int nextRequestId;`: A simple counter to generate unique IDs, demonstrating state management within the system class.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `addRequest(Scanner scanner)`: Reads input for description and priority. Includes a `while` loop and `try-catch(InputMismatchException)` specifically for reading the priority level to handle non-integer input and ensure a valid priority is entered before proceeding. It uses `Priority.fromLevel()` for validation. A new `SupportRequest` is created and added to the `pendingRequests` queue using `offer()`, which is the standard `Queue` method for adding elements.
 *     *   `processNextRequest()`: Uses `pendingRequests.poll()`. `poll()` is the preferred `Queue` method for removing and returning the head, as it returns `null` if the queue is empty, allowing for graceful handling of the empty case without throwing an exception like `remove()` would. If a request is retrieved, its status is updated, and it's added to the `completedRequests` list.
 *     *   `viewPendingRequests()`: Iterates through the `pendingRequests` queue using a `for-each` loop. This iterates over the elements without removing them, fulfilling the requirement to *view* the queue contents.
 *     *   `viewCompletedRequests()`: Iterates through the `completedRequests` list using a `for-each` loop.
 *     *   `displayMenu()`: A helper method to print the menu options.
 *     *   `run()`: Contains the main application loop. It uses a `Scanner` for input.
 * 
 * 4.  **User Interface and Flow Control:**
 *     *   The `run()` method contains a `while(running)` loop to keep the application active until the user chooses to exit.
 *     *   A `switch(choice)` statement is used to direct execution based on the user's menu selection.
 *     *   A `default` case in the `switch` handles invalid menu numbers.
 * 
 * 5.  **Error Handling (`try-catch`, `System.err`):**
 *     *   A `try-catch(InputMismatchException)` block is used around `scanner.nextInt()` when reading the menu choice to catch non-integer input and prevent the program from crashing. The invalid input is consumed using `scanner.nextLine()`.
 *     *   Similar `try-catch` is used during priority input in `addRequest`.
 *     *   A broader `try-catch(Exception e)` block wraps the main `while` loop in `run()`. This demonstrates class-wide exception handling for the main execution flow, catching any unexpected runtime errors and printing an error message and stack trace to `System.err`.
 *     *   `System.err.println()` is used consistently for all error messages (invalid input, empty queue/list conditions).
 *     *   `System.out.println()` is used for normal output (menu, prompts, success messages, request details).
 * 
 * 6.  **Best Practices:**
 *     *   Fields are `private`.
 *     *   Methods have descriptive names (`addRequest`, `processNextRequest`, `viewPendingRequests`, etc.).
 *     *   Javadoc comments are provided for classes and methods.
 *     *   Input validation is performed (checking priority level, handling non-integer input).
 *     *   Error handling is implemented using `try-catch` and `System.err`.
 *     *   The `Scanner` is closed in a `finally` block within `run()` to ensure resource cleanup regardless of whether an exception occurs or the loop exits normally.
 *     *   The code is structured into logical methods within the `SupportSystem` class.
 * 
 * This solution effectively combines the required Java components within a practical scenario, emphasizing good design principles and robust error handling, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for request status
enum Status {
    PENDING, COMPLETED
}

// Enum for request priority
enum Priority {
    LOW(1), MEDIUM(2), HIGH(3);

    private final int level;

    Priority(int level) {
        this.level = level;
    }

    public int getLevel() {
        return level;
    }

    // Helper method to get Priority from integer level
    public static Priority fromLevel(int level) {
        for (Priority p : Priority.values()) {
            if (p.level == level) {
                return p;
            }
        }
        return null; // Indicate invalid level
    }
}

/**
 * Represents a single technical support request.
 */
class SupportRequest {
    private int id;
    private String description;
    private Status status;
    private Priority priority;

    /**
     * Constructs a new SupportRequest.
     *
     * @param id          The unique identifier for the request.
     * @param description The description of the technical issue.
     * @param priority    The priority level of the request.
     */
    public SupportRequest(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.status = Status.PENDING; // New requests are always pending
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Status getStatus() {
        return status;
    }

    public Priority getPriority() {
        return priority;
    }

    // --- Setters ---
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the SupportRequest.
     *
     * @return A formatted string displaying request details.
     */
    @Override
    public String toString() {
        return "[ID: " + id +
               ", Description: " + description +
               ", Status: " + status +
               ", Priority: " + priority + "]";
    }
}

/**
 * Manages the queue of pending support requests and the list of completed requests.
 */
public class SupportSystem {
    // Queue for requests awaiting processing (FIFO)
    private Queue<SupportRequest> pendingRequests;
    // List for requests that have been processed
    private List<SupportRequest> completedRequests;
    // Counter for generating unique request IDs
    private int nextRequestId;

    /**
     * Constructs a new SupportSystem.
     * Initializes the pending queue, completed list, and request ID counter.
     */
    public SupportSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingRequests = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1;
    }

    /**
     * Adds a new support request to the pending queue based on user input.
     *
     * @param scanner The Scanner object for reading user input.
     */
    public void addRequest(Scanner scanner) {
        System.out.print("Enter request description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (1: LOW, 2: MEDIUM, 3: HIGH): ");
            try {
                int priorityLevel = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                priority = Priority.fromLevel(priorityLevel);
                if (priority != null) {
                    validPriority = true;
                } else {
                    System.err.println("Error: Invalid priority level. Please enter 1, 2, or 3.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for priority.");
                scanner.nextLine(); // Consume the invalid input
            }
        }

        SupportRequest newRequest = new SupportRequest(nextRequestId++, description, priority);
        pendingRequests.offer(newRequest); // offer() is generally preferred for queues
        System.out.println("Request ID " + newRequest.getId() + " added successfully.");
    }

    /**
     * Processes the next request from the pending queue.
     * Removes the request from the queue, updates its status, and adds it to the completed list.
     */
    public void processNextRequest() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        SupportRequest requestToProcess = pendingRequests.poll();

        if (requestToProcess != null) {
            System.out.println("Processing request ID " + requestToProcess.getId() + ": " + requestToProcess.getDescription());
            requestToProcess.setStatus(Status.COMPLETED);
            completedRequests.add(requestToProcess);
            System.out.println("Request ID " + requestToProcess.getId() + " completed.");
        } else {
            System.err.println("Error: No pending requests to process.");
        }
    }

    /**
     * Displays all requests currently in the pending queue.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (SupportRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all requests in the completed requests list.
     */
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("(No completed requests yet)");
        } else {
            // Iterate through the list
            for (SupportRequest request : completedRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Request System Menu ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addRequest(scanner);
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Support Request System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during system execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed. Application terminated.");
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
