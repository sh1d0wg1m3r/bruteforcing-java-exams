/*
 * Exam Question #673
 * Generated on: 2025-05-12 16:23:39
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Attendee Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage attendees for a technical workshop event. The event has a fixed maximum capacity. When attendees register, they are added to the main registered list if space is available. If the event is full, subsequent registrants are placed on a waiting list. If a registered attendee cancels, the first person on the waiting list (if any) is automatically moved to the registered list.
 * 
 * Your application must provide a menu-driven interface for the user to interact with the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain the list of currently registered attendees using a `java.util.List` interface type, implemented by `java.util.ArrayList`.
 *     *   Maintain the waiting list using a `java.util.Queue` interface type (you can choose an appropriate implementation like `java.util.LinkedList`).
 *     *   Create a simple `Attendee` class to hold attendee information (e.g., name and email). The email should be treated as a unique identifier.
 * 
 * 2.  **Functionality:**
 *     *   **Initialize Event:** Prompt the user to enter the maximum capacity of the event at the start.
 *     *   **Main Menu:** Display a menu with options:
 *         1.  Register Attendee
 *         2.  Cancel Registration
 *         3.  View Event Status
 *         4.  List Registered Attendees
 *         5.  List Waiting List
 *         6.  Exit
 *     *   **Register Attendee:**
 *         *   Prompt for attendee name and email.
 *         *   Create an `Attendee` object.
 *         *   Check if an attendee with the same email already exists (either registered or on waiting list). If so, report an error.
 *         *   If space is available (registered count < capacity), add the attendee to the registered list. Report success.
 *         *   If the event is full, add the attendee to the waiting list. Report that they were added to the waiting list.
 *     *   **Cancel Registration:**
 *         *   Prompt for the email of the attendee to cancel.
 *         *   Search for the attendee in the registered list.
 *         *   If found and removed from the registered list: Report successful cancellation. If the waiting list is *not* empty, remove the first attendee from the waiting list and add them to the registered list. Report this transfer.
 *         *   If not found in the registered list, search the waiting list. If found and removed from the waiting list: Report successful removal from waiting list.
 *         *   If not found in either list: Report an error.
 *     *   **View Event Status:** Display the event capacity, the number of registered attendees, the number of attendees on the waiting list, and the number of available spots (capacity - registered count).
 *     *   **List Registered Attendees:** Display a numbered list of all registered attendees (name and email).
 *     *   **List Waiting List:** Display a numbered list of all attendees on the waiting list (name and email), in the order they would be processed.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **Technical Requirements:**
 *     *   Use `java.util.Scanner` to read all user input.
 *     *   Implement the main menu logic using a `switch` statement within a loop.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, lists, and status.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, attendee not found, attendee already exists, capacity error).
 *     *   Include appropriate `try-catch` blocks for exception handling, specifically for handling potential input errors when reading numbers (like capacity or menu choice). Handle other potential issues like invalid attendee data creation.
 *     *   Structure your code into appropriate classes (`Attendee`, `EventManager`, and a main application class).
 *     *   Apply best practices:
 *         *   Use private fields and public methods (encapsulation).
 *         *   Use meaningful variable and method names.
 *         *   Include basic comments where necessary.
 *         *   Perform input validation (e.g., positive capacity, non-empty attendee details, valid menu choices).
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, displaying the menu, prompting for input, and showing results or errors based on user actions. Example interactions might look like:
 * 
 * ```
 * --- Event Management System ---
 * Enter event capacity: 5
 * 
 * --- Menu ---
 * 1. Register Attendee
 * ...
 * 6. Exit
 * ------------
 * Enter your choice: 1
 * --- Register New Attendee ---
 * Enter name: Alice
 * Enter email (unique identifier): alice@example.com
 * Attendee Alice registered successfully.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * --- Register New Attendee ---
 * Enter name: Bob
 * Enter email (unique identifier): bob@example.com
 * Attendee Bob registered successfully.
 * 
 * ... (Register 3 more attendees to reach capacity)
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * --- Register New Attendee ---
 * Enter name: Charlie
 * Enter email (unique identifier): charlie@example.com
 * Attendee Charlie added to waiting list (event full).
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Event Status ---
 * Capacity: 5
 * Registered: 5
 * Waiting List: 1
 * Available Spots: 0
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * --- Cancel Registration ---
 * Enter email of attendee to cancel: alice@example.com
 * Attendee Alice cancelled registration.
 * Attendee Charlie moved from waiting list to registered.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Event Status ---
 * Capacity: 5
 * Registered: 5
 * Waiting List: 0
 * Available Spots: 0
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Event Management System. Goodbye!
 * ```
 * (Error messages should go to `System.err`).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, validation, error handling).
 * *   Clean and well-structured code.
 *
 * EXPLANATION:
 * This solution implements the Event Attendee Management System following all specified requirements.
 * 
 * 1.  **Data Structures:**
 *     *   `registeredAttendees`: Declared as `List<Attendee>` and initialized as `new ArrayList<>()`. This uses the `List` interface for flexibility while leveraging the dynamic array capabilities of `ArrayList` for efficient storage and retrieval of registered attendees.
 *     *   `waitingList`: Declared as `Queue<Attendee>` and initialized as `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` that provides efficient FIFO (First-In, First-Out) operations (`offer` to add to the end, `poll` to remove from the front), which is exactly what's needed for a waiting list.
 *     *   `Attendee` class: A simple class encapsulating attendee `name` and `email`. The email is used as a unique identifier. The `equals` and `hashCode` methods are overridden based on the email to ensure correct behavior when using collection methods like `contains` or searching for duplicates. Basic validation for non-empty name/email is done in the constructor, throwing `IllegalArgumentException`.
 * 
 * 2.  **Functionality:**
 *     *   The `EventManagementApp` class contains the `main` method, which drives the application.
 *     *   It first prompts for event capacity, using a loop and `try-catch` to ensure valid integer input > 0.
 *     *   It then enters a `while(running)` loop that continuously displays the menu and processes user input.
 *     *   **Menu and Switch:** The `printMenu()` method displays options. The main loop reads the user's integer choice using `scanner.nextInt()` and uses a `switch` statement to dispatch to the appropriate private helper method (`registerAttendee`, `cancelRegistration`, etc.). Invalid integer input is handled by a `try-catch` around `scanner.nextInt()`, and invalid choice numbers are handled by the `default` case in the `switch`.
 *     *   **Registration Logic (`EventManager.registerAttendee`):** Checks for existing attendees by email in both lists. If unique, it checks if `registeredAttendees.size()` is less than `capacity`. If true, it adds to `registeredAttendees` (`ArrayList`). Otherwise, it adds to `waitingList` (`Queue`) using `offer()`.
 *     *   **Cancellation Logic (`EventManager.cancelRegistration`):** Searches for the attendee by email in `registeredAttendees` first. If found, it removes the attendee using an `Iterator`'s `remove()` method (safe during iteration). If the waiting list is not empty, it uses `waitingList.poll()` to get and remove the first person and adds them to `registeredAttendees`. If the attendee wasn't in `registeredAttendees`, it searches `waitingList` using an `Iterator` and removes if found. Error messages are printed to `System.err` if the attendee is not found.
 *     *   **Status and Listing:** Getter methods in `EventManager` provide access to counts and lists. `getRegisteredAttendees()` and `getWaitingList()` return *new* `ArrayList` instances containing copies of the internal lists to prevent external code from directly modifying the manager's state, promoting encapsulation. The listing methods in `EventManagementApp` iterate over these returned lists and print attendee details.
 * 
 * 3.  **Technical Requirements:**
 *     *   `Scanner`: A single `Scanner` instance (`scanner`) is used throughout the `EventManagementApp` class. Care is taken to consume the newline character after reading integers (`scanner.nextLine()`) to prevent issues with subsequent `scanner.nextLine()` calls. The scanner is closed upon application exit.
 *     *   `switch`: Used effectively for the main menu navigation.
 *     *   `System.out`/`System.err`: Used as required for normal output and error messages, respectively.
 *     *   `try-catch`: Used to handle `InputMismatchException` when reading integer inputs (capacity and menu choice) from the `Scanner`. It consumes the invalid input and prompts the user again. A `try-catch` is also used around the `Attendee` constructor call in `registerAttendee` to catch potential `IllegalArgumentException` if the user enters empty names or emails. The `EventManager` constructor also throws `IllegalArgumentException` for invalid capacity, which is caught in `main`.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Attendee` and `EventManager` are `private`. Access and modification are controlled through `public` methods.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `registeredAttendees`, `waitingList`, `registerAttendee`, `getAvailableSpots`).
 *     *   **Comments:** Basic comments explain the purpose of classes, key methods, and complex logic sections.
 *     *   **Input Validation:** Capacity is validated to be positive. Attendee name/email are validated to be non-empty. Menu choice is validated to be within the valid range.
 *     *   **Error Handling:** Input errors are handled with `try-catch`. Business logic errors (attendee exists, not found) are reported via `System.err` and method return values where applicable.
 * 
 * This solution demonstrates a solid understanding of using core Java collections (`List`, `Queue`, `ArrayList`, `LinkedList`), handling user input, implementing control flow with `switch` and loops, managing state across objects, and incorporating basic error handling and best practices. The interaction between the `List` and `Queue` in the cancellation logic adds a layer of complexity appropriate for an advanced task.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal from Queue if searching

// Represents an attendee
class Attendee {
    private String name;
    private String email; // Use as unique identifier

    public Attendee(String name, String email) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be empty.");
        }
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee email cannot be empty.");
        }
        this.name = name.trim();
        // Normalize email to handle case sensitivity issues in lookup
        this.email = email.trim().toLowerCase();
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    @Override
    public String toString() {
        return name + " (" + email + ")";
    }

    // Equals and hashCode are crucial for using email as a unique identifier
    // when searching/removing from collections.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return email.equals(attendee.email);
    }

    @Override
    public int hashCode() {
        return email.hashCode();
    }
}

// Manages the event registration and waiting list logic
class EventManager {
    // Using List interface type, implemented by ArrayList
    private List<Attendee> registeredAttendees;
    // Using Queue interface type, implemented by LinkedList
    private Queue<Attendee> waitingList;
    private int capacity;

    public EventManager(int capacity) {
        if (capacity <= 0) {
            // Using IllegalArgumentException for invalid constructor arguments
            throw new IllegalArgumentException("Event capacity must be positive.");
        }
        this.capacity = capacity;
        // Initialize with estimated capacity for performance
        this.registeredAttendees = new ArrayList<>(capacity);
        this.waitingList = new LinkedList<>();
    }

    /**
     * Attempts to register an attendee. Adds to registered list if space,
     * otherwise adds to waiting list.
     * @param attendee The attendee to register.
     * @return true if successfully added to either list, false if attendee already exists.
     */
    public boolean registerAttendee(Attendee attendee) {
        // Check if attendee already exists in either list using their email
        if (isAttendeeRegistered(attendee.getEmail()) || isAttendeeInWaitingList(attendee.getEmail())) {
            System.err.println("Error: Attendee with email " + attendee.getEmail() + " is already registered or on the waiting list.");
            return false;
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(attendee);
            System.out.println("Attendee " + attendee.getName() + " registered successfully.");
            return true;
        } else {
            // offer is the preferred Queue method for adding, returns false on failure (unlikely for LinkedList)
            waitingList.offer(attendee);
            System.out.println("Attendee " + attendee.getName() + " added to waiting list (event full).");
            return true;
        }
    }

    /**
     * Cancels registration for an attendee by email.
     * If attendee was registered and waiting list is not empty, moves next person from waiting list.
     * @param email The email of the attendee to cancel.
     * @return true if attendee was found and removed from either list, false otherwise.
     */
    public boolean cancelRegistration(String email) {
        // Normalize email for lookup
        String normalizedEmail = email.trim().toLowerCase();

        // Try to find and remove from registered list first
        Attendee attendeeToCancel = null;
        // Iterate to find the attendee by email
        Iterator<Attendee> registeredIterator = registeredAttendees.iterator();
        while (registeredIterator.hasNext()) {
            Attendee current = registeredIterator.next();
            if (current.getEmail().equals(normalizedEmail)) {
                attendeeToCancel = current;
                registeredIterator.remove(); // Safe removal during iteration
                System.out.println("Attendee " + attendeeToCancel.getName() + " cancelled registration.");

                // If someone is waiting, move them to registered
                if (!waitingList.isEmpty()) {
                    // poll() retrieves and removes the head of the queue
                    Attendee nextInLine = waitingList.poll();
                    if (nextInLine != null) { // poll() can return null if queue is empty, but we checked !isEmpty()
                        registeredAttendees.add(nextInLine);
                        System.out.println("Attendee " + nextInLine.getName() + " moved from waiting list to registered.");
                    }
                }
                return true; // Found and processed cancellation from registered list
            }
        }

        // If not found in registered, try to find and remove from waiting list
        Iterator<Attendee> waitingIterator = waitingList.iterator();
        while (waitingIterator.hasNext()) {
            Attendee current = waitingIterator.next();
            if (current.getEmail().equals(normalizedEmail)) {
                attendeeToCancel = current;
                waitingIterator.remove(); // Safe removal during iteration
                System.out.println("Attendee " + attendeeToCancel.getName() + " removed from waiting list.");
                return true; // Found and processed removal from waiting list
            }
        }

        // Attendee not found in either list
        System.err.println("Error: Attendee with email " + email + " not found in registered list or waiting list.");
        return false;
    }

    // --- Getters and Status Methods ---

    public List<Attendee> getRegisteredAttendees() {
        // Return a new ArrayList to prevent external modification of the internal list
        return new ArrayList<>(registeredAttendees);
    }

    public List<Attendee> getWaitingList() {
        // Convert Queue to List for easy iteration and viewing. Does not modify the queue.
        return new ArrayList<>(waitingList);
    }

    public int getCapacity() {
        return capacity;
    }

    public int getRegisteredCount() {
        return registeredAttendees.size();
    }

    public int getWaitingCount() {
        return waitingList.size();
    }

    public int getAvailableSpots() {
        return capacity - registeredAttendees.size();
    }

    // --- Helper Methods for checking existence ---

    private boolean isAttendeeRegistered(String email) {
        String normalizedEmail = email.trim().toLowerCase();
        // Simple linear search - sufficient for exam scope
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getEmail().equals(normalizedEmail)) {
                return true;
            }
        }
        return false;
    }

    private boolean isAttendeeInWaitingList(String email) {
        String normalizedEmail = email.trim().toLowerCase();
        // Simple linear search over the queue's elements
        for (Attendee attendee : waitingList) {
            if (attendee.getEmail().equals(normalizedEmail)) {
                return true;
            }
        }
        return false;
    }
}

// Main application class with user interaction
public class EventManagementApp {

    private static EventManager eventManager;
    // Use a single Scanner instance for the application
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Event Management System ---");

        // Get event capacity from user with input validation
        int capacity = -1;
        while (capacity <= 0) {
            System.out.print("Enter event capacity: ");
            try {
                capacity = scanner.nextInt();
                if (capacity <= 0) {
                    System.err.println("Capacity must be a positive number.");
                }
            } catch (InputMismatchException e) {
                // Catching non-integer input
                System.err.println("Invalid input. Please enter a whole number for capacity.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                capacity = -1; // Keep capacity invalid to repeat loop
            }
        }
        scanner.nextLine(); // Consume the leftover newline after reading int

        // Initialize EventManager - constructor validates capacity again, but our loop ensures it's > 0
        try {
             eventManager = new EventManager(capacity);
        } catch (IllegalArgumentException e) {
             // This catch block handles the case where the capacity validation above failed somehow,
             // or if EventManager constructor had other validation rules.
             System.err.println("Failed to initialize Event Manager: " + e.getMessage());
             scanner.close(); // Clean up scanner before exiting
             return; // Exit application
        }


        boolean running = true;
        while (running) {
            printMenu();
            int choice = -1;
            System.out.print("Enter your choice: ");

            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over after nextInt()
            } catch (InputMismatchException e) {
                // Catching non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number between 1 and 6.");
                scanner.nextLine(); // Consume the invalid input line
                continue; // Skip the rest of the loop and show menu again
            }

            // Use a switch statement to handle different menu options
            switch (choice) {
                case 1:
                    registerAttendee();
                    break;
                case 2:
                    cancelRegistration();
                    break;
                case 3:
                    viewEventStatus();
                    break;
                case 4:
                    listRegisteredAttendees();
                    break;
                case 5:
                    listWaitingList();
                    break;
                case 6:
                    running = false; // Set flag to exit the loop
                    System.out.println("Exiting Event Management System. Goodbye!");
                    break;
                default:
                    // Handle choices outside the valid range
                    System.err.println("Invalid choice. Please enter a number between 1 and 6.");
            }
            System.out.println(); // Add a blank line for better readability between menu interactions
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Cancel Registration");
        System.out.println("3. View Event Status");
        System.out.println("4. List Registered Attendees");
        System.out.println("5. List Waiting List");
        System.out.println("6. Exit");
        System.out.println("------------");
    }

    /**
     * Handles the process of registering a new attendee based on user input.
     */
    private static void registerAttendee() {
        System.out.println("--- Register New Attendee ---");
        System.out.print("Enter name: ");
        String name = scanner.nextLine();
        System.out.print("Enter email (unique identifier): ");
        String email = scanner.nextLine();

        try {
            // Create Attendee object - constructor throws IllegalArgumentException on invalid data
            Attendee newAttendee = new Attendee(name, email);
            // Call EventManager to handle registration logic
            eventManager.registerAttendee(newAttendee);
        } catch (IllegalArgumentException e) {
            // Catching exceptions from Attendee constructor
            System.err.println("Error creating attendee: " + e.getMessage());
        }
    }

    /**
     * Handles the process of cancelling an attendee's registration based on user input.
     */
    private static void cancelRegistration() {
        System.out.println("--- Cancel Registration ---");
        System.out.print("Enter email of attendee to cancel: ");
        String email = scanner.nextLine();
        // Call EventManager to handle cancellation logic
        eventManager.cancelRegistration(email);
    }

    /**
     * Displays the current status of the event.
     */
    private static void viewEventStatus() {
        System.out.println("--- Event Status ---");
        System.out.println("Capacity: " + eventManager.getCapacity());
        System.out.println("Registered: " + eventManager.getRegisteredCount());
        System.out.println("Waiting List: " + eventManager.getWaitingCount());
        System.out.println("Available Spots: " + eventManager.getAvailableSpots());
    }

    /**
     * Lists all attendees currently registered for the event.
     */
    private static void listRegisteredAttendees() {
        System.out.println("--- Registered Attendees ---");
        List<Attendee> registered = eventManager.getRegisteredAttendees(); // Get the list via getter
        if (registered.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            // Iterate and print using the List interface methods
            for (int i = 0; i < registered.size(); i++) {
                System.out.println((i + 1) + ". " + registered.get(i));
            }
        }
    }

    /**
     * Lists all attendees currently on the waiting list.
     */
    private static void listWaitingList() {
        System.out.println("--- Waiting List ---");
        // Get the waiting list as a List for easy ordered iteration
        List<Attendee> waiting = eventManager.getWaitingList();
        if (waiting.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate and print using the List interface methods
            for (int i = 0; i < waiting.size(); i++) {
                 System.out.println((i + 1) + ". " + waiting.get(i));
            }
        }
    }
}
