/*
 * Exam Question #445
 * Generated on: 2025-05-11 23:12:02
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Logistics Package Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified logistics system to manage packages. Packages arrive, are queued for processing (e.g., scanning, sorting), and then moved to a dispatched list. The system should allow users to interact via a command-line interface to add packages, process the next package in the queue, view packages awaiting processing, and view packages that have been processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` (specifically, an implementation like `LinkedList` or `ArrayDeque`, but declare using the `Queue` interface) to store packages awaiting processing.
 *     *   Use an `ArrayList` (declared using the `List` interface) to store packages that have been processed (dispatched).
 * 2.  **Package Representation:**
 *     *   Create a class `Package` with private fields: `packageId` (String), `destination` (String), and `status` (String, initially "PENDING").
 *     *   Provide a constructor to initialize `packageId` and `destination`.
 *     *   Provide public getter methods for all fields.
 *     *   Include a public method `markAsDispatched()` to change the status to "DISPATCHED".
 *     *   Override the `toString()` method to provide a clear representation of a package (e.g., "Package ID: [id], Destination: [dest], Status: [status]").
 * 3.  **System Functionality:**
 *     *   The main class (e.g., `LogisticsSystem`) should contain the `main` method.
 *     *   Initialize the `Queue` for pending packages and the `List` for dispatched packages.
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Package: Prompt for package ID and destination, create a `Package` object, and add it to the pending queue.
 *         2.  Process Next Package: Take the package from the front of the pending queue, mark it as dispatched, and add it to the dispatched list. If the queue is empty, print an appropriate message.
 *         3.  View Pending Packages: Display details of all packages currently in the pending queue.
 *         4.  View Dispatched Packages: Display details of all packages currently in the dispatched list.
 *         5.  Exit: Terminate the program.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu choice to ensure it's an integer within the valid range. Use `System.err` to print error messages for invalid input.
 *     *   Use `System.err` to print an error message if the user attempts to process a package when the pending queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method or the core logic loop to catch potential unexpected errors (e.g., `InputMismatchException` for non-integer input where an integer is expected, though specific validation for the menu choice is also required).
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, and package details.
 *     *   Use `System.err` for all error messages.
 * 6.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex parts.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Format:**
 * 
 * ```
 * --- Logistics System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Dispatched Packages
 * 5. Exit
 * Enter your choice: [user input]
 * 
 * // Depending on choice:
 * // For Add:
 * Enter Package ID: [user input]
 * Enter Destination: [user input]
 * Package [ID] added to pending queue.
 * 
 * // For Process:
 * Package [ID] to [Destination] processed and dispatched.
 * // OR (if queue empty):
 * Error: No packages in the pending queue to process. (printed to System.err)
 * 
 * // For View Pending:
 * --- Pending Packages ---
 * Package ID: [id1], Destination: [dest1], Status: PENDING
 * Package ID: [id2], Destination: [dest2], Status: PENDING
 * ...
 * (If empty: No pending packages.)
 * 
 * // For View Dispatched:
 * --- Dispatched Packages ---
 * Package ID: [id1], Destination: [dest1], Status: DISPATCHED
 * Package ID: [id2], Destination: [dest2], Status: DISPATCHED
 * ...
 * (If empty: No dispatched packages.)
 * 
 * // For invalid menu input:
 * Error: Invalid choice. Please enter a number between 1 and 5. (printed to System.err)
 * 
 * // For other unexpected errors:
 * An unexpected error occurred: [error message] (printed by catch block)
 * 
 * // For Exit:
 * Exiting Logistics System.
 * ```
 * 
 * Your solution should be a single Java file containing the `Package` class and the main `LogisticsSystem` class with the `main` method and necessary logic.
 *
 * EXPLANATION:
 * This solution implements a simple Logistics Package Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Package` Class:** This class encapsulates the data for a single package (`packageId`, `destination`, `status`). It uses private fields and public getters for proper encapsulation. The `markAsDispatched()` method modifies the internal state. The `toString()` method provides a convenient way to print package details.
 * 
 * 2.  **`LogisticsSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingPackages`: Declared as `Queue<Package>` and initialized with `new LinkedList<>()`. `LinkedList` is used because it implements the `Queue` interface and is suitable for adding to the end (`offer`) and removing from the front (`poll`), which are typical queue operations.
 *         *   `dispatchedPackages`: Declared as `List<Package>` and initialized with `new ArrayList<>()`. `ArrayList` is a common and efficient implementation of the `List` interface for storing and iterating over elements.
 *     *   **User Input:** A `Scanner` object (`scanner`) is used to read input from `System.in`.
 *     *   **Menu and `switch`:** The `run()` method contains the main application loop. It repeatedly displays a menu (`displayMenu()`) and reads the user's choice. A `switch` statement is used to execute the appropriate action based on the valid integer input (1-5).
 *     *   **Functionality Methods:**
 *         *   `addNewPackage()`: Prompts for package details, creates a `Package` object, and adds it to the `pendingPackages` queue using `offer()`. Includes basic validation for empty input.
 *         *   `processNextPackage()`: Uses `poll()` to get and remove the head of the `pendingPackages` queue. If `poll()` returns `null` (queue is empty), an error message is printed to `System.err`. Otherwise, the package's status is updated using `markAsDispatched()`, and it's added to the `dispatchedPackages` list using `add()`.
 *         *   `viewPendingPackages()`: Iterates through the `pendingPackages` queue using a for-each loop (which doesn't remove elements) and prints each package's details using its `toString()` method. Checks if the queue is empty.
 *         *   `viewDispatchedPackages()`: Iterates through the `dispatchedPackages` list and prints each package's details. Checks if the list is empty.
 *     *   **Error Handling:**
 *         *   The `run()` method uses a `try-catch` block to wrap the input reading and processing logic.
 *         *   Specific validation is implemented *before* the `switch` statement to check if the input is an integer (`hasNextInt()`) and if the integer is within the valid menu range (1-5). Invalid input messages are printed to `System.err`.
 *         *   The `catch (InputMismatchException e)` specifically handles cases where `scanner.nextInt()` might still throw the exception if the `hasNextInt()` check was bypassed or if the input stream state is unexpected (though less likely with the current logic).
 *         *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors, printing a generic error message to `System.err`.
 *         *   The `processNextPackage()` method explicitly checks if `pendingPackages.poll()` returns `null` and prints an error to `System.err` if the queue is empty.
 *     *   **Output:** `System.out.println` is used for the menu, prompts, success messages, and package listings. `System.err.println` is used exclusively for error messages.
 *     *   **Best Practices:** The code uses meaningful names (`pendingPackages`, `processNextPackage`), includes comments explaining the purpose of methods and classes, and separates the `Package` class from the main logic class. Input validation and error handling are included as required. The `scanner.nextLine()` calls after `scanner.nextInt()` are crucial to consume the leftover newline character, preventing input issues in subsequent `scanner.nextLine()` calls.
 * 
 * This solution effectively integrates all the required Java components within a practical, albeit simplified, application context, demonstrating understanding of core Java concepts and best practices.
 */

import java.util.Queue;
import java.util.LinkedList; // Using LinkedList as a Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a package in the logistics system
class Package {
    private String packageId;
    private String destination;
    private String status; // PENDING or DISPATCHED

    /**
     * Constructs a new Package object.
     *
     * @param packageId   The unique identifier for the package.
     * @param destination The destination address for the package.
     */
    public Package(String packageId, String destination) {
        this.packageId = packageId;
        this.destination = destination;
        this.status = "PENDING"; // Packages are pending upon creation
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the package status as DISPATCHED.
     */
    public void markAsDispatched() {
        this.status = "DISPATCHED";
    }

    /**
     * Provides a string representation of the Package object.
     *
     * @return A formatted string showing package details.
     */
    @Override
    public String toString() {
        return "Package ID: " + packageId + ", Destination: " + destination + ", Status: " + status;
    }
}

// Main class for the Logistics Package Management System
public class LogisticsSystem {

    private Queue<Package> pendingPackages; // Queue for packages awaiting processing
    private List<Package> dispatchedPackages; // List for packages that have been processed
    private Scanner scanner;

    /**
     * Constructs a new LogisticsSystem.
     */
    public LogisticsSystem() {
        this.pendingPackages = new LinkedList<>(); // LinkedList implements Queue
        this.dispatchedPackages = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Logistics System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Pending Packages");
        System.out.println("4. View Dispatched Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package to the pending queue based on user input.
     */
    private void addNewPackage() {
        System.out.print("Enter Package ID: ");
        String packageId = scanner.nextLine();
        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine();

        if (packageId == null || packageId.trim().isEmpty() || destination == null || destination.trim().isEmpty()) {
            System.err.println("Error: Package ID and Destination cannot be empty.");
            return;
        }

        Package newPackage = new Package(packageId.trim(), destination.trim());
        pendingPackages.offer(newPackage); // Add to the end of the queue
        System.out.println("Package " + packageId + " added to pending queue.");
    }

    /**
     * Processes the next package in the pending queue.
     * Removes it from the queue, marks it as dispatched, and adds it to the dispatched list.
     */
    private void processNextPackage() {
        Package packageToProcess = pendingPackages.poll(); // Retrieve and remove head of queue

        if (packageToProcess == null) {
            System.err.println("Error: No packages in the pending queue to process.");
        } else {
            packageToProcess.markAsDispatched();
            dispatchedPackages.add(packageToProcess); // Add to the dispatched list
            System.out.println("Package " + packageToProcess.getPackageId() + " to " + packageToProcess.getDestination() + " processed and dispatched.");
        }
    }

    /**
     * Displays all packages currently in the pending queue.
     */
    private void viewPendingPackages() {
        System.out.println("\n--- Pending Packages ---");
        if (pendingPackages.isEmpty()) {
            System.out.println("No pending packages.");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : pendingPackages) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Displays all packages currently in the dispatched list.
     */
    private void viewDispatchedPackages() {
        System.out.println("\n--- Dispatched Packages ---");
        if (dispatchedPackages.isEmpty()) {
            System.out.println("No dispatched packages.");
        } else {
            for (Package pkg : dispatchedPackages) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Runs the main loop of the logistics system.
     * Handles user input and dispatches actions based on menu choice.
     */
    public void run() {
        int choice = 0;
        while (choice != 5) {
            displayMenu();
            try {
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } else {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the non-integer input to prevent infinite loop
                    continue; // Skip the switch and re-display menu
                }

                // Validate the integer choice
                if (choice < 1 || choice > 5) {
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    continue; // Skip the switch and re-display menu
                }

                // Process valid choice using switch
                switch (choice) {
                    case 1:
                        addNewPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewPendingPackages();
                        break;
                    case 4:
                        viewDispatchedPackages();
                        break;
                    case 5:
                        System.out.println("Exiting Logistics System.");
                        break;
                    default:
                        // This case should ideally not be reached due to the validation above
                        System.err.println("Error: Unexpected choice value.");
                        break;
                }
            } catch (InputMismatchException e) {
                // This catch block is less likely to be hit now due to hasNextInt(),
                // but kept for robustness or if validation logic changes.
                System.err.println("Error: Invalid input. Please enter a valid number.");
                scanner.next(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        LogisticsSystem system = new LogisticsSystem();
        system.run();
    }
}
