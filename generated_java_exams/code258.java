/*
 * Exam Question #258
 * Generated on: 2025-05-11 22:45:47
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Task Management System Simulation**
 * 
 * Develop a Java program that simulates a simple task management system. The system should allow users to add new tasks, process the next available task from a queue, and view the status of all tasks (pending, completed, failed).
 * 
 * Your solution must demonstrate proficiency in core Java concepts and adhere to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `taskId`: An integer, uniquely identifying the task.
 *     *   `description`: A String describing the task.
 *     *   `status`: A String representing the task's current status (e.g., "PENDING", "COMPLETED", "FAILED").
 *     *   Include a constructor, getters, and a method to set the status. Implement a `toString()` method for easy printing.
 * 
 * 2.  **Task Management System:** Create a class `TaskSystem` that manages the tasks. It should have:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   An `ArrayList<Task>` to store completed tasks.
 *     *   An `ArrayList<Task>` to store failed tasks.
 *     *   A mechanism to generate unique task IDs (e.g., a static counter).
 * 
 * 3.  **Functionality:** Implement the following methods in `TaskSystem`:
 *     *   `addTask(String description)`: Creates a new `Task` with status "PENDING", assigns a unique ID, and adds it to the pending task queue. Includes input validation to ensure the description is not empty.
 *     *   `processNextTask()`: Retrieves the next task from the pending queue. Simulates processing the task. For demonstration purposes, simulate a potential failure (e.g., randomly, or if the description contains a specific keyword like "FAIL"). If processing succeeds, move the task to the completed list and set status to "COMPLETED". If it fails (simulated), move the task to the failed list, set status to "FAILED", and report the failure using `System.err`. Handle the case where the queue is empty.
 *     *   `viewStatus()`: Prints the details of tasks in the pending queue, completed list, and failed list using `System.out`.
 * 
 * 4.  **User Interface:** Implement a simple command-line interface in the `main` method (or a separate `App` class) using `Scanner` to interact with the `TaskSystem`. The interface should present a menu with options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Task Status
 *     *   4. Exit
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 
 * 6.  **Error Handling:**
 *     *   Use `System.err` to display error messages, such as invalid input, processing failures, or attempting to process when the queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input processing and the task processing simulation, to catch potential exceptions (e.g., `InputMismatchException`, or a custom/simulated exception during processing).
 * 
 * 7.  **Required Components:** Your solution MUST use ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (use `List` interface references where appropriate)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks for exception handling.
 * 
 * 8.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs are a plus).
 *     *   Input validation.
 *     *   Clean code structure.
 * 
 * **Expected Interaction:**
 * 
 * The program should display the menu, prompt for user input, perform the requested action, and display results or errors. This loop continues until the user chooses to exit.
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Status
 * 4. Exit
 * Enter your choice:
 * ```
 * 
 * If 'Add New Task' is chosen:
 * ```
 * Enter task description:
 * ```
 * (User enters description)
 * ```
 * Task [ID] added to queue.
 * ```
 * (If description is empty)
 * ```
 * Error: Task description cannot be empty.
 * ```
 * 
 * If 'Process Next Task' is chosen:
 * ```
 * Processing task [ID]...
 * ```
 * (If successful)
 * ```
 * Task [ID] completed.
 * ```
 * (If simulated failure)
 * ```
 * Error processing task [ID]: [Failure Reason]
 * ```
 * (If queue is empty)
 * ```
 * No tasks in the queue to process.
 * ```
 * 
 * If 'View Task Status' is chosen:
 * ```
 * --- Task Status ---
 * Pending Tasks:
 * - Task [ID]: [Description]
 * Completed Tasks:
 * - Task [ID]: [Description]
 * Failed Tasks:
 * - Task [ID]: [Description]
 * -------------------
 * ```
 * 
 * If 'Exit' is chosen:
 * ```
 * Exiting Task Management System.
 * ```
 * 
 * If an invalid choice is entered:
 * ```
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * ```
 * 
 * If invalid input type (non-integer) is entered for choice:
 * ```
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required components.
 * *   Logical flow and correct functionality for all menu options.
 * *   Effective use of `Queue` and `List`/`ArrayList`.
 * *   Proper implementation of `switch` and `Scanner`.
 * *   Robust error handling using `try-catch` and `System.err`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clear and correct output using `System.out` and `System.err`.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System, demonstrating the required Java concepts in a cohesive manner.
 * 
 * **Key Components and Concepts:**
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses `private` fields (`taskId`, `description`, `status`) for encapsulation.
 *     *   Includes a static counter `nextTaskId` to ensure unique IDs for each task instance.
 *     *   Provides `public` getter methods and a setter for the status.
 *     *   The `toString()` method provides a convenient formatted output for task details.
 * 
 * 2.  **`TaskSystem` Class:**
 *     *   Acts as the core manager of the system.
 *     *   **`Queue<Task> taskQueue`:** A `LinkedList` is used as an implementation of the `Queue` interface. This naturally models the "pending tasks" list where tasks are added to the end and processed from the front (FIFO - First-In, First-Out). The `offer()` method is used for adding (safer than `add` in queues) and `poll()` for retrieving and removing the head of the queue.
 *     *   **`List<Task> completedTasks` and `List<Task> failedTasks`:** `ArrayList` is used to implement the `List` interface. These lists store tasks after they have been processed, regardless of success or failure. `ArrayList` provides dynamic resizing and efficient element addition/access. Using `List` as the reference type is good practice, allowing flexibility to switch to other `List` implementations if needed.
 *     *   **`addTask(String description)`:** Demonstrates adding elements to the queue (`taskQueue.offer()`). Includes basic input validation for the description.
 *     *   **`processNextTask()`:**
 *         *   Uses `taskQueue.poll()` to get the next task, which returns `null` if the queue is empty, handled gracefully.
 *         *   Simulates task processing using a random number and checking for a specific keyword ("FAIL") in the description.
 *         *   Crucially, it uses a `try-catch` block around the simulated processing logic. Although the simulated failure here throws a generic `RuntimeException`, in a real-world scenario, this block would catch specific exceptions that might occur during actual task execution (e.g., network errors, file access issues, data processing errors).
 *         *   Based on the simulated outcome (success or caught exception), the task's status is updated (`setStatus()`), and it's moved to the appropriate `ArrayList` (`completedTasks` or `failedTasks`).
 *         *   Error reporting for failures uses `System.err`.
 *     *   **`viewStatus()`:** Iterates through the queue and both lists to display the current state of all tasks using `System.out`. Iterating the `Queue` directly (e.g., with a for-each loop) allows viewing elements without removing them.
 * 
 * 3.  **`TaskManagerApp` Class (`main` method):**
 *     *   Contains the main execution logic and user interface.
 *     *   **`Scanner scanner`:** Used to read input from the console (`System.in`).
 *     *   **`while(running)` loop:** Keeps the application running until the user chooses to exit.
 *     *   **`try-catch` block:** A comprehensive `try-catch` block wraps the main loop content. This demonstrates class-wide or main loop exception handling. It specifically catches `InputMismatchException` for handling cases where the user enters non-integer input when a number is expected for the menu choice. A general `Exception` catch is also included for any other unexpected errors within the loop, printing an error message to `System.err`.
 *     *   **Input Validation (`scanner.hasNextInt()`):** Before reading the integer choice, `hasNextInt()` is used to peek and see if the next token is an integer. If not, an error is printed to `System.err`, the invalid input is consumed (`scanner.next()`), and the loop continues, preventing an `InputMismatchException` from being thrown immediately by `scanner.nextInt()`.
 *     *   **`switch (choice)`:** Manages the flow based on the valid integer input from the user, directing execution to the appropriate `TaskSystem` method or handling the exit condition.
 *     *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls when reading the task description.
 *     *   `System.out.println()` and `System.err.println()` are used appropriately for normal output and error messages, respectively.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** `Task` fields are private, accessed via public methods.
 * *   **Meaningful Names:** Classes, methods, and variables have descriptive names (`taskQueue`, `processNextTask`, `completedTasks`, `description`).
 * *   **Comments:** Javadoc-style comments explain the purpose of classes, methods, and parameters.
 * *   **Input Validation:** The `addTask` method checks for empty descriptions, and the main loop checks for valid integer input.
 * *   **Error Handling:** `try-catch` blocks are used for potential input and processing errors, and `System.err` is used for error output.
 * *   **Clean Structure:** The code is divided into logical classes (`Task`, `TaskSystem`, `TaskManagerApp`).
 * 
 * This solution effectively integrates all required components to build a functional, albeit simple, task management system simulation, demonstrating a solid understanding of fundamental and intermediate Java concepts, including data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

// Represents a single task
class Task {
    private static int nextTaskId = 1; // Static counter for unique IDs

    private int taskId;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED", "FAILED"

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.taskId = nextTaskId++;
        this.description = description;
        this.status = "PENDING";
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     * @param status The new status ("PENDING", "COMPLETED", "FAILED").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string including task ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task " + taskId + ": \"" + description + "\" [" + status + "]";
    }
}

// Manages the task queue and processed task lists
class TaskSystem {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList
    private List<Task> failedTasks;   // Using List interface, implemented by ArrayList
    private Random random; // For simulating processing success/failure

    /**
     * Constructs a new TaskSystem, initializing queues and lists.
     */
    public TaskSystem() {
        // LinkedList is a common implementation of Queue
        this.taskQueue = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // offer is preferred over add for queues (returns false instead of throwing exception)
        System.out.println("Task " + newTask.getTaskId() + " added to queue.");
    }

    /**
     * Processes the next task from the queue. Simulates success or failure.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.out.println("No tasks in the queue to process.");
            return;
        }

        System.out.println("Processing task " + taskToProcess.getTaskId() + ": \"" + taskToProcess.getDescription() + "\"...");

        try {
            // --- Simulate Task Processing ---
            // Simulate success 80% of the time, failure 20%
            boolean success = random.nextDouble() < 0.8;

            // Also simulate failure if description contains "FAIL" keyword (case-insensitive)
            if (taskToProcess.getDescription().toUpperCase().contains("FAIL")) {
                success = false;
            }

            if (success) {
                // Simulate work... maybe sleep for a bit in a real system
                taskToProcess.setStatus("COMPLETED");
                completedTasks.add(taskToProcess);
                System.out.println("Task " + taskToProcess.getTaskId() + " completed successfully.");
            } else {
                // Simulate failure - could involve throwing/catching an exception here for more realism
                throw new RuntimeException("Simulated processing failure or contains 'FAIL' keyword.");
            }
        } catch (Exception e) {
            // Class-wide exception handling for processing errors
            taskToProcess.setStatus("FAILED");
            failedTasks.add(taskToProcess);
            System.err.println("Error processing task " + taskToProcess.getTaskId() + ": " + e.getMessage());
        }
    }

    /**
     * Displays the status of all tasks (pending, completed, failed).
     */
    public void viewStatus() {
        System.out.println("\n--- Task Status ---");

        System.out.println("Pending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("- No pending tasks.");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println("- " + task);
            }
        }

        System.out.println("\nCompleted Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("- No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println("- " + task);
            }
        }

        System.out.println("\nFailed Tasks:");
        if (failedTasks.isEmpty()) {
            System.out.println("- No failed tasks.");
        } else {
            for (Task task : failedTasks) {
                System.out.println("- " + task);
            }
        }
        System.out.println("-------------------\n");
    }
}

// Main class to run the application
public class TaskManagerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskSystem taskSystem = new TaskSystem();
        boolean running = true;

        System.out.println("--- Welcome to Task Management System ---");

        // Main application loop with exception handling
        while (running) {
            try {
                printMenu();
                System.out.print("Enter your choice: ");

                // Use hasNextInt() to check for integer input before reading
                if (!scanner.hasNextInt()) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskSystem.addTask(description);
                        break;
                    case 2:
                        taskSystem.processNextTask();
                        break;
                    case 3:
                        taskSystem.viewStatus();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (InputMismatchException e) {
                // This catch block is specifically for non-integer input if not caught by hasNextInt()
                // or if there's an issue with nextLine after nextInt in complex scenarios.
                // hasNextInt() check above makes this less likely for the *choice* itself,
                // but good practice for general input loops.
                System.err.println("Error: Invalid input type. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input line
            } catch (Exception e) {
                // General catch for any other unexpected exceptions in the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Status");
        System.out.println("4. Exit");
    }
}
