/*
 * Exam Question #945
 * Generated on: 2025-05-12 17:03:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Customer Support Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line customer support ticket management system. The system should allow users (acting as support agents) to perform basic operations: submit new tickets, view tickets currently waiting for processing, process the next waiting ticket, and view tickets that have already been processed.
 * 
 * Your solution must adhere to the following requirements and demonstrate advanced Java programming concepts:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage tickets that are pending processing. Tickets should be processed in the order they are submitted (FIFO).
 *     *   Use a `java.util.ArrayList` to store tickets that have been processed.
 *     *   Declare the variable holding the processed tickets using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and ticket details from the console.
 *     *   Present a menu of available actions to the user.
 *     *   Handle user input gracefully.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to dispatch actions based on the user's command.
 *     *   Implement a loop to keep the system running until the user explicitly chooses to exit.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, ticket information, and success messages.
 *     *   Use `System.err` specifically for displaying error messages (e.g., invalid commands, attempting to process when no tickets are pending).
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide or main operational loop exception handling using `try-catch` blocks to prevent the program from crashing due to unexpected errors, particularly related to input or operations on data structures.
 *     *   Perform input validation where necessary (e.g., ensuring ticket description is not empty).
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Ticket` class to represent a support ticket. This class should encapsulate ticket details (e.g., unique ID, description).
 *     *   Implement proper encapsulation (private fields, public getters) in the `Ticket` class.
 *     *   Design the main system class (`SupportSystem`) with private fields for data structures and a public method (`run`) to start the system's main loop.
 * 
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc comments for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Ticket Details:**
 * Each ticket should have:
 * *   A unique integer ID (assigned sequentially starting from 1).
 * *   A String description of the issue.
 * 
 * **System Operations:**
 * 1.  **Submit Ticket:** Prompt the user for a ticket description, create a new `Ticket` object with the next available ID, and add it to the pending queue.
 * 2.  **View Pending Tickets:** Display all tickets currently in the pending queue. Do not remove tickets from the queue when viewing.
 * 3.  **Process Next Ticket:** Remove the ticket at the front of the pending queue, mark it as processed (by moving it to the processed list), and display a confirmation message including the ticket ID. If the queue is empty, display an error message using `System.err`.
 * 4.  **View Processed Tickets:** Display all tickets that have been processed from the processed list.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Expected Output:**
 * The system should display a menu, accept commands, and produce output similar to the following (exact formatting may vary):
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Processed Tickets
 * 5. Exit
 * ----------------------------------
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * 
 * Ticket submitted successfully! Ticket ID: 1
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Network issue in office B
 * 
 * Ticket submitted successfully! Ticket ID: 2
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Pending Tickets:
 * Ticket ID: 1, Description: Printer not working
 * Ticket ID: 2, Description: Network issue in office B
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * Processing ticket ID: 1
 * 
 * Ticket ID 1 processed successfully!
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Pending Tickets:
 * Ticket ID: 2, Description: Network issue in office B
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * Processed Tickets:
 * Ticket ID: 1, Description: Printer not working
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * Processing ticket ID: 2
 * 
 * Ticket ID 2 processed successfully!
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * Processed Tickets:
 * Ticket ID: 1, Description: Printer not working
 * Ticket ID: 2, Description: Network issue in office B
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * Error: No pending tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Support Ticket System.
 * ```
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple customer support ticket management system demonstrating the required Java concepts.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with a unique `id` and a `description`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides public getter methods (`getId`, `getDescription`).
 *     *   Includes a `toString()` method for easy printing of ticket details.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   **Data Structures:**
 *         *   `private Queue<Ticket> pendingTickets;`: Declared as `Queue`, instantiated with `LinkedList`. `LinkedList` is a common implementation of `Queue` that provides FIFO behavior suitable for a waiting line of tickets.
 *         *   `private List<Ticket> processedTickets;`: Declared using the `List` interface type, instantiated with `ArrayList`. `ArrayList` is a dynamic array suitable for storing processed items where order is maintained and access by index is efficient (though not used in this specific display logic). Using the `List` interface adheres to the requirement and promotes programming to interfaces.
 *     *   **State:**
 *         *   `private int nextTicketId;`: Keeps track of the next ID to assign, ensuring uniqueness.
 *         *   `private Scanner scanner;`: Used for reading user input.
 *     *   **Constructor:** Initializes the `Queue`, `List`, `nextTicketId`, and `Scanner`.
 *     *   **`displayMenu()`:** A helper method to print the user menu using `System.out`.
 *     *   **`submitTicket()`:**
 *         *   Prompts the user for input using `System.out`.
 *         *   Reads the description using `scanner.nextLine()`.
 *         *   Performs basic input validation: checks if the description is empty. If so, it prints an error message using `System.err` and returns.
 *         *   Creates a new `Ticket` object using the current `nextTicketId` and the provided description.
 *         *   Adds the new ticket to the `pendingTickets` queue using `add()`. The `Queue` interface guarantees it's added to the tail.
 *         *   Increments `nextTicketId` for the next submission.
 *         *   Prints a success message using `System.out`.
 *     *   **`viewPendingTickets()`:**
 *         *   Checks if the `pendingTickets` queue is empty and prints a message if it is.
 *         *   If not empty, it iterates through the `pendingTickets` queue using an enhanced for loop. This allows viewing elements without removing them from the queue, preserving the queue's state.
 *         *   Prints each ticket's details using its `toString()` method via `System.out`.
 *     *   **`processNextTicket()`:**
 *         *   Checks if the `pendingTickets` queue is empty. If so, it prints an error message using `System.err` and returns.
 *         *   If not empty, it removes the ticket at the head of the queue using `poll()`. `poll()` returns `null` if the queue is empty, but we've already checked for emptiness.
 *         *   Adds the removed ticket to the `processedTickets` `List` using `add()`.
 *         *   Prints success messages using `System.out`, indicating which ticket was processed.
 *     *   **`viewProcessedTickets()`:**
 *         *   Checks if the `processedTickets` list is empty and prints a message if it is.
 *         *   If not empty, it iterates through the `processedTickets` list using an enhanced for loop.
 *         *   Prints each processed ticket's details using `System.out`.
 *     *   **`run()`:**
 *         *   Contains the main application loop (`while (choice != 5)`).
 *         *   Calls `displayMenu()`.
 *         *   Uses a `try-catch` block to wrap the core command processing logic. This handles potential exceptions like `InputMismatchException` if the user enters non-numeric input for the choice, or other unexpected errors.
 *         *   Reads the user's integer choice using `scanner.nextInt()`. **Note:** `scanner.nextLine()` is called after `nextInt()` in `submitTicket` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *         *   Uses a `switch` statement to execute the appropriate method based on the user's `choice`.
 *         *   Includes a `default` case in the `switch` to handle invalid numerical input, printing an error using `System.err`.
 *         *   The `catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice. It prints an error using `System.err` and consumes the invalid input (`scanner.next()`) to avoid an infinite loop caused by the scanner repeatedly failing on the same token.
 *         *   A general `catch (Exception e)` block is included to catch any other unexpected runtime exceptions, printing a generic error message using `System.err`.
 *         *   The loop continues until the user enters `5`.
 *         *   The `scanner.close()` method is called after the loop terminates to release system resources.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `SupportSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively utilizes all required components within a structured, object-oriented design, incorporates input validation and error handling, and simulates a practical scenario, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single support ticket.
 */
class Ticket {
    private int id;
    private String description;

    /**
     * Constructs a new Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the support issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the ticket ID.
     * @return The ticket ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the ticket description.
     * @return The ticket description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string for the ticket.
     */
    @Override
    public String toString() {
        return "Ticket ID: " + id + ", Description: " + description;
    }
}

/**
 * Manages the support ticket system operations.
 */
public class SupportSystem {
    // Queue to hold tickets waiting for processing (FIFO)
    private Queue<Ticket> pendingTickets;
    // List to hold tickets that have been processed
    private List<Ticket> processedTickets; // Declared using List interface
    private int nextTicketId; // Counter for assigning unique ticket IDs
    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new SupportSystem.
     * Initializes the data structures, ticket ID counter, and scanner.
     */
    public SupportSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedTickets = new ArrayList<>(); // ArrayList for processed tickets
        this.nextTicketId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Process Next Ticket");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
        System.out.println("----------------------------------");
        System.out.print("Enter your choice: ");
    }

    /**
     * Submits a new ticket based on user input.
     */
    private void submitTicket() {
        System.out.print("Enter ticket description: ");
        scanner.nextLine(); // Consume the newline character left by previous nextInt() or similar
        String description = scanner.nextLine().trim();

        // Input validation
        if (description.isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }

        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.add(newTicket); // Add to the end of the queue
        System.out.println("\nTicket submitted successfully! Ticket ID: " + newTicket.getId());
    }

    /**
     * Displays all tickets currently in the pending queue without removing them.
     */
    private void viewPendingTickets() {
        if (pendingTickets.isEmpty()) {
            System.out.println("\nNo pending tickets.");
        } else {
            System.out.println("\nPending Tickets:");
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Processes the next ticket in the pending queue by moving it to the processed list.
     */
    private void processNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("\nError: No pending tickets to process.");
            return;
        }

        Ticket ticketToProcess = pendingTickets.poll(); // Remove the head of the queue (FIFO)
        processedTickets.add(ticketToProcess); // Add to the processed list
        System.out.println("\nProcessing ticket ID: " + ticketToProcess.getId());
        System.out.println("Ticket ID " + ticketToProcess.getId() + " processed successfully!");
    }

    /**
     * Displays all tickets that have been moved to the processed list.
     */
    private void viewProcessedTickets() {
        if (processedTickets.isEmpty()) {
            System.out.println("\nNo tickets have been processed yet.");
        } else {
            System.out.println("\nProcessed Tickets:");
            // Iterate through the list
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Starts the main loop of the support system.
     * Handles user input and dispatches actions using a switch statement.
     * Includes class-wide try-catch for robust operation.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt(); // Read the integer choice

                // Use switch statement for control flow
                switch (choice) {
                    case 1:
                        submitTicket();
                        break;
                    case 2:
                        viewPendingTickets();
                        break;
                    case 3:
                        processNextTicket();
                        break;
                    case 4:
                        viewProcessedTickets();
                        break;
                    case 5:
                        System.out.println("\nExiting Support Ticket System.");
                        break;
                    default:
                        // Invalid choice handling
                        System.err.println("\nError: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("\nError: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("\nAn unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
            }
        }
        // Close the scanner when the program exits
        scanner.close();
    }

    /**
     * Main method to start the SupportSystem application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
