/*
 * Exam Question #605
 * Generated on: 2025-05-12 16:13:43
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Bug Tracking System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line application to simulate a basic bug tracking system. The system should allow users to submit new bugs, view all bugs in the system, and triage (process) the next bug awaiting review.
 * 
 * **Requirements:**
 * 
 * 1.  **Bug Representation:** Create a `Bug` class with the following private fields:
 *     *   `id` (int): A unique identifier for the bug, automatically generated.
 *     *   `description` (String): A brief description of the bug.
 *     *   `priority` (String): The bug's priority (e.g., "High", "Medium", "Low").
 *     *   `status` (String): The current status of the bug (e.g., "Submitted", "Triaged", "Deferred", "Resolved", "Closed").
 *     *   Include a constructor, appropriate getters for all fields, and a setter for the `status` field. Implement a `toString()` method for easy printing of bug details.
 * 
 * 2.  **Bug Tracking System Logic:** Create a `BugTrackingSystem` class to manage the bugs. This class must utilize:
 *     *   A `Queue<Bug>` to hold newly submitted bugs that are awaiting triage.
 *     *   A `List<Bug>` (implemented by `ArrayList`) to store *all* bugs that have ever been submitted, regardless of their status.
 *     *   A mechanism to generate unique bug IDs (a simple counter is sufficient).
 * 
 * 3.  **Core Operations:** Implement the following public methods in the `BugTrackingSystem` class:
 *     *   `submitBug(String description, String priority)`: Creates a new `Bug` object, assigns it a unique ID, adds it to both the queue of new bugs and the list of all bugs, and prints a success message.
 *     *   `listAllBugs()`: Prints the details of all bugs currently in the `allBugsList`. If the list is empty, print an appropriate message.
 *     *   `triageNextBug(String newStatus)`: Removes the next bug from the `newBugsQueue`. If the queue is empty, print an error message to `System.err`. If a bug is successfully retrieved, find this bug in the `allBugsList` and update its status to the provided `newStatus`. Print a success message to `System.out`. (Assume the `newStatus` provided is valid for this operation).
 * 
 * 4.  **User Interface:** Implement a `run()` method in `BugTrackingSystem` that provides a command-line interface using `java.util.Scanner`. The interface should present a menu with options for:
 *     *   1. Submit New Bug
 *     *   2. List All Bugs
 *     *   3. Triage Next Bug
 *     *   0. Exit
 *     *   Use a `switch` statement to handle user input for menu selection.
 *     *   Use `System.out` for menu prompts, normal messages, and bug listings.
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, queue empty, input validation failures).
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   Implement input validation for bug submission (e.g., description not empty, valid priority string). Throw `IllegalArgumentException` for invalid input during bug creation or submission.
 *     *   Handle potential `java.util.InputMismatchException` when reading user input with `Scanner`.
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main user interaction loop in the `run()` method. This catch block should handle any unexpected exceptions and print an error message to `System.err`. Include a `finally` block to close the `Scanner`.
 * 
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, methods, and variables.
 *     *   Include appropriate comments and basic documentation (e.g., method descriptions).
 *     *   Structure the code cleanly with separate classes.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and print results or error messages accordingly.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * --- Bug Tracking System Menu ---
 * 1. Submit New Bug
 * 2. List All Bugs
 * 3. Triage Next Bug
 * 0. Exit
 * --------------------------------
 * Enter choice: 1
 * Enter bug description: App crashes on login
 * Enter bug priority (High, Medium, Low): High
 * Bug submitted successfully! ID: 1
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 1
 * Enter bug description: UI glitch on profile page
 * Enter bug priority (High, Medium, Low): Medium
 * Bug submitted successfully! ID: 2
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 2
 * --- All Bugs ---
 * Bug ID: 1, Desc: "App crashes on login", Priority: High, Status: Submitted
 * Bug ID: 2, Desc: "UI glitch on profile page", Priority: Medium, Status: Submitted
 * ----------------
 * ...
 * Enter choice: 3
 * Enter new status for the bug (Triaged, Deferred, Resolved, Closed): Triaged
 * Bug ID 1 triaged. Status updated to: Triaged
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 3
 * Enter new status for the bug (Triaged, Deferred, Resolved, Closed): Resolved
 * Bug ID 2 triaged. Status updated to: Resolved
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 3
 * No bugs currently awaiting triage.
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 2
 * --- All Bugs ---
 * Bug ID: 1, Desc: "App crashes on login", Priority: High, Status: Triaged
 * Bug ID: 2, Desc: "UI glitch on profile page", Priority: Medium, Status: Resolved
 * ----------------
 * ...
 * Enter choice: abc
 * Invalid input. Please enter a number for the menu choice.
 * 
 * --- Bug Tracking System Menu ---
 * ...
 * Enter choice: 0
 * Exiting Bug Tracking System.
 * ```
 * 
 * Your solution should be a single Java file containing both classes.
 *
 * EXPLANATION:
 * This solution implements a basic Bug Tracking System satisfying all the requirements of the exam task.
 * 
 * 1.  **Class Structure:** The system is divided into two main classes: `Bug` to represent the data structure for a single bug, and `BugTrackingSystem` to manage the collection of bugs and handle user interaction. This promotes modularity and encapsulation.
 * 
 * 2.  **Data Structures (`Queue`, `List`/`ArrayList`):**
 *     *   A `Queue<Bug>` named `newBugsQueue` (implemented using `java.util.LinkedList`) is used to store bugs immediately after submission. This follows the First-In, First-Out (FIFO) principle, ensuring that the oldest submitted bug is triaged first when the user selects option 3. The `offer()` method is used to add to the queue, and `poll()` is used to remove from the front.
 *     *   A `List<Bug>` named `allBugsList` (implemented using `java.util.ArrayList`) is used to maintain a complete record of all bugs ever submitted to the system. This list allows iterating through all bugs for the listing operation (option 2) and provides a way to find and update the status of a bug after it has been polled from the `newBugsQueue`.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   The `run()` method contains the main application loop.
 *     *   `java.util.Scanner` is used to read input from the console.
 *     *   A `switch` statement is used within the loop to direct the program flow based on the user's numeric menu choice.
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, success messages, and the list of bugs.
 *     *   `System.err.println()` is used specifically for outputting error messages, such as invalid input, attempting to triage when the queue is empty, or validation failures.
 * 
 * 4.  **Operations (`submitBug`, `listAllBugs`, `triageNextBug`):**
 *     *   `submitBug`: Creates a `Bug` object, adds it to both `newBugsQueue` and `allBugsList`, and increments a simple `nextBugId` counter.
 *     *   `listAllBugs`: Iterates through the `allBugsList` and prints each `Bug` object's details using its `toString()` method.
 *     *   `triageNextBug`: Uses `newBugsQueue.poll()` to get the next bug awaiting triage. It then iterates through `allBugsList` to find the corresponding bug by its ID and updates its status using the `setStatus()` method.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   **Class-wide Handling:** The `run()` method is wrapped in a large `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, ensuring that any unexpected runtime error that occurs within the main application logic is caught, reported to `System.err`, and prevents the program from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 *     *   **Specific Input Handling:** An inner `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer input when a menu choice is expected. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   **Validation Handling:** `IllegalArgumentException` is used for business logic validation errors (e.g., empty description, invalid priority or status). These exceptions are caught by a dedicated `catch(IllegalArgumentException e)` block within the loop, printing the specific validation error message to `System.err`.
 * 
 * 6.  **Input Validation:**
 *     *   Validation for bug description and priority is performed in the `Bug` class constructor and the `submitBug` method handles the resulting `IllegalArgumentException`.
 *     *   Validation for the new status during triage is performed in the `run` method *before* calling `triageNextBug` using the `isValidTriageStatusInput` helper method. This prevents calling the method with invalid data and simplifies the `triageNextBug` logic. The `Bug.setStatus` method also includes validation as a safeguard.
 * 
 * 7.  **Best Practices:**
 *     *   All fields in `Bug` and `BugTrackingSystem` are `private`, enforcing encapsulation. Public methods provide controlled access.
 *     *   Names like `newBugsQueue`, `allBugsList`, `submitBug`, `triageNextBug`, `description`, `priority`, `status` are descriptive.
 *     *   Basic comments explain the purpose of classes, fields, and key methods.
 *     *   The code is separated into logical units (`Bug` and `BugTrackingSystem`).
 * 
 * This solution effectively demonstrates the practical application of the required Java collections, control flow structures, and error handling mechanisms in building a functional command-line application.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single bug in the tracking system.
 */
class Bug {
    private int id;
    private String description;
    private String priority; // e.g., High, Medium, Low
    private String status;   // e.g., Submitted, Triaged, Deferred, Resolved, Closed

    /**
     * Constructs a new Bug object.
     * @param id The unique ID for the bug.
     * @param description A brief description of the bug.
     * @param priority The bug's priority.
     * @throws IllegalArgumentException if description is empty or priority is invalid.
     */
    public Bug(int id, String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Bug description cannot be empty.");
        }
        if (!isValidPriority(priority)) {
             throw new IllegalArgumentException("Invalid priority: " + priority + ". Must be High, Medium, or Low (case-insensitive).");
        }
        this.id = id;
        this.description = description.trim();
        this.priority = priority.trim();
        this.status = "Submitted"; // Initial status
    }

    /**
     * Validates if the provided priority string is acceptable.
     * @param priority The priority string to validate.
     * @return true if the priority is valid, false otherwise.
     */
    private boolean isValidPriority(String priority) {
        if (priority == null) return false;
        String lowerPriority = priority.trim().toLowerCase();
        return lowerPriority.equals("high") || lowerPriority.equals("medium") || lowerPriority.equals("low");
    }

    // Getters
    public int getId() { return id; }
    public String getDescription() { return description; }
    public String getPriority() { return priority; }
    public String getStatus() { return status; }

    /**
     * Sets the status of the bug.
     * @param status The new status for the bug.
     * @throws IllegalArgumentException if the status is invalid.
     */
    public void setStatus(String status) {
         if (!isValidStatus(status)) {
             throw new IllegalArgumentException("Invalid status: " + status + ". Must be Triaged, Deferred, Resolved, or Closed (case-insensitive).");
         }
        this.status = status.trim();
    }

    /**
     * Validates if the provided status string is acceptable for triage.
     * @param status The status string to validate.
     * @return true if the status is valid, false otherwise.
     */
    private boolean isValidStatus(String status) {
         if (status == null) return false;
         String lowerStatus = status.trim().toLowerCase();
         return lowerStatus.equals("triaged") || lowerStatus.equals("deferred") || lowerStatus.equals("resolved") || lowerStatus.equals("closed");
    }


    /**
     * Returns a string representation of the Bug object.
     */
    @Override
    public String toString() {
        return String.format("Bug ID: %d, Desc: \"%s\", Priority: %s, Status: %s",
                             id, description, priority, status);
    }
}

/**
 * Manages the collection of bugs using a queue for new submissions
 * and a list for all bugs.
 */
public class BugTrackingSystem {

    private Queue<Bug> newBugsQueue; // Bugs awaiting triage (FIFO)
    private List<Bug> allBugsList;   // All bugs in the system (for listing and lookup)
    private int nextBugId;           // Counter for unique bug IDs

    /**
     * Constructs a new BugTrackingSystem, initializing collections and ID counter.
     */
    public BugTrackingSystem() {
        this.newBugsQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allBugsList = new ArrayList<>();   // ArrayList implements List
        this.nextBugId = 1;
    }

    /**
     * Submits a new bug to the system.
     * Adds the bug to both the new bugs queue and the all bugs list.
     * @param description The description of the bug.
     * @param priority The priority of the bug.
     */
    public void submitBug(String description, String priority) {
        try {
            Bug newBug = new Bug(nextBugId, description, priority);
            newBugsQueue.offer(newBug); // Add to the end of the queue
            allBugsList.add(newBug);    // Add to the end of the list
            System.out.println("Bug submitted successfully! ID: " + nextBugId);
            nextBugId++; // Increment ID counter for the next bug
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Bug constructor
            System.err.println("Submission failed: " + e.getMessage());
        }
    }

    /**
     * Lists all bugs currently in the system.
     */
    public void listAllBugs() {
        if (allBugsList.isEmpty()) {
            System.out.println("No bugs in the system yet.");
            return;
        }
        System.out.println("--- All Bugs ---");
        // Iterate through the List to display all bugs
        for (Bug bug : allBugsList) {
            System.out.println(bug);
        }
        System.out.println("----------------");
    }

    /**
     * Triages the next bug from the queue.
     * Removes the bug from the queue and updates its status in the main list.
     * @param newStatus The status to set for the triaged bug.
     * @throws IllegalArgumentException if the newStatus is invalid (validation moved to run method).
     */
    public void triageNextBug(String newStatus) {
        // Check if queue is empty before attempting to poll
        if (newBugsQueue.isEmpty()) {
            System.err.println("No bugs currently awaiting triage.");
            return;
        }

        // Poll the next bug from the queue (removes it)
        Bug bugToTriage = newBugsQueue.poll();

        // Find this bug in the allBugsList to update its status
        boolean foundInList = false;
        for (Bug bug : allBugsList) {
            if (bug.getId() == bugToTriage.getId()) {
                try {
                    bug.setStatus(newStatus); // Update status using the setter (may throw IllegalArgumentException)
                    System.out.println("Bug ID " + bug.getId() + " triaged. Status updated to: " + newStatus);
                    foundInList = true;
                    break; // Found and updated, exit loop
                } catch (IllegalArgumentException e) {
                     // This catch is less likely if validation is done before calling,
                     // but handles potential stricter validation in Bug.setStatus
                     System.err.println("Triage status update failed for Bug ID " + bug.getId() + ": " + e.getMessage());
                }
            }
        }

        // This check is a safeguard; a bug polled from the queue should always be in the list
        if (!foundInList) {
             System.err.println("Internal Error: Triaged bug ID " + bugToTriage.getId() + " not found in the main bug list.");
        }
    }

    /**
     * Helper method to print the main menu options.
     */
    private void printMenu() {
        System.out.println("--- Bug Tracking System Menu ---");
        System.out.println("1. Submit New Bug");
        System.out.println("2. List All Bugs");
        System.out.println("3. Triage Next Bug");
        System.out.println("0. Exit");
        System.out.println("--------------------------------");
    }

    /**
     * Validates if the provided status string is acceptable for triage.
     * Used for input validation before calling triageNextBug.
     * @param status The status string to validate.
     * @return true if the status is valid, false otherwise.
     */
    private boolean isValidTriageStatusInput(String status) {
         if (status == null) return false;
         String lowerStatus = status.trim().toLowerCase();
         return lowerStatus.equals("triaged") || lowerStatus.equals("deferred") || lowerStatus.equals("resolved") || lowerStatus.equals("closed");
    }


    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        // Class-wide try-catch block to catch any unexpected exceptions
        try {
            int choice = -1;
            // Main loop continues until user chooses to exit (choice 0)
            while (choice != 0) {
                printMenu();
                System.out.print("Enter choice: ");
                try {
                    // Read user's menu choice
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1: // Submit New Bug
                            System.out.print("Enter bug description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter bug priority (High, Medium, Low): ");
                            String priority = scanner.nextLine();
                            submitBug(description, priority); // Call the submit bug method
                            break;
                        case 2: // List All Bugs
                            listAllBugs(); // Call the list all bugs method
                            break;
                        case 3: // Triage Next Bug
                            System.out.print("Enter new status for the bug (Triaged, Deferred, Resolved, Closed): ");
                            String newStatus = scanner.nextLine();
                            // Validate the status input before calling the triage method
                            if (newStatus == null || newStatus.trim().isEmpty()) {
                                System.err.println("Error: New status cannot be empty.");
                            } else if (!isValidTriageStatusInput(newStatus)) {
                                System.err.println("Error: Invalid status '" + newStatus + "'. Must be Triaged, Deferred, Resolved, or Closed.");
                            }
                            else {
                                triageNextBug(newStatus); // Call the triage method
                            }
                            break;
                        case 0: // Exit
                            System.out.println("Exiting Bug Tracking System.");
                            break;
                        default:
                            // Handle invalid numeric input for menu choice
                            System.err.println("Invalid choice. Please enter a number from the menu.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number for the menu choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                    choice = -1; // Reset choice to ensure loop continues
                } catch (IllegalArgumentException e) {
                    // Catch validation exceptions thrown by methods like submitBug or setStatus
                     System.err.println("Operation failed: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                     System.err.println("An error occurred during the operation: " + e.getMessage());
                     // e.printStackTrace(System.err); // Optional: for detailed debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // This catch block handles any exceptions that escape the inner handling,
            // demonstrating the class-wide exception handling requirement.
            System.err.println("An unexpected fatal error occurred in the system: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for fatal errors
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Bug Tracking System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BugTrackingSystem system = new BugTrackingSystem();
        system.run(); // Start the application
    }
}
