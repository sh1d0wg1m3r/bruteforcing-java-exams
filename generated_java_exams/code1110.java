/*
 * Exam Question #1110
 * Generated on: 2025-05-12 17:26:14
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Task Processing System. This system manages a queue of tasks waiting to be processed, and keeps track of tasks that have been successfully completed and those that have failed. Users interact with the system via a command-line interface to add new tasks, process the next waiting task, and view the status of tasks.
 * 
 * **System Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a unit of work. Each task must have:
 *     *   A unique integer ID.
 *     *   A string description of the task.
 *     *   A status (e.g., WAITING, COMPLETED, FAILED). Use an enum for the status.
 * 2.  **Task Management:**
 *     *   Maintain a queue of tasks that are waiting to be processed.
 *     *   Maintain two separate lists: one for completed tasks and one for failed tasks.
 *     *   Implement functionality to add a new task to the waiting queue. Tasks are added with WAITING status.
 *     *   Implement functionality to process the next task from the waiting queue.
 *         *   Processing a task should simulate work. For this exam, processing is simulated: if the task description contains the word "FAIL" (case-insensitive), the processing fails; otherwise, it succeeds.
 *         *   If processing succeeds, the task's status is updated to COMPLETED and it is moved from the queue to the completed list.
 *         *   If processing fails, the task's status is updated to FAILED and it is moved from the queue to the failed list. A message indicating failure should be printed to `System.err`.
 *         *   If the queue is empty when processing is attempted, an appropriate message should be printed to `System.out`.
 *     *   Implement functionality to display the tasks currently in the waiting queue, the completed tasks list, and the failed tasks list.
 * 3.  **User Interface:**
 *     *   Use `Scanner` to read user commands from the console.
 *     *   Support the following commands:
 *         *   `add <description>`: Adds a new task with the given description to the waiting queue. The description can contain spaces.
 *         *   `process`: Processes the next task from the waiting queue.
 *         *   `list_waiting`: Displays tasks in the waiting queue.
 *         *   `list_completed`: Displays tasks in the completed list.
 *         *   `list_failed`: Displays tasks in the failed list.
 *         *   `exit`: Terminates the program.
 *     *   Use a `switch` statement to handle different commands.
 *     *   Provide clear prompts and output messages to the user using `System.out`.
 *     *   Handle invalid commands by printing an error message to `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement input validation for the `add` command: Ensure the description is not empty. If empty, print an error to `System.err` and do not add the task.
 *     *   Use `try-catch` blocks to handle potential runtime errors during program execution, particularly around the main command processing loop or potentially during task processing simulation (though the simulated failure is deterministic based on description). A general `Exception` catch in the main loop is acceptable for unexpected issues.
 *     *   Use `System.err` specifically for error messages (input validation failures, processing failures, invalid commands).
 *     *   Use `System.out` for all normal output (prompts, menus, task lists, success messages).
 * 5.  **Code Structure and Best Practices:**
 *     *   Organize the code into appropriate classes (`Task`, `TaskProcessor`).
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Declare lists and queues using interface types (`List`, `Queue`).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks
 * 
 * **Expected Output Format:**
 * 
 * *   Menu/Prompt messages: Clear text using `System.out`.
 * *   Task listings: Display task ID, description, and status for each task using `System.out`.
 * *   Processing success: Message like "Task [ID] processed successfully." using `System.out`.
 * *   Processing failure: Message like "Task [ID] failed during processing." using `System.err`.
 * *   Input validation error: Message like "Error: Task description cannot be empty." using `System.err`.
 * *   Invalid command error: Message like "Error: Invalid command. Type 'menu' for options." using `System.err`.
 * *   Empty queue message: Message like "No tasks in the waiting queue to process." using `System.out`.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Task Processing System Menu:
 * add <description> - Add a new task
 * process - Process next waiting task
 * list_waiting - List waiting tasks
 * list_completed - List completed tasks
 * list_failed - List failed tasks
 * exit - Exit the system
 * Enter command: add Process data file
 * Task 1 added to the queue.
 * Enter command: add Clean up temporary files
 * Task 2 added to the queue.
 * Enter command: list_waiting
 * Waiting Tasks:
 * Task ID: 1, Description: Process data file, Status: WAITING
 * Task ID: 2, Description: Clean up temporary files, Status: WAITING
 * Enter command: process
 * Task 1 processed successfully.
 * Enter command: add Backup database (FAIL)
 * Task 3 added to the queue.
 * Enter command: process
 * Task 3 failed during processing.
 * Enter command: list_completed
 * Completed Tasks:
 * Task ID: 1, Description: Process data file, Status: COMPLETED
 * Enter command: list_failed
 * Failed Tasks:
 * Task ID: 3, Description: Backup database (FAIL), Status: FAILED
 * Enter command: process
 * Task 2 processed successfully.
 * Enter command: process
 * No tasks in the waiting queue to process.
 * Enter command: exit
 * Exiting Task Processing System.
 * ```
 * 
 * This task requires you to integrate several core Java concepts to build a functional, robust, and well-structured application. Good luck!
 *
 * EXPLANATION:
 * This solution implements the Task Processing System using the required Java components and best practices.
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in, providing clear and type-safe status representation.
 * 2.  **`Task` Class:**
 *     *   Encapsulates the data for a single task (id, description, status).
 *     *   Uses private fields and public getters.
 *     *   The constructor includes basic input validation for the description, throwing an `IllegalArgumentException` if it's empty or null.
 *     *   Includes a `setStatus` method to allow the `TaskProcessor` to update the task's state.
 *     *   Overrides `toString` for easy printing.
 * 3.  **`TaskProcessor` Class:**
 *     *   **Fields:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with a `LinkedList`. This structure is perfect for managing tasks in a First-In, First-Out (FIFO) manner.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with an `ArrayList`. `ArrayList` is suitable for storing completed tasks where order might be relevant but access by index isn't the primary operation (iterating is more common).
 *         *   `failedTasks`: Declared as `List<Task>` and initialized with an `ArrayList`, similar to `completedTasks`.
 *         *   `nextTaskId`: An integer to generate unique IDs for tasks.
 *         *   `scanner`: A `Scanner` instance for reading user input.
 *     *   **`addTask(String description)` Method:**
 *         *   Creates a new `Task` object.
 *         *   Uses a `try-catch` block specifically to handle the `IllegalArgumentException` thrown by the `Task` constructor if the description is invalid. Error messages are printed to `System.err`.
 *         *   Uses `taskQueue.offer()` to add the task to the queue. `offer` is preferred over `add` in queues as it returns `false` if the element cannot be added, whereas `add` throws an exception (though in this case with `LinkedList`, `offer` will not fail).
 *     *   **`processNextTask()` Method:**
 *         *   Uses `taskQueue.poll()` to retrieve and remove the next task from the front of the queue. `poll()` returns `null` if the queue is empty, which is handled gracefully by printing a message to `System.out`.
 *         *   Simulates processing: checks if the description (case-insensitive) contains "fail".
 *         *   Updates the task's status using `taskToProcess.setStatus()`.
 *         *   Adds the processed task to either the `completedTasks` or `failedTasks` list.
 *         *   Prints success messages to `System.out` and failure messages to `System.err`.
 *     *   **`displayTasks(Iterable<Task> tasks, String listName)` Method:**
 *         *   A helper method to iterate through any collection implementing `Iterable` (which `Queue` and `List` do) and print task details.
 *         *   Prints a message indicating the list name and iterates through the tasks, printing each one's `toString()` representation.
 *         *   Handles the case where a list/queue is empty.
 *     *   **`displayMenu()` Method:** Prints the available commands to `System.out`.
 *     *   **`run()` Method:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   Uses a `Scanner` to read user input line by line.
 *         *   Splits the input into a command and an optional argument.
 *         *   Uses a `switch` statement on the command string to direct execution flow to the appropriate method (`addTask`, `processNextTask`, `displayTasks`) or to handle `exit`.
 *         *   The `default` case of the `switch` handles invalid commands, printing an error to `System.err`.
 *         *   A broad `try-catch(Exception e)` block wraps the entire `while` loop. This demonstrates class-wide exception handling, catching any unexpected runtime errors that might occur during the command processing cycle (e.g., issues with input reading, although the `Scanner` is handled in `finally`). Specific, expected errors like invalid task descriptions are handled within the `addTask` method itself.
 *         *   A `finally` block ensures the `Scanner` is closed when the loop terminates or an exception occurs.
 *     *   **`main` Method:** Creates a `TaskProcessor` instance and calls its `run` method to start the application.
 * 
 * This solution effectively uses `Queue` for managing waiting items, `List` for storing categorized results, `Scanner` for user interaction, `switch` for command dispatch, `System.err` for errors, `System.out` for normal output, and `try-catch` for robust error handling, all within a well-structured object-oriented design following best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive comparison

// Enum for Task Status
enum TaskStatus {
    WAITING,
    COMPLETED,
    FAILED
}

// Task Class
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = TaskStatus.WAITING;
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Status: %s", id, description, status);
    }
}

// Task Processor System Class
class TaskProcessor {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private List<Task> failedTasks;
    private int nextTaskId;
    private Scanner scanner;

    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the waiting queue.
     *
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(nextTaskId++, description);
            taskQueue.offer(newTask); // offer is preferred over add for queues
            System.out.println("Task " + newTask.getId() + " added to the queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the waiting queue.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll retrieves and removes the head of the queue

        if (taskToProcess == null) {
            System.out.println("No tasks in the waiting queue to process.");
            return;
        }

        System.out.println("Processing Task ID: " + taskToProcess.getId() + "...");

        // Simulate task processing: Fails if description contains "FAIL"
        if (taskToProcess.getDescription().toLowerCase(Locale.ENGLISH).contains("fail")) {
            taskToProcess.setStatus(TaskStatus.FAILED);
            failedTasks.add(taskToProcess);
            System.err.println("Task " + taskToProcess.getId() + " failed during processing.");
        } else {
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " processed successfully.");
        }
    }

    /**
     * Displays tasks from a given list or queue.
     *
     * @param tasks    The list of tasks (or a queue).
     * @param listName The name of the list/queue to display.
     */
    private void displayTasks(Iterable<Task> tasks, String listName) {
        System.out.println(listName + ":");
        boolean found = false;
        for (Task task : tasks) {
            System.out.println(task);
            found = true;
        }
        if (!found) {
            System.out.println("  (Empty)");
        }
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\nTask Processing System Menu:");
        System.out.println("  add <description> - Add a new task");
        System.out.println("  process - Process next waiting task");
        System.out.println("  list_waiting - List waiting tasks");
        System.out.println("  list_completed - List completed tasks");
        System.out.println("  list_failed - List failed tasks");
        System.out.println("  exit - Exit the system");
        System.out.print("Enter command: ");
    }

    /**
     * Runs the main command processing loop.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                String inputLine = scanner.nextLine().trim();
                String[] parts = inputLine.split(" ", 2); // Split into command and potential argument
                String command = parts[0].toLowerCase(Locale.ENGLISH);
                String argument = parts.length > 1 ? parts[1].trim() : "";

                switch (command) {
                    case "add":
                        addTask(argument);
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "list_waiting":
                        displayTasks(taskQueue, "Waiting Tasks");
                        break;
                    case "list_completed":
                        displayTasks(completedTasks, "Completed Tasks");
                        break;
                    case "list_failed":
                        displayTasks(failedTasks, "Failed Tasks");
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Type 'menu' for options.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            scanner.close(); // Close the scanner when done
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessor system = new TaskProcessor();
        system.run();
    }
}
