/*
 * Exam Question #1120
 * Generated on: 2025-05-12 17:27:35
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Assembly Line Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simplified simulation system for an assembly line in a manufacturing plant. The system manages incoming "work items" that need to be processed sequentially. Work items arrive and are placed in a waiting queue. When the assembly line is ready, it processes the next item from the front of the queue, and the processed item is moved to a list of finished goods.
 * 
 * Your program should provide a console-based interface allowing a user to interact with this simulation.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow the user to add new work items to the assembly line queue. Each work item should have a unique ID (starting from 1), a name/description, and a status (e.g., "Waiting", "Processed").
 *     *   Allow the user to process the next work item from the front of the queue. If the queue is empty, inform the user. Processing an item should change its status and move it from the queue to a list of finished items.
 *     *   Allow the user to view the current state of the assembly line queue (items waiting).
 *     *   Allow the user to view the list of finished items.
 *     *   Allow the user to exit the simulation.
 * 
 * 2.  **Java Component Usage:** Your solution MUST utilize ALL of the following Java components:
 *     *   `java.util.Queue`: To represent the assembly line waiting queue.
 *     *   `java.util.ArrayList`: To store the list of finished items.
 *     *   `java.util.List`: Declare the finished items collection using the `List` interface type.
 *     *   `java.util.Scanner`: To read user input from the console.
 *     *   `switch` statement: To handle the user's menu choices.
 *     *   `System.err`: To output error messages (e.g., invalid input, trying to process an empty queue).
 *     *   `System.out`: To output normal messages (menu, prompts, success messages, list contents).
 *     *   Class-wide exception handling with `try-catch` blocks: Implement exception handling to gracefully manage potential runtime errors, including input errors (`InputMismatchException`) and any other unexpected issues within the main application loop. A general `catch (Exception e)` block wrapping the core logic loop demonstrates class-wide handling for potential unforeseen errors.
 * 
 * 3.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods) for any custom classes (e.g., `WorkItem`, the class managing the simulation).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., ensuring menu choice is an integer, handling empty item names).
 *     *   Implement proper error handling as specified in requirement 2.
 *     *   Maintain a clean and organized code structure (e.g., separate concerns into different methods or classes).
 * 
 * **User Interface (Console Menu):**
 * 
 * The program should present a menu similar to this:
 * 
 * ```
 * --- Assembly Line Simulation System ---
 * 
 * Select an option:
 * 1. Add New Work Item
 * 2. Process Next Work Item
 * 3. View Assembly Line Queue
 * 4. View Finished Items
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * **Expected Output:**
 * 
 * *   When adding an item, print a confirmation including the item's ID and name.
 * *   When processing an item, print which item was processed. If the queue is empty, print an error message to `System.err`.
 * *   When viewing the queue or finished items, list the items with their details. Print a message if a list is empty.
 * *   Invalid menu input (non-integer or out of range) should result in an error message printed to `System.err`, and the menu should be redisplayed.
 * *   Any unexpected errors caught by the general exception handler should be reported to `System.err` with a message indicating a critical error.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Assembly Line Simulation System ---
 * 
 * Select an option:
 * 1. Add New Work Item
 * ...
 * Enter your choice: 1
 * Enter name for the new work item: Part A
 * Added: WorkItem [ID=1, Name='Part A', Status='Waiting']
 * 
 * Select an option:
 * ...
 * Enter your choice: 1
 * Enter name for the new work item: Part B
 * Added: WorkItem [ID=2, Name='Part B', Status='Waiting']
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Assembly Line Queue ---
 * 1. WorkItem [ID=1, Name='Part A', Status='Waiting']
 * 2. WorkItem [ID=2, Name='Part B', Status='Waiting']
 * ---------------------------
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Attempting to process next item...
 * Processed: WorkItem [ID=1, Name='Part A', Status='Processed']
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Assembly Line Queue ---
 * 1. WorkItem [ID=2, Name='Part B', Status='Waiting']
 * ---------------------------
 * 
 * Select an option:
 * ...
 * Enter your choice: 4
 * --- Finished Items ---
 * 1. WorkItem [ID=1, Name='Part A', Status='Processed']
 * ----------------------
 * 
 * Select an option:
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Attempting to process next item...
 * Processed: WorkItem [ID=2, Name='Part B', Status='Processed']
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Attempting to process next item...
 * Assembly line queue is empty. No item to process.
 * 
 * Select an option:
 * ...
 * Enter your choice: 5
 * Exiting simulation. Goodbye!
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Assembly Line Simulation system using the specified Java components and best practices.
 * 
 * 1.  **`WorkItem` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) to represent the data for each work item.
 *     *   It has `private` fields (`id`, `name`, `status`) demonstrating encapsulation.
 *     *   It provides public getter methods to access the data and a setter for the `status`.
 *     *   The `toString()` method is overridden for convenient printing of item details.
 * 
 * 2.  **`AssemblyLineManager` Class:**
 *     *   This class encapsulates the core logic of the simulation, managing the collections and item processing.
 *     *   It holds a `private Queue<WorkItem> assemblyLineQueue` to model the waiting line. `java.util.LinkedList` is used as the concrete implementation because it efficiently supports adding elements to the tail (`offer()`) and removing from the head (`poll()`), which are the primary operations for a queue.
 *     *   It holds a `private List<WorkItem> finishedItems` to store processed items. `java.util.ArrayList` is used as the concrete implementation, and it's declared using the `List` interface type as required. `ArrayList` is suitable here for storing a growing list of finished items.
 *     *   `nextItemId` is a simple counter to ensure unique IDs for new items.
 *     *   `addWorkItem(String name)`: Creates a new `WorkItem` and adds it to the `assemblyLineQueue` using the `offer()` method. Includes basic validation for the item name.
 *     *   `processNextWorkItem()`: Removes and returns the head of the `assemblyLineQueue` using the `poll()` method. If `poll()` returns `null`, the queue was empty. If successful, it updates the item's status and adds it to the `finishedItems` list. It returns a boolean indicating success or failure (due to an empty queue).
 *     *   `viewQueue()`: Iterates through the `assemblyLineQueue` to print its contents without removing elements.
 *     *   `viewFinishedItems()`: Iterates through the `finishedItems` list to print its contents.
 * 
 * 3.  **`AssemblyLineSimulation` Class (`main` application):**
 *     *   This class contains the `main` method, which is the entry point of the application.
 *     *   It creates instances of `Scanner` (for input) and `AssemblyLineManager` (to handle simulation logic).
 *     *   **Class-wide Exception Handling:** The core `while(running)` loop, which contains the main application logic (menu display, input reading, processing choices), is wrapped in a `try { ... } catch (Exception e) { ... }` block. This demonstrates a class-wide catch-all for any unexpected exceptions that might occur anywhere within the simulation loop, preventing the program from crashing abruptly and printing a critical error message to `System.err`.
 *     *   **Scanner and Input Handling:** A `Scanner` object reads input. A nested `try-catch(InputMismatchException e)` block is used specifically to handle cases where the user enters non-integer input when an integer (menu choice) is expected. This block consumes the invalid input and prints an error to `System.err`, allowing the program to continue. A secondary `catch(Exception e)` is added to the inner try block to catch other potential issues during input reading.
 *     *   **`switch` Statement:** The `switch (choice)` statement is used to direct the program flow based on the user's valid menu selection, calling the appropriate methods on the `AssemblyLineManager`.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for displaying the menu, prompts, and successful operation messages (adding, processing, viewing contents). `System.err.println()` is explicitly used for error conditions, such as invalid input, attempting to process an empty queue, or reporting critical unexpected errors.
 *     *   **Input Validation:** Beyond `InputMismatchException` handling, the code checks if the entered menu choice is within the valid range (1-5) and uses `System.err` for out-of-range errors. The `addWorkItem` method in `AssemblyLineManager` also validates that the item name is not empty.
 *     *   **`finally` Block:** A `finally` block is used to ensure that the `Scanner` resource is closed when the main `try` block is exited, whether normally or due to an exception.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, adhering to good programming practices and demonstrating robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single work item processed by the assembly line.
 */
class WorkItem {
    private int id;
    private String name;
    private String status; // e.g., "Waiting", "Processed"

    /**
     * Constructs a new WorkItem with an ID and name.
     * Initial status is "Waiting".
     * @param id The unique identifier for the work item.
     * @param name The name or description of the work item.
     */
    public WorkItem(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = "Waiting"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the work item.
     * @param status The new status (e.g., "Processed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the WorkItem.
     * @return String representation of the WorkItem.
     */
    @Override
    public String toString() {
        return "WorkItem [ID=" + id + ", Name='" + name + "', Status='" + status + "']";
    }
}

/**
 * Manages the assembly line simulation, including the waiting queue and finished items list.
 */
class AssemblyLineManager {
    // Using Queue interface, implemented by LinkedList for efficient additions/removals at ends
    private Queue<WorkItem> assemblyLineQueue;
    // Using List interface, implemented by ArrayList for efficient storage and retrieval by index
    private List<WorkItem> finishedItems;
    private int nextItemId; // Counter to generate unique IDs for new items

    /**
     * Constructs an AssemblyLineManager, initializing the queue and lists.
     */
    public AssemblyLineManager() {
        this.assemblyLineQueue = new LinkedList<>();
        this.finishedItems = new ArrayList<>();
        this.nextItemId = 1; // Start IDs from 1
    }

    /**
     * Adds a new work item to the assembly line queue.
     * @param name The name/description of the work item. Must not be null or empty.
     */
    public void addWorkItem(String name) {
        // Input validation for item name
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Work item name cannot be empty.");
            return;
        }
        WorkItem newItem = new WorkItem(nextItemId++, name.trim());
        assemblyLineQueue.offer(newItem); // offer() adds to the end of the queue, returns true/false
        System.out.println("Added: " + newItem);
    }

    /**
     * Processes the next work item from the queue.
     * Moves the item to the finished items list after updating its status.
     * @return true if an item was successfully processed, false if the queue was empty.
     */
    public boolean processNextWorkItem() {
        WorkItem itemToProcess = assemblyLineQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty
        if (itemToProcess == null) {
            // Queue was empty, nothing to process
            return false;
        } else {
            itemToProcess.setStatus("Processed"); // Update status
            finishedItems.add(itemToProcess); // Add to the finished list (ArrayList)
            System.out.println("Processed: " + itemToProcess);
            return true;
        }
    }

    /**
     * Displays the current work items waiting in the assembly line queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Assembly Line Queue ---");
        if (assemblyLineQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (WorkItem item : assemblyLineQueue) {
                System.out.println(index++ + ". " + item);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Displays the work items that have been processed and are in the finished items list.
     */
    public void viewFinishedItems() {
        System.out.println("\n--- Finished Items ---");
        if (finishedItems.isEmpty()) {
            System.out.println("No items have been processed yet.");
        } else {
            // Iterate through the finished items list
            int index = 1;
            for (WorkItem item : finishedItems) {
                System.out.println(index++ + ". " + item);
            }
        }
        System.out.println("----------------------\n");
    }
}

/**
 * Main application class for the Assembly Line Simulation.
 * Handles user interaction and manages the simulation flow.
 */
public class AssemblyLineSimulation {

    /**
     * Main method to run the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = null; // Declare scanner outside try for finally block access
        AssemblyLineManager manager = new AssemblyLineManager();
        boolean running = true;

        System.out.println("--- Assembly Line Simulation System ---");

        // Class-wide exception handling for the main application loop
        try {
            scanner = new Scanner(System.in); // Initialize scanner inside try

            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    // Attempt to read integer input for the menu choice
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Basic input validation: Check if the choice is within the valid range
                    if (choice < 1 || choice > 5) {
                         System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                         continue; // Skip the rest of the loop body and show menu again
                    }

                } catch (InputMismatchException e) {
                    // Handle non-integer input gracefully
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop body and show menu again
                } catch (Exception e) {
                     // Catch any other unexpected error during input reading phase
                     System.err.println("An unexpected error occurred during input reading: " + e.getMessage());
                     // Attempt to clear input stream in case of weird issues
                     if (scanner.hasNextLine()) {
                         scanner.nextLine();
                     }
                     continue; // Skip the rest of the loop body
                }

                // Use a switch statement to handle valid menu choices
                switch (choice) {
                    case 1: // Add Work Item
                        System.out.print("Enter name for the new work item: ");
                        String itemName = scanner.nextLine();
                        manager.addWorkItem(itemName); // addWorkItem includes its own validation/error message
                        break;

                    case 2: // Process Next Work Item
                        System.out.println("Attempting to process next item...");
                        boolean processed = manager.processNextWorkItem();
                        if (!processed) {
                            // Manager signals if the queue was empty
                            System.err.println("Assembly line queue is empty. No item to process.");
                        }
                        break;

                    case 3: // View Assembly Line Queue
                        manager.viewQueue();
                        break;

                    case 4: // View Finished Items
                        manager.viewFinishedItems();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting simulation. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;

                    default:
                        // This case should theoretically not be reached due to the validation above,
                        // but included as a safeguard.
                        System.err.println("Programming error: Unexpected choice value reached default switch case: " + choice);
                        break;
                }
            }
        } catch (Exception e) {
            // General catch block for any unhandled exceptions occurring within the try block (main loop)
            System.err.println("\n--- A critical unexpected error occurred ---");
            e.printStackTrace(System.err); // Print stack trace to the error stream
            System.err.println("Simulation is terminating due to a critical error.");
            System.err.println("------------------------------------------");
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
               scanner.close();
               System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Work Item");
        System.out.println("2. Process Next Work Item");
        System.out.println("3. View Assembly Line Queue");
        System.out.println("4. View Finished Items");
        System.out.println("5. Exit");
    }
}
