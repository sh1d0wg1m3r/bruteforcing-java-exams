/*
 * Exam Question #901
 * Generated on: 2025-05-12 16:57:04
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Scenario:** You are tasked with developing a simple Task Management System for a small team. The system needs to keep track of all tasks created, allow users to select specific tasks for immediate attention, and process those selected tasks in a specific order.
 * 
 * **Requirements:**
 * 
 * Implement a Java program consisting of at least two classes (`Task` and `TaskManager`) that fulfills the following:
 * 
 * 1.  **`Task` Class:**
 *     *   Create a class named `Task`.
 *     *   It must have private instance variables: `id` (int), `description` (String), and `priority` (String).
 *     *   Implement a constructor `Task(String description, String priority)` that initializes the description and priority. The `id` should be automatically assigned using a static counter, ensuring each task has a unique ID starting from 1.
 *     *   Provide public getter methods for `id`, `description`, and `priority`.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., "Task [ID=1, Desc='Complete report', Priority=High]").
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Create a class named `TaskManager`.
 *     *   It must contain a private instance variable `allTasks` declared as `java.util.List<Task>` and initialized as a `java.util.ArrayList<Task>`. This list will store *all* tasks ever created.
 *     *   It must contain a private instance variable `processingQueue` declared as `java.util.Queue<Task>` and initialized as a `java.util.LinkedList<Task>`. This queue will hold tasks that are selected by the user for processing.
 *     *   It must contain a private instance variable `scanner` of type `java.util.Scanner`, initialized to read from `System.in`.
 *     *   Implement a `public void run()` method that contains the main application loop and menu.
 *     *   Inside the `run()` method, use a `switch` statement to handle user choices from the following menu:
 *         1.  Add New Task: Prompts the user for a task description and priority. Creates a new `Task` object and adds it to the `allTasks` list. Validate that description and priority are not empty strings.
 *         2.  View All Tasks: Displays all tasks currently stored in the `allTasks` list. Explicitly demonstrate using the `List` interface reference when iterating or accessing elements.
 *         3.  Add Tasks to Processing Queue: Displays all tasks from the `allTasks` list (using their numbers/indices). Prompts the user to enter the number(s) of tasks they want to add to the `processingQueue`. The user should be able to enter multiple numbers separated by commas (e.g., "1, 3, 5"). Parse the input, retrieve the corresponding tasks from `allTasks`, and add them to the `processingQueue`. Handle cases where the user enters invalid numbers or non-numeric input. Avoid adding a task to the queue if it's already present.
 *         4.  Process Next Task from Queue: Removes and displays the task at the head of the `processingQueue`. If the queue is empty, print a message indicating this. Use the appropriate `Queue` method for removal.
 *         5.  View Processing Queue: Displays the tasks currently in the `processingQueue` *without* removing them. If the queue is empty, print a message indicating this.
 *         6.  Exit: Terminates the program.
 *     *   Include helper private methods for each menu option's logic (e.g., `private void addTask()`, `private void viewAllTasks()`, etc.) to keep `run()` clean.
 *     *   Implement **class-wide exception handling** within the `run()` method using `try-catch` blocks. This block should wrap the main loop or critical operations to catch potential runtime errors (like `NumberFormatException` during menu selection or task number parsing) and any other unexpected exceptions, printing an informative message using `System.err` and preventing the program from crashing. Specific input validation errors (e.g., empty description) should also use `System.err`.
 *     *   Use `System.out` for all normal program output (menu, prompts, task details, success messages).
 *     *   Adhere to Java best practices:
 *         *   Proper encapsulation (private fields, public methods/getters).
 *         *   Meaningful variable and method names.
 *         *   Include comments where necessary to explain complex logic or key parts of the code.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying the menu. Based on user input, it should perform the requested action. All errors (invalid choices, invalid input formats, empty required fields, processing empty queue) must be reported to `System.err`. All normal interactions (menu display, prompts, task listings, confirmations) must go to `System.out`. The program should be resilient to invalid user input and unexpected errors due to proper exception handling.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * ...
 * 6. Exit
 * ----------------------------
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Write exam question
 * Enter task priority (e.g., High, Medium, Low): High
 * Task added: Task [ID=1, Desc='Write exam question', Priority=High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * --- All Tasks ---
 * 1. Task [ID=1, Desc='Write exam question', Priority=High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Add Tasks to Processing Queue ---
 * --- All Tasks ---
 * 1. Task [ID=1, Desc='Write exam question', Priority=High]
 * Enter the number(s) of tasks to add to the queue (comma-separated, e.g., 1,3,5): 1, abc
 * Warning: Invalid input format for task number: 'abc'. Skipping.
 * Added Task ID 1 to queue.
 * 1 task(s) added to the processing queue.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Processing Queue ---
 * 1. Task [ID=1, Desc='Write exam question', Priority=High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Processing Next Task ---
 * Processing: Task [ID=1, Desc='Write exam question', Priority=High]
 * Task ID 1 processed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Processing Next Task ---
 * Processing queue is empty. No tasks to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number for menu choices.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** A basic POJO (Plain Old Java Object) representing a task. It includes `id`, `description`, and `priority`. The static `nextId` ensures unique IDs for each task instance, incremented in the constructor. Getters provide controlled access to private fields. The `toString()` method provides a clear representation for printing.
 * 
 * 2.  **`TaskManager` Class:** This is the core class managing the application logic.
 *     *   **Collections:**
 *         *   `allTasks`: An `ArrayList` is used here, declared with the `List` interface type (`List<Task>`). This stores all tasks created during the program's execution. `ArrayList` provides dynamic resizing and efficient random access by index, suitable for viewing all tasks or selecting tasks by number.
 *         *   `processingQueue`: A `LinkedList` is used here, declared with the `Queue` interface type (`Queue<Task>`). `LinkedList` implements `Queue`, providing FIFO (First-In, First-Out) behavior. Tasks are added using `offer()` and removed using `poll()`. This structure is suitable for processing tasks in the order they were added to the queue.
 *     *   **`Scanner` and Menu (`run` method):** A `Scanner` reads user input from `System.in`. The `run()` method contains a `do-while` loop that repeatedly displays the menu and processes user input using a `switch` statement. Each case in the `switch` calls a dedicated private method for that operation. Reading the entire line with `scanner.nextLine()` and then parsing is preferred over `nextInt()` to avoid newline consumption issues.
 *     *   **Menu Operations (Helper Methods):**
 *         *   `addTask()`: Prompts for description and priority, creates a `Task` object, and adds it to the `allTasks` list using `list.add()`. Includes validation to ensure description and priority are not empty, printing errors to `System.err`.
 *         *   `viewAllTasks()`: Iterates through the `allTasks` list. It explicitly shows using the `List` interface reference (`List<Task> tasksToDisplay = allTasks;`) and accesses elements using `list.get(index)`, demonstrating the `List` interface's methods.
 *         *   `addTasksToQueue()`: This method is more complex. It first displays all tasks. It then reads a comma-separated string of task numbers. It splits the string, iterates through the numbers, parses each number, converts it to a list index, retrieves the `Task` from `allTasks` using `list.get()`, and adds it to the `processingQueue` using `queue.offer()`. It includes error handling for `NumberFormatException` (invalid number format) and checks if the task number is a valid index in `allTasks`. It also checks if the task is already in the `processingQueue` using `queue.contains()` before adding it, preventing duplicates. Warnings/errors for invalid inputs are printed to `System.err`.
 *         *   `processNextTask()`: Checks if the `processingQueue` is empty. If not, it removes and returns the task at the head of the queue using `queue.poll()`. `poll()` is suitable as it returns `null` if the queue is empty, though we check `isEmpty()` first for a more user-friendly message. The processed task is then printed.
 *         *   `viewProcessingQueue()`: Checks if the `processingQueue` is empty. If not, it iterates through the queue elements using an enhanced for loop. This iterates over the elements without removing them, suitable for viewing the queue's contents.
 *     *   **Error Handling:**
 *         *   `System.err`: Used throughout the code for printing error messages related to invalid user input (menu choice, task numbers, empty fields) and operational errors (like trying to process an empty queue).
 *         *   `System.out`: Used for all normal output, including the menu, prompts, task listings, and success messages.
 *         *   `try-catch`:
 *             *   A large `try-catch(Exception e)` block wraps the main `do-while` loop in `run()`. This serves as class-wide exception handling, catching any unexpected runtime exceptions that might occur during the program's execution and printing a generic error message to `System.err`, preventing the program from crashing.
 *             *   A specific `try-catch(NumberFormatException e)` is used within the `run()` method to handle non-numeric input for the main menu choice.
 *             *   Another `try-catch(NumberFormatException e)` is used within `addTasksToQueue()` to handle non-numeric values entered as task numbers in the comma-separated list.
 *     *   **Best Practices:** The code uses private fields with public getters (encapsulation), descriptive names for variables and methods, and includes comments explaining key parts. Input validation is performed before attempting operations.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrates proper use of collections (`List` and `Queue`), handles user interaction, and implements robust error handling with distinct output streams (`System.out`, `System.err`) and exception handling (`try-catch`).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;
    private String priority;

    /**
     * Constructs a new Task with a unique ID.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public Task(String description, String priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string of the Task details.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Priority=" + priority + "]";
    }

    // Optional: Add equals and hashCode if checking for queue containment by value/ID is needed more robustly
    // For this problem, object reference equality is sufficient for queue containment check.
}

// Manages the collection of tasks and the processing queue
public class TaskManager {
    // List to store all tasks created (using ArrayList which implements List)
    private List<Task> allTasks;
    // Queue for tasks waiting to be processed (using LinkedList as a Queue)
    private Queue<Task> processingQueue;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing task storage and scanner.
     */
    public TaskManager() {
        allTasks = new ArrayList<>(); // Initialize ArrayList
        processingQueue = new LinkedList<>(); // Initialize LinkedList as Queue
        scanner = new Scanner(System.in); // Initialize Scanner
    }

    /**
     * Runs the main application loop with menu interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0; // Initialize choice outside the loop

        // Class-wide exception handling wrapping the main application loop
        try {
            do {
                printMenu();
                System.out.print("Enter your choice: ");

                // Read the entire line to avoid issues with nextInt() and nextLine() mix
                String inputLine = scanner.nextLine();

                // Handle potential NumberFormatException if input is not a number
                try {
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    // Print error to System.err and set choice to an invalid value
                    System.err.println("Error: Invalid input. Please enter a number for menu choices.");
                    choice = -1; // Set to an invalid choice to trigger default case or loop again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        addTasksToQueue();
                        break;
                    case 4:
                        processNextTask();
                        break;
                    case 5:
                        viewProcessingQueue();
                        break;
                    case 6:
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Only print default error if choice was actually parsed as a number
                        if (choice != -1) { // Avoid double error message if NumberFormatException occurred
                             System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        }
                        break;
                }
            } while (choice != 6);

        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        } finally {
            // It's generally not recommended to close System.in, but for a standalone exam
            // program, closing the scanner might be considered good practice.
            // scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Add Tasks to Processing Queue");
        System.out.println("4. Process Next Task from Queue");
        System.out.println("5. View Processing Queue");
        System.out.println("6. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Prompts user for task details and adds a new task to the list.
     * Includes input validation.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }

        System.out.print("Enter task priority (e.g., High, Medium, Low): ");
        String priority = scanner.nextLine();

        // Input validation for priority
        if (priority == null || priority.trim().isEmpty()) {
            System.err.println("Error: Task priority cannot be empty.");
            return; // Exit method if validation fails
        }

        Task newTask = new Task(description.trim(), priority.trim());
        allTasks.add(newTask); // Add task to the ArrayList (List interface)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Displays all tasks currently stored in the allTasks list.
     * Demonstrates usage of the List interface.
     */
    private void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks available.");
        } else {
            // Explicitly using List interface reference for demonstration
            List<Task> tasksToDisplay = allTasks;
            for (int i = 0; i < tasksToDisplay.size(); i++) {
                 // Accessing elements using List method get()
                 System.out.println((i + 1) + ". " + tasksToDisplay.get(i));
            }
        }
    }

    /**
     * Allows the user to select tasks from the allTasks list and add them to the processing queue.
     * Handles comma-separated input and input validation.
     */
    private void addTasksToQueue() {
        System.out.println("\n--- Add Tasks to Processing Queue ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks available to add to the queue.");
            return;
        }

        viewAllTasks(); // Show available tasks with their numbers

        System.out.print("Enter the number(s) of tasks to add to the queue (comma-separated, e.g., 1,3,5): ");
        String input = scanner.nextLine();

        if (input == null || input.trim().isEmpty()) {
             System.out.println("No tasks selected.");
             return;
        }

        String[] taskNumbers = input.split(","); // Split input by comma
        int tasksAddedCount = 0;

        for (String taskNumStr : taskNumbers) {
            try {
                // Trim whitespace and parse the number
                int taskNumber = Integer.parseInt(taskNumStr.trim());
                // Convert 1-based user input to 0-based list index
                int taskIndex = taskNumber - 1;

                // Validate the index
                if (taskIndex >= 0 && taskIndex < allTasks.size()) {
                    Task taskToAdd = allTasks.get(taskIndex);

                    // Check if the task is already in the queue
                    if (processingQueue.contains(taskToAdd)) {
                         System.out.println("Task ID " + taskToAdd.getId() + " is already in the processing queue. Skipping.");
                    } else {
                        // Add task to the processing queue using offer()
                        processingQueue.offer(taskToAdd);
                        System.out.println("Added Task ID " + taskToAdd.getId() + " to queue.");
                        tasksAddedCount++;
                    }
                } else {
                    // Handle invalid task numbers
                    System.err.println("Warning: Invalid task number: " + taskNumber + ". Skipping.");
                }
            } catch (NumberFormatException e) {
                // Handle non-numeric input within the comma-separated list
                System.err.println("Warning: Invalid input format for task number: '" + taskNumStr.trim() + "'. Skipping.");
            }
        }

        if (tasksAddedCount > 0) {
            System.out.println(tasksAddedCount + " task(s) successfully added to the processing queue.");
        } else if (taskNumbers.length > 0) {
             System.out.println("No tasks were added to the processing queue.");
        }
    }

    /**
     * Processes (removes and displays) the next task from the queue.
     * Handles empty queue case.
     */
    private void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");
        // Check if the queue is empty
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty. No tasks to process.");
        } else {
            // Get and remove the head of the queue using poll()
            Task nextTask = processingQueue.poll();
            System.out.println("Processing: " + nextTask);
            // Simulate processing work here if needed
            System.out.println("Task ID " + nextTask.getId() + " processed.");
        }
    }

    /**
     * Displays the tasks currently in the processing queue without removing them.
     * Handles empty queue case.
     */
    private void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        // Check if the queue is empty
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            // Iterate through the queue elements without removing them
            int count = 1;
            for (Task task : processingQueue) {
                 System.out.println(count++ + ". " + task);
            }
            // Alternatively, printing the queue directly: System.out.println(processingQueue);
            // But iterating gives more control over formatting.
        }
    }

    /**
     * Main method to start the Task Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
