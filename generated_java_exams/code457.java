/*
 * Exam Question #457
 * Generated on: 2025-05-11 23:14:06
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Task Scheduler System**
 * 
 * **Scenario:** You are tasked with building a simple command-line Task Scheduler system. This system should allow users to add new tasks, process the next task in a queue, and list all tasks that have ever been created.
 * 
 * **Task Details:** Each task should have a unique integer ID (starting from 1), a description (a string), and a category (which can only be "HIGH", "MEDIUM", or "LOW").
 * 
 * **System Behavior:**
 * 1.  **Adding Tasks:** When a task is added, it is assigned the next available ID, stored in a historical list of all tasks, and also placed into a queue for processing.
 * 2.  **Processing Tasks:** Processing a task means taking the task that has been waiting in the queue the longest and displaying its details. Once processed, the task is removed from the processing queue.
 * 3.  **Listing Tasks:** The system should be able to display the details of *all* tasks that have ever been added to the system, regardless of whether they are still in the processing queue or have been processed.
 * 4.  **User Interaction:** The system should run in a loop, prompting the user for commands.
 * 
 * **Required Commands:**
 * -   `add`: Prompts the user for task description and category, creates and adds the task.
 * -   `process`: Processes the next task from the queue.
 * -   `list_all`: Displays all tasks ever created.
 * -   `exit`: Terminates the program.
 * 
 * **Implementation Requirements:**
 * -   Your solution MUST use ALL of the following Java components:
 *     -   `java.util.Queue` (specifically, an implementation like `java.util.LinkedList`) to manage tasks waiting for processing.
 *     -   `java.util.ArrayList` to store the historical list of all tasks ever created.
 *     -   Declare the historical list using the `java.util.List` interface type.
 *     -   `java.util.Scanner` to read user commands and task details from standard input (`System.in`).
 *     -   A `switch` statement to handle the different user commands.
 *     -   `System.err` to print error messages (e.g., invalid input, attempting to process from an empty queue, unknown commands).
 *     -   `System.out` to print prompts, success messages, and task listings.
 *     -   Implement class-wide exception handling using `try-catch` blocks to catch unexpected errors during the main command loop.
 * -   Create a `Task` class (or similar structure) to represent tasks, demonstrating proper encapsulation (private fields, public getters).
 * -   Implement input validation for task details (e.g., ensuring category is one of the allowed values).
 * -   Ensure meaningful variable and method names are used.
 * -   Add appropriate comments explaining key parts of the code.
 * -   Structure the code cleanly.
 * 
 * **Expected Output Examples:**
 * ```
 * --- Task Scheduler System ---
 * Available commands: add, process, list_all, exit
 * 
 * Enter command: add
 * --- Add New Task ---
 * Enter task description: Buy groceries
 * Enter task category (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully: Task [ID=1, Desc='Buy groceries', Category='HIGH']
 * --------------------
 * 
 * Enter command: add
 * --- Add New Task ---
 * Enter task description: Write report
 * Enter task category (HIGH, MEDIUM, LOW): medium
 * Task added successfully: Task [ID=2, Desc='Write report', Category='MEDIUM']
 * --------------------
 * 
 * Enter command: list_all
 * --- All Tasks Created ---
 * Task [ID=1, Desc='Buy groceries', Category='HIGH']
 * Task [ID=2, Desc='Write report', Category='MEDIUM']
 * -------------------------
 * 
 * Enter command: process
 * --- Process Next Task ---
 * Processing task: Task [ID=1, Desc='Buy groceries', Category='HIGH']
 * -------------------------
 * 
 * Enter command: process
 * --- Process Next Task ---
 * Processing task: Task [ID=2, Desc='Write report', Category='MEDIUM']
 * -------------------------
 * 
 * Enter command: process
 * --- Process Next Task ---
 * Error: No tasks in the queue to process.
 * -------------------------
 * 
 * Enter command: list_all
 * --- All Tasks Created ---
 * Task [ID=1, Desc='Buy groceries', Category='HIGH']
 * Task [ID=2, Desc='Write report', Category='MEDIUM']
 * -------------------------
 * 
 * Enter command: invalid_command
 * Error: Unknown command. Please use add, process, list_all, or exit.
 * 
 * Enter command: add
 * --- Add New Task ---
 * Enter task description:
 * Error: Description cannot be empty.
 * --------------------
 * 
 * Enter command: add
 * --- Add New Task ---
 * Enter task description: Pay bills
 * Enter task category (HIGH, MEDIUM, LOW): URGENT
 * Error: Invalid category. Please enter HIGH, MEDIUM, or LOW.
 * Enter task category (HIGH, MEDIUM, LOW): LOW
 * Task added successfully: Task [ID=3, Desc='Pay bills', Category='LOW']
 * --------------------
 * 
 * Enter command: exit
 * Exiting Task Scheduler. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Scheduler system demonstrating the required Java concepts and best practices.
 * 
 * -   **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) to model a task. It encapsulates the task's properties (`id`, `description`, `category`) using `private` fields, ensuring data can only be accessed or modified through defined methods (getters in this case). This adheres to the principle of encapsulation. The `toString()` method is overridden to provide a convenient string representation of a task object, used for printing.
 * 
 * -   **`TaskScheduler` Class:** This is the main class containing the system's logic.
 *     -   **Data Structures:**
 *         -   `tasksToProcess`: A `java.util.Queue<Task>` is used to hold tasks waiting to be processed. The `java.util.LinkedList` class is chosen as it implements the `Queue` interface and provides efficient additions (`offer`) and removals (`poll`) from the head, which is characteristic of queue-based processing (First-In, First-Out).
 *         -   `allTasksEverCreated`: A `java.util.List<Task>` is used to maintain a historical record of every task added to the system. The `java.util.ArrayList` class is used as the concrete implementation, providing dynamic array capabilities suitable for storing and iterating over all tasks. Declaring it using the `List` interface type is good practice, allowing for potential changes to the underlying list implementation later without affecting code that uses the `List` interface methods.
 *     -   **State Management:** The `nextTaskId` field ensures that each new task is assigned a unique, auto-incrementing ID.
 *     -   **User Input:** A `java.util.Scanner` object is used to read command lines and task details from `System.in`. It is created once and closed when the application terminates.
 *     -   **Command Handling (`run` method):**
 *         -   The `run` method contains the main application loop (`while(running)`).
 *         -   Inside the loop, it prompts the user for a command using `System.out`.
 *         -   The entered command is read using `scanner.nextLine()`, trimmed, and converted to lowercase for case-insensitive comparison.
 *         -   A `switch` statement is used to dispatch the command to the appropriate private method (`addTask`, `processTask`, `listAllTasks`) based on the command string. This fulfills the requirement for using a `switch` statement for flow control.
 *         -   The `default` case of the `switch` handles any unrecognized commands, printing an error message to `System.err`.
 *         -   The loop terminates when the user enters the `exit` command.
 *     -   **Operational Methods (`addTask`, `processTask`, `listAllTasks`):**
 *         -   These private methods encapsulate the logic for each specific operation.
 *         -   `addTask`: Prompts for description and category. It includes input validation: checking for an empty description and using a `while` loop to repeatedly prompt for the category until a valid one ("HIGH", "MEDIUM", or "LOW", case-insensitive) is entered. Error messages for invalid input are printed to `System.err`. Valid tasks are created and added to both the `allTasksEverCreated` list (`add` method) and the `tasksToProcess` queue (`offer` method). Success messages are printed to `System.out`.
 *         -   `processTask`: Checks if the `tasksToProcess` queue is empty using `isEmpty()`. If it is, an error message is printed to `System.err`. Otherwise, it removes and returns the element at the head of the queue using `poll()` and prints a processing message to `System.out`.
 *         -   `listAllTasks`: Iterates through the `allTasksEverCreated` list using a for-each loop and prints each task's details using its `toString()` method to `System.out`. It also checks if the list is empty and prints an appropriate message.
 *     -   **Exception Handling:**
 *         -   A `try-catch(Exception e)` block is wrapped around the main command processing logic inside the `while` loop in the `run` method. This provides "class-wide" exception handling, catching any unexpected runtime errors that might occur during the execution of commands. When an exception is caught, an error message including the exception's message is printed to `System.err`, allowing the program to continue running rather than crashing.
 *         -   Specific error conditions like an empty queue during processing or invalid user input (category format, empty description) are handled explicitly within the respective methods, using `System.err` for targeted error feedback.
 *     -   **Best Practices:** The code demonstrates best practices such as proper encapsulation, meaningful variable and method names, input validation, separation of concerns (Task vs. TaskScheduler), appropriate use of `System.out` and `System.err`, and basic commenting to explain key parts.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application structure, demonstrating an advanced understanding of Java programming concepts, data structures, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive comparison

/**
 * Represents a single task in the Task Scheduler system.
 * Demonstrates encapsulation.
 */
class Task {
    private int id;
    private String description;
    private String category; // e.g., "HIGH", "MEDIUM", "LOW"

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     * @param category The category/priority of the task (HIGH, MEDIUM, LOW).
     */
    public Task(int id, String description, String category) {
        this.id = id;
        this.description = description;
        this.category = category;
    }

    // Getters for accessing private fields
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getCategory() {
        return category;
    }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Category='" + category + "']";
    }
}

/**
 * Manages the Task Scheduler system, handling user commands and task data.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch, and exception handling.
 */
public class TaskScheduler {
    // Queue to hold tasks waiting to be processed (FIFO order)
    private Queue<Task> tasksToProcess;
    // List to hold a historical record of all tasks ever created
    private List<Task> allTasksEverCreated;
    // Scanner for reading user input
    private Scanner scanner;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskScheduler and initializes data structures.
     */
    public TaskScheduler() {
        // Use LinkedList as an implementation of Queue
        tasksToProcess = new LinkedList<>();
        // Use ArrayList as an implementation of List
        allTasksEverCreated = new ArrayList<>();
        scanner = new Scanner(System.in);
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Handles the 'add' command: prompts user for task details, validates input,
     * creates a Task, and adds it to the historical list and the processing queue.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        // Input validation for description
        if (description.isEmpty()) {
            System.err.println("Error: Description cannot be empty.");
            System.out.println("--------------------");
            return; // Exit method if description is invalid
        }

        String category;
        // Input validation loop for category
        while (true) {
            System.out.print("Enter task category (HIGH, MEDIUM, LOW): ");
            category = scanner.nextLine().trim().toUpperCase(Locale.US); // Read and normalize input
            if (category.equals("HIGH") || category.equals("MEDIUM") || category.equals("LOW")) {
                break; // Valid category entered, exit loop
            } else {
                System.err.println("Error: Invalid category. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        // Create the new task with the next available ID
        Task newTask = new Task(nextTaskId++, description, category);

        // Add the task to the historical list (ArrayList)
        allTasksEverCreated.add(newTask);
        // Add the task to the processing queue (Queue using LinkedList)
        tasksToProcess.offer(newTask); // offer is preferred over add for queues

        System.out.println("Task added successfully: " + newTask);
        System.out.println("--------------------");
    }

    /**
     * Handles the 'process' command: takes the next task from the queue
     * and simulates processing it. Handles the case of an empty queue.
     */
    private void processTask() {
        System.out.println("--- Process Next Task ---");
        // Check if the queue is empty
        if (tasksToProcess.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            // Get and remove the head of the queue (FIFO)
            Task processedTask = tasksToProcess.poll();
            System.out.println("Processing task: " + processedTask);
        }
        System.out.println("-------------------------");
    }

    /**
     * Handles the 'list_all' command: iterates through the historical list
     * and prints details of all tasks ever created.
     */
    private void listAllTasks() {
        System.out.println("--- All Tasks Created ---");
        // Check if the historical list is empty
        if (allTasksEverCreated.isEmpty()) {
            System.out.println("No tasks have been created yet.");
        .
        } else {
            // Iterate through the List (ArrayList) and print each task
            for (Task task : allTasksEverCreated) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * The main execution loop of the Task Scheduler system.
     * Reads commands from the user and dispatches to appropriate methods.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Scheduler System ---");
        System.out.println("Available commands: add, process, list_all, exit");

        boolean running = true;
        // Main command loop
        while (running) {
            // Class-wide exception handling block
            try {
                System.out.print("\nEnter command: ");
                String command = scanner.nextLine().trim().toLowerCase(Locale.US); // Read and normalize command

                // Use switch statement for command dispatch
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "process":
                        processTask();
                        break;
                    case "list_all":
                        listAllTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle unknown commands
                        System.err.println("Error: Unknown command. Please use add, process, list_all, or exit.");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the command processing cycle
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // In a real application, logging the full stack trace might be useful for debugging:
                // e.printStackTrace(System.err);
            }
        }

        // Close the scanner resource when the application exits
        scanner.close();
    }

    /**
     * The entry point of the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run(); // Start the scheduler's main loop
    }
}
