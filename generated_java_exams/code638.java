/*
 * Exam Question #638
 * Generated on: 2025-05-12 16:18:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Digital Print Shop Job Management System
 * 
 * **Objective:** Design and implement a command-line application in Java to manage print jobs for a digital print shop. The system should allow users to add new print jobs to a queue, process the next job in the queue, and view lists of pending and completed jobs. This task requires demonstrating proficiency in core Java collections, input/output, control flow, and exception handling.
 * 
 * **Scenario:**
 * A digital print shop receives print jobs that need to be processed in the order they are received. Once a job is finished, it is moved to a history of completed jobs. The system needs to interact with an operator via a simple text-based interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Job Representation:** Create a class named `PrintJob` to represent a single print job. Each `PrintJob` must have:
 *     *   A unique integer `id`.
 *     *   A `String` `description` (e.g., "Print 100 brochures").
 *     *   A `String` `type` (e.g., "Standard", "High-Priority").
 *     *   A `String` `status` ("Pending" or "Completed").
 *     *   Appropriate private fields and public getter methods (encapsulation).
 *     *   A method `markCompleted()` that changes the status to "Completed".
 *     *   An overridden `toString()` method that returns a formatted string representing the job (e.g., `[ID] [Type] - [Description] ([Status])`).
 * 
 * 2.  **Job Management System:** Create a class named `PrintShopManager` that contains the main application logic. This class must manage the jobs using the following collections:
 *     *   A `java.util.Queue<PrintJob>` to hold jobs that are waiting to be processed (pending jobs). Jobs should be processed in First-In, First-Out (FIFO) order.
 *     *   A `java.util.List<PrintJob>` to hold jobs that have been completed. Use `java.util.ArrayList` as the concrete implementation for this list.
 * 
 * 3.  **User Interface:** Implement a command-line menu driven interface using `java.util.Scanner` for user input. The menu should present the following options:
 *     1.  Add New Job
 *     2.  Process Next Job
 *     3.  List Pending Jobs
 *     4.  List Completed Jobs
 *     5.  Exit
 * 
 * 4.  **Implementation Details:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   When adding a job, prompt the user for the description and type. Assign a unique ID automatically (e.g., starting from 1 and incrementing). Add the new job to the pending queue with status "Pending".
 *     *   When processing a job, remove the job from the front of the pending queue, call its `markCompleted()` method, and add it to the completed jobs list. If the queue is empty, display an appropriate error message.
 *     *   When listing pending jobs, iterate through the queue and print each job's details using its `toString()` method. If the queue is empty, print a message indicating no pending jobs.
 *     *   When listing completed jobs, iterate through the list and print each job's details using its `toString()` method. If the list is empty, print a message indicating no completed jobs.
 *     *   Use `System.out` for all normal output (menu, prompts, job lists, success messages).
 *     *   Use `System.err` for all error messages (e.g., invalid menu choice, attempting to process an empty queue, invalid input type).
 * 
 * 5.  **Exception Handling:** Implement robust exception handling.
 *     *   Use `try-catch` blocks to handle potential issues, particularly around user input (e.g., non-integer input when expecting a number).
 *     *   Implement "class-wide" exception handling by wrapping the main user interaction loop within a `try-catch` block to gracefully handle unexpected errors and allow the program to continue (where possible) or exit cleanly. Ensure that invalid input (like non-numeric for menu choice) doesn't crash the program or cause an infinite loop.
 * 
 * 6.  **Best Practices:**
 *     *   Follow Java coding conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or JavaDocs where necessary.
 *     *   Ensure proper encapsulation in the `PrintJob` class.
 * 
 * **Expected Output:**
 * The program should display the menu, prompt for input, and display results or errors based on user actions. Examples:
 * 
 * ```
 * --- Print Shop Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Pending Jobs
 * 4. List Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Print Report
 * Enter job type (Standard/High-Priority): Standard
 * Job #1 (Standard) added to queue.
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * Pending Jobs:
 * [1] Standard - Print Report (Pending)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * Processing job: [1] Standard - Print Report (Pending)
 * Job #1 marked as Completed.
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 4
 * Completed Jobs:
 * [1] Standard - Print Report (Completed)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * System.err: No jobs in the pending queue to process.
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: abc
 * System.err: Invalid input. Please enter a number.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on:
 * *   Correctness and functionality according to the requirements.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective implementation of exception handling (`try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clean and readable code structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the `PrintShopManager` application as described in the exam question, fulfilling all the requirements.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Encapsulates job details (`id`, `description`, `type`, `status`) using private fields and public getters.
 *     *   The constructor initializes a job with "Pending" status.
 *     *   `markCompleted()` provides a controlled way to change the status.
 *     *   `toString()` provides a clear representation for output.
 * 
 * 2.  **`PrintShopManager` Class:**
 *     *   Uses `java.util.Queue<PrintJob>` (`LinkedList` implementation) for `jobQueue` to ensure FIFO processing of pending jobs.
 *     *   Uses `java.util.List<PrintJob>` (`ArrayList` implementation) for `completedJobs` to store a history of finished jobs, allowing easy iteration and access.
 *     *   `nextJobId` is a simple counter to generate unique IDs for new jobs.
 *     *   The constructor initializes these collections and the counter.
 * 
 * 3.  **Core Methods:**
 *     *   `addJob()`: Creates a new `PrintJob`, assigns the next available ID, and adds it to the `jobQueue` using `offer()`. Prints a confirmation to `System.out`.
 *     *   `processNextJob()`: Checks if `jobQueue` is empty. If so, prints an error to `System.err`. Otherwise, it removes the head of the queue using `poll()`, updates its status using `markCompleted()`, adds it to `completedJobs`, and prints success messages to `System.out`.
 *     *   `listPendingJobs()`: Iterates through the `jobQueue` (using an enhanced for loop which doesn't remove elements) and prints each job's details to `System.out`. Handles the empty case.
 *     *   `listCompletedJobs()`: Iterates through the `completedJobs` `List` and prints each job's details to `System.out`. Handles the empty case.
 * 
 * 4.  **User Interface and Control Flow:**
 *     *   `displayMenu()`: Prints the menu options to `System.out`.
 *     *   `run()`: Contains the main application loop.
 *     *   `Scanner`: Used to read user input from `System.in`. `scanner.nextInt()` reads the integer choice, and `scanner.nextLine()` is crucial after `nextInt()` to consume the remaining newline character, preventing issues with subsequent `nextLine()` calls for description/type.
 *     *   `switch`: Directs execution based on the integer `choice` read from the user. Each case calls the appropriate job management method. The `default` case handles invalid integer choices, printing an error to `System.err`.
 *     *   `System.out`: Used for all prompts, the menu, job listings, and success messages.
 *     *   `System.err`: Used specifically for error messages, such as invalid menu input or attempting to process an empty queue.
 * 
 * 5.  **Exception Handling:**
 *     *   The main `while` loop in the `run()` method is wrapped in a `try-catch` block. This provides "class-wide" handling for exceptions that might occur during the user interaction process.
 *     *   `catch (InputMismatchException e)`: Specifically catches errors when `scanner.nextInt()` fails because the input was not a valid integer. It prints an error to `System.err` and uses `scanner.next()` to consume the invalid token, preventing an infinite loop caused by the `Scanner` repeatedly trying to read the same bad input.
 *     *   `catch (Exception e)`: A general catch block is included to handle any other unexpected runtime exceptions that might occur within the `try` block, printing a generic error message to `System.err`. This makes the application more robust against unforeseen issues.
 *     *   Specific business logic error handling (like processing an empty queue) is handled with an `if` check and `System.err.println` within the `processNextJob` method itself, as it's a specific, anticipated condition rather than an unexpected exception type.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names (`jobQueue`, `completedJobs`, `addJob`, `processNextJob`, `displayMenu`).
 *     *   Basic JavaDocs/comments explain the purpose of classes and methods.
 *     *   Encapsulation is correctly applied in the `PrintJob` class.
 *     *   The code is structured logically with separate methods for different actions.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * This solution effectively demonstrates the required Java components and concepts in a practical, cohesive application, including robust input handling and error reporting using `System.err`.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a print job in the system.
 */
class PrintJob {
    private int id;
    private String description;
    private String type; // e.g., "Standard", "High-Priority"
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new PrintJob.
     *
     * @param id The unique identifier for the job.
     * @param description A description of the job.
     * @param type The type of the job (e.g., Standard, High-Priority).
     */
    public PrintJob(int id, String description, String type) {
        this.id = id;
        this.description = description;
        this.type = type;
        this.status = "Pending"; // Jobs start in Pending status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the job as completed.
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return Formatted string of the job details.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + type + " - " + description + " (" + status + ")";
    }
}

/**
 * Manages print jobs using a queue for pending jobs and a list for completed jobs.
 * Provides a command-line interface for interaction.
 */
public class PrintShopManager {

    private Queue<PrintJob> jobQueue; // Pending jobs queue (FIFO)
    private List<PrintJob> completedJobs; // Completed jobs history
    private int nextJobId; // Counter for assigning unique job IDs

    /**
     * Constructs a new PrintShopManager, initializing collections and ID counter.
     */
    public PrintShopManager() {
        jobQueue = new LinkedList<>(); // LinkedList implements Queue
        completedJobs = new ArrayList<>(); // ArrayList implements List
        nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new job to the pending queue.
     *
     * @param description The job description.
     * @param type The job type.
     */
    public void addJob(String description, String type) {
        PrintJob newJob = new PrintJob(nextJobId++, description, type);
        jobQueue.offer(newJob); // offer() is the preferred way to add to a queue
        System.out.println("Job #" + newJob.getId() + " (" + newJob.getType() + ") added to queue.");
    }

    /**
     * Processes the next job from the pending queue.
     * Removes the job, marks it completed, and moves it to the completed list.
     */
    public void processNextJob() {
        if (jobQueue.isEmpty()) {
            System.err.println("No jobs in the pending queue to process.");
            return;
        }

        PrintJob processedJob = jobQueue.poll(); // poll() retrieves and removes the head
        System.out.println("Processing job: " + processedJob); // Print before marking completed
        processedJob.markCompleted();
        completedJobs.add(processedJob);
        System.out.println("Job #" + processedJob.getId() + " marked as Completed.");
    }

    /**
     * Lists all jobs currently in the pending queue.
     */
    public void listPendingJobs() {
        System.out.println("\n--- Pending Jobs ---");
        if (jobQueue.isEmpty()) {
            System.out.println("No jobs currently pending.");
        } else {
            // Iterate without removing elements
            for (PrintJob job : jobQueue) {
                System.out.println(job);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all jobs that have been completed.
     */
    public void listCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Shop Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. List Pending Jobs");
        System.out.println("4. List Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and actions.
     * Includes class-wide exception handling for input and unexpected errors.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling wrapping the main interaction loop
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over after nextInt()

                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter job type (e.g., Standard, High-Priority): ");
                        String type = scanner.nextLine();
                        addJob(description, type);
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        listPendingJobs();
                        break;
                    case 4:
                        listCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Print Shop Manager. Goodbye!");
                        running = false; // Exit the loop
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handles cases where the user enters non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Generic catch for any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for detailed debugging
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintShopManager manager = new PrintShopManager();
        manager.run();
    }
}
