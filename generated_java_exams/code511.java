/*
 * Exam Question #511
 * Generated on: 2025-05-11 23:22:11
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:** Design and implement a simple command-line application to simulate a print job management system. The system should manage a queue of waiting print jobs and a list of completed jobs.
 * 
 * **Scenario:** Imagine a shared printer server where print jobs arrive and are processed one by one. Your task is to build a program that allows users to add new print jobs, process the next job in the queue, view the waiting jobs, and view the completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement a `PrintJob` class:**
 *     *   It should have private fields: `id` (integer, unique identifier), `description` (String), and `status` (String, e.g., "WAITING", "COMPLETED").
 *     *   Provide a constructor to create new jobs with a description; the `id` should be automatically assigned (e.g., using a static counter), and the initial status should be "WAITING".
 *     *   Include public getter methods for all fields (`getId()`, `getDescription()`, `getStatus()`).
 *     *   Include a public method `markAsCompleted()` to change the status to "COMPLETED".
 *     *   Override the `toString()` method to provide a user-friendly representation of the job (e.g., "[ID] Description (Status)").
 * 
 * 2.  **Implement a `PrintManager` class:**
 *     *   It should have private fields:
 *         *   A `Queue<PrintJob>` to hold jobs that are waiting to be printed.
 *         *   A `List<PrintJob>` to hold jobs that have been completed.
 *         *   A static counter for generating unique job IDs.
 *     *   Provide public methods:
 *         *   `addJob(String description)`: Creates a new `PrintJob` with the given description and adds it to the waiting queue.
 *         *   `processNextJob()`: Retrieves and removes the job at the head of the waiting queue, marks it as completed, and adds it to the completed jobs list. If the queue is empty, it should indicate an error (e.g., return a specific value or throw an exception).
 *         *   `getWaitingQueue()`: Returns the current waiting queue.
 *         *   `getCompletedJobs()`: Returns the current list of completed jobs.
 * 
 * 3.  **Implement a main application class (e.g., `PrintSystem`):**
 *     *   The `main` method should contain the core application logic.
 *     *   Use a `Scanner` object to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         *   1. Add New Print Job
 *         *   2. Process Next Job
 *         *   3. View Waiting Queue
 *         *   4. View Completed Jobs
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Implement input validation for the menu choice. If the input is not a valid integer or not within the valid range, display an error message.
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and job lists/queue contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during input processing or operations (e.g., `InputMismatchException`). A general `catch(Exception e)` block around the main loop is acceptable for demonstrating the concept in this context.
 *     *   Ensure that the `Queue`, `ArrayList`, `List` interface, `Scanner`, `Switch`, `System.err`, `System.out`, and `try-catch` components are all used as required.
 * 
 * 4.  **General Requirements:**
 *     *   Adhere to best practices: proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments and documentation (Javadoc is recommended), clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display the results or errors. Examples:
 * 
 * ```
 * --- Print Job Management ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Report Document
 * Job added: [1] Report Document (WAITING)
 * 
 * --- Print Job Management ---
 * ...
 * Enter your choice: 3
 * Waiting Queue:
 * [1] Report Document (WAITING)
 * 
 * --- Print Job Management ---
 * ...
 * Enter your choice: 2
 * Processing next job...
 * Job completed: [1] Report Document (COMPLETED)
 * 
 * --- Print Job Management ---
 * ...
 * Enter your choice: 3
 * Waiting Queue is empty.
 * 
 * --- Print Job Management ---
 * ...
 * Enter your choice: 4
 * Completed Jobs:
 * [1] Report Document (COMPLETED)
 * 
 * --- Print Job Management ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * You must provide the complete, runnable Java code solution.
 *
 * EXPLANATION:
 * This solution implements a simple print job management system demonstrating the required Java concepts and best practices.
 * 
 * **Key Components Used and Demonstrated:**
 * 
 * 1.  **`Queue` (from `java.util.Queue`)**: The `PrintManager` class uses a `java.util.Queue<PrintJob>` (`waitingJobsQueue`) to store jobs waiting to be processed. The `LinkedList` class is used as the concrete implementation because it efficiently supports queue operations (`offer` for adding, `poll` for removing from the head). This demonstrates the FIFO (First-In, First-Out) nature suitable for a print queue.
 * 2.  **`ArrayList` (from `java.util.ArrayList`)**: The `PrintManager` class uses an `java.util.ArrayList<PrintJob>` (`completedJobsList`) to store jobs that have finished processing. `ArrayList` is chosen for its common use as a resizable array implementation, suitable for keeping a history of completed items.
 * 3.  **`List` interface (from `java.util.List`)**: The `completedJobsList` is declared using the `List` interface type (`List<PrintJob> completedJobsList = new ArrayList<>();`). This demonstrates programming to the interface, which is a core object-oriented principle promoting flexibility and abstraction.
 * 4.  **`Scanner` for user input (from `java.util.Scanner`)**: The `main` method in the `PrintSystem` class uses a `Scanner` object to read user input (menu choices and job descriptions) from `System.in`.
 * 5.  **`Switch` statement for flow control**: The `main` method uses a `switch` statement based on the user's menu choice (`choice`) to direct the program's execution to the appropriate action (add job, process job, view queues, exit).
 * 6.  **`System.err` for error messages**: Error messages, such as invalid input formats (`InputMismatchException`), invalid menu choices, or attempting to process an empty queue, are printed to `System.err`. This distinguishes error output from standard application output.
 * 7.  **`System.out` for normal output**: The menu, prompts, successful operation messages, and the contents of the waiting queue and completed jobs list are printed to `System.out`.
 * 8.  **Class-wide exception handling with `try-catch` blocks**:
 *     *   A `try-catch(InputMismatchException e)` block is used specifically around reading the integer menu choice to handle cases where the user enters non-numeric input. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   A broader `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This demonstrates catching any unexpected runtime exceptions that might occur during the program's execution and printing a stack trace to `System.err`, providing a form of class-wide error handling for the main application flow.
 *     *   The `processNextJob` method in `PrintManager` returns `null` to indicate an empty queue, and this condition is checked and handled in the `main` method, printing an error to `System.err`.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Proper Encapsulation:** Fields in `PrintJob` and `PrintManager` are `private`. Public methods (`getters`, `addJob`, `processNextJob`, etc.) provide controlled access to the internal state and functionality.
 * *   **Meaningful Variable and Method Names:** Names like `waitingJobsQueue`, `completedJobsList`, `addJob`, `processNextJob`, `displayMenu` clearly indicate their purpose.
 * *   **Appropriate Comments and Documentation:** Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific logic where needed.
 * *   **Input Validation:** The code checks if the menu input is a valid integer and within the expected range. It also checks if the job description is empty.
 * *   **Proper Error Handling:** Specific errors (`InputMismatchException`, empty queue condition) are anticipated and handled gracefully, providing informative messages to the user via `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical classes (`PrintJob`, `PrintManager`, `PrintSystem`), separating concerns (data representation, business logic, user interface). The `main` method is kept relatively clean by delegating tasks to the `PrintManager` and a helper `displayMenu` method. The use of `finally` ensures the `Scanner` is closed.
 * 
 * This solution effectively integrates all the required components into a functional and well-structured program, demonstrating advanced understanding of Java collections, basic object-oriented principles, input/output, control flow, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int id;
    private String description;
    private String status; // WAITING, COMPLETED

    // Constructor
    public PrintJob(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "WAITING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to mark the job as completed
    public void markAsCompleted() {
        this.status = "COMPLETED";
    }

    // User-friendly string representation
    @Override
    public String toString() {
        return "[" + id + "] " + description + " (" + status + ")";
    }
}

// Manages the print job queue and completed list
class PrintManager {
    private Queue<PrintJob> waitingJobsQueue;
    private List<PrintJob> completedJobsList;
    private static int nextJobId = 1; // Static counter for unique job IDs

    // Constructor
    public PrintManager() {
        this.waitingJobsQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobsList = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new print job to the waiting queue.
     * @param description The description of the job.
     */
    public void addJob(String description) {
        PrintJob newJob = new PrintJob(nextJobId++, description);
        waitingJobsQueue.offer(newJob); // offer() is preferred for queues (returns false if fails, doesn't throw)
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the waiting queue.
     * Moves the job from waiting to completed list.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob jobToProcess = waitingJobsQueue.poll(); // poll() retrieves and removes, returns null if empty
        if (jobToProcess != null) {
            jobToProcess.markAsCompleted();
            completedJobsList.add(jobToProcess);
            return jobToProcess;
        } else {
            return null; // Indicate no job was processed
        }
    }

    /**
     * Returns the queue of waiting print jobs.
     * @return The Queue of waiting jobs.
     */
    public Queue<PrintJob> getWaitingQueue() {
        return waitingJobsQueue;
    }

    /**
     * Returns the list of completed print jobs.
     * @return The List of completed jobs.
     */
    public List<PrintJob> getCompletedJobs() {
        return completedJobsList;
    }
}

// Main application class
public class PrintSystem {

    public static void main(String[] args) {
        PrintManager printManager = new PrintManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling wrapping the main loop
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading the integer

                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Use switch statement for menu handling
                switch (choice) {
                    case 1: // Add New Print Job
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Error: Job description cannot be empty.");
                        } else {
                            printManager.addJob(description.trim());
                        }
                        break;

                    case 2: // Process Next Job
                        System.out.println("Processing next job...");
                        PrintJob processedJob = printManager.processNextJob();
                        if (processedJob != null) {
                            System.out.println("Job completed: " + processedJob);
                        } else {
                            System.err.println("Error: Waiting queue is empty. No job to process.");
                        }
                        break;

                    case 3: // View Waiting Queue
                        System.out.println("\n--- Waiting Queue ---");
                        Queue<PrintJob> waiting = printManager.getWaitingQueue();
                        if (waiting.isEmpty()) {
                            System.out.println("Waiting Queue is empty.");
                        } else {
                            // Iterating over the queue without removing elements
                            waiting.forEach(System.out::println);
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 4: // View Completed Jobs
                        System.out.println("\n--- Completed Jobs ---");
                        List<PrintJob> completed = printManager.getCompletedJobs();
                        if (completed.isEmpty()) {
                            System.out.println("No jobs have been completed yet.");
                        } else {
                            completed.forEach(System.out::println);
                        }
                        System.out.println("----------------------\n");
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Displays the main menu
    private static void displayMenu() {
        System.out.println("\n--- Print Job Management ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
