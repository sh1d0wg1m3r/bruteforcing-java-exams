/*
 * Exam Question #1050
 * Generated on: 2025-05-12 17:18:10
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Develop a simplified Hospital Appointment Management System.
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a command-line application for a small hospital to manage patient registrations, doctor registrations, and appointment requests. The system needs to handle patients requesting appointments with specific doctors. If a doctor is currently seeing a patient, new requests for that doctor should be placed in a waiting queue.
 * 
 * Your solution must demonstrate proficiency in using core Java collections and control flow structures, along with proper error handling and code organization.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of all registered patients.
 *     *   Maintain a list of all registered doctors.
 *     *   Each doctor must have a waiting list (queue) for patients requesting an appointment while the doctor is busy.
 *     *   Maintain a list of currently scheduled appointments.
 * 2.  **Functionality (via command-line interface):**
 *     *   `register patient <name>`: Registers a new patient. Patient names must be unique.
 *     *   `register doctor <name>`: Registers a new doctor. Doctor names must be unique.
 *     *   `request <patient_name> <doctor_name>`: A patient requests an appointment with a doctor.
 *         *   If the doctor is free, schedule the appointment immediately.
 *         *   If the doctor is busy (currently seeing a patient), add the patient to the doctor's waiting queue.
 *         *   Handle cases where the patient or doctor does not exist.
 *     *   `status <patient_name>`: Displays the current status of a patient:
 *         *   Scheduled with which doctor.
 *         *   In the waiting queue for which doctor (and their position in the queue - optional but good).
 *         *   Registered but no active request/appointment.
 *         *   Patient not found.
 *     *   `cancel <patient_name>`: Cancels a patient's active appointment or removes them from a waiting queue.
 *         *   If the patient has a scheduled appointment, cancel it and free up the doctor.
 *         *   If the patient is in a waiting queue, remove them.
 *         *   Handle cases where the patient has no active request/appointment or is not found.
 *     *   `exit`: Terminates the application.
 * 3.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read commands and arguments from the console (`System.in`).
 *     *   Use `System.out` for prompts, successful operations, and status messages.
 *     *   Use `System.err` for all error messages (invalid commands, patient/doctor not found, name already exists, invalid input format, etc.).
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to process different commands.
 * 5.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during command processing.
 * 6.  **Code Structure and Best Practices:**
 *     *   Use meaningful class, method, and variable names.
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Include comments/documentation where necessary.
 *     *   Implement input validation (e.g., non-empty names, correct number of arguments for commands).
 *     *   Declare collection variables using the appropriate interface (`List`, `Queue`).
 *     *   Structure the code into appropriate classes (e.g., `Patient`, `Doctor`, `Appointment`, `HospitalSystem`).
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Enter command: register patient Alice
 * Patient Alice registered successfully.
 * Enter command: register doctor Dr. Smith
 * Doctor Dr. Smith registered successfully.
 * Enter command: register doctor Dr. Jones
 * Doctor Dr. Jones registered successfully.
 * Enter command: request Alice Dr. Smith
 * Appointment scheduled for Alice with Dr. Smith.
 * Enter command: status Alice
 * Patient Alice is scheduled with Dr. Smith.
 * Enter command: register patient Bob
 * Patient Bob registered successfully.
 * Enter command: request Bob Dr. Smith
 * Dr. Smith is busy. Bob added to Dr. Smith's waiting queue.
 * Enter command: status Bob
 * Patient Bob is in the waiting queue for Dr. Smith.
 * Enter command: cancel Alice
 * Appointment for Alice with Dr. Smith cancelled. Dr. Smith is now free.
 * Enter command: status Alice
 * Patient Alice is registered but has no active request or appointment.
 * Enter command: status Bob
 * Patient Bob is in the waiting queue for Dr. Smith.
 * Enter command: request Charlie Dr. Smith
 * Patient Charlie not found.
 * Enter command: exit
 * Exiting Hospital System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of functionality.
 * *   Proper usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and organization.
 * 
 * **Deliverables:**
 * 
 * A single Java file containing all necessary classes (`Patient`, `Doctor`, `Appointment`, `HospitalSystem`, etc.) that can be compiled and run from the `main` method.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Hospital Appointment Management System based on the requirements. It demonstrates the use of all specified Java components in a cohesive manner.
 * 
 * **Class Structure:**
 * 
 * 1.  `Patient`: A simple class to represent a patient with a `name`. `equals` and `hashCode` are overridden to allow proper comparison and use in collections.
 * 2.  `Doctor`: Represents a doctor with a `name`. Crucially, it holds a `Queue<Patient>` (`waitingQueue`) to manage patients waiting for this doctor and a `Patient` reference (`currentPatient`) for the one currently being seen. Methods are provided to manage the queue (`addToQueue`, `removeFromQueue`, `isPatientInQueue`) and the current patient status (`isFree`, `assignPatient`, `finishCurrentPatient`). `equals` and `hashCode` are overridden.
 * 3.  `Appointment`: Represents a scheduled appointment, simply linking a `Patient` and a `Doctor`.
 * 4.  `HospitalSystem`: This is the main class that orchestrates the system.
 *     *   It holds `List`s (implemented as `ArrayList`s) for `patients`, `doctors`, and `appointments`. Using `List` as the variable type adheres to best practices, programming to the interface.
 *     *   It contains a `Scanner` for reading user input.
 *     *   It includes methods for the core functionalities: `registerPatient`, `registerDoctor`, `requestAppointment`, `viewStatus`, and `cancelRequest`. These methods encapsulate the business logic and interact with the collection objects.
 *     *   Helper methods like `findPatient`, `findDoctor`, `getPatientAppointment`, and `getPatientWaitingDoctor` are used internally to locate entities.
 *     *   The `run` method contains the main application loop, reads commands, and uses a `switch` statement to dispatch to the appropriate method based on the command.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`Queue (java.util.Queue)`:** Used in the `Doctor` class (`waitingQueue`) via its implementation `java.util.LinkedList`. Patients are added using `offer()` and removed using `remove()` or `removeFromQueue()`. Iteration is used in `viewStatus` to find a patient's position.
 * *   **`ArrayList (java.util.ArrayList)`:** Used as the concrete implementation for the `patients`, `doctors`, and `appointments` lists within the `HospitalSystem` class.
 * *   **`List interface (java.util.List)`:** Used to declare the variables `patients`, `doctors`, and `appointments` (`private List<Patient> patients = new ArrayList<>();`). This promotes flexibility and good design.
 * *   **`Scanner (java.util.Scanner)`:** An instance is created in `HospitalSystem` to read user input from `System.in` in the `run` method. It's closed upon exiting.
 * *   **`Switch statement`:** Located in the `run` method of `HospitalSystem`, it is used to determine which action to perform based on the first word of the user's command.
 * *   **`System.err`:** Used throughout the `HospitalSystem` methods (`registerPatient`, `registerDoctor`, `requestAppointment`, `viewStatus`, `cancelRequest`) and the `run` method (in the `default` case of the switch and in the `catch` block) to print error messages for invalid input, non-existent entities, or incorrect command formats.
 * *   **`System.out`:** Used in the `run` method for the welcome message and prompts, and in the `HospitalSystem` methods for confirmation messages, successful operation feedback, and patient status reports.
 * *   **`try-catch blocks`:** A `try-catch(Exception e)` block is wrapped around the main `switch` statement inside the `while(true)` loop in the `run` method. This provides "class-wide" exception handling for the core command processing logic, catching any unexpected runtime exceptions that might occur and printing an error message to `System.err` before the loop potentially continues, preventing the application from crashing abruptly.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Patient`, `Doctor`, and `Appointment` are `private`, with public getter methods provided where necessary. Logic is contained within the `HospitalSystem` class's methods.
 * *   **Meaningful Names:** Class names (`Patient`, `Doctor`, etc.), variable names (`waitingQueue`, `currentPatient`, `appointments`), and method names (`registerPatient`, `requestAppointment`, `viewStatus`, `cancelRequest`) are descriptive.
 * *   **Input Validation:** Checks are performed for null or empty names in registration and request methods. Command argument counts are checked in the `run` method.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for various failure conditions (not found, already exists, invalid format). A general `try-catch` handles unforeseen exceptions.
 * *   **Clean Code Structure:** The code is organized into logical classes, and the `HospitalSystem` class separates helper methods from core logic methods and the main run loop. The use of an `Iterator` for safe removal from the `appointments` list during cancellation is also a good practice.
 * 
 * This solution effectively integrates the required components to simulate a practical scenario, demonstrating understanding of object-oriented principles, data structures, and robust programming practices in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator;

// Represents a Patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // Override equals and hashCode for proper comparison in collections
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return name.equals(patient.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a Doctor
class Doctor {
    private String name;
    private Patient currentPatient; // Patient currently being seen
    private Queue<Patient> waitingQueue; // Patients waiting for this doctor

    public Doctor(String name) {
        this.name = name;
        this.currentPatient = null;
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    public String getName() {
        return name;
    }

    public Patient getCurrentPatient() {
        return currentPatient;
    }

    public Queue<Patient> getWaitingQueue() {
        return waitingQueue;
    }

    public boolean isFree() {
        return currentPatient == null;
    }

    public void assignPatient(Patient patient) {
        this.currentPatient = patient;
    }

    public void finishCurrentPatient() {
        this.currentPatient = null;
        // In a more complex system, this would automatically schedule the next patient.
        // For this exam, we keep it simple: next patient is assigned only on a new 'request' command
        // when the doctor is found free.
    }

    public void addToQueue(Patient patient) {
        waitingQueue.offer(patient); // offer is preferred over add for queues
    }

    public boolean removeFromQueue(Patient patient) {
        return waitingQueue.remove(patient); // remove specific element
    }

    // Override equals and hashCode
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Doctor doctor = (Doctor) o;
        return name.equals(doctor.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a scheduled Appointment
class Appointment {
    private Patient patient;
    private Doctor doctor;

    public Appointment(Patient patient, Doctor doctor) {
        this.patient = patient;
        this.doctor = doctor;
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }
}

// Main system class managing patients, doctors, appointments, and user interaction
public class HospitalSystem {

    private List<Patient> patients; // Use List interface, implement with ArrayList
    private List<Doctor> doctors;   // Use List interface, implement with ArrayList
    private List<Appointment> appointments; // Use List interface, implement with ArrayList
    private Scanner scanner;

    public HospitalSystem() {
        this.patients = new ArrayList<>();
        this.doctors = new ArrayList<>();
        this.appointments = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // --- Helper Methods to find entities ---
    private Patient findPatient(String name) {
        for (Patient p : patients) {
            if (p.getName().equalsIgnoreCase(name)) {
                return p;
            }
        }
        return null; // Patient not found
    }

    private Doctor findDoctor(String name) {
        for (Doctor d : doctors) {
            if (d.getName().equalsIgnoreCase(name)) {
                return d;
            }
        }
        return null; // Doctor not found
    }

    // --- Core System Logic Methods ---

    public void registerPatient(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }
        if (findPatient(name) != null) {
            System.err.println("Error: Patient '" + name + "' already registered.");
            return;
        }
        patients.add(new Patient(name.trim()));
        System.out.println("Patient '" + name.trim() + "' registered successfully.");
    }

    public void registerDoctor(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        if (findDoctor(name) != null) {
            System.err.println("Error: Doctor '" + name + "' already registered.");
            return;
        }
        doctors.add(new Doctor(name.trim()));
        System.out.println("Doctor '" + name.trim() + "' registered successfully.");
    }

    public void requestAppointment(String patientName, String doctorName) {
        if (patientName == null || patientName.trim().isEmpty() || doctorName == null || doctorName.trim().isEmpty()) {
             System.err.println("Error: Patient and Doctor names cannot be empty.");
             return;
        }

        Patient patient = findPatient(patientName.trim());
        Doctor doctor = findDoctor(doctorName.trim());

        if (patient == null) {
            System.err.println("Error: Patient '" + patientName + "' not found.");
            return;
        }
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        // Check if patient already has an appointment or is in a queue
        if (getPatientAppointment(patient) != null) {
             System.err.println("Error: Patient '" + patientName + "' already has a scheduled appointment.");
             return;
        }
         if (getPatientWaitingDoctor(patient) != null) {
             System.err.println("Error: Patient '" + patientName + "' is already in a waiting queue.");
             return;
         }


        if (doctor.isFree()) {
            // Schedule appointment
            Appointment newAppointment = new Appointment(patient, doctor);
            appointments.add(newAppointment);
            doctor.assignPatient(patient);
            System.out.println("Appointment scheduled for '" + patient.getName() + "' with " + doctor.getName() + ".");
        } else {
            // Add to waiting queue
            doctor.addToQueue(patient);
            System.out.println(doctor.getName() + " is busy. '" + patient.getName() + "' added to " + doctor.getName() + "'s waiting queue.");
        }
    }

    // Helper to find appointment for a patient
    private Appointment getPatientAppointment(Patient patient) {
        for (Appointment apt : appointments) {
            if (apt.getPatient().equals(patient)) {
                return apt;
            }
        }
        return null;
    }

    // Helper to find which doctor's queue a patient is in
    private Doctor getPatientWaitingDoctor(Patient patient) {
        for (Doctor doc : doctors) {
            if (doc.isPatientInQueue(patient)) {
                return doc;
            }
        }
        return null;
    }


    public void viewStatus(String patientName) {
        if (patientName == null || patientName.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }
        Patient patient = findPatient(patientName.trim());

        if (patient == null) {
            System.err.println("Error: Patient '" + patientName + "' not found.");
            return;
        }

        Appointment appointment = getPatientAppointment(patient);
        if (appointment != null) {
            System.out.println("Patient '" + patient.getName() + "' is scheduled with " + appointment.getDoctor().getName() + ".");
            return;
        }

        Doctor waitingDoctor = getPatientWaitingDoctor(patient);
        if (waitingDoctor != null) {
            // Optional: find position in queue - requires iterating the queue
            int position = 0;
            boolean found = false;
            for(Patient p : waitingDoctor.getWaitingQueue()) { // Iterate Queue
                position++;
                if (p.equals(patient)) {
                    found = true;
                    break;
                }
            }
            if (found) {
                 System.out.println("Patient '" + patient.getName() + "' is in the waiting queue for " + waitingDoctor.getName() + " (Position: " + position + ").");
            } else {
                 // Should not happen if getPatientWaitingDoctor returned the doctor, but good defensive check
                 System.out.println("Patient '" + patient.getName() + "' is in a waiting queue for " + waitingDoctor.getName() + ".");
            }
            return;
        }

        // If not scheduled and not in queue
        System.out.println("Patient '" + patient.getName() + "' is registered but has no active request or appointment.");
    }

    public void cancelRequest(String patientName) {
         if (patientName == null || patientName.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }
        Patient patient = findPatient(patientName.trim());

        if (patient == null) {
            System.err.println("Error: Patient '" + patientName + "' not found.");
            return;
        }

        // Check scheduled appointments first
        Appointment appointmentToCancel = null;
        Iterator<Appointment> aptIterator = appointments.iterator(); // Use Iterator for safe removal
        while (aptIterator.hasNext()) {
            Appointment apt = aptIterator.next();
            if (apt.getPatient().equals(patient)) {
                appointmentToCancel = apt;
                aptIterator.remove(); // Remove using iterator
                apt.getDoctor().finishCurrentPatient(); // Free up the doctor
                System.out.println("Appointment for '" + patient.getName() + "' with " + apt.getDoctor().getName() + " cancelled.");
                return; // Found and cancelled scheduled appointment
            }
        }

        // If not in scheduled appointments, check waiting queues
        Doctor waitingDoctor = getPatientWaitingDoctor(patient);
        if (waitingDoctor != null) {
            if (waitingDoctor.removeFromQueue(patient)) { // remove from queue
                 System.out.println("Request for '" + patient.getName() + "' removed from " + waitingDoctor.getName() + "'s waiting queue.");
                 return; // Found and removed from queue
            }
             // Should technically not reach here if getPatientWaitingDoctor was correct, but defensive
             System.err.println("Internal Error: Patient reported in queue but could not be removed.");
             return;
        }

        // If not in appointment and not in queue
        System.out.println("Patient '" + patient.getName() + "' has no active request or appointment to cancel.");
    }


    // --- Main Application Loop ---
    public void run() {
        System.out.println("--- Hospital Appointment System ---");
        System.out.println("Commands: register patient <name>, register doctor <name>, request <patient_name> <doctor_name>, status <patient_name>, cancel <patient_name>, exit");

        while (true) {
            System.out.print("\nEnter command: ");
            String line = scanner.nextLine();
            String[] parts = line.trim().split("\\s+"); // Split by whitespace

            if (parts.length == 0 || parts[0].isEmpty()) {
                continue; // Ignore empty lines
            }

            String command = parts[0].toLowerCase(); // Process command case-insensitively

            // Class-wide exception handling around the command processing
            try {
                switch (command) {
                    case "register":
                        if (parts.length >= 3) {
                            String type = parts[1].toLowerCase();
                            String name = "";
                            // Reconstruct name allowing spaces
                            for (int i = 2; i < parts.length; i++) {
                                name += parts[i] + (i < parts.length - 1 ? " " : "");
                            }
                            if (type.equals("patient")) {
                                registerPatient(name);
                            } else if (type.equals("doctor")) {
                                registerDoctor(name);
                            } else {
                                System.err.println("Error: Unknown registration type. Use 'patient' or 'doctor'.");
                            }
                        } else {
                            System.err.println("Error: Invalid 'register' command format. Use 'register patient <name>' or 'register doctor <name>'.");
                        }
                        break;

                    case "request":
                        if (parts.length >= 4) {
                             // Patient and doctor names might contain spaces, need to find the split point
                             String patientName = null;
                             String doctorName = null;
                             // Simple approach: assume the split is after the first two words
                             // More robust would involve quoting or looking up registered names
                             // For exam simplicity, let's assume names don't contain spaces, or
                             // if they do, they are captured by joining remaining parts.
                             // Let's stick to simple split for exam: patient name is parts[1], doctor name is parts[2]
                             // This means names with spaces won't work unless quoted or handled differently.
                             // A better exam approach: "request <patient_name> with <doctor_name>"
                             // Let's revise the command format for simplicity: "request <patientName> <doctorName>"
                             // And assume names are single words OR handle spaces carefully.
                             // Let's handle spaces by taking the first part as patient, rest as doctor for now, needs refinement.
                             // Simpler: require single word names for patient and doctor in 'request'.
                             // Let's assume single word names for simplicity in request/status/cancel.
                            if (parts.length == 3) {
                                patientName = parts[1];
                                doctorName = parts[2];
                                requestAppointment(patientName, doctorName);
                            } else {
                                System.err.println("Error: Invalid 'request' command format. Use 'request <patientName> <doctorName>'. (Names should be single words for this command)");
                            }

                        } else {
                            System.err.println("Error: Invalid 'request' command format. Use 'request <patientName> <doctorName>'.");
                        }
                        break;

                    case "status":
                         if (parts.length >= 2) {
                             // Assuming patient name can have spaces if it's the rest of the line
                             String patientName = "";
                             for (int i = 1; i < parts.length; i++) {
                                 patientName += parts[i] + (i < parts.length - 1 ? " " : "");
                             }
                             viewStatus(patientName.trim());
                         } else {
                             System.err.println("Error: Invalid 'status' command format. Use 'status <patientName>'.");
                         }
                         break;

                    case "cancel":
                         if (parts.length >= 2) {
                             // Assuming patient name can have spaces if it's the rest of the line
                             String patientName = "";
                             for (int i = 1; i < parts.length; i++) {
                                 patientName += parts[i] + (i < parts.length - 1 ? " " : "");
                             }
                             cancelRequest(patientName.trim());
                         } else {
                             System.err.println("Error: Invalid 'cancel' command format. Use 'cancel <patientName>'.");
                         }
                         break;


                    case "exit":
                        System.out.println("Exiting Hospital System.");
                        scanner.close(); // Close the scanner
                        return; // Exit the run method and main

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            } catch (Exception e) {
                // Class-wide catch for unexpected errors during command processing
                System.err.println("An unexpected error occurred while processing the command: " + e.getMessage());
                // Optional: e.printStackTrace(); // For debugging
            }
        }
    }

    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.run();
    }
}
