/*
 * Exam Question #217
 * Generated on: 2025-05-11 22:33:44
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Shop Job Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Print Shop Job Management system. This system will manage print jobs submitted by customers. Jobs are processed in the order they are received. The system should allow adding new jobs, processing the next pending job, viewing pending jobs, viewing completed jobs, and searching for a job by its ID.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store jobs that are waiting to be processed (pending jobs).
 *     *   Use an `ArrayList` to store jobs that have been completed.
 *     *   Use the `List` interface when referring to collections of jobs where the specific implementation (like `ArrayList`) is not critical, such as method return types for viewing jobs.
 * 2.  **Job Representation:** Create a `PrintJob` class to represent a single print job. It should include:
 *     *   A unique integer `jobId`.
 *     *   Customer name (String).
 *     *   Number of pages (int).
 *     *   A status (e.g., using an enum: `PENDING`, `COMPLETED`).
 *     *   Appropriate getters and a method to update the status.
 * 3.  **Job Manager:** Create a `PrintManager` class responsible for managing the collections of pending and completed jobs. It should have methods for:
 *     *   Adding a new job to the pending queue.
 *     *   Processing the next job from the pending queue (moving it to the completed list and updating its status). This method should handle the case where the pending queue is empty.
 *     *   Retrieving a list of pending jobs.
 *     *   Retrieving a list of completed jobs.
 *     *   Finding a job (either pending or completed) by its ID.
 * 4.  **User Interface:** Create a main class (`PrintShopApp`) with a `main` method that provides a text-based menu interface using `Scanner` for user interaction. The menu should include options for:
 *     *   Add New Job
 *     *   Process Next Job
 *     *   View Pending Jobs
 *     *   View Completed Jobs
 *     *   Find Job by ID
 *     *   Exit
 * 5.  **Control Flow:** Use a `switch` statement in the main application loop to handle the user's menu choice.
 * 6.  **Input/Output:**
 *     *   Use `Scanner` to read user input for menu choices and job details.
 *     *   Use `System.out` for displaying the menu, normal messages, and job lists.
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process an empty queue, invalid menu choice).
 * 7.  **Exception Handling:** Implement robust exception handling using `try-catch` blocks. This should include:
 *     *   Handling potential `InputMismatchException` when reading user input.
 *     *   Handling the case where the user tries to process a job when the pending queue is empty (consider defining a custom exception for this).
 *     *   Handling other potential runtime errors gracefully.
 * 8.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement input validation (e.g., ensure page count is positive).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should run continuously, displaying the menu and responding to user input.
 * - Adding a job should report the assigned job ID.
 * - Processing a job should indicate which job was processed.
 * - Viewing lists should display the details of jobs in the respective lists.
 * - Finding a job should display its details or indicate if not found.
 * - Error messages should be clearly displayed using `System.err`.
 * - Invalid input should be handled gracefully, allowing the program to continue.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Print Shop Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Find Job by ID
 * 0. Exit
 * -----------------------
 * Enter your choice: 1
 * Enter customer name: Alice
 * Enter number of pages: 10
 * Job added successfully with ID: 1
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 1
 * Enter customer name: Bob
 * Enter number of pages: 5
 * Job added successfully with ID: 2
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * Job ID: 1, Customer: Alice, Pages: 10, Status: PENDING
 * Job ID: 2, Customer: Bob, Pages: 5, Status: PENDING
 * --------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * Processed job ID 1 for Alice
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * Job ID: 2, Customer: Bob, Pages: 5, Status: PENDING
 * --------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job ID: 1, Customer: Alice, Pages: 10, Status: COMPLETED
 * ----------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 5
 * Enter Job ID to find: 2
 * Found Job: Job ID: 2, Customer: Bob, Pages: 5, Status: PENDING
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 0 and 5.
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Print Shop Job Manager. Goodbye!
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Correct logic for managing jobs (adding, processing, listing, finding).
 * *   Robustness in handling invalid input and operational errors.
 * *   Clean and well-structured code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Print Shop Job Management system following all the specified requirements.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a print job with `jobId`, `customerName`, `pageCount`, and `status`.
 *     *   An `enum Status` is used for clarity and type safety for job status.
 *     *   The constructor includes basic input validation for `pageCount`.
 *     *   Getters provide controlled access to job properties.
 *     *   `setStatus` allows changing the job's status.
 *     *   `toString` provides a convenient string representation for printing.
 * 
 * 2.  **`EmptyQueueException` Class:**
 *     *   A simple custom exception class is defined to specifically signal when an operation requiring a non-empty queue (like processing the next job) is attempted on an empty queue. This makes the error handling in `PrintShopApp` more specific and readable than using a general exception.
 * 
 * 3.  **`PrintManager` Class:**
 *     *   Manages the core logic and data structures.
 *     *   `pendingJobsQueue`: Declared as a `Queue<PrintJob>` and initialized as a `LinkedList`. `LinkedList` is a good choice here as it implements the `Queue` interface and provides efficient insertion/removal at both ends, suitable for a queue's FIFO (First-In, First-Out) behavior.
 *     *   `completedJobsList`: Declared as a `List<PrintJob>` and initialized as an `ArrayList`. `ArrayList` is suitable for storing completed jobs where access by index or iteration is common.
 *     *   `nextJobId`: A simple counter to ensure unique job IDs.
 *     *   `addJob`: Creates a new `PrintJob` with a unique ID and adds it to the `pendingJobsQueue` using `offer()`.
 *     *   `processNextJob`: Checks if the `pendingJobsQueue` is empty. If so, it throws the custom `EmptyQueueException`. Otherwise, it uses `poll()` to remove the next job from the queue, updates its status to `COMPLETED`, adds it to the `completedJobsList`, and returns the processed job.
 *     *   `getPendingJobs` and `getCompletedJobs`: These methods return `List<PrintJob>`. Crucially, they return *unmodifiable* lists (using `Collections.unmodifiableList(new ArrayList<>(...))`) to prevent external code from directly modifying the internal state of the `PrintManager`'s collections, upholding encapsulation principles.
 *     *   `findJobById`: Iterates through both the pending queue and the completed list to find a job by its ID, returning the job or `null`.
 * 
 * 4.  **`PrintShopApp` Class (Main Class):**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   Creates instances of `PrintManager` and `Scanner`.
 *     *   Uses a `try-with-resources` block to ensure the `Scanner` is automatically closed when the program exits or an exception occurs that leaves the `try` block.
 *     *   A `do-while` loop runs the main application cycle, displaying the menu and processing user input until the 'Exit' option (0) is chosen.
 *     *   Inside the loop, a `try-catch` block is used to handle potential exceptions during input reading and processing, specifically `InputMismatchException` if the user enters non-numeric input where a number is expected.
 *     *   A `switch` statement directs the program flow based on the user's valid menu choice.
 *     *   Each case in the `switch` calls the appropriate method in the `PrintManager`.
 *     *   Input validation for page count is performed before creating a `PrintJob`.
 *     *   Specific `try-catch` blocks are used within the `switch` cases where specific exceptions are expected (e.g., catching `EmptyQueueException` when processing a job).
 *     *   `System.out` is used for standard output (menu, success messages, job listings).
 *     *   `System.err` is used for displaying error messages (invalid input, empty queue error, invalid menu choice, unexpected errors).
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing an error message and allowing the loop to continue.
 * 
 * This structure effectively demonstrates the use of the required Java components in a practical scenario, adhering to best practices for object-oriented design, error handling, and input/output management. The strategic placement of `try-catch` blocks within the main loop and specific actions ensures graceful error recovery and allows the application to continue running even after invalid input or certain operational errors.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collections; // For unmodifiable lists (Java 8 compatibility)

// Represents a single print job
class PrintJob {
    // Enum for job status
    public enum Status {
        PENDING, COMPLETED
    }

    private int jobId;
    private String customerName;
    private int pageCount;
    private Status status;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param customerName The name of the customer.
     * @param pageCount The number of pages in the job.
     */
    public PrintJob(int jobId, String customerName, int pageCount) {
        if (pageCount <= 0) {
            throw new IllegalArgumentException("Page count must be positive.");
        }
        this.jobId = jobId;
        this.customerName = customerName;
        this.pageCount = pageCount;
        this.status = Status.PENDING; // New jobs are always pending
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getCustomerName() {
        return customerName;
    }

    public int getPageCount() {
        return pageCount;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Sets the status of the print job.
     * @param status The new status for the job.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Job ID: %d, Customer: %s, Pages: %d, Status: %s",
                             jobId, customerName, pageCount, status);
    }
}

// Custom exception for when the queue is empty
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with a detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Manages the collection of print jobs
class PrintManager {
    // Queue for jobs waiting to be processed (FIFO)
    private Queue<PrintJob> pendingJobsQueue;
    // List for jobs that have been completed
    private List<PrintJob> completedJobsList;
    // Counter for generating unique job IDs
    private int nextJobId;

    /**
     * Constructs a new PrintManager, initializing job collections.
     */
    public PrintManager() {
        // LinkedList implements the Queue interface and is suitable for this use case
        this.pendingJobsQueue = new LinkedList<>();
        // ArrayList is a common general-purpose List implementation
        this.completedJobsList = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue.
     * @param customerName The name of the customer.
     * @param pageCount The number of pages in the job.
     * @return The unique ID assigned to the new job.
     * @throws IllegalArgumentException if page count is not positive.
     */
    public int addJob(String customerName, int pageCount) {
        // PrintJob constructor validates pageCount
        PrintJob newJob = new PrintJob(nextJobId++, customerName, pageCount);
        pendingJobsQueue.offer(newJob); // offer() is preferred over add() for queues
        return newJob.getJobId();
    }

    /**
     * Processes the next job from the pending queue, moves it to completed,
     * and updates its status.
     * @return The PrintJob that was processed.
     * @throws EmptyQueueException if there are no pending jobs to process.
     */
    public PrintJob processNextJob() throws EmptyQueueException {
        // Check if the queue is empty before trying to poll
        if (pendingJobsQueue.isEmpty()) {
            throw new EmptyQueueException("No pending jobs to process.");
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        // (though we already checked with isEmpty)
        PrintJob jobToProcess = pendingJobsQueue.poll();

        // Update status and move to completed list
        if (jobToProcess != null) {
            jobToProcess.setStatus(PrintJob.Status.COMPLETED);
            completedJobsList.add(jobToProcess);
        }
        return jobToProcess; // Return the job that was just processed
    }

    /**
     * Retrieves a list of all pending jobs.
     * Returns an unmodifiable list to prevent external modification of the queue.
     * @return A List of pending PrintJobs.
     */
    public List<PrintJob> getPendingJobs() {
        // Return an unmodifiable copy to protect the internal queue state
        // Use new ArrayList for Java 8 compatibility with Collections.unmodifiableList
        return Collections.unmodifiableList(new ArrayList<>(pendingJobsQueue));
    }

    /**
     * Retrieves a list of all completed jobs.
     * Returns an unmodifiable list to prevent external modification.
     * @return A List of completed PrintJobs.
     */
    public List<PrintJob> getCompletedJobs() {
        // Return an unmodifiable view of the completed list
         return Collections.unmodifiableList(completedJobsList);
    }

    /**
     * Finds a job by its ID in either the pending or completed lists.
     * @param id The ID of the job to find.
     * @return The PrintJob if found, otherwise null.
     */
    public PrintJob findJobById(int id) {
        // Search pending jobs first
        for (PrintJob job : pendingJobsQueue) {
            if (job.getJobId() == id) {
                return job;
            }
        }
        // If not found in pending, search completed jobs
        for (PrintJob job : completedJobsList) {
            if (job.getJobId() == id) {
                return job;
            }
        }
        return null; // Job not found
    }
}

// Main application class with user interface
public class PrintShopApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Print Shop Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Find Job by ID");
        System.out.println("0. Exit");
        System.out.println("-----------------------");
    }

    public static void main(String[] args) {
        PrintManager printManager = new PrintManager();
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice;

            // Main application loop
            do {
                displayMenu();

                // Use a try-catch block around the input reading and processing
                // to handle potential InputMismatchException or other errors gracefully
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer choice
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Switch statement for menu navigation
                    switch (choice) {
                        case 1: // Add Job
                            System.out.print("Enter customer name: ");
                            String name = scanner.nextLine();

                            System.out.print("Enter number of pages: ");
                            int pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            // Input validation for page count
                            if (pages <= 0) {
                                System.err.println("Error: Page count must be positive.");
                                break; // Exit switch, continue loop
                            }

                            try {
                                int jobId = printManager.addJob(name, pages);
                                System.out.println("Job added successfully with ID: " + jobId);
                            } catch (IllegalArgumentException e) {
                                // Catch exception from PrintJob constructor validation
                                System.err.println("Error adding job: " + e.getMessage());
                            }
                            break;

                        case 2: // Process Next Job
                            try {
                                PrintJob processedJob = printManager.processNextJob();
                                System.out.println("Processed job ID " + processedJob.getJobId() + " for " + processedJob.getCustomerName());
                            } catch (EmptyQueueException e) {
                                // Handle the custom exception when queue is empty
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case 3: // View Pending Jobs
                            List<PrintJob> pending = printManager.getPendingJobs();
                            if (pending.isEmpty()) {
                                System.out.println("No pending jobs.");
                            } else {
                                System.out.println("--- Pending Jobs ---");
                                // Iterate and print using forEach and method reference
                                pending.forEach(System.out::println);
                                System.out.println("--------------------");
                            }
                            break;

                        case 4: // View Completed Jobs
                            List<PrintJob> completed = printManager.getCompletedJobs();
                            if (completed.isEmpty()) {
                                System.out.println("No completed jobs.");
                            } else {
                                System.out.println("--- Completed Jobs ---");
                                // Iterate and print using enhanced for loop
                                for (PrintJob job : completed) {
                                    System.out.println(job);
                                }
                                System.out.println("----------------------");
                            }
                            break;

                        case 5: // Find Job by ID
                            System.out.print("Enter Job ID to find: ");
                            // This nextInt() is within the main try block,
                            // InputMismatchException is caught below.
                            int searchId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            PrintJob foundJob = printManager.findJobById(searchId);
                            if (foundJob != null) {
                                System.out.println("Found Job: " + foundJob);
                            } else {
                                System.out.println("Job with ID " + searchId + " not found.");
                            }
                            break;

                        case 0: // Exit
                            System.out.println("Exiting Print Shop Job Manager. Goodbye!");
                            break;

                        default:
                            // Handle invalid menu choices
                            System.err.println("Error: Invalid choice. Please enter a number between 0 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input for numbers
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Set choice to a value that keeps the loop running
                } catch (Exception e) {
                    // Catch any other unexpected exceptions that might occur
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging during development: e.printStackTrace();
                    choice = -1; // Keep the loop running after unexpected error
                }

            } while (choice != 0); // Loop until the user chooses to exit

        } // Scanner is automatically closed here by the try-with-resources block
    }
}
