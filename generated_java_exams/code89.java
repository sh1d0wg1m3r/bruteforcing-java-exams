/*
 * Exam Question #89
 * Generated on: 2025-05-11 22:12:06
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Package Processing and Shipping System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for managing packages in a small distribution center. Packages arrive, are placed in a queue for processing, and then moved to a shipped list once processed. The system needs to handle user input for adding packages, processing the next package, and viewing the status of packages.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a class `Package` with the following private attributes:
 *     *   `packageId` (int): A unique identifier for the package.
 *     *   `destination` (String): The shipping destination.
 *     *   `weight` (double): The weight of the package in kilograms.
 *     *   Include a constructor, appropriate getters, and a `toString()` method to display package details.
 * 
 * 2.  **System Core:** Create a class (e.g., `PackageProcessingSystem`) that manages the package flow. This class must contain:
 *     *   A `Queue<Package>` to hold packages waiting for processing.
 *     *   A `List<Package>` (implemented using `ArrayList`) to hold packages that have been processed/shipped.
 *     *   A mechanism to generate unique package IDs (e.g., a counter).
 * 
 * 3.  **Functionality:** Implement the following operations within the system class:
 *     *   `addPackage(String destination, double weight)`: Adds a new package to the processing queue. Assigns a unique ID. Validates input (destination not empty, weight > 0). Throws an exception or handles invalid input appropriately.
 *     *   `processNextPackage()`: Removes the package at the front of the processing queue and adds it to the shipped packages list. If the queue is empty, it should indicate an error.
 *     *   `viewProcessingQueue()`: Displays the details of all packages currently in the processing queue.
 *     *   `viewShippedPackages()`: Displays the details of all packages that have been shipped.
 * 
 * 4.  **User Interface:** Implement a command-line interface in the `main` method using `Scanner` to interact with the system. The interface should present a menu with options:
 *     *   Add Package
 *     *   Process Next Package
 *     *   View Processing Queue
 *     *   View Shipped Packages
 *     *   Exit
 * 
 * 5.  **Control Flow and Error Handling:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation for adding packages (destination and weight). Use `System.err.println()` for invalid input messages.
 *     *   Use `System.out.println()` for menu display, prompts, successful operations, and displaying package lists.
 *     *   Implement exception handling using `try-catch` blocks. Wrap the main interaction loop or critical operations within a `try-catch` block to handle potential runtime errors gracefully (demonstrating class-wide handling in the main execution flow). Use `System.err.println()` to report caught exceptions.
 *     *   Handle the specific case of trying to process a package when the queue is empty, reporting the error using `System.err.println()`.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include comments where necessary, especially for complex logic or method purpose (Javadoc style encouraged).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, prompt for user input, perform the requested action, and display results or error messages accordingly.
 * 
 * *   Adding a package: Prompt for destination and weight. On success, confirm the package was added with its ID. On failure (invalid input), print an error to `System.err`.
 * *   Processing: On success, indicate which package (by ID) was processed. On failure (empty queue), print an error to `System.err`.
 * *   Viewing queues/lists: Print the details of packages in the respective collection, or indicate if the collection is empty.
 * *   Exit: Terminate the program.
 * *   General Errors: Any unexpected exceptions caught by the main `try-catch` should print an error message (including exception details) to `System.err`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Package Processing System Menu:
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Processing Queue
 * 4. View Shipped Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter destination: New York
 * Enter weight (kg): 5.5
 * Package 1 added to processing queue.
 * 
 * Package Processing System Menu:
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Processing Queue
 * 4. View Shipped Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter destination:
 * Enter weight (kg): 2.0
 * Error: Destination cannot be empty.
 * 
 * Package Processing System Menu:
 * ...
 * Enter your choice: 3
 * --- Processing Queue ---
 * Package ID: 1, Destination: New York, Weight: 5.5 kg
 * ------------------------
 * 
 * Package Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing package 1... Package 1 shipped.
 * 
 * Package Processing System Menu:
 * ...
 * Enter your choice: 4
 * --- Shipped Packages ---
 * Package ID: 1, Destination: New York, Weight: 5.5 kg
 * ------------------------
 * 
 * Package Processing System Menu:
 * ...
 * Enter your choice: 2
 * Error: Processing queue is empty.
 * 
 * Package Processing System Menu:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simplified package processing and shipping system, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * 1.  `Package` class: This is a simple Plain Old Java Object (POJO) representing a package. It encapsulates the package's state (`packageId`, `destination`, `weight`) using private fields and provides public getter methods. The `toString()` method is overridden for easy printing of package details. This fulfills the encapsulation and meaningful naming requirements.
 * 
 * 2.  `PackageProcessingSystem` class: This class contains the core logic for managing packages.
 *     *   It uses a `java.util.Queue<Package>` named `processingQueue` (specifically, a `LinkedList` implementation) to store packages waiting to be processed. The `Queue` interface is ideal here because packages are processed in a First-In, First-Out (FIFO) manner.
 *     *   It uses a `java.util.List<Package>` named `shippedPackages` (specifically, an `ArrayList` implementation) to store packages that have completed processing. The `List` interface provides ordered storage and easy iteration over the shipped items.
 *     *   `nextPackageId` is a simple counter to ensure unique IDs for new packages.
 * 
 * **Key Functionality Implementation:**
 * *   `addPackage(String destination, double weight)`: This method demonstrates input validation. It checks if the destination is empty or null and if the weight is positive. Invalid input results in an error message printed to `System.err` and returns `null`. Valid input creates a `Package` object with a unique ID and adds it to the `processingQueue` using the `offer()` method (a standard `Queue` operation).
 * *   `processNextPackage()`: This method demonstrates queue processing. It first checks if the `processingQueue` is empty. If so, it prints an error to `System.err` and returns `null`. Otherwise, it uses `poll()` to retrieve and remove the package at the head of the queue and adds it to the `shippedPackages` `ArrayList`.
 * *   `viewProcessingQueue()` and `viewShippedPackages()`: These methods iterate over the respective collections (`Queue` and `List`) and print the details of each package using the `Package` class's `toString()` method. They also handle the case where a collection is empty.
 * 
 * **User Interface and Control Flow:**
 * *   The `main` method in `PackageProcessingSystem` acts as the command-line interface.
 * *   A `Scanner` is used to read user input from `System.in`.
 * *   A `while` loop keeps the system running until the user chooses to exit.
 * *   A menu is displayed using `System.out.println()`.
 * *   User input for the menu choice is read. Input validation for the choice being an integer is included.
 * *   A `switch` statement is used to direct the program flow based on the user's valid choice, calling the appropriate methods in the `PackageProcessingSystem` instance.
 * *   `System.out.println()` is used for successful operations, prompts, and displaying lists.
 * *   `System.err.println()` is used specifically for printing error messages, such as invalid input during package creation or attempting to process an empty queue.
 * 
 * **Exception Handling:**
 * *   The entire `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This demonstrates a form of "class-wide" exception handling for the main execution flow, catching any unexpected `Exception` that might occur during the program's operation (beyond the specific input validation and empty queue checks handled internally). If an unexpected exception occurs, it is caught, an error message is printed to `System.err`, and the stack trace is printed using `e.printStackTrace(System.err)`, providing debugging information.
 * *   Specific input validation errors (like `NumberFormatException` when parsing weight or choice) are also handled, printing messages to `System.err`.
 * 
 * **Required Components Usage:**
 * *   `Queue`: Used for `processingQueue` (FIFO).
 * *   `ArrayList`: Used for `shippedPackages` (dynamic list).
 * *   `List interface`: `shippedPackages` is declared as `List<Package>`.
 * *   `Scanner`: Used in `main` for reading user input.
 * *   `Switch statement`: Used in `main` for menu navigation.
 * *   `System.err`: Used for all error messages.
 * *   `System.out`: Used for normal output (menu, prompts, success messages, lists).
 * *   `try-catch`: Used in `main` for general exception handling and specific input parsing errors.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, adheres to best practices like encapsulation and clear naming, and demonstrates robust error handling and input validation, making it a suitable challenge for an advanced Java exam.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Specific exception for queue operations

/**
 * Represents a package to be processed and shipped.
 */
class Package {
    private int packageId;
    private String destination;
    private double weight; // in kilograms

    /**
     * Constructs a new Package.
     * @param packageId The unique ID for the package.
     * @param destination The shipping destination.
     * @param weight The weight of the package.
     */
    public Package(int packageId, String destination, double weight) {
        this.packageId = packageId;
        this.destination = destination;
        this.weight = weight;
    }

    // Getters
    public int getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Provides a string representation of the package.
     * @return A formatted string describing the package.
     */
    @Override
    public String toString() {
        return String.format("Package ID: %d, Destination: %s, Weight: %.2f kg",
                             packageId, destination, weight);
    }
}

/**
 * Manages the processing and shipping of packages using queues and lists.
 */
public class PackageProcessingSystem {

    // Using LinkedList as a Queue implementation
    private Queue<Package> processingQueue;
    // Using ArrayList as a List implementation for shipped packages
    private List<Package> shippedPackages;
    private int nextPackageId;

    /**
     * Constructs a new PackageProcessingSystem.
     * Initializes the processing queue and shipped packages list.
     */
    public PackageProcessingSystem() {
        this.processingQueue = new LinkedList<>();
        this.shippedPackages = new ArrayList<>();
        this.nextPackageId = 1; // Start package IDs from 1
    }

    /**
     * Adds a new package to the processing queue after validation.
     * @param destination The destination of the package.
     * @param weight The weight of the package.
     * @return The newly created package, or null if validation fails.
     */
    public Package addPackage(String destination, double weight) {
        // Input validation
        if (destination == null || destination.trim().isEmpty()) {
            System.err.println("Error: Destination cannot be empty.");
            return null; // Indicate failure
        }
        if (weight <= 0) {
            System.err.println("Error: Weight must be a positive value.");
            return null; // Indicate failure
        }

        Package newPackage = new Package(nextPackageId++, destination.trim(), weight);
        processingQueue.offer(newPackage); // offer is generally preferred over add in queues as it returns boolean
        return newPackage; // Indicate success
    }

    /**
     * Processes the next package in the queue (removes it and adds to shipped list).
     * @return The processed package, or null if the queue is empty.
     */
    public Package processNextPackage() {
        // Check if the queue is empty before attempting to poll
        if (processingQueue.isEmpty()) {
            System.err.println("Error: Processing queue is empty.");
            return null; // Indicate failure
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        Package processedPackage = processingQueue.poll();
        if (processedPackage != null) {
            shippedPackages.add(processedPackage);
            return processedPackage; // Indicate success
        }
        // This case should theoretically not be reached due to the isEmpty check,
        // but good practice to handle poll returning null defensively.
        System.err.println("Error: Failed to retrieve package from queue.");
        return null;
    }

    /**
     * Displays all packages currently in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterating over the queue without removing elements
            for (Package pkg : processingQueue) {
                System.out.println(pkg);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Displays all packages that have been shipped.
     */
    public void viewShippedPackages() {
        System.out.println("--- Shipped Packages ---");
        if (shippedPackages.isEmpty()) {
            System.out.println("No packages have been shipped yet.");
        } else {
            // Iterating over the list
            for (Package pkg : shippedPackages) {
                System.out.println(pkg);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Main method to run the Package Processing System.
     * Handles user interaction and calls system methods.
     * Includes a class-wide try-catch for general exceptions.
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PackageProcessingSystem system = new PackageProcessingSystem();
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                System.out.println("\nPackage Processing System Menu:");
                System.out.println("1. Add Package");
                System.out.println("2. Process Next Package");
                System.out.println("3. View Processing Queue");
                System.out.println("4. View Shipped Packages");
                System.out.println("5. Exit");
                System.out.print("Enter your choice: ");

                // Use a nested try-catch for Scanner input specifically,
                // or rely on the outer try-catch for broader issues.
                // Let's rely on the outer one for simplicity and meeting "class-wide" feel.
                // However, checking for non-integer input is good practice.
                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration
                }


                // Using a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter destination: ");
                        String destination = scanner.nextLine();
                        System.out.print("Enter weight (kg): ");
                        double weight = -1; // Initialize with invalid value
                        try {
                            weight = Double.parseDouble(scanner.nextLine());
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid weight format. Please enter a number.");
                            break; // Exit switch case, continue loop
                        }
                        Package addedPackage = system.addPackage(destination, weight);
                        if (addedPackage != null) {
                            System.out.println("Package " + addedPackage.getPackageId() + " added to processing queue.");
                        }
                        // Error message is printed within addPackage method
                        break;

                    case 2:
                        Package processedPackage = system.processNextPackage();
                        if (processedPackage != null) {
                            System.out.println("Processing package " + processedPackage.getPackageId() + "... Package " + processedPackage.getPackageId() + " shipped.");
                        }
                        // Error message for empty queue is printed within processNextPackage method
                        break;

                    case 3:
                        system.viewProcessingQueue();
                        break;

                    case 4:
                        system.viewShippedPackages();
                        break;

                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // This catch block handles any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
