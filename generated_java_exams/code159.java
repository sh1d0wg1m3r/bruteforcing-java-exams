/*
 * Exam Question #159
 * Generated on: 2025-05-11 22:23:22
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Production Line Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a production line task management system. The system should manage tasks as they enter, are processed, and are completed. It needs to handle incoming tasks, process the next available task, and allow viewing the current state of the production line.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a unit of work on the production line. Each `Task` should have:
 *     *   A unique integer ID (assigned automatically by the system).
 *     *   A String description of the task.
 *     *   A status (e.g., `PENDING`, `PROCESSING`, `COMPLETED`). Use an `enum` for the status.
 *     *   Private fields with public getter methods.
 *     *   A meaningful `toString()` method for easy display.
 * 
 * 2.  **Production Line Manager:** Create a `ProductionLineManager` class responsible for managing the tasks. This class must:
 *     *   Use a `java.util.Queue<Task>` to hold tasks that are waiting to be processed (`PENDING`).
 *     *   Use a `java.util.List<Task>` (specifically implemented using `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Maintain an internal counter for assigning unique task IDs.
 *     *   Provide a method to add a new task to the pending queue.
 *     *   Provide a method to process the next task from the pending queue. This method should move the task from the queue, update its status to `COMPLETED`, and add it to the completed list. It should handle the case where the queue is empty.
 *     *   Provide methods to get lists of pending tasks and completed tasks.
 *     *   All fields should be private, and methods public where necessary for interaction.
 * 
 * 3.  **User Interface (Main Application):** Create a main application class (e.g., `ProductionLineApp`) with a `main` method. This method will:
 *     *   Instantiate the `ProductionLineManager`.
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 *     *   Include input validation for the user's command choice (must be a valid menu number).
 *     *   Use `System.out` for all normal output (menu, task lists, success messages).
 *     *   Use `java.lang.System.err` for all error messages (e.g., invalid command, processing failed because queue is empty, invalid task description input).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle unexpected errors during user input or task processing.
 * 
 * **Required Java Components Checklist:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `java.lang.System.err`
 * *   `java.lang.System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods/getters).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (Javadoc where applicable).
 * *   Input validation and proper error handling.
 * *   Clean code structure.
 * *   Use the `enum` for task status.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Assemble Widget A
 * Task added: Task{id=1, description='Assemble Widget A', status=PENDING}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Test Component B
 * Task added: Task{id=2, description='Test Component B', status=PENDING}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=1, description='Assemble Widget A', status=PENDING}
 * Task{id=2, description='Test Component B', status=PENDING}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Processed: Task{id=1, description='Assemble Widget A', status=COMPLETED}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=2, description='Test Component B', status=PENDING}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Assemble Widget A', status=COMPLETED}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Processed: Task{id=2, description='Test Component B', status=COMPLETED}
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * System.err: No tasks in the pending queue to process.
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: exit (user types non-integer)
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Production Line System.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Task` class, the `ProductionLineManager` class, and the main application class (`ProductionLineApp`) in a single code block.
 *
 * EXPLANATION:
 * This solution implements the Production Line Task Management System as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * **1. Task Representation (`Task` class):**
 * *   An `enum`, `TaskStatus`, is used to define the possible states of a task (`PENDING`, `COMPLETED`).
 * *   The `Task` class encapsulates task data (`id`, `description`, `status`) using private fields and public getters.
 * *   The constructor validates the description input, throwing an `IllegalArgumentException` if it's invalid.
 * *   A `markCompleted()` method is provided for controlled status updates by the manager.
 * *   A `toString()` method provides a convenient way to display task information.
 * 
 * **2. Production Line Manager (`ProductionLineManager` class):**
 * *   It uses a `java.util.Queue<Task>` (`pendingTasksQueue`) implemented by `java.util.LinkedList`. `LinkedList` is suitable here because `Queue` operations like `offer` (add to end) and `poll` (remove from front) are efficient.
 * *   It uses a `java.util.List<Task>` (`completedTasksList`) implemented by `java.util.ArrayList`. `ArrayList` is efficient for storing and iterating over completed tasks.
 * *   `nextTaskId` ensures unique IDs for tasks.
 * *   `addTask(String description)` creates a new `Task` and adds it to the `pendingTasksQueue` using `offer()`.
 * *   `processNextTask()` uses `poll()` to remove the head of the `pendingTasksQueue`. If a task is retrieved (`poll()` returns non-null), its status is updated using `markCompleted()`, and it's added to the `completedTasksList`. It returns the processed task or `null` if the queue was empty, which the calling code must handle.
 * *   `getPendingTasks()` and `getCompletedTasks()` return copies of the internal lists (`ArrayList` constructor from another collection) to maintain encapsulation and prevent external code from modifying the manager's internal state directly.
 * 
 * **3. User Interface (`ProductionLineApp` class):**
 * *   The `main` method drives the application.
 * *   `java.util.Scanner` reads user input from `System.in`.
 * *   A `while(running)` loop keeps the application active until the user chooses to exit.
 * *   A `switch` statement handles the different menu choices, calling the appropriate methods on the `ProductionLineManager`.
 * *   Input validation is performed using `scanner.hasNextInt()` before reading the integer choice to prevent `InputMismatchException` for non-integer input. If invalid, an error is printed to `System.err`, and the invalid input is consumed.
 * *   Normal output (menu, task lists, success messages) is directed to `System.out`.
 * *   Error messages (invalid choice, queue empty, invalid task description) are directed to `java.lang.System.err`.
 * *   **Class-wide exception handling:** A `try-catch (Exception e)` block wraps the core logic within the `while` loop (specifically, the part after checking `hasNextInt` and reading the choice). This provides a central point to catch any unexpected runtime exceptions that might occur during command processing, preventing the application from crashing abruptly. A more specific `catch (InputMismatchException e)` is also included for clarity, although the `hasNextInt` check mitigates its primary cause in this specific structure.
 * 
 * **Best Practices Demonstrated:**
 * *   **Encapsulation:** Fields in `Task` and `ProductionLineManager` are private, with controlled access via public methods/getters.
 * *   **Meaningful Names:** Variables (`pendingTasksQueue`, `completedTasksList`, `nextTaskId`), methods (`addTask`, `processNextTask`, `getPendingTasks`), and enum values are clearly named.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** Checks for valid menu input and non-empty task descriptions are included.
 * *   **Error Handling:** Specific error conditions (empty queue, invalid input, invalid description) are checked and reported using `System.err`. A general `try-catch` handles unexpected exceptions.
 * *   **Clean Code Structure:** The code is divided into logical classes, and the `main` method focuses on user interaction and flow control.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating core object-oriented principles and robust error handling.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING, // Could be used, but for this problem, tasks go directly from PENDING to COMPLETED
    COMPLETED
}

// Represents a single task in the production line
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter (Internal use by manager) ---
    // Protected to allow manager in the same package to modify status if needed,
    // or could be private and manager calls a specific method like markCompleted()
    // Let's make it package-private for simplicity or add a specific method.
    // A specific method is better encapsulation.
    void markCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status=" + status + '}';
    }
}

// Manages the collection of tasks on the production line
class ProductionLineManager {
    // Use LinkedList as it implements Queue and is efficient for add/remove from ends
    private Queue<Task> pendingTasksQueue;
    // Use ArrayList for completed tasks as we'll primarily list them
    private List<Task> completedTasksList;
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new ProductionLineManager.
     */
    public ProductionLineManager() {
        this.pendingTasksQueue = new LinkedList<>();
        this.completedTasksList = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return The newly created Task object.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task addTask(String description) {
        // Task constructor already validates description
        Task newTask = new Task(nextTaskId++, description);
        pendingTasksQueue.offer(newTask); // offer is preferred over add for queues
        return newTask;
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list and updates its status.
     * @return The processed Task object, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasksQueue.poll(); // poll retrieves and removes the head of the queue
        if (taskToProcess != null) {
            taskToProcess.markCompleted(); // Update status
            completedTasksList.add(taskToProcess); // Add to completed list
            return taskToProcess;
        }
        return null; // No task was available
    }

    /**
     * Gets a list of all pending tasks.
     * Returns a new list to prevent external modification of the internal queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to maintain encapsulation
        return new ArrayList<>(pendingTasksQueue);
    }

    /**
     * Gets a list of all completed tasks.
     * Returns the internal list reference (read-only access assumed by caller).
     * A defensive copy could be returned here too, but for simplicity,
     * returning the reference is acceptable if documentation notes it.
     * Let's return a copy for better encapsulation.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return new ArrayList<>(completedTasksList);
    }

    /**
     * Checks if the pending queue is empty.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return pendingTasksQueue.isEmpty();
    }
}

// Main application class for the Production Line Task Management System
public class ProductionLineApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLineManager manager = new ProductionLineManager();
        boolean running = true;

        System.out.println("--- Production Line Task Management System ---");

        // Class-wide exception handling loop
        while (running) {
            try {
                printMenu();
                System.out.print("Enter your choice: ");

                // Input validation for the command
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Go to the next iteration of the loop
                }

                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                // Use switch for command handling
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            Task addedTask = manager.addTask(description);
                            System.out.println("Task added: " + addedTask);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        System.out.println("Processing next task...");
                        Task processedTask = manager.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processed: " + processedTask);
                        } else {
                            System.err.println("No tasks in the pending queue to process.");
                        }
                        break;

                    case 3: // View Pending Tasks
                        List<Task> pending = manager.getPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // View Completed Tasks
                        List<Task> completed = manager.getCompletedTasks();
                        System.out.println("--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Production Line System.");
                        break;

                    default: // Invalid command number
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // This specific catch is technically covered by the hasNextInt check,
                // but included for robustness if the check were removed or logic changed.
                // The general Exception catch below is the primary "class-wide" handler.
                 System.err.println("Input error: Please enter a valid number for the choice.");
                 scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // General catch-all for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Production Line Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
