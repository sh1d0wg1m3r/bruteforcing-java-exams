/*
 * Exam Question #374
 * Generated on: 2025-05-11 23:01:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simple console-based simulator for a manufacturing production line. The system should manage tasks that arrive, wait in a queue, are processed one by one, and then moved to a list of completed tasks.
 * 
 * Your program must allow a user to interact with the production line through a menu-driven interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique task ID (integer), a description (String), and an estimated time to complete (integer, in minutes). Include a constructor and public getter methods for these fields. Override the `toString()` method to provide a user-friendly representation of a task.
 * 
 * 2.  **Production Line Management:** Create a `ProductionLine` class that manages the tasks.
 *     *   It must use a `java.util.Queue` (e.g., `LinkedList`) to hold tasks that are waiting to be processed.
 *     *   It must use a `java.util.List` (implemented by `java.util.ArrayList`) to hold tasks that have been completed.
 *     *   Include methods:
 *         *   `addTask(String description, int estimatedTimeMinutes)`: Adds a new task to the waiting queue. Assign a unique ID (starting from 1 and incrementing). Perform input validation: description cannot be empty, estimated time must be positive. Report validation errors using `System.err`.
 *         *   `processNextTask()`: Removes the next task from the waiting queue and adds it to the completed list. If the queue is empty, it should indicate that no task was processed.
 *         *   `getWaitingTasks()`: Returns the queue of waiting tasks.
 *         *   `getCompletedTasks()`: Returns the list of completed tasks.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `ProductionLineApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Implement a menu loop that presents the following options using `System.out`:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Waiting Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement based on the user's menu choice to control the program flow.
 *     *   For options 3 and 4, iterate through the respective collection and print each task using `System.out`. Clearly indicate if a list/queue is empty.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch unexpected errors. Print a generic error message and stack trace to `System.err` in case of such errors.
 *     *   Handle `InputMismatchException` specifically when reading integer input (menu choice, estimated time). Print an error message to `System.err` and recover gracefully, prompting the user again. Ensure the `Scanner`'s state is cleared after an invalid input to prevent infinite loops.
 *     *   Handle cases where the user tries to process a task when the waiting queue is empty, providing a user-friendly message using `System.out`.
 *     *   Use `System.err` exclusively for error messages and `System.out` for all normal program output (menu, prompts, task details, success messages).
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for public methods).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested operations, printing output and errors to the correct streams (`System.out` or `System.err`). The output for viewing tasks should clearly list the tasks with their details.
 * 
 * Example interaction:
 * 
 * ```
 * --- Production Line Simulator ---
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Build Component A
 * Enter estimated time (minutes): 15
 * Added: Task #1: 'Build Component A' (15 min)
 * 
 * Menu:
 * ...
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Test Module B
 * Enter estimated time (minutes): 20
 * Added: Task #2: 'Test Module B' (20 min)
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. Task #1: 'Build Component A' (15 min)
 * 2. Task #2: 'Test Module B' (20 min)
 * Total waiting: 2
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * --- Process Next Task ---
 * Processed: Task #1: 'Build Component A' (15 min)
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. Task #2: 'Test Module B' (20 min)
 * Total waiting: 1
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task #1: 'Build Component A' (15 min)
 * Total completed: 1
 * 
 * Menu:
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Menu:
 * ...
 * Enter your choice: 99
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * Exiting Production Line Simulator. Goodbye!
 * Scanner closed.
 * ```
 * 
 * This task assesses your ability to use fundamental Java data structures (`Queue`, `List`, `ArrayList`), control flow (`switch`), input/output (`Scanner`, `System.out`, `System.err`), object-oriented principles (encapsulation, classes), and robust error handling (`try-catch`, input validation).
 *
 * EXPLANATION:
 * This solution implements the Production Line Simulator as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** A simple POJO (`Plain Old Java Object`) representing a task with `taskId`, `description`, and `estimatedTimeMinutes`. It uses private fields and public getters for encapsulation. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **ProductionLine Class:** This class encapsulates the core logic of the simulation.
 *     *   `waitingTasks`: A `Queue<Task>` is used (specifically `LinkedList`, which implements `Queue`). The `Queue` interface is ideal here because tasks are processed in the order they are added (First-In, First-Out - FIFO), which is the natural behavior of a production line queue. `offer()` is used to add tasks, and `poll()` is used to remove and retrieve the next task, handling the empty case gracefully by returning `null`.
 *     *   `completedTasks`: A `List<Task>` is used (specifically `ArrayList`, which implements `List`). The `List` interface is suitable for storing completed tasks where order of completion might matter, and easy iteration or access by index is possible (though iteration is primarily used here). Using `List` as the interface type for the `ArrayList` instance is a good practice.
 *     *   `nextTaskId`: A simple counter to assign unique IDs to tasks.
 *     *   `addTask`: Handles adding tasks after performing basic input validation (non-empty description, positive time). Validation errors are reported using `System.err`.
 *     *   `processNextTask`: Implements the core processing logic, moving a task from the `waitingTasks` queue to the `completedTasks` list. It correctly uses `poll()` to handle the case where the queue is empty.
 *     *   `getWaitingTasks` and `getCompletedTasks`: Provide access to the underlying collections for viewing.
 * 
 * 3.  **ProductionLineApp Class:** This is the main application class that provides the user interface.
 *     *   `Scanner`: Used to read input from the console.
 *     *   **Class-wide Exception Handling (`try-catch`):** The `run()` method has a `try-catch(Exception e)` block wrapped around the main `while(true)` loop. This provides a top-level safety net to catch any unexpected runtime exceptions that might occur within the application logic, printing an error to `System.err` and preventing the program from crashing abruptly.
 *     *   **Input Validation & Specific Exception Handling (`InputMismatchException`):** A nested `try-catch(InputMismatchException e)` block is used specifically when reading the menu choice (`scanner.nextInt()`). This allows the program to gracefully handle cases where the user enters non-numeric input for the menu option. An error message is printed to `System.err`, and `scanner.nextLine()` is called within the `catch` block to consume the invalid input from the scanner buffer, which is crucial to prevent an infinite loop where `scanner.nextInt()` repeatedly fails on the same invalid input. The `continue` statement then restarts the `while` loop, showing the menu again. A similar `try-catch` is used when reading the estimated time for adding a task.
 *     *   `switch` statement: Used effectively to dispatch control based on the user's numeric menu choice.
 *     *   `System.out` and `System.err`: Used correctly throughout the application, with `System.out` for normal output (menu, prompts, task lists, success messages) and `System.err` exclusively for error messages (validation failures, invalid input, unexpected exceptions).
 *     *   Viewing Tasks: The `viewWaitingTasks` and `viewCompletedTasks` methods iterate through the `Queue` and `List` respectively to print the details of each task using the `Task` class's `toString()` method. They also check if the collections are empty before attempting to iterate.
 *     *   `Scanner` Closing: The `finally` block in the `run()` method ensures that the `Scanner` resource is closed when the `try` block is exited, whether normally (by returning from the loop) or due to an exception.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario. It demonstrates good object-oriented design with encapsulation and uses appropriate data structures for the task requirements. The error handling strategy, combining specific input validation/exception handling with a general top-level catch, makes the application more robust against various types of errors.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task in the production line.
 */
class Task {
    private int taskId;
    private String description;
    private int estimatedTimeMinutes;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param estimatedTimeMinutes The estimated time to complete the task in minutes.
     */
    public Task(int taskId, String description, int estimatedTimeMinutes) {
        this.taskId = taskId;
        this.description = description;
        this.estimatedTimeMinutes = estimatedTimeMinutes;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getEstimatedTimeMinutes() {
        return estimatedTimeMinutes;
    }

    /**
     * Provides a user-friendly string representation of the task.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return String.format("Task #%d: '%s' (%d min)", taskId, description, estimatedTimeMinutes);
    }
}

/**
 * Manages the production line, holding waiting and completed tasks.
 */
class ProductionLine {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> waitingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList
    private int nextTaskId; // Counter for assigning unique task IDs

    /**
     * Constructs a new ProductionLine, initializing task collections.
     */
    public ProductionLine() {
        this.waitingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the waiting queue.
     * Performs validation on the input parameters.
     * @param description The task description.
     * @param estimatedTimeMinutes The estimated time to complete the task in minutes.
     * @return true if the task was added successfully, false otherwise (due to validation failure).
     */
    public boolean addTask(String description, int estimatedTimeMinutes) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        if (estimatedTimeMinutes <= 0) {
            System.err.println("Error: Estimated time must be positive.");
            return false;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), estimatedTimeMinutes);
        waitingTasks.offer(newTask); // Use offer for queues; returns true/false
        System.out.println("Added: " + newTask);
        return true;
    }

    /**
     * Processes the next task from the waiting queue.
     * Removes the head of the queue and adds it to the completed tasks list.
     * @return The task that was processed, or null if the waiting queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = waitingTasks.poll(); // poll returns null if queue is empty
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            return taskToProcess;
        } else {
            // Queue was empty, nothing to process
            return null;
        }
    }

    /**
     * Returns the queue of tasks currently waiting to be processed.
     * @return The Queue of waiting tasks.
     */
    public Queue<Task> getWaitingTasks() {
        return waitingTasks;
    }

    /**
     * Returns the list of tasks that have been completed.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Production Line Simulator.
 * Handles user interaction, menu display, and delegates operations to ProductionLine.
 * Includes class-wide exception handling.
 */
public class ProductionLineApp {

    private ProductionLine productionLine;
    private Scanner scanner;

    /**
     * Constructs the ProductionLineApp, initializing the ProductionLine and Scanner.
     */
    public ProductionLineApp() {
        productionLine = new ProductionLine();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling using try-catch.
     */
    public void run() {
        System.out.println("--- Production Line Simulator ---");

        // Class-wide exception handling wrapping the main application loop
        try {
            while (true) {
                printMenu();
                int choice = -1;

                // Specific try-catch for reading the menu choice to handle non-integer input
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input (e.g., "abc") to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show the menu again
                }

                // Use switch statement for handling menu options
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processTask();
                        break;
                    case 3:
                        viewWaitingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Production Line Simulator. Goodbye!");
                        return; // Exit the run method, terminating the application loop
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print the stack trace to standard error
        } finally {
            // Ensure the scanner resource is closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Handles the "Add New Task" menu option.
     * Prompts user for task details and calls ProductionLine.addTask().
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the whole line for description

        int estimatedTime = -1;
        try {
            System.out.print("Enter estimated time (minutes): ");
            estimatedTime = scanner.nextInt();
            scanner.nextLine(); // Consume the newline

            // Delegate adding task and validation to ProductionLine
            productionLine.addTask(description, estimatedTime);

        } catch (InputMismatchException e) {
            System.err.println("Invalid input for estimated time. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
        }
        // Validation logic for description and time value is inside ProductionLine.addTask()
    }

    /**
     * Handles the "Process Next Task" menu option.
     * Calls ProductionLine.processNextTask() and reports the result.
     */
    private void processTask() {
        System.out.println("--- Process Next Task ---");
        Task processedTask = productionLine.processNextTask();
        if (processedTask != null) {
            System.out.println("Processed: " + processedTask);
        } else {
            System.out.println("No tasks waiting to be processed.");
        }
    }

    /**
     * Handles the "View Waiting Tasks" menu option.
     * Retrieves and prints the tasks in the waiting queue.
     */
    private void viewWaitingTasks() {
        System.out.println("--- Waiting Tasks ---");
        Queue<Task> waiting = productionLine.getWaitingTasks();
        if (waiting.isEmpty()) {
            System.out.println("No tasks currently waiting.");
        } else {
            // Iterate over the queue elements for display
            int count = 1;
            for (Task task : waiting) {
                System.out.println(count++ + ". " + task);
            }
            System.out.println("Total waiting: " + waiting.size());
        }
    }

    /**
     * Handles the "View Completed Tasks" menu option.
     * Retrieves and prints the tasks in the completed list.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        List<Task> completed = productionLine.getCompletedTasks();
        if (completed.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate over the list elements for display
            int count = 1;
            for (Task task : completed) {
                System.out.println(count++ + ". " + task);
            }
            System.out.println("Total completed: " + completed.size());
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineApp app = new ProductionLineApp();
        app.run(); // Start the application
    }
}
