/*
 * Exam Question #158
 * Generated on: 2025-05-11 22:23:21
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam - Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified hospital appointment management system. The system should manage patients waiting to see a doctor and keep a record of patients who have already been seen. It should be a command-line application interacting with the user via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Representation:** Create a `Patient` class with private fields for `name` (String) and appropriate public methods (getters, constructor) following encapsulation principles.
 * 2.  **Appointment Manager:** Create a class named `AppointmentManager` that will handle the core logic.
 *     *   It must use a `Queue` to store patients currently waiting.
 *     *   It must use an `ArrayList` to store patients who have been seen. The field should be declared using the `List` interface type.
 *     *   It must have methods to:
 *         *   `addPatient(String name)`: Adds a new patient to the waiting queue. Perform input validation: patient name cannot be null or empty.
 *         *   `callNextPatient()`: Removes the patient at the front of the waiting queue and adds them to the list of seen patients. If the queue is empty, report an error.
 *         *   `listWaitingPatients()`: Prints the names of all patients currently in the waiting queue, in order.
 *         *   `listSeenPatients()`: Prints the names of all patients who have been seen.
 * 3.  **User Interface (Main Application):**
 *     *   The `main` method in a separate class (e.g., `HospitalApp`) will drive the application.
 *     *   It should use a `Scanner` to read user commands from the console.
 *     *   The system should present a menu of options to the user:
 *         1.  Add Patient
 *         2.  Call Next Patient
 *         3.  List Waiting Patients
 *         4.  List Seen Patients
 *         5.  Exit
 *     *   A `switch` statement must be used to process the user's command.
 *     *   Use a loop to keep the application running until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential issues, such as invalid input (non-integer command) or errors within the `AppointmentManager` (e.g., trying to call a patient when the queue is empty).
 *     *   Use `System.err.println()` to output error messages (e.g., invalid command, queue empty, invalid patient name).
 *     *   Use `System.out.println()` for all normal output (menu, confirmations, lists).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, accept integer commands, and perform the requested actions, printing relevant messages or lists to `System.out` and errors to `System.err`.
 * 
 * Example interaction:
 * 
 * ```
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 1
 * Enter patient name: Alice
 * Patient 'Alice' added to the waiting queue.
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 1
 * Enter patient name: Bob
 * Patient 'Bob' added to the waiting queue.
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 3
 * Waiting Patients:
 * - Alice
 * - Bob
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 2
 * Calling next patient... Patient 'Alice' is now being seen.
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 3
 * Waiting Patients:
 * - Bob
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 4
 * Seen Patients:
 * - Alice
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 6
 * Error: Invalid command. Please enter a number between 1 and 5.
 * 
 * --- Appointment Management System ---
 * 1. Add Patient
 * 2. Call Next Patient
 * 3. List Waiting Patients
 * 4. List Seen Patients
 * 5. Exit
 * Enter command: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * **Constraints:**
 * 
 * *   Adhere strictly to all listed requirements and use *all* specified Java components.
 * *   The solution should be a single Java program with appropriate classes.
 * *   Focus on clarity, correctness, and demonstrating the required concepts.
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * The provided solution implements a basic hospital appointment management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Patient` Class:** This class represents a patient with a `name` field. It follows encapsulation by making the field `private` and providing a public `getName()` getter. The constructor includes basic input validation for the name, throwing an `IllegalArgumentException` if the name is null or empty. This demonstrates how validation can be integrated into object creation.
 * 
 * 2.  **`AppointmentManager` Class:** This is the core logic class.
 *     *   It uses a `Queue<Patient>` named `waitingQueue`, implemented by `LinkedList`, to manage patients waiting in line. The `Queue` interface is ideal here because we need FIFO (First-In, First-Out) behavior: the first patient added is the first one to be called.
 *     *   It uses a `List<Patient>` named `seenPatients`, implemented by `ArrayList`, to store patients who have finished their appointments. Using the `List` interface type for the field (`List<Patient> seenPatients = new ArrayList<>();`) demonstrates polymorphism and good practice, as the specific implementation (`ArrayList`) can be changed later if needed without affecting the rest of the code that interacts with `seenPatients` only through the `List` interface.
 *     *   `addPatient()`: Creates a new `Patient` object (which validates the name) and adds it to the `waitingQueue` using `offer()`.
 *     *   `callNextPatient()`: Uses `poll()` to retrieve and remove the head of the `waitingQueue`. `poll()` is used because it returns `null` if the queue is empty, which allows for graceful handling of the "queue empty" scenario without throwing an exception. If a patient is retrieved, they are added to the `seenPatients` list. If `poll()` returns `null`, an error message is printed to `System.err`.
 *     *   `listWaitingPatients()` and `listSeenPatients()`: These methods iterate through their respective collections (`Queue` and `List`) and print the patient names using `System.out.println()`. Iterating over the `Queue` does not remove elements, preserving the waiting order.
 * 
 * 3.  **`HospitalApp` Class (Main Application):**
 *     *   The `main` method contains the application's entry point and main loop.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   The `printMenu()` method displays the available commands using `System.out.println()`.
 *     *   A `while` loop keeps the application running until `running` is set to `false` (when the user chooses option 5).
 *     *   **Class-wide Exception Handling:** The core logic within the `while` loop (reading command, processing) is wrapped in a `try-catch` block.
 *         *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input for the command, printing an error to `System.err` and consuming the invalid input from the scanner (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   A generic `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing an error to `System.err` and the stack trace for debugging.
 *     *   A nested `try-catch` is used around `manager.addPatient(patientName)` within the `case 1` block to catch the `IllegalArgumentException` thrown by the `Patient` constructor if the name is invalid. This demonstrates handling specific business logic exceptions.
 *     *   A `switch` statement is used to direct the flow of execution based on the integer command entered by the user. Each case calls the appropriate method in the `AppointmentManager` or handles the exit command. The `default` case handles invalid integer commands, printing an error to `System.err`.
 *     *   `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls for reading the patient name.
 *     *   The `scanner` is closed when the application exits.
 * 
 * This solution effectively uses all required components in a practical scenario, demonstrates proper object-oriented design with encapsulation, handles user input and potential errors gracefully using `Scanner`, `Switch`, `try-catch`, `System.out`, and `System.err`, and follows best coding practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient object.
     * @param name The name of the patient. Must not be null or empty.
     */
    public Patient(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Manages the patient appointments, including waiting queue and seen patients.
 */
class AppointmentManager {
    private Queue<Patient> waitingQueue;
    private List<Patient> seenPatients;

    /**
     * Constructs a new AppointmentManager.
     */
    public AppointmentManager() {
        // Use LinkedList as an implementation of Queue
        this.waitingQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.seenPatients = new ArrayList<>();
    }

    /**
     * Adds a new patient to the waiting queue.
     * @param name The name of the patient.
     * @throws IllegalArgumentException if the patient name is invalid.
     */
    public void addPatient(String name) {
        Patient newPatient = new Patient(name); // Patient constructor handles validation
        waitingQueue.offer(newPatient); // offer() is preferred over add() as it doesn't throw exception on capacity restricted queues
        System.out.println("Patient '" + newPatient.getName() + "' added to the waiting queue.");
    }

    /**
     * Calls the next patient from the waiting queue to be seen.
     * Moves the patient from the waiting queue to the seen patients list.
     * Reports an error if the waiting queue is empty.
     */
    public void callNextPatient() {
        Patient nextPatient = waitingQueue.poll(); // poll() returns null if queue is empty

        if (nextPatient != null) {
            seenPatients.add(nextPatient);
            System.out.println("Calling next patient... Patient '" + nextPatient.getName() + "' is now being seen.");
        } else {
            System.err.println("Error: The waiting queue is currently empty.");
        }
    }

    /**
     * Lists all patients currently in the waiting queue.
     */
    public void listWaitingPatients() {
        System.out.println("\n--- Waiting Patients ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("No patients currently waiting.");
        } else {
            // Iterate through the queue without removing elements
            waitingQueue.forEach(patient -> System.out.println("- " + patient.getName()));
        }
        System.out.println("-------------------------");
    }

    /**
     * Lists all patients who have already been seen.
     */
    public void listSeenPatients() {
        System.out.println("\n--- Seen Patients ---");
        if (seenPatients.isEmpty()) {
            System.out.println("No patients have been seen yet.");
        } else {
            // Iterate through the list
            seenPatients.forEach(patient -> System.out.println("- " + patient.getName()));
        }
        System.out.println("-------------------------");
    }
}

/**
 * Main application class for the Hospital Appointment System.
 * Handles user interaction and coordinates with the AppointmentManager.
 */
public class HospitalApp {

    private static void printMenu() {
        System.out.println("\n--- Appointment Management System ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Call Next Patient");
        System.out.println("3. List Waiting Patients");
        System.out.println("4. List Seen Patients");
        System.out.println("5. Exit");
        System.out.print("Enter command: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        AppointmentManager manager = new AppointmentManager();
        boolean running = true;

        while (running) {
            printMenu();

            // Class-wide exception handling for the main loop
            try {
                int command = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                switch (command) {
                    case 1:
                        System.out.print("Enter patient name: ");
                        String patientName = scanner.nextLine();
                        try {
                            manager.addPatient(patientName);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;
                    case 2:
                        manager.callNextPatient();
                        break;
                    case 3:
                        manager.listWaitingPatients();
                        break;
                    case 4:
                        manager.listSeenPatients();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
        }

        scanner.close(); // Close the scanner when the application exits
    }
}
