/*
 * Exam Question #301
 * Generated on: 2025-05-11 22:51:47
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Build Pipeline Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line simulator for a software build pipeline. The pipeline manages build jobs that are processed sequentially. Jobs are added to a queue, processed one by one, and then moved to either a list of completed jobs or a list of failed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this build pipeline. Your program must meet the following specifications:
 * 
 * 1.  **Job Representation:** Create a class `BuildJob` to represent a single build job. It should have private fields for:
 *     *   `id` (an integer)
 *     *   `description` (a String)
 *     *   `status` (a String, e.g., "Pending", "Running", "Completed", "Failed")
 *     *   Include a constructor and appropriate public getter methods. Add a method `setStatus(String status)` to update the job's status. Override `toString()` to provide a useful representation of the job.
 * 
 * 2.  **Pipeline Management:** Create a class `BuildPipeline` to manage the jobs. It must contain:
 *     *   A `java.util.Queue<BuildJob>` to hold jobs that are waiting to be processed (pending jobs).
 *     *   A `java.util.List<BuildJob>` to hold jobs that have successfully completed. Use `java.util.ArrayList` as the concrete implementation.
 *     *   A `java.util.List<BuildJob>` to hold jobs that have failed. Use `java.util.ArrayList` as the concrete implementation.
 *     *   Include a public method `addJob(BuildJob job)` that adds a job to the pending queue.
 *     *   Include a public method `runNextJob()` that:
 *         *   Retrieves and removes the next job from the pending queue.
 *         *   If the queue is empty, it should indicate an error (e.g., return false or throw a custom exception, but for this exam, printing an error and returning false is sufficient).
 *         *   Simulates running the job (e.g., prints a message).
 *         *   Asks the user if the job succeeded or failed (e.g., 'Y' for success, 'N' for failure).
 *         *   Updates the job's status accordingly ("Completed" or "Failed").
 *         *   Adds the processed job to the corresponding list (`completedJobs` or `failedJobs`).
 *         *   Returns `true` if a job was processed, `false` otherwise.
 *     *   Include a public method `viewStatus()` that prints the contents of the pending queue, completed jobs list, and failed jobs list. Clearly label each section.
 * 
 * 3.  **User Interface:** Implement a `main` method in a separate class (e.g., `PipelineSimulator`) that provides a command-line interface using `java.util.Scanner`. The interface should support the following commands:
 *     *   `A`: Add a new job. Prompts for job ID (integer) and description (String).
 *     *   `R`: Run the next job in the queue.
 *     *   `V`: View pipeline status.
 *     *   `E`: Exit the program.
 * 
 * 4.  **Control Flow and Error Handling:**
 *     *   Use a `switch` statement in the `main` method to handle the user commands.
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and pipeline status.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, invalid input for job details, attempting to run a job when the queue is empty).
 *     *   Implement **class-wide exception handling** in the `main` method's main loop using a `try-catch(Exception e)` block to catch unexpected errors during command processing. Catch specific exceptions like `java.util.InputMismatchException` or handle them within the case blocks where they occur, but ensure the main loop has a general catch.
 *     *   Include input validation for job ID (must be a positive integer) and description (must not be empty).
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation in the `BuildJob` and `BuildPipeline` classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and respond to user commands. Examples:
 * 
 * *   Adding a job: Prompts for ID and description, confirms job added.
 * *   Running a job: Prints "Running job...", asks for success/failure, prints outcome, moves job. If queue empty, prints error to `System.err`.
 * *   Viewing status: Prints "--- Pipeline Status ---", lists Pending Jobs, Completed Jobs, Failed Jobs.
 * *   Invalid command: Prints error to `System.err`.
 * *   Invalid input (e.g., non-integer ID): Prints error to `System.err`.
 * *   General unhandled exception: Prints error message from catch block to `System.err`.
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a Build Pipeline Simulator meeting all the specified requirements.
 * 
 * 1.  **BuildJob Class:**
 *     *   Represents a single job with `id`, `description`, and `status`.
 *     *   Private fields enforce encapsulation.
 *     *   Public getters provide controlled access to data.
 *     *   The constructor includes input validation for ID (positive) and description (not empty), throwing `IllegalArgumentException` for invalid input.
 *     *   `setStatus` allows updating the job's state.
 *     *   `toString` provides a convenient way to print job details.
 * 
 * 2.  **BuildPipeline Class:**
 *     *   Uses `java.util.Queue<BuildJob>` (`LinkedList` implementation) for `pendingJobs`. The `Queue` interface is ideal for managing items in a FIFO (First-In, First-Out) order, representing jobs waiting to be processed.
 *     *   Uses `java.util.List<BuildJob>` (`ArrayList` implementation) for `completedJobs` and `failedJobs`. The `List` interface and `ArrayList` provide dynamic arrays suitable for storing processed jobs where order or index access might be useful (though not explicitly used here, `List` is the required interface type).
 *     *   `addJob`: Uses `queue.offer()` to add a job to the end of the `pendingJobs` queue.
 *     *   `runNextJob`: Uses `queue.poll()` to retrieve and remove the job at the front of the `pendingJobs` queue. It checks if the result is `null` to handle an empty queue. It then simulates processing, interacts with the user via the provided `Scanner` to determine the outcome, updates the job status, and adds the job to the appropriate `List` (`completedJobs` or `failedJobs`).
 *     *   `viewStatus`: Iterates through all three collections (`Queue` and two `List`s) and prints their contents using the `BuildJob`'s `toString()` method. It uses `forEach` loops for concise iteration. Note that iterating a `Queue` directly (as done for printing pending jobs status) does not remove elements.
 * 
 * 3.  **PipelineSimulator Class (`main` method):**
 *     *   Initializes `Scanner` and `BuildPipeline`.
 *     *   Enters a `while` loop to keep the simulation running until the user chooses to exit.
 *     *   Presents a menu using `System.out`.
 *     *   Reads user command using `scanner.nextLine()`. Reading the entire line and then parsing (like for the job ID) helps avoid common issues with `Scanner`'s next methods mixing line endings.
 *     *   A `switch` statement handles the different command inputs (`A`, `R`, `V`, `E`, and default for invalid input).
 *     *   **Input Validation:**
 *         *   For 'A' (Add Job), it attempts to parse the job ID from a string using `Integer.parseInt()`, catching `NumberFormatException` if the input is not a valid integer. The `BuildJob` constructor handles validation for positive ID and non-empty description. Error messages go to `System.err`.
 *         *   For 'R' (Run Job), the `runNextJob` method handles the case of an empty queue and validates the 'Y/N' user input loop, printing errors to `System.err`.
 *     *   **Error Handling:**
 *         *   Specific error conditions (invalid command, invalid input format, empty queue) are caught and reported to `System.err`.
 *         *   A **class-wide `try-catch(Exception e)` block** wraps the main command processing loop (`while(running)`). This demonstrates catching any unexpected exceptions that might occur during the program's execution within that loop, providing a fallback error reporting mechanism to `System.err` and printing a stack trace for debugging.
 *     *   `System.out` is used for normal program flow, menus, prompts, and status reports.
 *     *   `System.err` is used exclusively for error messages.
 *     *   A `finally` block ensures the `Scanner` resource is closed when the program exits or an unhandled exception occurs.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` with class-wide handling, while following best practices for encapsulation, naming, commenting, and input validation in a practical simulation context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single build job in the pipeline.
 */
class BuildJob {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Running", "Completed", "Failed"

    /**
     * Constructs a new BuildJob.
     * @param id The unique identifier for the job.
     * @param description A description of the job.
     * @throws IllegalArgumentException if id is not positive or description is null/empty.
     */
    public BuildJob(int id, String description) {
        if (id <= 0) {
            throw new IllegalArgumentException("Job ID must be a positive integer.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the job.
     * @param status The new status string.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the BuildJob.
     * @return A formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return String.format("Job #%d: %s [%s]", id, description, status);
    }
}

/**
 * Manages the build pipeline, including pending, completed, and failed jobs.
 */
class BuildPipeline {
    // Using LinkedList for Queue as it supports Queue interface
    private Queue<BuildJob> pendingJobs;
    // Using ArrayList for List implementation
    private List<BuildJob> completedJobs;
    private List<BuildJob> failedJobs;

    /**
     * Constructs a new BuildPipeline, initializing job collections.
     */
    public BuildPipeline() {
        this.pendingJobs = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.failedJobs = new ArrayList<>();   // ArrayList implements List
    }

    /**
     * Adds a job to the pending queue.
     * @param job The BuildJob to add.
     */
    public void addJob(BuildJob job) {
        pendingJobs.offer(job); // offer is preferred over add for queues
        System.out.println("Job added to pipeline: " + job.getDescription());
    }

    /**
     * Runs the next job from the pending queue.
     * Simulates processing and moves the job to completed or failed list based on user input.
     * @param scanner Scanner object to get user input for job outcome.
     * @return true if a job was processed, false if the queue was empty.
     */
    public boolean runNextJob(Scanner scanner) {
        BuildJob currentJob = pendingJobs.poll(); // Retrieves and removes the head of this queue

        if (currentJob == null) {
            System.err.println("Error: No pending jobs in the pipeline.");
            return false;
        }

        System.out.println("--- Running Job ---");
        System.out.println(currentJob); // Print job details
        currentJob.setStatus("Running"); // Update status (simulated)

        // Simulate outcome based on user input
        String outcomeInput = "";
        while (!outcomeInput.equals("Y") && !outcomeInput.equals("N")) {
            System.out.print("Did job #" + currentJob.getId() + " succeed? (Y/N): ");
            outcomeInput = scanner.nextLine().trim().toUpperCase();
            if (!outcomeInput.equals("Y") && !outcomeInput.equals("N")) {
                System.err.println("Invalid input. Please enter 'Y' for success or 'N' for failure.");
            }
        }

        if (outcomeInput.equals("Y")) {
            currentJob.setStatus("Completed");
            completedJobs.add(currentJob); // Add to completed list
            System.out.println("Job #" + currentJob.getId() + " marked as Completed.");
        } else { // outcomeInput must be "N"
            currentJob.setStatus("Failed");
            failedJobs.add(currentJob); // Add to failed list
            System.out.println("Job #" + currentJob.getId() + " marked as Failed.");
        }

        System.out.println("-------------------");
        return true;
    }

    /**
     * Displays the current status of the pipeline: pending, completed, and failed jobs.
     */
    public void viewStatus() {
        System.out.println("\n--- Pipeline Status ---");

        System.out.println("Pending Jobs (" + pendingJobs.size() + "):");
        if (pendingJobs.isEmpty()) {
            System.out.println("  None");
        } else {
            // Iterate through the queue without removing elements
            pendingJobs.forEach(job -> System.out.println("  " + job));
        }

        System.out.println("\nCompleted Jobs (" + completedJobs.size() + "):");
        if (completedJobs.isEmpty()) {
            System.out.println("  None");
        } else {
            // Iterate through the list
            completedJobs.forEach(job -> System.out.println("  " + job));
        }

        System.out.println("\nFailed Jobs (" + failedJobs.size() + "):");
        if (failedJobs.isEmpty()) {
            System.out.println("  None");
        } else {
            // Iterate through the list
            failedJobs.forEach(job -> System.out.println("  " + job));
        }

        System.out.println("-----------------------");
    }
}

/**
 * Main class to run the Pipeline Simulator.
 * Provides a command-line interface.
 */
public class PipelineSimulator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BuildPipeline pipeline = new BuildPipeline();
        boolean running = true;

        System.out.println("--- Build Pipeline Simulator ---");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toUpperCase();

                // Use switch statement for command handling
                switch (command) {
                    case "A": // Add Job
                        try {
                            System.out.print("Enter Job ID (integer > 0): ");
                            int jobId = Integer.parseInt(scanner.nextLine()); // Read as line then parse to avoid scanner issues
                            System.out.print("Enter Job Description: ");
                            String jobDescription = scanner.nextLine();

                            // Input validation handled by BuildJob constructor
                            BuildJob newJob = new BuildJob(jobId, jobDescription);
                            pipeline.addJob(newJob);
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid input for Job ID. Please enter a valid integer.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding job: " + e.getMessage());
                        } catch (Exception e) { // Catch any other unexpected issues during job creation/add
                             System.err.println("An unexpected error occurred while adding a job: " + e.getMessage());
                        }
                        break;

                    case "R": // Run Next Job
                        // runNextJob handles its own errors (empty queue, invalid Y/N input)
                        pipeline.runNextJob(scanner);
                        break;

                    case "V": // View Status
                        pipeline.viewStatus();
                        break;

                    case "E": // Exit
                        System.out.println("Exiting simulator.");
                        running = false;
                        break;

                    default: // Invalid Command
                        System.err.println("Error: Invalid command. Please use A, R, V, or E.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between commands
            }
        } catch (Exception e) {
            // Class-wide catch for any unhandled exceptions during the main loop execution
            System.err.println("An unexpected fatal error occurred:");
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed. Program finished.");
        }
    }

    /**
     * Prints the available menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Available Commands:");
        System.out.println(" A - Add Job");
        System.out.println(" R - Run Next Job");
        System.out.println(" V - View Status");
        System.out.println(" E - Exit");
    }
}
