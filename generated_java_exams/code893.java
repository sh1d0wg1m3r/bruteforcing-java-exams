/*
 * Exam Question #893
 * Generated on: 2025-05-12 16:56:04
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a small team. The system should maintain a backlog of tasks waiting to be done and a list of tasks that have been completed. Users will interact with the system by entering commands.
 * 
 * **Requirements:**
 * 
 * Develop a Java application that meets the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with a unique ID and a description.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the task collections.
 *     *   Maintain a **backlog** of tasks using a `java.util.Queue`. Tasks should typically be processed from the front of the queue.
 *     *   Maintain a list of **completed tasks** using a `java.util.List` (implemented with `java.util.ArrayList`).
 *     *   Provide methods to:
 *         *   Add a new task to the backlog.
 *         *   Retrieve a list view of the current backlog (for display and selection).
 *         *   Retrieve a list view of the completed tasks.
 *         *   Mark a specific task from the backlog as completed. This involves removing it from the backlog queue and adding it to the completed tasks list.
 * 3.  **User Interface:** Create a main application class (e.g., `TaskManagerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user commands and task details from the console.
 *     *   Present a menu of options to the user: Add Task, View Backlog, View Completed, Complete Task, Exit.
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Display normal output (menu, task lists, success messages) using `System.out`.
 *     *   Display error messages (invalid input, empty lists, task not found) using `System.err`.
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for user commands (e.g., ensure a number is entered, ensure the number is within the valid range).
 *     *   Implement validation when adding a task (e.g., task description should not be empty).
 *     *   Implement validation when completing a task (e.g., ensure the backlog is not empty, ensure the entered task index is valid).
 *     *   Use `try-catch` blocks for exception handling. Include a **class-wide** `try-catch` block in the main application loop to catch unexpected errors, and specific `try-catch` blocks where appropriate (e.g., for number parsing).
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resource cleanup (close the `Scanner`).
 * 
 * **Task Completion Logic:**
 * 
 * When the user chooses to "Complete Task", the application should:
 * 1. Display the current backlog tasks with a numbered list (1-based index).
 * 2. Prompt the user to enter the number of the task they want to complete.
 * 3. Validate the user's input (must be a number, must be a valid index in the displayed list).
 * 4. If the input is valid, remove the corresponding task from the *backlog queue* and add it to the *completed tasks list*.
 * 5. Report success or failure using `System.out` or `System.err`.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Task Management System ---
 * Select an option:
 * 1. Add Task
 * 2. View Backlog
 * 3. View Completed Tasks
 * 4. Complete Task from Backlog
 * 5. Exit
 * Enter command: 1
 * Enter task description: Implement login feature
 * Task added to backlog: Implement login feature
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 1
 * Enter task description: Write unit tests
 * Task added to backlog: Write unit tests
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 2
 * --- Backlog Tasks ---
 * 1. ID: 1, Description: Implement login feature
 * 2. ID: 2, Description: Write unit tests
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 4
 * --- Select Task to Complete ---
 * 1. ID: 1, Description: Implement login feature
 * 2. ID: 2, Description: Write unit tests
 * Enter the number of the task to complete: 1
 * Task completed: Implement login feature
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 2
 * --- Backlog Tasks ---
 * 1. ID: 2, Description: Write unit tests
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 3
 * --- Completed Tasks ---
 * ID: 1, Description: Implement login feature
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 4
 * --- Select Task to Complete ---
 * 1. ID: 2, Description: Write unit tests
 * Enter the number of the task to complete: 5
 * Error: Invalid task number. Please enter a number between 1 and 1.
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 4
 * Cannot complete task: Backlog is empty.
 * 
 * Select an option:
 * ... menu ...
 * Enter command: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Select an option:
 * ... menu ...
 * Enter command: 5
 * Exiting system...
 * Scanner closed.
 * Task Management System terminated.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Task Class:**
 *     *   A simple class representing a task with a unique integer `id` and a `description`.
 *     *   `nextId` is a static field to ensure each task gets a unique ID upon creation.
 *     *   The constructor validates that the description is not empty, throwing an `IllegalArgumentException` if it is.
 *     *   `equals()` and `hashCode()` are overridden based on the unique `id`. This is crucial because we retrieve a `Task` object from a `List` view of the queue and then need to `remove(Object)` that specific object from the `Queue`. The `Queue.remove(Object)` method relies on `equals()` to find the correct element.
 * 
 * 2.  **TaskManager Class:**
 *     *   Uses `java.util.Queue<Task>` (`LinkedList` implementation) for the `backlog`. `offer()` is used for adding tasks, which is the standard non-blocking way to add to a queue.
 *     *   Uses `java.util.List<Task>` (`ArrayList` implementation) for `completedTasks`. `ArrayList` provides dynamic resizing and efficient element addition/retrieval by index.
 *     *   `addTask()` creates a `Task` object (handling potential `IllegalArgumentException`) and adds it to the `backlog` queue using `offer()`.
 *     *   `getBacklogView()` and `getCompletedTasks()` return *new* `ArrayList` instances containing the current elements of the respective collections. This provides a snapshot or view for external use (like display) without exposing the internal `Queue` or `List` directly, adhering to encapsulation and preventing external modification of the core collections' state or structure.
 *     *   `completeTask(Task taskToComplete)` is the key method demonstrating interaction between the list view and the queue. It attempts to remove the specific `Task` object from the `backlog` queue using `backlog.remove(taskToComplete)`. If successful, the task is added to the `completedTasks` list. The `boolean` return value of `remove()` is used to determine success and provide appropriate feedback.
 * 
 * 3.  **TaskManagerApp Class:**
 *     *   Contains the `main` method, which is the application entry point.
 *     *   Initializes `TaskManager` and `Scanner`.
 *     *   The main logic resides in the `run()` method, which contains the primary application loop (`while(running)`).
 *     *   **Class-wide Exception Handling:** The `run()` method is wrapped in a `try-catch(Exception e)` block. This serves as a broad catch-all for any unexpected exceptions that might occur during the program's execution within the loop, preventing the application from crashing abruptly and demonstrating the requirement for class-wide handling. A `finally` block ensures the `Scanner` is closed.
 *     *   User input is read using `scanner.nextLine()`.
 *     *   **Input Validation and Error Handling:**
 *         *   A `try-catch(NumberFormatException)` block is used specifically when parsing the user's command input and the task index input to handle non-numeric entries, printing an error to `System.err`.
 *         *   `if` statements are used to validate the range of the command number and the task index number, printing errors to `System.err`.
 *         *   The `TaskManager`'s `addTask` method handles validation of the task description internally.
 *         *   Checks are made before attempting to complete a task if the backlog is empty.
 *     *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the validated integer command entered by the user.
 *     *   `System.out` is used for standard messages like the menu, prompts, listing tasks, and success messages.
 *     *   `System.err` is used exclusively for reporting errors or invalid actions.
 *     *   The `completeTask()` method in `TaskManagerApp` orchestrates the task completion by first getting the list view, displaying it with 1-based indices, getting and validating the user's index input, retrieving the corresponding `Task` object from the list view, and then passing that object to the `TaskManager`'s `completeTask()` method. This pattern effectively allows indexed selection from a queue structure by using an intermediate list representation.
 *     *   The `exit()` method simply sets the `running` flag to `false`, causing the main loop to terminate gracefully.
 *     *   The `Scanner` is closed in the `finally` block of the main `try-catch` in `run()`, ensuring resource cleanup.
 * 
 * The solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, well-structured application that follows best practices like encapsulation, meaningful names, and comprehensive error handling. The task completion logic, which involves presenting a queue's contents as an indexed list for selection and then removing the selected object from the queue, adds a suitable level of complexity for an advanced exam question.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Potentially needed for Queue operations, though offer/poll are safer

/**
 * Represents a single task with a unique ID and description.
 */
class Task {
    private static int nextId = 1;
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Cannot be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = nextId++;
        this.description = description.trim();
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including ID and description.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description;
    }

    /**
     * Compares this task to another object for equality based on ID.
     * Necessary for removing a specific task object from the Queue.
     * @param o The object to compare with.
     * @return true if the objects are equal (same ID), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    /**
     * Returns a hash code value for the task based on its ID.
     * Necessary for consistency with equals when storing in collections.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

/**
 * Manages the collection of tasks, maintaining a backlog and completed tasks.
 */
class TaskManager {
    // Use Queue for the backlog (FIFO behavior often desired)
    private Queue<Task> backlog;
    // Use List for completed tasks (ordered storage)
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.backlog = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // ArrayList is a common List implementation
    }

    /**
     * Adds a new task to the backlog queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            // offer is the preferred way to add to a Queue
            if (backlog.offer(newTask)) {
                System.out.println("Task added to backlog: \"" + newTask.getDescription() + "\"");
            } else {
                 // This case is rare with LinkedList unless memory is exhausted
                 System.err.println("Failed to add task to backlog.");
            }
        } catch (IllegalArgumentException e) {
            // Catch validation error from Task constructor
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Provides a list view of the current backlog tasks.
     * Useful for displaying tasks with indices for selection.
     * @return An ArrayList containing tasks from the backlog (a snapshot).
     */
    public List<Task> getBacklogView() {
        // Return a new ArrayList containing elements from the queue
        // This provides a list representation without modifying the queue structure
        return new ArrayList<>(backlog);
    }

    /**
     * Provides a list view of the completed tasks.
     * @return An ArrayList containing completed tasks (a snapshot).
     */
    public List<Task> getCompletedTasks() {
        // Return a new ArrayList containing elements from the completed list
        return new ArrayList<>(completedTasks); // Return a copy
    }

    /**
     * Marks a specific task as completed.
     * Removes the task from the backlog queue and adds it to the completed tasks list.
     * @param taskToComplete The Task object to complete. This object should
     *                       typically come from the list returned by getBacklogView().
     * @return true if the task was found in the backlog and successfully completed, false otherwise.
     */
    public boolean completeTask(Task taskToComplete) {
        if (taskToComplete == null) {
            System.err.println("Error: Cannot complete a null task.");
            return false;
        }

        // Queue.remove(Object) iterates through the queue to find and remove the object
        boolean removed = backlog.remove(taskToComplete);

        if (removed) {
            completedTasks.add(taskToComplete);
            System.out.println("Task completed: \"" + taskToComplete.getDescription() + "\"");
            return true;
        } else {
            // This means the task object passed was not found in the current backlog
            System.err.println("Error: Task not found in backlog or already completed.");
            return false;
        }
    }

    /**
     * Checks if the backlog is empty.
     * @return true if the backlog has no tasks, false otherwise.
     */
    public boolean isBacklogEmpty() {
        return backlog.isEmpty();
    }

    /**
     * Checks if the completed tasks list is empty.
     * @return true if no tasks are completed, false otherwise.
     */
    public boolean isCompletedEmpty() {
        return completedTasks.isEmpty();
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction, command processing, and overall application flow.
 */
public class TaskManagerApp {

    private TaskManager taskManager;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs the TaskManagerApp, initializing the TaskManager and Scanner.
     */
    public TaskManagerApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
        running = true; // Flag to control the main loop
    }

    /**
     * Starts the main application loop, handling user commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");
                String input = scanner.nextLine();

                int command = -1;
                // Use try-catch for parsing the command input
                try {
                    command = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement to process the command
                switch (command) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewBacklog();
                        break;
                    case 3:
                        viewCompleted();
                        break;
                    case 4:
                        completeTask();
                        break;
                    case 5:
                        exit();
                        break;
                    default:
                        // Handle commands outside the valid range
                        System.err.println("Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability after each command
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure resources are closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
            System.out.println("Task Management System terminated.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add Task");
        System.out.println("2. View Backlog");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Complete Task from Backlog");
        System.out.println("5. Exit");
    }

    /**
     * Handles the "Add Task" command flow.
     * Prompts user for description and calls TaskManager to add the task.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
        taskManager.addTask(description); // TaskManager handles validation and output
    }

    /**
     * Handles the "View Backlog" command flow.
     * Retrieves and displays tasks currently in the backlog.
     */
    private void viewBacklog() {
        List<Task> backlogView = taskManager.getBacklogView(); // Get list view from TaskManager
        if (backlogView.isEmpty()) {
            System.out.println("Backlog is empty.");
        } else {
            System.out.println("--- Backlog Tasks ---");
            // Display tasks with 1-based index for user readability and selection
            for (int i = 0; i < backlogView.size(); i++) {
                System.out.println((i + 1) + ". " + backlogView.get(i));
            }
        }
    }

    /**
     * Handles the "View Completed Tasks" command flow.
     * Retrieves and displays tasks that have been completed.
     */
    private void viewCompleted() {
        List<Task> completed = taskManager.getCompletedTasks(); // Get completed tasks list
        if (completed.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
            for (Task task : completed) {
                System.out.println(task);
            }
        }
    }

    /**
     * Handles the "Complete Task" command flow.
     * Displays backlog, prompts for index, validates input, and calls TaskManager to complete the task.
     */
    private void completeTask() {
        List<Task> backlogView = taskManager.getBacklogView(); // Get list view for display/selection
        if (backlogView.isEmpty()) {
            System.err.println("Cannot complete task: Backlog is empty.");
            return; // Exit the method if backlog is empty
        }

        System.out.println("--- Select Task to Complete ---");
        // Display backlog with 1-based indices again for user selection
        for (int i = 0; i < backlogView.size(); i++) {
            System.out.println((i + 1) + ". " + backlogView.get(i));
        }

        System.out.print("Enter the number of the task to complete: ");
        String input = scanner.nextLine();

        int taskIndex = -1;
        // Use try-catch for parsing the task index input
        try {
            taskIndex = Integer.parseInt(input);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a number.");
            return; // Exit the method if input is not a number
        }

        // Validate the 1-based index entered by the user
        if (taskIndex < 1 || taskIndex > backlogView.size()) {
            System.err.println("Invalid task number. Please enter a number between 1 and " + backlogView.size() + ".");
            return; // Exit the method if index is out of range
        }

        // Get the Task object from the list view using the 0-based index
        Task taskToComplete = backlogView.get(taskIndex - 1);

        // Call TaskManager to perform the completion logic (remove from queue, add to list)
        taskManager.completeTask(taskToComplete);
    }

    /**
     * Handles the "Exit" command. Sets the running flag to false to terminate the loop.
     */
    private void exit() {
        running = false;
        System.out.println("Exiting system...");
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run(); // Start the application
    }
}
