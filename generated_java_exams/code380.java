/*
 * Exam Question #380
 * Generated on: 2025-05-11 23:02:50
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Helpdesk Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line Helpdesk Ticket Management System. The system should allow users to add new support tickets, view tickets currently awaiting processing, process the next ticket in line, and view tickets that have been completed.
 * 
 * The system should simulate a first-in, first-out (FIFO) processing order for pending tickets. Completed tickets should be stored for review.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Represent pending support tickets using a `java.util.Queue`. Tickets should be processed in the order they were added.
 *     *   Represent completed support tickets using a `java.util.List` implementation (specifically `java.util.ArrayList`).
 * 
 * 2.  **SupportTicket Class:**
 *     *   Create a `SupportTicket` class with the following private fields:
 *         *   `id` (an integer, unique identifier)
 *         *   `description` (a String, the problem description)
 *     *   Provide a constructor to initialize these fields.
 *     *   Include public getter methods for `id` and `description`.
 *     *   Override the `toString()` method to provide a clear string representation of a ticket (e.g., "Ticket #ID: Description").
 * 
 * 3.  **HelpdeskSystem Class:**
 *     *   Create a `HelpdeskSystem` class to manage the tickets.
 *     *   It should contain the `Queue` for pending tickets and the `List` for completed tickets as private fields.
 *     *   Maintain a private counter for generating unique ticket IDs.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `SupportTicket` with the next available ID and the given description, and adds it to the pending queue. Print a confirmation message using `System.out`.
 *         *   `viewPendingTickets()`: Prints a list of all tickets currently in the pending queue to `System.out`. If the queue is empty, print an appropriate message.
 *         *   `processNextTicket()`: Removes the next ticket from the pending queue (FIFO). If a ticket is successfully removed, add it to the completed list and print a success message using `System.out`. If the pending queue is empty, print an error message to `System.err`. Return the processed ticket or null if the queue was empty.
 *         *   `viewCompletedTickets()`: Prints a list of all tickets in the completed list to `System.out`. If the list is empty, print an appropriate message.
 *     *   Include a method (e.g., `runSystem()`) to handle the main application loop and user interaction.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Ticket
 *         2.  View Pending Tickets
 *         3.  Process Next Ticket
 *         4.  View Completed Tickets
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should continue running until the user chooses to exit.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input operations that might throw exceptions (e.g., `NumberFormatException` when reading the menu choice).
 *     *   Handle the case where the user enters an invalid menu option using the `default` case of the `switch` statement. Print an error message to `System.err`.
 *     *   Handle the case where the user attempts to process a ticket when the pending queue is empty, printing an error message to `System.err` as specified in requirement 3.
 *     *   Use `System.out` for all standard output (menu, confirmations, lists).
 *     *   Use `System.err` for all error messages (invalid input, empty queue processing attempt).
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes/methods) and documentation.
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying the menu, prompting for input, and printing results or errors. A sample interaction might look like this:
 * 
 * ```
 * Helpdesk Ticket Management System
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer not working in room 101
 * Ticket #1 added.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Software installation failed on PC-LAB-05
 * Ticket #2 added.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket #1: Printer not working in room 101
 * Ticket #2: Software installation failed on PC-LAB-05
 * -----------------------
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 3
 * Processing ticket #1: Printer not working in room 101
 * Ticket #1 processed.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 3
 * Processing ticket #2: Software installation failed on PC-LAB-05
 * Ticket #2 processed.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 3
 * Error: No pending tickets to process.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tickets ---
 * Ticket #1: Printer not working in room 101
 * Ticket #2: Software installation failed on PC-LAB-05
 * -------------------------
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Menu:
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 5
 * Exiting Helpdesk System.
 * ```
 * 
 * Your code should be a single file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Helpdesk Ticket Management System as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * 1.  **`SupportTicket` Class:** This simple class encapsulates the data for a single ticket (`id` and `description`) with private fields and public getters, adhering to encapsulation principles. The `toString()` method provides a convenient way to display ticket information.
 * 
 * 2.  **`HelpdeskSystem` Class:** This is the core class managing the system's state and operations.
 *     *   **`Queue<SupportTicket> pendingTickets`**: A `LinkedList` is used here because it implements the `Queue` interface and provides efficient FIFO operations (`offer` to add, `poll` to remove from the head). This directly fulfills the requirement for a queue for pending tickets.
 *     *   **`List<SupportTicket> completedTickets`**: An `ArrayList` is used here, declared with the `List` interface type (`List<SupportTicket>`). This fulfills the requirement for an `ArrayList` accessed via the `List` interface to store completed tickets. `ArrayList` is suitable because completed tickets are simply added and listed, and random access or dynamic resizing is handled efficiently.
 *     *   **`nextTicketId`**: A private integer counter ensures each ticket gets a unique, sequential ID.
 *     *   **Methods (`addTicket`, `viewPendingTickets`, `processNextTicket`, `viewCompletedTickets`)**: These methods implement the core logic, interacting with the queues and lists. They follow best practices by being public methods accessing private data. `processNextTicket` specifically uses `poll()` to get the next item in FIFO order and handles the case where the queue is empty by returning `null`.
 * 
 * 3.  **User Interface (`runSystem` method):**
 *     *   A `Scanner` object reads input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `printMenu()` method displays the options using `System.out`.
 *     *   User input is read using `scanner.nextLine()`.
 *     *   **`try-catch (NumberFormatException e)`**: This inner `try-catch` block specifically handles the case where the user enters input that cannot be parsed as an integer (e.g., text instead of a number) when prompted for the menu choice. An error message is printed to `System.err`.
 *     *   **`switch (choice)`**: This statement directs the program flow based on the valid integer input received from the user, executing the appropriate method (`addTicket`, `viewPendingTickets`, etc.).
 *     *   The `default` case of the `switch` handles valid integer inputs that do not correspond to any menu option, printing an error message to `System.err`.
 *     *   Input validation is also included for the ticket description to prevent adding empty tickets.
 * 
 * 4.  **Error Handling and Output:**
 *     *   **`System.out`**: Used for displaying the menu, confirmations (`Ticket #X added`), lists of tickets, and successful processing messages.
 *     *   **`System.err`**: Used specifically for error conditions: invalid menu input (both `NumberFormatException` and out-of-range numbers) and attempting to process a ticket when the pending queue is empty.
 *     *   **`try-catch (Exception e)`**: The outer `try-catch` block wraps the entire `while` loop in `runSystem()`. This provides a general safety net to catch any unexpected runtime exceptions that might occur within the main application logic, printing the error details to `System.err`. This demonstrates class-wide exception handling.
 *     *   Error conditions within specific methods (like `processNextTicket` checking for an empty queue) also use `System.err`.
 * 
 * 5.  **Resource Management:** The `Scanner` object is created before the loop and closed in a `finally` block. This ensures the resource is released even if an exception occurs, demonstrating proper resource cleanup.
 * 
 * 6.  **Best Practices:** The code adheres to the requested best practices: private fields and public methods (`SupportTicket`, `HelpdeskSystem`), descriptive names (`pendingTickets`, `processNextTicket`, `runSystem`), and Javadoc comments explaining the purpose of classes and methods.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, showcasing advanced understanding of data structures, object-oriented design, user interaction, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single support ticket in the helpdesk system.
 */
class SupportTicket {
    private int id;
    private String description;

    /**
     * Constructs a new SupportTicket.
     * @param id The unique identifier for the ticket.
     * @param description The description of the problem.
     */
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the ticket ID.
     * @return The ticket ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the ticket description.
     * @return The ticket description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string for the ticket.
     */
    @Override
    public String toString() {
        return "Ticket #" + id + ": " + description;
    }
}

/**
 * Manages the collection of pending and completed support tickets.
 */
public class HelpdeskSystem { // Main class for the exam
    private Queue<SupportTicket> pendingTickets;
    private List<SupportTicket> completedTickets; // Using List interface type
    private int nextTicketId;

    /**
     * Constructs a new HelpdeskSystem, initializing the ticket queues and lists.
     */
    public HelpdeskSystem() {
        // Use LinkedList as a Queue implementation for FIFO
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as a List implementation for completed tickets
        this.completedTickets = new ArrayList<>();
        this.nextTicketId = 1;
    }

    /**
     * Adds a new support ticket to the pending queue.
     * @param description The description of the problem for the new ticket.
     */
    public void addTicket(String description) {
        SupportTicket newTicket = new SupportTicket(nextTicketId++, description);
        pendingTickets.offer(newTicket); // offer is preferred over add for queues
        System.out.println("Ticket #" + newTicket.getId() + " added.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            System.out.println("--- Pending Tickets ---");
            // Iterate through the queue without removing elements
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Processes the next ticket in the pending queue (FIFO).
     * Moves the processed ticket to the completed list.
     * @return The processed SupportTicket, or null if the queue was empty.
     */
    public SupportTicket processNextTicket() {
        SupportTicket ticketToProcess = pendingTickets.poll(); // Retrieves and removes the head of the queue
        if (ticketToProcess == null) {
            System.err.println("Error: No pending tickets to process.");
            return null;
        } else {
            System.out.println("Processing " + ticketToProcess);
            completedTickets.add(ticketToProcess);
            System.out.println("Ticket #" + ticketToProcess.getId() + " processed.");
            return ticketToProcess;
        }
    }

    /**
     * Displays all tickets that have been completed.
     */
    public void viewCompletedTickets() {
        if (completedTickets.isEmpty()) {
            System.out.println("No completed tickets.");
        } else {
            System.out.println("--- Completed Tickets ---");
            for (SupportTicket ticket : completedTickets) {
                System.out.println(ticket);
            }
            System.out.println("-------------------------");
        }
    }

    /**
     * Runs the main application loop for user interaction.
     */
    public void runSystem() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Helpdesk Ticket Management System");

        // Class-wide try-catch for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Inner try-catch for input validation
                try {
                    int choice = Integer.parseInt(scanner.nextLine());

                    // Switch statement for flow control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Description cannot be empty.");
                            } else {
                                addTicket(description.trim());
                            }
                            break;
                        case 2:
                            viewPendingTickets();
                            break;
                        case 3:
                            processNextTicket(); // Method handles its own System.out/err
                            break;
                        case 4:
                            viewCompletedTickets();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Helpdesk System.");
                            break;
                        default:
                            // Invalid menu choice handled by default case
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Input validation for non-integer input
                    System.err.println("Error: Invalid input. Please enter a number.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Process Next Ticket");
        System.out.println("4. View Completed Tickets");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HelpdeskSystem system = new HelpdeskSystem();
        system.runSystem();
    }
}
