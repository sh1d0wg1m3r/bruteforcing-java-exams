/*
 * Exam Question #123
 * Generated on: 2025-05-11 22:18:04
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Technical Support Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple console-based technical support ticket management system. The system should allow users to add new support tickets, process the next pending ticket, view pending tickets, view processed tickets, and find a ticket by its ID.
 * 
 * The system should manage tickets using a queue for pending requests and a list for storing processed tickets. It must handle user interaction via the console, provide a menu of options, and manage potential errors gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a class `SupportTicket` to represent a support ticket. It should have:
 *     *   A unique integer ID.
 *     *   A description of the issue (String).
 *     *   A status (String, e.g., "Pending", "Processing", "Resolved").
 *     *   Appropriate constructors, getters, and a method to update the status. Use proper encapsulation.
 * 
 * 2.  **Ticket Management Logic:** Create a class `TicketManager` responsible for managing the tickets. It must use:
 *     *   `java.util.Queue<SupportTicket>` to store tickets that are waiting to be processed (pending tickets).
 *     *   `java.util.List<SupportTicket>` (implemented using `java.util.ArrayList`) to store tickets that have been processed.
 *     *   Methods for:
 *         *   `addTicket(String description)`: Creates a new `SupportTicket` with a unique ID, sets its status to "Pending", and adds it to the pending queue.
 *         *   `processNextTicket()`: Removes the next ticket from the pending queue, updates its status to "Processing", then to "Resolved", and moves it to the processed list. If the queue is empty, it should indicate an error.
 *         *   `viewPendingTickets()`: Displays all tickets currently in the pending queue.
 *         *   `viewProcessedTickets()`: Displays all tickets in the processed list.
 *         *   `findTicketById(int id)`: Searches both the pending queue and the processed list for a ticket with the given ID and displays its details. If not found, it should indicate an error.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `SupportSystem`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user (Add Ticket, Process Next, View Pending, View Processed, Find Ticket, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation results (like ticket details).
 *     *   Use `System.err` specifically for displaying error messages (e.g., invalid input, empty queue, ticket not found).
 * 
 * 4.  **Error Handling:**
 *     *   Implement robust input validation (e.g., handle non-integer input for menu choices or ticket IDs, handle empty description for new tickets).
 *     *   Use `try-catch` blocks to handle potential exceptions (e.g., `NumberFormatException` for input parsing, or custom error conditions like attempting to process a ticket when the queue is empty). The main loop should use a class-wide or method-wide `try-catch` structure to manage potential issues.
 *     *   Provide clear error messages to the user via `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (Javadocs are a plus).
 *     *   Ensure the `Scanner` is closed properly.
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and display results or errors.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets
 * 5. Find Ticket by ID
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket 1 added successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Network connection unstable.
 * Ticket 2 added successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: My printer is not working., Status: Pending
 * Ticket ID: 2, Description: Network connection unstable., Status: Pending
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket 1: My printer is not working.
 * Ticket 1 resolved and moved to processed list.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 2, Description: Network connection unstable., Status: Pending
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Tickets ---
 * Ticket ID: 1, Description: My printer is not working., Status: Resolved
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Enter ticket ID to find: 2
 * Ticket Found: Ticket ID: 2, Description: Network connection unstable., Status: Pending
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Enter ticket ID to find: 99
 * Error: Ticket with ID 99 not found.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket 2: Network connection unstable.
 * Ticket 2 resolved and moved to processed list.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Support Ticket System.
 * ```
 * 
 * This task requires integrating several core Java concepts and data structures in a practical application, demonstrating understanding of object-oriented design, data structures, user interaction, and error handling.
 *
 * EXPLANATION:
 * This solution implements a simple technical support ticket management system demonstrating the required Java concepts.
 * 
 * 1.  **Scenario:** The system simulates managing support tickets, where new tickets arrive and are placed in a queue for processing in order. Processed tickets are archived in a separate list.
 * 2.  **`SupportTicket` Class:** This class serves as the data model for a ticket, holding its ID, description, and status. It uses `private` fields and `public` getters/setters for encapsulation. The `toString()` method provides a convenient way to display ticket information.
 * 3.  **`TicketManager` Class:** This class encapsulates the core logic of the system.
 *     *   `private Queue<SupportTicket> pendingTickets;`: A `Queue` (implemented here using `LinkedList`) is used to store tickets awaiting processing. The `Queue` interface is crucial here as it enforces FIFO (First-In, First-Out) behavior, which is typical for a support queue. `offer()` is used to add to the tail, and `poll()` is used to remove from the head.
 *     *   `private List<SupportTicket> processedTickets;`: A `List` (implemented using `ArrayList`) is used to store tickets after they have been processed. `ArrayList` provides efficient random access, although for this simple use case, iteration is the primary operation.
 *     *   `private int nextTicketId;`: Manages the assignment of unique IDs to new tickets.
 *     *   Methods like `addTicket`, `processNextTicket`, `getPendingTickets`, `getProcessedTickets`, and `findTicketById` implement the system's functionality, interacting with the `Queue` and `List`.
 * 4.  **`SupportSystem` Class (Main):** This class handles the user interface and overall control flow.
 *     *   `private static Scanner scanner;`: A `Scanner` is used to read input from the console (`System.in`). It's declared `static` and closed in the `finally` block or after the main loop finishes to release system resources.
 *     *   `private static TicketManager manager;`: An instance of the `TicketManager` is created to perform the actual ticket operations.
 *     *   **Main Loop:** A `while(running)` loop keeps the system active until the user chooses to exit.
 *     *   **Menu and `switch`:** The `printMenu()` method displays options, and a `switch` statement on the user's integer input directs execution to the appropriate action method (`addTicket`, `processNextTicket`, etc.).
 *     *   **`try-catch` for Exception Handling:** A large `try-catch` block wraps the core logic within the main loop.
 *         *   `NumberFormatException`: Catches errors if the user enters non-integer input for the menu choice or ticket ID, printing an error to `System.err`.
 *         *   `IllegalArgumentException`: Catches errors related to invalid method arguments, such as an empty ticket description, which is thrown by `TicketManager::addTicket`.
 *         *   `Exception`: A general catch block is included as a safety net for any other unexpected runtime errors, printing a generic message to `System.err`.
 *     *   **`System.out` vs. `System.err`:** `System.out.println()` is used for normal program output: displaying the menu, prompts, success messages, and ticket details. `System.err.println()` is used exclusively for displaying error messages, making them distinct (often appearing in red in many console environments).
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** `SupportTicket` fields are private, accessed via public methods. `TicketManager` manages its internal data structures privately.
 *     *   **Meaningful Names:** Variables (`pendingTickets`, `nextTicketId`), methods (`processNextTicket`, `findTicketById`), and classes (`SupportTicket`, `TicketManager`, `SupportSystem`) have clear, descriptive names.
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, and key logic sections.
 *     *   **Input Validation:** The `addTicket` method checks for empty descriptions, and the main `try-catch` handles `NumberFormatException` for integer inputs. `processNextTicket` handles the case of an empty queue. `findTicketById` explicitly checks if the returned ticket is null.
 *     *   **Error Handling:** Clear messages are provided via `System.err` for specific error conditions (invalid input, empty queue, not found, empty description).
 *     *   **Clean Structure:** The code is divided into logical classes (`SupportTicket` for data, `TicketManager` for logic, `SupportSystem` for UI), promoting modularity.
 * 
 * This solution effectively uses `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical context, demonstrating key Java programming skills and adherence to best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator;

// Represents a single support ticket
class SupportTicket {
    private int ticketId;
    private String description;
    private String status;

    // Constructor
    public SupportTicket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return "Ticket ID: " + ticketId + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the queue of pending tickets and list of processed tickets
class TicketManager {
    private Queue<SupportTicket> pendingTickets;
    private List<SupportTicket> processedTickets;
    private int nextTicketId; // To generate unique IDs

    // Constructor
    public TicketManager() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.processedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1;
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the issue.
     * @return The newly created ticket ID.
     */
    public int addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        SupportTicket newTicket = new SupportTicket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer is preferred over add for queues
        return newTicket.getTicketId();
    }

    /**
     * Processes the next ticket in the pending queue.
     * @return The processed ticket, or null if no tickets were pending.
     */
    public SupportTicket processNextTicket() {
        SupportTicket ticketToProcess = pendingTickets.poll(); // poll retrieves and removes head, returns null if empty
        if (ticketToProcess != null) {
            ticketToProcess.setStatus("Processing");
            System.out.println("Processing ticket " + ticketToProcess.getTicketId() + ": " + ticketToProcess.getDescription());
            // Simulate work...
            ticketToProcess.setStatus("Resolved");
            processedTickets.add(ticketToProcess);
            return ticketToProcess;
        }
        return null; // Indicate no ticket was processed
    }

    /**
     * Returns the list of pending tickets.
     * @return A List view of pending tickets.
     */
    public List<SupportTicket> getPendingTickets() {
        // Return a new list or an unmodifiable view to prevent external modification
        // For this exam, returning the internal queue's contents is acceptable.
        // A robust solution might return new ArrayList<>(pendingTickets);
        return new ArrayList<>(pendingTickets); // Return a copy
    }

    /**
     * Returns the list of processed tickets.
     * @return The List of processed tickets.
     */
    public List<SupportTicket> getProcessedTickets() {
        // Return a new list or an unmodifiable view to prevent external modification
        // A robust solution might return Collections.unmodifiableList(processedTickets);
        return processedTickets; // Returning the direct list for exam simplicity
    }

    /**
     * Finds a ticket by its ID in either pending or processed lists.
     * @param id The ID of the ticket to find.
     * @return The found ticket, or null if not found.
     */
    public SupportTicket findTicketById(int id) {
        // Search pending queue
        for (SupportTicket ticket : pendingTickets) {
            if (ticket.getTicketId() == id) {
                return ticket;
            }
        }
        // Search processed list
        for (SupportTicket ticket : processedTickets) {
            if (ticket.getTicketId() == id) {
                return ticket;
            }
        }
        return null; // Not found
    }
}

// Main class for user interaction
public class SupportSystem {

    private static TicketManager manager = new TicketManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        boolean running = true;

        while (running) {
            printMenu();
            String input = scanner.nextLine();
            int choice = -1;

            try {
                choice = Integer.parseInt(input);

                switch (choice) {
                    case 1:
                        addTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewProcessedTickets();
                        break;
                    case 5:
                        findTicketById();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Support Ticket System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (IllegalArgumentException e) {
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when exiting
    }

    private static void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Find Ticket by ID");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    private static void addTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();
        try {
            int ticketId = manager.addTicket(description);
            System.out.println("Ticket " + ticketId + " added successfully.");
        } catch (IllegalArgumentException e) {
             // This specific validation is handled by TicketManager, re-throwing to main catch
            throw e;
        }
    }

    private static void processNextTicket() {
        SupportTicket processedTicket = manager.processNextTicket();
        if (processedTicket != null) {
            System.out.println("Ticket " + processedTicket.getTicketId() + " resolved and moved to processed list.");
        } else {
            System.err.println("Error: No pending tickets to process.");
        }
    }

    private static void viewPendingTickets() {
        List<SupportTicket> pending = manager.getPendingTickets();
        if (pending.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            System.out.println("--- Pending Tickets ---");
            for (SupportTicket ticket : pending) {
                System.out.println(ticket);
            }
        }
    }

    private static void viewProcessedTickets() {
        List<SupportTicket> processed = manager.getProcessedTickets();
        if (processed.isEmpty()) {
            System.out.println("No processed tickets.");
        } else {
            System.out.println("--- Processed Tickets ---");
            for (SupportTicket ticket : processed) {
                System.out.println(ticket);
            }
        }
    }

    private static void findTicketById() {
        System.out.print("Enter ticket ID to find: ");
        String idInput = scanner.nextLine();
        try {
            int id = Integer.parseInt(idInput);
            SupportTicket ticket = manager.findTicketById(id);
            if (ticket != null) {
                System.out.println("Ticket Found: " + ticket);
            } else {
                System.err.println("Error: Ticket with ID " + id + " not found.");
            }
        } catch (NumberFormatException e) {
             // Re-throw to main catch for consistent error message
            throw new NumberFormatException("Invalid ticket ID format. Please enter a number.");
        }
    }
}
