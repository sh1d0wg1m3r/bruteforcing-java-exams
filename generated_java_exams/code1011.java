/*
 * Exam Question #1011
 * Generated on: 2025-05-12 17:12:28
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Software Engineering Fundamentals - Advanced Java Programming**
 * 
 * **Exam Task: Incident Response Queue System**
 * 
 * You are tasked with developing a simplified Incident Response System for an IT support team. The system should manage incoming incidents, allow analysts to process them, and keep track of resolved incidents.
 * 
 * Your implementation must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incidents that are pending resolution. Incidents should be processed in a First-In, First-Out (FIFO) manner from this queue.
 *     *   Use a `java.util.List` (implemented with `java.util.ArrayList`) to store incidents that have been resolved.
 * 
 * 2.  **Incident Representation:**
 *     *   Create a `class` named `Incident` to represent an IT incident.
 *     *   The `Incident` class must have `private` fields for:
 *         *   `id` (int): A unique identifier for the incident.
 *         *   `description` (String): A brief description of the issue.
 *         *   `severity` (enum `Severity`): The priority level (e.g., HIGH, MEDIUM, LOW).
 *         *   `status` (enum `Status`): The current state (e.g., PENDING, RESOLVED).
 *     *   Implement a constructor to initialize these fields.
 *     *   Provide `public` getter methods for all fields.
 *     *   Include a method (e.g., `markAsResolved()`) to change the status of an incident to `RESOLVED`.
 *     *   Override the `toString()` method to provide a user-friendly representation of an incident.
 *     *   Define the `Severity` and `Status` enums within or accessible by the `Incident` class.
 * 
 * 3.  **System Functionality:**
 *     *   Create a main class, `IncidentResponseSystem`, which contains the `main` method and manages the queues and lists.
 *     *   Implement a menu-driven interface using `java.util.Scanner` for user interaction. The menu should include options for:
 *         *   Add New Incident
 *         *   Process Next Incident
 *         *   View Pending Incidents
 *         *   View Resolved Incidents
 *         *   Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement methods corresponding to each menu option within the `IncidentResponseSystem` class (e.g., `addNewIncident()`, `processNextIncident()`, `viewPending()`, `viewResolved()`).
 * 
 * 4.  **Input and Output:**
 *     *   Read user input using `java.util.Scanner`.
 *     *   Display normal program output (menu, incident details, status messages) using `System.out`.
 *     *   Display error messages (e.g., invalid input, system errors) using `System.err`.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for user choices (e.g., ensuring an integer is entered for the menu, validating severity input).
 *     *   Handle potential runtime errors gracefully, such as trying to process an incident when the queue is empty.
 *     *   Use `try-catch` blocks for exception handling, particularly around input operations and critical system logic. Implement class-wide exception handling where appropriate (e.g., in the main loop).
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic or key sections.
 *     *   Ensure proper encapsulation by keeping data fields private.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform actions based on the input, and display results or errors. Examples:
 * 
 * *   Adding an incident: Prompt for description and severity, confirm addition.
 * *   Processing an incident: Display details of the processed incident and confirm it's moved to resolved, or indicate if the queue is empty.
 * *   Viewing incidents: List pending or resolved incidents with their details, or indicate if the list/queue is empty.
 * *   Invalid input: Display an error message on `System.err` and re-show the menu or prompt again.
 * *   General errors: Catch exceptions and display an error message on `System.err`.
 * 
 * Your solution should be a single Java file containing all necessary classes and logic.
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements the Incident Response Queue System as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * 1.  **`Incident` Class:**
 *     *   Represents a single incident with `private` fields (`id`, `description`, `severity`, `status`) ensuring encapsulation.
 *     *   `Severity` and `Status` are defined as `enum`s, providing type safety and clarity for the limited set of possible values.
 *     *   A constructor initializes the incident, setting the initial status to `PENDING`.
 *     *   `public` getters allow controlled access to the incident's state.
 *     *   `markAsResolved()` is a public method to change the status, demonstrating a controlled state transition.
 *     *   `toString()` is overridden for easy printing of incident details.
 * 
 * 2.  **`IncidentResponseSystem` Class:**
 *     *   This is the main class managing the system's state and logic.
 *     *   It holds the two required data structures:
 *         *   `pendingIncidents`: Declared as `Queue<Incident>` and instantiated as `LinkedList<Incident>`. `LinkedList` is a common implementation of the `Queue` interface in `java.util`. This fulfills the requirement of using `Queue`.
 *         *   `resolvedIncidents`: Declared as `List<Incident>` and instantiated as `ArrayList<Incident>`. This fulfills the requirements of using both the `List` interface and the `ArrayList` implementation.
 *     *   `scanner`: A `Scanner` object is used as a class member for reading user input throughout the `run()` method and helper methods.
 *     *   `incidentCounter`: A `static` counter generates simple unique IDs for incidents.
 * 
 * 3.  **Methods and Functionality:**
 *     *   `addNewIncident()`: Prompts the user for incident details, validates the severity input using a loop and `try-catch` with `Severity.valueOf()`, creates a new `Incident` object, and adds it to the `pendingIncidents` queue using `offer()`.
 *     *   `processNextIncident()`: Uses `poll()` to retrieve and remove the head of the `pendingIncidents` queue. `poll()` is preferred over `remove()` for queues when handling potentially empty queues, as it returns `null` instead of throwing an exception. If an incident is retrieved, its status is updated using `markAsResolved()`, and it's added to the `resolvedIncidents` list. Includes a check for an empty queue.
 *     *   `viewPendingIncidents()` and `viewResolvedIncidents()`: Iterate through the respective data structures and print the details of each incident using the overridden `toString()` method. They also handle the case where the structures are empty.
 *     *   `displayMenu()`: A helper method to print the user menu.
 *     *   `run()`: This is the core execution loop.
 *         *   It contains a `while` loop that continues until the user chooses to exit (option 5).
 *         *   A `try-catch` block wraps the main loop logic. This provides class-wide exception handling, catching any unexpected errors that might occur within the loop iterations.
 *         *   Inside the loop, `displayMenu()` is called, and user input is read using `scanner.nextInt()`.
 *         *   A nested `try-catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *         *   Another `catch (Exception e)` inside the loop handles any other general exceptions that might occur during a specific menu option execution, printing an error to `System.err`.
 *         *   A `switch` statement directs execution based on the valid user choice, calling the appropriate system method.
 *         *   A `finally` block ensures the `Scanner` is closed when the `run` method finishes (either by exiting the loop or due to an uncaught exception), releasing system resources.
 *     *   `main()`: The entry point of the program, creating an instance of `IncidentResponseSystem` and calling its `run()` method.
 * 
 * 4.  **Input/Output and Error Handling:**
 *     *   `Scanner` is used for all user input.
 *     *   `System.out.println()` is used for normal messages, menu display, and incident details.
 *     *   `System.err.println()` is used specifically for displaying error messages, as required.
 *     *   Input validation is performed for the menu choice (`InputMismatchException`) and severity input (`IllegalArgumentException` when using `valueOf` on the enum).
 *     *   Specific logic handles the case of an empty queue when processing (`poll()` returning null).
 *     *   `try-catch` blocks are used for robust error handling, covering potential input errors and general runtime exceptions. The `try-catch` around the main `while` loop in `run()` demonstrates class-wide handling for the primary operational flow.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, demonstrating core programming concepts like encapsulation, data structures, control flow, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Enum for Incident Severity
enum Severity {
    HIGH, MEDIUM, LOW
}

// Enum for Incident Status
enum Status {
    PENDING, RESOLVED
}

// Class to represent an Incident
class Incident {
    private int id;
    private String description;
    private Severity severity;
    private Status status;

    // Constructor
    public Incident(int id, String description, Severity severity) {
        this.id = id;
        this.description = description;
        this.severity = severity;
        this.status = Status.PENDING; // New incidents are always pending
    }

    // Public getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Severity getSeverity() {
        return severity;
    }

    public Status getStatus() {
        return status;
    }

    // Method to mark the incident as resolved
    public void markAsResolved() {
        this.status = Status.RESOLVED;
    }

    // Override toString for user-friendly output
    @Override
    public String toString() {
        return String.format("Incident ID: %d, Description: \"%s\", Severity: %s, Status: %s",
                             id, description, severity, status);
    }
}

// Main class for the Incident Response System
public class IncidentResponseSystem {

    private Queue<Incident> pendingIncidents;
    private List<Incident> resolvedIncidents;
    private Scanner scanner;
    private static int incidentCounter = 0; // To generate unique incident IDs

    // Constructor
    public IncidentResponseSystem() {
        // Use LinkedList as an implementation of Queue
        this.pendingIncidents = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.resolvedIncidents = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Method to add a new incident
    private void addNewIncident() {
        System.out.println("\n--- Add New Incident ---");
        System.out.print("Enter incident description: ");
        String description = scanner.nextLine();

        Severity severity = null;
        boolean validSeverity = false;
        while (!validSeverity) {
            System.out.print("Enter severity (HIGH, MEDIUM, LOW): ");
            String severityInput = scanner.nextLine().trim().toUpperCase();
            try {
                severity = Severity.valueOf(severityInput);
                validSeverity = true;
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid severity. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        // Generate unique ID and create incident
        incidentCounter++;
        Incident newIncident = new Incident(incidentCounter, description, severity);
        pendingIncidents.offer(newIncident); // Use offer to add to the queue

        System.out.println("Incident added successfully. " + newIncident);
    }

    // Method to process the next incident from the queue
    private void processNextIncident() {
        System.out.println("\n--- Process Next Incident ---");
        try {
            // poll() retrieves and removes the head of the queue, returns null if empty
            Incident incidentToProcess = pendingIncidents.poll();

            if (incidentToProcess == null) {
                System.out.println("No pending incidents to process.");
            } else {
                incidentToProcess.markAsResolved();
                resolvedIncidents.add(incidentToProcess); // Add to the resolved list
                System.out.println("Incident processed and moved to resolved: " + incidentToProcess);
            }
        } catch (NoSuchElementException e) {
            // This catch is technically redundant with poll() returning null,
            // but included to show handling potential queue exceptions like remove()
            System.err.println("Error processing incident: Queue is empty.");
        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during incident processing: " + e.getMessage());
            // For debugging, you might want to print the stack trace
            // e.printStackTrace(System.err);
        }
    }

    // Method to view pending incidents
    private void viewPendingIncidents() {
        System.out.println("\n--- Pending Incidents ---");
        if (pendingIncidents.isEmpty()) {
            System.out.println("No pending incidents.");
        } else {
            // Iterate through the queue without removing elements
            for (Incident incident : pendingIncidents) {
                System.out.println(incident);
            }
        }
    }

    // Method to view resolved incidents
    private void viewResolvedIncidents() {
        System.out.println("\n--- Resolved Incidents ---");
        if (resolvedIncidents.isEmpty()) {
            System.out.println("No resolved incidents.");
        } else {
            // Iterate through the list
            for (Incident incident : resolvedIncidents) {
                System.out.println(incident);
            }
        }
    }

    // Method to display the menu
    private void displayMenu() {
        System.out.println("\n--- Incident Response System Menu ---");
        System.out.println("1. Add New Incident");
        System.out.println("2. Process Next Incident");
        System.out.println("3. View Pending Incidents");
        System.out.println("4. View Resolved Incidents");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the system
    public void run() {
        int choice = -1;
        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                displayMenu();
                try {
                    // Read integer choice, handles non-integer input
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control
                    switch (choice) {
                        case 1:
                            addNewIncident();
                            break;
                        case 2:
                            processNextIncident();
                            break;
                        case 3:
                            viewPendingIncidents();
                            break;
                        case 4:
                            viewResolvedIncidents();
                            break;
                        case 5:
                            System.out.println("Exiting Incident Response System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the loop iteration
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optional: for detailed debugging
                }
            }
        } finally {
            // Ensure the scanner is closed when the program exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation
            }
        }
    }

    // Entry point of the program
    public static void main(String[] args) {
        IncidentResponseSystem system = new IncidentResponseSystem();
        system.run();
    }
}
