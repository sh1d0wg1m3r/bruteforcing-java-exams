/*
 * Exam Question #1172
 * Generated on: 2025-05-12 17:34:51
 * Generated by: Account 2
 * 
 * QUESTION:
 * **IT Support Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application to help a small IT support team manage their incoming tasks. The system should allow team members to add new tasks, view tasks currently waiting to be addressed, view tasks that have been completed, and mark the next pending task as completed.
 * 
 * Tasks arrive in a sequential order and should ideally be addressed in that order (First-In, First-Out). Completed tasks can be stored in a simple list for historical review.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `taskId` (an integer, auto-generated sequentially), `description` (String), and `status` (an enum: `PENDING`, `COMPLETED`). Include appropriate public getter methods and a method to update the status.
 * 2.  **Task Management:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue` to store pending tasks. Use a suitable implementation like `LinkedList`.
 *     *   It must use a `java.util.ArrayList` to store completed tasks. Declare the field using the `java.util.List` interface.
 *     *   Implement methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and `PENDING` status and adds it to the pending queue.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed list.
 *         *   `completeNextTask()`: Removes the task at the front of the pending queue, changes its status to `COMPLETED`, and adds it to the completed list. Handle the case where there are no pending tasks.
 * 3.  **User Interface:** Implement a console-based menu in the `TaskManager` class's main execution flow (e.g., within a `run()` method or `main` method). The menu should present options for the operations listed above and an option to exit.
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, empty task description, attempting to complete a task when none are pending, invalid input type).
 *     *   Implement class-wide exception handling within the main application loop (e.g., using a `try-catch` block around the loop or key input operations) to gracefully handle potential issues like `InputMismatchException` from the `Scanner`. Ensure the `Scanner` resource is properly closed.
 * 7.  **Output:** Use `System.out` for displaying the menu, task lists, and success messages.
 * 8.  **Best Practices:** Adhere to good programming practices including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Input validation (e.g., check for empty task description).
 *     *   Clean code structure.
 * 
 * **Expected Output Format:**
 * 
 * The program should display a menu upon starting. Based on user input, it should perform the requested action and print relevant output to `System.out` or error messages to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- IT Support Task Manager ---
 * Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Investigate network issue
 * Task added: Investigate network issue
 * 
 * Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Setup new laptop for user X
 * Task added: Setup new laptop for user X
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Description: "Investigate network issue", Status: PENDING
 * Task ID: 2, Description: "Setup new laptop for user X", Status: PENDING
 * ---------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * Task completed: Investigate network issue
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * Task ID: 2, Description: "Setup new laptop for user X", Status: PENDING
 * ---------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Description: "Investigate network issue", Status: COMPLETED
 * -----------------------
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * Task completed: Setup new laptop for user X
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * Error: No pending tasks to complete.
 * 
 * Menu:
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * You need to provide the complete Java code for this application.
 *
 * EXPLANATION:
 * The provided solution implements a simple IT Support Task Management System, fulfilling all the specified requirements.
 * 
 * 1.  **Task Representation:** The `Task` class encapsulates task details (`taskId`, `description`, `status`) using private fields and provides public getter methods for accessing this information. The `TaskStatus` enum clearly defines the two possible states of a task. A `setStatus` method allows changing the task's state, specifically used when a task is completed. The `toString()` method provides a convenient formatted output for task details.
 * 
 * 2.  **Task Management:** The `TaskManager` class orchestrates the application logic.
 *     *   A `java.util.Queue<Task>` named `pendingTasks` is used, implemented by `java.util.LinkedList`. The Queue's FIFO nature is ideal for representing tasks waiting to be processed in the order they were received. Methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used, which are standard and safe Queue operations.
 *     *   A `java.util.List<Task>` named `completedTasks` is used, instantiated as `java.util.ArrayList`. The `List` interface provides general list operations, while `ArrayList` provides a dynamic array implementation suitable for storing completed tasks where insertion/removal performance isn't as critical as the pending queue.
 *     *   The `nextTaskId` field ensures each new task gets a unique sequential ID.
 *     *   Methods like `addTask`, `viewPendingTasks`, `viewCompletedTasks`, and `completeNextTask` implement the core business logic, interacting with the `pendingTasks` queue and `completedTasks` list.
 * 
 * 3.  **User Interface & Control Flow:** The `run()` method contains the main application loop. It repeatedly displays a menu using `displayMenu()` and reads the user's integer choice using `Scanner.nextInt()`. A `switch` statement is used to direct the program flow based on the user's choice, calling the appropriate `TaskManager` methods. The loop continues until the user chooses option 5 (Exit).
 * 
 * 4.  **Input Handling:** `java.util.Scanner` is used to read both integer choices (`nextInt()`) and string descriptions (`nextLine()`) from the console (`System.in`). Care is taken to consume the leftover newline character after reading an integer using `scanner.nextLine()`.
 * 
 * 5.  **Error Handling:**
 *     *   `System.err.println()` is used for all error messages, clearly distinguishing them from normal application output. This includes validation errors (empty description) and operational errors (no pending tasks to complete, invalid menu choice).
 *     *   Class-wide exception handling is demonstrated in the `run()` method using `try-catch` blocks. An inner `try-catch(InputMismatchException)` specifically handles cases where the user enters non-integer input when prompted for a menu choice, preventing the program from crashing and informing the user. A general `catch(Exception)` is included within the loop's operational block to catch any other unexpected runtime errors during task operations. An outer `try-catch` is used primarily in conjunction with a `finally` block to ensure the `Scanner` resource is closed, which is crucial for resource management.
 * 
 * 6.  **Output:** `System.out.println()` is used for displaying the menu, informative messages (task added, task completed, exiting), and the formatted lists of pending and completed tasks.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are private, with controlled access via public methods.
 *     *   **Meaningful Names:** Class names (`Task`, `TaskManager`), variable names (`pendingTasks`, `completedTasks`, `description`), and method names (`addTask`, `viewPendingTasks`, `completeNextTask`) are descriptive and reflect their purpose.
 *     *   **Comments/Documentation:** Javadoc-style comments are included for classes and methods, explaining their purpose, parameters, and return values where applicable. Inline comments clarify specific code logic.
 *     *   **Input Validation:** The `addTask` method checks if the provided description is null or empty/whitespace, printing an error via `System.err` if invalid. The `switch` statement's `default` case handles integer choices outside the valid range. `InputMismatchException` handling validates the *type* of input.
 *     *   **Clean Code Structure:** The code is organized into logical classes (`Task`, `TaskManager`) and methods, promoting readability and maintainability. The main application logic is contained within the `TaskManager.run()` method, separating it from the `main` entry point which simply creates the manager and starts it.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured application that follows best practices for error handling, input validation, and encapsulation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Enum representing the possible statuses of a Task.
 */
enum TaskStatus {
    PENDING,
    COMPLETED
}

/**
 * Represents a single task in the IT support system.
 */
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a given ID and description.
     * Initially, the status is set to PENDING.
     * @param taskId The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---

    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---

    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: \"" + description + "\", Status: " + status;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 * Provides methods for adding, viewing, and completing tasks.
 */
class TaskManager {
    // Queue for tasks that are waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Declared as List, instantiated as ArrayList
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskManager, initializing the task collections and ID counter.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Task IDs start from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Performs validation to ensure the description is not empty.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer() is the preferred method to add to a queue
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates through the queue without removing elements.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate using forEach or an iterator; avoid polling here
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Marks the next task in the pending queue as completed.
     * Removes the task from the pending queue, updates its status,
     * and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void completeNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task taskToComplete = pendingTasks.poll();
        if (taskToComplete == null) {
            System.err.println("Error: No pending tasks to complete.");
        } else {
            taskToComplete.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToComplete);
            System.out.println("Task completed: " + taskToComplete.getDescription());
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop, handling user interaction via the console.
     * Includes class-wide exception handling for the operational loop.
     */
    public void run() {
        Scanner scanner = null; // Declare scanner outside try for finally block access
        int choice = -1; // Initialize choice

        System.out.println("--- IT Support Task Manager ---");

        // Class-wide exception handling for the main application loop
        try {
            scanner = new Scanner(System.in);

            while (choice != 5) {
                displayMenu();
                System.out.print("Enter your choice: ");

                try {
                    // Attempt to read the integer choice
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            addTask(description); // Call method to add task
                            break;
                        case 2:
                            viewPendingTasks(); // Call method to view pending tasks
                            break;
                        case 3:
                            viewCompletedTasks(); // Call method to view completed tasks
                            break;
                        case 4:
                            completeNextTask(); // Call method to complete the next task
                            break;
                        case 5:
                            System.out.println("Exiting Task Manager. Goodbye!"); // Exit message
                            break;
                        default:
                            // Handle invalid integer input outside the 1-5 range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break; // No need to reset choice, loop condition handles it
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to ensure loop continues and menu is shown
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // Optional: e.printStackTrace(); // For debugging purposes
                }
                System.out.println(); // Add a blank line for better readability between operations
            }
        } catch (Exception mainException) {
             // Catch any exceptions during Scanner initialization or the outer loop structure itself
             System.err.println("A critical error occurred: " + mainException.getMessage());
             // Optional: mainException.printStackTrace();
        } finally {
            // Ensure the scanner is closed when the application exits or a critical error occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation for debugging/understanding flow
            }
        }
    }

    /**
     * The main entry point for the IT Support Task Manager application.
     * Creates a TaskManager instance and starts the application loop.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
