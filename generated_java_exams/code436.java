/*
 * Exam Question #436
 * Generated on: 2025-05-11 23:10:45
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: IT Support Ticketing System**
 * 
 * **Objective:** Design and implement a simple command-line IT Support Ticketing System simulation. This task requires you to apply fundamental and advanced Java concepts, including collections, user input handling, control flow, and robust error management.
 * 
 * **Scenario:**
 * You are building a basic system for managing support tickets. New tickets are added to a queue for processing. Support technicians process tickets from the front of the queue. Once processed, tickets are moved to a list of completed tickets. The system should allow users to interact via a command-line interface.
 * 
 * **Requirements:**
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tickets that are pending processing.
 *     *   Use a `java.util.List` (specifically, instantiate with `java.util.ArrayList`) to store tickets that have been completed.
 *     *   Create a `SupportTicket` class to represent a ticket with attributes like a unique ID, description, and status (e.g., "Pending", "Completed").
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         *   Add New Ticket
 *         *   Process Next Pending Ticket
 *         *   View Pending Tickets
 *         *   View Completed Tickets
 *         *   Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 3.  **Core Functionality:**
 *     *   **Add New Ticket:** Prompt the user for a ticket description. Create a new `SupportTicket` with a unique ID and "Pending" status, and add it to the pending tickets queue.
 *     *   **Process Next Pending Ticket:** Remove the next ticket from the front of the pending queue. Update its status to "Completed" and add it to the completed tickets list. Handle the case where there are no pending tickets.
 *     *   **View Pending Tickets:** Display all tickets currently in the pending queue.
 *     *   **View Completed Tickets:** Display all tickets currently in the completed tickets list.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and ticket details.
 *     *   Use `System.err` to display error messages (e.g., "Invalid menu choice.", "No pending tickets to process.").
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, such as invalid input (e.g., non-integer input for menu selection) or attempting operations on empty collections where applicable.
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation in the `SupportTicket` class (private fields, public getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Perform basic input validation (e.g., ensuring ticket description is not empty).
 *     *   Structure the code into appropriate classes and methods for clarity and maintainability.
 * 
 * **Expected Output:**
 * The program should run interactively, displaying a menu, accepting user input, performing the requested operations, and providing clear output or error messages based on the actions taken.
 * 
 * Example interaction flow:
 * ```
 * IT Support Ticketing System
 * ---------------------------
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Completed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Network issue in office 3B
 * Ticket #1 added.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 1
 * Enter ticket description: Software installation problem
 * Ticket #2 added.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [ID: 1, Description: Network issue in office 3B, Status: Pending]
 * [ID: 2, Description: Software installation problem, Status: Pending]
 * -----------------------
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 2
 * Processing ticket #1...
 * Ticket #1 completed.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [ID: 2, Description: Software installation problem, Status: Pending]
 * -----------------------
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 4
 * --- Completed Tickets ---
 * [ID: 1, Description: Network issue in office 3B, Status: Completed]
 * -------------------------
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 2
 * Processing ticket #2...
 * Ticket #2 completed.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 2
 * Error: No pending tickets to process.
 * 
 * IT Support Ticketing System
 * ---------------------------
 * ... menu ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **
 *
 * EXPLANATION:
 * This solution provides a complete implementation of the IT Support Ticketing System based on the requirements.
 * 
 * 1.  **`SupportTicket` Class:** This class is a simple Plain Old Java Object (POJO) representing a ticket. It demonstrates encapsulation by keeping its data fields (`id`, `description`, `status`) private and providing public getter methods. The `setStatus` method allows controlled modification of the status. The overridden `toString` method facilitates easy printing of ticket details.
 * 
 * 2.  **`ITSupportSystem` Class:** This is the core class containing the application logic.
 *     *   **Collections:**
 *         *   `pendingTickets`: A `Queue<SupportTicket>` is used, specifically implemented with `LinkedList`. The `Queue` interface is appropriate because tickets are processed in the order they are received (FIFO - First-In, First-Out). New tickets are added using `offer()`, and tickets are retrieved and removed for processing using `poll()`.
 *         *   `completedTickets`: A `List<SupportTicket>` is used, instantiated as an `ArrayList<SupportTicket>`. The `List` interface and `ArrayList` implementation are suitable for storing completed tickets where order isn't strictly FIFO for processing but we might want to iterate through them or potentially access them by index (though not required in this specific problem). The requirement explicitly asked for `List` and `ArrayList`, which is met.
 *     *   **State:** `nextTicketId` maintains a counter for assigning unique IDs to new tickets. `scanner` manages console input.
 *     *   **Methods:** Methods like `addTicket`, `processNextTicket`, `viewPendingTickets`, and `viewCompletedTickets` encapsulate specific system operations, promoting modularity and readability. Input validation (e.g., checking for empty description in `addTicket`) and checks for empty collections (in `processNextTicket` and view methods) are included.
 * 
 * 3.  **`run()` Method:** This method drives the application's main loop.
 *     *   **User Interaction:** It repeatedly displays the menu (`displayMenu()`) and reads the user's choice using the `scanner`.
 *     *   **`switch` Statement:** A `switch` statement is used to execute the corresponding system function based on the integer choice entered by the user, fulfilling a core requirement.
 *     *   **Exception Handling (`try-catch`):**
 *         *   An outer `try-catch(Exception e)` block wraps the main `while` loop. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might propagate up from method calls or other operations within the loop. It prints a generic error message to `System.err` and the stack trace for debugging.
 *         *   An inner `try-catch(InputMismatchException e)` block is specifically used around the `scanner.nextInt()` call. This handles cases where the user enters non-integer input for the menu choice. It prints a user-friendly error message to `System.err` and uses `scanner.next()` to consume the invalid token, preventing an infinite loop. `continue` restarts the `while` loop to show the menu again.
 *         *   A `finally` block associated with the inner `try-catch` is crucial. `scanner.nextInt()` only reads the integer, leaving the newline character in the input buffer. The `scanner.nextLine()` call within this `finally` consumes that leftover newline, ensuring that subsequent calls to `scanner.nextLine()` (like the one in `addTicket`) read actual input lines and not just the leftover newline.
 *         *   An outer `finally` block ensures that the `scanner` resource is closed when the `run` method exits, whether normally or due to an exception. This is important for resource management.
 *     *   `System.out` is used for normal program output (menu, prompts, success messages), while `System.err` is reserved for error messages as required.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, interactive system simulation.
 */

// Required imports
import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList; // Required implementation for List
import java.util.Scanner;
import java.util.InputMismatchException; // For handling non-integer input

// Class to represent a support ticket
class SupportTicket {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new SupportTicket.
     * @param id The unique ID for the ticket.
     * @param description A brief description of the issue.
     */
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    /**
     * Updates the status of the ticket.
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string showing ticket details.
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", Description: " + description + ", Status: " + status + "]";
    }
}

// Main class for the IT Support System logic
public class ITSupportSystem {

    private Queue<SupportTicket> pendingTickets;
    private List<SupportTicket> completedTickets; // Using List interface, will instantiate with ArrayList
    private int nextTicketId;
    private Scanner scanner; // Scanner is a resource that should be managed

    /**
     * Constructs the ITSupportSystem, initializing collections and scanner.
     */
    public ITSupportSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.completedTickets = new ArrayList<>(); // Required to use ArrayList
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new ticket based on user input.
     * Prompts for description and adds the ticket to the pending queue.
     * Includes input validation for the description.
     */
    public void addTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit method if description is invalid
        }

        SupportTicket newTicket = new SupportTicket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer is generally preferred over add for queues
        System.out.println("Ticket #" + newTicket.getId() + " added.");
    }

    /**
     * Processes the next ticket in the pending queue.
     * Removes the head of the queue, updates its status, and moves it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTicket() {
        // Check if the queue is empty before attempting to poll
        if (pendingTickets.isEmpty()) {
            System.err.println("Error: No pending tickets to process.");
            return;
        }

        SupportTicket ticketToProcess = pendingTickets.poll(); // poll retrieves and removes the head
        System.out.println("Processing ticket #" + ticketToProcess.getId() + "...");

        // Update status and move to completed list
        ticketToProcess.setStatus("Completed");
        completedTickets.add(ticketToProcess);
        System.out.println("Ticket #" + ticketToProcess.getId() + " completed.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            // LinkedList's iterator provides elements in insertion order, matching Queue order
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets currently in the completed list.
     */
    public void viewCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---");
        if (completedTickets.isEmpty()) {
            System.out.println("No completed tickets.");
        } else {
            // Iterate through the list
            for (SupportTicket ticket : completedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\nIT Support Ticketing System");
        System.out.println("---------------------------");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Completed Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main interactive loop of the IT Support System.
     * Handles user input, menu navigation, and class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block for the main loop to catch unexpected errors
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default value for choice

                // Inner try-catch for handling non-integer input specifically
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                } finally {
                     // Consume the newline character left by nextInt()
                     // This is crucial before the next nextLine() call in addTicket()
                     if (scanner.hasNextLine()) { // Check if there's a line to consume
                         scanner.nextLine();
                     }
                }

                // Use switch statement for menu handling
                switch (choice) {
                    case 1:
                        addTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewCompletedTickets();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
             // Ensure scanner is closed when the program exits or an exception occurs
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ITSupportSystem system = new ITSupportSystem();
        system.run();
    }
}
