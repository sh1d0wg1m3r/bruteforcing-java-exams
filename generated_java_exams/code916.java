/*
 * Exam Question #916
 * Generated on: 2025-05-12 16:59:03
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a print job management system. The system should manage a queue of pending print jobs and a history of completed jobs. Users interact with the system via a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class named `PrintJob` with the following private fields: `jobId` (int), `fileName` (String), and `pages` (int).
 *     *   Implement a constructor `PrintJob(int jobId, String fileName, int pages)`.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of a print job (e.g., "Job ID: [id], File: [name], Pages: [pages]").
 * 
 * 2.  **`PrintJobManager` Class:**
 *     *   Create a class named `PrintJobManager`.
 *     *   This class should manage two data structures:
 *         *   A `Queue<PrintJob>` (use `java.util.Queue`) to hold jobs waiting to be printed.
 *         *   A `List<PrintJob>` (use `java.util.List`, implemented with `java.util.ArrayList`) to hold jobs that have been processed.
 *     *   Include a private field to keep track of the next available job ID, ensuring each new job gets a unique, incrementing ID starting from 1.
 *     *   Implement a public method `addJob(String fileName, int pages)`:
 *         *   Takes the file name and number of pages as input.
 *         *   Validates that `pages` is a positive integer (> 0). If not, print an error message to `System.err` and do not add the job.
 *         *   Creates a new `PrintJob` object with the next available ID.
 *         *   Adds the new job to the pending jobs queue.
 *         *   Increments the next job ID counter.
 *         *   Prints a success message to `System.out`.
 *     *   Implement a public method `processNextJob()`:
 *         *   Attempts to remove the next job from the pending jobs queue.
 *         *   If the queue is empty, print an error message to `System.err` indicating no jobs are pending.
 *         *   If a job is successfully removed, add it to the completed jobs list and print a success message to `System.out` including the job details.
 *         *   Return the processed `PrintJob` object, or `null` if the queue was empty.
 *     *   Implement public methods `getPendingJobs()` and `getCompletedJobs()` that return the respective collections.
 * 
 * 3.  **Main Application (`PrintJobSystem` or similar):**
 *     *   Create a main class with a `main` method.
 *     *   Instantiate a `Scanner` for user input and a `PrintJobManager`.
 *     *   Implement a menu-driven loop that presents the following options to the user:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Pending Jobs
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Call the appropriate methods of the `PrintJobManager` based on the user's selection.
 *     *   Use `System.out` for displaying the menu, prompts, and job lists.
 *     *   Use `System.err` for all error messages, including:
 *         *   Invalid menu choices.
 *         *   Input validation failures (e.g., non-positive pages).
 *         *   Attempting to process a job when the queue is empty.
 *         *   Handling non-integer input using `Scanner`.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle potential input errors (like entering text when an integer is expected) and other unexpected issues during the main loop execution. Ensure the program doesn't crash on invalid input and prompts the user again.
 * 
 * 4.  **General Requirements:**
 *     *   Adhere to Java coding best practices:
 *         *   Proper encapsulation (private fields, public methods).
 *         *   Meaningful variable and method names.
 *         *   Appropriate comments and documentation (basic Javadoc or inline comments where helpful).
 *         *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu, accept user input, perform the requested action, and display results or errors. Error messages *must* go to `System.err`. Job lists and success messages *must* go to `System.out`.
 * 
 * Example interaction flow (user input shown after `>`):
 * 
 * ```
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: > 1
 * Enter file name: > document.pdf
 * Enter number of pages: > 15
 * Job ID 1 (document.pdf, 15 pages) added to the queue.
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 2
 * Processing job: Job ID: 1, File: document.pdf, Pages: 15
 * Job ID 1 processed and moved to completed.
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 2
 * No pending jobs to process. (This message goes to System.err)
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 3
 * --- Pending Jobs ---
 * (If queue is empty, print "No pending jobs.")
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 4
 * --- Completed Jobs ---
 * Job ID: 1, File: document.pdf, Pages: 15
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 1
 * Enter file name: > report.docx
 * Enter number of pages: > -5
 * Error: Number of pages must be positive. (This message goes to System.err)
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > invalid
 * Error: Invalid input. Please enter a number. (This message goes to System.err)
 * --- Print Job Management Menu ---
 * ...
 * Enter your choice: > 5
 * Exiting Print Job Management System.
 * ```
 * 
 * Your solution should be provided as a single block of code containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Print Job Management System as described, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:** This is a simple Plain Old Java Object (POJO) representing a data entity. It uses private fields (`jobId`, `fileName`, `pages`) and public getters, adhering to encapsulation. The `toString()` method provides a convenient way to display job details.
 * 
 * 2.  **`PrintJobManager` Class:** This class encapsulates the core logic and data structures of the system.
 *     *   It uses a `Queue<PrintJob>` named `pendingJobs` (specifically implemented using `LinkedList`, which is a common choice for queues) to maintain the order of jobs waiting to be processed (First-In, First-Out).
 *     *   It uses a `List<PrintJob>` named `completedJobs` (implemented using `ArrayList`) to store the history of jobs that have finished processing. `ArrayList` is suitable here as we primarily need to add to the end and iterate through the history.
 *     *   A `nextJobId` counter ensures unique IDs for new jobs.
 *     *   `addJob`: Takes file name and pages, performs basic input validation (`pages > 0`), creates a `PrintJob`, adds it to the queue using `offer()` (a standard `Queue` method), increments the ID, and prints a success message to `System.out`.
 *     *   `processNextJob`: Uses `poll()` to retrieve and remove the head of the queue. `poll()` is safe as it returns `null` if the queue is empty, which is handled by printing an error to `System.err`. If a job is retrieved, it's added to the `completedJobs` list using `add()` (a `List` method), and a success message is printed to `System.out`.
 *     *   `getPendingJobs` and `getCompletedJobs`: Provide access to the internal collections. While returning the direct reference is done here for simplicity in an exam context, in a production system, returning unmodifiable views or copies would be better for stricter encapsulation.
 * 
 * 3.  **Main Application (`PrintJobSystem`):**
 *     *   The `main` method drives the application.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   A `PrintJobManager` instance holds the system state.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `displayMenu()` method prints the options to `System.out`.
 *     *   **Class-wide Exception Handling:** A large `try-catch(Exception e)` block wraps the main `while` loop. This provides a safety net for any unexpected errors that might occur during execution, printing the error details to `System.err` and preventing the program from crashing abruptly.
 *     *   **Input Validation and Handling:**
 *         *   Inside the main loop's `try` block, there's a nested `try-catch(InputMismatchException)` specifically for reading the menu choice. This handles cases where the user enters non-integer input for the menu option. Upon catching the exception, an error is printed to `System.err`, `scanner.next()` consumes the invalid input, and `continue` restarts the loop, showing the menu again.
 *         *   Similar `try-catch(InputMismatchException)` is used when reading the number of pages for a new job.
 *         *   The `addJob` method itself performs validation for positive page count, printing an error to `System.err` if invalid.
 *     *   **`switch` Statement:** This is used to direct the program flow based on the valid menu choice read from the user, calling the appropriate `PrintJobManager` methods or handling the exit condition.
 *     *   **`System.out` and `System.err`:** `System.out` is used for all normal output (menu, prompts, success messages, job lists). `System.err` is strictly used for error messages (invalid input, validation errors, empty queue warnings, unexpected exceptions).
 *     *   **Resource Management:** The `finally` block ensures the `Scanner` resource is closed when the main loop terminates, either normally or due to an unexpected exception caught by the outer `try-catch`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (`List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a practical, menu-driven application, while following good object-oriented principles and error handling practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int jobId;
    private String fileName;
    private int pages;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the file.
     */
    public PrintJob(int jobId, String fileName, int pages) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.pages = pages;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return Formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages;
    }
}

// Manages the queue of pending jobs and list of completed jobs
class PrintJobManager {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs;
    private int nextJobId; // Counter for unique job IDs

    /**
     * Constructs a new PrintJobManager, initializing collections and job ID counter.
     */
    public PrintJobManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue.
     * @param fileName The name of the file.
     * @param pages The number of pages.
     * @return The added PrintJob object, or null if validation fails.
     */
    public PrintJob addJob(String fileName, int pages) {
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive.");
            return null; // Indicate failure
        }

        PrintJob newJob = new PrintJob(nextJobId, fileName, pages);
        pendingJobs.offer(newJob); // offer is generally preferred over add for queues
        System.out.println("Job ID " + newJob.getJobId() + " (" + newJob.getFileName() + ", " + newJob.getPages() + " pages) added to the queue.");
        nextJobId++; // Increment for the next job
        return newJob; // Return the successfully added job
    }

    /**
     * Processes the next job in the queue (simulating printing).
     * Moves the job from pending to completed.
     * @return The processed PrintJob object, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob jobToProcess = pendingJobs.poll(); // poll retrieves and removes the head

        if (jobToProcess == null) {
            System.err.println("No pending jobs to process.");
            return null; // Indicate queue was empty
        } else {
            System.out.println("Processing job: " + jobToProcess);
            completedJobs.add(jobToProcess);
            System.out.println("Job ID " + jobToProcess.getJobId() + " processed and moved to completed.");
            return jobToProcess; // Return the processed job
        }
    }

    /**
     * Returns the queue of pending print jobs.
     * @return The Queue of pending jobs.
     */
    public Queue<PrintJob> getPendingJobs() {
        // Returning the reference allows external iteration. For stricter encapsulation,
        // one might return an unmodifiable view or a copy. For this exam, returning the reference is acceptable.
        return pendingJobs;
    }

    /**
     * Returns the list of completed print jobs.
     * @return The List of completed jobs.
     */
    public List<PrintJob> getCompletedJobs() {
         // Returning the reference allows external iteration. For stricter encapsulation,
        // one might return an unmodifiable view or a copy. For this exam, returning the reference is acceptable.
        return completedJobs;
    }
}

// Main class for the Print Job Management System application
public class PrintJobSystem {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Print Job Management Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main entry point for the Print Job Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintJobManager manager = new PrintJobManager();
        boolean running = true;

        // Class-wide exception handling wrapping the main application loop
        try {
            while (running) {
                displayMenu();

                int choice = -1; // Default invalid choice

                // --- Input handling for menu choice ---
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }
                // --- End Input handling ---

                // --- Process menu choice using switch ---
                switch (choice) {
                    case 1: // Add New Print Job
                        System.out.print("Enter file name: ");
                        scanner.nextLine(); // Consume the newline left by nextInt()
                        String fileName = scanner.nextLine();

                        int pages = -1;
                        System.out.print("Enter number of pages: ");
                        try {
                             pages = scanner.nextInt();
                             manager.addJob(fileName, pages); // addJob includes its own validation
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for pages. Please enter a number.");
                             scanner.next(); // Consume the invalid input
                        }
                        break;

                    case 2: // Process Next Job
                        manager.processNextJob();
                        break;

                    case 3: // View Pending Jobs
                        System.out.println("\n--- Pending Jobs ---");
                        Queue<PrintJob> pending = manager.getPendingJobs();
                        if (pending.isEmpty()) {
                            System.out.println("No pending jobs.");
                        } else {
                            // Iterate through the queue without removing elements
                            pending.forEach(System.out::println);
                        }
                        break;

                    case 4: // View Completed Jobs
                        System.out.println("\n--- Completed Jobs ---");
                        List<PrintJob> completed = manager.getCompletedJobs();
                        if (completed.isEmpty()) {
                            System.out.println("No completed jobs.");
                        } else {
                            // Iterate through the list
                            completed.forEach(System.out::println);
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Job Management System.");
                        running = false; // Set flag to exit loop
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                // --- End switch ---

            } // End while loop
        } catch (Exception e) {
            // General catch block for any unexpected errors during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    } // End main method
}
