/*
 * Exam Question #614
 * Generated on: 2025-05-12 16:14:51
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment Simulation
 * 
 * **Objective:** Design and implement a Java program that simulates a basic warehouse order fulfillment system. The system manages inventory and processes incoming orders based on item availability.
 * 
 * **Scenario:**
 * You are developing software for a small warehouse. The warehouse stores various items, each with a name and quantity. Incoming customer orders arrive and are placed in a queue to be processed in the order they were received (FIFO). When an order is processed, the system checks if all requested items are available in sufficient quantities in the inventory. If yes, the items are deducted from the inventory, and the order is marked as fulfilled. If not, the order cannot be fulfilled at this time, and an error is reported.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store incoming `Order` objects.
 *     *   Use `java.util.List` interface, implemented by `java.util.ArrayList`, to store the warehouse `Item` inventory.
 * 2.  **Classes:**
 *     *   Create a class `Item` to represent an item with `name` (String) and `quantity` (int). Include appropriate constructors, getters, and setters.
 *     *   Create a class `Order` to represent a customer order. Each order should have a unique `orderId` (int) and a `List<Item>` representing the items and their requested quantities in this specific order. Include appropriate constructors, getters, and setters.
 *     *   Create a main class, e.g., `WarehouseSimulation`, which contains the `main` method and manages the inventory and order queue.
 * 3.  **Functionality (implemented in `WarehouseSimulation`):**
 *     *   **Main Menu:** Present a text-based menu to the user with options:
 *         1.  Add Item to Inventory
 *         2.  View Inventory
 *         3.  Add Order to Queue
 *         4.  Process Next Order
 *         5.  View Pending Orders
 *         6.  Exit
 *     *   **Add Item to Inventory:**
 *         *   Prompt the user for item name and quantity.
 *         *   If the item already exists, update its quantity.
 *         *   If the item is new, add it to the inventory list.
 *         *   Validate that quantity is non-negative.
 *     *   **View Inventory:**
 *         *   List all items currently in the inventory with their names and quantities.
 *     *   **Add Order to Queue:**
 *         *   Prompt for an order ID.
 *         *   Prompt the user to enter items for the order one by one (item name and requested quantity). Allow adding multiple items until the user indicates they are done (e.g., by entering a special value like "done" for the item name).
 *         *   Create an `Order` object and add it to the `incomingOrders` queue.
 *         *   Validate that requested quantities are positive.
 *     *   **Process Next Order:**
 *         *   Take the next `Order` from the `incomingOrders` queue.
 *         *   For each `Item` requested in the order:
 *             *   Check if the item exists in the inventory.
 *             *   Check if there is sufficient quantity available.
 *         *   **Crucially:** Only if *all* items in the order have sufficient stock, deduct the quantities from the inventory and print a success message to `System.out`.
 *         *   If *any* item in the order is not found or has insufficient stock, *do not* deduct any items. Print an error message to `System.err` indicating which item caused the failure and the order ID. The order should be removed from the queue in this case (as it cannot be fulfilled currently).
 *         *   Handle the case where the order queue is empty.
 *     *   **View Pending Orders:**
 *         *   List the IDs of all orders currently in the `incomingOrders` queue.
 *     *   **Exit:** Terminate the program.
 * 4.  **Input Handling:**
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Handle potential `InputMismatchException` when reading numbers.
 * 5.  **Error Handling:**
 *     *   Use `try-catch` blocks for exception handling, particularly around input operations and potentially during order processing (e.g., you could define a custom exception like `InsufficientStockException`, though simple error messages to `System.err` are also acceptable if the order processing logic handles the check explicitly). Ensure class-wide handling where appropriate (e.g., in the main loop).
 *     *   Print normal output (menu, inventory, success messages, pending orders) to `System.out`.
 *     *   Print error messages (invalid input, insufficient stock, item not found during processing) to `System.err`.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Apply proper encapsulation (private fields, public getters/setters).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   Menu displayed clearly.
 * *   Inventory listing shows item names and quantities.
 * *   Pending orders listing shows order IDs.
 * *   Success messages for adding items/orders and processing successful orders (`System.out`).
 * *   Error messages for invalid input, insufficient stock, or missing items during processing (`System.err`).
 * 
 * Implement the complete Java code for this simulation.
 *
 * EXPLANATION:
 * This solution implements the `WarehouseSimulation` as requested, demonstrating the use of all required Java components in a practical scenario.
 * 
 * 1.  **Classes (`Item`, `Order`):** Simple classes are created to model the core entities (`Item` with name and quantity, `Order` with ID and a list of requested `Item`s). They follow encapsulation principles with private fields and public getters/setters. `toString()` methods are overridden for easy printing.
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`, `LinkedList`):**
 *     *   `inventory` is declared as `List<Item>` and initialized as an `ArrayList`. This demonstrates programming to the interface (`List`), while using a concrete implementation (`ArrayList`) for dynamic resizing and efficient element access.
 *     *   `incomingOrders` is declared as `Queue<Order>` and initialized as a `LinkedList`. `LinkedList` is a common and efficient implementation for the `Queue` interface, suitable for FIFO operations (adding to the end, removing from the front).
 * 3.  **Scanner:** A `Scanner` object is used to read user input from `System.in` for menu choices, item details, and order details.
 * 4.  **Switch Statement:** The `run()` method uses a `switch` statement to handle the different menu options selected by the user, directing the program flow to the appropriate method (`addItemToInventory`, `viewInventory`, etc.).
 * 5.  **System.out and System.err:**
 *     *   `System.out.println()` is used for all standard output: displaying the menu, listing inventory, showing pending orders, and printing success messages (e.g., item added, order processed successfully).
 *     *   `System.err.println()` is used specifically for error messages: invalid menu choices, invalid input formats (`InputMismatchException`), validation errors (negative quantity), and crucial errors during order processing (item not found, insufficient stock). This separation is a good practice for distinguishing normal program output from critical errors.
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A main `try-catch` block wraps the `switch` statement inside the `run()` loop. This provides class-wide handling for potential exceptions that might occur during the execution of any menu option, particularly `InputMismatchException` if the user enters non-integer input when a number is expected (like the menu choice or quantities).
 *     *   Within `addItemToInventory` and `addOrderToQueue`, `try-catch` blocks are also used specifically around `scanner.nextInt()` calls to catch `InputMismatchException` and handle invalid numerical input gracefully for quantities.
 *     *   While a custom `InsufficientStockException` class is included as an example of good practice, the core logic in `processNextOrder` explicitly checks conditions (item existence, stock level) and uses `System.err` to report failures without necessarily throwing a custom exception, which is also acceptable for this exam context. The `processNextOrder` logic ensures that *no* deductions happen if *any* item in the order fails the check.
 * 7.  **Functionality Implementation:**
 *     *   Methods like `addItemToInventory`, `viewInventory`, `addOrderToQueue`, `processNextOrder`, and `viewPendingOrders` encapsulate the logic for each menu option.
 *     *   `findItemInInventory` is a helper method demonstrating how to search the `ArrayList` inventory.
 *     *   `addOrderToQueue` uses a loop to allow adding multiple items to a single order before adding the complete `Order` object to the `incomingOrders` queue using `offer()`.
 *     *   `processNextOrder` uses `peek()` to look at the next order without removing it first, performs checks, and *only* removes the order using `poll()` if it can be fully processed or if it fails validation (to clear it from the pending queue). It iterates through the requested items, verifies stock *before* making any deductions, and then performs deductions only if all checks pass.
 *     *   `viewPendingOrders` iterates through the `Queue` using a for-each loop, which uses the queue's iterator, allowing viewing elements without removing them.
 * 8.  **Best Practices:**
 *     *   Variable and method names are descriptive (e.g., `incomingOrders`, `processNextOrder`, `requestedItems`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Encapsulation is used in `Item` and `Order`.
 *     *   Input validation is performed (e.g., non-negative quantity for inventory, positive quantity for order requests, non-empty names).
 *     *   The code structure separates concerns into different methods.
 *     *   The `Scanner` is closed when the program exits.
 * 
 * This solution effectively combines the required Java components to build a functional simulation that handles different user actions, manages data in appropriate structures, and includes essential error handling and validation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an item in the warehouse or an item requested in an order
class Item {
    private String name;
    private int quantity;

    public Item(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return name + " (Qty: " + quantity + ")";
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<Item> requestedItems;

    public Order(int orderId, List<Item> requestedItems) {
        this.orderId = orderId;
        this.requestedItems = requestedItems;
    }

    public int getOrderId() {
        return orderId;
    }

    public List<Item> getRequestedItems() {
        return requestedItems;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        sb.append("  Items: ");
        if (requestedItems.isEmpty()) {
            sb.append("None");
        } else {
            for (int i = 0; i < requestedItems.size(); i++) {
                sb.append(requestedItems.get(i).getName()).append(" (Req: ").append(requestedItems.get(i).getQuantity()).append(")");
                if (i < requestedItems.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }
}

// Custom exception for insufficient stock (optional, but good practice)
class InsufficientStockException extends Exception {
    public InsufficientStockException(String message) {
        super(message);
    }
}

// Main class for the warehouse simulation
public class WarehouseSimulation {

    // Using List interface, implemented by ArrayList for inventory
    private List<Item> inventory;
    // Using Queue interface, implemented by LinkedList for incoming orders (FIFO)
    private Queue<Order> incomingOrders;
    private Scanner scanner;
    private int nextOrderId = 1; // Simple counter for unique order IDs

    public WarehouseSimulation() {
        inventory = new ArrayList<>();
        incomingOrders = new LinkedList<>(); // LinkedList is a common implementation for Queue
        scanner = new Scanner(System.in);
    }

    // Main method to run the simulation
    public static void main(String[] args) {
        WarehouseSimulation simulation = new WarehouseSimulation();
        simulation.run();
    }

    // Main simulation loop
    public void run() {
        int choice = -1;
        while (choice != 6) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use switch for menu navigation
                switch (choice) {
                    case 1:
                        addItemToInventory();
                        break;
                    case 2:
                        viewInventory();
                        break;
                    case 3:
                        addOrderToQueue();
                        break;
                    case 4:
                        processNextOrder();
                        break;
                    case 5:
                        viewPendingOrders();
                        break;
                    case 6:
                        System.out.println("Exiting Warehouse Simulation. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input using try-catch
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Generic catch for unexpected errors (class-wide handling example)
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: for debugging
            }
            System.out.println(); // Add a newline for better readability between actions
        }
        scanner.close(); // Close the scanner when exiting
    }

    private void printMenu() {
        System.out.println("--- Warehouse Menu ---");
        System.out.println("1. Add Item to Inventory");
        System.out.println("2. View Inventory");
        System.out.println("3. Add Order to Queue");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.println("----------------------");
    }

    // Helper method to find an item in the inventory by name
    private Item findItemInInventory(String name) {
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(name.trim())) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Option 1: Add or update item in inventory
    private void addItemToInventory() {
        System.out.println("--- Add/Update Item ---");
        System.out.print("Enter item name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Item name cannot be empty.");
            return;
        }

        int quantity = -1;
        try {
            System.out.print("Enter quantity to add/set: ");
            quantity = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            if (quantity < 0) {
                System.err.println("Quantity cannot be negative.");
                return;
            }

        } catch (InputMismatchException e) {
            System.err.println("Invalid quantity. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
            return;
        }

        Item existingItem = findItemInInventory(name);

        if (existingItem != null) {
            // Update quantity if item exists
            existingItem.setQuantity(existingItem.getQuantity() + quantity);
            System.out.println("Updated quantity for '" + name + "'. New quantity: " + existingItem.getQuantity());
        } else {
            // Add new item if it doesn't exist
            inventory.add(new Item(name, quantity));
            System.out.println("Added new item: '" + name + "' with quantity: " + quantity);
        }
    }

    // Option 2: View current inventory
    private void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Item item : inventory) {
                System.out.println(item); // Uses Item's toString()
            }
        }
    }

    // Option 3: Add a new order to the queue
    private void addOrderToQueue() {
        System.out.println("--- Add New Order ---");
        int currentOrderId = nextOrderId++;
        List<Item> requestedItems = new ArrayList<>();

        System.out.println("Creating Order ID: " + currentOrderId);
        System.out.println("Enter items for the order (enter 'done' for item name when finished):");

        while (true) {
            System.out.print("  Enter item name ('done' to finish): ");
            String itemName = scanner.nextLine().trim();

            if (itemName.equalsIgnoreCase("done")) {
                break; // Exit item entry loop
            }

            if (itemName.isEmpty()) {
                System.err.println("  Item name cannot be empty. Please try again.");
                continue; // Ask for item name again
            }

            int requestedQuantity = -1;
            try {
                System.out.print("  Enter requested quantity for '" + itemName + "': ");
                requestedQuantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (requestedQuantity <= 0) {
                    System.err.println("  Requested quantity must be positive. Please try again.");
                    continue; // Ask for quantity again
                }

                // Add the requested item to the order's list
                requestedItems.add(new Item(itemName, requestedQuantity));
                System.out.println("  Added '" + itemName + "' (x" + requestedQuantity + ") to order.");

            } catch (InputMismatchException e) {
                System.err.println("  Invalid quantity. Please enter a number.");
                scanner.nextLine(); // Consume invalid input
                // Continue the outer loop to ask for the next item name
            }
        }

        if (requestedItems.isEmpty()) {
            System.out.println("No items added to order " + currentOrderId + ". Order not added to queue.");
        } else {
            Order newOrder = new Order(currentOrderId, requestedItems);
            incomingOrders.offer(newOrder); // Add order to the end of the queue
            System.out.println("Order " + currentOrderId + " added to the queue.");
        }
    }

    // Option 4: Process the next order in the queue
    private void processNextOrder() {
        System.out.println("--- Process Next Order ---");
        // poll() retrieves and removes the head of the queue, returns null if empty
        Order orderToProcess = incomingOrders.peek(); // Use peek() first to check before removing

        if (orderToProcess == null) {
            System.out.println("No pending orders in the queue.");
            return;
        }

        System.out.println("Attempting to process " + orderToProcess);

        boolean canFulfill = true;
        List<Item> itemsToDeduct = new ArrayList<>(); // List to store items and quantities to deduct

        // First Pass: Check if all items can be fulfilled
        for (Item requestedItem : orderToProcess.getRequestedItems()) {
            String itemName = requestedItem.getName();
            int requestedQuantity = requestedItem.getQuantity();

            Item inventoryItem = findItemInInventory(itemName);

            if (inventoryItem == null) {
                System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Item '" + itemName + "' not found in inventory.");
                canFulfill = false;
                break; // Stop checking this order
            }

            if (inventoryItem.getQuantity() < requestedQuantity) {
                System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Insufficient stock for item '" + itemName + "' (requested " + requestedQuantity + ", available " + inventoryItem.getQuantity() + ").");
                canFulfill = false;
                break; // Stop checking this order
            }

            // If checks pass, add to the list of items to deduct later
            itemsToDeduct.add(new Item(itemName, requestedQuantity));
        }

        // Second Pass: Deduct items if all checks passed
        if (canFulfill) {
            // Remove the order from the queue now that we know it can be processed
            incomingOrders.poll();

            for (Item deductionItem : itemsToDeduct) {
                Item inventoryItem = findItemInInventory(deductionItem.getName());
                // This should not be null based on the first pass, but defensive coding
                if (inventoryItem != null) {
                    inventoryItem.setQuantity(inventoryItem.getQuantity() - deductionItem.getQuantity());
                }
            }
            System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully.");
        } else {
             // If not fulfilled, remove the order from the queue and report failure
             incomingOrders.poll(); // Remove the order that failed processing
             System.err.println("Order " + orderToProcess.getOrderId() + " could not be fulfilled due to errors listed above. Removed from queue.");
        }
    }

    // Option 5: View orders currently waiting in the queue
    private void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (incomingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            int position = 1;
            for (Order order : incomingOrders) {
                System.out.println(position + ". " + order); // Uses Order's toString()
                position++;
            }
        }
    }
}
