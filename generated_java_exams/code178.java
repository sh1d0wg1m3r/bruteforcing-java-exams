/*
 * Exam Question #178
 * Generated on: 2025-05-11 22:26:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * You are tasked with developing a simplified Help Desk Ticket Management System simulation. This system should allow users to submit new support tickets, process the oldest pending ticket, and view the status of tickets.
 * 
 * Your solution must adhere to the following specifications and demonstrate advanced Java programming concepts:
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with private fields for a unique ID, description, priority (e.g., "High", "Medium", "Low"), and status ("Pending", "Processed"). Include a constructor and public getter methods. Add a method to change the status to "Processed". Use a static counter for generating unique IDs.
 * 2.  **System Core:** Create a `HelpDeskSystem` class that manages the tickets. This class must contain:
 *     *   A `Queue` to hold pending tickets, ensuring they are processed in the order they were received. Use a suitable `Queue` implementation (e.g., `LinkedList`).
 *     *   A `List` to store tickets that have been processed. Use `List` as the interface type and an `ArrayList` as the concrete implementation.
 *     *   A `Scanner` object to read user input from the console (`System.in`).
 * 3.  **Functionality:** The system should provide a command-line interface with the following options:
 *     *   **Add New Ticket:** Prompt the user for a description and priority, create a `Ticket` object, and add it to the pending tickets queue. Display a confirmation message using `System.out`.
 *     *   **Process Next Ticket:** Take the oldest ticket from the pending queue, update its status to "Processed", and move it to the processed history list. Display details of the processed ticket using `System.out`. If the queue is empty, display an error message using `System.err`.
 *     *   **View Pending Tickets:** Display all tickets currently in the pending queue, in order. If the queue is empty, display a message. Use `System.out`.
 *     *   **View Processed History:** Display all tickets that have been processed. If the history list is empty, display a message. Use `System.out`.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:** Implement a loop that continuously displays a menu of options and prompts the user for input until they choose to exit. Use a `switch` statement to handle the different menu choices.
 * 5.  **Input Validation and Error Handling:**
 *     *   Validate user input for menu choices (ensure it's a number within the valid range). Use `System.err` for invalid menu choices.
 *     *   Handle potential `NumberFormatException` if the user enters non-numeric input for the menu choice. Use `System.err` for the error message.
 *     *   Perform basic validation on ticket description and priority (e.g., not empty). Use `System.err` for validation errors.
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main operational loop to catch any unexpected runtime exceptions. Include a `finally` block to ensure resources like the `Scanner` are closed. Print unexpected errors to `System.err`.
 * 6.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (briefly explain classes/methods).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept numerical input, and perform actions based on the input. Expected output includes:
 * *   Menu display.
 * *   Prompts for ticket details.
 * *   Confirmation messages for adding/processing tickets.
 * *   Lists of pending and processed tickets.
 * *   Messages indicating empty queues/history.
 * *   Error messages printed to `System.err` for invalid input, empty queue processing attempts, or unexpected exceptions.
 * 
 * Example Interaction Flow (demonstrating various outputs including errors):
 * 
 * ```
 * --- Help Desk Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Processed History
 * 5. Exit
 * ----------------------
 * Enter choice: 1
 * --- Add New Ticket ---
 * Enter ticket description: My monitor is flickering
 * Enter ticket priority (e.g., High, Medium, Low): High
 * Ticket #1 added successfully.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 1
 * --- Add New Ticket ---
 * Enter ticket description: Can't access shared drive
 * Enter ticket priority (e.g., High, Medium, Low): Medium
 * Ticket #2 added successfully.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 3
 * --- Pending Tickets ---
 * Ticket [ID=1, Priority=High, Status=Pending, Description='My monitor is flickering']
 * Ticket [ID=2, Priority=Medium, Status=Pending, Description='Can't access shared drive']
 * Total pending tickets: 2
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 2
 * --- Process Next Ticket ---
 * Processed ticket: Ticket [ID=1, Priority=High, Status=Processed, Description='My monitor is flickering']
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 4
 * --- Processed Ticket History ---
 * Ticket [ID=1, Priority=High, Status=Processed, Description='My monitor is flickering']
 * Total processed tickets: 1
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: process
 * Invalid input. Please enter a number. // This should print to System.err
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 9
 * Invalid choice. Please enter a number between 1 and 5. // This should print to System.err
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 2
 * --- Process Next Ticket ---
 * Processed ticket: Ticket [ID=2, Priority=Medium, Status=Processed, Description='Can't access shared drive']
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 2
 * --- Process Next Ticket ---
 * No pending tickets to process. // This should print to System.err
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simplified Help Desk Ticket System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`Ticket` Class:** This class represents the core data unit. It follows encapsulation principles with private fields (`id`, `description`, `priority`, `status`) and public getter methods. A static `nextId` ensures each ticket gets a unique identifier upon creation. The `process()` method demonstrates object state change.
 * 
 * 2.  **`HelpDeskSystem` Class:** This is the main class orchestrating the system.
 *     *   **`Queue<Ticket> pendingTickets`**: A `Queue` is used to manage incoming tickets. The `Queue` interface guarantees FIFO (First-In, First-Out) behavior, which is appropriate for a help desk where tickets are typically addressed in the order they are received. `LinkedList` is chosen as a common and suitable implementation for a `Queue`. Tickets are added using `offer()` and removed using `poll()`.
 *     *   **`List<Ticket> processedHistory`**: A `List` is used to store tickets once they have been processed. Unlike the queue, the order of processed tickets isn't strictly managed by the `List`'s core functionality, but it serves as a dynamic collection to keep a history. `List` is used as the interface type, promoting good practice by programming to the interface, while `ArrayList` is chosen as the concrete implementation for its common use and efficient element access/addition (though insertion/deletion in the middle would be less efficient, which isn't needed here). Tickets are added using `add()`.
 *     *   **`Scanner scanner`**: A `Scanner` is used to read user input from the console (`System.in`), allowing interactive use of the system.
 * 
 * 3.  **Functionality Implementation:**
 *     *   The `run()` method contains the main application loop. It continuously displays the menu and processes user input until the 'Exit' option is chosen.
 *     *   **`Scanner` Input and `switch` Statement:** Inside the loop, user input is read using `scanner.nextLine()`. A `try-catch` block specifically handles `NumberFormatException` if the input cannot be parsed as an integer, directing the error message to `System.err`. A `switch` statement then directs execution to the appropriate private method (`addTicket`, `processNextTicket`, etc.) based on the valid integer input. This demonstrates structured flow control based on user commands.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for normal program output, such as displaying the menu, prompts, success messages, and ticket lists. `System.err.println()` is specifically used for error conditions, such as invalid menu choices, non-numeric input, empty queue situations, and validation errors (e.g., empty description). This separation helps distinguish normal output from error messages.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   **Input Validation:** The `addTicket` method includes checks to ensure the description and priority are not empty after trimming whitespace. Error messages for failed validation are sent to `System.err`. The `run` method handles `NumberFormatException` for menu input.
 *     *   **Empty Queue/List Checks:** Before attempting to process a ticket or view lists, the code checks if `pendingTickets` or `processedHistory` are empty using `.isEmpty()`. Appropriate messages are printed to `System.err` (for processing an empty queue) or `System.out` (for viewing empty lists).
 *     *   **Class-wide `try-catch`:** A `try-catch(Exception e)` block wraps the entire `while` loop in the `run()` method. This serves as a general safety net to catch any unexpected exceptions that might occur during the program's execution, preventing the program from crashing abruptly. The error details are printed to `System.err`.
 *     *   **`finally` Block:** A `finally` block is used in the `run()` method to ensure that the `scanner.close()` method is called regardless of whether the `try` block completes successfully, an exception is caught, or the loop is exited normally. This is crucial for releasing system resources held by the `Scanner`.
 * 
 * 5.  **Best Practices:** The code adheres to best practices by using meaningful names for variables, methods, and classes. Encapsulation is maintained through private fields and public accessors/mutators (like `process()`). Basic comments explain the purpose of classes and key methods. The structure is clean, with helper methods (`printMenu`, `addTicket`, etc.) breaking down the functionality.
 * 
 * In summary, this solution effectively integrates `Queue`, `List` (`ArrayList`), `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks within a practical simulation, demonstrating key Java concepts and best practices for building robust command-line applications.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single help desk support ticket.
 */
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs
    private int id;
    private String description;
    private String priority;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Ticket with a unique ID and initial status "Pending".
     * @param description The description of the issue.
     * @param priority The priority level of the ticket.
     */
    public Ticket(String description, String priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the ticket status to "Processed".
     */
    public void process() {
        this.status = "Processed";
    }

    /**
     * Provides a string representation of the Ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Priority=" + priority + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the help desk tickets using a Queue for pending and a List for processed history.
 */
public class HelpDeskSystem {
    // Queue to hold tickets waiting to be processed (FIFO)
    private Queue<Ticket> pendingTickets;
    // List to hold tickets that have been processed (history)
    private List<Ticket> processedHistory; // Declared as List interface
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new HelpDeskSystem, initializing data structures and scanner.
     */
    public HelpDeskSystem() {
        // Use LinkedList as the concrete implementation for the Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as the concrete implementation for the List
        this.processedHistory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide exception handling for the main operational loop
        try {
            boolean running = true;
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");
                String choiceStr = scanner.nextLine();
                int choice = -1;

                // Input validation for menu choice (must be a number)
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // Use System.err for invalid input errors
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for flow control based on valid numerical input
                switch (choice) {
                    case 1:
                        addTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewProcessedHistory();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Use System.err for choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during system execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace to System.err for debugging
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed when the application exits or errors
            if (scanner != null) {
                scanner.close();
            }
            // System.out.println("Scanner closed."); // Optional: confirmation
        }
    }

    /**
     * Displays the main menu options to the console using System.out.
     */
    private void printMenu() {
        System.out.println("--- Help Desk Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.println("----------------------");
    }

    /**
     * Prompts user for ticket details, validates input, creates a Ticket,
     * and adds it to the pending queue. Uses System.out and System.err.
     */
    private void addTicket() {
        System.out.println("\n--- Add New Ticket ---");
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Description cannot be empty.");
             return; // Stop the method if validation fails
        }

        System.out.print("Enter ticket priority (e.g., High, Medium, Low): ");
        String priority = scanner.nextLine();

         // Input validation for priority
         if (priority == null || priority.trim().isEmpty()) {
             System.err.println("Error: Priority cannot be empty.");
             return; // Stop the method if validation fails
        }

        // Create new ticket and add to the queue
        Ticket newTicket = new Ticket(description.trim(), priority.trim());
        pendingTickets.offer(newTicket); // offer() is preferred for capacity-constrained queues, but works fine here

        // Confirmation message using System.out
        System.out.println("Ticket #" + newTicket.getId() + " added successfully.");
    }

    /**
     * Processes the next available ticket from the pending queue (FIFO).
     * Updates its status and moves it to the processed history list.
     * Uses System.out and System.err.
     */
    private void processNextTicket() {
        System.out.println("\n--- Process Next Ticket ---");
        if (pendingTickets.isEmpty()) {
            // Use System.err for error condition (no tickets to process)
            System.err.println("No pending tickets to process.");
            return; // Stop the method if queue is empty
        }

        // Retrieve and remove the head of the queue
        Ticket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess != null) {
            ticketToProcess.process(); // Update status
            processedHistory.add(ticketToProcess); // Add to the end of the processed history list
            // Confirmation message using System.out
            System.out.println("Processed ticket: " + ticketToProcess);
        } else {
             // This else block handles the rare case where poll() returns null unexpectedly
             System.err.println("Error: Failed to retrieve ticket from queue.");
        }
    }

    /**
     * Displays all tickets currently in the pending queue using System.out.
     */
    private void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements to display them
            // The for-each loop uses the queue's iterator.
            int count = 0;
            for (Ticket ticket : pendingTickets) {
                 System.out.println(ticket);
                 count++;
            }
            System.out.println("Total pending tickets: " + count);
        }
    }

    /**
     * Displays all tickets in the processed history list using System.out.
     */
    private void viewProcessedHistory() {
        System.out.println("\n--- Processed Ticket History ---");
        if (processedHistory.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            // Iterate through the list to display processed tickets
            for (Ticket ticket : processedHistory) {
                System.out.println(ticket);
            }
             System.out.println("Total processed tickets: " + processedHistory.size());
        }
    }

    /**
     * Main method to start the HelpDeskSystem application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run(); // Start the main application loop
    }
}
