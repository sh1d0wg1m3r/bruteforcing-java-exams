/*
 * Exam Question #548
 * Generated on: 2025-05-11 23:27:54
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Emergency Response Dispatch System Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation of an Emergency Response Dispatch System. This system manages incoming emergency calls and dispatches available response units (like ambulances or police cars) to handle them.
 * 
 * The system should maintain a queue of incoming calls and a list of available response units. Users interact with the system via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incoming emergency calls. Calls can be represented as `String` objects containing brief details (e.g., "Traffic accident at Main St", "Medical emergency on Elm Ave").
 *     *   Use a `java.util.List` (specifically an `java.util.ArrayList`) to manage the pool of response units. Each unit should be an object of a custom class (`EmergencyUnit`).
 * 
 * 2.  **`EmergencyUnit` Class:**
 *     *   Create a class named `EmergencyUnit`.
 *     *   It must have private fields: `unitId` (int) and `isAvailable` (boolean).
 *     *   Provide a constructor `EmergencyUnit(int unitId)` that initializes the unit with the given ID and sets `isAvailable` to `true`.
 *     *   Provide public getter methods for `unitId` and `isAvailable`.
 *     *   Provide a public setter method `setAvailable(boolean available)` to change the unit's availability status.
 *     *   Override the `toString()` method to provide a clear string representation of the unit (e.g., "Unit 1 (Available)" or "Unit 3 (Busy)").
 *     *   Implement proper encapsulation.
 * 
 * 3.  **`EmergencyDispatchSystem` Class:**
 *     *   This will be the main class containing the `main` method and the core logic.
 *     *   It must have private fields for the call queue (`Queue<String>`) and the unit list (`List<EmergencyUnit>`).
 *     *   It must use `java.util.Scanner` to read user input from the console.
 *     *   Implement a command-line menu with the following options:
 *         1.  Receive New Call
 *         2.  Dispatch Unit to Next Call
 *         3.  View Pending Calls
 *         4.  View Response Units Status
 *         5.  Mark Unit as Available
 *         0.  Exit
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Implement methods corresponding to each menu option (e.g., `addCall()`, `dispatchUnit()`, `viewCalls()`, etc.).
 *     *   Initialize the system with a fixed number of `EmergencyUnit` objects (e.g., 5 units) in the list when the system starts.
 *     *   **Input Validation:** Validate user input where necessary (e.g., ensuring unit IDs are valid integers and correspond to existing units).
 *     *   **Error Handling:**
 *         *   Use `try-catch` blocks to handle potential exceptions, especially `NumberFormatException` for invalid integer input.
 *         *   Handle cases where there are no pending calls to dispatch or no available units.
 *         *   Use `System.err` to print error messages (e.g., invalid menu choice, invalid unit ID, input errors).
 *         *   Use `System.out` for normal output (menu, prompts, success messages, status displays).
 *         *   Implement exception handling within the class methods or the main loop to catch and report errors gracefully without crashing the program.
 * 
 * 4.  **Logic Details:**
 *     *   **Receive New Call:** Prompts the user for call details (a string) and adds it to the end of the incoming calls queue.
 *     *   **Dispatch Unit:**
 *         *   Checks if the call queue is empty. If so, prints a message.
 *         *   Checks if there are any available units in the list. If not, prints a message.
 *         *   If both a call exists and a unit is available:
 *             *   Takes the next call from the front of the queue.
 *             *   Finds the first available unit in the list.
 *             *   Marks the found unit as busy (`isAvailable = false`).
 *             *   Prints a message indicating which unit was dispatched to which call.
 *     *   **View Pending Calls:** Displays all calls currently in the queue without removing them.
 *     *   **View Response Units Status:** Lists all units and their current status (Available/Busy).
 *     *   **Mark Unit as Available:** Prompts the user for a unit ID, finds the unit in the list, and marks it as available if it exists and was busy. Handles cases where the ID is invalid, the unit doesn't exist, or the unit is already available.
 * 
 * **Expected Output:**
 * 
 * The system should run in a loop, displaying the menu, accepting user input, and performing the requested actions. Output should clearly indicate the results of operations, status of calls and units, and error conditions using `System.out` and `System.err` appropriately.
 * 
 * ---
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Emergency Dispatch System ---
 * 1. Receive New Call
 * 2. Dispatch Unit to Next Call
 * 3. View Pending Calls
 * 4. View Response Units Status
 * 5. Mark Unit as Available
 * 0. Exit
 * Enter choice: 1
 * Enter call details: Car crash on I-95
 * Call received and added to queue.
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 4
 * Response Units Status:
 * Unit 1 (Available)
 * Unit 2 (Available)
 * Unit 3 (Available)
 * Unit 4 (Available)
 * Unit 5 (Available)
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 2
 * Dispatching Unit...
 * Call details: Car crash on I-95
 * Dispatched Unit 1 to Car crash on I-95.
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 4
 * Response Units Status:
 * Unit 1 (Busy)
 * Unit 2 (Available)
 * Unit 3 (Available)
 * Unit 4 (Available)
 * Unit 5 (Available)
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 5
 * Enter Unit ID to mark available: 1
 * Unit 1 is now marked as Available.
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 4
 * Response Units Status:
 * Unit 1 (Available)
 * Unit 2 (Available)
 * Unit 3 (Available)
 * Unit 4 (Available)
 * Unit 5 (Available)
 * 
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 9
 * Error: Invalid menu choice. Please enter a number from 0 to 5.
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: abc
 * Error: Invalid input. Please enter a number.
 * --- Emergency Dispatch System ---
 * ...
 * Enter choice: 0
 * Exiting system.
 * ```
 * 
 * ---
 * **Your Task:** Implement the complete Java code for this Emergency Response Dispatch System based on the requirements above.
 *
 * EXPLANATION:
 * This solution implements the Emergency Response Dispatch System as described, fulfilling all the requirements.
 * 
 * 1.  **`EmergencyUnit` Class:** This class models a single response unit. It uses `private` fields (`unitId`, `isAvailable`), a constructor, public getters, and a public setter (`setAvailable`) to demonstrate proper encapsulation. The `toString()` method provides a user-friendly representation, adhering to best practices for object representation.
 * 
 * 2.  **`EmergencyDispatchSystem` Class:**
 *     *   **Data Structures:**
 *         *   `Queue<String> incomingCalls = new LinkedList<>();`: A `LinkedList` is used because it implements the `Queue` interface and is efficient for adding/removing elements from the ends, which is typical queue behavior (FIFO).
 *         *   `List<EmergencyUnit> responseUnits = new ArrayList<>();`: An `ArrayList` is used because it implements the `List` interface and provides dynamic resizing and efficient element access by index (though we primarily iterate here, `ArrayList` is a common and suitable `List` implementation). The variable is declared as `List` to program against the interface, a good practice.
 *     *   **Initialization:** The constructor creates a fixed number of `EmergencyUnit` objects and adds them to the `responseUnits` list.
 *     *   **Scanner and Menu:** A `Scanner` is used for reading user input. The `displayMenu()` method presents options, and the `run()` method contains the main loop that reads input and uses a `switch` statement to direct the program flow based on the user's choice. Reading input as a `String` first (`scanner.nextLine()`) and then parsing it is a robust way to handle potential `InputMismatchException` when the user enters non-integer input, allowing the `NumberFormatException` catch block to handle it specifically.
 *     *   **Core Logic Methods:**
 *         *   `addCall()`: Demonstrates adding to the queue using `offer()`.
 *         *   `dispatchUnit()`: Shows how to check if the queue is empty (`isEmpty()`), iterate through the `List` to find an available unit, get and remove an element from the queue (`poll()`), and update an object's state (`setAvailable(false)`). It handles the cases where no calls or no units are available.
 *         *   `viewCalls()`: Iterates through the `Queue` using a for-each loop. This allows viewing elements without removing them, as required.
 *         *   `viewUnits()`: Iterates through the `List` to display the status of each unit using its `toString()` method.
 *         *   `markUnitAvailable()`: Demonstrates searching for an object within the `List` based on a property (`unitId`) and updating its state. It includes input parsing and validation for the unit ID.
 *     *   **Input Validation and Error Handling:**
 *         *   `try-catch (NumberFormatException)` is used specifically when parsing user input strings to integers (both for the menu choice and the unit ID). This correctly handles cases where the user types non-numeric input.
 *         *   `System.err.println()` is used to print specific error messages for invalid input (like non-numbers or invalid menu options) or operational errors (like unit not found).
 *         *   `System.out.println()` is used for all normal output, including the menu, prompts, success messages, and status displays.
 *         *   A general `try-catch (Exception e)` is included in the main `run` loop's inner `try` block. This provides a class-wide safety net to catch any unexpected exceptions that might occur during the execution of the menu options, preventing the program from crashing and printing an error message to `System.err`.
 *         *   Specific checks (`incomingCalls.isEmpty()`, iterating to find `availableUnit == null`, checking if a unit exists by ID) handle expected operational conditions gracefully with messages printed to `System.out` or `System.err` as appropriate.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block within the `run()` method's outer `try` block to ensure it's released when the program exits the loop, regardless of whether it's a normal exit or due to an exception caught within the loop.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, simulated scenario, demonstrating good programming practices like encapsulation, clear naming, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although parsing String to int handles this implicitly

/**
 * Represents an emergency response unit with an ID and availability status.
 */
class EmergencyUnit {
    private int unitId;
    private boolean isAvailable;

    /**
     * Constructs a new EmergencyUnit.
     * Initially, units are available.
     * @param unitId The unique identifier for the unit.
     */
    public EmergencyUnit(int unitId) {
        this.unitId = unitId;
        this.isAvailable = true; // Units start as available
    }

    /**
     * Gets the ID of the unit.
     * @return The unit ID.
     */
    public int getUnitId() {
        return unitId;
    }

    /**
     * Checks if the unit is currently available.
     * @return true if the unit is available, false otherwise.
     */
    public boolean isAvailable() {
        return isAvailable;
    }

    /**
     * Sets the availability status of the unit.
     * @param available The new availability status (true for available, false for busy).
     */
    public void setAvailable(boolean available) {
        this.isAvailable = available;
    }

    /**
     * Provides a string representation of the unit's status.
     * @return A string like "Unit 1 (Available)" or "Unit 3 (Busy)".
     */
    @Override
    public String toString() {
        return "Unit " + unitId + " (" + (isAvailable ? "Available" : "Busy") + ")";
    }
}

/**
 * Simulates an Emergency Response Dispatch System.
 * Manages incoming calls in a queue and response units in a list.
 */
public class EmergencyDispatchSystem {
    private Queue<String> incomingCalls;
    private List<EmergencyUnit> responseUnits;
    private Scanner scanner;
    private static final int NUMBER_OF_UNITS = 5; // Fixed number of initial units

    /**
     * Constructs the EmergencyDispatchSystem.
     * Initializes data structures and creates response units.
     */
    public EmergencyDispatchSystem() {
        // Use LinkedList as a concrete implementation of Queue
        incomingCalls = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        responseUnits = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Initialize response units
        for (int i = 1; i <= NUMBER_OF_UNITS; i++) {
            responseUnits.add(new EmergencyUnit(i));
        }

        System.out.println("Emergency Dispatch System Initialized with " + NUMBER_OF_UNITS + " units.");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Emergency Dispatch System ---");
        System.out.println("1. Receive New Call");
        System.out.println("2. Dispatch Unit to Next Call");
        System.out.println("3. View Pending Calls");
        System.out.println("4. View Response Units Status");
        System.out.println("5. Mark Unit as Available");
        System.out.println("0. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a new emergency call to the queue.
     */
    private void addCall() {
        System.out.print("Enter call details: ");
        String callDetails = scanner.nextLine();
        incomingCalls.offer(callDetails); // offer is generally preferred over add for queues
        System.out.println("Call received and added to queue.");
    }

    /**
     * Dispatches an available unit to the next pending call.
     */
    private void dispatchUnit() {
        if (incomingCalls.isEmpty()) {
            System.out.println("No pending calls in the queue.");
            return;
        }

        EmergencyUnit availableUnit = null;
        // Find the first available unit in the list
        for (EmergencyUnit unit : responseUnits) {
            if (unit.isAvailable()) {
                availableUnit = unit;
                break; // Found one, no need to check further
            }
        }

        if (availableUnit == null) {
            System.out.println("No response units currently available to dispatch.");
            return;
        }

        // Both call and unit are available, proceed with dispatch
        String callDetails = incomingCalls.poll(); // Get and remove the next call
        availableUnit.setAvailable(false); // Mark unit as busy

        System.out.println("Dispatching Unit...");
        System.out.println("Call details: " + callDetails);
        System.out.println("Dispatched " + availableUnit.toString() + " to handle the call.");
    }

    /**
     * Displays all pending calls in the queue without removing them.
     */
    private void viewCalls() {
        if (incomingCalls.isEmpty()) {
            System.out.println("No pending calls.");
            return;
        }

        System.out.println("--- Pending Calls ---");
        // Iterate through the queue without removing elements
        int index = 1;
        for (String call : incomingCalls) {
            System.out.println(index++ + ". " + call);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the status of all response units.
     */
    private void viewUnits() {
        System.out.println("--- Response Units Status ---");
        if (responseUnits.isEmpty()) {
             System.out.println("No response units configured.");
             return;
        }
        for (EmergencyUnit unit : responseUnits) {
            System.out.println(unit.toString());
        }
        System.out.println("-----------------------------");
    }

    /**
     * Marks a specific unit as available based on user input ID.
     */
    private void markUnitAvailable() {
        System.out.print("Enter Unit ID to mark available: ");
        String input = scanner.nextLine(); // Read input as string first

        try {
            int unitId = Integer.parseInt(input);
            EmergencyUnit targetUnit = null;

            // Find the unit by ID
            for (EmergencyUnit unit : responseUnits) {
                if (unit.getUnitId() == unitId) {
                    targetUnit = unit;
                    break;
                }
            }

            if (targetUnit == null) {
                System.err.println("Error: Unit with ID " + unitId + " not found.");
            } else {
                if (targetUnit.isAvailable()) {
                    System.out.println("Unit " + unitId + " is already available.");
                } else {
                    targetUnit.setAvailable(true);
                    System.out.println("Unit " + unitId + " is now marked as Available.");
                }
            }

        } catch (NumberFormatException e) {
            // Handle cases where the input is not a valid integer
            System.err.println("Error: Invalid input. Please enter a valid number for the Unit ID.");
            // e.printStackTrace(); // For debugging, could be removed in final exam
        }
    }

    /**
     * Runs the main dispatch system loop.
     * Handles user interaction and delegates to appropriate methods.
     */
    public void run() {
        int choice = -1; // Initialize with a value that won't exit immediately

        // Class-wide exception handling within the main loop
        try {
            while (choice != 0) {
                displayMenu();
                String input = scanner.nextLine(); // Read line to handle non-integer input gracefully

                try {
                    choice = Integer.parseInt(input); // Attempt to parse the input

                    // Use switch for menu control flow
                    switch (choice) {
                        case 1:
                            addCall();
                            break;
                        case 2:
                            dispatchUnit();
                            break;
                        case 3:
                            viewCalls();
                            break;
                        case 4:
                            viewUnits();
                            break;
                        case 5:
                            markUnitAvailable();
                            break;
                        case 0:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            // Handle choices outside the defined range
                            System.err.println("Error: Invalid menu choice. Please enter a number from 0 to 5.");
                    }
                } catch (NumberFormatException e) {
                    // Catch specific exception for invalid number format
                    System.err.println("Error: Invalid input. Please enter a number for the menu choice.");
                    // choice remains -1, loop continues
                } catch (Exception e) {
                     // Catch any other unexpected exceptions during operation execution
                     System.err.println("An unexpected error occurred: " + e.getMessage());
                     // e.printStackTrace(); // Useful for debugging during development
                }
            }
        } finally {
            // Ensure the scanner is closed when the application exits or loop breaks
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the Emergency Dispatch System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EmergencyDispatchSystem system = new EmergencyDispatchSystem();
        system.run();
    }
}
