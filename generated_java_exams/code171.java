/*
 * Exam Question #171
 * Generated on: 2025-05-11 22:25:42
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are required to develop a simple console-based application to manage tasks. The system should simulate a basic workflow where tasks are added, processed one by one in the order they were added, and then marked as complete.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a public class named `Task`.
 *     *   The `Task` class must have a private `String` field named `description` to store the task details.
 *     *   Provide a public constructor `Task(String description)` to initialize the task.
 *     *   Provide a public getter method `getDescription()` for the `description` field.
 *     *   Override the `toString()` method to return a user-friendly string representation of the task (e.g., "Task: [description]").
 * 
 * 2.  **Task Management System:**
 *     *   Create a public class named `TaskProcessingSystem`.
 *     *   This class will manage the collection of tasks.
 *     *   It must have a private field to store **pending tasks** using a `java.util.Queue<Task>`. Initialize this using `java.util.LinkedList`.
 *     *   It must have a private field to store **completed tasks** using a `java.util.List<Task>`. Initialize this using `java.util.ArrayList`, ensuring the field is declared with the `List` interface type.
 *     *   It must have a private field for a `java.util.Scanner` to read user input from `System.in`.
 * 
 * 3.  **Menu and User Interaction:**
 *     *   Implement a console-based menu within the `TaskProcessingSystem` using a loop that continues until the user chooses to exit.
 *     *   The menu should present the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's integer input corresponding to the menu choice.
 * 
 * 4.  **Functionality Implementation:**
 *     *   **Add New Task:** Prompt the user to enter a task description. Create a new `Task` object and add it to the pending tasks queue.
 *     *   **Process Next Task:** Remove the next task from the head of the pending queue and add it to the completed tasks list.
 *     *   **View Pending Tasks:** Iterate through the pending tasks queue and display each task's description.
 *     *   **View Completed Tasks:** Iterate through the completed tasks list and display each task's description.
 *     *   **Exit:** Terminate the program gracefully.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   **Input Validation:**
 *         *   When adding a task, check if the entered description is empty or contains only whitespace. If so, display an error message using `System.err.println()` and do not add the task.
 *         *   Handle cases where the user enters non-integer input for the menu choice. Use a `try-catch` block specifically for `java.util.InputMismatchException`, print an error message using `System.err.println()`, and ensure the scanner recovers to accept the next input.
 *         *   Handle invalid menu choices (numbers outside the range 1-5) in the `default` case of the `switch` statement, displaying an error message using `System.err.println()`.
 *     *   **Operational Error Handling:**
 *         *   If the user attempts to "Process Next Task" when the pending queue is empty, display an error message using `System.err.println()`.
 *         *   If the user attempts to "View Pending Tasks" or "View Completed Tasks" when the respective collection is empty, display a user-friendly message using `System.out.println()` indicating that there are no tasks to display.
 *     *   **General Exception Handling:** Implement class-wide exception handling using a `try-catch` block that wraps the main loop controlling the menu interaction. This block should catch general `Exception` and print an informative error message to `System.err.println()`, including the exception's message, and potentially the stack trace for debugging purposes.
 * 
 * 6.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, successful operation messages, and task listings.
 *     *   Use `System.err.println()` for all error messages (validation errors, operational errors, unexpected exceptions).
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public/private methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments (e.g., Javadoc-style or inline comments) to explain the code.
 *     *   Ensure the `Scanner` resource is properly closed when the program exits.
 *     *   Structure the code logically into methods for each menu option and a main method to start the system.
 * 
 * **Expected Execution Flow Example:**
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare lecture slides
 * Task added to pending queue.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Grade assignments
 * Task added to pending queue.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Prepare lecture slides
 * 2. Grade assignments
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Prepare lecture slides
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Grade assignments
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Prepare lecture slides
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Grade assignments
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Prepare lecture slides
 * 2. Grade assignments
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should consist of the `Task` class and the `TaskProcessingSystem` class.
 *
 * EXPLANATION:
 * The provided solution implements a console-based Task Management System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **`Task` Class:** This simple class serves as a Plain Old Java Object (POJO) to represent a task. It encapsulates the task's `description` using a private field and provides a public getter and a helpful `toString()` method for display.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core class managing the system's state and logic.
 *     *   **Data Structures:**
 *         *   `private Queue<Task> pendingTasks;`: A `Queue` is used for pending tasks because it naturally supports the First-In, First-Out (FIFO) processing order required by the "Process Next Task" operation. `java.util.LinkedList` is a common implementation of the `Queue` interface in Java and is used here.
 *         *   `private List<Task> completedTasks;`: A `List` is used for completed tasks to maintain the order of completion and allow easy iteration. The field is declared using the `List` interface type, promoting good practice of programming to interfaces. `java.util.ArrayList` is used for the concrete implementation.
 *     *   **`Scanner`:** `private Scanner scanner;` is used to read input from the console (`System.in`). It is initialized in the constructor.
 *     *   **Encapsulation:** All data fields (`pendingTasks`, `completedTasks`, `scanner`) are kept private, and interaction is managed through public or private methods, adhering to encapsulation principles.
 * 
 * 3.  **Menu and `switch` Statement:**
 *     *   The `displayMenu()` method prints the available options to `System.out`.
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   User input for the menu choice is read using `scanner.nextInt()`.
 *     *   A `switch` statement is used to direct the program flow based on the integer `choice` entered by the user, calling the appropriate private method (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) or setting the `running` flag to `false` for the "Exit" option. The `default` case handles invalid number inputs.
 * 
 * 4.  **Functionality:** Each menu option corresponds to a private method within `TaskProcessingSystem`:
 *     *   `addTask()`: Reads the description, validates it, creates a `Task` object, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. If a task is returned (not `null`), it's added to the `completedTasks` list.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue using an enhanced for loop (which doesn't remove elements) and prints each task's description.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list and prints each task's description.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   **Input Validation:**
 *         *   `addTask()` checks `description.isEmpty()` after trimming whitespace. If empty, an error is printed to `System.err`.
 *         *   A `try-catch(InputMismatchException e)` block is specifically placed around `scanner.nextInt()` within the main loop. If the user enters non-integer text, this block catches the exception, prints an error to `System.err`, and `scanner.next()` consumes the invalid input token to prevent an infinite loop. `continue` skips the rest of the current loop iteration, prompting for input again.
 *         *   The `default` case of the `switch` handles integer inputs outside the 1-5 range, printing an error to `System.err`.
 *     *   **Operational Error Handling:**
 *         *   `processNextTask()` checks if `pendingTasks.poll()` returns `null` (indicating an empty queue) and prints an error to `System.err` if so.
 *         *   `viewPendingTasks()` and `viewCompletedTasks()` check if their respective collections are empty using `isEmpty()` and print informational messages to `System.out`.
 *     *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the entire `while(running)` loop in the `run()` method. This provides a safety net to catch any unexpected runtime exceptions that might occur during the execution of the chosen menu action, printing a generic error message and the stack trace to `System.err`.
 * 
 * 6.  **Output Streams:**
 *     *   `System.out.println()` is used for standard messages like the menu, task added/processed confirmations, and task listings.
 *     *   `System.err.println()` is exclusively used for all error conditions, making error messages distinct from normal output.
 * 
 * 7.  **Best Practices:**
 *     *   Encapsulation is applied as described above.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`).
 *     *   Javadoc-style comments are included for classes and methods, explaining their purpose. Inline comments clarify specific code points (like consuming the newline after `nextInt()`).
 *     *   The `finally` block in the `run()` method ensures that the `scanner.close()` method is called before the program terminates, releasing the system resource.
 *     *   The logic is structured into dedicated methods (`addTask`, `run`, etc.) for clarity and maintainability. The `main` method is kept minimal, just creating an instance and starting the `run` method.
 * 
 * This solution effectively demonstrates the required Java concepts and practices in a cohesive, practical application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 */
public class Task {
    private String description;

    /**
     * Constructs a new Task with the given description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return A string in the format "Task: [description]".
     */
    @Override
    public String toString() {
        return "Task: " + description;
    }
}

/**
 * A system for managing and processing tasks using a queue and a list.
 * Handles user interaction via console menu.
 */
public class TaskProcessingSystem {

    // Queue to hold tasks that are waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed, declared using the List interface
    private List<Task> completedTasks;
    // Scanner for reading user input from the console
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem, initializing the task collections and scanner.
     */
    public TaskProcessingSystem() {
        // LinkedList implements the Queue interface and is suitable for FIFO operations
        this.pendingTasks = new LinkedList<>();
        // ArrayList implements the List interface and is suitable for ordered storage
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts the user for a task description and adds a new task to the pending queue.
     * Includes input validation for the description.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(description);
        // offer() is used for adding to the queue, returning true on success
        pendingTasks.offer(newTask);
        System.out.println("Task added to pending queue.");
    }

    /**
     * Processes the next task from the pending queue (FIFO) and moves it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task nextTask = pendingTasks.poll();

        if (nextTask == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask.getDescription());
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Handles the case where the pending queue is empty.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate over the queue elements without removing them
            int i = 1;
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task.getDescription());
            }
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     * Handles the case where the completed list is empty.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            int i = 1;
            for (Task task : completedTasks) {
                System.out.println(i++ + ". " + task.getDescription());
            }
        }
    }

    /**
     * Runs the main loop of the Task Processing System, handling user interaction.
     * Includes class-wide exception handling and specific input handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block to catch unexpected exceptions during the system's operation
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Specific try-catch block for handling potential input errors (like non-integer)
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input from the scanner buffer to prevent infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop iteration and show the menu again
                }

                // Use switch statement to perform actions based on user choice
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Generic catch block for any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred during system operation: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for detailed debugging information
        } finally {
            // Ensure the scanner resource is closed properly when the system exits
            if (scanner != null) {
                scanner.close();
            }
            // System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * The main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run(); // Start the system's main loop
    }
}
