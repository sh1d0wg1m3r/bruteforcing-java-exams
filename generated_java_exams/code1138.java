/*
 * Exam Question #1138
 * Generated on: 2025-05-12 17:29:56
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Complex Java Programming Exam Task: Emergency Response Dispatch Simulation**
 * 
 * You are tasked with developing a simplified simulation of an emergency response dispatch system. This system will manage incoming emergency calls, queue them for dispatch, and track incidents that have been handled.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts and best practices.
 * 
 * **System Requirements:**
 * 
 * 1.  **Emergency Call Representation:** Create a class `EmergencyCall` with the following attributes:
 *     *   `id`: A unique integer identifier for the call.
 *     *   `description`: A string describing the emergency (e.g., "Traffic accident", "Fire alarm", "Medical emergency").
 *     *   `priority`: An integer indicating the urgency (e.g., 1 for highest, 5 for lowest).
 *     *   Implement appropriate private fields, public getters, and a constructor. Include a `toString()` method for easy printing.
 * 
 * 2.  **Dispatch System Logic:** Create a main class (e.g., `DispatchSystem`) that contains the core logic. This class must manage:
 *     *   A queue of pending `EmergencyCall` objects. Calls are added to the end of the queue and dispatched from the front.
 *     *   A list of `EmergencyCall` objects representing incidents that have been handled (dispatched).
 * 
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` to interact with the system. The system should present a menu of options to the user:
 *     *   **1. Receive New Call:** Prompt the user for the call description and priority. Create a new `EmergencyCall` object with a unique ID and add it to the queue of pending calls. Validate the priority input (must be between 1 and 5).
 *     *   **2. Dispatch Next Unit:** Take the next call from the front of the pending queue. If the queue is not empty, move the call to the list of handled incidents and report which call was dispatched. If the queue is empty, report that there are no pending calls.
 *     *   **3. List Pending Calls:** Display all calls currently in the pending queue, in the order they will be dispatched.
 *     *   **4. List Handled Incidents:** Display all calls that have been moved to the handled incidents list.
 *     *   **5. Exit:** Terminate the program.
 * 
 * 4.  **Required Java Features:** Your solution *must* explicitly use:
 *     *   `java.util.Queue` (specifically an implementation like `LinkedList` that implements `Queue`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (declare variables using the interface type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement for handling menu options.
 *     *   `System.err` for printing *all* error messages (e.g., invalid input, dispatching from an empty queue).
 *     *   `System.out` for printing normal output (menu, prompts, confirmations, list contents).
 *     *   Class-wide exception handling using `try-catch` blocks. This should include handling potential input errors (`InputMismatchException`, `NoSuchElementException` when polling from an empty queue) and a general catch for unexpected errors, printing errors to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation in the `EmergencyCall` class.
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 *     *   Perform input validation (especially for priority).
 *     *   Implement robust error handling as specified.
 *     *   Structure the code logically with separate methods for different operations within the `DispatchSystem` class.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting the menu, accepting user input, performing the requested actions, and providing appropriate output to `System.out` or error messages to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Emergency Response Dispatch System
 * Choose an action:
 * 1. Receive New Call
 * 2. Dispatch Next Unit
 * 3. List Pending Calls
 * 4. List Handled Incidents
 * 5. Exit
 * Enter your choice: 1
 * Enter call description: Medical emergency at Main St
 * Enter priority (1-5): 2
 * Call ID 1 received and added to queue.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 1
 * Enter call description: Fire alarm at Oak Ave
 * Enter priority (1-5): 1
 * Call ID 2 received and added to queue.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 3
 * --- Pending Calls ---
 * ID: 1, Description: Medical emergency at Main St, Priority: 2
 * ID: 2, Description: Fire alarm at Oak Ave, Priority: 1
 * ---------------------
 * 
 * Choose an action:
 * ...
 * Enter your choice: 2
 * Dispatching unit to Call ID 1: Medical emergency at Main St (Priority: 2)
 * Call ID 1 moved to handled incidents.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 3
 * --- Pending Calls ---
 * ID: 2, Description: Fire alarm at Oak Ave, Priority: 1
 * ---------------------
 * 
 * Choose an action:
 * ...
 * Enter your choice: 4
 * --- Handled Incidents ---
 * ID: 1, Description: Medical emergency at Main St, Priority: 2
 * -----------------------
 * 
 * Choose an action:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 2
 * Dispatching unit to Call ID 2: Fire alarm at Oak Ave (Priority: 1)
 * Call ID 2 moved to handled incidents.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 2
 * Error: No pending calls to dispatch.
 * 
 * Choose an action:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 *
 * EXPLANATION:
 * This solution implements a basic Emergency Response Dispatch System, fulfilling all the requirements of the task.
 * 
 * 1.  **`EmergencyCall` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) to model an emergency call.
 *     *   It uses `private` fields (`id`, `description`, `priority`) to enforce encapsulation.
 *     *   `public` getter methods provide controlled access to the data.
 *     *   The constructor initializes these fields.
 *     *   The `toString()` method provides a convenient way to print call details.
 * 
 * 2.  **`DispatchSystem` Class:**
 *     *   This is the main class orchestrating the simulation.
 *     *   **Data Structures:**
 *         *   `Queue<EmergencyCall> pendingCalls = new LinkedList<>();`: A `Queue` is used to store calls awaiting dispatch. The `LinkedList` implementation is suitable for efficient additions (`offer`) and removals (`poll`) from the ends, which is characteristic of a queue (FIFO - First-In, First-Out). We declare it using the `Queue` interface type as required.
 *         *   `List<EmergencyCall> handledIncidents = new ArrayList<>();`: An `ArrayList` is used to store calls once they have been dispatched. An `ArrayList` provides dynamic resizing and efficient access/iteration, suitable for keeping a history of handled items. We declare it using the `List` interface type as required.
 *     *   **ID Generation:** `nextCallId` is a simple counter to ensure each `EmergencyCall` gets a unique ID.
 *     *   **Methods:**
 *         *   `receiveNewCall()`: Creates a new `EmergencyCall`, performs input validation on priority and description, and adds it to the `pendingCalls` queue using `offer()`. `offer()` is preferred over `add()` for queues as it handles capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained).
 *         *   `dispatchNextUnit()`: Removes the head of the `pendingCalls` queue using `poll()`. `poll()` is preferred over `remove()` as it returns `null` if the queue is empty, which is handled gracefully in the calling code, whereas `remove()` would throw a `NoSuchElementException`. If a call is retrieved, it's added to the `handledIncidents` list using `add()`.
 *         *   `listPendingCalls()`: Iterates through the `pendingCalls` queue to display its contents without removing elements.
 *         *   `listHandledIncidents()`: Iterates through the `handledIncidents` list to display its contents.
 *         *   `displayMenu()`: A helper method to print the user menu.
 *     *   **`main()` Method:**
 *         *   Initializes the `DispatchSystem` and `Scanner`.
 *         *   Contains the main application loop (`while(running)`).
 *         *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the entire `while` loop. This serves as a top-level handler for any unhandled exceptions that might occur during the system's execution, printing the error to `System.err` and the stack trace. The `finally` block ensures the `Scanner` is closed.
 *         *   **Input Handling & Validation:** Inside the loop, specific `try-catch` blocks handle expected input issues:
 *             *   `InputMismatchException` is caught when reading the main menu choice and when reading the priority for a new call, preventing the program from crashing on non-integer input. Error messages are printed to `System.err`, and `scanner.nextLine()` is used to consume the invalid input line, preventing an infinite loop.
 *             *   `IllegalArgumentException` is caught from `receiveNewCall` if the priority is out of range or the description is empty/null, printing the specific validation error message to `System.err`.
 *             *   `NoSuchElementException` is included in a `try-catch` block around the dispatch operation as requested, although `poll()`'s behavior makes it less likely to be thrown here compared to `remove()`. The code explicitly checks for the `null` return from `poll()` to handle the empty queue case with a specific error message printed to `System.err`.
 *         *   **Flow Control:** A `switch` statement is used to process the user's valid menu choice (`1` through `5`), directing execution to the appropriate method calls or the exit logic. The `default` case handles invalid numeric choices, printing an error to `System.err`.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical simulation, demonstrating object-oriented principles (encapsulation), input validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents an emergency call received by the dispatch system.
 */
class EmergencyCall {
    private int id;
    private String description;
    private int priority; // 1 (highest) to 5 (lowest)

    /**
     * Constructs a new EmergencyCall.
     * @param id The unique identifier for the call.
     * @param description A description of the emergency.
     * @param priority The priority level (1-5).
     */
    public EmergencyCall(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the EmergencyCall.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %d",
                             id, description, priority);
    }
}

/**
 * Simulates an emergency response dispatch system.
 * Manages pending calls in a queue and handled incidents in a list.
 */
public class DispatchSystem {

    // Use Queue interface, backed by LinkedList
    private Queue<EmergencyCall> pendingCalls;
    // Use List interface, backed by ArrayList
    private List<EmergencyCall> handledIncidents;
    private int nextCallId; // To generate unique IDs

    /**
     * Constructs a new DispatchSystem.
     * Initializes the collections and the call ID counter.
     */
    public DispatchSystem() {
        this.pendingCalls = new LinkedList<>(); // Queue implementation
        this.handledIncidents = new ArrayList<>(); // List implementation
        this.nextCallId = 1; // Start IDs from 1
    }

    /**
     * Adds a new emergency call to the pending queue.
     * @param description The description of the call.
     * @param priority The priority of the call (1-5).
     * @return The newly created EmergencyCall object.
     */
    public EmergencyCall receiveNewCall(String description, int priority) {
        // Input validation for priority
        if (priority < 1 || priority > 5) {
            throw new IllegalArgumentException("Priority must be between 1 and 5.");
        }
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Description cannot be empty.");
        }

        EmergencyCall newCall = new EmergencyCall(nextCallId++, description.trim(), priority);
        pendingCalls.offer(newCall); // Use offer() for Queue insertion
        return newCall;
    }

    /**
     * Dispatches the next pending call.
     * Removes the call from the queue and adds it to the handled list.
     * @return The dispatched EmergencyCall, or null if the queue was empty.
     */
    public EmergencyCall dispatchNextUnit() {
        EmergencyCall callToDispatch = pendingCalls.poll(); // Use poll() for Queue removal

        if (callToDispatch != null) {
            handledIncidents.add(callToDispatch); // Add to the handled list
            return callToDispatch;
        } else {
            // Queue is empty, will return null
            return null;
        }
    }

    /**
     * Displays all pending calls currently in the queue.
     */
    public void listPendingCalls() {
        System.out.println("--- Pending Calls ---");
        if (pendingCalls.isEmpty()) {
            System.out.println("No pending calls.");
        } else {
            // Iterate through the queue without removing elements
            for (EmergencyCall call : pendingCalls) {
                System.out.println(call);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all handled incidents currently in the list.
     */
    public void listHandledIncidents() {
        System.out.println("--- Handled Incidents ---");
        if (handledIncidents.isEmpty()) {
            System.out.println("No handled incidents yet.");
        } else {
            // Iterate through the list
            for (EmergencyCall call : handledIncidents) {
                System.out.println(call);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nEmergency Response Dispatch System");
        System.out.println("Choose an action:");
        System.out.println("1. Receive New Call");
        System.out.println("2. Dispatch Next Unit");
        System.out.println("3. List Pending Calls");
        System.out.println("4. List Handled Incidents");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main method to run the dispatch system simulation.
     * Contains the main application loop and handles user interaction.
     */
    public static void main(String[] args) {
        DispatchSystem system = new DispatchSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                system.displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt(); // Read user choice
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter call description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (1-5): ");
                        try {
                            int priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            EmergencyCall newCall = system.receiveNewCall(description, priority);
                            System.out.println("Call ID " + newCall.getId() + " received and added to queue.");
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid priority input. Please enter an integer between 1 and 5.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (IllegalArgumentException e) {
                             System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 2:
                        try {
                            EmergencyCall dispatchedCall = system.dispatchNextUnit();
                            if (dispatchedCall != null) {
                                System.out.println("Dispatching unit to " + dispatchedCall);
                                System.out.println("Call ID " + dispatchedCall.getId() + " moved to handled incidents.");
                            } else {
                                // Handled case where poll() returns null
                                System.err.println("Error: No pending calls to dispatch.");
                            }
                         // NoSuchElementException is less likely with poll(), but good practice
                         // if using remove() or element() on an empty queue.
                         // Keeping it here as requested for demonstration, though poll() handles empty queue.
                        } catch (NoSuchElementException e) {
                            System.err.println("Error: Attempted to dispatch from an empty queue.");
                        }
                        break;

                    case 3:
                        system.listPendingCalls();
                        break;

                    case 4:
                        system.listHandledIncidents();
                        break;

                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;

                    default:
                        // Handle choices outside the 1-5 range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // General catch for any unexpected errors during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
