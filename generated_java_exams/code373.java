/*
 * Exam Question #373
 * Generated on: 2025-05-11 23:01:47
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Task Scheduling and Execution Simulator**
 * 
 * You are tasked with building a simple command-line based simulator for managing and executing tasks. The system should allow users to add tasks to a queue, execute the next task in the queue, and view a history of all tasks that have been executed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Definition:** Create a class named `Task` with the following properties:
 *     *   `taskId` (String): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `type` (String): Represents the task type (e.g., "SHORT", "LONG", "URGENT").
 *     *   Implement a constructor to initialize these properties.
 *     *   Implement a `toString()` method that provides a clear representation of the task.
 *     *   Implement a method `execute()` that simulates task execution (e.g., prints a message like "Executing Task [ID]: [Description]").
 * 
 * 2.  **Scheduler Logic:** Create a class named `TaskScheduler` that manages the task queue and execution history.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks waiting to be executed.
 *     *   It must use a `java.util.List<Task>` (specifically, an `ArrayList<Task>`) to store tasks after they have been executed.
 *     *   Implement a method `addTask(Task task)` that adds a task to the waiting queue.
 *     *   Implement a method `executeNextTask()` that removes the task at the front of the queue, calls its `execute()` method, and adds it to the execution history. This method should handle the case where the queue is empty.
 *     *   Implement a method `viewHistory()` that prints the details of all tasks in the execution history.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method (or a method called by main) that interacts with the `TaskScheduler`.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Support the following commands:
 *         *   `add <id> <type> <description>`: Creates a new `Task` object and adds it to the scheduler's queue. `<description>` can contain spaces but should be the rest of the line after the type.
 *         *   `execute`: Executes the next task in the queue.
 *         *   `history`: Displays the execution history.
 *         *   `exit`: Terminates the program.
 *     *   Use a `switch` statement to process the different commands.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for normal program output (prompts, success messages, history listing, task execution messages).
 *     *   Use `System.err` for error messages (e.g., invalid command format, queue is empty when `execute` is called).
 *     *   Implement input validation for the `add` command (check if enough arguments are provided).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., issues with scanner input, unexpected nulls, although the design should minimize these). A single `try-catch` around the main command processing loop is acceptable for this exam.
 * 
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods) in both `Task` and `TaskScheduler`.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure the code clearly.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Enter command (add, execute, history, exit):
 * add task1 SHORT Do a quick check
 * Task added: Task [ID: task1, Type: SHORT, Description: Do a quick check]
 * Enter command (add, execute, history, exit):
 * add task2 LONG Compile the project
 * Task added: Task [ID: task2, Type: LONG, Description: Compile the project]
 * Enter command (add, execute, history, exit):
 * execute
 * Executing Task [ID: task1]: Do a quick check
 * Task task1 executed and moved to history.
 * Enter command (add, execute, history, exit):
 * execute
 * Executing Task [ID: task2]: Compile the project
 * Task task2 executed and moved to history.
 * Enter command (add, execute, history, exit):
 * execute
 * Error: Task queue is empty. No tasks to execute.
 * Enter command (add, execute, history, exit):
 * history
 * --- Execution History ---
 * Task [ID: task1, Type: SHORT, Description: Do a quick check]
 * Task [ID: task2, Type: LONG, Description: Compile the project]
 * -------------------------
 * Enter command (add, execute, history, exit):
 * add
 * Error: Invalid 'add' command format. Usage: add <id> <type> <description>
 * Enter command (add, execute, history, exit):
 * unknown_command
 * Error: Unknown command. Please use add, execute, history, or exit.
 * Enter command (add, execute, history, exit):
 * exit
 * Exiting Task Scheduler.
 * ```
 * 
 * Implement the Java code for the `Task` and `TaskScheduler` classes to fulfill these requirements.
 *
 * EXPLANATION:
 * The solution implements a `Task Scheduling and Execution Simulator` as requested, demonstrating the use of all specified Java components in a practical scenario.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data and behavior of a single task.
 *     *   **Encapsulation:** `taskId`, `description`, and `type` are private fields, accessed via public getter methods.
 *     *   **`execute()` method:** Simulates the task's work, fulfilling the requirement for a task behavior.
 *     *   **`toString()` method:** Provides a convenient string representation for printing task details.
 * 
 * 2.  **`TaskScheduler` Class:** This class manages the core logic of the simulator.
 *     *   **`Queue<Task>`:** The `taskQueue` field is declared as a `Queue` interface type but initialized with `LinkedList`. This demonstrates using the interface type for flexibility while using a concrete implementation. The `offer()` method is used for adding tasks, and `poll()` for removing, which are standard `Queue` operations that handle capacity constraints gracefully (though not relevant in this unbounded `LinkedList`).
 *     *   **`List<Task>` / `ArrayList<Task>`:** The `executionHistory` field is declared as a `List` interface type and initialized with `ArrayList`. This again shows the use of the interface type. `ArrayList` is a suitable choice for storing history where elements are added to the end and iterated over.
 *     *   **`addTask()`, `executeNextTask()`, `viewHistory()` methods:** These public methods provide the interface for interacting with the scheduler's internal state (`taskQueue` and `executionHistory`), adhering to encapsulation.
 *     *   **Error Handling in `executeNextTask()`:** It checks if `poll()` returned `null` (meaning the queue was empty) and prints an error message to `System.err` instead of crashing or attempting to execute a non-existent task.
 * 
 * 3.  **User Interface (`main` method):**
 *     *   **`Scanner`:** An instance of `Scanner` reads input from `System.in`.
 *     *   **Input Parsing:** The input line is split into parts. A limit of 4 is used in `split("\\s+", 4)` for the `add` command to ensure that the description (the 4th part) captures the rest of the line, including spaces.
 *     *   **`switch` Statement:** The parsed command (converted to lowercase for case-insensitivity) is processed using a `switch` statement, directing control flow to the appropriate logic based on the user's input (`add`, `execute`, `history`, `exit`).
 *     *   **Input Validation (`add` command):** Before attempting to create a `Task`, the code checks if the `parts` array has at least 4 elements, ensuring the user provided ID, type, and at least some description. An error message is printed to `System.err` if the format is incorrect.
 *     *   **`System.out` and `System.err`:** Used throughout for clear separation of normal output (prompts, success, history, execution) and error messages (invalid command, empty queue, invalid format).
 * 
 * 4.  **Class-wide Exception Handling:**
 *     *   A `try-catch(Exception e)` block wraps the main `while(running)` loop. This provides a safety net for any unexpected exceptions that might occur during the command processing or method calls within the loop. While more granular exception handling is often preferred in production code, this structure fulfills the requirement for a class-wide handler around the core logic for an exam context.
 *     *   A `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used consistently.
 *     *   **Naming:** Variable names (`taskId`, `taskQueue`, `inputLine`, `command`) and method names (`addTask`, `executeNextTask`, `viewHistory`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific code logic (like the `split` limit).
 *     *   **Code Structure:** The code is divided into logical classes (`Task`, `TaskScheduler`) with a clear entry point (`main`).
 * 
 * This solution effectively combines multiple core Java concepts to create a functional and robust command-line application, suitable for evaluating an intermediate to advanced understanding of Java programming.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays;

/**
 * Represents a single task in the scheduling system.
 */
class Task {
    private String taskId;
    private String description;
    private String type; // e.g., "SHORT", "LONG", "URGENT"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param type The type of the task.
     * @param description The description of the task.
     */
    public Task(String taskId, String type, String description) {
        this.taskId = taskId;
        this.description = description;
        this.type = type;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public String getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task type.
     * @return The task type.
     */
    public String getType() {
        return type;
    }

    /**
     * Simulates the execution of the task.
     */
    public void execute() {
        System.out.println("Executing Task [ID: " + taskId + "]: " + description);
        // In a real system, this would contain actual task logic
    }

    /**
     * Returns a string representation of the task.
     * @return A string representation.
     */
    @Override
    public String toString() {
        return "Task [ID: " + taskId + ", Type: " + type + ", Description: " + description + "]";
    }
}

/**
 * Manages a queue of tasks and an execution history.
 */
public class TaskScheduler { // Made public for the main method
    private Queue<Task> taskQueue;
    private List<Task> executionHistory;

    /**
     * Constructs a new TaskScheduler, initializing the queue and history.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.executionHistory = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a task to the waiting queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        taskQueue.offer(task); // offer is preferred over add for queues
        System.out.println("Task added: " + task);
    }

    /**
     * Executes the next task in the queue.
     * If the queue is empty, prints an error message.
     * Moves the executed task to the history.
     */
    public void executeNextTask() {
        Task nextTask = taskQueue.poll(); // poll returns null if queue is empty
        if (nextTask != null) {
            nextTask.execute();
            executionHistory.add(nextTask);
            System.out.println("Task " + nextTask.getTaskId() + " executed and moved to history.");
        } else {
            System.err.println("Error: Task queue is empty. No tasks to execute.");
        }
    }

    /**
     * Displays the history of executed tasks.
     * If history is empty, prints a message.
     */
    public void viewHistory() {
        System.out.println("--- Execution History ---");
        if (executionHistory.isEmpty()) {
            System.out.println("No tasks have been executed yet.");
        } else {
            for (Task task : executionHistory) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Main method to run the Task Scheduler simulator.
     * Handles user input and command processing.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.println("Enter command (add, execute, history, exit):");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Skip empty lines
                }

                String[] parts = inputLine.split("\\s+", 4); // Split by whitespace, limit to 4 parts
                String command = parts[0].toLowerCase();

                switch (command) {
                    case "add":
                        if (parts.length >= 4) {
                            String taskId = parts[1];
                            String taskType = parts[2];
                            String taskDescription = parts[3]; // The rest of the line
                            Task newTask = new Task(taskId, taskType, taskDescription);
                            scheduler.addTask(newTask);
                        } else {
                            System.err.println("Error: Invalid 'add' command format. Usage: add <id> <type> <description>");
                        }
                        break;

                    case "execute":
                        scheduler.executeNextTask();
                        break;

                    case "history":
                        scheduler.viewHistory();
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Scheduler.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please use add, execute, history, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
