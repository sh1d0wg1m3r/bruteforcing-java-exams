/*
 * Exam Question #539
 * Generated on: 2025-05-11 23:26:32
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Objective:** Implement a simplified restaurant order management system demonstrating core Java data structures, control flow, and error handling.
 * 
 * **Scenario:** You are building a basic system for a restaurant to manage incoming and completed food orders. New orders arrive and are placed in a queue to be processed by the kitchen. Once an order is prepared, it is moved to a list of completed orders. The system should allow users (simulating restaurant staff) to interact via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store orders that are pending processing.
 *     *   Use a `java.util.List` (specifically implemented as `java.util.ArrayList`) to store orders that have been completed.
 * 2.  **Order Representation:** Create a simple class `RestaurantOrder` to represent an order. It should contain:
 *     *   A unique order ID (an integer).
 *     *   A description of the items ordered (a String).
 *     *   A status (e.g., "Pending", "Completed").
 *     *   Ensure proper encapsulation (private fields, public getters).
 * 3.  **System Functionality:** The system should support the following operations via a command-line menu:
 *     *   **Place New Order:** Prompt the user for order details (items), create a `RestaurantOrder` object, and add it to the pending orders queue. Assign a unique ID (e.g., sequentially).
 *     *   **Process Next Order:** Take the oldest order from the pending orders queue, update its status to "Completed", and move it to the completed orders list. If there are no pending orders, inform the user.
 *     *   **View Pending Orders:** Display all orders currently in the pending queue, in the order they were received.
 *     *   **View Completed Orders:** Display all orders that have been processed and moved to the completed list.
 *     *   **Exit:** Terminate the application.
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input (menu choices and order details).
 *     *   Display a clear menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, successful operation messages, and listing orders.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, no pending orders to process, input errors).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (like invalid input format) during the main program loop.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc where necessary to explain complex parts.
 *     *   Validate user input where appropriate (e.g., ensuring menu choice is a number within range).
 *     *   Ensure the `Scanner` resource is properly managed (closed).
 * 
 * **Expected Output:**
 * The program should display a menu, accept user input, perform the requested action, and provide feedback. Error messages should go to standard error, and normal output to standard output.
 * 
 * Example Interaction Flow:
 * ```
 * Restaurant Order Management System
 * Please choose an option:
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter order items: Burger and Fries
 * Order 1 placed: Burger and Fries (Pending)
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 1
 * Enter order items: Pizza
 * Order 2 placed: Pizza (Pending)
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 3
 * --- Pending Orders ---
 * Order 1: Burger and Fries (Pending)
 * Order 2: Pizza (Pending)
 * ----------------------
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 2
 * Processing order 1: Burger and Fries (Pending)
 * Order 1 completed.
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 3
 * --- Pending Orders ---
 * Order 2: Pizza (Pending)
 * ----------------------
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 4
 * --- Completed Orders ---
 * Order 1: Burger and Fries (Completed)
 * ------------------------
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: abc
 * java.util.InputMismatchException: Invalid input. Please enter a number.
 * (This or similar error message should appear on System.err, followed by the menu again)
 * 
 * Restaurant Order Management System
 * Please choose an option:
 * ...
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * **Constraints:**
 * *   Focus on demonstrating the required components.
 * *   Keep the `RestaurantOrder` class simple.
 * *   The system does not need persistence (data is lost when the program ends).
 * 
 * **Task:** Write the complete Java code for this Restaurant Order Management System.
 *
 * EXPLANATION:
 * This solution implements a basic Restaurant Order Management System using the required Java components and following best practices.
 * 
 * **RestaurantOrder Class:**
 * *   Represents an individual order with `orderId`, `items`, and `status`.
 * *   `nextOrderId` is a static field to ensure each new order gets a unique, sequential ID.
 * *   Private fields and public getters/setters demonstrate encapsulation.
 * *   The `toString()` method provides a convenient string representation for printing.
 * 
 * **RestaurantManagementSystem Class:**
 * *   **Data Structures:**
 *     *   `pendingOrders`: Declared as `Queue<RestaurantOrder>` and initialized as a `LinkedList`. `LinkedList` is chosen because it efficiently implements the `Queue` interface (offering FIFO behavior for adding/removing elements at the ends). Orders are added using `offer()` and removed using `poll()`.
 *     *   `completedOrders`: Declared as `List<RestaurantOrder>` and initialized as an `ArrayList`. `ArrayList` is suitable for storing completed orders where we might need to iterate through them or potentially access them by index (though simple iteration is used here). Orders are added using `add()`.
 * *   **Scanner:** A `Scanner` object is created to read input from `System.in`. It's initialized in the constructor and closed when the main loop finishes to prevent resource leaks.
 * *   **`run()` Method:**
 *     *   This method contains the main application loop (`while (choice != 5)`).
 *     *   It repeatedly displays the menu and prompts for user input.
 *     *   **Exception Handling:** A `try-catch` block surrounds the core logic within the loop.
 *         *   `catch (InputMismatchException e)` specifically handles cases where `scanner.nextInt()` fails because the user entered non-integer input. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   `catch (Exception e)` is a general catch-all for any other unexpected runtime exceptions that might occur, printing the error message and stack trace to `System.err`.
 *     *   **Switch Statement:** A `switch` statement is used to direct execution based on the user's integer choice, calling the appropriate private helper method (`placeOrder`, `processNextOrder`, etc.). The `default` case handles invalid numerical input.
 * *   **Helper Methods (`displayMenu`, `placeOrder`, `processNextOrder`, `viewPendingOrders`, `viewCompletedOrders`):**
 *     *   These private methods encapsulate the logic for each menu option, promoting modularity and readability.
 *     *   `placeOrder()`: Reads order items, creates a `RestaurantOrder`, and adds it to the `pendingOrders` queue using `offer()`. Includes basic validation for empty input.
 *     *   `processNextOrder()`: Uses `poll()` to get and remove the next order from the `pendingOrders` queue. It checks if `poll()` returned `null` (meaning the queue was empty) and prints an error to `System.err` if so. Otherwise, it updates the order's status and adds it to the `completedOrders` list.
 *     *   `viewPendingOrders()`: Iterates through the `pendingOrders` queue (using a for-each loop, which uses the queue's iterator and doesn't remove elements) and prints each order to `System.out`. Checks for emptiness.
 *     *   `viewCompletedOrders()`: Iterates through the `completedOrders` list and prints each order to `System.out`. Checks for emptiness.
 * *   **`main()` Method:** The standard entry point, which creates an instance of `RestaurantManagementSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList` (via `List`), `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` for class-wide exception handling in a practical, albeit simplified, application context, adhering to best practices like encapsulation and meaningful naming.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single order in the restaurant system
class RestaurantOrder {
    private static int nextOrderId = 1; // Static counter for unique IDs

    private int orderId;
    private String items;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new RestaurantOrder.
     * @param items The description of the items in the order.
     */
    public RestaurantOrder(String items) {
        this.orderId = nextOrderId++;
        this.items = items;
        this.status = "Pending"; // New orders start as Pending
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public String getItems() {
        return items;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Order " + orderId + ": " + items + " (" + status + ")";
    }
}

// Main class for the Restaurant Order Management System
public class RestaurantManagementSystem {

    // Using LinkedList as it implements Queue
    private Queue<RestaurantOrder> pendingOrders;
    // Using ArrayList as it implements List
    private List<RestaurantOrder> completedOrders;
    private Scanner scanner;

    /**
     * Constructs a new RestaurantManagementSystem.
     * Initializes the queues, lists, and scanner.
     */
    public RestaurantManagementSystem() {
        this.pendingOrders = new LinkedList<>(); // Queue implementation
        this.completedOrders = new ArrayList<>(); // List implementation
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nRestaurant Order Management System");
        System.out.println("Please choose an option:");
        System.out.println("1. Place New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles placing a new order.
     */
    private void placeOrder() {
        System.out.print("Enter order items: ");
        // Consume the newline character left by previous nextInt() or similar
        scanner.nextLine();
        String items = scanner.nextLine();

        if (items == null || items.trim().isEmpty()) {
            System.err.println("Order items cannot be empty.");
            return;
        }

        RestaurantOrder newOrder = new RestaurantOrder(items);
        pendingOrders.offer(newOrder); // Add to the end of the queue
        System.out.println("Order " + newOrder.getOrderId() + " placed: " + newOrder.getItems() + " (" + newOrder.getStatus() + ")");
    }

    /**
     * Handles processing the next order from the queue.
     */
    private void processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        RestaurantOrder orderToProcess = pendingOrders.poll();

        if (orderToProcess != null) {
            System.out.println("Processing order " + orderToProcess.getOrderId() + ": " + orderToProcess.getItems() + " (" + orderToProcess.getStatus() + ")");
            orderToProcess.setStatus("Completed");
            completedOrders.add(orderToProcess); // Add to the completed list
            System.out.println("Order " + orderToProcess.getOrderId() + " completed.");
        } else {
            System.err.println("No pending orders to process.");
        }
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    private void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements (using peek or an iterator)
            for (RestaurantOrder order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all orders that have been completed.
     */
    private void viewCompletedOrders() {
        System.out.println("--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            // Iterate through the list
            for (RestaurantOrder order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt(); // Read user choice

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        placeOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewPendingOrders();
                        break;
                    case 4:
                        viewCompletedOrders();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where input is not an integer
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to stderr for debugging
                choice = -1; // Reset choice to stay in the loop
            }
        }

        // Close the scanner resource when exiting
        scanner.close();
    }

    /**
     * Main method to start the application.
     */
    public static void main(String[] args) {
        RestaurantManagementSystem system = new RestaurantManagementSystem();
        system.run();
    }
}
