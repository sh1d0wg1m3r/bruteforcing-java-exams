/*
 * Exam Question #611
 * Generated on: 2025-05-12 16:14:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Assembly Line Simulation**
 * 
 * You are tasked with creating a simple simulation of a manufacturing assembly line using core Java data structures and control flow mechanisms. The system should manage a queue of tasks waiting to be processed and a list of tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the waiting tasks.
 *     *   Use a `java.util.ArrayList` to store the completed tasks.
 *     *   Declare the variable holding the completed tasks using the `java.util.List` interface type.
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to get input from the user.
 *     *   Present a menu of options to the user:
 *         *   Add a new task to the queue.
 *         *   Process the next task from the queue.
 *         *   View all completed tasks.
 *         *   Exit the simulation.
 *     *   Use `System.out` for normal messages and output (menu, task details, etc.).
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process from an empty queue).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Implement a loop to keep the simulation running until the user chooses to exit.
 * 
 * 4.  **Core Logic:**
 *     *   **Add Task:** Prompt the user for a task description (a string) and add it to the waiting queue.
 *     *   **Process Task:** Attempt to remove the next task from the front of the queue. If the queue is not empty, move the task to the completed tasks list. If the queue is empty, display an error message using `System.err`.
 *     *   **View Completed:** Display all tasks currently in the completed tasks list. If the list is empty, inform the user.
 * 
 * 5.  **Exception Handling:**
 *     *   Implement class-wide or method-level `try-catch` blocks to handle potential exceptions, particularly around user input (e.g., `InputMismatchException` if the user enters non-numeric input for a menu choice).
 *     *   Gracefully handle errors and inform the user via `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulate the simulation logic within a class (e.g., `AssemblyLineSimulation`).
 *     *   Use private fields for the data structures and scanner.
 *     *   Use meaningful method and variable names.
 *     *   Include basic comments or Javadoc where appropriate.
 *     *   Ensure the `Scanner` resource is properly closed when the simulation exits.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Assembly Line Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Completed Tasks
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Build Widget A
 * Task "Build Widget A" added to the queue.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 2
 * Processing task: Build Widget A
 * Task "Build Widget A" completed.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 3
 * Completed Tasks:
 * 1. Build Widget A
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Assembly Line Menu ---
 * ...
 * Enter choice: 4
 * Exiting Assembly Line Simulation.
 * ```
 * 
 * Your solution should be a single Java file containing the `AssemblyLineSimulation` class and a `main` method to start the simulation.
 *
 * EXPLANATION:
 * This solution implements the `AssemblyLineSimulation` class to manage the task processing flow.
 * 
 * 1.  **Data Structures:**
 *     *   `taskQueue`: A `java.util.Queue<String>` is used, specifically instantiated as a `LinkedList`. A Queue is ideal here because tasks are processed in First-In, First-Out (FIFO) order. The `offer()` method adds tasks to the end, and `poll()` removes tasks from the front.
 *     *   `completedTasks`: A `java.util.List<String>` is used, instantiated as an `ArrayList`. The variable is declared using the `List` interface, demonstrating polymorphism and adherence to the requirement. An `ArrayList` is suitable for storing completed tasks as a dynamic list where order matters and elements might be accessed by index (though iteration is used here).
 * 
 * 2.  **User Interface & Control Flow:**
 *     *   `Scanner`: An instance of `Scanner` reads user input from `System.in`.
 *     *   `displayMenu()`: A helper method to print the available options.
 *     *   `runSimulation()`: Contains the main `while(running)` loop that keeps the program active until the user chooses to exit.
 *     *   `getUserChoice()`: Reads the integer choice from the user.
 *     *   `handleUserInput()`: Uses a `switch` statement to direct execution based on the validated user choice, calling the appropriate private methods (`addTask`, `processNextTask`, `viewCompletedTasks`, `exitSimulation`).
 * 
 * 3.  **Core Logic:**
 *     *   `addTask()`: Reads a line of text from the user for the task description and adds it to the `taskQueue` using `offer()`. Includes basic validation to prevent adding empty tasks.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. `poll()` is safe as it returns `null` if the queue is empty, which is checked to display an error message via `System.err`. If a task is retrieved, it's added to the `completedTasks` list using `add()`.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list using a standard `for` loop and prints each completed task with a sequential number. It checks if the list is empty before attempting to print.
 * 
 * 4.  **Exception Handling:**
 *     *   A `try-catch` block is wrapped around the main `while` loop within `runSimulation()`. This provides a broad safety net for unexpected errors during the simulation's execution.
 *     *   A specific `try-catch` is used within `getUserChoice()` to handle `InputMismatchException` if the user enters non-integer input for the menu choice. This prevents the program from crashing and prompts the user to enter valid input.
 *     *   Error messages are printed to `System.err` as required, distinguishing them from normal program output.
 *     *   A `finally` block in `runSimulation()` ensures that the `scanner` resource is always closed, regardless of whether the simulation exits normally or due to an exception.
 * 
 * 5.  **Best Practices:**
 *     *   The class fields (`taskQueue`, `completedTasks`, `scanner`, `running`) are declared as `private` to enforce encapsulation.
 *     *   Public methods (`runSimulation`, `main`) provide the interface to interact with the simulation. Private helper methods (`displayMenu`, `getUserChoice`, `handleUserInput`, `addTask`, `processNextTask`, `viewCompletedTasks`, `exitSimulation`, `closeScanner`) handle internal logic.
 *     *   Method and variable names are descriptive (e.g., `taskQueue`, `processNextTask`, `viewCompletedTasks`).
 *     *   Basic Javadoc-style comments explain the purpose of the class and key methods.
 *     *   Input validation is performed for task descriptions and menu choices.
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated, and error-handled structure, meeting the criteria for a challenging exam task.
 */

import java.util.LinkedList; // Common implementation for Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Simulates a simple manufacturing assembly line using a Queue for waiting tasks
 * and a List for completed tasks.
 */
public class AssemblyLineSimulation {

    // Private fields for encapsulation
    private Queue<String> taskQueue;
    private List<String> completedTasks; // Declared using the List interface
    private Scanner scanner;
    private boolean running;

    /**
     * Constructor to initialize the simulation components.
     */
    public AssemblyLineSimulation() {
        // Use LinkedList as a common Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as an implementation of the List interface
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts the main simulation loop.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        System.out.println("--- Assembly Line Simulation Started ---");

        // Class-wide try-catch for the main simulation loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();
                handleUserInput(choice);
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when simulation ends or an error occurs
            closeScanner();
            System.out.println("--- Assembly Line Simulation Ended ---");
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Assembly Line Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Gets and validates the user's menu choice.
     * Handles InputMismatchException.
     *
     * @return The valid menu choice.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle non-integer input
            System.err.println("Error: Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        }
        return choice;
    }

    /**
     * Handles the user's chosen menu option using a switch statement.
     *
     * @param choice The user's menu choice.
     */
    private void handleUserInput(int choice) {
        switch (choice) {
            case 1:
                addTask();
                break;
            case 2:
                processNextTask();
                break;
            case 3:
                viewCompletedTasks();
                break;
            case 4:
                exitSimulation();
                break;
            default:
                // Handle invalid choice numbers
                System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                break;
        }
    }

    /**
     * Prompts the user for a task description and adds it to the task queue.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        scanner.nextLine(); // Consume the leftover newline character after reading the integer choice
        String taskDescription = scanner.nextLine();
        if (taskDescription != null && !taskDescription.trim().isEmpty()) {
            taskQueue.offer(taskDescription.trim()); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not constrained.
            System.out.println("Task \"" + taskDescription.trim() + "\" added to the queue.");
        } else {
            System.err.println("Error: Task description cannot be empty.");
        }
    }

    /**
     * Processes the next task from the queue, moving it to the completed list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        String nextTask = taskQueue.poll(); // poll() returns null if queue is empty

        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask);
            completedTasks.add(nextTask);
            System.out.println("Task \"" + nextTask + "\" completed.");
        } else {
            System.err.println("Error: No tasks in the queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("Completed Tasks:");
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
    }

    /**
     * Sets the running flag to false to exit the simulation loop.
     */
    private void exitSimulation() {
        System.out.println("Exiting Assembly Line Simulation.");
        running = false;
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            // System.out.println("Scanner closed."); // Optional: for debugging
        }
    }

    /**
     * Main method to start the simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLineSimulation simulation = new AssemblyLineSimulation();
        simulation.runSimulation();
    }
}
