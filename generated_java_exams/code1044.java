/*
 * Exam Question #1044
 * Generated on: 2025-05-12 17:17:14
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Objective:** Design and implement a simplified Hospital Appointment Management System using core Java concepts and specific data structures and control flow mechanisms.
 * 
 * **Scenario:** You are tasked with creating a console-based application for a small clinic. The system needs to manage patients, doctors, and their appointments. Each doctor maintains a waiting list (queue) of appointments. Patients can schedule appointments with a specific doctor, and doctors can process the next appointment in their queue.
 * 
 * **System Requirements:**
 * 
 * 1.  **Data Management:**
 *     *   Maintain a list of registered patients. Each patient should have a unique integer ID and a name.
 *     *   Maintain a list of registered doctors. Each doctor should have a unique integer ID, a name, and a specialty.
 *     *   Maintain a queue of pending appointments for each doctor. An appointment should link a patient ID, a doctor ID, and a simple time slot string (e.g., "10:00 AM").
 * 
 * 2.  **Functionality:** The system must provide the following options via a main menu:
 *     *   **Add New Patient:** Register a new patient. Assign a unique ID automatically.
 *     *   **Add New Doctor:** Register a new doctor. Assign a unique ID automatically.
 *     *   **Schedule Appointment:** Allow a user to schedule an appointment by providing a patient ID, a doctor ID, and a time slot. The appointment should be added to the specified doctor's waiting queue.
 *     *   **Process Next Appointment:** Allow a user (acting as a doctor) to specify a doctor ID and process the next appointment in that doctor's queue. This should remove the appointment from the queue and display details (Patient Name, Doctor Name, Time Slot).
 *     *   **List All Patients:** Display details of all registered patients.
 *     *   **List All Doctors:** Display details of all registered doctors.
 *     *   **List Pending Appointments for Doctor:** Allow a user to specify a doctor ID and list all appointments currently in that doctor's waiting queue without removing them.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **Technical Constraints:** Your solution MUST use the following Java components:
 *     *   `java.util.Queue` (specifically, an implementation like `LinkedList`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (declare variables using this interface)
 *     *   `java.util.Scanner` for all user input
 *     *   `switch` statement for handling the main menu options
 *     *   `System.err` for displaying error messages (e.g., invalid input, patient/doctor not found, queue empty)
 *     *   `System.out` for displaying the menu, prompts, success messages, and lists
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes/methods) and documentation.
 *     *   Perform input validation (e.g., ensuring numeric input is valid, checking if patient/doctor IDs exist).
 *     *   Implement proper error handling using `try-catch` blocks, including a class-wide `try-catch` for the main application loop to handle unexpected errors, and specific `try-catch` for input parsing errors.
 *     *   Ensure the `Scanner` resource is properly closed.
 *     *   Structure the code logically into appropriate classes (`Patient`, `Doctor`, `Appointment`, `AppointmentSystem`).
 * 
 * **Input Format:**
 * The program should prompt the user for input based on the selected menu option. Numeric inputs (IDs, menu choices) should be handled robustly against non-numeric input.
 * 
 * **Output Format:**
 * *   Menu and prompts should be clear (`System.out`).
 * *   Success messages should be informative (`System.out`).
 * *   Error messages must be printed to `System.err`.
 * *   List outputs should be formatted clearly, showing relevant details (IDs, names, specialties, time slots).
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Add New Patient
 * 2. Add New Doctor
 * 3. Schedule Appointment
 * 4. Process Next Appointment
 * 5. List All Patients
 * 6. List All Doctors
 * 7. List Pending Appointments for Doctor
 * 8. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Patient added with ID: 1
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 2
 * Enter doctor name: Dr. Smith
 * Enter doctor specialty: Cardiology
 * Doctor added with ID: 101
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 3
 * Enter patient ID: 1
 * Enter doctor ID: 101
 * Enter time slot (e.g., 10:00 AM): 10:30 AM
 * Appointment scheduled for Patient ID 1 with Doctor ID 101 at 10:30 AM.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 4
 * Enter doctor ID to process appointment: 101
 * Processing appointment for Dr. Smith (Cardiology). Next appointment: Patient Alice at 10:30 AM.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 7
 * Enter doctor ID to list appointments: 101
 * Pending appointments for Dr. Smith (Cardiology):
 *  - Patient ID 1 at 10:30 AM
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 8
 * Exiting system.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on:
 * *   Correctness of implementation for all functionalities.
 * *   Adherence to all technical constraints (usage of required components).
 * *   Quality of error handling and input validation (`System.err`).
 * *   Code structure, encapsulation, readability, and adherence to best practices.
 * *   Proper use of `try-catch` blocks and resource management (`Scanner`).
 * 
 * Write the complete Java code for the `AppointmentSystem` and its helper classes (`Patient`, `Doctor`, `Appointment`).
 *
 * EXPLANATION:
 * This solution implements a simplified Hospital Appointment Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is organized into four classes: `Patient`, `Doctor`, `Appointment` (simple data holders with private fields and public getters - encapsulation), and `AppointmentSystem` (the main class containing the application logic).
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.ArrayList`: Used to store the collections of `Patient` objects (`patients`) and `Doctor` objects (`doctors`). Declared using the `java.util.List` interface (`List<Patient> patients = new ArrayList<>();`), adhering to the requirement to use the interface.
 *     *   `java.util.Queue`: Used to represent the waiting list of appointments for each doctor. A `Map<Integer, Queue<Appointment>>` (`doctorAppointmentQueues`) is used to associate each Doctor's ID with their specific appointment queue. `LinkedList` is used as the concrete implementation of `Queue` (`new LinkedList<>()`), as it provides efficient additions to the tail (`offer`) and removals from the head (`poll`).
 * 
 * 3.  **User Input:** `java.util.Scanner` is used to read input from `System.in`. A single `Scanner` instance is created and managed using a try-with-resources block in the `run()` method, ensuring it is automatically closed when the application loop finishes or an unexpected error occurs. A helper method `readIntInput` is used to handle reading integers robustly, parsing the input string and catching `NumberFormatException` to prevent crashes on non-numeric input.
 * 
 * 4.  **Control Flow:**
 *     *   A `while` loop in the `run()` method keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used within the loop to direct execution based on the user's menu choice, calling the appropriate private methods (`addPatient`, `addDoctor`, etc.). This fulfills the requirement for using a `switch` statement.
 * 
 * 5.  **Output:**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, success messages, and lists of patients, doctors, and pending appointments.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid menu choices, invalid input formats, patient/doctor not found, or attempting to process an appointment when the queue is empty. This clearly separates error output from standard output.
 * 
 * 6.  **Error Handling:**
 *     *   **Input Validation:** The `readIntInput` helper method validates that integer inputs are actual numbers. Methods like `addPatient`, `addDoctor`, `scheduleAppointment`, etc., check for empty string inputs where appropriate.
 *     *   **Business Logic Validation:** Before scheduling or processing appointments, the system checks if the provided patient and doctor IDs correspond to existing entities using helper methods (`findPatientById`, `findDoctorById`). It also checks if a doctor's queue is empty before attempting to process or list appointments from it.
 *     *   **Specific `try-catch`:** `NumberFormatException` is caught when parsing user input for menu choices and IDs, printing an error message to `System.err`.
 *     *   **Class-wide `try-catch`:** The main `run()` method is wrapped in a `try-catch (Exception e)` block. This serves as a safety net to catch any unexpected runtime exceptions that might occur anywhere within the main application loop, preventing the program from crashing abruptly and printing an error message (including stack trace to `System.err`) before exiting cleanly (due to the try-with-resources closing the scanner).
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Patient`, `Doctor`, and `Appointment` are `private`, accessible only through public getter methods. Methods in `AppointmentSystem` that are internal helpers are `private`, while the main entry point (`run`) and the `main` method are `public`.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `nextPatientId`, `scheduleAppointment`, `doctorAppointmentQueues`).
 *     *   **Comments:** Javadoc comments are provided for each class and major method, explaining their purpose, parameters, and return values. Inline comments are used where necessary to clarify specific logic.
 *     *   **Code Structure:** The code is divided into logical methods corresponding to the menu options and helper functions, making it modular and easier to understand.
 * 
 * This solution effectively integrates all required Java components to build a functional system, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in a practical context.
 */

import java.util.*;

/**
 * Represents a Patient in the Hospital Appointment System.
 */
class Patient {
    private int id;
    private String name;

    /**
     * Constructs a new Patient.
     * @param id The unique ID for the patient.
     * @param name The name of the patient.
     */
    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * Gets the patient's ID.
     * @return The patient ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the patient's name.
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

/**
 * Represents a Doctor in the Hospital Appointment System.
 */
class Doctor {
    private int id;
    private String name;
    private String specialty;

    /**
     * Constructs a new Doctor.
     * @param id The unique ID for the doctor.
     * @param name The name of the doctor.
     * @param specialty The specialty of the doctor.
     */
    public Doctor(int id, String name, String specialty) {
        this.id = id;
        this.name = name;
        this.specialty = specialty;
    }

    /**
     * Gets the doctor's ID.
     * @return The doctor ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the doctor's name.
     * @return The doctor name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the doctor's specialty.
     * @return The doctor specialty.
     */
    public String getSpecialty() {
        return specialty;
    }

    @Override
    public String toString() {
        return "Doctor [ID=" + id + ", Name=" + name + ", Specialty=" + specialty + "]";
    }
}

/**
 * Represents an Appointment in the Hospital Appointment System.
 */
class Appointment {
    private int patientId;
    private int doctorId;
    private String timeSlot;

    /**
     * Constructs a new Appointment.
     * @param patientId The ID of the patient.
     * @param doctorId The ID of the doctor.
     * @param timeSlot The scheduled time slot.
     */
    public Appointment(int patientId, int doctorId, String timeSlot) {
        this.patientId = patientId;
        this.doctorId = doctorId;
        this.timeSlot = timeSlot;
    }

    /**
     * Gets the ID of the patient for this appointment.
     * @return The patient ID.
     */
    public int getPatientId() {
        return patientId;
    }

    /**
     * Gets the ID of the doctor for this appointment.
     * @return The doctor ID.
     */
    public int getDoctorId() {
        return doctorId;
    }

    /**
     * Gets the time slot for this appointment.
     * @return The time slot string.
     */
    public String getTimeSlot() {
        return timeSlot;
    }

    @Override
    public String toString() {
        return "Appointment [Patient ID=" + patientId + ", Doctor ID=" + doctorId + ", Time=" + timeSlot + "]";
    }
}

/**
 * The main class for the Hospital Appointment Management System.
 * Manages patients, doctors, and their appointment queues.
 */
public class AppointmentSystem {
    // Using List interface for flexibility, implementing with ArrayList
    private List<Patient> patients;
    private List<Doctor> doctors;
    // Map to hold queues for each doctor, using Doctor ID as key
    private Map<Integer, Queue<Appointment>> doctorAppointmentQueues;

    private int nextPatientId = 1; // Auto-incrementing ID for patients
    private int nextDoctorId = 101; // Auto-incrementing ID for doctors

    // Using Scanner for user input, declared as a field for try-with-resources in run()
    private Scanner scanner;

    /**
     * Constructs a new AppointmentSystem.
     * Initializes the data structures.
     */
    public AppointmentSystem() {
        patients = new ArrayList<>();
        doctors = new ArrayList<>();
        doctorAppointmentQueues = new HashMap<>(); // Using HashMap for the map implementation
    }

    /**
     * Runs the main application loop, displaying the menu and handling user input.
     * Includes class-wide exception handling and resource management.
     */
    public void run() {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner inputScanner = new Scanner(System.in)) {
            this.scanner = inputScanner; // Assign to field for method access

            System.out.println("--- Welcome to Hospital Appointment System ---");
            boolean running = true;
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");
                String choiceStr = scanner.nextLine();

                try {
                    int choice = Integer.parseInt(choiceStr);

                    // Using switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addPatient();
                            break;
                        case 2:
                            addDoctor();
                            break;
                        case 3:
                            scheduleAppointment();
                            break;
                        case 4:
                            processNextAppointment();
                            break;
                        case 5:
                            listPatients();
                            break;
                        case 6:
                            listDoctors();
                            break;
                        case 7:
                            listPendingAppointmentsForDoctor();
                            break;
                        case 8:
                            System.out.println("Exiting system.");
                            running = false;
                            break;
                        default:
                            // Using System.err for invalid menu choice
                            System.err.println("Invalid choice. Please enter a number between 1 and 8.");
                    }
                } catch (NumberFormatException e) {
                    // Using System.err for invalid input format
                    System.err.println("Invalid input. Please enter a number for your choice.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Class-wide exception handling for any unexpected errors
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        }
        // Scanner is automatically closed by try-with-resources
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Hospital Appointment System Menu ---");
        System.out.println("1. Add New Patient");
        System.out.println("2. Add New Doctor");
        System.out.println("3. Schedule Appointment");
        System.out.println("4. Process Next Appointment");
        System.out.println("5. List All Patients");
        System.out.println("6. List All Doctors");
        System.out.println("7. List Pending Appointments for Doctor");
        System.out.println("8. Exit");
        System.out.println("----------------------------------------");
    }

    /**
     * Adds a new patient to the system based on user input.
     */
    private void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Patient name cannot be empty.");
            return;
        }
        Patient newPatient = new Patient(nextPatientId++, name.trim());
        patients.add(newPatient);
        System.out.println("Patient added successfully: " + newPatient);
    }

    /**
     * Adds a new doctor to the system based on user input.
     */
    private void addDoctor() {
        System.out.print("Enter doctor name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Doctor name cannot be empty.");
            return;
        }
        System.out.print("Enter doctor specialty: ");
        String specialty = scanner.nextLine();
         if (specialty == null || specialty.trim().isEmpty()) {
            System.err.println("Doctor specialty cannot be empty.");
            return;
        }
        Doctor newDoctor = new Doctor(nextDoctorId++, name.trim(), specialty.trim());
        doctors.add(newDoctor);
        // Initialize an empty queue for the new doctor
        doctorAppointmentQueues.put(newDoctor.getId(), new LinkedList<>()); // LinkedList implements Queue
        System.out.println("Doctor added successfully: " + newDoctor);
    }

    /**
     * Schedules a new appointment based on user input for patient, doctor, and time.
     * Adds the appointment to the doctor's queue.
     */
    private void scheduleAppointment() {
        int patientId = readIntInput("Enter patient ID: ");
        if (patientId == -1) return; // Error occurred during input

        int doctorId = readIntInput("Enter doctor ID: ");
        if (doctorId == -1) return; // Error occurred during input

        System.out.print("Enter time slot (e.g., 10:30 AM): ");
        String timeSlot = scanner.nextLine();
        if (timeSlot == null || timeSlot.trim().isEmpty()) {
             System.err.println("Time slot cannot be empty.");
             return;
        }
        timeSlot = timeSlot.trim();


        Patient patient = findPatientById(patientId);
        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return;
        }

        Doctor doctor = findDoctorById(doctorId);
        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        // Get or create the queue for the doctor
        // Using getOrDefault for robustness, though addDoctor should ensure queue exists
        Queue<Appointment> queue = doctorAppointmentQueues.getOrDefault(doctorId, new LinkedList<>());
        if (!doctorAppointmentQueues.containsKey(doctorId)) {
             // This case should ideally not happen if addDoctor works correctly,
             // but handling it makes scheduleAppointment more robust.
             System.err.println("Internal Error: Queue not found for doctor ID " + doctorId + ". Initializing queue.");
             doctorAppointmentQueues.put(doctorId, queue);
        }

        Appointment newAppointment = new Appointment(patientId, doctorId, timeSlot);
        queue.offer(newAppointment); // Add to the end of the queue
        System.out.println("Appointment scheduled successfully for Patient '" + patient.getName() +
                           "' with Doctor '" + doctor.getName() + "' at " + timeSlot + ".");
    }

    /**
     * Processes (removes) the next appointment from a doctor's queue.
     */
    private void processNextAppointment() {
        int doctorId = readIntInput("Enter doctor ID to process appointment for: ");
        if (doctorId == -1) return; // Error occurred during input

        Doctor doctor = findDoctorById(doctorId);
        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        Queue<Appointment> queue = doctorAppointmentQueues.get(doctorId);
        if (queue == null || queue.isEmpty()) {
            System.err.println("No pending appointments for Doctor '" + doctor.getName() + "'.");
            return;
        }

        Appointment nextAppointment = queue.poll(); // Remove and get the head of the queue

        // Find patient details for output
        Patient patient = findPatientById(nextAppointment.getPatientId());
        String patientName = (patient != null) ? patient.getName() : "Unknown Patient";

        System.out.println("Processing appointment for Doctor '" + doctor.getName() + "' (" + doctor.getSpecialty() + ").");
        System.out.println("Next appointment processed: Patient '" + patientName +
                           "' (ID " + nextAppointment.getPatientId() + ") at " + nextAppointment.getTimeSlot() + ".");
    }

    /**
     * Lists all registered patients.
     */
    private void listPatients() {
        System.out.println("--- All Patients ---");
        if (patients.isEmpty()) {
            System.out.println("No patients registered.");
        } else {
            for (Patient p : patients) {
                System.out.println(p);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all registered doctors.
     */
    private void listDoctors() {
        System.out.println("--- All Doctors ---");
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered.");
        } else {
            for (Doctor d : doctors) {
                System.out.println(d);
            }
        }
        System.out.println("-------------------");
    }

    /**
     * Lists pending appointments for a specific doctor without removing them from the queue.
     */
    private void listPendingAppointmentsForDoctor() {
        int doctorId = readIntInput("Enter doctor ID to list appointments for: ");
        if (doctorId == -1) return; // Error occurred during input

        Doctor doctor = findDoctorById(doctorId);
        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        Queue<Appointment> queue = doctorAppointmentQueues.get(doctorId);
        System.out.println("--- Pending Appointments for Dr. " + doctor.getName() + " (" + doctor.getSpecialty() + ") ---");
        if (queue == null || queue.isEmpty()) {
            System.out.println("No pending appointments.");
        } else {
            // Iterate through the queue without removing elements
            for (Appointment appt : queue) {
                 // Find patient details for output
                Patient patient = findPatientById(appt.getPatientId());
                String patientName = (patient != null) ? patient.getName() : "Unknown Patient";
                System.out.println(" - Patient '" + patientName + "' (ID " + appt.getPatientId() + ") at " + appt.getTimeSlot());
            }
        }
        System.out.println("-------------------------------------------------");
    }

    /**
     * Helper method to find a patient by their ID.
     * @param id The patient ID to search for.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientById(int id) {
        for (Patient p : patients) {
            if (p.getId() == id) {
                return p;
            }
        }
        return null;
    }

    /**
     * Helper method to find a doctor by their ID.
     * @param id The doctor ID to search for.
     * @return The Doctor object if found, otherwise null.
     */
    private Doctor findDoctorById(int id) {
        for (Doctor d : doctors) {
            if (d.getId() == id) {
                return d;
            }
        }
        return null;
    }

    /**
     * Helper method to read an integer input from the user safely.
     * Handles NumberFormatException and returns -1 on error.
     * @param prompt The message to display to the user.
     * @return The integer entered by the user, or -1 if input was invalid.
     */
    private int readIntInput(String prompt) {
        System.out.print(prompt);
        String inputLine = scanner.nextLine();
        try {
            return Integer.parseInt(inputLine);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a valid number.");
            return -1; // Indicate error
        }
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AppointmentSystem system = new AppointmentSystem();
        system.run();
    }
}
