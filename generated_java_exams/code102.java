/*
 * Exam Question #102
 * Generated on: 2025-05-11 22:14:26
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Automated Task Processing System
 * 
 * **Objective:** Design and implement a simple automated task processing system that manages tasks in a queue and archives completed tasks in a list. This task requires you to demonstrate proficiency in using various Java collection types, input handling, control flow, and exception management.
 * 
 * **Scenario:**
 * 
 * You are building the core logic for a system that receives tasks and processes them in a First-In, First-Out (FIFO) manner. Pending tasks are held in a queue. Once a task is processed, it is moved to a list of completed tasks. The system should interact with a user via a simple command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): Represents the current status of the task (e.g., "Pending", "Completed").
 * 
 * 2.  **Task Processor:** Create a class `TaskProcessor` that manages the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `List<Task>` (specifically instantiated as an `ArrayList<Task>`) to hold tasks that have been completed.
 *     *   Methods for the following operations:
 *         *   `addTask(String description)`: Creates a new `Task` with "Pending" status and adds it to the queue of pending tasks. The description must not be empty or null.
 *         *   `processNextTask()`: Takes the task from the front of the pending queue, changes its status to "Completed", and moves it to the list of completed tasks. Handle the case where the pending queue is empty.
 *         *   `getPendingTasks()`: Returns the `Queue` of pending tasks (consider returning a copy or an unmodifiable view if you want to prevent external modification, but for this exam, returning the reference is acceptable).
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks (similarly, returning the reference is acceptable).
 * 
 * 3.  **User Interface:** Implement a command-line interface in a main class (e.g., `TaskProcessingApp`) using `Scanner` to interact with the user. The interface should present a menu with the following options:
 *     *   Add New Task
 *     *   Process Next Task
 *     *   View Pending Tasks
 *     *   View Completed Tasks
 *     *   Exit
 * 
 * 4.  **Control Flow:** Use a `switch` statement to handle the user's menu selection.
 * 
 * 5.  **Input Handling:** Use `Scanner` to read user input for menu choices and task descriptions. Implement validation to ensure that the user enters valid input (e.g., an integer for the menu choice, a non-empty string for the task description).
 * 
 * 6.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `InputMismatchException` when reading integer input and potentially other exceptions during task processing (e.g., handling the empty queue scenario).
 *     *   Use `System.err` to print error messages (e.g., invalid input, empty queue processing attempts, empty task description).
 *     *   Use `System.out` for the menu, prompts, and displaying task lists.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (Javadoc style is encouraged).
 *     *   Structure your code logically into classes and methods.
 * 
 * **Specific Requirements Checklist:**
 * 
 * *   [ ] Use `java.util.Queue`
 * *   [ ] Use `java.util.ArrayList`
 * *   [ ] Use `java.util.List` interface (declare a variable of type `List` initialized with `ArrayList`)
 * *   [ ] Use `java.util.Scanner`
 * *   [ ] Use a `switch` statement
 * *   [ ] Use `System.err` for error output
 * *   [ ] Use `System.out` for normal output
 * *   [ ] Implement class-wide exception handling with `try-catch`
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu, prompt for user input, and perform the requested action.
 * *   Adding a task should confirm the task was added.
 * *   Processing a task should indicate which task was processed or report if the queue was empty.
 * *   Viewing tasks should list the tasks with their status.
 * *   Invalid input or errors (like processing an empty queue) should print an informative message to `System.err`.
 * *   Exiting the program should terminate the application gracefully.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: Buy groceries [Pending]
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task added: Pay bills [Pending]
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Buy groceries [Pending]
 * 2. Pay bills [Pending]
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Buy groceries [Pending]
 * Task processed: Buy groceries [Completed]
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Buy groceries [Completed]
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processor.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The solution implements the Automated Task Processing System as described in the exam question, utilizing all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single unit of work.
 *     *   It has private fields `description` and `status` for encapsulation.
 *     *   A constructor initializes the task with a description and sets its status to "Pending".
 *     *   Public getter and setter methods provide controlled access to the fields.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the collection of tasks.
 *     *   `pendingTasks`: A `Queue<Task>` is used to store tasks waiting to be processed. `LinkedList` is chosen as a concrete implementation of the `Queue` interface because it provides efficient insertion and removal from both ends, suitable for a queue.
 *     *   `completedTasks`: A `List<Task>` variable is declared, and it is instantiated as an `ArrayList<Task>`. This demonstrates using the `List` interface type for polymorphism while using a concrete `ArrayList` implementation, which is suitable for storing a dynamic list of completed items.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. Includes input validation to ensure the description is not empty or null, throwing an `IllegalArgumentException` if it is.
 *     *   `processNextTask()`: Checks if the `pendingTasks` queue is empty. If not, it uses `poll()` to retrieve and remove the head of the queue, updates its status to "Completed", and adds it to the `completedTasks` list. If the queue is empty, it prints an error message to `System.err` and returns null.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: Provide access to the internal collections.
 * 
 * 3.  **`TaskProcessingApp` Class (Main Application):**
 *     *   Contains the `main` method to start the application.
 *     *   An instance of `TaskProcessor` is created to handle the task logic.
 *     *   A `Scanner` is used for reading user input from `System.in`.
 *     *   The `run()` method contains the main application loop.
 *     *   `displayMenu()` prints the available options to `System.out`.
 *     *   A `while` loop continues until the user chooses to exit.
 *     *   **Input Handling & `try-catch`:** A `try-catch` block surrounds the input reading (`scanner.nextInt()`) and the `switch` statement. This catches `InputMismatchException` if the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *     *   **`switch` Statement:** Controls the program flow based on the user's valid menu choice. Each case calls the appropriate method on the `TaskProcessor` instance or handles viewing tasks.
 *     *   **Error Handling (`System.err`):** `System.err` is used for printing error messages related to invalid menu choices, `InputMismatchException`, empty task descriptions (`IllegalArgumentException` caught in the main loop), and attempting to process tasks when the queue is empty (handled within `processNextTask`).
 *     *   **Normal Output (`System.out`):** `System.out` is used for displaying the menu, prompts, confirmation messages (task added/processed), and the lists of tasks.
 *     *   **Viewing Tasks:** The `viewTasks` helper method iterates through the provided collection (either the `Queue` or the `List`) and prints each task. It uses `Iterable` as the parameter type to accept both `Queue` and `List` as they both implement `Iterable`.
 *     *   A final `try-catch` is included in the `run` method to catch any other unexpected exceptions during the main loop's execution, printing an error and stack trace to `System.err`.
 *     *   The `Scanner` is closed when the loop exits.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, menu-driven application, including proper object-oriented design, collection usage, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description and status.
 */
class Task {
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.status = "Pending";
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     * @return The task status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return description + " [" + status + "]";
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 */
class TaskProcessor {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared as List, instantiated as ArrayList

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // Instantiated as ArrayList
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     * @return The processed task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No tasks in the pending queue to process.");
            return null;
        }
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        System.out.println("Processing task: " + taskToProcess);
        taskToProcess.setStatus("Completed");
        completedTasks.add(taskToProcess);
        System.out.println("Task processed: " + taskToProcess);
        return taskToProcess;
    }

    /**
     * Gets the queue of pending tasks.
     * @return The pending tasks queue.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Gets the list of completed tasks.
     * @return The completed tasks list.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Automated Task Processing System.
 * Handles user interaction and menu operations.
 */
public class TaskProcessingApp {

    private TaskProcessor processor;
    private Scanner scanner;

    /**
     * Constructs the TaskProcessingApp.
     */
    public TaskProcessingApp() {
        this.processor = new TaskProcessor();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            processor.addTask(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;
                    case 2:
                        processor.processNextTask();
                        break;
                    case 3:
                        viewTasks(processor.getPendingTasks(), "Pending Tasks");
                        break;
                    case 4:
                        viewTasks(processor.getCompletedTasks(), "Completed Tasks");
                        break;
                    case 5:
                        System.out.println("Exiting Task Processor.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the loop iteration
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(); // Print stack trace for debugging
                 // Decide whether to continue or exit based on severity; here we continue
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Displays a list of tasks.
     * @param tasks The collection of tasks to display (either Queue or List).
     * @param title The title for the task list.
     */
    private void viewTasks(Iterable<Task> tasks, String title) {
        System.out.println("\n--- " + title + " ---");
        if (!tasks.iterator().hasNext()) {
            System.out.println("No " + title.toLowerCase() + ".");
            return;
        }
        int index = 1;
        for (Task task : tasks) {
            System.out.println(index++ + ". " + task);
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingApp app = new TaskProcessingApp();
        app.run();
    }
}
