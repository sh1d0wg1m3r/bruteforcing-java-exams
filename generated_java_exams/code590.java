/*
 * Exam Question #590
 * Generated on: 2025-05-12 16:11:32
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Industrial Task Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified system for managing and processing tasks in a small industrial plant. Tasks arrive, are placed in a queue, processed one by one, and then moved to a history log. The system should allow adding new tasks, processing the next task in the queue, viewing the pending tasks, and viewing the history of processed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following private fields:
 *     *   `taskId` (String): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (String): The priority level (e.g., "HIGH", "MEDIUM", "LOW").
 *     *   `status` (String): The current status ("PENDING", "PROCESSING", "COMPLETED", "FAILED").
 *     *   Include a constructor and appropriate public getter methods for these fields. Provide a public method `updateStatus(String newStatus)` to change the task's status.
 * 
 * 2.  **Task Processing System:** Create a class `TaskProcessor` that manages the task workflow.
 *     *   It must have a private field `taskQueue` of type `java.util.Queue<Task>` to hold tasks awaiting processing.
 *     *   It must have a private field `taskHistory` of type `java.util.List<Task>` to hold tasks that have been processed (either completed or failed). Use `java.util.ArrayList` as the concrete implementation for `taskHistory`.
 *     *   Implement the following public methods:
 *         *   `addTask(Task task)`: Adds a task to the `taskQueue`. Perform input validation: the task and its description must not be null or empty. If invalid, print an error to `System.err` and do not add the task.
 *         *   `processNextTask()`: Attempts to process the next task from the `taskQueue`.
 *             *   If the queue is empty, print a message to `System.out` indicating no tasks are pending.
 *             *   If a task is available:
 *                 *   Remove the task from the queue.
 *                 *   Update its status to "PROCESSING". Print a message to `System.out`.
 *                 *   **Simulate Processing:** Introduce a simulated processing step. This simulation should have a chance of success or failure (e.g., 80% success, 20% failure, or simulate a potential exception).
 *                 *   If processing succeeds: Update status to "COMPLETED", print a success message to `System.out`, and add the task to `taskHistory`.
 *                 *   If processing fails (simulated failure or exception): Update status to "FAILED", print a failure message to `System.err`, and add the task to `taskHistory`. Use `try-catch` blocks to handle potential exceptions during processing simulation.
 *         *   `getPendingTasks()`: Returns the current `taskQueue`. *Note: Return the Queue itself for simplicity in this exam context, though in a real system, you might return a copy or an unmodifiable view.*
 *         *   `getTaskHistory()`: Returns the `taskHistory` list. *Note: Similar to `getPendingTasks`, return the List directly.*
 * 
 * 3.  **Main Application:** Create a class (e.g., `IndustrialSystemApp`) with a `main` method to run the system.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Create an instance of `TaskProcessor`.
 *     *   Implement a command-line interface loop:
 *         *   Display a menu of options: Add Task, Process Next Task, View Pending Tasks, View Task History, Exit.
 *         *   Read the user's choice using `Scanner`.
 *         *   Use a `switch` statement to handle the different menu options.
 *         *   For "Add Task", prompt the user for task details (ID, description, priority) and create a `Task` object before adding it to the processor. Generate a unique ID if not provided by the user (e.g., using a counter).
 *         *   For "View Pending Tasks" and "View Task History", iterate through the respective collections and print task details to `System.out`.
 *         *   Include a "Exit" option to terminate the program gracefully.
 *         *   Handle invalid menu choices.
 *     *   Implement class-wide exception handling around the main loop using a `try-catch` block to catch any unexpected exceptions and print an error message using `System.err`. Ensure the `Scanner` is closed properly, perhaps in a `finally` block or using try-with-resources (though a single `try-catch` around the loop is sufficient for the requirement).
 * 
 * 4.  **Required Java Components:** Ensure your solution explicitly uses:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (including a broad one in `main`).
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Add comments to explain complex logic or key sections.
 *     *   Implement input validation as specified.
 *     *   Handle errors gracefully, using `System.err` for errors.
 *     *   Structure the code into logical classes.
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user via the console. Example interactions:
 * 
 * ```
 * --- Task Management System ---
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter choice: 1
 * Enter Task ID: task001
 * Enter Description: Calibrate Machine A
 * Enter Priority (HIGH/MEDIUM/LOW): HIGH
 * Task added: task001 - Calibrate Machine A [PENDING]
 * 
 * --- Task Management System ---
 * Choose an option:
 * ...
 * Enter choice: 2
 * Processing task: task001 - Calibrate Machine A [PROCESSING]
 * Task task001 completed successfully.
 * 
 * --- Task Management System ---
 * Choose an option:
 * ...
 * Enter choice: 3
 * --- Pending Tasks ---
 * (Queue is empty)
 * 
 * --- Task Management System ---
 * Choose an option:
 * ...
 * Enter choice: 4
 * --- Task History ---
 * task001 - Calibrate Machine A [COMPLETED]
 * 
 * --- Task Management System ---
 * Choose an option:
 * ...
 * Enter choice: 2
 * No tasks pending.
 * 
 * --- Task Management System ---
 * Choose an option:
 * ...
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * (Error messages should go to System.err)
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * *   Correct implementation of all required functionalities.
 * *   Proper use of all specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code structure and readability.
 *
 * EXPLANATION:
 * This solution implements a simple industrial task management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data for a single task using private fields (`taskId`, `description`, `priority`, `status`).
 *     *   Provides a constructor for creating tasks with basic validation (`IllegalArgumentException` if ID/description is empty or priority is invalid).
 *     *   Includes public getter methods for accessing task properties.
 *     *   Has a public `updateStatus` method to modify the task's state.
 *     *   Overrides `toString()` for easy printing of task details.
 *     *   This demonstrates **encapsulation** and basic **input validation**.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the core logic and data structures.
 *     *   Uses a `private Queue<Task> taskQueue` (implemented with `LinkedList`) to store tasks waiting to be processed, adhering to the **`Queue`** requirement. Tasks are added to the end and removed from the front (FIFO).
 *     *   Uses a `private List<Task> taskHistory` (implemented with `ArrayList`) to store tasks after processing, fulfilling the **`ArrayList`** and **`List`** requirements.
 *     *   `addTask`: Adds a valid `Task` object to the `taskQueue` using `offer()`. Includes a check to prevent adding null tasks or tasks with duplicate IDs (a good practice). Uses `System.err` for error messages.
 *     *   `processNextTask`: Retrieves the next task using `poll()`. Updates the status to "PROCESSING". It then simulates processing with a `Random` chance of failure, throwing a `RuntimeException` to mimic a real-world processing error. A **`try-catch`** block handles this potential exception (or the simulated one).
 *         *   If successful, the status is set to "COMPLETED".
 *         *   If an exception occurs, the status is set to "FAILED".
 *         *   A **`finally`** block ensures that the task is added to the `taskHistory` list regardless of success or failure. This demonstrates robust error handling and resource management within a method.
 *         *   Uses **`System.out`** for success messages and **`System.err`** for failure messages.
 *     *   `getPendingTasks` and `getTaskHistory`: Public methods to provide access to the internal collections. (Note: Returning the collections directly is acceptable for a simple exam task but might be modified in a production system).
 *     *   This class demonstrates the practical use of **`Queue`**, **`List`**, **`ArrayList`**, **`try-catch`** for specific method logic, and **encapsulation**.
 * 
 * 3.  **`IndustrialSystemApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses **`Scanner`** within a try-with-resources block to read user input from the console, ensuring the scanner is closed automatically.
 *     *   Creates an instance of `TaskProcessor`.
 *     *   Runs a main loop (`while(running)`).
 *     *   Inside the loop:
 *         *   It displays a menu.
 *         *   Reads the user's integer choice. Includes basic input validation to check if the input is an integer, consuming invalid input if necessary.
 *         *   Uses a **`switch`** statement to direct execution based on the user's choice, fulfilling the `switch` requirement.
 *         *   Case 1 (`Add Task`): Prompts for task details, handles auto-generating an ID, creates a `Task` object (catching `IllegalArgumentException` from the `Task` constructor using a specific `try-catch`), and calls `processor.addTask()`.
 *         *   Case 2 (`Process Next Task`): Calls `processor.processNextTask()`.
 *         *   Case 3 (`View Pending Tasks`): Retrieves the queue using `processor.getPendingTasks()` and iterates through it to print tasks to **`System.out`**.
 *         *   Case 4 (`View Task History`): Retrieves the list using `processor.getTaskHistory()` and iterates through it to print tasks to **`System.out`**.
 *         *   Case 5 (`Exit`): Sets `running` to false to terminate the loop.
 *         *   `default`: Handles invalid integer choices using **`System.err`**.
 *     *   A broad **`try-catch`** block is placed around the entire main `while` loop. This serves as the **class-wide exception handling** mechanism required, catching any unexpected runtime exceptions that might propagate up from method calls and printing an error message and stack trace to **`System.err`**.
 *     *   A `finally` block (associated with the outer `try` handling the loop) ensures a final message is printed upon system shutdown.
 *     *   Includes a helper method `printMenu` for clean code structure.
 *     *   Uses a simple counter to generate unique task IDs when the user doesn't provide one.
 *     *   This class demonstrates **`Scanner`**, **`switch`**, **`System.out`**, **`System.err`**, **class-wide `try-catch`**, and good application structure.
 * 
 * Overall, the solution integrates all required components into a cohesive application that simulates a practical scenario, adheres to best practices like encapsulation and error handling, and provides a clear command-line interface.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Random; // For simulating processing success/failure

// Represents a single task in the system
class Task {
    private String taskId;
    private String description;
    private String priority;
    private String status; // e.g., PENDING, PROCESSING, COMPLETED, FAILED

    // Constructor
    public Task(String taskId, String description, String priority) {
        // Basic validation during creation
        if (taskId == null || taskId.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        // Simple priority validation (can be expanded)
        if (!priority.equalsIgnoreCase("HIGH") && !priority.equalsIgnoreCase("MEDIUM") && !priority.equalsIgnoreCase("LOW")) {
             throw new IllegalArgumentException("Invalid priority: " + priority + ". Must be HIGH, MEDIUM, or LOW.");
        }

        this.taskId = taskId.trim();
        this.description = description.trim();
        this.priority = priority.toUpperCase(); // Standardize priority
        this.status = "PENDING"; // Default status
    }

    // Public getters
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // Method to update task status
    public void updateStatus(String newStatus) {
        // Basic validation for new status (can be expanded)
         if (newStatus == null || newStatus.trim().isEmpty()) {
             System.err.println("Warning: Attempted to set task status to null or empty for task " + this.taskId);
             return; // Or throw exception
         }
        this.status = newStatus.trim().toUpperCase(); // Standardize status
    }

    @Override
    public String toString() {
        return String.format("%s - %s [%s]", taskId, description, status);
    }
}

// Manages the queue and history of tasks
class TaskProcessor {
    // Using LinkedList as a Queue implementation
    private Queue<Task> taskQueue;
    // Using ArrayList as a List implementation for history
    private List<Task> taskHistory;
    private Random random; // For simulating processing outcome

    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // Queue for pending tasks
        this.taskHistory = new ArrayList<>(); // List for processed tasks
        this.random = new Random(); // Initialize randomizer
    }

    /**
     * Adds a task to the processing queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        // Validation handled in Task constructor, but check for null Task object itself
        if (task == null) {
            System.err.println("Error: Cannot add a null task.");
            return;
        }
        // Check if task with same ID already exists (optional but good practice)
        boolean existsInQueue = taskQueue.stream().anyMatch(t -> t.getTaskId().equals(task.getTaskId()));
        boolean existsInHistory = taskHistory.stream().anyMatch(t -> t.getTaskId().equals(task.getTaskId()));

        if (existsInQueue || existsInHistory) {
             System.err.println("Error: Task with ID " + task.getTaskId() + " already exists.");
             return;
        }

        taskQueue.offer(task); // Add to the end of the queue
        System.out.println("Task added: " + task);
    }

    /**
     * Processes the next task from the queue.
     * Simulates processing success/failure.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks pending.");
            return;
        }

        // Get and remove the next task from the queue
        Task currentTask = taskQueue.poll();

        try {
            // Update status to PROCESSING
            currentTask.updateStatus("PROCESSING");
            System.out.println("Processing task: " + currentTask);

            // --- Simulate Processing Logic ---
            // Simulate a chance of failure (e.g., 20% chance of failure)
            if (random.nextDouble() < 0.2) {
                // Simulate a processing error
                throw new RuntimeException("Simulated processing failure for task " + currentTask.getTaskId());
            }

            // If no exception, processing is successful
            currentTask.updateStatus("COMPLETED");
            System.out.println("Task " + currentTask.getTaskId() + " completed successfully.");

        } catch (Exception e) {
            // Handle processing failure (simulated or real)
            currentTask.updateStatus("FAILED");
            System.err.println("Task " + currentTask.getTaskId() + " failed during processing: " + e.getMessage());
        } finally {
            // Regardless of success or failure, move the task to history
            taskHistory.add(currentTask);
        }
    }

    /**
     * Returns the queue of tasks awaiting processing.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return taskQueue;
    }

    /**
     * Returns the list of tasks that have been processed.
     * @return The List of processed tasks.
     */
    public List<Task> getTaskHistory() {
        return taskHistory;
    }
}

// Main application class to run the system
public class IndustrialSystemApp {

    private static int taskCounter = 0; // Simple counter for unique task IDs

    // Method to generate a simple unique task ID
    private static String generateTaskId() {
        taskCounter++;
        return "TASK-" + String.format("%04d", taskCounter);
    }

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskProcessor processor = new TaskProcessor();
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    printMenu();
                    System.out.print("Enter choice: ");

                    // Check if the next input is an integer
                    if (!scanner.hasNextInt()) {
                        System.err.println("Invalid input. Please enter a number between 1 and 5.");
                        scanner.next(); // Consume the invalid input
                        continue; // Go to the next iteration
                    }

                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int

                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter Task ID (or leave blank for auto-generate): ");
                            String idInput = scanner.nextLine().trim();
                            String taskId = idInput.isEmpty() ? generateTaskId() : idInput;

                            System.out.print("Enter Description: ");
                            String description = scanner.nextLine();

                            System.out.print("Enter Priority (HIGH/MEDIUM/LOW): ");
                            String priority = scanner.nextLine();

                            try {
                                Task newTask = new Task(taskId, description, priority);
                                processor.addTask(newTask);
                            } catch (IllegalArgumentException e) {
                                // Catch validation errors from Task constructor
                                System.err.println("Failed to create task: " + e.getMessage());
                            }
                            break;

                        case 2: // Process Next Task
                            processor.processNextTask();
                            break;

                        case 3: // View Pending Tasks
                            System.out.println("\n--- Pending Tasks ---");
                            Queue<Task> pendingTasks = processor.getPendingTasks();
                            if (pendingTasks.isEmpty()) {
                                System.out.println("(Queue is empty)");
                            } else {
                                // Iterate and print tasks in the queue
                                pendingTasks.forEach(System.out::println);
                            }
                            System.out.println("---------------------");
                            break;

                        case 4: // View Task History
                            System.out.println("\n--- Task History ---");
                            List<Task> taskHistory = processor.getTaskHistory();
                             if (taskHistory.isEmpty()) {
                                System.out.println("(History is empty)");
                            } else {
                                // Iterate and print tasks in the history list
                                taskHistory.forEach(System.out::println);
                            }
                            System.out.println("--------------------");
                            break;

                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting system.");
                            break;

                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                    System.out.println(); // Add a newline for better formatting
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions in the main loop
                System.err.println("\nAn unexpected system error occurred:");
                e.printStackTrace(System.err); // Print stack trace to System.err
            } finally {
                // Scanner is automatically closed by try-with-resources
                System.out.println("System shutdown complete.");
            }

        } // Scanner is closed here automatically
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Task History");
        System.out.println("5. Exit");
    }
}
