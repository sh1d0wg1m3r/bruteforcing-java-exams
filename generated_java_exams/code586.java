/*
 * Exam Question #586
 * Generated on: 2025-05-12 16:11:02
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing inventory and processing customer orders in a small warehouse. The system needs to keep track of available inventory items and process incoming orders in the order they are received.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the Core System:** Create a Java application that simulates this warehouse system.
 * 2.  **Data Structures:**
 *     *   Manage the warehouse inventory using a `java.util.List` implementation (specifically `java.util.ArrayList`).
 *     *   Manage incoming customer orders using a `java.util.Queue` implementation (specifically `java.util.LinkedList`).
 * 3.  **Classes:** Define the following classes with appropriate private fields, public getters, and constructors:
 *     *   `InventoryItem`: Represents an item in the warehouse inventory. Should have properties like `itemId` (String), `name` (String), and `quantity` (int).
 *     *   `OrderItem`: Represents a specific item and quantity requested within a customer order. Should have properties like `itemId` (String) and `quantity` (int).
 *     *   `Order`: Represents a customer order. Should have properties like `orderId` (int) and a `List<OrderItem>` representing the items requested in the order.
 *     *   `WarehouseSystem`: This class will contain the main logic, managing the inventory list and the orders queue. It should have methods for the operations listed below.
 * 4.  **User Interface:** Provide a command-line interface using `java.util.Scanner` for user interaction. The main application loop should present a menu of options to the user.
 * 5.  **Menu Options:** Implement the following functionalities accessible via the menu:
 *     *   **Add Inventory:** Allows adding a new `InventoryItem` or updating the quantity of an existing item based on `itemId`.
 *     *   **View Inventory:** Displays all items currently in the inventory with their quantities.
 *     *   **Place Order:** Allows the user to create a new `Order` by specifying multiple `OrderItem`s and their quantities. The new order is added to the end of the pending orders `Queue`.
 *     *   **View Pending Orders:** Displays all orders currently waiting in the `Queue`.
 *     *   **Process Next Order:** Attempts to fulfill the order at the front of the `Queue`.
 *         *   Dequeue the order.
 *         *   For each `OrderItem` in the order, check if the required quantity is available in the inventory.
 *         *   If **all** items for the order are available in sufficient quantity: Decrease the quantity of each item in the inventory, print a success message to `System.out`, and the order is considered fulfilled.
 *         *   If **any** item is *not* available in sufficient quantity: Print an error message to `System.err` indicating which item is short and by how much. The order *cannot* be fulfilled at this time, and it should *not* be re-queued (for simplicity, just discard it and report failure).
 *         *   Handle the case where the queue is empty when attempting to process. Print an informative message to `System.out`.
 *     *   **Exit:** Terminates the application.
 * 6.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 7.  **Error Handling:**
 *     *   Use `System.err` to print all error messages (e.g., invalid input, insufficient inventory).
 *     *   Use `System.out` for all normal output (menu, prompts, successful operations, viewing lists/queues).
 *     *   Implement robust input validation (e.g., ensure quantities are positive integers, handle non-integer input gracefully).
 *     *   Use `try-catch` blocks to handle potential runtime exceptions, particularly around user input (`InputMismatchException`) and potentially during order processing (e.g., if an item ID in an order doesn't exist in inventory, although the current design prevents this if validation is done). A class-wide `try-catch` around the main processing loop is required.
 * 8.  **Best Practices:** Adhere to Java best practices including proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments (including Javadoc), and clean code structure.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add Inventory
 * 2. View Inventory
 * 3. Place Order
 * 4. View Pending Orders
 * 5. Process Next Order
 * 6. Exit
 * Enter your choice: 1
 * Enter item ID: A101
 * Enter item name: Laptop
 * Enter quantity: 50
 * Inventory updated/added.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 1
 * Enter item ID: B202
 * Enter item name: Keyboard
 * Enter quantity: 100
 * Inventory updated/added.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 2
 * --- Current Inventory ---
 * Item ID: A101, Name: Laptop, Quantity: 50
 * Item ID: B202, Name: Keyboard, Quantity: 100
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 3
 * Enter order ID (e.g., 1): 1
 * Enter number of items in order: 2
 * Enter item 1 ID: A101
 * Enter item 1 quantity: 2
 * Enter item 2 ID: B202
 * Enter item 2 quantity: 5
 * Order 1 placed and added to queue.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Orders ---
 * Order ID: 1, Items: [Item ID: A101, Quantity: 2, Item ID: B202, Quantity: 5]
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 5
 * Processing Order ID: 1
 * Order 1 fulfilled successfully. Inventory updated.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 2
 * --- Current Inventory ---
 * Item ID: A101, Name: Laptop, Quantity: 48
 * Item ID: B202, Name: Keyboard, Quantity: 95
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 5
 * Processing next order...
 * No pending orders to process.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 3
 * Enter order ID (e.g., 2): 2
 * Enter number of items in order: 1
 * Enter item 1 ID: A101
 * Enter item 1 quantity: 60
 * Order 2 placed and added to queue.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 5
 * Processing Order ID: 2
 * Insufficient inventory for item A101. Required: 60, Available: 48. Order cannot be fulfilled.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Warehouse System.
 * ```
 * 
 * Your solution must compile and run, demonstrating all the required functionalities and adhering to the specified constraints and best practices.
 *
 * EXPLANATION:
 * This solution implements a simplified Warehouse Order Fulfillment System demonstrating the required Java concepts and best practices.
 * 
 * **Core Design:**
 * 
 * *   **`InventoryItem`:** A simple class to hold details of an item in stock (`itemId`, `name`, `quantity`). Includes a `decreaseQuantity` method for managing stock levels during order processing.
 * *   **`OrderItem`:** Represents a line item within an `Order`, specifying the `itemId` and `quantity` requested by the customer.
 * *   **`Order`:** Represents a full customer order, identified by `orderId` and containing a `List` of `OrderItem`s. Using `List` as the type here demonstrates polymorphism, although the implementation used is `ArrayList`.
 * *   **`WarehouseSystem`:** This is the central class.
 *     *   It uses an `ArrayList<InventoryItem>` named `inventoryItems` to store the warehouse stock. `ArrayList` is suitable here as we might iterate, add, or search by ID.
 *     *   It uses a `LinkedList<Order>` (assigned to a `Queue<Order>` variable `pendingOrdersQueue`) to store incoming orders. `Queue` (specifically `LinkedList` which implements `Queue`) is ideal because orders are processed in the First-In, First-Out (FIFO) manner.
 *     *   It contains methods for each menu operation (`addOrUpdateInventory`, `viewInventory`, `placeOrder`, `viewPendingOrders`, `processNextOrder`).
 *     *   A helper method `findInventoryItem` is used internally to locate items in the inventory list.
 *     *   `nextOrderId` is used to automatically generate unique IDs for new orders.
 * 
 * **Required Component Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingOrdersQueue` is declared as `Queue<Order>` and initialized with `new LinkedList<>()`. The `offer()` method is used to add orders to the end, and `peek()` and `poll()` are used to inspect and remove the order from the front for processing.
 * 2.  **`java.util.ArrayList`:** The `inventoryItems` list is initialized with `new ArrayList<>()`. Items are added to it, iterated over, and searched within it.
 * 3.  **`java.util.List`:** The `inventoryItems` field in `WarehouseSystem` is declared as `List<InventoryItem>`, demonstrating coding to the interface. The `items` field in the `Order` class is also declared as `List<OrderItem>`.
 * 4.  **`java.util.Scanner`:** Used in the `main` method of `WarehouseApp` to read user input from the console. `scanner.nextInt()` and `scanner.nextLine()` are used, with careful handling of the newline character left by `nextInt()`.
 * 5.  **`switch` statement:** Used in the `main` method to direct program flow based on the user's menu choice.
 * 6.  **`System.err`:** Used exclusively for printing error messages, such as invalid input, insufficient inventory warnings, or unexpected exceptions.
 * 7.  **`System.out`:** Used for all standard output, including the menu, prompts, successful operation confirmations, and displaying the contents of the inventory and pending orders.
 * 8.  **`try-catch` blocks:**
 *     *   A large `try-catch(Exception e)` block wraps the main `while(running)` loop in the `main` method. This provides class-wide exception handling, catching any unexpected errors that might occur during program execution and printing them to `System.err`.
 *     *   Inner `try-catch(InputMismatchException e)` blocks are used specifically around `scanner.nextInt()` calls to handle cases where the user enters non-integer input when a number is expected. This prevents the program from crashing due to invalid input type. The invalid input is consumed using `scanner.nextLine()` within the catch block to prevent infinite loops.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `InventoryItem`, `OrderItem`, and `Order` are `private` with public getter methods. The `WarehouseSystem` class encapsulates the data structures (`inventoryItems`, `pendingOrdersQueue`) and the logic for manipulating them.
 * *   **Meaningful Names:** Variables (`itemId`, `pendingOrdersQueue`, `nextOrderId`), methods (`addOrUpdateInventory`, `processNextOrder`), and classes are named clearly reflecting their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods explaining their purpose, parameters, and return values. Inline comments explain specific logic points where necessary.
 * *   **Input Validation:** The code checks for non-positive quantities where appropriate (e.g., adding inventory, order items) and uses `try-catch` to handle non-numeric input.
 * *   **Error Handling:** Error conditions like insufficient inventory or an empty queue are explicitly checked and handled, with informative messages printed to `System.err`. Input validation errors are also handled.
 * *   **Clean Code Structure:** The logic is divided into classes and methods with single responsibilities. The `main` method is kept relatively clean, primarily handling the user interface loop and delegating core logic to the `WarehouseSystem` instance. The `printMenu` is a separate helper method.
 * 
 * **Complexity:**
 * 
 * The task requires managing two different collection types (`List` and `Queue`), coordinating operations between them (processing an order involves checking/updating inventory), handling multiple user commands via a `switch`, implementing input validation, and incorporating structured exception handling with both specific (`InputMismatchException`) and general (`Exception`) catches using both `System.out` and `System.err`. This provides a good test of intermediate to advanced Java skills within a practical context.
 * 
 * The processing logic for an order (checking multiple items against inventory before committing to updates) adds a layer of complexity beyond simple add/remove operations on collections. Handling the failure case (insufficient stock) by removing the order and reporting an error is a reasonable design choice for an exam scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an item in the warehouse inventory
class InventoryItem {
    private String itemId;
    private String name;
    private int quantity;

    /**
     * Constructs an InventoryItem.
     * @param itemId The unique identifier for the item.
     * @param name The name of the item.
     * @param quantity The current quantity in stock.
     */
    public InventoryItem(String itemId, String name, int quantity) {
        this.itemId = itemId;
        this.name = name;
        this.quantity = quantity;
    }

    // Getters
    public String getItemId() {
        return itemId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    /**
     * Sets the quantity of the item.
     * @param quantity The new quantity. Must be non-negative.
     */
    public void setQuantity(int quantity) {
        if (quantity >= 0) {
            this.quantity = quantity;
        } else {
            // In a real system, might throw an exception or log a warning
            System.err.println("Warning: Attempted to set negative quantity for item " + itemId);
            this.quantity = 0; // Or handle differently
        }
    }

    /**
     * Decreases the quantity by a specified amount.
     * @param amount The amount to decrease.
     * @return true if quantity was successfully decreased, false otherwise (e.g., insufficient stock).
     */
    public boolean decreaseQuantity(int amount) {
        if (this.quantity >= amount && amount >= 0) {
            this.quantity -= amount;
            return true;
        }
        return false; // Insufficient stock or invalid amount
    }

    @Override
    public String toString() {
        return "Item ID: " + itemId + ", Name: " + name + ", Quantity: " + quantity;
    }
}

// Represents an item and its quantity within an order
class OrderItem {
    private String itemId;
    private int quantity;

    /**
     * Constructs an OrderItem.
     * @param itemId The ID of the item being ordered.
     * @param quantity The quantity of the item being ordered.
     */
    public OrderItem(String itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    // Getters
    public String getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Item ID: " + itemId + ", Quantity: " + quantity;
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<OrderItem> items; // Using List interface type

    /**
     * Constructs an Order.
     * @param orderId The unique identifier for the order.
     * @param items The list of items included in the order.
     */
    public Order(int orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = items; // items is expected to be an ArrayList or similar List implementation
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append(", Items: [");
        for (int i = 0; i < items.size(); i++) {
            sb.append(items.get(i).toString());
            if (i < items.size() - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}

// Manages inventory and pending orders
class WarehouseSystem {
    // Using ArrayList for inventory as we might access by index or iterate
    private List<InventoryItem> inventoryItems;
    // Using Queue (LinkedList implementation) for orders to process them in FIFO order
    private Queue<Order> pendingOrdersQueue;
    private int nextOrderId; // To generate unique order IDs

    /**
     * Constructs a WarehouseSystem.
     */
    public WarehouseSystem() {
        this.inventoryItems = new ArrayList<>(); // Implementation of List
        this.pendingOrdersQueue = new LinkedList<>(); // Implementation of Queue
        this.nextOrderId = 1;
    }

    /**
     * Finds an inventory item by its ID.
     * @param itemId The ID of the item to find.
     * @return The InventoryItem if found, null otherwise.
     */
    private InventoryItem findInventoryItem(String itemId) {
        for (InventoryItem item : inventoryItems) {
            if (item.getItemId().equalsIgnoreCase(itemId)) {
                return item;
            }
        }
        return null;
    }

    /**
     * Adds a new item to inventory or updates the quantity of an existing item.
     * @param itemId The ID of the item.
     * @param name The name of the item.
     * @param quantity The quantity to add. Must be positive.
     */
    public void addOrUpdateInventory(String itemId, String name, int quantity) {
        if (quantity <= 0) {
            System.err.println("Error: Quantity must be positive when adding/updating inventory.");
            return;
        }

        InventoryItem existingItem = findInventoryItem(itemId);

        if (existingItem != null) {
            // Update existing item's quantity
            existingItem.setQuantity(existingItem.getQuantity() + quantity);
            System.out.println("Inventory updated for item ID " + itemId + ".");
        } else {
            // Add new item
            InventoryItem newItem = new InventoryItem(itemId, name, quantity);
            inventoryItems.add(newItem);
            System.out.println("New item added to inventory: " + itemId + ".");
        }
    }

    /**
     * Displays all items currently in the inventory.
     */
    public void viewInventory() {
        if (inventoryItems.isEmpty()) {
            System.out.println("Inventory is empty.");
            return;
        }
        System.out.println("--- Current Inventory ---");
        for (InventoryItem item : inventoryItems) {
            System.out.println(item);
        }
    }

    /**
     * Places a new order and adds it to the pending orders queue.
     * @param items The list of OrderItems in the order.
     * @return The ID of the placed order, or -1 if placing failed (e.g., empty order).
     */
    public int placeOrder(List<OrderItem> items) {
        if (items == null || items.isEmpty()) {
            System.err.println("Error: Cannot place an empty order.");
            return -1;
        }

        // Basic validation: check if all order items have positive quantity
        for(OrderItem oi : items) {
            if (oi.getQuantity() <= 0) {
                 System.err.println("Error: Order item quantity must be positive for item ID " + oi.getItemId() + ".");
                 return -1; // Fail to place order if any item has invalid quantity
            }
        }

        Order newOrder = new Order(nextOrderId++, items); // Auto-increment order ID
        pendingOrdersQueue.offer(newOrder); // Add to the end of the queue
        System.out.println("Order " + newOrder.getOrderId() + " placed and added to queue.");
        return newOrder.getOrderId();
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    public void viewPendingOrders() {
        if (pendingOrdersQueue.isEmpty()) {
            System.out.println("No pending orders.");
            return;
        }
        System.out.println("--- Pending Orders ---");
        // Iterate through the queue without removing elements
        for (Order order : pendingOrdersQueue) {
            System.out.println(order);
        }
    }

    /**
     * Attempts to process the next order in the queue.
     */
    public void processNextOrder() {
        System.out.println("Processing next order...");
        Order orderToProcess = pendingOrdersQueue.peek(); // Look at the front without removing

        if (orderToProcess == null) {
            System.out.println("No pending orders to process.");
            return;
        }

        System.out.println("Attempting to process Order ID: " + orderToProcess.getOrderId());

        // --- Check Inventory Availability ---
        boolean canFulfill = true;
        List<InventoryItem> itemsToUpdate = new ArrayList<>(); // Collect items that need updating
        List<Integer> quantitiesToDecrease = new ArrayList<>(); // Collect corresponding quantities

        for (OrderItem orderItem : orderToProcess.getItems()) {
            InventoryItem inventoryItem = findInventoryItem(orderItem.getItemId());

            if (inventoryItem == null) {
                System.err.println("Error: Item ID " + orderItem.getItemId() + " in Order " + orderToProcess.getOrderId() + " not found in inventory.");
                canFulfill = false;
                break; // Cannot fulfill if item doesn't exist
            }

            if (inventoryItem.getQuantity() < orderItem.getQuantity()) {
                System.err.println("Insufficient inventory for item " + orderItem.getItemId() +
                                   ". Required: " + orderItem.getQuantity() +
                                   ", Available: " + inventoryItem.getQuantity() +
                                   ". Order cannot be fulfilled.");
                canFulfill = false;
                break; // Cannot fulfill if stock is insufficient
            }

            // If check passes, add to list for potential update
            itemsToUpdate.add(inventoryItem);
            quantitiesToDecrease.add(orderItem.getQuantity());
        }

        // --- Fulfill or Fail ---
        if (canFulfill) {
            // Decrease inventory for all items in the order
            for (int i = 0; i < itemsToUpdate.size(); i++) {
                itemsToUpdate.get(i).decreaseQuantity(quantitiesToDecrease.get(i));
            }
            pendingOrdersQueue.poll(); // Remove the order from the queue
            System.out.println("Order " + orderToProcess.getOrderId() + " fulfilled successfully. Inventory updated.");
        } else {
            // Order cannot be fulfilled, remove it and report failure
             pendingOrdersQueue.poll(); // Remove the order from the queue
             System.err.println("Order " + orderToProcess.getOrderId() + " failed to process due to insufficient inventory or missing items. Removed from queue.");
        }
    }
}

// Main application class
public class WarehouseApp {

    public static void main(String[] args) {
        WarehouseSystem warehouse = new WarehouseSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Using a switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Inventory
                        System.out.print("Enter item ID: ");
                        String addItemId = scanner.nextLine();
                        System.out.print("Enter item name: ");
                        String addItemName = scanner.nextLine();
                        int addQuantity = -1;
                        try {
                            System.out.print("Enter quantity: ");
                            addQuantity = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            warehouse.addOrUpdateInventory(addItemId, addItemName, addQuantity);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid quantity. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;

                    case 2: // View Inventory
                        warehouse.viewInventory();
                        break;

                    case 3: // Place Order
                        System.out.print("Enter number of items in order: ");
                        int numItems = -1;
                        try {
                            numItems = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid number of items. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit case 3
                        }

                        if (numItems <= 0) {
                            System.err.println("Error: Order must contain at least one item.");
                            break;
                        }

                        List<OrderItem> orderItems = new ArrayList<>();
                        for (int i = 0; i < numItems; i++) {
                            System.out.println("--- Item " + (i + 1) + " ---");
                            System.out.print("Enter item ID: ");
                            String orderItemId = scanner.nextLine();
                            int orderItemQuantity = -1;
                            try {
                                System.out.print("Enter quantity: ");
                                orderItemQuantity = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                if (orderItemQuantity > 0) {
                                    orderItems.add(new OrderItem(orderItemId, orderItemQuantity));
                                } else {
                                     System.err.println("Warning: Item quantity must be positive. Skipping this item.");
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid quantity for item. Please enter an integer.");
                                scanner.nextLine(); // Consume invalid input
                                // Decide how to handle: skip item or abort order? Aborting order is simpler for exam.
                                orderItems.clear(); // Clear list to indicate invalid order
                                break; // Exit loop for adding items
                            }
                        }

                        if (!orderItems.isEmpty()) {
                             warehouse.placeOrder(orderItems);
                        } else {
                             System.err.println("Order placement cancelled due to invalid item input.");
                        }
                        break;

                    case 4: // View Pending Orders
                        warehouse.viewPendingOrders();
                        break;

                    case 5: // Process Next Order
                        warehouse.processNextOrder();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Warehouse System.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add Inventory");
        System.out.println("2. View Inventory");
        System.out.println("3. Place Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Process Next Order");
        System.out.println("6. Exit");
    }
}
