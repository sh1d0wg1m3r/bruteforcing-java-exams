/*
 * Exam Question #371
 * Generated on: 2025-05-11 23:01:33
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Warehouse Inventory and Shipping Simulation**
 * 
 * You are tasked with developing a simplified warehouse management system in Java. This system will manage a list of inventory items and a queue of pending shipping orders. The user will interact with the system via a command-line interface to perform various operations.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts, including data structures, user input, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of `InventoryItem` objects using an `ArrayList`.
 *     *   Maintain a queue of `ShippingOrder` objects using a `Queue`.
 *     *   Use the `List` interface for declarations where appropriate (e.g., for the inventory collection).
 * 2.  **Classes:**
 *     *   Create an `InventoryItem` class with private fields: `id` (int), `name` (String), `quantity` (int), `price` (double). Include a constructor, public getter methods for all fields, and a public method `updateQuantity(int delta)` that modifies the quantity (handle potential negative results from subtraction, ensuring quantity doesn't go below zero).
 *     *   Create an `OrderItem` class representing an item within a shipping order, with private fields: `itemId` (int), `quantity` (int). Include a constructor and public getter methods.
 *     *   Create a `ShippingOrder` class with private fields: `orderId` (int), `items` (`List<OrderItem>`), `status` (String, e.g., "Pending", "Shipped", "Cancelled"). Include a constructor, public getter methods, and a method `setStatus(String status)`.
 *     *   Create a main class (e.g., `WarehouseManagementSystem`) that contains the `main` method and manages the `List<InventoryItem>` and `Queue<ShippingOrder>`.
 * 3.  **User Interface & Control Flow:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with the following options using a `switch` statement:
 *         1.  Add New Inventory Item
 *         2.  Update Inventory Quantity
 *         3.  Create New Shipping Order
 *         4.  Process Next Pending Order
 *         5.  View Inventory
 *         6.  View Pending Orders Queue
 *         7.  Exit
 *     *   The main loop should continue until the user chooses to exit.
 * 4.  **Operations:**
 *     *   **Add New Inventory Item:** Prompt for ID, name, quantity, and price. Validate that ID is unique and quantity/price are non-negative. Add the new item to the inventory list.
 *     *   **Update Inventory Quantity:** Prompt for item ID and the quantity change (positive for adding stock, negative for removing). Find the item by ID and update its quantity. Handle cases where the item is not found or the quantity update results in a negative value (report error, do not update).
 *     *   **Create New Shipping Order:** Prompt for a new order ID. Then, repeatedly prompt the user to enter item ID and quantity for items to include in the order. The user should be able to add multiple items to one order (e.g., by entering 0 for item ID to finish adding items). Create `OrderItem` objects and add them to a `List` within the `ShippingOrder`. Add the new `ShippingOrder` to the queue. *Do not check inventory availability at this stage.*
 *     *   **Process Next Pending Order:** Dequeue the next order from the queue. Attempt to fulfill the order by checking and reducing inventory quantities for each `OrderItem`.
 *         *   If all items in the order can be fulfilled (sufficient stock for all), update the inventory, set the order status to "Shipped", and report success.
 *         *   If *any* item in the order has insufficient stock, do *not* update any inventory quantities for this order. Set the order status to "Cancelled" and report which item caused the cancellation due to low stock. The order is removed from the queue regardless of success or failure.
 *         *   Handle the case where the queue is empty.
 *     *   **View Inventory:** Print details of all items in the inventory list.
 *     *   **View Pending Orders Queue:** Print details of all orders currently in the queue.
 * 5.  **Error Handling & Output:**
 *     *   Use `System.err` to print all error messages (e.g., invalid input, item not found, insufficient stock, queue empty).
 *     *   Use `System.out` for all normal output (menus, prompts, success messages, item/order details).
 *     *   Implement class-wide or operation-specific `try-catch` blocks to handle potential exceptions, especially related to user input (`InputMismatchException`). Ensure the program doesn't crash due to bad input.
 *     *   Implement input validation (e.g., ensuring numbers are positive where required).
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Follow proper Java coding conventions (indentation, braces, etc.).
 *     *   Ensure encapsulation in your classes.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input based on the chosen option, display results or error messages, and loop until exited.
 * 
 * ```
 * --- Warehouse Management Menu ---
 * 1. Add New Inventory Item
 * 2. Update Inventory Quantity
 * 3. Create New Shipping Order
 * 4. Process Next Pending Order
 * 5. View Inventory
 * 6. View Pending Orders Queue
 * 7. Exit
 * Enter your choice:
 * ```
 * 
 * Error messages should go to `System.err`, regular messages to `System.out`.
 *
 * EXPLANATION:
 * The provided solution implements the `WarehouseManagementSystem` as described in the problem statement, demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   `InventoryItem`, `OrderItem`, and `ShippingOrder` classes are created to model the entities in the system.
 *     *   Fields in these classes are `private`, and access is provided through `public` getter methods, adhering to encapsulation principles.
 *     *   `InventoryItem` includes a `updateQuantity` method to manage its own state change safely.
 *     *   `ShippingOrder` includes a `setStatus` method.
 *     *   `toString()` methods are overridden for easy printing of object details.
 * 
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`):**
 *     *   `List<InventoryItem> inventory = new ArrayList<>();` is used to store the inventory items. `List` is used for the type declaration, and `ArrayList` for the concrete implementation, demonstrating the use of the interface. `ArrayList` provides dynamic resizing and efficient random access, suitable for looking up items by ID (though a `Map` might be more efficient for large inventories, `ArrayList` fulfills the requirement).
 *     *   `Queue<ShippingOrder> orderQueue = new LinkedList<>();` is used to store pending shipping orders. `Queue` is used for the type declaration, and `LinkedList` is chosen as it implements the `Queue` interface and is efficient for adding/removing elements from the ends. Orders are added using `offer()` and retrieved/removed using `poll()`. `peek()` is used to look at the next order without removing it during the stock check phase.
 * 
 * 3.  **User Input (`Scanner`), Control Flow (`switch`), and Output (`System.out`, `System.err`):**
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   The main application loop presents a menu, and a `switch` statement handles the user's choice, directing execution to the appropriate private method.
 *     *   `System.out.println` is used for all normal output, including the menu, prompts, success messages, and item/order details.
 *     *   `System.err.println` is specifically used for printing error messages, fulfilling the requirement to distinguish errors from standard output.
 * 
 * 4.  **Exception Handling (`try-catch`):**
 *     *   A top-level `try-catch` block is placed around the main loop's interaction with the `Scanner` to catch `InputMismatchException` if the user enters non-integer input when an integer is expected for the menu choice. This prevents the program from crashing. The invalid input is consumed using `scanner.nextLine()`.
 *     *   `try-catch` blocks are also used within specific methods like `addInventoryItem`, `updateInventoryQuantity`, and `createShippingOrder` to handle `InputMismatchException` when reading specific numeric inputs, providing more localized error messages.
 *     *   A general `catch (Exception e)` is included in the main loop's `try-catch` to catch any other unexpected runtime errors, print an error message to `System.err`, and print the stack trace for debugging. This demonstrates a robust approach to handling unforeseen issues.
 *     *   Business logic errors (like item not found or insufficient stock) are handled using `if` conditions and reported via `System.err`, as they are not necessarily exceptional program states but rather invalid operations based on the current data.
 * 
 * 5.  **Operations and Logic:**
 *     *   Each menu option corresponds to a private method (`addInventoryItem`, `updateInventoryQuantity`, etc.) which encapsulates the logic for that operation.
 *     *   Input validation is performed within these methods (e.g., checking for non-negative quantities/prices, unique item IDs).
 *     *   The `createShippingOrder` method correctly allows adding multiple items and adds the complete order to the `orderQueue`. It defers inventory checks.
 *     *   The `processNextOrder` method demonstrates the core logic involving both data structures:
 *         *   It first peeks at the next order in the queue.
 *         *   It iterates through the order's items and checks inventory availability *without* modifying inventory yet.
 *         *   Based on the availability check (`canFulfill`), it then removes the order from the queue (`poll()`).
 *         *   If fulfillable, it updates the inventory quantities using the `updateQuantity` method and sets the order status to "Shipped".
 *         *   If not fulfillable, it sets the order status to "Cancelled" and leaves the inventory unchanged.
 *     *   Helper methods like `findInventoryItemById` improve code organization and readability.
 * 
 * 6.  **Best Practices:**
 *     *   Variable and method names are descriptive (e.g., `inventory`, `orderQueue`, `addInventoryItem`, `findInventoryItemById`).
 *     *   Comments are used to explain the purpose of classes, methods, and key logic sections (like the `updateQuantity` return value or the order processing steps).
 *     *   Code is formatted consistently.
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a practical scenario, requiring careful state management, input handling, and error reporting.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class representing an item in the inventory
class InventoryItem {
    private int id;
    private String name;
    private int quantity;
    private double price;

    public InventoryItem(int id, String name, int quantity, double price) {
        this.id = id;
        this.name = name;
        this.quantity = quantity;
        this.price = price;
    }

    public int getId() { return id; }
    public String getName() { return name; }
    public int getQuantity() { return quantity; }
    public double getPrice() { return price; }

    /**
     * Updates the quantity of the inventory item.
     *
     * @param delta The amount to change the quantity by (positive for add, negative for remove).
     * @return true if the update was successful, false if the resulting quantity would be negative.
     */
    public boolean updateQuantity(int delta) {
        if (this.quantity + delta < 0) {
            return false; // Cannot result in negative quantity
        }
        this.quantity += delta;
        return true;
    }

    @Override
    public String toString() {
        return "Item ID: " + id + ", Name: " + name + ", Quantity: " + quantity + ", Price: $" + String.format("%.2f", price);
    }
}

// Class representing an item within a shipping order
class OrderItem {
    private int itemId;
    private int quantity;

    public OrderItem(int itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public int getItemId() { return itemId; }
    public int getQuantity() { return quantity; }

    @Override
    public String toString() {
        return "  - Item ID: " + itemId + ", Quantity: " + quantity;
    }
}

// Class representing a shipping order
class ShippingOrder {
    private static int nextOrderId = 1; // Simple auto-incrementing ID
    private int orderId;
    private List<OrderItem> items; // Using List interface
    private String status; // e.g., "Pending", "Shipped", "Cancelled"

    public ShippingOrder(List<OrderItem> items) {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(items); // Create a copy of the list
        this.status = "Pending"; // Default status
    }

    public int getOrderId() { return orderId; }
    public List<OrderItem> getItems() { return items; } // Returns a reference, could return immutable copy for safety
    public String getStatus() { return status; }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append(", Status: ").append(status).append("\n");
        sb.append("  Items:\n");
        for (OrderItem item : items) {
            sb.append(item.toString()).append("\n");
        }
        return sb.toString();
    }
}

// Main class managing the warehouse system
public class WarehouseManagementSystem {

    private List<InventoryItem> inventory; // Using List interface
    private Queue<ShippingOrder> orderQueue; // Using Queue interface
    private Scanner scanner;

    public WarehouseManagementSystem() {
        inventory = new ArrayList<>(); // Using ArrayList implementation
        orderQueue = new LinkedList<>(); // Using LinkedList as it implements Queue
        scanner = new Scanner(System.in);
    }

    public void run() {
        int choice = -1;
        while (choice != 7) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addInventoryItem();
                        break;
                    case 2:
                        updateInventoryQuantity();
                        break;
                    case 3:
                        createShippingOrder();
                        break;
                    case 4:
                        processNextOrder();
                        break;
                    case 5:
                        viewInventory();
                        break;
                    case 6:
                        viewPendingOrders();
                        break;
                    case 7:
                        System.out.println("Exiting Warehouse Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
            System.out.println(); // Add a blank line for readability
        }
        scanner.close();
    }

    private void printMenu() {
        System.out.println("--- Warehouse Management Menu ---");
        System.out.println("1. Add New Inventory Item");
        System.out.println("2. Update Inventory Quantity");
        System.out.println("3. Create New Shipping Order");
        System.out.println("4. Process Next Pending Order");
        System.out.println("5. View Inventory");
        System.out.println("6. View Pending Orders Queue");
        System.out.println("7. Exit");
    }

    private void addInventoryItem() {
        System.out.println("--- Add New Inventory Item ---");
        try {
            System.out.print("Enter Item ID: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Check if ID already exists
            if (findInventoryItemById(id) != null) {
                System.err.println("Error: Item with ID " + id + " already exists.");
                return;
            }

            System.out.print("Enter Item Name: ");
            String name = scanner.nextLine();

            System.out.print("Enter Quantity: ");
            int quantity = scanner.nextInt();
            scanner.nextLine(); // Consume newline
            if (quantity < 0) {
                System.err.println("Error: Quantity cannot be negative.");
                return;
            }

            System.out.print("Enter Price: ");
            double price = scanner.nextDouble();
            scanner.nextLine(); // Consume newline
            if (price < 0) {
                System.err.println("Error: Price cannot be negative.");
                return;
            }

            InventoryItem newItem = new InventoryItem(id, name, quantity, price);
            inventory.add(newItem);
            System.out.println("Inventory item added successfully.");

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter the correct data type (e.g., number for ID, quantity, price).");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    private void updateInventoryQuantity() {
        System.out.println("--- Update Inventory Quantity ---");
        try {
            System.out.print("Enter Item ID to update: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            InventoryItem item = findInventoryItemById(id);
            if (item == null) {
                System.err.println("Error: Item with ID " + id + " not found.");
                return;
            }

            System.out.print("Enter quantity change (e.g., 10 for adding 10, -5 for removing 5): ");
            int delta = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            if (item.updateQuantity(delta)) {
                System.out.println("Inventory quantity updated successfully. New quantity for " + item.getName() + ": " + item.getQuantity());
            } else {
                System.err.println("Error: Cannot reduce quantity below zero. Current quantity: " + item.getQuantity());
            }

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number for ID and quantity change.");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    private void createShippingOrder() {
        System.out.println("--- Create New Shipping Order ---");
        List<OrderItem> orderItems = new ArrayList<>(); // Using ArrayList for items in this order

        System.out.println("Enter items for the order (Enter Item ID 0 to finish):");

        while (true) {
            try {
                System.out.print("Enter Item ID (0 to finish): ");
                int itemId = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (itemId == 0) {
                    if (orderItems.isEmpty()) {
                        System.out.println("Order cancelled as no items were added.");
                        return; // Exit method if no items added
                    }
                    break; // Finish adding items
                }

                // Optional: Check if item exists in inventory? Requirement says NO check at this stage.
                // InventoryItem item = findInventoryItemById(itemId);
                // if (item == null) {
                //     System.err.println("Warning: Item ID " + itemId + " not found in inventory. Adding to order anyway.");
                //     // Could skip adding this item, but requirement says add now, validate on process.
                // }


                System.out.print("Enter Quantity for Item ID " + itemId + ": ");
                int quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive. Item not added to order.");
                    continue; // Ask for next item
                }

                orderItems.add(new OrderItem(itemId, quantity));
                System.out.println("Item added to order.");

            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for Item ID and Quantity.");
                scanner.nextLine(); // Consume the invalid input
            }
        }

        ShippingOrder newOrder = new ShippingOrder(orderItems);
        orderQueue.offer(newOrder); // Add order to the end of the queue
        System.out.println("Shipping order " + newOrder.getOrderId() + " created and added to the queue.");
    }

    private void processNextOrder() {
        System.out.println("--- Process Next Pending Order ---");
        if (orderQueue.isEmpty()) {
            System.err.println("Error: No pending orders in the queue.");
            return;
        }

        ShippingOrder orderToProcess = orderQueue.peek(); // Peek to check before removing
        System.out.println("Attempting to process Order ID: " + orderToProcess.getOrderId());

        // --- Check Stock Availability First ---
        boolean canFulfill = true;
        List<InventoryItem> itemsToUpdate = new ArrayList<>(); // Temporarily store items found
        for (OrderItem orderItem : orderToProcess.getItems()) {
            InventoryItem inventoryItem = findInventoryItemById(orderItem.getItemId());
            if (inventoryItem == null) {
                System.err.println("Error processing Order ID " + orderToProcess.getOrderId() + ": Item ID " + orderItem.getItemId() + " not found in inventory.");
                canFulfill = false;
                break; // Cannot fulfill if item not found
            }
            if (inventoryItem.getQuantity() < orderItem.getQuantity()) {
                System.err.println("Error processing Order ID " + orderToProcess.getOrderId() + ": Insufficient stock for Item ID " + orderItem.getItemId() + ". Required: " + orderItem.getQuantity() + ", Available: " + inventoryItem.getQuantity());
                canFulfill = false;
                break; // Cannot fulfill if insufficient stock
            }
            itemsToUpdate.add(inventoryItem); // Store reference if check passes
        }

        // --- Process Based on Check ---
        ShippingOrder processedOrder = orderQueue.poll(); // Remove the order from the queue

        if (canFulfill) {
            // If all items available, update inventory
            for (int i = 0; i < orderToProcess.getItems().size(); i++) {
                 OrderItem orderItem = orderToProcess.getItems().get(i);
                 InventoryItem inventoryItem = itemsToUpdate.get(i); // Use the stored reference

                 // This update should not fail because we already checked quantity
                 inventoryItem.updateQuantity(-orderItem.getQuantity());
            }
            processedOrder.setStatus("Shipped");
            System.out.println("Order ID " + processedOrder.getOrderId() + " successfully shipped.");
        } else {
            // If not all items available, cancel the order
            processedOrder.setStatus("Cancelled");
            System.out.println("Order ID " + processedOrder.getOrderId() + " cancelled due to insufficient stock or item not found.");
            // Inventory quantities remain unchanged
        }
        // Note: The processedOrder object is now removed from the queue.
        // It could potentially be added to a history list, but that's beyond the requirements.
    }

    private void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (InventoryItem item : inventory) {
                System.out.println(item);
            }
        }
    }

    private void viewPendingOrders() {
        System.out.println("--- Pending Orders Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Order queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (ShippingOrder order : orderQueue) {
                System.out.println("--- Position " + index++ + " ---");
                System.out.println(order);
            }
        }
    }

    // Helper method to find an inventory item by ID
    private InventoryItem findInventoryItemById(int id) {
        for (InventoryItem item : inventory) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null; // Item not found
    }

    public static void main(String[] args) {
        WarehouseManagementSystem system = new WarehouseManagementSystem();
        system.run();
    }
}
