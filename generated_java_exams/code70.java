/*
 * Exam Question #70
 * Generated on: 2025-05-11 22:08:44
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing System
 * 
 * **Objective:** Design and implement a simple Task Processing System in Java. This system should manage tasks that arrive and are placed in a queue for processing. Once processed, tasks are moved to a list of completed items. The system must be interactive, allowing users to add new tasks, process the next task in the queue, and view the status of pending and completed tasks through a menu-driven interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:**
 *     *   Create a `Task` class with private fields: `taskId` (int), `description` (String), and `status` (String). The status should represent the task's current state (e.g., "Pending", "Processing", "Completed").
 *     *   Include a constructor to initialize a task with an ID and description, setting the initial status to "Pending".
 *     *   Provide public getter methods for all fields.
 *     *   Include public methods `markAsProcessing()` and `markAsCompleted()` to update the task's status.
 *     *   Override the `toString()` method to provide a clear string representation of the task (e.g., `[ID=1] Write Report [Pending]`).
 * 
 * 2.  **TaskProcessingSystem Class:**
 *     *   Create a `TaskProcessingSystem` class to manage the collections of tasks.
 *     *   Declare a private field `taskQueue` of type `java.util.Queue<Task>`. Use a `java.util.LinkedList` as the concrete implementation.
 *     *   Declare a private field `completedTasks` of type `java.util.List<Task>`. Use a `java.util.ArrayList` as the concrete implementation.
 *     *   Include a private field `nextTaskId` (int) to generate unique IDs for new tasks, starting from 1.
 *     *   Provide a public constructor to initialize the `taskQueue`, `completedTasks`, and `nextTaskId`.
 *     *   Implement a public method `addTask(String description)`: Creates a new `Task` object with the next available ID and the provided description, and adds it to the `taskQueue`. Include basic validation to ensure the description is not empty.
 *     *   Implement a public method `processNextTask()`: Removes the task at the head of the `taskQueue`, updates its status to "Processing" (simulated), then updates its status to "Completed", and finally adds it to the `completedTasks` list. This method should handle the case where the `taskQueue` is empty by printing an informative message.
 *     *   Implement public methods `viewPendingTasks()` and `viewCompletedTasks()`: These methods should iterate through the respective collections and print the details of each task. If a collection is empty, print a message indicating so.
 * 
 * 3.  **Main Application (`ExamTaskSystem` class):**
 *     *   Create a class `ExamTaskSystem` with a `public static void main(String[] args)` method.
 *     *   Inside `main`, use `java.util.Scanner` to read input from `System.in`.
 *     *   Create an instance of `TaskProcessingSystem`.
 *     *   Implement a main application loop that presents the following menu to the user using `System.out`:
 *         ```
 *         --- Task Processing System ---
 * 
 *         Choose an option:
 *         1. Add New Task
 *         2. Process Next Task
 *         3. View Pending Tasks
 *         4. View Completed Tasks
 *         5. Exit
 *         Enter choice:
 *         ```
 *     *   Use a `switch` statement to handle the user's integer input for the menu choice.
 *     *   For option 1, prompt the user for the task description and call the `addTask` method.
 *     *   For option 2, call the `processNextTask` method.
 *     *   For option 3, call the `viewPendingTasks` method.
 *     *   For option 4, call the `viewCompletedTasks` method.
 *     *   For option 5, exit the application loop.
 *     *   Handle invalid menu choices (numbers outside the range 1-5 or non-integer input) by printing an error message using `System.err` and allowing the user to try again.
 *     *   Implement class-wide exception handling using `try-catch` block(s) within the main loop to catch potential runtime exceptions that might occur during user input processing or method calls. Print a generic error message to `System.err` if an unexpected exception is caught.
 *     *   Ensure the `Scanner` is closed when the program exits.
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style for methods).
 *     *   Implement input validation as described (non-empty description, valid menu choice).
 *     *   Use `System.out` for normal output and `System.err` for error messages.
 *     *   Structure your code cleanly. For the exam, all classes can be included in a single `.java` file.
 * 
 * **Expected Output:** The program should run interactively, displaying the menu, accepting input, performing actions, and showing results or errors as described in the requirements and illustrated in the example interaction flow provided in the brainstorming phase (not included here to save space, but assume standard menu interaction, task addition/processing confirmations, list displays, and error messages).
 *
 * EXPLANATION:
 * This solution implements a simple Task Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class models a single task with its ID, description, and status. It follows encapsulation by keeping fields private and providing public getters and status update methods. The `toString()` method makes printing task details convenient.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   It uses a `java.util.Queue<Task>` (`taskQueue`) implemented by `java.util.LinkedList`. The Queue is the natural choice for managing pending tasks that are processed in a First-In, First-Out (FIFO) manner. `offer()` is used for adding tasks, and `poll()` is used for removing the head of the queue.
 *     *   It uses a `java.util.List<Task>` (`completedTasks`) implemented by `java.util.ArrayList`. The List is suitable for storing completed tasks, allowing easy iteration and access. The field is declared using the `List` interface, adhering to the principle of programming to interfaces.
 *     *   `nextTaskId` ensures each task gets a unique identifier.
 *     *   Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewCompletedTasks` encapsulate the core logic of managing the task flow between the queue and the list. `processNextTask` includes specific logic to handle the case of an empty queue using `System.err`.
 * 
 * 3.  **`ExamTaskSystem` Class (Main):**
 *     *   The `main` method provides the command-line interface.
 *     *   `java.util.Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement effectively handles the menu navigation based on the user's integer input.
 *     *   `System.out` is used for displaying the menu, prompts, and successful operation messages.
 *     *   `System.err` is specifically used for displaying error messages, such as invalid menu input, out-of-range choices, or attempting to process an empty queue (as handled by the `TaskProcessingSystem` and reported back).
 *     *   **Input Validation:** The code checks if the input is an integer using `scanner.hasNextInt()` before reading it. If not, it prints an error to `System.err` and consumes the invalid token using `scanner.next()` to prevent an infinite loop caused by the scanner repeatedly failing on the same input. It also consumes the newline character left by `scanner.nextInt()` using `scanner.nextLine()` to avoid issues with subsequent `nextLine()` calls for task descriptions.
 *     *   **Exception Handling:** A `try-catch(Exception e)` block is placed around the core logic within the `while` loop (after the initial input reading and validation). This provides class-wide exception handling for the main execution flow, catching any unexpected runtime errors that might occur during the switch statement or calls to the `TaskProcessingSystem` methods. It prints a generic error message to `System.err`.
 *     *   The `Scanner` resource is properly closed when the application exits.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a cohesive, practical scenario, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Task class representing a single task
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Pending", "Processing", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // Getters for task properties
    public int getTaskId() { return taskId; }
    public String getDescription() { return description; }
    public String getStatus() { return status; }

    /**
     * Updates the task status to "Processing".
     */
    public void markAsProcessing() { this.status = "Processing"; }

    /**
     * Updates the task status to "Completed".
     */
    public void markAsCompleted() { this.status = "Completed"; }

    /**
     * Provides a string representation of the task.
     * @return A formatted string including task ID, description, and status.
     */
    @Override
    public String toString() {
        return "[ID=" + taskId + "] " + description + " [" + status + "]";
    }
}

// TaskProcessingSystem class managing the queue and completed list
class TaskProcessingSystem {
    // Using Queue interface with LinkedList implementation for pending tasks
    private Queue<Task> taskQueue;
    // Using List interface with ArrayList implementation for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskProcessingSystem, initializing collections and ID counter.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // Tasks waiting to be processed
        this.completedTasks = new ArrayList<>(); // Tasks that are finished
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the description is not empty.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        // offer() is generally preferred over add() for queues as it handles capacity-constrained queues
        taskQueue.offer(newTask);
        System.out.println("Added Task #" + newTask.getTaskId() + ": \"" + newTask.getDescription() + "\" to the queue.");
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the pending queue, updates its status,
     * and adds it to the completed tasks list.
     * Prints an error message if the queue is empty.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task task = taskQueue.poll();
        System.out.println("--- Processing Task ---");
        System.out.println("Starting: " + task);
        task.markAsProcessing();

        // In a real system, actual work would happen here.
        // For this simulation, we just update status and move it.

        task.markAsCompleted();
        // add() appends the element to the end of the list
        completedTasks.add(task);
        System.out.println("Completed: " + task);
        System.out.println("-----------------------\n");
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates through the queue without removing elements.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate over the queue using a for-each loop
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Displays all tasks that have been completed.
     * Iterates through the list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks List ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate over the list using a standard for loop to show index
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
        System.out.println("----------------------------\n");
    }
}

// Main class for the Task Processing System user interface
public class ExamTaskSystem {

    public static void main(String[] args) {
        // Scanner for reading input from the console
        Scanner scanner = new Scanner(System.in);
        // Instantiate the task processing system
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true; // Flag to control the main loop

        System.out.println("--- Task Processing System ---");

        // Main application loop
        while (running) {
            // Display menu options
            System.out.println("\nChoose an option:");
            System.out.println("1. Add New Task");
            System.out.println("2. Process Next Task");
            System.out.println("3. View Pending Tasks");
            System.out.println("4. View Completed Tasks");
            System.out.println("5. Exit");
            System.out.print("Enter choice: ");

            // Class-wide exception handling for potential issues during input or operations
            try {
                int choice = -1;
                // Validate if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();
                } else {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number (1-5).");
                    // Consume the invalid token to prevent an infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop body and show menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        // Read the full line for the task description
                        String description = scanner.nextLine();
                        system.addTask(description);
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        system.viewPendingTasks();
                        break;
                    case 4:
                        system.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        running = false; // Set flag to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // In a real application, you might log the full stack trace for debugging:
                // e.printStackTrace();
            }
        }

        // Close the scanner resource
        scanner.close();
        System.out.println("Scanner closed.");
    }
}
