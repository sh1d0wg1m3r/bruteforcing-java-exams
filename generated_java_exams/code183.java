/*
 * Exam Question #183
 * Generated on: 2025-05-11 22:27:41
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Objective:** Design and implement a command-line based Task Processing System that manages tasks using queues for processing order and lists for historical tracking. This task requires demonstrating proficiency in core Java collections, flow control, user input handling, and robust error management.
 * 
 * **Scenario:** You are developing a simple system to manage tasks. Users can submit tasks, process the next task in line, and view the list of pending tasks or the complete history of all tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create an `enum` called `TaskStatus` with the states: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 *     *   Create a class called `Task` to represent a task. It must have:
 *         *   A unique integer `taskId`.
 *         *   A `String` `description`.
 *         *   A `TaskStatus` `status`.
 *         *   A constructor `Task(int taskId, String description)` that initializes the status to `PENDING`.
 *         *   Getter methods for all fields (`getTaskId`, `getDescription`, `getStatus`).
 *         *   A setter method `setStatus(TaskStatus status)`.
 *         *   Override the `toString()` method to provide a user-friendly representation of the task (including ID, description, and status).
 * 
 * 2.  **Task Management System:**
 *     *   Create a class (e.g., `TaskProcessingSystem`) that manages the tasks.
 *     *   This class must use:
 *         *   A `java.util.Queue<Task>` (e.g., `LinkedList`) to hold tasks that are waiting to be processed.
 *         *   A `java.util.List<Task>` (implemented using `java.util.ArrayList<Task>`) to keep a history of *all* tasks ever submitted, regardless of their current status.
 *     *   Implement the following functionalities as methods within this class:
 *         *   **`submitTask(String description)`:** Creates a new `Task` with an auto-incrementing unique ID, adds it to both the processing queue and the history list, and prints a confirmation message using `System.out`. Validate that the description is not empty or just whitespace; if invalid, print an error using `System.err` and do not submit the task.
 *         *   **`processNextTask()`:**
 *             *   Removes the next task from the processing queue.
 *             *   If the queue is empty, print an error message using `System.err`.
 *             *   If a task is retrieved, simulate processing. For the exam, simulate a 20% chance of the task *failing* processing.
 *             *   Update the status of the task in the `taskHistory` list. If simulation indicates failure, set status to `FAILED`; otherwise, set status to `COMPLETED`.
 *             *   Print the outcome of the processing (success or failure) using `System.out` or `System.err` appropriately.
 *         *   **`viewQueue()`:** Prints the details of all tasks currently in the processing queue using `System.out`. If the queue is empty, print a message indicating that.
 *         *   **`viewHistory()`:** Prints the details of all tasks in the history list using `System.out`. If the history is empty, print a message indicating that.
 *     *   Include a `run()` method that contains the main application loop:
 *         *   Use `java.util.Scanner` to read user commands from the console.
 *         *   Implement a `switch` statement to handle different commands: `submit`, `process`, `view queue`, `view history`, `exit`.
 *         *   Prompt the user for input.
 *         *   Handle invalid commands by printing an error message using `System.err`.
 *         *   The loop should continue until the user enters the `exit` command.
 *         *   Ensure the `Scanner` is properly closed when the program exits.
 * 
 * 3.  **Error Handling and Best Practices:**
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main command processing loop in the `run()` method. This block should catch general `Exception` and print an error message using `System.err`.
 *     *   Use `System.out` for normal program output (prompts, confirmations, successful operations, list views).
 *     *   Use `System.err` for all error messages (invalid input, empty queue, processing failures, exceptions).
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Add comments where necessary to explain complex logic.
 *     *   Ensure input validation is performed (e.g., for the submit command).
 * 
 * **Expected Output:** The program should interact with the user via the console, accepting commands and printing relevant output or error messages. Examples:
 * 
 * ```
 * Enter command (submit <desc>, process, view queue, view history, exit): submit Task A
 * Task 1 submitted: Task A [PENDING]
 * Enter command (submit <desc>, process, view queue, view history, exit): submit Task B
 * Task 2 submitted: Task B [PENDING]
 * Enter command (submit <desc>, process, view queue, view history, exit): view queue
 * Queue:
 * Task 1: Task A [PENDING]
 * Task 2: Task B [PENDING]
 * Enter command (submit <desc>, process, view queue, view history, exit): process
 * Processing Task 1...
 * Task 1: Task A [COMPLETED]
 * Enter command (submit <desc>, process, view queue, view history, exit): process
 * Processing Task 2...
 * Task 2: Task B [FAILED] // Or COMPLETED, based on random chance
 * Enter command (submit <desc>, process, view queue, view history, exit): process
 * Error: No tasks in the queue to process.
 * Enter command (submit <desc>, process, view queue, view history, exit): view history
 * History:
 * Task 1: Task A [COMPLETED]
 * Task 2: Task B [FAILED]
 * Enter command (submit <desc>, process, view queue, view history, exit): invalid command
 * Error: Unknown command. Please use submit <desc>, process, view queue, view history, or exit.
 * Enter command (submit <desc>, process, view queue, view history, exit): exit
 * Exiting Task Processing System.
 * ```
 * 
 * **Grading Criteria:**
 * *   Correct usage of all required Java components (Queue, ArrayList, List, Scanner, switch, System.err, System.out, try-catch).
 * *   Correct implementation of Task class and TaskStatus enum.
 * *   Correct implementation of TaskProcessingSystem methods (`submitTask`, `processNextTask`, `viewQueue`, `viewHistory`).
 * *   Correct implementation of the main `run()` loop and command handling.
 * *   Proper input validation and error handling using `System.err`.
 * *   Effective use of `System.out` for normal output.
 * *   Appropriate class-wide exception handling.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Correct simulation of task processing and status updates.
 * 
 * **Note:** Implement the entire solution within a single `.java` file for submission convenience in an exam setting.
 *
 * EXPLANATION:
 * This solution implements the Task Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`), providing a clear and type-safe way to manage task status.
 * 2.  **`Task` Class:** Encapsulates the data for a single task (ID, description, status). It uses private fields and public getter/setter methods (`setStatus`), adhering to encapsulation principles. The constructor initializes a task with a `PENDING` status. The `toString()` method is overridden for easy printing of task details.
 * 3.  **`TaskProcessingSystem` Class:**
 *     *   **Collections:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized as `new LinkedList<>()`. This correctly uses the `Queue` interface and an implementation (`LinkedList`) to manage tasks in a FIFO (First-In, First-Out) manner for processing.
 *         *   `taskHistory`: Declared as `List<Task>` and initialized as `new ArrayList<>()`. This correctly uses the `List` interface and its `ArrayList` implementation to store all tasks submitted, providing a dynamic, index-based collection for historical tracking.
 *     *   **`submitTask(String description)`:**
 *         *   Generates a unique `taskId` using `nextTaskId++`.
 *         *   Performs basic input validation on the description using `trim().isEmpty()`. If invalid, it prints an error to `System.err` and returns.
 *         *   Creates a new `Task` object.
 *         *   Adds the *same* `Task` object reference to both the `taskQueue` and `taskHistory`. This is crucial because when the task's status is updated later (during processing), the update to the object will be reflected in both collections (though it will be removed from the queue after processing).
 *         *   Prints a confirmation message using `System.out`.
 *     *   **`processNextTask()`:**
 *         *   Uses `taskQueue.poll()` to retrieve and remove the next task from the front of the queue. `poll()` is preferred over `remove()` for queues when handling potentially empty queues, as it returns `null` instead of throwing an exception.
 *         *   Checks if `taskToProcess` is `null`. If so, it means the queue was empty, and an error message is printed to `System.err`.
 *         *   Simulates processing success/failure using `random.nextDouble() < 0.20`.
 *         *   Updates the status of the retrieved `taskToProcess` object using `setStatus()`. Since the `taskHistory` list holds a reference to this exact object, updating the polled object automatically updates the status in the history list as well.
 *         *   Prints the processing outcome using `System.out` for success and `System.err` for failure simulation.
 *     *   **`viewQueue()` and `viewHistory()`:**
 *         *   Iterate through the respective collections (`taskQueue` and `taskHistory`) to print the details of each task using the `Task` class's `toString()` method.
 *         *   Check if the collections are empty and print appropriate messages using `System.out`. Iterating the `Queue` directly (as done in `viewQueue`) uses its iterator and does not remove elements.
 *     *   **`run()` Method:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   Uses `Scanner` to read user input line by line.
 *         *   Parses the command and its arguments using `split(" ", 2)`.
 *         *   Uses a `switch` statement to direct execution based on the command (`submit`, `process`, `view`, `exit`). This fulfills the requirement for using a switch statement for flow control.
 *         *   Handles invalid commands by printing an error to `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This catches any unexpected runtime exceptions that might occur within the command processing loop, preventing the program from crashing abruptly and providing a generic error message using `System.err`.
 *         *   **Resource Management:** The `finally` block ensures that the `Scanner` resource is closed when the loop terminates or an exception occurs, preventing resource leaks.
 *     *   **`main` Method:** The entry point of the program, creating an instance of `TaskProcessingSystem` and calling its `run()` method to start the application.
 * 
 * This solution effectively integrates all the required Java components into a practical scenario, demonstrates proper data structures usage, handles user input and different commands, incorporates input validation and specific error messages using `System.err`, manages normal output with `System.out`, and includes robust class-wide exception handling, all while adhering to good programming practices like encapsulation and meaningful naming.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Class to represent a Task
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including task ID, description, and status.
     */
    @Override
    public String toString() {
        return String.format("Task %d: %s [%s]", taskId, description, status);
    }
}

// Main class for the Task Processing System
public class TaskProcessingSystem {

    // Required components: Queue, List (ArrayList implementation), Scanner
    private Queue<Task> taskQueue;
    private List<Task> taskHistory;
    private int nextTaskId; // For generating unique task IDs
    private Scanner scanner;
    private Random random; // For simulating processing failure

    /**
     * Constructs the Task Processing System.
     */
    public TaskProcessingSystem() {
        // Initialize required collections
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.taskHistory = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
        this.random = new Random(); // Initialize random for simulation
    }

    /**
     * Submits a new task to the system.
     * Adds the task to both the processing queue and the history list.
     * @param description The description of the task.
     */
    public void submitTask(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Do not submit task
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.add(newTask);
        taskHistory.add(newTask); // Add the same task object reference to history
        System.out.println(newTask + " submitted."); // Use Task's toString()
    }

    /**
     * Processes the next task in the queue.
     * Removes from queue, simulates processing, updates status in history.
     */
    public void processNextTask() {
        // Check if queue is empty
        Task taskToProcess = taskQueue.poll(); // Retrieves and removes the head of this queue
        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        System.out.println("Processing " + taskToProcess + "...");

        // Simulate processing success or failure (20% chance of failure)
        boolean processingFailed = random.nextDouble() < 0.20; // 20% chance of failure

        // Find the task in the history list and update its status
        // Since we added the same object reference to history,
        // updating the polled object directly updates the one in history.
        if (processingFailed) {
            taskToProcess.setStatus(TaskStatus.FAILED);
            System.err.println(taskToProcess + " - Processing failed.");
        } else {
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            System.out.println(taskToProcess + " - Processing completed successfully.");
        }
        // No need to explicitly find in history if we update the polled object,
        // as the history list holds a reference to that same object.
    }

    /**
     * Displays all tasks currently in the processing queue.
     */
    public void viewQueue() {
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
            return;
        }
        System.out.println("Queue:");
        // Iterate over the queue without removing elements
        for (Task task : taskQueue) {
            System.out.println(task); // Use Task's toString()
        }
    }

    /**
     * Displays the history of all tasks ever submitted.
     */
    public void viewHistory() {
        if (taskHistory.isEmpty()) {
            System.out.println("History is empty.");
            return;
        }
        System.out.println("History:");
        // Iterate over the history list
        for (Task task : taskHistory) {
            System.out.println(task); // Use Task's toString()
        }
    }

    /**
     * Runs the main application loop, handling user input and commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Task Processing System started.");
        System.out.println("Enter command (submit <desc>, process, view queue, view history, exit):");

        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.print("> ");
                String input = scanner.nextLine().trim();

                if (input.isEmpty()) {
                    continue; // Skip empty input
                }

                String[] parts = input.split(" ", 2); // Split into command and rest
                String command = parts[0].toLowerCase(); // Case-insensitive command

                // Switch statement for command handling
                switch (command) {
                    case "submit":
                        if (parts.length > 1) {
                            submitTask(parts[1]);
                        } else {
                            System.err.println("Error: Submit command requires a description.");
                        }
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "view":
                        if (parts.length > 1) {
                            String viewType = parts[1].toLowerCase();
                            if (viewType.equals("queue")) {
                                viewQueue();
                            } else if (viewType.equals("history")) {
                                viewHistory();
                            } else {
                                System.err.println("Error: Unknown view type. Use 'view queue' or 'view history'.");
                            }
                        } else {
                             System.err.println("Error: View command requires specifying 'queue' or 'history'.");
                        }
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        System.err.println("Error: Unknown command. Please use submit <desc>, process, view queue, view history, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the run
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
