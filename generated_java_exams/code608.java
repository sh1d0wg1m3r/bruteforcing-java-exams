/*
 * Exam Question #608
 * Generated on: 2025-05-12 16:14:12
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Order Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for a restaurant's order management. The system should allow staff to add new customer orders to a queue for the kitchen, process the next order in the queue, and view the current orders waiting.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your program must meet the following technical requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold incoming customer orders, ensuring First-In, First-Out (FIFO) processing.
 *     *   Use a `java.util.ArrayList` to store the restaurant's menu items.
 *     *   Declare the variable holding the menu using the `java.util.List` interface type.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (for menu choices and order details).
 *     *   Present a menu of options to the user: Add Order, Process Next Order, View Order Queue, Exit.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user menu selections.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the main menu, prompts, successful actions, and the current order queue status.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically within the main program loop, to gracefully handle potential runtime errors (like incorrect input formats).
 *     *   Validate user input where necessary (e.g., menu item selections, main menu choices).
 *     *   Handle the case where a user tries to process an order when the queue is empty.
 * 6.  **Object-Oriented Design:**
 *     *   Create appropriate classes (`MenuItem`, `Order`, `RestaurantSystem`) to model the system components.
 *     *   Apply proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 * 7.  **Code Quality:**
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Functionality Details:**
 * 
 * *   **MenuItem:** A simple class representing a menu item with a name and price.
 * *   **Order:** Represents a customer order. It should contain a unique order ID (can be a simple counter) and a list of `MenuItem`s selected by the customer.
 * *   **RestaurantSystem:** The main class containing the `main` method. It should:
 *     *   Initialize a sample menu.
 *     *   Manage the `Queue` of `Order` objects.
 *     *   Implement the main application loop:
 *         *   Display the menu options.
 *         *   Read user input.
 *         *   Use a `switch` to perform actions:
 *             *   **Add Order:** Display the menu, allow the user to select multiple items (by number), create an `Order` object, and add it to the queue. Handle invalid item selections.
 *             *   **Process Next Order:** Remove the order at the front of the queue and simulate processing it. Print an error if the queue is empty.
 *             *   **View Order Queue:** Display the current orders in the queue, showing their ID and number of items. Indicate if the queue is empty.
 *             *   **Exit:** Terminate the program.
 * 
 * **Expected Output Structure:**
 * 
 * The program should present a loop of options, respond to user input, print relevant information to `System.out`, and print errors to `System.err`.
 * 
 * ```
 * --- Restaurant Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Order Queue
 * 4. Exit
 * Enter your choice: 
 * ```
 * (Example interaction for Add Order)
 * ```
 * --- Menu ---
 * 1. Item A ($10.00)
 * 2. Item B ($15.00)
 * Enter item number to add to order (0 to finish): 
 * ```
 * (Example interaction for Process Order)
 * ```
 * Processing Order #X with Y items...
 * ```
 * (Example interaction for View Queue)
 * ```
 * --- Current Order Queue ---
 * Order #X (Y items)
 * Order #Z (W items)
 * ...
 * Queue is empty.
 * ```
 * (Example error)
 * ```
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * ```
 * (Example processing empty queue error)
 * ```
 * Error: No orders in the queue to process.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `MenuItem`, `Order`, and `RestaurantSystem` classes in a single file or logically separated if using an IDE, ensuring it compiles and runs correctly.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles and best practices.
 * *   Correct implementation of the required functionality.
 * *   Robust error handling and input validation.
 * *   Code clarity, comments, and structure.
 *
 * EXPLANATION:
 * This solution implements a basic restaurant order processing system, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **Object-Oriented Design:**
 *     *   `MenuItem` class encapsulates the data for a menu item (name, price) with private fields and public getters.
 *     *   `Order` class encapsulates the data for a customer order (ID, list of items). It includes a static counter for unique IDs and a method to add items. It uses an `ArrayList` internally to store the items.
 *     *   `RestaurantSystem` is the main class that orchestrates the system. It holds the menu (`List<MenuItem>`) and the pending orders (`Queue<Order>`). It contains the main application logic, user interaction, and error handling.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   The `menu` is declared as `List<MenuItem>` and initialized as an `ArrayList`. This demonstrates using the interface type (`List`) for the variable, which is a best practice for flexibility. `ArrayList` is suitable here as we need indexed access to display the menu and retrieve items by number.
 *     *   The `orderQueue` is declared as `Queue<Order>` and initialized as a `LinkedList`. `LinkedList` is a common implementation for `Queue` in Java, providing efficient add/remove operations from the ends, which is ideal for a queue's FIFO behavior. `Queue.offer()` is used to add orders, and `Queue.poll()` is used to retrieve and remove the next order. `Queue.isEmpty()` checks if the queue is empty before processing.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is created to read input from `System.in`. It's used to read the user's main menu choice and the item numbers when adding an order.
 *     *   `scanner.nextInt()` is used for reading numbers, and `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls (though not strictly necessary here as we only use `nextInt()` and `next()`).
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The main application loop in the `run()` method uses a `switch` statement based on the user's integer choice from the main menu. Each `case` corresponds to a specific action (Add Order, Process Order, View Queue, Exit). The `default` case handles invalid numerical input.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard messages: displaying the menu, prompts, success messages, and the contents of the order queue.
 *     *   `System.err.println()` is used specifically for error messages, such as when the user enters an invalid menu choice, non-numeric input, or attempts to process an order when the queue is empty. This separates error output from normal program output, which is useful in larger applications or when redirecting output.
 * 
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the core logic within the `run()` method's `while` loop. This provides class-wide exception handling.
 *     *   Inside the main loop's `try` block, another `try-catch` block specifically handles `InputMismatchException` that can occur if the user enters non-integer input when `scanner.nextInt()` is expected. This block catches the error, prints an informative message to `System.err`, and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *     *   The outer `catch (Exception e)` block catches any other unexpected runtime exceptions that might occur during the program's execution, printing a generic error message and the stack trace to `System.err` for debugging.
 *     *   The `finally` block ensures the `Scanner` resource is closed when the `run()` method finishes (either normally or due to an exception), preventing resource leaks.
 *     *   Specific logic handles the empty queue case in `processNextOrder()` by checking if `orderQueue.poll()` returns `null`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `MenuItem` and `Order` are private, accessed via public methods.
 *     *   **Meaningful Names:** Variables (`orderQueue`, `menu`, `itemChoice`), methods (`addNewOrder`, `processNextOrder`), and classes are named descriptively.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes, constructors, and public methods. Inline comments explain specific code sections.
 *     *   **Input Validation:** Checks are made for valid item numbers (`itemChoice > 0 && itemChoice <= menu.size()`) and for valid main menu choices in the `switch` statement. `InputMismatchException` handling validates input type.
 *     *   **Clean Code:** The code is organized into separate methods for different functionalities (`displayMainMenu`, `addNewOrder`, etc.), improving readability and maintainability.
 * 
 * This solution effectively integrates all the required components to build a functional, albeit simple, order processing system, demonstrating key Java programming concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single menu item
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The price.
     */
    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("%s ($%.2f)", name, price);
    }
}

// Represents a customer order
class Order {
    private static int orderCounter = 0; // To generate unique order IDs
    private int orderId;
    private List<MenuItem> items;

    /**
     * Constructs a new Order.
     * Initializes with an empty list of items and assigns a unique ID.
     */
    public Order() {
        this.orderId = ++orderCounter;
        this.items = new ArrayList<>();
    }

    /**
     * Adds a MenuItem to the order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
        }
    }

    /**
     * Gets the unique ID of the order.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of MenuItems.
     */
    public List<MenuItem> getItems() {
        return items;
    }

    /**
     * Gets the number of items in the order.
     * @return The item count.
     */
    public int getItemCount() {
        return items.size();
    }

    @Override
    public String toString() {
        return "Order #" + orderId + " (" + items.size() + " items)";
    }
}

// Main class for the restaurant order processing system
public class RestaurantSystem {

    // Use List interface type, implemented by ArrayList
    private List<MenuItem> menu;
    // Use Queue interface type, implemented by LinkedList for FIFO behavior
    private Queue<Order> orderQueue;
    private Scanner scanner;

    /**
     * Constructs the RestaurantSystem.
     * Initializes the menu, order queue, and scanner.
     */
    public RestaurantSystem() {
        // Initialize menu using ArrayList
        menu = new ArrayList<>();
        initializeMenu();

        // Initialize order queue using LinkedList implementing Queue
        orderQueue = new LinkedList<>();

        scanner = new Scanner(System.in);
    }

    /**
     * Populates the menu with some sample items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Salad", 7.00));
        menu.add(new MenuItem("Fries", 3.50));
        menu.add(new MenuItem("Soda", 2.00));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order System ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Order Queue");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the restaurant menu with item numbers.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menu.size(); i++) {
            System.out.println((i + 1) + ". " + menu.get(i));
        }
        System.out.println("0. Finish Adding Items");
    }

    /**
     * Handles the process of adding a new order.
     * Prompts user to select items and adds the order to the queue.
     */
    private void addNewOrder() {
        Order newOrder = new Order();
        System.out.println("\n--- Adding New Order ---");
        displayMenu();

        int itemChoice = -1;
        while (itemChoice != 0) {
            System.out.print("Enter item number to add to order (0 to finish): ");
            try {
                itemChoice = scanner.nextInt();

                if (itemChoice > 0 && itemChoice <= menu.size()) {
                    MenuItem selectedItem = menu.get(itemChoice - 1);
                    newOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else if (itemChoice == 0) {
                    // Finish adding items
                    if (newOrder.getItemCount() == 0) {
                        System.out.println("No items added to the order. Order cancelled.");
                        return; // Cancel order if no items were added
                    }
                    System.out.println("Finishing order.");
                } else {
                    System.err.println("Error: Invalid item number. Please try again.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
            } catch (Exception e) {
                 System.err.println("An unexpected error occurred while adding items: " + e.getMessage());
                 // Decide if you want to break or continue based on severity
                 // For this case, let's continue the loop
            }
        }

        orderQueue.offer(newOrder); // Add the completed order to the queue
        System.out.println("Order #" + newOrder.getOrderId() + " added to the queue.");
    }

    /**
     * Handles processing the next order from the queue.
     */
    private void processNextOrder() {
        System.out.println("\n--- Processing Order ---");
        Order nextOrder = orderQueue.poll(); // Get and remove the head of the queue

        if (nextOrder != null) {
            System.out.println("Processing " + nextOrder + "...");
            // Simulate processing time or kitchen actions here
            System.out.println("Order #" + nextOrder.getOrderId() + " processed successfully.");
        } else {
            System.err.println("Error: No orders in the queue to process.");
        }
    }

    /**
     * Displays the current orders waiting in the queue.
     */
    private void viewOrderQueue() {
        System.out.println("\n--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterating over the queue does not remove elements
            for (Order order : orderQueue) {
                System.out.println(order);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling for the main loop
        try {
            while (choice != 4) {
                displayMainMenu();

                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    switch (choice) {
                        case 1:
                            addNewOrder();
                            break;
                        case 2:
                            processNextOrder();
                            break;
                        case 3:
                            viewOrderQueue();
                            break;
                        case 4:
                            System.out.println("Exiting Restaurant System. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    choice = -1; // Reset choice to stay in loop
                }
            }
        } catch (Exception e) {
             // Catch any other unexpected exceptions in the main loop
             System.err.println("An unexpected system error occurred: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
