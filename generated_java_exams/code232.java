/*
 * Exam Question #232
 * Generated on: 2025-05-11 22:36:19
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Task Management System Simulation**
 * 
 * You are tasked with developing a simple command-line application to manage tasks using queues and lists. The system should allow users to add new tasks, process the next task in line, and view the current lists of pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for a unique integer `id` and a `String description`. Include a constructor and public getter methods for these fields.
 * 2.  **Task Management Logic:** Create a class `TaskManager` responsible for managing the tasks.
 *     *   It must use a `java.util.Queue` (specifically, an `ArrayDeque`) to store tasks that are pending.
 *     *   It must use a `java.util.List` (specifically, an `ArrayList`) to store tasks that have been completed.
 *     *   Include methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the oldest task from the pending queue and adds it to the completed list. This method should indicate if a task was successfully processed or if the queue was empty.
 *         *   `getPendingTasks()`: Returns a `List` containing all tasks currently in the pending queue. *Hint: You may need to iterate through the queue to create this list.*
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 *         *   A helper method to check if the pending queue is empty.
 * 3.  **User Interface:** Create a main application class (`TaskApp`) with a `main` method that provides a command-line interface.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Implement a menu with the following options:
 *         1.  Add Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, attempting to process an empty queue, invalid task description).
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Handle `InputMismatchException`.
 *     *   Handle the case where the user tries to process a task when the pending queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method or the primary application loop to catch potential unexpected runtime errors.
 *     *   Handle empty task descriptions when adding a task.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Structure the code cleanly across the classes.
 * 
 * **Expected Output:**
 * 
 * The program should loop, presenting the menu. User input should trigger the corresponding actions. Output should clearly indicate successful operations (`System.out`) or errors (`System.err`). Task lists should display the task ID and description. When exiting, the program should terminate gracefully.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Simple Task Management System ---
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Added task: Task #1: Buy groceries
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task #1: Buy groceries
 * ---------------------
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task #1: Buy groceries
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * No pending tasks.
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task #1: Buy groceries
 * -----------------------
 * 
 * Choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Choose an option:
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * Scanner closed. System shutting down.
 * ```
 * 
 * Your solution should be a single Java program contained in one or more `.java` files (can be presented as one block of code for the exam).
 *
 * EXPLANATION:
 * The provided solution implements a simple task management system as required, demonstrating the use of various Java concepts.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task with an `id` and `description`. It follows encapsulation by making fields private and providing public getters. The `toString()` method is overridden for easy printing.
 * 
 * 2.  **TaskManager Class:** This class encapsulates the core logic for managing tasks.
 *     *   `pendingTasks`: A `Queue<Task>` (implemented using `ArrayDeque`) is used. The `Queue` interface is suitable here because tasks are processed in a First-In, First-Out (FIFO) manner. `ArrayDeque` is a good choice as it's efficient for adding to the tail (`offer`) and removing from the head (`poll`).
 *     *   `completedTasks`: A `List<Task>` (implemented using `ArrayList`) is used. The `List` interface provides ordered storage, which is appropriate for keeping track of completed tasks in the order they were finished. `ArrayList` is a common and efficient implementation for general-purpose lists.
 *     *   `nextTaskId`: A counter ensures each task gets a unique ID.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: Uses `poll()` to safely remove the next task from the `pendingTasks` queue. `poll()` returns `null` if the queue is empty, allowing the method to gracefully handle this case without throwing an exception. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `getPendingTasks()`: This method demonstrates converting the contents of the `Queue` into a `List` by creating a new `ArrayList` populated with the elements from the `pendingTasks` queue. This fulfills the requirement to use both `Queue` and `List` interface/implementation and also protects the internal queue from external modification.
 *     *   `getCompletedTasks()`: Returns the internal `completedTasks` list reference.
 *     *   `isEmptyPending()`: A simple helper method to check the state of the pending queue.
 * 
 * 3.  **TaskApp Class:** This is the main application class.
 *     *   `main(String[] args)`: The entry point of the program. It initializes the `TaskManager` and `Scanner`. A large `try-catch(Exception e)` block is wrapped around the `runMenu()` call. This serves as the "class-wide exception handling," catching any unexpected exceptions that might escape from the main execution flow. A `finally` block ensures the `Scanner` resource is closed.
 *     *   `runMenu()`: Contains the main application loop.
 *         *   It displays the menu using `System.out`.
 *         *   A nested `try-catch(InputMismatchException e)` block specifically handles errors during integer input for the menu choice. If non-integer input is detected, an error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop.
 *         *   `scanner.nextInt()` reads the integer choice, and a subsequent `scanner.nextLine()` is crucial to consume the newline character left behind, so that the next `scanner.nextLine()` call (e.g., when reading the task description) works correctly.
 *         *   A `switch` statement is used to direct the program flow based on the user's valid integer choice.
 *         *   Each case calls the appropriate `TaskManager` method or handles viewing the lists.
 *         *   Cases 3 and 4 retrieve the task lists (`List<Task>`) and iterate through them, printing task details to `System.out`. They check if the lists are empty and print appropriate messages.
 *         *   Case 2 explicitly checks the boolean return value of `processNextTask()` to determine if an error message (`System.err`) about an empty queue is needed.
 *         *   Case 1 includes input validation for the task description, printing an error to `System.err` if it's empty.
 *         *   The `default` case of the `switch` handles integer inputs that are outside the valid menu range, printing an error to `System.err`.
 *         *   The loop continues until the user enters '5'.
 * 
 * 4.  **Error Handling and System.err/System.out:** `System.err` is used specifically for reporting errors (invalid input, empty queue, empty description), separating them from normal output (`System.out`) like the menu, task lists, and success messages. The `try-catch` blocks demonstrate handling both specific input errors (`InputMismatchException`) and providing a general catch-all for other potential runtime issues.
 * 
 * 5.  **Best Practices:** The code adheres to best practices through private fields, public methods, clear variable/method names, comments explaining functionality, and a logical separation of concerns into different classes. Input validation and specific error condition checks (like empty queues) are implemented.
 * 
 * This solution effectively integrates all required Java components and demonstrates robust handling of user interaction, data structures, and potential errors in a practical scenario.
 */

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task #" + id + ": " + description;
    }
}

// Manages a collection of tasks using a Queue for pending and a List for completed.
class TaskManager {
    private Queue<Task> pendingTasks; // Using ArrayDeque which implements Queue
    private List<Task> completedTasks; // Using ArrayList which implements List
    private int nextTaskId;

    /**
     * Constructs a new TaskManager, initializing task collections and ID counter.
     */
    public TaskManager() {
        this.pendingTasks = new ArrayDeque<>(); // Initialize Queue
        this.completedTasks = new ArrayList<>(); // Initialize List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue with a unique ID.
     * Performs basic validation on description.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // This case is also handled in TaskApp, but good practice to validate here too.
            System.err.println("Error in TaskManager: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer() is the preferred way to add to a Queue
        System.out.println("Added task: " + newTask);
    }

    /**
     * Processes the next task from the pending queue, moving it to the completed list.
     * @return true if a task was processed, false if the pending queue was empty.
     */
    public boolean processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll() retrieves and removes the head, returns null if empty
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
            return true;
        } else {
            return false; // No tasks were available in the queue
        }
    }

    /**
     * Returns a list containing all tasks currently in the pending queue.
     * Creates a new list to avoid exposing the internal queue structure for modification.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Iterate through the Queue and add elements to a new ArrayList
        // This demonstrates converting Queue contents to a List view.
        return new ArrayList<>(pendingTasks); // A convenient way to copy Queue contents to a List
    }

    /**
     * Returns the list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Returns the reference to the internal completed list
    }

    /**
     * Checks if there are any pending tasks.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isEmptyPending() {
        return pendingTasks.isEmpty();
    }
}

// Main application class for the Task Management System
public class TaskApp {

    // Using static for simplicity in a single-file exam context
    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Simple Task Management System ---");

        // Class-wide exception handling using a try-catch block around the main execution logic
        try {
            runMenu(); // Delegate menu logic to a separate method
        } catch (Exception e) {
            // Catch any unexpected exceptions that might propagate up
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging in case of unexpected errors
        } finally {
            // Ensure resources like Scanner are closed properly
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed. System shutting down.");
            }
        }
    }

    /**
     * Runs the main menu loop for the task management system.
     * Handles user input and delegates actions to TaskManager.
     */
    private static void runMenu() {
        int choice = -1; // Initialize choice outside the loop

        // Loop until the user chooses to exit (option 5)
        while (choice != 5) {
            printMenu(); // Display menu options
            try {
                System.out.print("Enter your choice: ");
                // Read the integer input for the menu choice
                choice = scanner.nextInt();
                // Consume the leftover newline character after reading the integer
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        // Input validation for task description
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            taskManager.addTask(description);
                        }
                        break;

                    case 2: // Process Next Task
                        // Check if there are pending tasks before attempting to process
                        if (taskManager.processNextTask()) {
                            // Success message is printed inside TaskManager method
                        } else {
                            // Error message if no tasks are pending
                            System.err.println("No pending tasks to process.");
                        }
                        break;

                    case 3: // View Pending Tasks
                        List<Task> pending = taskManager.getPendingTasks(); // Get pending tasks as a List
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            System.out.println("--- Pending Tasks ---");
                            // Iterate and print each pending task using System.out
                            for (Task task : pending) {
                                System.out.println(task); // Task's toString() is used implicitly
                            }
                            System.out.println("---------------------");
                        }
                        break;

                    case 4: // View Completed Tasks
                        List<Task> completed = taskManager.getCompletedTasks(); // Get completed tasks as a List
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            System.out.println("--- Completed Tasks ---");
                            // Iterate and print each completed task using System.out
                            for (Task task : completed) {
                                System.out.println(task); // Task's toString() is used implicitly
                            }
                            System.out.println("-----------------------");
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System.");
                        // Loop condition will handle termination
                        break;

                    default: // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the input is not an integer
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the incorrect input to prevent an infinite loop
                choice = -1; // Reset choice to ensure loop continues and re-prompts
            }
            // Note: More specific exceptions from TaskManager methods (if any were explicitly thrown)
            // would ideally be caught here or allowed to propagate to the main try-catch.
            // In this design, TaskManager methods handle their specific internal errors (like empty queue).
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\nChoose an option:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
