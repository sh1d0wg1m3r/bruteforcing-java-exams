/*
 * Exam Question #307
 * Generated on: 2025-05-11 22:52:54
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Warehouse Task Management System**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for warehouse workers. The system should allow adding new tasks, processing the next task in sequence, viewing pending tasks, and viewing completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures and control flow mechanisms by adhering to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage tasks that are waiting to be processed. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` (implementing `java.util.List`) to store a history of tasks that have been completed.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the standard input.
 *     *   Support the following commands:
 *         *   `add <task description>`: Adds a new task with the given description to the end of the pending task queue.
 *         *   `process`: Removes and processes the next task from the front of the pending task queue.
 *         *   `view_pending`: Displays all tasks currently in the pending queue without removing them.
 *         *   `view_completed`: Displays all tasks that have been processed.
 *         *   `exit`: Terminates the application.
 * 
 * 3.  **Control Flow & Output:**
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Use `System.out` for all normal output (prompts, task lists, success messages).
 *     *   Use `System.err` for all error messages (e.g., attempting to process a task when the queue is empty, invalid commands).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues during command processing. Specifically, handle the case where the user tries to `process` a task when the queue is empty.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulate the task management logic within a class (`WarehouseTaskSystem`).
 *     *   Declare data structure fields as private.
 *     *   Provide public methods for the supported operations (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain key parts of the code.
 *     *   Perform basic input validation (e.g., check if the task description is empty for the `add` command).
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output Format:**
 * 
 * *   Prompt: `Enter command (add, process, view_pending, view_completed, exit): `
 * *   Add success: `Task added: [task description]`
 * *   Process success: `Processed task: [task description]`
 * *   Process empty error: `Error: No tasks in the queue to process.` (to System.err)
 * *   View Pending (if not empty):
 *     ```
 *     Pending Tasks (Queue):
 *     1. [task description 1]
 *     2. [task description 2]
 *     ...
 *     ```
 * *   View Pending (if empty): `Pending tasks queue is empty.`
 * *   View Completed (if not empty):
 *     ```
 *     Completed Tasks:
 *     1. [task description 1]
 *     2. [task description 2]
 *     ...
 *     ```
 * *   View Completed (if empty): `No completed tasks yet.`
 * *   Invalid command error: `Error: Unknown command. Available commands: add, process, view_pending, view_completed, exit` (to System.err)
 * *   Add with empty description error: `Error: Task description cannot be empty.` (to System.err)
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command (add, process, view_pending, view_completed, exit): add Pick Item A
 * Task added: Pick Item A
 * Enter command (add, process, view_pending, view_completed, exit): add Pack Order #123
 * Task added: Pack Order #123
 * Enter command (add, process, view_pending, view_completed, exit): view_pending
 * Pending Tasks (Queue):
 * 1. Pick Item A
 * 2. Pack Order #123
 * Enter command (add, process, view_pending, view_completed, exit): process
 * Processed task: Pick Item A
 * Enter command (add, process, view_pending, view_completed, exit): view_pending
 * Pending Tasks (Queue):
 * 1. Pack Order #123
 * Enter command (add, process, view_pending, view_completed, exit): view_completed
 * Completed Tasks:
 * 1. Pick Item A
 * Enter command (add, process, view_pending, view_completed, exit): process
 * Processed task: Pack Order #123
 * Enter command (add, process, view_pending, view_completed, exit): process
 * Error: No tasks in the queue to process.
 * Enter command (add, process, view_pending, view_completed, exit): view_pending
 * Pending tasks queue is empty.
 * Enter command (add, process, view_pending, view_completed, exit): view_completed
 * Completed Tasks:
 * 1. Pick Item A
 * 2. Pack Order #123
 * Enter command (add, process, view_pending, view_completed, exit): exit
 * Exiting Warehouse Task System.
 * ```
 * 
 * Implement the `WarehouseTaskSystem` class and the main application logic to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements a `WarehouseTaskSystem` class that manages pending and completed tasks based on user input.
 * 
 * 1.  **Class Structure and Encapsulation:** The `WarehouseTaskSystem` class encapsulates the data (`taskQueue`, `completedTasks`) and the operations (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) related to task management. The data fields are declared as `private`, enforcing encapsulation, and access is provided through `public` methods.
 * 
 * 2.  **Data Structures:**
 *     *   `private Queue<String> taskQueue;`: A `Queue` (implemented using `LinkedList`) is used to store pending tasks. The `Queue` interface ensures that tasks are added to the rear (`offer`) and removed from the front (`poll`), adhering to the FIFO principle required for processing tasks in order.
 *     *   `private List<String> completedTasks;`: A `List` (implemented using `ArrayList`) is used to store tasks after they have been processed. `ArrayList` is suitable here as it provides dynamic resizing and allows easy addition of elements to the end, maintaining the history.
 * 
 * 3.  **User Input (`Scanner`):** The `main` method initializes a `Scanner` to read input lines from the console (`System.in`). The `scanner.nextLine()` method reads the entire line of input, which is then parsed to extract the command and any arguments.
 * 
 * 4.  **Control Flow (`switch`):** A `while` loop keeps the system running until the `exit` command is given. Inside the loop, the user's input line is read, split into command and arguments, and a `switch` statement is used to direct execution to the appropriate logic based on the command string (`add`, `process`, `view_pending`, `view_completed`, `exit`, or `default` for unknown commands).
 * 
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for normal output such as prompts, confirmation messages (task added, task processed), and listing the contents of the queues/lists.
 *     *   `System.err.println()` is used specifically for error messages, such as when trying to process an empty queue or when an invalid command is entered. This separates error output from standard information.
 * 
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the core command processing logic within the `while` loop in `main`. This demonstrates class-wide exception handling as required. While specific error conditions like an empty queue are handled explicitly *within* the `processNextTask` method (by checking if `poll()` returns `null`), the `try-catch` in `main` provides a safety net for any other unexpected runtime exceptions that might occur during command parsing or execution.
 *     *   Inside `processNextTask`, the check `nextTask == null` after calling `taskQueue.poll()` is a specific way to handle the "empty queue" condition gracefully, printing an error to `System.err` instead of throwing an exception.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used as described in point 1.
 *     *   **Meaningful Names:** Variables (`taskQueue`, `completedTasks`, `inputLine`, `command`, `nextTask`) and methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) have names that clearly indicate their purpose.
 *     *   **Comments:** Basic Javadoc-style comments are included for the class and methods, and inline comments explain key logic points.
 *     *   **Input Validation:** The `addTask` method checks if the provided `taskDescription` is null or empty after trimming whitespace, preventing invalid tasks from being added. The `main` method checks if the `add` command was provided with an argument.
 *     *   **Resource Management:** The `scanner.close()` call after the main loop ensures that the `Scanner` resource is released, which is important for preventing resource leaks.
 * 
 * This solution effectively integrates the required Java components and demonstrates fundamental programming concepts and best practices in a practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // Useful for viewing Queue elements

/**
 * Manages warehouse tasks using a queue for pending tasks and a list for completed tasks.
 */
public class WarehouseTaskSystem {

    // Private fields for encapsulation
    private Queue<String> taskQueue;
    private List<String> completedTasks;

    /**
     * Constructs a new WarehouseTaskSystem.
     * Initializes the pending task queue and completed tasks list.
     */
    public WarehouseTaskSystem() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation for history
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending task queue.
     * @param taskDescription The description of the task to add.
     */
    public void addTask(String taskDescription) {
        if (taskDescription == null || taskDescription.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return;
        }
        taskQueue.offer(taskDescription.trim()); // offer is preferred over add in queues
        System.out.println("Task added: " + taskDescription.trim());
    }

    /**
     * Processes the next task from the pending task queue.
     * Removes the task from the queue and adds it to the completed tasks list.
     */
    public void processNextTask() {
        String nextTask = taskQueue.poll(); // poll retrieves and removes the head, returns null if queue is empty
        if (nextTask == null) {
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask);
        }
    }

    /**
     * Displays all tasks currently in the pending task queue.
     */
    public void viewPendingTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("Pending tasks queue is empty.");
            return;
        }
        System.out.println("Pending Tasks (Queue):");
        // Iterate through the queue without removing elements
        Iterator<String> iterator = taskQueue.iterator();
        int index = 1;
        while (iterator.hasNext()) {
            System.out.println(index++ + ". " + iterator.next());
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks yet.");
            return;
        }
        System.out.println("Completed Tasks:");
        for (int i = 0; i < completedTasks.size(); i++) {
            System.out.println((i + 1) + ". " + completedTasks.get(i));
        }
    }

    /**
     * Main method to run the Warehouse Task System application.
     * Handles user input and dispatches commands.
     */
    public static void main(String[] args) {
        WarehouseTaskSystem system = new WarehouseTaskSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Warehouse Task Management System ---");

        while (running) {
            System.out.print("Enter command (add, process, view_pending, view_completed, exit): ");
            String inputLine = scanner.nextLine().trim();

            // Use a try-catch block for general exception handling around command processing
            try {
                // Split command and arguments
                String[] parts = inputLine.split(" ", 2); // Split into command and potential argument string
                String command = parts[0].toLowerCase(); // Get the command part

                switch (command) {
                    case "add":
                        if (parts.length > 1) {
                            system.addTask(parts[1]); // Pass the rest as task description
                        } else {
                            System.err.println("Error: 'add' command requires a task description.");
                        }
                        break;
                    case "process":
                        system.processNextTask();
                        break;
                    case "view_pending":
                        system.viewPendingTasks();
                        break;
                    case "view_completed":
                        system.viewCompletedTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting Warehouse Task System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Unknown command. Available commands: add, process, view_pending, view_completed, exit");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: for debugging, but maybe not in exam output
            }
        }

        // Ensure the scanner resource is closed
        scanner.close();
        System.out.println("System shutdown complete.");
    }
}
