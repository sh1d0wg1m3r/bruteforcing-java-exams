/*
 * Exam Question #1060
 * Generated on: 2025-05-12 17:19:30
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Document Processing Queue Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simulation of a simple document processing system. Documents arrive and are placed in a queue waiting to be processed. A "processor" component can take the next document from the queue and mark it as completed, moving it to a list of processed documents. The system should provide a command-line interface for users to interact with it.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement a `Document` class:**
 *     *   It should have private fields: `id` (int), `name` (String), and `status` (String, e.g., "Pending", "Processed").
 *     *   Provide a constructor to initialize `id`, `name`, and set the initial status to "Pending".
 *     *   Include public getter methods for all fields.
 *     *   Include a public method `setStatus(String status)` to change the document's status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the document (e.g., "ID: [id], Name: [name], Status: [status]").
 * 
 * 2.  **Implement a `DocumentProcessorSystem` class:**
 *     *   It should manage the collection of documents.
 *     *   Use a `java.util.Queue<Document>` to store documents waiting to be processed.
 *     *   Use a `java.util.List<Document>` (specifically, an instance of `java.util.ArrayList`) to store documents that have been processed.
 *     *   Maintain a private counter for assigning unique document IDs, starting from 1.
 *     *   Provide a public method `addDocument(String name)` that creates a new `Document` with the next available ID and the given name, and adds it to the pending queue. Perform input validation to ensure the document name is not empty.
 *     *   Provide a public method `processNextDocument()` that retrieves the next document from the pending queue (if available), changes its status to "Processed", and moves it to the processed list. If the queue is empty, it should indicate that no documents are pending.
 *     *   Provide a public method `viewPendingDocuments()` that prints the details of all documents currently in the pending queue.
 *     *   Provide a public method `viewProcessedDocuments()` that prints the details of all documents in the processed list.
 * 
 * 3.  **Implement a main application class (e.g., `DocumentProcessorApp`) with a `main` method:**
 *     *   This class will contain the command-line interface logic.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu with the following options:
 *         1.  Add Document
 *         2.  Process Next Document
 *         3.  View Pending Documents
 *         4.  View Processed Documents
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Use `System.out` for the menu, prompts, and displaying document lists or success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty document name, attempting to process an empty queue).
 *     *   Implement robust error handling using `try-catch` blocks. This should include catching potential `InputMismatchException` when reading integer input and a general `Exception` catch to handle unexpected errors within the main loop or critical operations, printing an informative message using `System.err`.
 *     *   The program should loop until the user chooses to exit.
 * 
 * 4.  **Adhere to Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should provide interactive output. Examples include:
 * 
 * ```
 * --- Document Processor Menu ---
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter your choice: 1
 * Enter document name: Report_Q3
 * Document 'Report_Q3' added with ID 1.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 1
 * Enter document name: Presentation_Final
 * Document 'Presentation_Final' added with ID 2.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Documents ---
 * ID: 1, Name: Report_Q3, Status: Pending
 * ID: 2, Name: Presentation_Final, Status: Pending
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing document ID 1: Report_Q3
 * Document ID 1 processed.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Documents ---
 * ID: 2, Name: Presentation_Final, Status: Pending
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Documents ---
 * ID: 1, Name: Report_Q3, Status: Processed
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing document ID 2: Presentation_Final
 * Document ID 2 processed.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 2
 * Error: No documents are pending processing.
 * 
 * --- Document Processor Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution must compile and run, demonstrating the correct usage of all specified Java components and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple document processing system simulation, fulfilling all the requirements of the exam task.
 * 
 * 1.  **`Document` Class:**
 *     *   Represents a single document with an ID, name, and status.
 *     *   Private fields (`id`, `name`, `status`) ensure encapsulation.
 *     *   Public getters provide controlled access to the document's state.
 *     *   A `setStatus` method allows changing the status.
 *     *   `toString()` provides a convenient way to display document information.
 *     *   Static final strings are used for status values for clarity and maintainability.
 * 
 * 2.  **`DocumentProcessorSystem` Class:**
 *     *   This class acts as the core manager of the system.
 *     *   `private Queue<Document> pendingDocuments;`: A `Queue` (implemented by `LinkedList`) is used to store documents awaiting processing. The `Queue` interface provides methods like `offer()` (add) and `poll()` (retrieve and remove from the head), which are ideal for managing items in a First-In, First-Out (FIFO) order, simulating a processing queue.
 *     *   `private List<Document> processedDocuments;`: A `List` (implemented by `ArrayList`) is used to store documents once they have been processed. `ArrayList` is suitable here for storing a dynamic collection of processed items, allowing easy iteration.
 *     *   `private int nextDocumentId;`: Keeps track of the next unique ID to assign to new documents.
 *     *   `addDocument(String name)`: Creates a new `Document` object and adds it to the `pendingDocuments` queue using `offer()`. It includes basic input validation for the document name and throws an `IllegalArgumentException` if the name is invalid.
 *     *   `processNextDocument()`: Uses `poll()` to retrieve and remove the document at the front of the `pendingDocuments` queue. If `poll()` returns `null` (meaning the queue is empty), an error message is printed to `System.err`. Otherwise, the document's status is updated, and it's added to the `processedDocuments` list using `add()`.
 *     *   `viewPendingDocuments()` and `viewProcessedDocuments()`: These methods iterate through the respective collections and print the `toString()` representation of each document to `System.out`.
 * 
 * 3.  **`DocumentProcessorApp` Class (`main` method):**
 *     *   This class provides the command-line interface.
 *     *   `Scanner scanner = new Scanner(System.in);`: Used to read input from the console.
 *     *   `DocumentProcessorSystem system = new DocumentProcessorSystem();`: An instance of the system manager is created.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   `printMenu()`: A helper method to display the options using `System.out`.
 *     *   `switch (choice)`: This statement is used to direct the program flow based on the user's integer input, executing the corresponding system operation.
 *     *   `System.out`: Used for displaying the menu, prompts, success messages, and document lists.
 *     *   `System.err`: Used for displaying error messages, such as invalid menu choices, empty document names caught by `IllegalArgumentException`, attempts to process an empty queue, or invalid input types caught by `InputMismatchException`.
 *     *   **Exception Handling (`try-catch`):**
 *         *   An outer `try-catch(Exception mainException)` block wraps the main `while` loop. This provides a high-level safety net to catch any unexpected exceptions that might occur during the program's execution and print a critical error message to `System.err`.
 *         *   An inner `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer input when an integer is expected for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A general `catch(Exception e)` inside the loop handles other potential runtime exceptions that might occur during the execution of the `switch` cases, printing a general error message to `System.err`.
 *         *   The `addDocument` call is wrapped in a `try-catch(IllegalArgumentException e)` to specifically handle and report the error if the user provides an empty document name.
 *         *   A `finally` block ensures the `Scanner` is closed when the main loop terminates (either by exiting or due to a critical error).
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList` (as a `List`), `Scanner`, `Switch`, `System.out`, `System.err`, and `try-catch` for robust error handling within a practical, object-oriented structure adhering to best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a document in the processing system.
 */
class Document {
    private int id;
    private String name;
    private String status;

    private static final String STATUS_PENDING = "Pending";
    private static final String STATUS_PROCESSED = "Processed";

    /**
     * Constructs a new Document.
     * @param id The unique identifier for the document.
     * @param name The name or title of the document.
     */
    public Document(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = STATUS_PENDING; // Documents are pending upon creation
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the document.
     * @param status The new status (e.g., "Pending", "Processed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the document.
     * @return A formatted string showing document details.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Status: " + status;
    }
}

/**
 * Manages the queue of pending documents and the list of processed documents.
 */
class DocumentProcessorSystem {
    // Queue for documents waiting to be processed (FIFO)
    private Queue<Document> pendingDocuments;
    // List for documents that have been processed
    private List<Document> processedDocuments;
    // Counter for assigning unique document IDs
    private int nextDocumentId;

    /**
     * Constructs a new DocumentProcessorSystem.
     * Initializes the pending queue and processed list.
     */
    public DocumentProcessorSystem() {
        // LinkedList implements both Queue and List, suitable for a queue implementation
        this.pendingDocuments = new LinkedList<>();
        // ArrayList is a common List implementation for storing processed items
        this.processedDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start IDs from 1
    }

    /**
     * Adds a new document to the pending queue.
     * @param name The name of the document.
     * @throws IllegalArgumentException if the document name is null or empty.
     */
    public void addDocument(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Document name cannot be empty.");
        }
        Document newDocument = new Document(nextDocumentId++, name.trim());
        pendingDocuments.offer(newDocument); // offer is generally preferred over add for queues
        System.out.println("Document '" + newDocument.getName() + "' added with ID " + newDocument.getId() + ".");
    }

    /**
     * Processes the next document from the pending queue.
     * If a document is processed, it's moved to the processed list.
     * @return true if a document was processed, false if the queue was empty.
     */
    public boolean processNextDocument() {
        Document docToProcess = pendingDocuments.poll(); // poll retrieves and removes the head
        if (docToProcess != null) {
            System.out.println("Processing document ID " + docToProcess.getId() + ": " + docToProcess.getName());
            docToProcess.setStatus("Processed"); // Update status
            processedDocuments.add(docToProcess); // Add to processed list
            System.out.println("Document ID " + docToProcess.getId() + " processed.");
            return true;
        } else {
            System.err.println("Error: No documents are pending processing.");
            return false;
        }
    }

    /**
     * Displays all documents currently in the pending queue.
     */
    public void viewPendingDocuments() {
        System.out.println("--- Pending Documents ---");
        if (pendingDocuments.isEmpty()) {
            System.out.println("No documents pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Document doc : pendingDocuments) {
                System.out.println(doc);
            }
        }
    }

    /**
     * Displays all documents currently in the processed list.
     */
    public void viewProcessedDocuments() {
        System.out.println("--- Processed Documents ---");
        if (processedDocuments.isEmpty()) {
            System.out.println("No documents processed yet.");
        } else {
            // Iterate through the list
            for (Document doc : processedDocuments) {
                System.out.println(doc);
            }
        }
    }
}

/**
 * Main application class for the Document Processing System.
 * Provides the command-line interface.
 */
public class DocumentProcessorApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DocumentProcessorSystem system = new DocumentProcessorSystem();
        boolean running = true;

        // Outer try-catch for general exception handling covering the main loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                // Inner try-catch for handling input specific exceptions
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1: // Add Document
                            System.out.print("Enter document name: ");
                            String docName = scanner.nextLine();
                            try {
                                system.addDocument(docName);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 2: // Process Next Document
                            system.processNextDocument();
                            break;
                        case 3: // View Pending Documents
                            system.viewPendingDocuments();
                            break;
                        case 4: // View Processed Documents
                            system.viewProcessedDocuments();
                            break;
                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting system.");
                            break;
                        default: // Invalid choice
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during menu processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Optional: print stack trace for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception mainException) {
            // This catches any exceptions that propagate out of the inner try-catch or loop
            System.err.println("A critical error stopped the application: " + mainException.getMessage());
            mainException.printStackTrace();
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Document Processor Menu ---");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Pending Documents");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Exit");
    }
}
