/*
 * Exam Question #459
 * Generated on: 2025-05-11 23:14:16
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Customer Service Ticket Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based customer service ticket management system. The system should allow users to add new tickets, process the oldest pending ticket, view all pending tickets, and view all processed tickets.
 * 
 * Your solution must effectively utilize various Java collection types and control flow mechanisms, demonstrating a solid understanding of core Java concepts and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage pending customer service tickets (FIFO - First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store tickets that have been processed.
 *     *   Declare the variable holding processed tickets using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Ticket
 *         2.  Process Next Ticket
 *         3.  View Pending Tickets
 *         4.  View Processed Tickets
 *         5.  Exit
 *     *   Prompt the user for input based on the selected option (e.g., ticket description).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Implement a loop to keep the system running until the user chooses to exit.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and lists of tickets.
 *     *   Use `System.err` to display error messages (e.g., invalid menu option, processing an empty queue, empty ticket description).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during the main execution loop or specific operations.
 * 
 * 5.  **Ticket Representation:**
 *     *   Create a `Ticket` class with appropriate fields (e.g., unique ID, description, status - PENDING/PROCESSED).
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Include a method to easily display ticket information (e.g., `toString()`).
 * 
 * 6.  **Best Practices:**
 *     *   Employ meaningful variable and method names.
 *     *   Add comments to explain complex logic or class purpose.
 *     *   Include basic input validation (e.g., check if ticket description is empty).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it should display the menu. Based on user input, it should perform the requested action and provide feedback (success message, error message, or list of tickets).
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My internet is slow.
 * Ticket #1 added to the queue.
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 1
 * Enter ticket description: Cannot login to my account.
 * Ticket #2 added to the queue.
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket #1 [PENDING]: My internet is slow.
 * Ticket #2 [PENDING]: Cannot login to my account.
 * -----------------------
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 2
 * Processing ticket #1...
 * Ticket #1 [PROCESSED]: My internet is slow. processed.
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket #2 [PENDING]: Cannot login to my account.
 * -----------------------
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 4
 * --- Processed Tickets ---
 * Ticket #1 [PROCESSED]: My internet is slow.
 * -------------------------
 * 
 * Customer Service Ticket System Menu:
 * 1. Add New Ticket
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing the `Ticket` class and the main class (e.g., `CustomerServiceSystem`) with the `main` method.
 * 
 * **Submission:** Provide the complete Java code for the solution.
 *
 * EXPLANATION:
 * This solution implements a basic customer service ticket system demonstrating the required Java concepts.
 * 
 * 1.  **`Ticket` Class:** A simple POJO (`Plain Old Java Object`) representing a ticket. It has private fields (`ticketId`, `description`, `status`) enforcing encapsulation. Getters provide read access. The `setStatus` method allows changing the status. The `toString()` method provides a convenient way to print ticket details. An `enum TicketStatus` improves code readability and prevents invalid status values.
 * 
 * 2.  **`CustomerServiceSystem` Class:** This is the main class containing the system logic.
 *     *   **Data Structures:**
 *         *   `pendingTicketsQueue`: Declared and instantiated as a `Queue<Ticket>` using `LinkedList`. `LinkedList` is a common implementation of `Queue` in `java.util` and provides the necessary FIFO behavior.
 *         *   `processedTicketsList`: Declared as `List<Ticket>` but instantiated as `new ArrayList<>()`. This fulfills the requirement to use `ArrayList` and also demonstrates the good practice of programming to an interface (`List`) rather than a specific implementation (`ArrayList`).
 *     *   **State:** `nextTicketId` is a simple counter to generate unique ticket IDs.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read user input. It's declared as a class member and initialized in the constructor.
 *     *   **`displayMenu()`:** A helper method to print the menu options.
 *     *   **`addNewTicket()`:**
 *         *   Prompts the user for a description.
 *         *   Includes basic input validation to check if the description is empty using `trim()` and `isEmpty()`. An error message is printed to `System.err` if invalid.
 *         *   Creates a new `Ticket` object with the next available ID and `PENDING` status.
 *         *   Uses `pendingTicketsQueue.offer()` to add the new ticket to the end of the queue. `offer()` is generally preferred over `add()` for queues as it handles capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained).
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextTicket()`:**
 *         *   Checks if the `pendingTicketsQueue` is empty using `isEmpty()`. If so, prints an error to `System.err`.
 *         *   Uses `pendingTicketsQueue.poll()` to retrieve and remove the ticket at the head of the queue (the oldest one).
 *         *   If a ticket is successfully retrieved (`poll()` returns non-null), its status is changed to `PROCESSED`, and it's added to the `processedTicketsList`.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewPendingTickets()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the queue is empty.
 *         *   If not empty, it iterates through the `pendingTicketsQueue` using a for-each loop. This iterates over the elements without removing them, which is the desired behavior for viewing. Each ticket's `toString()` is implicitly called when printed.
 *         *   Prints a footer to `System.out`.
 *     *   **`viewProcessedTickets()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the list is empty.
 *         *   If not empty, it iterates through the `processedTicketsList` using a for-each loop and prints each ticket.
 *         *   Prints a footer to `System.out`.
 *     *   **`runSystem()`:**
 *         *   This method contains the main application loop.
 *         *   It uses a `boolean running` flag to control the loop.
 *         *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates handling unexpected exceptions that might occur during the program's execution. The caught exception's stack trace is printed to `System.err`.
 *         *   **`finally` block:** A `finally` block ensures that the `scanner` is closed when the `try` block is exited, whether normally or due to an exception. This prevents resource leaks.
 *         *   Inside the loop:
 *             *   The menu is displayed.
 *             *   User input for the choice is read using `scanner.nextInt()`.
 *             *   A nested `try-catch(InputMismatchException e)` is used specifically to handle cases where the user enters non-integer input for the menu choice. An error is printed to `System.err`, the invalid input is consumed (`scanner.next()`), and `continue` skips to the next iteration.
 *             *   A `switch` statement handles the valid integer choices (1-5), calling the appropriate methods.
 *             *   A `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *             *   Choice 5 sets `running` to `false`, exiting the loop.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `CustomerServiceSystem` and calls the `runSystem()` method to start the application.
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, following best practices like encapsulation, meaningful names, and basic error handling.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for ticket status
enum TicketStatus {
    PENDING,
    PROCESSED
}

// Class representing a customer service ticket
class Ticket {
    private int ticketId;
    private String description;
    private TicketStatus status;

    /**
     * Constructs a new Ticket with PENDING status.
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = TicketStatus.PENDING;
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the ticket.
     * @param status The new status.
     */
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Ticket #%d [%s]: %s", ticketId, status, description);
    }
}

// Main class for the Customer Service Ticket System
public class CustomerServiceSystem {

    private Queue<Ticket> pendingTicketsQueue;
    private List<Ticket> processedTicketsList; // Declared as List interface
    private int nextTicketId;
    private Scanner scanner;

    /**
     * Constructs a new CustomerServiceSystem.
     * Initializes the queues, lists, and scanner.
     */
    public CustomerServiceSystem() {
        // Use LinkedList as a Queue implementation
        this.pendingTicketsQueue = new LinkedList<>();
        // Instantiate as ArrayList, but declare as List interface
        this.processedTicketsList = new ArrayList<>();
        this.nextTicketId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nCustomer Service Ticket System Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new ticket to the pending queue.
     */
    private void addNewTicket() {
        System.out.print("Enter ticket description: ");
        // Consume the newline character left by previous nextInt() or similar
        scanner.nextLine(); // Consume leftover newline
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }

        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTicketsQueue.offer(newTicket); // offer is preferred over add for queues
        System.out.println("Ticket #" + newTicket.getTicketId() + " added to the queue.");
    }

    /**
     * Processes the next ticket from the pending queue.
     */
    private void processNextTicket() {
        if (pendingTicketsQueue.isEmpty()) {
            System.err.println("Error: No pending tickets to process.");
            return;
        }

        Ticket ticketToProcess = pendingTicketsQueue.poll(); // Retrieves and removes the head
        if (ticketToProcess != null) {
            System.out.println("Processing ticket #" + ticketToProcess.getTicketId() + "...");
            ticketToProcess.setStatus(TicketStatus.PROCESSED);
            processedTicketsList.add(ticketToProcess);
            System.out.println(ticketToProcess + " processed.");
        } else {
             // This case should ideally not happen with isEmpty() check, but good practice
             System.err.println("Error: Failed to retrieve ticket from queue.");
        }
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    private void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTicketsQueue.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate without removing elements - using for-each or stream
            for (Ticket ticket : pendingTicketsQueue) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been processed.
     */
    private void viewProcessedTickets() {
        System.out.println("\n--- Processed Tickets ---");
        if (processedTicketsList.isEmpty()) {
            System.out.println("No tickets processed yet.");
        } else {
            for (Ticket ticket : processedTicketsList) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main system loop for user interaction.
     */
    public void runSystem() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addNewTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewProcessedTickets();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during system operation
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        CustomerServiceSystem system = new CustomerServiceSystem();
        system.runSystem();
    }
}
