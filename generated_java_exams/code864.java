/*
 * Exam Question #864
 * Generated on: 2025-05-12 16:52:11
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based application to manage orders for a small restaurant. The system should allow staff to view the menu, place new orders, process pending orders, and view completed orders.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures and control flow mechanisms, adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store orders that are waiting to be prepared (`pending orders`).
 *     *   Use `java.util.List` to store the available menu items.
 *     *   Use `java.util.List` (specifically implemented by `ArrayList`) to store orders that have been completed.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (e.g., Display Menu, Place Order, Process Order, View Pending Orders, View Completed Orders, Exit).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user menu options.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around operations that might fail (like reading user input or operating on potentially empty collections).
 *     *   Use `System.err` to display error messages to the user (e.g., invalid input, trying to process an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, order details).
 *     *   Validate user input where necessary (e.g., ensure menu item selection is valid).
 * 5.  **Object-Oriented Design:**
 *     *   Create separate classes for `MenuItem` and `Order` to represent these entities.
 *     *   Implement proper encapsulation (private fields, public getters/setters where appropriate, meaningful method names).
 *     *   The main application logic should reside in a class (e.g., `RestaurantSystem`) that manages the data structures and user interaction.
 * 6.  **Code Quality:**
 *     *   Include meaningful variable and method names.
 *     *   Add appropriate comments to explain complex parts of the code.
 *     *   Ensure clean code structure.
 * 
 * **Functionality Details:**
 * 
 * *   **MenuItem:** Should have an ID (int), name (String), and price (double).
 * *   **Order:** Should have a unique Order ID (int, automatically generated), a list of `MenuItem`s, and a status (String, e.g., "Pending", "Completed").
 * *   **Place Order:**
 *     *   Display the menu.
 *     *   Prompt the user to enter the IDs of the items they want to order, one per line.
 *     *   The user should enter a specific value (e.g., 0) to indicate they are finished adding items.
 *     *   Validate that the entered item ID exists in the menu. If not, display an error and ignore that input.
 *     *   Create a new `Order` object with the selected items and "Pending" status.
 *     *   Add the new order to the pending orders queue.
 * *   **Process Order:**
 *     *   Take the next order from the front of the pending orders queue.
 *     *   If the queue is empty, display an error message using `System.err`.
 *     *   If an order is retrieved, change its status to "Completed" and move it to the completed orders list.
 *     *   Display a confirmation message including the processed Order ID.
 * *   **View Pending Orders:** Display the details of all orders currently in the pending queue.
 * *   **View Completed Orders:** Display the details of all orders in the completed list.
 * 
 * **Initial Menu:**
 * 
 * The system should start with a small predefined menu (e.g., Burger, Fries, Drink).
 * 
 * **Expected Output:**
 * 
 * The output should guide the user through the application, displaying the menu, prompts, order details, and error messages clearly using `System.out` and `System.err` appropriately.
 * 
 * ---
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. Display Menu
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Pending Orders
 * 5. View Completed Orders
 * 6. Exit
 * Enter your choice: 1
 * 
 * --- Menu ---
 * ID: 1, Name: Burger, Price: $8.99
 * ID: 2, Name: Fries, Price: $3.49
 * ID: 3, Name: Drink, Price: $1.99
 * 
 * --- Restaurant Order Management ---
 * 1. Display Menu
 * ...
 * Enter your choice: 2
 * 
 * --- Place New Order ---
 * Enter item ID (0 to finish): 1
 * Enter item ID (0 to finish): 2
 * Enter item ID (0 to finish): 99
 * Error: Invalid item ID. Please try again.
 * Enter item ID (0 to finish): 0
 * Order #1 placed with 2 items.
 * 
 * --- Restaurant Order Management ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Orders ---
 * Order ID: 1
 *   - Burger ($8.99)
 *   - Fries ($3.49)
 * Status: Pending
 * 
 * --- Restaurant Order Management ---
 * ...
 * Enter your choice: 3
 * Order #1 processed and moved to completed.
 * 
 * --- Restaurant Order Management ---
 * ...
 * Enter your choice: 5
 * 
 * --- Completed Orders ---
 * Order ID: 1
 *   - Burger ($8.99)
 *   - Fries ($3.49)
 * Status: Completed
 * 
 * --- Restaurant Order Management ---
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * **Task:** Implement the complete Java code for this Restaurant Order Management System based on the requirements above.
 *
 * EXPLANATION:
 * This solution implements a simplified restaurant order management system using the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple class to hold the data for a single menu item (ID, name, price). It uses private fields and public getters for encapsulation and includes a `toString` method for easy printing.
 *     *   `Order`: Represents a customer order. It includes a static counter (`nextOrderId`) to ensure each order gets a unique ID upon creation. It holds a `List<MenuItem>` for the items ordered and a `String` for the status. It also uses private fields and public methods (`setStatus`, getters) for encapsulation and has a detailed `toString` method.
 *     *   `RestaurantSystem`: This is the main class that orchestrates the application. It holds the core data structures and methods for the system's operations.
 * 
 * 2.  **Data Structures:**
 *     *   `menu`: Declared as `List<MenuItem>` and initialized as `ArrayList<MenuItem>`. This stores the fixed menu items. Using `List` interface is a good practice for flexibility.
 *     *   `pendingOrders`: Declared as `Queue<Order>` and initialized as `LinkedList<Order>`. `LinkedList` is a common implementation of `Queue`. This structure correctly models orders waiting to be processed (FIFO - First-In, First-Out). `offer()` is used to add to the tail, and `poll()` is used to remove from the head.
 *     *   `completedOrders`: Declared as `List<Order>` and initialized as `ArrayList<Order>`. This stores orders after they have been processed. `ArrayList` is suitable for storing and iterating over completed orders.
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner`: An instance is created in the `RestaurantSystem` constructor and used throughout the class to read user input. It's closed when the application exits.
 *     *   `displayMainMenu()`: Prints the options available to the user.
 *     *   `run()`: This method contains the main application loop (`while(running)`). It repeatedly displays the menu, reads the user's choice, and uses a `switch` statement to direct execution to the appropriate method (`displayMenu`, `placeOrder`, etc.).
 *     *   `switch` statement: Used in `run()` to handle the different menu options based on the integer input from the user.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `displayMenu()`: Iterates through the `menu` list and prints each `MenuItem`.
 *     *   `findMenuItemById()`: A helper method to search the `menu` list for a `MenuItem` with a matching ID, used during order placement.
 *     *   `placeOrder()`: Prompts the user to enter item IDs. It uses a loop and `scanner.nextInt()`. It validates the input ID against the `menu` using `findMenuItemById()`. Valid items are added to a temporary `ArrayList` (`orderedItems`). When the user enters 0, the loop ends. If `orderedItems` is not empty, a new `Order` is created and added to the `pendingOrders` queue using `offer()`.
 *     *   `processNextOrder()`: Checks if `pendingOrders` is empty. If not, it uses `poll()` to retrieve and remove the next order from the queue, updates its status to "Completed", and adds it to the `completedOrders` list.
 *     *   `viewPendingOrders()`: Iterates through the `pendingOrders` queue (using an enhanced for loop, which doesn't remove elements) and prints each order's details.
 *     *   `viewCompletedOrders()`: Iterates through the `completedOrders` list and prints each order's details.
 * 
 * 5.  **Error Handling:**
 *     *   `try-catch` blocks are used in `run()` and `placeOrder()` around `scanner.nextInt()` calls to catch `InputMismatchException` if the user enters non-integer input. This prevents the program from crashing and prompts the user correctly. `scanner.next()` is called in the catch block to consume the invalid input token and clear the scanner's state.
 *     *   Specific checks are made before operations that might fail: `pendingOrders.isEmpty()` is checked in `processNextOrder()` and `viewPendingOrders()` to handle cases where there's nothing to process or view.
 *     *   Input validation is performed in `placeOrder()` to check if the entered item ID exists in the menu.
 *     *   `System.err` is used specifically for error messages (invalid input, invalid menu choice, empty queue).
 *     *   A general `catch(Exception e)` is included in the `run()` loop as a class-wide catch-all for any other unexpected runtime errors, printing an error message to `System.err` and the stack trace for debugging purposes (as requested by "class-wide exception handling").
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in `MenuItem` and `Order` classes.
 *     *   Meaningful names are used for variables, methods, and classes.
 *     *   Comments explain the purpose of classes, methods, and key code sections.
 *     *   `List` and `Queue` interfaces are used where appropriate, promoting polymorphism.
 *     *   Input is validated during order placement.
 *     *   Error conditions are handled gracefully using `try-catch` and conditional checks, with distinct output streams (`System.out` vs `System.err`).
 *     *   The code is structured logically into classes and methods.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, albeit simplified, application scenario.
 */

import java.util.*;
import java.util.LinkedList; // Explicitly import LinkedList for Queue implementation
import java.util.InputMismatchException; // Import for specific exception handling

// Represents a single menu item
class MenuItem {
    private int id;
    private String name;
    private double price;

    // Constructor
    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    // toString for easy printing
    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Price: $%.2f", id, name, price);
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items; // List of items in this order
    private String status; // e.g., "Pending", "Completed"

    // Constructor: Creates a new order with a unique ID and sets status to Pending
    public Order(List<MenuItem> items) {
        this.orderId = nextOrderId++; // Assign unique ID and increment counter
        this.items = new ArrayList<>(items); // Create a copy of the items list
        this.status = "Pending";
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return items;
    }

    public String getStatus() {
        return status;
    }

    // Method to update the order status
    public void setStatus(String status) {
        this.status = status;
    }

    // toString for easy printing of order details
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append(String.format(" ($%.2f)", item.getPrice())).append("\n");
        }
        sb.append("Status: ").append(status);
        return sb.toString();
    }
}

// Main class managing the restaurant system
public class RestaurantSystem {
    // Use List interface, implemented by ArrayList
    private List<MenuItem> menu;
    // Use Queue interface, implemented by LinkedList
    private Queue<Order> pendingOrders;
    // Use List interface, implemented by ArrayList
    private List<Order> completedOrders;

    private Scanner scanner; // Scanner for user input

    // Constructor: Initializes the system with a predefined menu
    public RestaurantSystem() {
        // Initialize data structures
        menu = new ArrayList<>();
        pendingOrders = new LinkedList<>(); // LinkedList implements Queue
        completedOrders = new ArrayList<>();

        // Add initial menu items
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Fries", 3.49));
        menu.add(new MenuItem(3, "Drink", 1.99));
        menu.add(new MenuItem(4, "Pizza Slice", 4.50));

        // Initialize scanner
        scanner = new Scanner(System.in);
    }

    // Displays the available menu items
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item);
            }
        }
        System.out.println("------------");
    }

    // Finds a menu item by its ID
    private MenuItem findMenuItemById(int id) {
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Handles placing a new order
    private void placeOrder() {
        System.out.println("\n--- Place New Order ---");
        displayMenu(); // Show menu to help customer choose

        List<MenuItem> orderedItems = new ArrayList<>();
        int itemId;

        System.out.println("Enter item ID (0 to finish):");

        // Loop to read item IDs until user enters 0
        while (true) {
            System.out.print("> ");
            try {
                itemId = scanner.nextInt(); // Read integer input
                if (itemId == 0) {
                    break; // Exit loop if user enters 0
                }

                MenuItem selectedItem = findMenuItemById(itemId);
                if (selectedItem != null) {
                    orderedItems.add(selectedItem);
                    System.out.println(selectedItem.getName() + " added.");
                } else {
                    // Use System.err for error message
                    System.err.println("Error: Invalid item ID. Please try again.");
                }
            } catch (InputMismatchException e) {
                // Use System.err for input type error
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected errors during input
                System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                scanner.next(); // Attempt to consume input
            }
        }

        // After loop, check if any items were added
        if (!orderedItems.isEmpty()) {
            Order newOrder = new Order(orderedItems);
            pendingOrders.offer(newOrder); // Add order to the end of the queue
            System.out.println("Order #" + newOrder.getOrderId() + " placed with " + orderedItems.size() + " items.");
        } else {
            System.out.println("No items selected. Order not placed.");
        }
    }

    // Processes the next order from the pending queue
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        if (pendingOrders.isEmpty()) {
            // Use System.err for operational error
            System.err.println("Error: No pending orders to process.");
        } else {
            Order orderToProcess = pendingOrders.poll(); // Get and remove the head of the queue
            if (orderToProcess != null) { // poll returns null if queue is empty, though we checked isEmpty()
                orderToProcess.setStatus("Completed"); // Update status
                completedOrders.add(orderToProcess); // Add to completed list
                System.out.println("Order #" + orderToProcess.getOrderId() + " processed and moved to completed.");
            }
        }
    }

    // Displays all orders in the pending queue
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No orders currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : pendingOrders) {
                System.out.println(order);
                System.out.println("------------"); // Separator for readability
            }
        }
    }

    // Displays all orders in the completed list
    private void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No orders have been completed yet.");
        } else {
            for (Order order : completedOrders) {
                System.out.println(order);
                System.out.println("------------"); // Separator for readability
            }
        }
    }

    // Displays the main application menu
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order Management ---");
        System.out.println("1. Display Menu");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. View Completed Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main application loop
    public void run() {
        boolean running = true;
        while (running) {
            displayMainMenu();
            try {
                int choice = scanner.nextInt(); // Read user choice

                // Use switch statement for main menu navigation
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        viewCompletedOrders();
                        break;
                    case 6:
                        running = false; // Exit the loop
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid menu choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Use System.err for input type error in main menu
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
            } catch (Exception e) {
                // Class-wide catch for any other unexpected exceptions in the loop
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging in exam scenario
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run(); // Start the main application loop
    }
}
