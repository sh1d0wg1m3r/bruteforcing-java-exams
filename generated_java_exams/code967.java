/*
 * Exam Question #967
 * Generated on: 2025-05-12 17:06:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small business. The system should allow users to add new tasks to a processing queue, simulate the processing of tasks, view the pending tasks, and view the tasks that have been completed or failed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store tasks that have been processed (either successfully completed or failed).
 *     *   Declare the variable holding the completed/failed tasks using the `java.util.List` interface type.
 * 2.  **Task Representation:**
 *     *   Create a `Task` class with private fields for `taskId` (an integer, unique), `taskType` (a String, e.g., "DATA_ENTRY", "REPORT"), `description` (a String), and `status` (an enum: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Include appropriate public getter methods for these fields.
 *     *   Include a method to update the `status` of the task.
 *     *   Override the `toString()` method to provide a clear string representation of a task.
 * 3.  **System Functionality:**
 *     *   Implement a main class (e.g., `TaskManagementSystem`) with a `main` method that drives the application.
 *     *   Provide a menu-driven interface using `java.util.Scanner` for user input.
 *     *   The menu should include options for:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks Queue
 *         4.  View Processed Tasks List
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Implementation Details:**
 *     *   **Add New Task:** Prompt the user for task type and description. Create a new `Task` object with status `PENDING` and add it to the queue. Assign a simple sequential `taskId`.
 *     *   **Process Next Task:** Attempt to retrieve the next task from the queue.
 *         *   If the queue is empty, print an error message to `System.err`.
 *         *   If a task is retrieved, set its status to `PROCESSING`. Simulate processing:
 *             *   If the task type is "REPORT", simulate a processing failure by setting its status to `FAILED` and printing an error to `System.err`.
 *             *   For any other task type, simulate successful completion by setting its status to `COMPLETED` and printing a success message to `System.out`.
 *         *   In either case (success or failure), remove the task from the queue (which `poll()` does) and add it to the list of processed tasks.
 *     *   **View Pending Tasks Queue:** Print the details of all tasks currently in the queue using `System.out`. If the queue is empty, print a message indicating so.
 *     *   **View Processed Tasks List:** Print the details of all tasks in the processed tasks list using `System.out`. If the list is empty, print a message indicating so.
 *     *   **Exit:** Terminate the program.
 * 5.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Use `System.err` for invalid input messages.
 *     *   Implement class-wide exception handling using a `try-catch` block wrapping the main application loop to catch unexpected runtime errors. Print a generic error message to `System.err` if an exception occurs.
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but not strictly required for every single element in an exam; focus on clarity).
 *     *   Ensure clear output messages using `System.out`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform the requested actions, printing status and results to `System.out` and errors to `System.err`.
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Followed by appropriate output based on the choice.
 * 
 * **Constraints:**
 * 
 * *   You must use *all* the Java components listed in Requirement 1 & 3 (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   The task processing simulation logic must include the specific failure condition for "REPORT" tasks as described.
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Task` class and the `TaskManagementSystem` class.
 *
 * EXPLANATION:
 * The solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents individual tasks with `taskId`, `taskType`, `description`, and `status`.
 *     *   Uses an `enum` (`TaskStatus`) for clear and type-safe status representation (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Encapsulation is maintained with private fields and public getter methods.
 *     *   A `setStatus` method allows updating the task's status.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskManagementSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTasksQueue`: Declared as `Queue<Task>` and instantiated with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, fulfilling the requirement to use `Queue`. Tasks are added here using `offer()`.
 *         *   `processedTasksList`: Declared as `List<Task>` and instantiated with `new ArrayList<>()`. This demonstrates using the `List` interface type while implementing it with `ArrayList`, fulfilling both `List` and `ArrayList` requirements. Processed tasks are added here using `add()`.
 *     *   **Functionality Methods:**
 *         *   `addTask(String type, String description)`: Creates a new `Task` object with a unique ID and adds it to the `pendingTasksQueue`.
 *         *   `processNextTask()`: Uses `pendingTasksQueue.poll()` to retrieve and remove the head of the queue. It checks if the result is `null` (queue empty) and prints an error to `System.err`. If a task is found, it simulates processing. The specific requirement for "REPORT" tasks failing is implemented with an `equalsIgnoreCase` check. The task's status is updated (`FAILED` or `COMPLETED`), and the task is then added to the `processedTasksList`. Error messages for failed tasks are sent to `System.err`, success messages to `System.out`.
 *         *   `viewPendingTasks()`: Iterates through the `pendingTasksQueue` (using a for-each loop, which doesn't remove elements) and prints each task to `System.out`.
 *         *   `viewProcessedTasks()`: Iterates through the `processedTasksList` and prints each task to `System.out`.
 *     *   **Menu and User Input:**
 *         *   `displayMenu()`: Prints the options to `System.out`.
 *         *   `main(String[] args)`: Contains the main application loop.
 *             *   A `Scanner` object is used to read user input from `System.in`.
 *             *   A `while(running)` loop keeps the system active until the user chooses to exit.
 *             *   Input validation is performed using `scanner.hasNextInt()` to check if the next input is an integer. If not, an error is printed to `System.err`, the invalid input is consumed, and the loop continues.
 *             *   A `switch` statement is used to control the flow based on the valid menu choice, calling the appropriate methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewProcessedTasks`) or setting `running` to `false` for the exit option.
 *             *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   **Class-wide Exception Handling:**
 *         *   The entire `while` loop in `main` is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unexpected exceptions that might occur during the execution of the menu options or input processing. If an exception is caught, a generic error message and the stack trace are printed to `System.err`.
 *         *   A `finally` block ensures the `Scanner` is closed when the program exits, whether normally or due to an exception.
 *     *   **Best Practices:** The code uses meaningful names (`pendingTasksQueue`, `processNextTask`, `TaskStatus`), private fields, public methods, and comments to explain sections of code. Output is directed to `System.out` for normal information and `System.err` for errors.
 * 
 * This solution effectively integrates all required components into a functional program that simulates a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in Java.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    PROCESSING, // Although processing is simulated quickly, this status could be used in a more complex system
    COMPLETED,
    FAILED
}

// Represents a single task in the system
class Task {
    private int taskId;
    private String taskType;
    private String description;
    private TaskStatus status;

    public Task(int taskId, String taskType, String description) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getTaskType() {
        return taskType;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for Status ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    // --- toString Method ---
    @Override
    public String toString() {
        return String.format("Task ID: %d, Type: %s, Status: %s, Description: \"%s\"",
                             taskId, taskType, status, description);
    }
}

// Main class for the Task Management System
public class TaskManagementSystem {

    // Use Queue for pending tasks (LinkedList is a common implementation)
    private Queue<Task> pendingTasksQueue;

    // Use List interface type for processed tasks, implemented by ArrayList
    private List<Task> processedTasksList;

    private int nextTaskId = 1; // Counter for unique task IDs

    public TaskManagementSystem() {
        pendingTasksQueue = new LinkedList<>(); // LinkedList implements Queue
        processedTasksList = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param type The type of the task.
     * @param description The description of the task.
     */
    public void addTask(String type, String description) {
        Task newTask = new Task(nextTaskId++, type, description);
        pendingTasksQueue.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added: " + newTask.toString());
    }

    /**
     * Processes the next task from the queue.
     * Simulates processing success or failure.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasksQueue.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the pending queue to process.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess.getTaskId());
        taskToProcess.setStatus(TaskStatus.PROCESSING); // Set status to processing (briefly)

        // Simulate processing logic
        if ("REPORT".equalsIgnoreCase(taskToProcess.getTaskType())) {
            // Simulate failure for REPORT tasks
            taskToProcess.setStatus(TaskStatus.FAILED);
            System.err.println("Task ID " + taskToProcess.getTaskId() + " (Type: REPORT) failed during processing.");
        } else {
            // Simulate success for other task types
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            System.out.println("Task ID " + taskToProcess.getTaskId() + " processed successfully.");
        }

        // Add the processed task (whether completed or failed) to the processed list
        processedTasksList.add(taskToProcess);
        System.out.println("Task ID " + taskToProcess.getTaskId() + " moved to processed list.");
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks Queue ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("The pending task queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasksQueue) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Displays all tasks in the processed tasks list.
     */
    public void viewProcessedTasks() {
        System.out.println("\n--- Processed Tasks List ---");
        if (processedTasksList.isEmpty()) {
            System.out.println("The processed tasks list is empty.");
        } else {
            for (Task task : processedTasksList) {
                System.out.println(task);
            }
        }
        System.out.println("----------------------------\n");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks Queue");
        System.out.println("4. View Processed Tasks List");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Task Management System.
     * Includes the main application loop and class-wide exception handling.
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManagementSystem system = new TaskManagementSystem();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                system.displayMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task type (e.g., DATA_ENTRY, REPORT, SUPPORT): ");
                        String type = scanner.nextLine();
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        system.addTask(type, description);
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        system.viewPendingTasks();
                        break;
                    case 4:
                        system.viewProcessedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shut down.");
        }
    }
}
