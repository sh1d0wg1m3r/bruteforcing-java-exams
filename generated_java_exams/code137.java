/*
 * Exam Question #137
 * Generated on: 2025-05-11 22:20:03
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Warehouse Inventory & Order Processing System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified Warehouse Inventory and Order Processing System. The system should manage inventory of various items, handle incoming shipments that replenish stock, and process outgoing orders that deplete stock. Incoming shipments are processed in the order they are received, while outgoing orders are processed immediately if inventory allows.
 * 
 * Your task is to create a Java program that simulates this system, interacting with the user via a console menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending incoming shipment requests. Shipments must be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` to store the current inventory of items.
 *     *   Declare the inventory list using the `java.util.List` interface (`List<InventoryItem> inventoryList = new ArrayList<>();`).
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console for menu choices and data (item names, quantities).
 *     *   Implement a main menu loop that allows the user to select actions.
 * 
 * 3.  **Core Functionality (Menu Options):**
 *     *   **Add Incoming Shipment Request:** Prompt the user for an item name and quantity. Create a request object and add it to the shipment queue.
 *     *   **Process Next Incoming Shipment:** Take the oldest request from the queue. Find the item in the inventory. If it exists, add the quantity to the current stock. If it doesn't exist, add a new item to the inventory list with the specified quantity. Handle the case where the queue is empty.
 *     *   **Place Outgoing Order:** Prompt the user for an item name and quantity. Find the item in the inventory. If the item exists and there is sufficient stock, decrease the inventory quantity and confirm the order. If the item is not found or there is insufficient stock, report an error.
 *     *   **Check Inventory:** Display the name and current quantity of all items in the inventory.
 *     *   **Check Shipment Queue:** Display the details of all pending shipment requests in the queue (without removing them).
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, invalid input format, insufficient stock, item not found, empty queue).
 *     *   Implement input validation (e.g., quantities must be positive integers).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential runtime errors (like invalid input format or errors propagating from business logic).
 * 
 * 6.  **Best Practices:**
 *     *   Create appropriate classes (e.g., `InventoryItem`, `ShipmentRequest`, `WarehouseSystem`) with private fields and public methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   Menu options displayed clearly using `System.out`.
 * *   Prompts for input using `System.out`.
 * *   Success messages and inventory/queue status displayed using `System.out`.
 * *   Error messages displayed using `System.err`.
 * *   Program exits cleanly when the user chooses the exit option.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Warehouse Order Processing System ---
 * 
 * Select an action:
 * 1. Add Incoming Shipment Request
 * 2. Process Next Incoming Shipment
 * 3. Place Outgoing Order
 * 4. Check Inventory
 * 5. Check Shipment Queue
 * 6. Exit
 * Enter choice: 1
 * Enter item name for shipment: Laptop
 * Enter quantity for shipment: 5
 * Shipment request added for 5 of Laptop.
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 1
 * Enter item name for shipment: Mouse
 * Enter quantity for shipment: 10
 * Shipment request added for 10 of Mouse.
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 5
 * --- Pending Shipments ---
 *   - 5 of Laptop
 *   - 10 of Mouse
 * -------------------------
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 2
 * Processed shipment: Added new item Laptop with quantity 5.
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 4
 * --- Current Inventory ---
 * Laptop: 5
 * -------------------------
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 3
 * Enter item name for order: Laptop
 * Enter quantity for order: 2
 * Order placed successfully for 2 of Laptop. Remaining quantity: 3
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 3
 * Enter item name for order: Keyboard
 * Enter quantity for order: 1
 * Processing Error: Error: Item 'Keyboard' not found in inventory.
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 2
 * Processed shipment: Added new item Mouse with quantity 10. New quantity: 10
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 4
 * --- Current Inventory ---
 * Laptop: 3
 * Mouse: 10
 * -------------------------
 * 
 * Select an action:
 * ... (menu repeats)
 * Enter choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a basic Warehouse Inventory and Order Processing System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `InventoryItem`: A simple class to hold an item's `name` and `quantity`. It includes methods to safely add and remove quantity, enforcing encapsulation.
 *     *   `ShipmentRequest`: A simple class to represent an incoming shipment request, holding the `itemName` and `quantity`.
 *     *   `WarehouseSystem`: The main class that orchestrates the system. It holds the core data structures (`inventoryList` and `shipmentQueue`) and contains the methods for performing warehouse operations. The `main` method resides here to run the application.
 * 
 * 2.  **Data Structures Implementation:**
 *     *   `List<InventoryItem> inventoryList = new ArrayList<>();`: An `ArrayList` is used to store `InventoryItem` objects. It is declared using the `List` interface, adhering to best practices for programming to interfaces. `ArrayList` provides efficient random access, which is suitable for searching through the inventory.
 *     *   `Queue<ShipmentRequest> shipmentQueue = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface for storing `ShipmentRequest` objects. `Queue`'s `add()` and `poll()` methods naturally support the FIFO behavior required for processing shipments in order of arrival.
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner`: Used in the `main` method to read user input from `System.in`. Care is taken to consume the newline character after reading integers (`scanner.nextLine();`) to prevent issues with subsequent `nextLine()` calls.
 *     *   `while` loop: The main application runs within a `while(running)` loop, allowing the user to perform multiple actions until they choose to exit.
 *     *   `switch` statement: Inside the loop, a `switch` statement is used to direct the program flow based on the user's integer input, calling the corresponding methods of the `WarehouseSystem` object.
 * 
 * 4.  **Core Functionality Logic:**
 *     *   `addShipmentRequest`: Creates a `ShipmentRequest` object and adds it to the `shipmentQueue` using `queue.add()`. Includes input validation for quantity and item name.
 *     *   `processNextShipment`: Uses `queue.poll()` to get and remove the next request from the queue. It checks if the queue is empty (`request == null`). It then searches the `inventoryList` for the item. If found, it updates the existing `InventoryItem`; otherwise, it creates and adds a new `InventoryItem` to the list.
 *     *   `placeOrder`: Searches the `inventoryList` for the requested item. It checks if the item exists and if there is sufficient quantity using the `removeQuantity` method of `InventoryItem`. If successful, it confirms the order; otherwise, it throws a `RuntimeException` indicating the specific reason (item not found or insufficient stock). Includes input validation.
 *     *   `displayInventory`: Iterates through the `inventoryList` and prints each `InventoryItem` using its `toString()` method.
 *     *   `displayShipmentQueue`: Iterates through the `shipmentQueue`. Iterating directly over a `Queue` using a for-each loop uses its iterator, which allows viewing elements without removing them, fulfilling the requirement to check the queue status.
 * 
 * 5.  **Error Handling:**
 *     *   `System.err.println()`: Used consistently for all error messages as required.
 *     *   Input Validation: Checks for positive quantities and non-empty item names are performed before processing requests/orders, throwing `IllegalArgumentException` for invalid input data.
 *     *   `try-catch` blocks: The entire `while` loop in the `main` method is wrapped in a `try-catch` block. This demonstrates class-wide exception handling. It specifically catches:
 *         *   `InputMismatchException`: Handles cases where the user enters non-integer input when an integer is expected by `scanner.nextInt()`. The invalid input is consumed to prevent an infinite loop.
 *         *   `IllegalArgumentException`: Catches exceptions thrown by methods like `addShipmentRequest` or `placeOrder` for invalid input parameters (e.g., non-positive quantity).
 *         *   `RuntimeException`: Catches exceptions thrown by methods like `placeOrder` for business logic failures (item not found, insufficient stock). Using `RuntimeException` is common for such recoverable business errors that might occur during normal operation based on data state.
 *         *   `Exception`: A general catch-all for any other unexpected exceptions that might occur, providing a basic level of robustness.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods ensure encapsulation.
 *     *   Method names (`addShipmentRequest`, `processNextShipment`, `placeOrder`, `displayInventory`, `findInventoryItem`) and variable names (`shipmentQueue`, `inventoryList`, `itemName`, `quantity`, `choice`) are descriptive.
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   The code is structured into logical methods within the `WarehouseSystem` class.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, control flow, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an item in the warehouse inventory.
 */
class InventoryItem {
    private String name;
    private int quantity;

    /**
     * Constructs an InventoryItem.
     * @param name The name of the item.
     * @param quantity The initial quantity.
     */
    public InventoryItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current quantity of the item.
     * @return The current quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Adds quantity to the item's stock.
     * @param quantity The amount to add.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addQuantity(int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity to add must be positive.");
        }
        this.quantity += quantity;
    }

    /**
     * Removes quantity from the item's stock.
     * @param quantity The amount to remove.
     * @return true if successful, false if insufficient stock or quantity is not positive.
     */
    public boolean removeQuantity(int quantity) {
        if (quantity <= 0) {
             // Could throw exception, but returning false is also a valid strategy for business logic failure
             return false; // Indicate invalid quantity attempt
        }
        if (this.quantity >= quantity) {
            this.quantity -= quantity;
            return true; // Success
        } else {
            return false; // Insufficient stock
        }
    }

    /**
     * Returns a string representation of the inventory item.
     * @return String in format "Name: Quantity".
     */
    @Override
    public String toString() {
        return name + ": " + quantity;
    }
}

/**
 * Represents a request for an incoming shipment.
 * These requests are processed in FIFO order.
 */
class ShipmentRequest {
    private String itemName;
    private int quantity;

    /**
     * Constructs a ShipmentRequest.
     * @param itemName The name of the item in the shipment.
     * @param quantity The quantity of the item.
     */
    public ShipmentRequest(String itemName, int quantity) {
        this.itemName = itemName;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the item in the shipment request.
     * @return The item name.
     */
    public String getItemName() {
        return itemName;
    }

    /**
     * Gets the quantity of the item in the shipment request.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }
}

/**
 * The main class managing warehouse operations: inventory and shipments.
 */
public class WarehouseSystem { // Made public for the main method

    // Use List interface for flexibility, implemented by ArrayList
    private List<InventoryItem> inventoryList;
    // Use Queue interface for FIFO processing, implemented by LinkedList
    private Queue<ShipmentRequest> shipmentQueue;

    /**
     * Constructs a WarehouseSystem with empty inventory and shipment queue.
     */
    public WarehouseSystem() {
        this.inventoryList = new ArrayList<>();
        this.shipmentQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
    }

    /**
     * Adds a new shipment request to the queue.
     * @param itemName The name of the item.
     * @param quantity The quantity of the item.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addShipmentRequest(String itemName, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Shipment quantity must be positive.");
        }
        if (itemName == null || itemName.trim().isEmpty()) {
             throw new IllegalArgumentException("Item name cannot be empty.");
        }
        ShipmentRequest request = new ShipmentRequest(itemName.trim(), quantity);
        shipmentQueue.add(request);
        System.out.println("Shipment request added for " + quantity + " of " + itemName + ".");
    }

    /**
     * Processes the next shipment request in the queue (FIFO).
     * Adds the items to the inventory.
     */
    public void processNextShipment() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        ShipmentRequest request = shipmentQueue.poll();
        if (request == null) {
            System.out.println("No pending shipment requests to process.");
            return;
        }

        String itemName = request.getItemName();
        int quantity = request.getQuantity();

        // Find the item in inventory (case-insensitive search)
        InventoryItem item = findInventoryItem(itemName);

        if (item != null) {
            // Item exists, add quantity
            item.addQuantity(quantity); // addQuantity handles positive check internally
            System.out.println("Processed shipment: Added " + quantity + " of " + itemName + ". New quantity: " + item.getQuantity());
        } else {
            // Item does not exist, add new item to inventory
            InventoryItem newItem = new InventoryItem(itemName, quantity);
            inventoryList.add(newItem);
            System.out.println("Processed shipment: Added new item '" + itemName + "' with quantity " + quantity + ".");
        }
    }

    /**
     * Places an order for items from inventory.
     * @param itemName The name of the item to order.
     * @param quantity The quantity to order.
     * @throws IllegalArgumentException if quantity is not positive.
     * @throws RuntimeException if item not found or insufficient stock.
     */
    public void placeOrder(String itemName, int quantity) {
         if (quantity <= 0) {
            throw new IllegalArgumentException("Order quantity must be positive.");
        }
         if (itemName == null || itemName.trim().isEmpty()) {
             throw new IllegalArgumentException("Item name cannot be empty.");
        }

        InventoryItem item = findInventoryItem(itemName.trim());

        if (item == null) {
            // Throw a RuntimeException for business logic failure (item not found)
            throw new RuntimeException("Item '" + itemName + "' not found in inventory.");
        }

        // removeQuantity returns boolean indicating success/failure due to stock/quantity
        if (item.removeQuantity(quantity)) {
            System.out.println("Order placed successfully for " + quantity + " of " + itemName + ". Remaining quantity: " + item.getQuantity());
             // Optional: remove item from list if quantity becomes 0
             if (item.getQuantity() == 0) {
                 inventoryList.remove(item);
                 System.out.println("Note: '" + itemName + "' inventory is now empty and removed from list.");
             }
        } else {
            // Throw a RuntimeException for business logic failure (insufficient stock)
            throw new RuntimeException("Insufficient stock for '" + itemName + "'. Available: " + item.getQuantity());
        }
    }

    /**
     * Finds an inventory item by name (case-insensitive search).
     * @param itemName The name of the item to find.
     * @return The InventoryItem object if found, otherwise null.
     */
    private InventoryItem findInventoryItem(String itemName) {
        for (InventoryItem item : inventoryList) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                return item;
            }
        }
        return null; // Not found
    }

    /**
     * Displays the current inventory status.
     */
    public void displayInventory() {
        System.out.println("\n--- Current Inventory ---");
        if (inventoryList.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            // Iterate through the List and print each item
            for (InventoryItem item : inventoryList) {
                System.out.println(item); // Uses InventoryItem's toString() method
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the current shipment queue status without removing elements.
     */
     public void displayShipmentQueue() {
         System.out.println("\n--- Pending Shipments ---");
         if (shipmentQueue.isEmpty()) {
             System.out.println("Shipment queue is empty.");
         } else {
             // Iterate through the Queue using a for-each loop (uses iterator internally)
             // This allows viewing elements without removing them (unlike poll() or remove())
             for (ShipmentRequest request : shipmentQueue) {
                 System.out.println("  - " + request.getQuantity() + " of " + request.getItemName());
             }
         }
         System.out.println("-------------------------");
     }


    /**
     * Main method to run the warehouse system simulation.
     * Handles user input and menu navigation.
     * Includes class-wide exception handling.
     */
    public static void main(String[] args) {
        // Scanner for user input
        Scanner scanner = new Scanner(System.in);
        WarehouseSystem system = new WarehouseSystem();
        boolean running = true;

        System.out.println("--- Warehouse Order Processing System ---");

        // Main application loop with class-wide exception handling
        while (running) {
            try {
                // Display menu using System.out
                System.out.println("\nSelect an action:");
                System.out.println("1. Add Incoming Shipment Request");
                System.out.println("2. Process Next Incoming Shipment");
                System.out.println("3. Place Outgoing Order");
                System.out.println("4. Check Inventory");
                System.out.println("5. Check Shipment Queue");
                System.out.println("6. Exit");
                System.out.print("Enter choice: ");

                // Read integer input for choice
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left after nextInt()

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter item name for shipment: ");
                        String shipmentItemName = scanner.nextLine();
                        System.out.print("Enter quantity for shipment: ");
                        int shipmentQuantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        system.addShipmentRequest(shipmentItemName, shipmentQuantity);
                        break;

                    case 2:
                        system.processNextShipment();
                        break;

                    case 3:
                        System.out.print("Enter item name for order: ");
                        String orderItemName = scanner.nextLine();
                        System.out.print("Enter quantity for order: ");
                        int orderQuantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        system.placeOrder(orderItemName, orderQuantity);
                        break;

                    case 4:
                        system.displayInventory();
                        break;

                    case 5:
                        system.displayShipmentQueue();
                        break;

                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;

                    default:
                        // Use System.err for invalid menu choice error
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (java.util.InputMismatchException e) {
                // Handle cases where user enters non-integer input for numbers
                System.err.println("Error: Invalid input format. Please enter a number for the choice or quantity.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent an infinite loop
            } catch (IllegalArgumentException e) {
                 // Handle specific validation errors like non-positive quantity or empty name
                 System.err.println("Input Error: " + e.getMessage());
            } catch (RuntimeException e) {
                 // Handle business logic errors thrown as RuntimeExceptions (e.g., item not found, insufficient stock)
                 System.err.println("Processing Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions for robustness
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging unexpected issues
                // e.printStackTrace();
            }
        }

        // Close the scanner resource
        scanner.close();
    }
}
