/*
 * Exam Question #668
 * Generated on: 2025-05-12 16:22:42
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line based Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting for processing, process the next task in line, and view all tasks ever created.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a task. Each task should have a unique integer ID, a string description, and an integer priority (1 being highest, 5 being lowest).
 * 2.  **Task Management Logic:** Create a `TaskManager` class that will handle the collection and processing of tasks.
 *     *   The `TaskManager` must maintain **two** collections:
 *         *   A `java.util.List` (specifically, a `java.util.ArrayList`) to store **all** tasks ever created in the system.
 *         *   A `java.util.Queue` (specifically, a `java.util.LinkedList` which implements `Queue`) to store tasks that are **pending** processing. Tasks should be processed in the order they were added to the queue (FIFO - First-In, First-Out), regardless of priority for this simplified version.
 *     *   Implement methods in `TaskManager`:
 *         *   `addTask(String description, int priority)`: Creates a new `Task`, adds it to both the list of all tasks and the queue of pending tasks. Assigns a unique, auto-incrementing ID starting from 1.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them.
 *         *   `processNextTask()`: Removes and returns the next task from the pending queue. Simulates processing by printing a message. Handles the case where the queue is empty.
 *         *   `viewAllTasks()`: Displays all tasks ever added to the system (from the list).
 * 3.  **User Interface:** Implement a simple command-line interface in a `main` method.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu with options:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  Process Next Task
 *         4.  View All Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Input Validation & Error Handling:**
 *     *   Validate user input for adding a task: Description should not be empty, priority must be between 1 and 5 (inclusive).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `NumberFormatException` when parsing user input for menu choices or priority.
 *     *   Use `System.err` to print error messages (e.g., invalid input, attempting to process an empty queue).
 *     *   Use `System.out` for menu display, prompts, successful operation messages, and listing tasks.
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods) in `Task` and `TaskManager` classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments where necessary for clarity.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should present a menu, accept user input, perform the requested action, and provide appropriate feedback using `System.out` for normal operations and `System.err` for errors. Example interactions might include:
 * 
 * *   Adding tasks and seeing confirmation.
 * *   Viewing the queue and seeing the tasks in FIFO order.
 * *   Processing a task and seeing it removed from the queue.
 * *   Attempting to process a task when the queue is empty and seeing an error message on `System.err`.
 * *   Viewing all tasks ever created.
 * *   Entering invalid menu choices or task details and seeing error messages on `System.err`.
 * *   Exiting the system.
 * 
 * Your solution should compile and run, demonstrating the correct usage of all required Java components in a cohesive program.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * **Overall Structure:**
 * The system is divided into three main classes:
 * 1.  `Task`: A simple class encapsulating the data for a single task (`id`, `description`, `priority`). It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print task details.
 * 2.  `TaskManager`: This class holds the core logic for managing tasks. It uses the required collections (`List` and `Queue`) to store tasks in different states (all tasks vs. pending tasks). It contains methods for adding, viewing, and processing tasks.
 * 3.  `TaskManagementSystem`: This class contains the `main` method, which serves as the command-line interface. It interacts with the user via `Scanner`, uses a `switch` statement for menu navigation, and incorporates `try-catch` blocks for error handling.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`java.util.Queue`**: The `pendingTasks` field in `TaskManager` is declared as a `Queue<Task>` and instantiated as a `java.util.LinkedList`. The `offer()` method is used to add tasks to the queue (at the tail), and the `poll()` method is used to retrieve and remove the next task from the queue (from the head), implementing FIFO behavior. Iteration using an enhanced for loop in `viewPendingTasks()` demonstrates viewing queue elements without removing them.
 * *   **`java.util.ArrayList`**: The `allTasks` field in `TaskManager` is declared as a `java.util.List<Task>` and instantiated as a `java.util.ArrayList`. This collection stores a record of every task ever created. Tasks are added using the `add()` method, and the `viewAllTasks()` method iterates through this list to display all entries.
 * *   **`java.util.List`**: The `allTasks` field is explicitly declared using the `List` interface type (`List<Task> allTasks = new ArrayList<>();`). This demonstrates the good practice of programming to the interface rather than the specific implementation (`ArrayList`), although the requirements specifically requested `ArrayList` usage.
 * *   **`java.util.Scanner`**: An instance of `Scanner` is created in the `main` method (`Scanner scanner = new Scanner(System.in);`) to read user input from the console for menu choices and task details. `scanner.nextLine()` is used consistently to read input lines.
 * *   **`switch` statement**: The `main` method uses a `switch` statement based on the integer `choice` read from the user. Each `case` corresponds to a menu option, directing the program flow to the appropriate `TaskManager` method or exit logic. A `default` case handles invalid menu numbers.
 * *   **`System.err`**: Used specifically for printing error messages, such as invalid menu choices, invalid task input (empty description, out-of-range priority), and attempting to process a task when the queue is empty. This differentiates error output from normal program output.
 * *   **`System.out`**: Used for all standard program output, including printing the menu, prompts for input, confirmation messages for adding/processing tasks, and displaying the contents of the task lists/queue.
 * *   **Class-wide exception handling with `try-catch`**: A large `try-catch` block wraps the main loop logic where user input is read and parsed. This block specifically catches `NumberFormatException` which occurs if the user enters non-integer text when a number is expected (for choice or priority). A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing the error message to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, accessible only through public methods (`getters`, `addTask`, etc.).
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`), variable names (`allTasks`, `pendingTasks`, `nextTaskId`, `description`, `priority`, `choice`), and method names (`addTask`, `viewPendingTasks`, `processNextTask`, `viewAllTasks`, `printMenu`) are descriptive and indicate their purpose.
 * *   **Comments:** Basic comments are included to explain the purpose of classes, fields, and key methods.
 * *   **Input Validation:** Checks are performed in the `main` method before calling `addTask` to ensure the description is not empty and the priority is within the valid range (1-5). Error messages for invalid input are printed to `System.err`.
 * *   **Error Handling:** Specific exception handling for `NumberFormatException` is implemented. The `processNextTask` method explicitly checks if the queue is empty (`pendingTasks.poll() == null`) before attempting to process, preventing a potential `NullPointerException` or other queue-specific errors and printing a user-friendly error message to `System.err`.
 * *   **Clean Code Structure:** The code is organized into logical classes. The `main` method focuses on user interaction and delegation to `TaskManager`, while `TaskManager` handles the data structures and business logic. A separate helper method `printMenu` keeps the `main` method cleaner. Using `System.lineSeparator()` provides better cross-platform compatibility for newlines in output.
 * 
 * This solution effectively integrates all specified Java components in a practical scenario, demonstrating an understanding of collection types, control flow, input/output handling, and robust error management.
 */

import java.util.Scanner;
import java.util.List;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.InputMismatchException; // Although nextLine+parseInt is used, good to know

// Represents a single task
class Task {
    private int id;
    private String description;
    private int priority; // 1 (high) to 5 (low)

    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters for accessing task details
    public int getId() { return id; }
    public String getDescription() { return description; }
    public int getPriority() { return priority; }

    // Provides a user-friendly string representation of the task
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Priority=" + priority + "]";
    }
}

// Manages the collection and processing of tasks
class TaskManager {
    // List to store all tasks ever created
    private List<Task> allTasks;
    // Queue to store tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    // Constructor initializes the collections and task ID counter
    public TaskManager() {
        allTasks = new ArrayList<>(); // Using ArrayList for the List implementation
        pendingTasks = new LinkedList<>(); // Using LinkedList for the Queue implementation
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Creates a new task and adds it to both the list of all tasks and the pending queue.
     * Assumes description is not empty and priority is valid (validation done in main).
     * @param description The task description.
     * @param priority The task priority (1-5).
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasks.offer(newTask); // Add to the pending queue (offer is preferred over add for capacity-constrained queues, though LinkedList is not)
        System.out.println(System.lineSeparator() + "Task added: " + newTask);
    }

    /**
     * Displays all tasks currently in the pending queue without removing them.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println(System.lineSeparator() + "No pending tasks in the queue.");
            return;
        }
        System.out.println(System.lineSeparator() + "--- Pending Tasks (Queue) ---");
        // Iterate through the queue elements. The iterator for LinkedList does not remove elements.
        for (Task task : pendingTasks) {
            System.out.println(task);
        }
        System.out.println("-----------------------------");
    }

    /**
     * Removes and returns the next task from the pending queue, simulating processing.
     * Prints an error message if the queue is empty.
     * @return The processed Task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task processedTask = pendingTasks.poll(); // Remove and get the head of the queue
        if (processedTask == null) {
            System.err.println(System.lineSeparator() + "Error: No tasks available to process. The queue is empty."); // Use System.err for the error condition
            return null;
        }
        System.out.println(System.lineSeparator() + "Processing task: " + processedTask);
        // In a real system, actual processing logic would go here
        System.out.println("Task processed successfully.");
        return processedTask;
    }

    /**
     * Displays all tasks that have ever been created and added to the system.
     */
     public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println(System.lineSeparator() + "No tasks have been created yet.");
            return;
        }
        System.out.println(System.lineSeparator() + "--- All Created Tasks (List) ---");
        // Iterate through the list of all tasks
        for (Task task : allTasks) {
            System.out.println(task);
        }
        System.out.println("------------------------------");
    }
}

// Main class to run the Task Management System
public class TaskManagementSystem {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in); // Scanner for user input
        boolean running = true;

        System.out.println("--- Simple Task Management System ---");

        while (running) {
            printMenu();
            System.out.print("Enter choice: ");

            try {
                // Read the entire line to avoid issues with nextInt() and the newline character
                String choiceString = scanner.nextLine();
                int choice = Integer.parseInt(choiceString); // Parse the input string to an integer

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (1-5, 1=high, 5=low): ");
                        String priorityString = scanner.nextLine();
                        int priority = Integer.parseInt(priorityString); // Parse priority input

                        // Input Validation for task details
                        if (description.trim().isEmpty()) {
                            System.err.println(System.lineSeparator() + "Error: Task description cannot be empty."); // Validation error on System.err
                        } else if (priority < 1 || priority > 5) {
                            System.err.println(System.lineSeparator() + "Error: Priority must be between 1 and 5."); // Validation error on System.err
                        } else {
                            taskManager.addTask(description, priority); // Call task manager method if input is valid
                        }
                        break;

                    case 2: // View Pending Tasks
                        taskManager.viewPendingTasks(); // Call task manager method
                        break;

                    case 3: // Process Next Task
                        taskManager.processNextTask(); // Call task manager method
                        break;

                    case 4: // View All Tasks
                         taskManager.viewAllTasks(); // Call task manager method
                         break;

                    case 5: // Exit
                        System.out.println(System.lineSeparator() + "Exiting Task Management System. Goodbye!"); // Normal exit message on System.out
                        running = false; // Set flag to exit the loop
                        break;

                    default:
                        System.err.println(System.lineSeparator() + "Error: Invalid choice. Please enter a number between 1 and 5."); // Invalid menu choice on System.err
                        break;
                }
            } catch (NumberFormatException e) {
                // Catch block for handling non-integer input when expecting a number
                System.err.println(System.lineSeparator() + "Error: Invalid input format. Please enter a valid number.");
            } catch (Exception e) {
                // Generic catch block for any other unexpected exceptions
                System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }
             // Add a newline after each operation for better readability in the console
             System.out.println();
        }

        scanner.close(); // Close the scanner to release system resources
    }

    // Helper method to print the menu options to System.out
    private static void printMenu() {
        System.out.println("\nChoose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View All Tasks");
        System.out.println("5. Exit");
    }
}
