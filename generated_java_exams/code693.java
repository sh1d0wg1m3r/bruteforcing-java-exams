/*
 * Exam Question #693
 * Generated on: 2025-05-12 16:26:34
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a document processing workflow. Documents arrive, are added to a queue for processing, and are then processed one by one. Processed documents are moved to an archive. The system needs to handle user input, display system status, and manage potential processing issues.
 * 
 * **Requirements:**
 * 
 * 1.  **`Document` Class:**
 *     *   Create a class named `Document` with the following private fields:
 *         *   `int id`: A unique identifier for the document.
 *         *   `String name`: The name of the document.
 *         *   `DocumentStatus status`: The current status of the document.
 *     *   Create an `enum` called `DocumentStatus` with possible values: `PENDING`, `PROCESSING`, `ARCHIVED`, `FAILED`.
 *     *   Implement a constructor to initialize `id`, `name`, and set the initial status to `PENDING`.
 *     *   Provide public getter methods for `id`, `name`, and `status`.
 *     *   Provide a public method `setStatus(DocumentStatus status)` to change the document's status.
 *     *   Override the `toString()` method to provide a clear string representation of the document (e.g., "ID: [id], Name: [name], Status: [status]").
 * 
 * 2.  **`DocumentProcessor` Class:**
 *     *   Create a class named `DocumentProcessor` to manage the document workflow.
 *     *   Declare a private field `Queue<Document> processingQueue` to hold documents waiting to be processed. Initialize it using an appropriate `Queue` implementation (e.g., `LinkedList`).
 *     *   Declare a private field `List<Document> archivedDocuments` to hold documents that have been processed or failed. This variable **must** be declared as `List` but instantiated as `ArrayList`.
 *     *   Declare a private field `int nextDocumentId` initialized to 1, used to assign unique IDs to new documents.
 *     *   Implement a public method `addDocument(String name)`:
 *         *   Creates a new `Document` object with the next available ID and the given name.
 *         *   Adds the new document to the `processingQueue`.
 *         *   Prints a confirmation message to `System.out`.
 *     *   Implement a public method `processNextDocument()`:
 *         *   Attempts to remove the head of the `processingQueue`.
 *         *   If the queue is empty, print an error message to `System.err` and return.
 *         *   If a document is retrieved:
 *             *   Set its status to `PROCESSING`.
 *             *   **Simulate Processing:** Implement a simple simulation of processing. You can, for example, use `Math.random()` to simulate a processing failure with a 20% chance.
 *             *   If processing is simulated as successful: Set status to `ARCHIVED`. Print a success message to `System.out`. Add the document to `archivedDocuments`.
 *             *   If processing is simulated as failed: Set status to `FAILED`. Print a failure message to `System.err`. Add the document to `archivedDocuments`.
 *     *   Implement a public method `viewProcessingQueue()`:
 *         *   Print a header "--- Processing Queue ---" to `System.out`.
 *         *   Iterate through the `processingQueue` and print each document's `toString()` representation to `System.out`.
 *         *   If the queue is empty, print "(Queue is empty)" to `System.out`.
 *         *   Print a footer "------------------------" to `System.out`.
 *     *   Implement a public method `viewArchivedDocuments()`:
 *         *   Print a header "--- Archived Documents ---" to `System.out`.
 *         *   Iterate through the `archivedDocuments` list and print each document's `toString()` representation to `System.out`.
 *         *   If the archive is empty, print "(Archive is empty)" to `System.out`.
 *         *   Print a footer "--------------------------" to `System.out`.
 * 
 * 3.  **Main Application (`Main` class):**
 *     *   Create a `main` method to run the application.
 *     *   Create instances of `Scanner` (for user input) and `DocumentProcessor`.
 *     *   Implement a menu-driven interface using a `while` loop that continues until the user chooses to exit.
 *     *   The menu options should be:
 *         1.  Add New Document
 *         2.  Process Next Document
 *         3.  View Processing Queue
 *         4.  View Archived Documents
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement robust exception handling:
 *         *   Use a `try-catch` block around the user input reading (`scanner.nextInt()`) to catch `InputMismatchException` if the user enters non-integer input. Print an error message to `System.err` and clear the invalid input from the scanner buffer.
 *         *   Consider placing a `try-catch` block around the call to `processNextDocument()` if your processing simulation might throw an exception (though the boolean/random approach is simpler for this task and might not require it, ensure overall class-wide handling is present). A general `try-catch(Exception e)` around the main loop or within the switch cases is acceptable for demonstrating class-wide handling.
 *     *   Use `System.out` for the menu and standard output.
 *     *   Use `System.err` for error messages (invalid input, processing errors, queue empty).
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Include comments where necessary to explain logic.
 *     *   Implement basic input validation (e.g., for menu choice).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform the requested action, printing relevant output or error messages. The output should clearly show the state of the queue and archive when viewed.
 * 
 * ```
 * --- Document Processing System Menu ---
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Archived Documents
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Followed by output based on the choice, e.g.:
 * 
 * ```
 * Enter document name: Report_Q3
 * Document 'Report_Q3' (ID: 1) added to the queue.
 * 
 * --- Processing Queue ---
 * ID: 1, Name: Report_Q3, Status: PENDING
 * ------------------------
 * 
 * Processing document ID: 1...
 * Document ID: 1 processed successfully and archived.
 * 
 * --- Archived Documents ---
 * ID: 1, Name: Report_Q3, Status: ARCHIVED
 * --------------------------
 * ```
 * 
 * Or in case of error/failure:
 * 
 * ```
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * 
 * Processing document ID: 2...
 * Error processing document ID: 2. Status set to FAILED.
 * ```
 * 
 * ---
 * 
 * **Assessment:**
 * 
 * Your solution will be assessed on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Implementation of the specified classes and methods.
 * *   Correct logic for adding, processing, and archiving documents.
 * *   Effective use of `try-catch` for exception handling.
 * *   Adherence to best practices (encapsulation, naming, comments, validation).
 * *   Clarity and correctness of output.
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`DocumentStatus.java`, `Document.java`, `DocumentProcessor.java`, `Main.java`) in a single block.
 *
 * EXPLANATION:
 * This solution implements the requested Document Processing System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`DocumentStatus` Enum:** Defines the possible states a document can be in, providing type safety and readability compared to using simple integers or strings for status.
 * 2.  **`Document` Class:**
 *     *   Encapsulates document data (`id`, `name`, `status`) using private fields.
 *     *   Provides public getters to access the data safely.
 *     *   Includes a setter for `status` as it's the only field expected to change after creation.
 *     *   The `toString()` method provides a convenient way to display document information.
 * 3.  **`DocumentProcessor` Class:**
 *     *   Manages the core logic of the system.
 *     *   Uses a `Queue<Document>` (`LinkedList` implementation) for the `processingQueue`, correctly representing items waiting in line to be processed in FIFO (First-In, First-Out) order. `offer()` is used for adding, `poll()` for removing, which are standard Queue operations.
 *     *   Uses a `List<Document>` declared as `List` but instantiated as `ArrayList` for `archivedDocuments`. This demonstrates using the interface type for flexibility while using a concrete implementation (`ArrayList`) which is suitable for storing and iterating over processed items.
 *     *   `addDocument` creates a new `Document` and adds it to the queue using `offer()`.
 *     *   `processNextDocument` uses `poll()` to retrieve and remove the next document. It checks if the queue is empty and prints an error to `System.err` if so. It simulates processing with a random chance of failure and updates the document's status accordingly (`ARCHIVED` or `FAILED`). Both successful and failed documents are added to the `archivedDocuments` list. `System.out` is used for success messages, and `System.err` for processing failure messages.
 *     *   `viewProcessingQueue` and `viewArchivedDocuments` iterate through their respective collections (Queue and List) and print the document details to `System.out`. They include checks for empty collections.
 * 4.  **`Main` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes `Scanner` for reading console input and `DocumentProcessor` to handle the system logic.
 *     *   The main application loop runs until the user chooses to exit (`running = false`).
 *     *   `printMenu()` is a helper method to display the options to `System.out`.
 *     *   A `try-catch` block is used around the `scanner.nextInt()` call within the loop. This is crucial for handling `InputMismatchException` if the user types text instead of a number for the menu choice. The `catch` block prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *     *   A `switch` statement efficiently handles the different menu options, calling the appropriate methods in the `DocumentProcessor`.
 *     *   A general `catch(Exception e)` is included within the loop's `try` block. This demonstrates class-wide exception handling, catching any other unexpected runtime errors that might occur within the loop's execution (though the specific logic here is designed to handle most expected cases, this provides a safety net). The error message is printed to `System.err`.
 *     *   `System.out` is used for the menu, prompts, successful operations, and viewing lists.
 *     *   `System.err` is used for error messages related to invalid input, empty queue, and processing failures, clearly separating errors from standard output.
 *     *   The `Scanner` is closed when the application exits to release system resources.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical simulation, following good object-oriented design principles and error handling practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random; // Needed for processing simulation

// Enum for Document Status
enum DocumentStatus {
    PENDING,
    PROCESSING,
    ARCHIVED,
    FAILED
}

// Class representing a Document
class Document {
    private int id;
    private String name;
    private DocumentStatus status;

    // Constructor
    public Document(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = DocumentStatus.PENDING; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public DocumentStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(DocumentStatus status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Status: " + status;
    }
}

// Class managing the document processing workflow
class DocumentProcessor {
    // Use Queue for documents waiting processing
    private Queue<Document> processingQueue;
    // Use List (specifically ArrayList) for processed/failed documents
    private List<Document> archivedDocuments;
    private int nextDocumentId; // To assign unique IDs
    private Random random; // For simulating processing failure

    // Constructor
    public DocumentProcessor() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.archivedDocuments = new ArrayList<>(); // Declared as List, instantiated as ArrayList
        this.nextDocumentId = 1;
        this.random = new Random(); // Initialize Random
    }

    /**
     * Adds a new document to the processing queue.
     * @param name The name of the document.
     */
    public void addDocument(String name) {
        Document newDoc = new Document(nextDocumentId++, name);
        processingQueue.offer(newDoc); // offer is preferred over add for queues
        System.out.println("Document '" + name + "' (ID: " + newDoc.getId() + ") added to the queue.");
    }

    /**
     * Processes the next document in the queue.
     * Moves document from queue to archive after processing simulation.
     */
    public void processNextDocument() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Document docToProcess = processingQueue.poll();

        if (docToProcess == null) {
            System.err.println("Error: Processing queue is empty. No documents to process.");
            return; // Exit the method if queue is empty
        }

        System.out.println("Processing document ID: " + docToProcess.getId() + "...");
        docToProcess.setStatus(DocumentStatus.PROCESSING);

        // Simulate processing: 20% chance of failure
        boolean processingSuccessful = random.nextDouble() > 0.2; // 80% success rate

        if (processingSuccessful) {
            docToProcess.setStatus(DocumentStatus.ARCHIVED);
            archivedDocuments.add(docToProcess); // Add to archive list
            System.out.println("Document ID: " + docToProcess.getId() + " processed successfully and archived.");
        } else {
            docToProcess.setStatus(DocumentStatus.FAILED);
            archivedDocuments.add(docToProcess); // Add to archive list even if failed
            System.err.println("Error processing document ID: " + docToProcess.getId() + ". Status set to FAILED.");
        }
    }

    /**
     * Displays the current documents in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing elements
            for (Document doc : processingQueue) {
                System.out.println(doc);
            }
        }
        System.out.println("------------------------\n");
    }

    /**
     * Displays the documents in the archive.
     */
    public void viewArchivedDocuments() {
        System.out.println("\n--- Archived Documents ---");
        if (archivedDocuments.isEmpty()) {
            System.out.println("(Archive is empty)");
        } else {
            for (Document doc : archivedDocuments) {
                System.out.println(doc);
            }
        }
        System.out.println("--------------------------\n");
    }
}

// Main application class
public class Main {

    public static void main(String[] args) {
        // Scanner for user input
        Scanner scanner = new Scanner(System.in);
        // DocumentProcessor instance
        DocumentProcessor processor = new DocumentProcessor();
        boolean running = true;

        System.out.println("--- Document Processing System ---");

        // Main application loop
        while (running) {
            printMenu();

            int choice = -1; // Default invalid choice

            // Class-wide exception handling for input
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter document name: ");
                        String docName = scanner.nextLine();
                        if (docName == null || docName.trim().isEmpty()) {
                            System.err.println("Error: Document name cannot be empty.");
                        } else {
                             processor.addDocument(docName.trim());
                        }
                        break;
                    case 2:
                        // processNextDocument handles its own empty queue error via System.err
                        processor.processNextDocument();
                        break;
                    case 3:
                        processor.viewProcessingQueue();
                        break;
                    case 4:
                        processor.viewArchivedDocuments();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Document Processing System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer input outside the defined range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }

            } catch (InputMismatchException e) {
                // Catch non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                // Consume the invalid input to prevent infinite loop
                scanner.next();
            } catch (Exception e) {
                // General catch-all for any other unexpected errors in the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Document Processing System Menu ---");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Archived Documents");
        System.out.println("5. Exit");
    }
}
