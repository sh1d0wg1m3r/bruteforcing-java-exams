/*
 * Exam Question #404
 * Generated on: 2025-05-11 23:06:17
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a command-line application to manage tasks for a small team. The system should allow users to add new tasks, process the next task waiting to be done, view pending tasks, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a class named `Task` with private fields for a unique integer `id` and a `String description`. Include a constructor, public getter methods for both fields, and override the `toString()` method for easy printing. Tasks should be assigned sequential IDs starting from 1.
 * 2.  **Task Management Logic:** Create a class named `TaskProcessor` that manages the tasks. This class should internally use:
 *     *   A `java.util.Queue<Task>` to store tasks that are currently pending (waiting to be processed). Tasks should be processed in the order they were added (FIFO - First-In, First-Out).
 *     *   A `java.util.List<Task>` to store tasks that have been completed.
 * 3.  **Functionality:** The `TaskProcessor` class (or a separate main class) should provide the following operations accessible via a command-line menu:
 *     *   **Add New Task:** Prompt the user for a task description. Create a new `Task` object with the next available ID and add it to the pending tasks queue.
 *     *   **Process Next Task:** Remove the task at the head of the pending tasks queue and add it to the completed tasks list. If the pending queue is empty, display an appropriate error message.
 *     *   **View Pending Tasks:** Display all tasks currently in the pending queue, including their ID and description. If the queue is empty, display a message indicating so.
 *     *   **View Completed Tasks:** Display all tasks in the completed tasks list, including their ID and description. If the list is empty, display a message indicating so.
 *     *   **Exit:** Terminate the application.
 * 4.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` to read user input. Display a menu with options for each function.
 * 5.  **Flow Control:** Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, empty task description, trying to process when no tasks are pending, invalid input type).
 * 7.  **Error Handling:**
 *     *   Implement input validation (e.g., ensure task description is not empty, handle non-integer menu input).
 *     *   Use `try-catch` blocks for exception handling. Include a broad `try-catch(Exception e)` block around the main application loop to demonstrate "class-wide" handling of unexpected errors, printing an error message and the stack trace to `System.err` before exiting. Also, handle specific input exceptions (like `InputMismatchException` from `Scanner`).
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments to explain the code.
 *     *   Ensure resources like `Scanner` are properly closed.
 *     *   When methods in `TaskProcessor` return collections (like pending or completed tasks), they should return them typed as the `java.util.List` interface, potentially returning a copy of the internal collection to prevent external modification.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting numerical input for choices, and performing the requested operations. Output should clearly distinguish between normal information (`System.out`) and error messages (`System.err`).
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * -------------------------
 * Enter your choice: <user input>
 * ... (output based on choice)
 * ```
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * *   Structure your code logically into appropriate classes. A single file solution containing all classes is acceptable for this exam.
 *
 * EXPLANATION:
 * The solution implements a simple Task Management System using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task, holding a unique `id` and a `description`. It follows encapsulation principles with private fields and public getters. The `toString()` method is overridden for convenient printing of task details.
 * 2.  **`TaskProcessor` Class:** This is the core class managing the task collections and operations.
 *     *   **Collections:** It uses a `java.util.Queue<Task>` named `pendingTasks` implemented by `java.util.LinkedList`. The `Queue` interface naturally supports the FIFO requirement for processing tasks. It uses a `java.util.List<Task>` named `completedTasks` implemented by `java.util.ArrayList` to store the history of processed tasks.
 *     *   **`addTask(String description)`:** Creates a new `Task` with an auto-incrementing ID (`nextTaskId`) and adds it to the `pendingTasks` queue using `offer()`. It includes input validation to ensure the description is not empty, throwing an `IllegalArgumentException` if it is.
 *     *   **`processNextTask()`:** Removes and returns the head of the `pendingTasks` queue using `poll()`. If the queue is empty, `poll()` returns `null`, which is used to indicate that no task was processed. If a task is processed, it's added to the `completedTasks` list.
 *     *   **`getPendingTasks()` and `getCompletedTasks()`:** These methods return the task collections. Crucially, they are typed to return `java.util.List<Task>`, fulfilling the requirement to use the `List` interface for return types. They return *new* `ArrayList` instances containing the elements from the internal collections. This is a good practice to prevent external code from modifying the internal state of the `TaskProcessor`'s collections directly.
 * 3.  **Main Application Logic (`main` method within `TaskProcessor`):**
 *     *   An instance of `TaskProcessor` and `Scanner` are created.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `printMenu()` method displays the available options using `System.out`.
 *     *   User input is read using `scanner.nextInt()` for the menu choice. `scanner.nextLine()` is called immediately after to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls for task descriptions.
 *     *   **Input Validation & Specific Exception Handling:** A `try-catch(InputMismatchException e)` block is used specifically around `scanner.nextInt()` to gracefully handle cases where the user enters non-integer input, printing an error message to `System.err` and consuming the invalid input before continuing the loop.
 *     *   **`switch` Statement:** The user's valid integer choice is processed using a `switch` statement, directing execution to the appropriate case (`addTask`, `processNextTask`, `view pending`, `view completed`, `exit`, or invalid choice).
 *     *   **Error Reporting:** `System.err` is used for all error conditions: invalid menu choice (default case), invalid task description (caught `IllegalArgumentException`), and attempting to process a task when the queue is empty. `System.out` is used for all normal output.
 *     *   **Class-Wide Exception Handling:** A broad `try-catch(Exception e)` block wraps the entire `while` loop. This demonstrates a form of "class-wide" handling by catching any unexpected `RuntimeException` or other `Exception` that might occur within the main application flow, preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 *     *   **Resource Management:** A `finally` block ensures that the `Scanner` resource is closed when the `try` block is exited, whether normally or due to an exception.
 * 
 * This solution effectively demonstrates the required components and best practices, including appropriate collection usage, structured control flow, robust input handling, and layered exception management (`InputMismatchException` specific catch, `IllegalArgumentException` specific catch via `addTask` method, and a general `Exception` catch for the main loop).
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "']";
    }
}

/**
 * Manages a collection of pending and completed tasks.
 * Uses a Queue for pending tasks (FIFO) and a List for completed tasks.
 * Includes the main application loop and user interaction.
 */
public class TaskProcessor {

    // Use Queue for pending tasks (FIFO order)
    private Queue<Task> pendingTasks;
    // Use List/ArrayList for completed tasks history
    private List<Task> completedTasks;
    // Counter for unique task IDs
    private int nextTaskId;

    /**
     * Constructor initializes the task collections and ID counter.
     */
    public TaskProcessor() {
        // LinkedList is a common implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public void addTask(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue (FIFO).
     * Moves the processed task to the completed tasks list.
     * @return The task that was processed, or null if the pending queue is empty.
     */
    public Task processNextTask() {
        // Check if queue is empty before attempting to process
        if (pendingTasks.isEmpty()) {
            return null; // Indicate no task was processed
        }
        Task processedTask = pendingTasks.poll(); // poll removes and returns the head
        completedTasks.add(processedTask);
        return processedTask;
    }

    /**
     * Returns a list of currently pending tasks.
     * Returns a copy to prevent external modification of the internal queue.
     * The return type is the List interface.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This uses the List interface as the return type
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of completed tasks.
     * Returns a copy to prevent external modification of the internal list.
     * The return type is the List interface.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a new ArrayList containing elements from the completed tasks list
        // This uses the List interface as the return type
        return new ArrayList<>(completedTasks);
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("-------------------------\n");
    }

    /**
     * Main method to run the Task Processor application.
     * Handles the user interaction loop and top-level exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling around the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read integer input
                    choice = scanner.nextInt();
                    // Consume the rest of the line, including the newline character
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop body and show the menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            processor.addTask(description);
                        } catch (IllegalArgumentException e) {
                            // Use System.err for validation errors
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        System.out.println("Attempting to process next task...");
                        Task processed = processor.processNextTask();
                        if (processed != null) {
                            System.out.println("Processed: " + processed); // Use System.out for success
                        } else {
                            // Use System.err for error condition (queue empty)
                            System.err.println("No pending tasks to process.");
                        }
                        break;

                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = processor.getPendingTasks(); // Get as List
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks."); // Use System.out for normal message
                        } else {
                            for (Task task : pending) {
                                System.out.println(task); // Use System.out for normal output
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 4: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = processor.getCompletedTasks(); // Get as List
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks yet."); // Use System.out for normal message
                        } else {
                            for (Task task : completed) {
                                System.out.println(task); // Use System.out for normal output
                            }
                        }
                        System.out.println("-----------------------\n");
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Processor. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        // Use System.err for invalid menu option
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions in the main loop for "class-wide" handling
            System.err.println("\nAn unexpected error occurred during application execution:");
            // Print stack trace to System.err for debugging unexpected errors
            e.printStackTrace(System.err);
            System.err.println("Application is terminating due to an unrecoverable error.");
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}
