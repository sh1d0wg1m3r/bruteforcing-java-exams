/*
 * Exam Question #508
 * Generated on: 2025-05-11 23:21:53
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Processing System
 * 
 * **Problem Description:**
 * 
 * Design and implement a console-based application simulating a basic warehouse order processing system. The system should manage a list of available products and a queue of incoming customer orders.
 * 
 * Each **Product** in the warehouse has a unique integer ID, a name (String), and a current stock quantity (integer).
 * Each **Order** consists of a list of **Order Items**. Each Order Item specifies a Product ID and the quantity of that product requested in the order.
 * 
 * The system should allow a user (simulating a warehouse manager) to interact via a menu:
 * 1.  **Add New Product:** Add a new product to the warehouse inventory with an initial stock level.
 * 2.  **Add New Order:** Create a new customer order containing one or more items and add it to the processing queue.
 * 3.  **Process Next Order:** Take the next order from the front of the queue, check if there is sufficient stock for all items in the order, and if so, deduct the stock quantities and mark the order as processed. If stock is insufficient for any item, the order remains in the queue, and an error is reported.
 * 4.  **View Warehouse Status:** Display the current stock level for all products and the number of orders currently waiting in the queue.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Requirements:**
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts and adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` (specifically `LinkedList` which implements `Queue`) to manage the incoming customer orders.
 *     *   Use `java.util.ArrayList` to store the list of available products.
 *     *   Use `java.util.List` as the type interface for the list of products and for the list of items within an order.
 * 
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and status information.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, product not found, insufficient stock, empty queue).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use loops (`while` or `for`) as appropriate for input validation and processing order items.
 * 
 * 4.  **Exception Handling:**
 *     *   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle unexpected errors during the main application loop.
 *     *   Implement specific input validation checks (e.g., for non-numeric input, negative quantities/stock, non-existent product IDs) and report errors using `System.err` *before* attempting operations that might fail.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Create separate classes for `Product`, `OrderItem`, and `Order` with private fields, public getters, and appropriate constructors (demonstrating encapsulation).
 *     *   The main application logic should reside in a separate class (e.g., `WarehouseSystem`) that manages the product list and order queue.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic or design choices.
 *     *   Ensure proper input validation and error handling as specified above.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and provide feedback based on their actions. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example Interaction Snippets:
 * 
 * ```
 * Welcome to the Warehouse Order Processing System!
 * 
 * Warehouse System Menu:
 * 1. Add New Product
 * 2. Add New Order
 * 3. Process Next Order
 * 4. View Warehouse Status
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Product ---
 * Enter product name: Laptop
 * Enter initial stock quantity: 10
 * Product added: Product{id=1, name='Laptop', stock=10}
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 1
 * --- Add New Product ---
 * Enter product name: Mouse
 * Enter initial stock quantity: 50
 * Product added: Product{id=2, name='Mouse', stock=50}
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 4
 * --- Warehouse Status ---
 * Products in Inventory:
 *   - Laptop (ID: 1, Stock: 10)
 *   - Mouse (ID: 2, Stock: 50)
 * 
 * Pending Orders in Queue: 0
 * -----------------------
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 2
 * --- Add New Order ---
 * Enter product ID for item (or 0 to finish order): 1
 * Enter quantity for product 1 (Laptop): 2
 * Added 2 of product 1 to order.
 * Enter product ID for item (or 0 to finish order): 2
 * Enter quantity for product 2 (Mouse): 5
 * Added 5 of product 2 to order.
 * Enter product ID for item (or 0 to finish order): 0
 * Order added to processing queue.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 4
 * --- Warehouse Status ---
 * Products in Inventory:
 *   - Laptop (ID: 1, Stock: 10)
 *   - Mouse (ID: 2, Stock: 50)
 * 
 * Pending Orders in Queue: 1
 *   Next order to process: Order{items=[OrderItem{productId=1, quantity=2}, OrderItem{productId=2, quantity=5}]}
 * -----------------------
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 3
 * --- Processing Next Order ---
 * Attempting to process order: Order{items=[OrderItem{productId=1, quantity=2}, OrderItem{productId=2, quantity=5}]}
 * Processing order: Order{items=[OrderItem{productId=1, quantity=2}, OrderItem{productId=2, quantity=5}]}
 *   - Deducted 2 of product 1 (Laptop). Remaining stock: 8
 *   - Deducted 5 of product 2 (Mouse). Remaining stock: 45
 * Order successfully processed.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 3
 * --- Processing Next Order ---
 * System.err: Order queue is empty. Nothing to process.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 2
 * --- Add New Order ---
 * Enter product ID for item (or 0 to finish order): 1
 * Enter quantity for product 1 (Laptop): 10
 * Added 10 of product 1 to order.
 * Enter product ID for item (or 0 to finish order): 0
 * Order added to processing queue.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 3
 * --- Processing Next Order ---
 * Attempting to process order: Order{items=[OrderItem{productId=1, quantity=10}]}
 * System.err: Error: Insufficient stock for product 1 (Laptop). Required: 10, Available: 8. Cannot process order.
 * System.err: Order could not be processed due to insufficient stock or missing product. Leaving order in queue.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: invalid
 * System.err: Invalid input. Please enter a number between 1 and 5.
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Warehouse System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Warehouse System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your code should compile and run, fulfilling all the specified requirements.
 *
 * EXPLANATION:
 * This solution implements a `WarehouseSystem` class that manages products and orders, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Data Structures:**
 *     *   `java.util.Queue`: The `orderQueue` is declared as a `Queue<Order>` and instantiated as a `LinkedList<Order>`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing methods like `offer()` to add to the tail and `poll()`/`peek()` to interact with the head, which are suitable for a processing queue.
 *     *   `java.util.ArrayList`: The `products` list is declared as a `List<Product>` and instantiated as an `ArrayList<Product>`. `ArrayList` is suitable here for storing and accessing products by iterating or potentially searching (though a `HashMap` might be more efficient for ID-based lookup in a larger system, `ArrayList` fulfills the requirement). The `items` list within the `Order` class also uses `ArrayList` via the `List` interface.
 *     *   `java.util.List interface`: The `products` field and the return type of `Order.getItems()` are typed as `List`, demonstrating the use of the interface rather than the concrete implementation (`ArrayList`).
 * 
 * 2.  **Input/Output:**
 *     *   `java.util.Scanner`: A `Scanner` object is used to read user input from `System.in`.
 *     *   `System.out`: Used for printing the menu, user prompts, confirmation messages (e.g., "Product added:", "Order added:", "Order successfully processed"), and the status report.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, non-numeric input errors, product not found errors, insufficient stock errors, and messages when the order queue is empty. This directs error output to the standard error stream, which is good practice.
 * 
 * 3.  **Control Flow:**
 *     *   `switch` statement: The `run()` method uses a `switch` statement based on the user's menu choice to dispatch to the appropriate method (`addProduct`, `addOrder`, etc.).
 *     *   Loops: `while` loops are used for the main application loop (`while(running)`), for input validation (e.g., ensuring stock/quantity is non-negative), and for iterating through order items during order creation and processing. `for` loops are used to iterate through the list of products for status display or lookup.
 * 
 * 4.  **Exception Handling:**
 *     *   **Class-wide `try-catch`:** The main `while` loop in the `run()` method is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unhandled runtime exception that might occur within the core application flow and printing an error message to `System.err`. A `finally` block is used to ensure the `Scanner` is closed regardless of whether an exception occurs or the loop finishes normally.
 *     *   **Specific Input Validation/Handling:** `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls within loops (`run`, `addProduct`, `addOrder`) to specifically catch cases where the user enters non-integer text when an integer is expected. This allows the program to print an informative error to `System.err`, consume the invalid input token (`scanner.next()`), and continue or re-prompt, preventing crashes or infinite loops caused by invalid input. Other specific error conditions (like negative stock, non-existent product ID, insufficient stock, empty queue) are checked with `if` statements *before* attempting operations and reported using `System.err`.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Separate classes (`Product`, `OrderItem`, `Order`) are defined with private fields (`id`, `name`, `stock`, `productId`, `quantity`, `items`) and public getters, demonstrating encapsulation.
 *     *   The `WarehouseSystem` class acts as the controller, holding the data structures (`products`, `orderQueue`) and containing the methods for the system's operations.
 *     *   Methods like `Product.updateStock` encapsulate the logic for modifying the product's state.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names are used for classes, fields, methods, and variables (e.g., `orderQueue`, `processOrder`, `sufficientStock`, `initialStock`).
 *     *   Comments are included to explain the purpose of classes, methods, and specific code sections, including explanations for input validation loops and error handling.
 *     *   Input validation is performed before attempting to use input values (checking ranges, types, existence of products).
 *     *   Error messages are informative and directed to `System.err`.
 *     *   The code is structured logically into methods and classes, making it readable and maintainable. The consumption of the newline character after `nextInt()` (`scanner.nextLine()`) is correctly handled to prevent issues with subsequent line-based input. Defensive copies are used for the `Order`'s item list in the constructor and getter to protect the internal state.
 * 
 * This solution effectively integrates all required Java components and best practices into a cohesive, practical application, demonstrating advanced understanding of Java programming.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product in the warehouse inventory.
 * Demonstrates encapsulation with private fields and public getters.
 */
class Product {
    private int id;
    private String name;
    private int stock;

    /**
     * Constructs a new Product.
     * @param id The unique product ID.
     * @param name The name of the product.
     * @param stock The initial stock quantity.
     */
    public Product(int id, String name, int stock) {
        this.id = id;
        this.name = name;
        this.stock = stock;
    }

    // Public getters for accessing product details
    public int getId() { return id; }
    public String getName() { return name; }
    public int getStock() { return stock; }

    /**
     * Updates the stock quantity.
     * Encapsulates the stock modification logic.
     * @param quantityChange The amount to change stock by (positive for add, negative for deduct).
     * @return true if stock was updated successfully, false if change would result in negative stock.
     */
    public boolean updateStock(int quantityChange) {
        if (this.stock + quantityChange < 0) {
            return false; // Not enough stock for deduction
        }
        this.stock += quantityChange;
        return true;
    }

    /**
     * Provides a string representation of the Product.
     */
    @Override
    public String toString() {
        return "Product{" + "id=" + id + ", name='" + name + '\'' + ", stock=" + stock + '}';
    }
}

/**
 * Represents a single item within an order.
 */
class OrderItem {
    private int productId;
    private int quantity;

    /**
     * Constructs a new OrderItem.
     * @param productId The ID of the product being ordered.
     * @param quantity The quantity of the product ordered.
     */
    public OrderItem(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    // Public getters for accessing order item details
    public int getProductId() { return productId; }
    public int getQuantity() { return quantity; }

    /**
     * Provides a string representation of the OrderItem.
     */
    @Override
    public String toString() {
        return "OrderItem{" + "productId=" + productId + ", quantity=" + quantity + '}';
    }
}

/**
 * Represents a customer order containing multiple items.
 * Uses the List interface for storing items.
 */
class Order {
    private List<OrderItem> items; // Using List interface, instantiated with ArrayList

    /**
     * Constructs a new Order.
     * @param items A list of OrderItems included in the order.
     */
    public Order(List<OrderItem> items) {
        // Create a defensive copy to prevent external modification of the order's item list
        this.items = new ArrayList<>(items); // ArrayList implements List
    }

    /**
     * Returns a copy of the list of order items.
     * @return A new ArrayList containing the order items.
     */
    public List<OrderItem> getItems() {
        // Return a defensive copy to prevent external modification
        return new ArrayList<>(items); // ArrayList implements List
    }

    /**
     * Provides a string representation of the Order.
     */
    @Override
    public String toString() {
        return "Order{" + "items=" + items + '}';
    }
}

/**
 * The main class for the Warehouse Order Processing System.
 * Manages products, orders, and user interaction.
 * Demonstrates the use of Queue, ArrayList, List, Scanner, Switch, System.out/err, and try-catch.
 */
public class WarehouseSystem {
    // Using List interface for products, implemented by ArrayList
    private List<Product> products;
    // Using Queue interface for orders, implemented by LinkedList
    private Queue<Order> orderQueue;
    private Scanner scanner;
    private int nextProductId = 1; // Simple auto-incrementing ID for new products

    /**
     * Constructs the WarehouseSystem, initializing data structures and scanner.
     */
    public WarehouseSystem() {
        this.products = new ArrayList<>(); // Instantiate List with ArrayList
        this.orderQueue = new LinkedList<>(); // Instantiate Queue with LinkedList
        this.scanner = new Scanner(System.in);
    }

    /**
     * Finds a product by its ID.
     * @param productId The ID of the product to find.
     * @return The Product object if found, otherwise null.
     */
    private Product findProductById(int productId) {
        for (Product product : products) {
            if (product.getId() == productId) {
                return product;
            }
        }
        return null; // Product not found
    }

    /**
     * Adds a new product to the warehouse inventory.
     * Includes input validation and error handling using System.err.
     */
    public void addProduct() {
        System.out.println("\n--- Add New Product ---");
        try {
            System.out.print("Enter product name: ");
            String name = scanner.nextLine(); // Read the full line for name

            int initialStock = -1;
            // Input validation loop for stock quantity
            while (initialStock < 0) {
                System.out.print("Enter initial stock quantity: ");
                try {
                    initialStock = scanner.nextInt();
                    if (initialStock < 0) {
                        System.err.println("Stock quantity cannot be negative. Please try again.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number for stock quantity.");
                    scanner.next(); // Consume the invalid input token
                    initialStock = -1; // Keep initialStock invalid to continue loop
                } finally {
                    // Consume the newline character left by scanner.nextInt()
                    if (scanner.hasNextLine()) {
                        scanner.nextLine();
                    }
                }
            }

            // Generate a simple unique product ID
            int productId = nextProductId++;
            Product newProduct = new Product(productId, name, initialStock);
            products.add(newProduct); // Add to ArrayList (using List interface)
            System.out.println("Product added: " + newProduct);

        } catch (Exception e) {
            // Catch any unexpected error during product addition
            System.err.println("An unexpected error occurred while adding product: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging unexpected exceptions
        }
    }

    /**
     * Adds a new order to the processing queue.
     * Includes input validation and error handling using System.err.
     * Uses ArrayList to build the list of order items before creating the Order object.
     */
    public void addOrder() {
        System.out.println("\n--- Add New Order ---");
        // Use ArrayList to collect items before creating the final Order object
        List<OrderItem> items = new ArrayList<>();
        boolean addingItems = true;

        try {
            while (addingItems) {
                System.out.print("Enter product ID for item (or 0 to finish order): ");
                int productId = -1;
                try {
                    productId = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Handle non-integer input for product ID
                    System.err.println("Invalid input. Please enter a number for product ID.");
                    scanner.next(); // Consume invalid input
                    continue; // Skip to the next iteration of the while loop
                } finally {
                     // Consume the newline character left by scanner.nextInt()
                     if (scanner.hasNextLine()) {
                         scanner.nextLine();
                     }
                }

                if (productId == 0) {
                    addingItems = false; // User finished adding items
                    break;
                }

                // Validate if product exists
                Product product = findProductById(productId);
                if (product == null) {
                    System.err.println("Product with ID " + productId + " not found. Cannot add to order.");
                    continue; // Skip to the next item input
                }

                int quantity = -1;
                // Input validation loop for item quantity
                while (quantity <= 0) {
                     System.out.print("Enter quantity for product " + productId + " (" + product.getName() + "): ");
                     try {
                        quantity = scanner.nextInt();
                        if (quantity <= 0) {
                            System.err.println("Quantity must be positive. Please try again.");
                        }
                     } catch (InputMismatchException e) {
                         // Handle non-integer input for quantity
                         System.err.println("Invalid input. Please enter a number for quantity.");
                         scanner.next(); // Consume invalid input
                         quantity = -1; // Keep quantity invalid to continue loop
                     } finally {
                         // Consume the newline character left by scanner.nextInt()
                         if (scanner.hasNextLine()) {
                             scanner.nextLine();
                         }
                     }
                }

                items.add(new OrderItem(productId, quantity)); // Add OrderItem to ArrayList
                System.out.println("Added " + quantity + " of product " + productId + " to order.");
            }

            // Only add the order to the queue if items were added
            if (!items.isEmpty()) {
                Order newOrder = new Order(items);
                orderQueue.offer(newOrder); // Add the new Order to the end of the Queue
                System.out.println("Order added to processing queue.");
            } else {
                 System.out.println("No items added. Order cancelled.");
            }

        } catch (Exception e) {
             // Catch any unexpected error during order addition
            System.err.println("An unexpected error occurred while adding order: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging unexpected exceptions
        }
    }

    /**
     * Processes the next order from the queue.
     * Checks stock availability for all items before processing.
     * Uses System.err for reporting errors like empty queue or insufficient stock.
     */
    public void processOrder() {
        System.out.println("\n--- Processing Next Order ---");
        try {
            // Check if the queue is empty using the Queue interface method
            if (orderQueue.isEmpty()) {
                System.err.println("Order queue is empty. Nothing to process.");
                return;
            }

            // Use peek() to view the head of the queue without removing it yet
            Order orderToProcess = orderQueue.peek();
            System.out.println("Attempting to process order: " + orderToProcess);

            // --- Stock Availability Check ---
            boolean sufficientStock = true;
            // Iterate through items using the List interface returned by getItems()
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProductId());

                // Check if product exists in inventory
                if (product == null) {
                    System.err.println("Error: Product ID " + item.getProductId() + " in order not found in inventory. Cannot process.");
                    sufficientStock = false;
                    break; // Cannot process this order if any product is missing
                }

                // Check if sufficient stock is available
                if (product.getStock() < item.getQuantity()) {
                    System.err.println("Error: Insufficient stock for product " + product.getId() + " (" + product.getName() + "). Required: " + item.getQuantity() + ", Available: " + product.getStock() + ". Cannot process order.");
                    sufficientStock = false;
                    break; // Cannot process this order if stock is insufficient for any item
                }
            }

            // --- Process Order if Stock is Sufficient ---
            if (sufficientStock) {
                // Use poll() to remove the order from the head of the queue now that stock is confirmed
                orderToProcess = orderQueue.poll();
                System.out.println("Processing order: " + orderToProcess);

                // Deduct stock for each item in the order
                for (OrderItem item : orderToProcess.getItems()) {
                    Product product = findProductById(item.getProductId()); // Product is guaranteed to exist here based on checks above
                    // Update stock using the encapsulated method
                    product.updateStock(-item.getQuantity()); // Deduct quantity (negative change)
                    System.out.println("  - Deducted " + item.getQuantity() + " of product " + product.getId() + " (" + product.getName() + "). Remaining stock: " + product.getStock());
                }
                System.out.println("Order successfully processed.");
            } else {
                // If stock was insufficient or product missing, report error and leave order in queue
                System.err.println("Order could not be processed due to insufficient stock or missing product. Leaving order in queue.");
            }

        } catch (Exception e) {
            // Catch any unexpected error during order processing
            System.err.println("An unexpected error occurred while processing order: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging unexpected exceptions
        }
    }

    /**
     * Displays the current status of the warehouse inventory and order queue.
     * Uses System.out for output.
     */
    public void viewStatus() {
        System.out.println("\n--- Warehouse Status ---");
        System.out.println("Products in Inventory:");
        // Iterate through the list of products
        if (products.isEmpty()) {
            System.out.println("  No products available.");
        } else {
            for (Product product : products) {
                System.out.println("  - " + product.getName() + " (ID: " + product.getId() + ", Stock: " + product.getStock() + ")");
            }
        }

        // Display the number of pending orders in the queue
        System.out.println("\nPending Orders in Queue: " + orderQueue.size());
        // Display the next order to be processed using peek() if queue is not empty
        if (!orderQueue.isEmpty()) {
            System.out.println("  Next order to process: " + orderQueue.peek());
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     * Uses System.out.
     */
    private void displayMenu() {
        System.out.println("\nWarehouse System Menu:");
        System.out.println("1. Add New Product");
        System.out.println("2. Add New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Warehouse Status");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu selection.
     * Implements the main switch statement and class-wide try-catch.
     */
    public void run() {
        boolean running = true;
        System.out.println("Welcome to the Warehouse Order Processing System!");

        // --- Class-wide exception handling for the main application loop ---
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Initialize choice to an invalid value
                try {
                    // Attempt to read the integer choice from the user
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    scanner.next(); // Consume the invalid input token to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show the menu again
                } finally {
                     // Always consume the newline character left by scanner.nextInt()
                     // This is crucial before the next scanner.nextLine() call in other methods
                      if (scanner.hasNextLine()) {
                         scanner.nextLine();
                      }
                }


                // --- Switch statement for flow control based on user choice ---
                switch (choice) {
                    case 1:
                        addProduct();
                        break;
                    case 2:
                        addOrder();
                        break;
                    case 3:
                        processOrder();
                        break;
                    case 4:
                        viewStatus();
                        break;
                    case 5:
                        running = false; // Set running to false to exit the loop
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the expected range 1-5
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // --- Catch any unexpected exception that might occur during the main loop ---
            // This serves as the "class-wide" exception handling for the core application flow.
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging critical errors
        } finally {
            // --- Ensure resources are cleaned up ---
            // The finally block guarantees this code runs whether an exception occurred or not.
            if (scanner != null) {
                scanner.close(); // Close the scanner resource
            }
            System.out.println("Scanner closed.");
        }
    }

    /**
     * The main method to start the WarehouseSystem application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run(); // Start the main application loop
    }
}
