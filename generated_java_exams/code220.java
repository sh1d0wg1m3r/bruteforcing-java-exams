/*
 * Exam Question #220
 * Generated on: 2025-05-11 22:34:10
 * Generated by: Account 5
 * 
 * QUESTION:
 * Subject: Advanced Java Programming
 * Task: Support Request Management System
 * 
 * You are tasked with developing a simple command-line application to manage technical support requests. The system should allow users to add new requests, view pending requests, process the next request, and view completed requests.
 * 
 * Each support request should have a unique ID, a description, a priority (High, Medium, or Low), and a status (Pending or Processed).
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending support requests. Requests should be processed in a FIFO manner (First-In, First-Out) from this queue using the appropriate `Queue` methods.
 *     *   Use a `java.util.ArrayList` to store processed support requests.
 *     *   Declare the list of processed requests using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console for menu choices and request details.
 *     *   Present a clear menu with options: 1. Add Request, 2. View Pending, 3. Process Next, 4. View Processed, 5. Exit.
 *     *   Use a `switch` statement to handle the user's menu selection, directing execution to the appropriate functionality.
 * 
 * 3.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and lists of requests (pending and processed).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue, unexpected errors).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using a single `try-catch` block that wraps the main application loop or core logic within your main class to catch unexpected runtime errors.
 *     *   Include specific input validation:
 *         *   Validate that the menu choice is a valid integer within the acceptable range. Handle non-integer input gracefully.
 *         *   Validate that the entered priority for a new request is one of the valid options ("HIGH", "MEDIUM", "LOW" - case-insensitive validation is recommended). Re-prompt or handle invalid priority input.
 *     *   Handle scenarios where the user attempts to process a request when the pending queue is empty by printing an informative message to `System.err`.
 *     *   Handle scenarios where the user views pending or processed lists when they are empty by printing an informative message to `System.out`.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Create a `SupportRequest` class with private fields (ID, description, priority, status) and public methods (constructor, getters, and a setter for status). Use appropriate enums for Priority and Status. Implement a `toString()` method for easy printing. Ensure unique IDs are generated for each request.
 *     *   Create a main class (e.g., `SupportSystem`) that manages the `Queue` and `List` data structures, contains the main application logic (menu, user interaction, method calls), and includes the `main` method to start the application.
 *     *   Apply encapsulation principles by making fields private and accessing them via public methods.
 * 
 * 6.  **Code Quality:**
 *     *   Use meaningful variable, method, and class names that clearly indicate their purpose.
 *     *   Include comments where necessary to explain the role of different parts of the code, especially the use of required components and error handling logic.
 *     *   Ensure the `Scanner` resource is properly closed when the application exits or terminates due to an error.
 * 
 * **Expected Behavior:**
 * 
 * *   Upon execution, the program should display the main menu.
 * *   The user interacts by entering a number corresponding to a menu option.
 * *   **Add Request (1):** Prompts for description and priority. Validates priority input. Creates a `SupportRequest` object with a unique ID and PENDING status, and adds it to the pending queue. Prints a success message with the request details to `System.out`. Handles invalid priority input with an error message to `System.err`.
 * *   **View Pending (2):** Iterates through and prints details of all requests currently in the pending queue to `System.out`. Prints a message to `System.out` if the queue is empty.
 * *   **Process Next (3):** Removes the oldest request from the pending queue (head of the queue), updates its status to PROCESSED, and adds it to the processed list. Prints a success message with the processed request details to `System.out`. If the pending queue is empty, prints an error message to `System.err`.
 * *   **View Processed (4):** Iterates through and prints details of all requests in the processed list to `System.out`. Prints a message to `System.out` if the list is empty.
 * *   **Exit (5):** Prints a goodbye message to `System.out` and terminates the program.
 * *   **Invalid Choice:** If the user enters input that is not a valid menu number, an error message is printed to `System.err`, and the menu is redisplayed.
 * *   **Unexpected Errors:** Any unhandled exceptions during the program execution should be caught by the class-wide `try-catch` block, printing a generic error message to `System.err`.
 * 
 * Implement the `SupportRequest` and `SupportSystem` classes (you may place them in separate files or the same file for the exam) to fulfill these requirements.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Support Request Management System, demonstrating the required advanced Java concepts and best practices.
 * 
 * 1.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `java.util.Queue<SupportRequest>` named `pendingRequests` is used to hold requests awaiting processing. A `LinkedList` is chosen as the concrete implementation because it efficiently implements the `Queue` interface (allowing FIFO operations like `offer` to add and `poll` to remove from the head). The problem specifically requires using `java.util.Queue`.
 *     *   A `java.util.List<SupportRequest>` named `processedRequests` is used to store requests after they have been processed. An `ArrayList` is chosen as the concrete implementation. The variable is correctly declared using the `List` interface type, which is good practice as it allows flexibility to change the implementation later if needed (e.g., to a `LinkedList` or `Vector`) without altering the code that interacts with the list. The problem requires using both `java.util.List` and `java.util.ArrayList`.
 * 
 * 2.  **User Interaction (`Scanner`, `switch`):**
 *     *   A `java.util.Scanner` object reads input from `System.in` to get the user's menu choices and details for new requests.
 *     *   A `switch` statement in the `start()` method directs the program flow based on the integer input received from the user's menu selection, calling the appropriate private method (`addRequest`, `viewPendingRequests`, etc.).
 * 
 * 3.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for standard application output, such as displaying the menu, prompts for input, confirmation messages for successful operations, and listing the contents of the pending and processed request collections.
 *     *   `System.err.println()` is used exclusively for displaying error messages, such as invalid user input (non-numeric menu choice, invalid priority) or attempting an operation on an empty collection (processing from an empty queue). This distinguishes error output from normal program output.
 * 
 * 4.  **Error Handling (`try-catch`, Input Validation):**
 *     *   **Class-wide `try-catch`:** The `start()` method contains a `try-catch(Exception e)` block that wraps the main `while(true)` application loop. This block serves as a class-wide handler, catching any unexpected `Exception` that might occur within the loop's execution and wasn't handled by more specific catches. It prints a generic error message to `System.err`, demonstrating a fallback error handling mechanism. A `finally` block ensures the `Scanner` is closed.
 *     *   **Input Validation:**
 *         *   Menu choice validation: The input is first read as a `String` (`scanner.nextLine()`) and then parsed as an integer inside a specific `try-catch(NumberFormatException e)` block. If parsing fails, an error is printed to `System.err`, and `continue` is used to restart the loop, prompting the user again.
 *         *   Priority validation: In `addRequest()`, the priority input string is validated by attempting to convert it to the `SupportRequest.Priority` enum using `SupportRequest.Priority.valueOf()`. This is done inside a `try-catch(IllegalArgumentException e)` block within a `while` loop. If the conversion fails (invalid string), an error is printed to `System.err`, and the loop continues, re-prompting the user until valid input is given.
 *     *   **Empty Collection Handling:** Before attempting to `poll()` from `pendingRequests` or iterating through `pendingRequests`/`processedRequests`, the code checks if the collection is `isEmpty()`. If so, appropriate messages are printed to `System.err` (for processing) or `System.out` (for viewing), preventing runtime errors like `NoSuchElementException` (which `remove()` would throw on an empty queue) or simply providing user feedback for empty lists.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   The `SupportRequest` class encapsulates the data related to a request (ID, description, priority, status) with private fields. Public getter methods provide controlled access to this data, and a public `setStatus` method allows changing the status. Enums (`Priority`, `Status`) provide type safety for specific values. A static `AtomicInteger` ensures unique IDs.
 *     *   The `SupportSystem` class manages the application state (`pendingRequests`, `processedRequests`, `scanner`) and contains the core logic in separate, well-named methods (`addRequest`, `processNextRequest`, etc.), promoting modularity and readability.
 * 
 * 6.  **Code Quality:**
 *     *   Variable and method names are descriptive (e.g., `pendingRequests`, `processNextRequest`, `viewProcessedRequests`).
 *     *   Comments explain the purpose of classes, methods, fields, and specific blocks of code, including the role of the required components and error handling.
 *     *   The `closeScanner()` method is called in the `finally` block of the `start()` method's `try` block, ensuring the `Scanner` resource is released whether the program exits normally or due to an unexpected error caught by the class-wide handler.
 * 
 * In summary, the solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and class-wide `try-catch` within a practical application scenario, demonstrating robust error handling, input validation, and adherence to object-oriented principles and good coding practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // To generate unique IDs

// Represents a support request with ID, description, priority, and status.
class SupportRequest {

    // Enum for request priority levels.
    public enum Priority {
        HIGH, MEDIUM, LOW
    }

    // Enum for request status.
    public enum Status {
        PENDING, PROCESSED
    }

    // Static counter for generating unique request IDs. Atomic for thread safety,
    // though not strictly necessary for this single-threaded example, it's good practice.
    private static final AtomicInteger nextId = new AtomicInteger(1);

    private int id; // Unique identifier for the request
    private String description; // Description of the issue
    private Priority priority; // Priority level (HIGH, MEDIUM, LOW)
    private Status status; // Current status (PENDING, PROCESSED)

    /**
     * Constructs a new SupportRequest.
     * Automatically assigns a unique ID and sets status to PENDING.
     *
     * @param description The description of the request.
     * @param priority    The priority of the request.
     */
    public SupportRequest(String description, Priority priority) {
        this.id = nextId.getAndIncrement(); // Get current value and increment for the next request
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New requests start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter (for status update) ---
    /**
     * Sets the status of the support request.
     * @param status The new status to set.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the SupportRequest.
     * @return A formatted string describing the request.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Priority: %s, Status: %s, Description: \"%s\"",
                id, priority, status, description);
    }
}

// Main class to manage the support request system.
public class SupportSystem {

    // Queue to hold requests that are waiting to be processed (FIFO).
    private Queue<SupportRequest> pendingRequests;

    // List to hold requests that have been processed. Declared as List interface.
    private List<SupportRequest> processedRequests;

    // Scanner for reading user input from the console.
    private Scanner scanner;

    /**
     * Constructs a new SupportSystem, initializing data structures and scanner.
     */
    public SupportSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingRequests = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.processedRequests = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the main application loop.
     * Includes the required class-wide exception handling.
     */
    public void start() {
        // Class-wide try-catch block wrapping the core application logic.
        try {
            // Main loop to keep the application running until exit.
            while (true) {
                displayMenu(); // Show menu options
                System.out.print("Enter your choice: ");

                String choiceInput = scanner.nextLine(); // Read the entire line to handle potential non-numeric input cleanly

                int choice;
                try {
                    // Attempt to parse the input string into an integer
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    // Handle cases where the input is not a valid number
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show the menu again
                }

                // Use a switch statement to handle different menu choices.
                switch (choice) {
                    case 1:
                        addRequest(); // Call method to add a new request
                        break;
                    case 2:
                        viewPendingRequests(); // Call method to view pending requests
                        break;
                    case 3:
                        processNextRequest(); // Call method to process the next request
                        break;
                    case 4:
                        viewProcessedRequests(); // Call method to view processed requests
                        break;
                    case 5:
                        System.out.println("Exiting Support System. Goodbye!");
                        return; // Exit the start method, terminating the application
                    default:
                        // Handle choices that are numbers but outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that occur within the try block.
            // This provides the required class-wide exception handling.
            System.err.println("An unexpected error occurred during system operation: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging information during development/testing
        } finally {
            // This block executes regardless of whether an exception occurred or the loop exited normally.
            // It ensures the scanner resource is closed to prevent resource leaks.
            closeScanner();
        }
    }

    /**
     * Displays the main menu options to the console using System.out.
     */
    private void displayMenu() {
        System.out.println("--- Support Request System Menu ---");
        System.out.println("1. Add New Support Request");
        System.out.println("2. View Pending Requests");
        System.out.println("3. Process Next Pending Request");
        System.out.println("4. View Processed Requests");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Prompts the user for request details, validates input,
     * creates a SupportRequest object, and adds it to the pending queue.
     * Uses System.out for prompts and success, System.err for validation errors.
     */
    private void addRequest() {
        System.out.println("--- Add New Support Request ---");

        // Get description from user
        System.out.print("Enter request description: ");
        String description = scanner.nextLine();
        // Validate description is not empty or just whitespace
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Description cannot be empty.");
             return; // Exit method if description is invalid
        }

        // Get and validate priority from user
        SupportRequest.Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase(); // Read, trim whitespace, convert to uppercase
            try {
                // Attempt to convert string input to Priority enum
                priority = SupportRequest.Priority.valueOf(priorityInput);
                validPriority = true; // Input was valid, exit loop
            } catch (IllegalArgumentException e) {
                // Handle cases where the input string does not match an enum constant
                System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
                // Loop continues to re-prompt
            }
        }

        // Create the new request object
        SupportRequest newRequest = new SupportRequest(description, priority);
        // Add the new request to the pending queue using offer().
        // offer() is generally preferred over add() for capacity-constrained queues,
        // though LinkedList is not capacity-constrained. It's good practice.
        pendingRequests.offer(newRequest);
        System.out.println("Request added successfully: " + newRequest);
    }

    /**
     * Displays all requests currently in the pending queue using System.out.
     * Prints a message to System.out if the queue is empty.
     */
    private void viewPendingRequests() {
        System.out.println("--- Pending Support Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate over the queue elements without removing them.
            // Using a simple for-each loop is suitable for viewing.
            int count = 1;
            // Iterating over a Queue uses its iterator, which for LinkedList is ordered FIFO
            for (SupportRequest request : pendingRequests) {
                System.out.println(count++ + ". " + request);
            }
        }
    }

    /**
     * Processes the next request from the pending queue (FIFO).
     * Removes the request from the queue, updates its status, and adds it to the processed list.
     * Uses System.out for success, System.err if the queue is empty.
     */
    private void processNextRequest() {
        System.out.println("--- Processing Next Request ---");
        if (pendingRequests.isEmpty()) {
            System.err.println("No pending requests to process.");
        } else {
            // Retrieve and remove the head of the queue using poll().
            // poll() is preferred over remove() as it returns null if the queue is empty
            // instead of throwing an exception, although our isEmpty() check prevents null here.
            SupportRequest processedRequest = pendingRequests.poll();

            // Update the status of the retrieved request.
            processedRequest.setStatus(SupportRequest.Status.PROCESSED);

            // Add the processed request to the list of processed requests.
            processedRequests.add(processedRequest);

            System.out.println("Processed request: " + processedRequest);
        }
    }

    /**
     * Displays all requests that have been processed using System.out.
     * Prints a message to System.out if the processed list is empty.
     */
    private void viewProcessedRequests() {
        System.out.println("--- Processed Support Requests ---");
        if (processedRequests.isEmpty()) {
            System.out.println("No requests have been processed yet.");
        } else {
            // Iterate over the list of processed requests.
            int count = 1;
            for (SupportRequest request : processedRequests) {
                System.out.println(count++ + ". " + request);
            }
        }
    }

    /**
     * Closes the Scanner resource to release system resources.
     * Called in the finally block of the start method.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the SupportSystem application.
     * Creates an instance of SupportSystem and calls its start method.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.start(); // Start the application loop
    }
}
