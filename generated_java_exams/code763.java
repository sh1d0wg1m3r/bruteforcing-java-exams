/*
 * Exam Question #763
 * Generated on: 2025-05-12 16:37:18
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Waiting List Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified hospital system focusing on managing patient waiting lists for doctors. When a patient arrives for an appointment, they are added to the waiting list (queue) for their specific doctor. Doctors process patients from their waiting list in the order they arrived.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that allows users to interact with this system through a console interface. The system should support the following operations:
 * 
 * 1.  **Add New Patient:** Register a new patient with a unique ID and name.
 * 2.  **Add New Doctor:** Register a new doctor with a unique ID, name, and specialization. Each doctor should maintain their own waiting list.
 * 3.  **Check-In Patient:** Simulate a patient checking in for an appointment. The user provides the patient ID and the doctor ID. If both exist, the patient is added to the *end* of that doctor's waiting list.
 * 4.  **Process Next Patient:** Simulate a doctor calling the next patient from their waiting list. The user provides the doctor ID. If the doctor exists and their waiting list is not empty, the patient at the *front* of the list is removed and announced as being seen.
 * 5.  **List All Patients:** Display details of all registered patients.
 * 6.  **List All Doctors:** Display details of all registered doctors and the number of patients currently in their waiting list.
 * 7.  **View Doctor's Waiting List:** Display the names of patients currently in a specific doctor's waiting list, in order.
 * 
 * Your solution must adhere to the following technical constraints and best practices:
 * 
 * *   Use `java.util.Queue` to represent each doctor's waiting list.
 * *   Use `java.util.ArrayList` to store the collection of all patients and all doctors.
 * *   Use the `java.util.List` interface type when declaring collections of patients and doctors.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.err` to print error messages (e.g., invalid input, patient/doctor not found, empty waiting list).
 * *   Use `System.out` for all normal output (menu, prompts, success messages, lists).
 * *   Implement class-wide or operation-specific exception handling using `try-catch` blocks, particularly for handling invalid input (like non-integer IDs) or potential issues during operations (though custom exceptions are not strictly required, graceful handling of errors like "not found" or "empty queue" using checks and `System.err` is essential).
 * *   Employ proper encapsulation (private fields, public getters/methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and basic documentation.
 * *   Validate user input where necessary (e.g., ensuring numeric input for IDs).
 * 
 * **Class Structure Suggestion:**
 * 
 * *   `Patient` class: Fields for ID, name.
 * *   `Doctor` class: Fields for ID, name, specialization, and a `Queue<Patient>` for the waiting list.
 * *   `HospitalSystem` class: Contains `List<Patient>` and `List<Doctor>`, methods for adding, finding, scheduling, processing, and listing.
 * *   `HospitalScheduler` class: Contains the `main` method, handles the menu, user interaction, and calls methods on a `HospitalSystem` instance.
 * 
 * **Input Format:**
 * 
 * User input will be read line by line. Follow the prompts provided by the system. IDs are integers. Names and specializations are strings.
 * 
 * **Expected Output:**
 * 
 * *   A clear menu of options.
 * *   Prompts for required input (e.g., "Enter patient name:").
 * *   Confirmation messages for successful operations (e.g., "Patient added successfully with ID: X").
 * *   Lists formatted clearly.
 * *   Error messages printed to `System.err` when operations fail due to invalid input, non-existent IDs, or empty queues.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Hospital Waiting List System ---
 * 1. Add Patient
 * 2. Add Doctor
 * 3. Check-In Patient
 * 4. Process Next Patient
 * 5. List Patients
 * 6. List Doctors
 * 7. View Doctor's Waiting List
 * 8. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Patient added successfully with ID: 1
 * 
 * Enter your choice: 2
 * Enter doctor name: Dr. Smith
 * Enter specialization: Cardiology
 * Doctor added successfully with ID: 101
 * 
 * Enter your choice: 3
 * Enter patient ID to check-in: 1
 * Enter doctor ID for appointment: 101
 * Patient Alice checked in for Dr. Smith.
 * 
 * Enter your choice: 7
 * Enter doctor ID to view waiting list: 101
 * Dr. Smith's Waiting List:
 * 1. Alice (ID: 1)
 * 
 * Enter your choice: 4
 * Enter doctor ID to process patient: 101
 * Dr. Smith is now seeing patient Alice (ID: 1).
 * 
 * Enter your choice: 7
 * Enter doctor ID to view waiting list: 101
 * Dr. Smith's Waiting List is empty.
 * 
 * Enter your choice: 4
 * Enter doctor ID to process patient: 102
 * Error: Doctor with ID 102 not found.
 * 
 * Enter your choice: 4
 * Enter doctor ID to process patient: 101
 * Error: Dr. Smith's waiting list is empty.
 * ```
 * 
 * Implement the full system according to these requirements.
 *
 * EXPLANATION:
 * The solution implements a simplified hospital waiting list system as described in the problem.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`: A simple class representing a patient with a unique `id` (generated using `AtomicInteger` for thread-safe increment, although not strictly necessary in this single-threaded console app, it's a good practice for unique IDs) and `name`. It includes a constructor and getters following encapsulation principles.
 *     *   `Doctor`: Represents a doctor with a unique `id`, `name`, `specialization`, and crucially, a `Queue<Patient>` named `waitingList`. This `Queue` holds the patients waiting to be seen by this specific doctor. Methods like `addPatientToWaitingList` (`offer`) and `processNextPatient` (`poll`) interact directly with this queue. `LinkedList` is used as the concrete implementation for the `Queue`.
 *     *   `HospitalSystem`: This class acts as the central manager. It holds `List<Patient> patients` and `List<Doctor> doctors`, both declared using the `List` interface type but instantiated as `ArrayList`. It contains methods for adding patients/doctors, finding them by ID, checking patients into a doctor's queue (`checkInPatient`), processing the next patient from a queue (`processNextPatient`), and listing the registered patients and doctors. Error conditions like patient/doctor not found or empty waiting lists are checked within its methods, throwing exceptions (`IllegalArgumentException`, `IllegalStateException`) or returning null where appropriate, allowing the caller to handle the error reporting.
 *     *   `HospitalScheduler`: This is the main class containing the `main` method. It initializes the `Scanner` and `HospitalSystem`. It presents a menu to the user and uses a `do-while` loop and a `switch` statement to process user choices.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: Used in the `Doctor` class (`waitingList`) to manage the FIFO (First-In, First-Out) order of patients waiting for a specific doctor. `offer()` is used for adding patients, and `poll()` is used for removing the next patient.
 *     *   `ArrayList`: Used in `HospitalSystem` to store the collections of `patients` and `doctors`.
 *     *   `List interface`: Used to declare the `patients` and `doctors` fields in `HospitalSystem` (`private List<Patient> patients; private List<Doctor> doctors;`), promoting good practice by programming to the interface.
 *     *   `Scanner`: Used in `HospitalScheduler.main` and helper methods (`addPatient`, `addDoctor`, etc.) to read user input from `System.in`. `scanner.nextLine()` is used consistently to avoid common pitfalls with `nextInt()` or `nextDouble()` followed by `nextLine()`.
 *     *   `Switch statement`: Used in `HospitalScheduler.main` to direct program flow based on the user's menu selection.
 *     *   `System.err`: Used to print error messages in `HospitalScheduler.main`'s `catch` blocks and within helper methods (like input validation for names) when an operation fails or invalid input is detected.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and formatted lists of patients and doctors.
 *     *   `try-catch blocks`: Used in `HospitalScheduler.main` to handle potential `NumberFormatException` when parsing user input for IDs and to catch `IllegalArgumentException` and `IllegalStateException` propagated from `HospitalSystem` methods, providing robust error handling for user actions. Separate `try-catch` blocks are also included in helper methods like `checkInPatient`, `processNextPatient`, and `viewDoctorWaitingList` specifically for `NumberFormatException` related to reading IDs, allowing `IllegalArgumentException`/`IllegalStateException` to be caught by the main loop's handler.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** All class fields (`id`, `name`, `waitingList`, etc.) are private. Public getter methods are provided where necessary.
 *     *   **Meaningful Names:** Classes, variables, and methods have descriptive names (e.g., `waitingList`, `checkInPatient`, `findDoctorById`).
 *     *   **Comments:** Basic comments explain the purpose of classes, key methods, and fields.
 *     *   **Input Validation:** The code attempts to parse numeric input and catches `NumberFormatException`. It also includes basic checks for empty names/specializations. The `HospitalSystem` methods validate whether requested patient/doctor IDs exist.
 *     *   **Error Handling:** Errors like invalid input, non-existent entities, or operations on empty queues are handled gracefully using `try-catch` and informative messages printed to `System.err`.
 *     *   **Clean Code Structure:** The logic is separated into distinct classes (`Patient`, `Doctor`, `HospitalSystem`), and the main application logic is in `HospitalScheduler`. Helper methods are used in `HospitalScheduler` to keep the `main` method clean.
 * 
 * This solution effectively demonstrates the required Java components and incorporates good programming practices within a practical simulation.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For generating unique IDs

// Represents a patient
class Patient {
    private static final AtomicInteger idCounter = new AtomicInteger(0);
    private int id;
    private String name;

    public Patient(String name) {
        this.id = idCounter.incrementAndGet();
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name + " (ID: " + id + ")";
    }
}

// Represents a doctor with a waiting list
class Doctor {
    private static final AtomicInteger idCounter = new AtomicInteger(100); // Start doctor IDs from 101
    private int id;
    private String name;
    private String specialization;
    private Queue<Patient> waitingList;

    public Doctor(String name, String specialization) {
        this.id = idCounter.incrementAndGet();
        this.name = name;
        this.specialization = specialization;
        this.waitingList = new LinkedList<>(); // LinkedList is a common implementation of Queue
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSpecialization() {
        return specialization;
    }

    public Queue<Patient> getWaitingList() {
        return waitingList;
    }

    /**
     * Adds a patient to the end of the waiting list.
     * @param patient The patient to add.
     * @return true if the patient was added successfully.
     */
    public boolean addPatientToWaitingList(Patient patient) {
        return waitingList.offer(patient); // offer is generally preferred over add for capacity-constrained queues
    }

    /**
     * Removes and returns the patient at the front of the waiting list.
     * @return The patient at the front, or null if the list is empty.
     */
    public Patient processNextPatient() {
        return waitingList.poll();
    }

    /**
     * Checks if the waiting list is empty.
     * @return true if the list is empty, false otherwise.
     */
    public boolean isWaitingListEmpty() {
        return waitingList.isEmpty();
    }

    /**
     * Gets the number of patients in the waiting list.
     * @return The size of the waiting list.
     */
    public int getWaitingListSize() {
        return waitingList.size();
    }

    @Override
    public String toString() {
        return "Dr. " + name + " (ID: " + id + ", " + specialization + ")";
    }
}

// Manages the collections of patients and doctors, and the scheduling logic
class HospitalSystem {
    private List<Patient> patients;
    private List<Doctor> doctors;

    public HospitalSystem() {
        this.patients = new ArrayList<>();
        this.doctors = new ArrayList<>();
    }

    /**
     * Adds a new patient to the system.
     * @param name The name of the patient.
     * @return The newly created patient object.
     */
    public Patient addPatient(String name) {
        Patient patient = new Patient(name);
        patients.add(patient);
        return patient;
    }

    /**
     * Adds a new doctor to the system.
     * @param name The name of the doctor.
     * @param specialization The doctor's specialization.
     * @return The newly created doctor object.
     */
    public Doctor addDoctor(String name, String specialization) {
        Doctor doctor = new Doctor(name, specialization);
        doctors.add(doctor);
        return doctor;
    }

    /**
     * Finds a patient by their ID.
     * @param id The ID of the patient to find.
     * @return The Patient object if found, null otherwise.
     */
    public Patient findPatientById(int id) {
        for (Patient patient : patients) {
            if (patient.getId() == id) {
                return patient;
            }
        }
        return null;
    }

    /**
     * Finds a doctor by their ID.
     * @param id The ID of the doctor to find.
     * @return The Doctor object if found, null otherwise.
     */
    public Doctor findDoctorById(int id) {
        for (Doctor doctor : doctors) {
            if (doctor.getId() == id) {
                return doctor;
            }
        }
        return null;
    }

    /**
     * Checks a patient into a doctor's waiting list.
     * @param patientId The ID of the patient.
     * @param doctorId The ID of the doctor.
     * @throws IllegalArgumentException if patient or doctor is not found.
     */
    public void checkInPatient(int patientId, int doctorId) {
        Patient patient = findPatientById(patientId);
        Doctor doctor = findDoctorById(doctorId);

        if (patient == null) {
            throw new IllegalArgumentException("Patient with ID " + patientId + " not found.");
        }
        if (doctor == null) {
            throw new IllegalArgumentException("Doctor with ID " + doctorId + " not found.");
        }

        doctor.addPatientToWaitingList(patient);
        System.out.println("Patient " + patient.getName() + " checked in for " + doctor.getName() + ".");
    }

    /**
     * Processes the next patient for a given doctor.
     * @param doctorId The ID of the doctor.
     * @throws IllegalArgumentException if doctor is not found.
     * @throws IllegalStateException if the doctor's waiting list is empty.
     */
    public void processNextPatient(int doctorId) {
        Doctor doctor = findDoctorById(doctorId);

        if (doctor == null) {
            throw new IllegalArgumentException("Doctor with ID " + doctorId + " not found.");
        }

        Patient nextPatient = doctor.processNextPatient();

        if (nextPatient == null) {
            throw new IllegalStateException(doctor.getName() + "'s waiting list is empty.");
        } else {
            System.out.println(doctor.getName() + " is now seeing patient " + nextPatient.getName() + " (ID: " + nextPatient.getId() + ").");
        }
    }

    /**
     * Lists all registered patients.
     */
    public void listAllPatients() {
        if (patients.isEmpty()) {
            System.out.println("No patients registered yet.");
            return;
        }
        System.out.println("\n--- All Patients ---");
        for (Patient patient : patients) {
            System.out.println(patient);
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all registered doctors and their waiting list sizes.
     */
    public void listAllDoctors() {
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered yet.");
            return;
        }
        System.out.println("\n--- All Doctors ---");
        for (Doctor doctor : doctors) {
            System.out.println(doctor + " - Waiting list size: " + doctor.getWaitingListSize());
        }
        System.out.println("--------------------");
    }

    /**
     * Views the waiting list for a specific doctor.
     * @param doctorId The ID of the doctor.
     * @throws IllegalArgumentException if doctor is not found.
     */
    public void viewDoctorWaitingList(int doctorId) {
        Doctor doctor = findDoctorById(doctorId);

        if (doctor == null) {
            throw new IllegalArgumentException("Doctor with ID " + doctorId + " not found.");
        }

        System.out.println("\n--- " + doctor.getName() + "'s Waiting List ---");
        Queue<Patient> waitingList = doctor.getWaitingList();
        if (waitingList.isEmpty()) {
            System.out.println("The waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Patient patient : waitingList) {
                System.out.println(index++ + ". " + patient);
            }
        }
        System.out.println("--------------------");
    }
}

// Main class to run the hospital scheduler system
public class HospitalScheduler {

    private static Scanner scanner = new Scanner(System.in);
    private static HospitalSystem hospitalSystem = new HospitalSystem();

    public static void main(String[] args) {
        int choice;
        do {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = Integer.parseInt(scanner.nextLine()); // Read line and parse to avoid issues with nextInt()

                switch (choice) {
                    case 1:
                        addPatient();
                        break;
                    case 2:
                        addDoctor();
                        break;
                    case 3:
                        checkInPatient();
                        break;
                    case 4:
                        processNextPatient();
                        break;
                    case 5:
                        hospitalSystem.listAllPatients();
                        break;
                    case 6:
                        hospitalSystem.listAllDoctors();
                        break;
                    case 7:
                        viewDoctorWaitingList();
                        break;
                    case 8:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 8.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid input. Please enter a number.");
                choice = 0; // Reset choice to continue loop
            } catch (IllegalArgumentException | IllegalStateException e) {
                System.err.println("Error: " + e.getMessage());
                choice = 0; // Reset choice to continue loop
            }
            System.out.println(); // Add a blank line for readability
        } while (choice != 8);

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("--- Hospital Waiting List System ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Add Doctor");
        System.out.println("3. Check-In Patient");
        System.out.println("4. Process Next Patient");
        System.out.println("5. List Patients");
        System.out.println("6. List Doctors");
        System.out.println("7. View Doctor's Waiting List");
        System.out.println("8. Exit");
        System.out.println("------------------------------------");
    }

    private static void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }
        Patient newPatient = hospitalSystem.addPatient(name.trim());
        System.out.println("Patient added successfully with ID: " + newPatient.getId());
    }

    private static void addDoctor() {
        System.out.print("Enter doctor name: ");
        String name = scanner.nextLine();
         if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Doctor name cannot be empty.");
             return;
        }
        System.out.print("Enter specialization: ");
        String specialization = scanner.nextLine();
         if (specialization == null || specialization.trim().isEmpty()) {
             System.err.println("Error: Specialization cannot be empty.");
             return;
        }
        Doctor newDoctor = hospitalSystem.addDoctor(name.trim(), specialization.trim());
        System.out.println("Doctor added successfully with ID: " + newDoctor.getId());
    }

    private static void checkInPatient() {
        try {
            System.out.print("Enter patient ID to check-in: ");
            int patientId = Integer.parseInt(scanner.nextLine());
            System.out.print("Enter doctor ID for appointment: ");
            int doctorId = Integer.parseInt(scanner.nextLine());

            hospitalSystem.checkInPatient(patientId, doctorId);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter numeric IDs.");
        }
        // IllegalArgumentException is caught in the main loop
    }

    private static void processNextPatient() {
        try {
            System.out.print("Enter doctor ID to process patient: ");
            int doctorId = Integer.parseInt(scanner.nextLine());

            hospitalSystem.processNextPatient(doctorId);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a numeric doctor ID.");
        }
        // IllegalArgumentException and IllegalStateException are caught in the main loop
    }

     private static void viewDoctorWaitingList() {
        try {
            System.out.print("Enter doctor ID to view waiting list: ");
            int doctorId = Integer.parseInt(scanner.nextLine());

            hospitalSystem.viewDoctorWaitingList(doctorId);
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a numeric doctor ID.");
        }
         // IllegalArgumentException is caught in the main loop
    }
}
