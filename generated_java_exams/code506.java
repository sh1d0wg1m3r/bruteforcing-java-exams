/*
 * Exam Question #506
 * Generated on: 2025-05-11 23:21:36
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for managing orders at a small restaurant. The system needs to handle placing new orders, processing orders in the order they were received, and viewing the status of pending and completed orders.
 * 
 * **Requirements:**
 * 
 * Implement a Java program for the Restaurant Order Management System with the following features:
 * 
 * 1.  **Menu:** A predefined list of menu items with an ID, name, and price.
 * 2.  **Placing Orders:**
 *     *   Allow users to select multiple items and specify quantities for a single order.
 *     *   Validate item IDs and quantities entered by the user.
 *     *   Each order should have a unique ID.
 *     *   Newly placed orders are added to a waiting queue for preparation.
 * 3.  **Processing Orders:**
 *     *   Process orders one by one from the front of the waiting queue.
 *     *   Once processed, move the order to a list of completed orders.
 *     *   Handle the case where the queue is empty.
 * 4.  **Viewing Orders:**
 *     *   Allow viewing all orders currently in the pending queue.
 *     *   Allow viewing all orders that have been completed.
 * 5.  **User Interface:**
 *     *   Provide a simple text-based menu for user interaction (Place Order, Process Order, View Pending Orders, View Completed Orders, Exit).
 *     *   Use `Scanner` to get user input for menu choices, item selections, and quantities.
 *     *   Use a `switch` statement to handle the main menu choices.
 *     *   Display normal output (menu, order details, status messages) using `System.out`.
 *     *   Display error messages (invalid input, queue empty, item not found) using `System.err`.
 * 6.  **Error Handling:**
 *     *   Implement robust input validation for user inputs (menu choice, item ID, quantity).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `NumberFormatException` when parsing user input.
 *     *   Include a general `try-catch` block in the main execution loop to demonstrate class-wide exception handling for unexpected errors. Report these errors using `System.err`.
 * 7.  **Data Structures:**
 *     *   Use `java.util.Queue` to store orders waiting to be processed (pending orders).
 *     *   Use `java.util.ArrayList` to store the menu items.
 *     *   Use `java.util.List` interface type for declaring variables where appropriate (e.g., for the menu or completed orders list).
 * 8.  **Object-Oriented Design:**
 *     *   Create classes for `MenuItem`, `OrderItem` (representing an item within an order with quantity), and `Order`.
 *     *   Implement proper encapsulation (private fields, public getters/setters where necessary, meaningful methods).
 *     *   Create a main `RestaurantOrderSystem` class to manage the menu, queues, lists, and user interaction logic.
 * 9.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts of the code.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Interaction Flow (Example):**
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Order
 * 4. View Pending Orders
 * 5. View Completed Orders
 * 6. Exit
 * Enter your choice: 1
 * 
 * --- Menu ---
 * ID: 1, Name: Burger, Price: $8.99
 * ID: 2, Name: Pizza, Price: $12.50
 * ID: 3, Name: Salad, Price: $6.75
 * ID: 4, Name: Fries, Price: $3.50
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 2
 * 
 * --- Place New Order ---
 * Enter item ID (or 0 to finish): 1
 * Enter quantity: 2
 * Item 'Burger' (x2) added to order.
 * Enter item ID (or 0 to finish): 4
 * Enter quantity: 3
 * Item 'Fries' (x3) added to order.
 * Enter item ID (or 0 to finish): 0
 * Order #1 placed with 2 items.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 4
 * 
 * --- Pending Orders ---
 * Order #1 (Pending)
 *   - Burger (x2)
 *   - Fries (x3)
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 3
 * 
 * Processing Order #1...
 * Order #1 completed.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 4
 * 
 * --- Pending Orders ---
 * No pending orders.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 5
 * 
 * --- Completed Orders ---
 * Order #1 (Completed)
 *   - Burger (x2)
 *   - Fries (x3)
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 6
 * 
 * Exiting system.
 * ```
 * 
 * **Error Handling Example:**
 * 
 * ```
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 2
 * 
 * --- Place New Order ---
 * Enter item ID (or 0 to finish): 99
 * Error: Item with ID 99 not found. Please try again.
 * Enter item ID (or 0 to finish): 1
 * Enter quantity: -5
 * Error: Quantity must be positive. Please try again.
 * Enter item ID (or 0 to finish): 1
 * Enter quantity: xyz
 * Error: Invalid quantity input. Please enter a number.
 * Enter item ID (or 0 to finish): 0
 * Order placement cancelled or no items added.
 * 
 * --- Restaurant Order Management ---
 * ... (menu options again)
 * Enter your choice: 3
 * 
 * --- Processing Order ---
 * Error: No pending orders to process.
 * ```
 * 
 * Your solution should consist of all necessary classes and a main method to run the system.
 * 
 * **Assessment Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Implementation of all required features.
 * *   Correct input validation and error handling.
 * *   Clean code structure, meaningful names, and comments.
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Management System using the required Java components and adhering to best practices.
 * 
 * 1.  **Object-Oriented Structure:**
 *     *   `MenuItem`: Simple class encapsulating an item's ID, name, and price.
 *     *   `OrderItem`: Links a `MenuItem` with a specific `quantity` for an order.
 *     *   `Order`: Represents a complete customer order with a unique ID, a list of `OrderItem`s, and a status. It uses a static counter (`nextOrderId`) to ensure unique IDs for each new order instance. It holds its items in a `List<OrderItem>`.
 *     *   `RestaurantOrderSystem`: The main class orchestrating the system. It holds the menu (`List<MenuItem>`), pending orders (`Queue<Order>`), and completed orders (`List<Order>`). It contains the methods for user interaction and system logic.
 * 
 * 2.  **Data Structures:**
 *     *   `menu`: Declared as `List<MenuItem>` and initialized with `new ArrayList<>()`. `ArrayList` is suitable here as we need indexed access to add initial items and iterate, but the `List` interface is used for the variable type.
 *     *   `pendingOrders`: Declared as `Queue<Order>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` and is efficient for adding (`offer`) and removing (`poll`) elements from the ends, which matches the FIFO nature of an order queue.
 *     *   `completedOrders`: Declared as `List<Order>` and initialized with `new ArrayList<>()`. `ArrayList` is suitable for storing completed orders as a historical list, allowing easy iteration.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `Scanner`: Used in the `RestaurantOrderSystem` class to read user input from the console (`System.in`). It's initialized once and closed in the `finally` block of the `run` method to release system resources. Using `scanner.nextLine()` and then parsing (`Integer.parseInt`) is generally safer than mixing `nextInt()` and `nextLine()` as it consumes the whole line, preventing newline character issues.
 *     *   `switch` statement: Used in the main `run` method to direct execution flow based on the user's numeric choice from the main menu. This provides a clean and readable way to handle multiple distinct options.
 * 
 * 4.  **Error Handling:**
 *     *   `try-catch` for `NumberFormatException`: Used specifically when parsing user input (menu choice, item ID, quantity) that is expected to be an integer. If parsing fails, an error message is printed to `System.err`, and the program either prompts for input again or continues the main loop.
 *     *   Input Validation: Checks are performed for invalid item IDs (`findMenuItemById` returning null) and non-positive quantities. Error messages are printed to `System.err`.
 *     *   Handling Empty Queue: The `processNextOrder` method checks if `pendingOrders.poll()` returns `null` (which indicates the queue is empty) and prints an error message to `System.err` instead of attempting to process a non-existent order.
 *     *   Class-wide `try-catch`: The core `while` loop in the `run` method is wrapped in a general `try-catch(Exception e)`. This catches any unexpected runtime exception that might occur within the main application logic, preventing the program from crashing abruptly. It prints a generic error message and the exception details (including stack trace via `e.printStackTrace(System.err)`) to `System.err`.
 *     *   `System.err` vs `System.out`: Error messages are explicitly directed to `System.err`, separating them from standard output messages like menu displays and order confirmations, which go to `System.out`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `MenuItem`, `OrderItem`, and `Order` are `private`, with public getter methods provided where access is needed. Methods operate on the object's internal state.
 *     *   **Meaningful Names:** Classes, variables, and methods have names that clearly indicate their purpose (e.g., `pendingOrders`, `placeOrder`, `findMenuItemById`).
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic points.
 *     *   **Clean Code:** The logic is broken down into smaller, focused methods (`displayMenu`, `placeOrder`, `processNextOrder`, etc.), making the code more modular and readable. The `run` method acts as the main application loop controller.
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // More specific than Exception for Scanner issues

// Represents a single item on the restaurant menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Price: $%.2f", id, name, price);
    }
}

// Represents an item within a specific order (MenuItem + quantity)
class OrderItem {
    private MenuItem menuItem;
    private int quantity;

    public OrderItem(MenuItem menuItem, int quantity) {
        this.menuItem = menuItem;
        this.quantity = quantity;
    }

    public MenuItem getMenuItem() {
        return menuItem;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return String.format("%s (x%d)", menuItem.getName(), quantity);
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique IDs

    private int orderId;
    private List<OrderItem> items; // Using List interface
    private String status; // e.g., "Pending", "Completed"

    public Order(List<OrderItem> items) {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(items); // Create a copy to prevent external modification
        this.status = "Pending";
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items; // Return the internal list (copy already made in constructor)
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("Order #%d (%s)\n", orderId, status));
        for (OrderItem item : items) {
            sb.append("  - ").append(item.toString()).append("\n");
        }
        return sb.toString();
    }
}

// Main class to manage the restaurant system
public class RestaurantOrderSystem {

    // Use List interface for the menu, implemented by ArrayList
    private List<MenuItem> menu;
    // Use Queue interface for pending orders, implemented by LinkedList
    private Queue<Order> pendingOrders;
    // Use List interface for completed orders, implemented by ArrayList
    private List<Order> completedOrders;

    private Scanner scanner;

    public RestaurantOrderSystem() {
        // Initialize data structures
        menu = new ArrayList<>();
        pendingOrders = new LinkedList<>(); // LinkedList is a common and efficient Queue implementation
        completedOrders = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Populate the menu
        initializeMenu();
    }

    // Initializes the restaurant menu with some items
    private void initializeMenu() {
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Pizza", 12.50));
        menu.add(new MenuItem(3, "Salad", 6.75));
        menu.add(new MenuItem(4, "Fries", 3.50));
        System.out.println("Menu initialized.");
    }

    // Displays the current menu
    public void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item);
            }
        }
        System.out.println("------------");
    }

    // Finds a menu item by its ID
    private MenuItem findMenuItemById(int id) {
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Handles placing a new order based on user input
    public void placeOrder() {
        System.out.println("\n--- Place New Order ---");
        List<OrderItem> currentOrderItems = new ArrayList<>(); // Use ArrayList for items in the current order

        while (true) {
            System.out.print("Enter item ID (or 0 to finish): ");
            int itemId = -1;
            try {
                itemId = Integer.parseInt(scanner.nextLine());
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                continue; // Ask for ID again
            }

            if (itemId == 0) {
                break; // Finish placing order
            }

            MenuItem selectedItem = findMenuItemById(itemId);
            if (selectedItem == null) {
                System.err.println("Error: Item with ID " + itemId + " not found. Please try again.");
                continue; // Ask for ID again
            }

            System.out.print("Enter quantity: ");
            int quantity = -1;
            try {
                quantity = Integer.parseInt(scanner.nextLine());
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive. Please try again.");
                    continue; // Ask for quantity again
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid quantity input. Please enter a number.");
                continue; // Ask for quantity again
            }

            // If we reach here, input is valid
            currentOrderItems.add(new OrderItem(selectedItem, quantity));
            System.out.println(selectedItem.getName() + " (x" + quantity + ") added to order.");
        }

        // After the loop
        if (currentOrderItems.isEmpty()) {
            System.out.println("Order placement cancelled or no items added.");
        } else {
            Order newOrder = new Order(currentOrderItems);
            // Add the new order to the pending queue
            pendingOrders.offer(newOrder); // offer is preferred over add for queues
            System.out.println("Order #" + newOrder.getOrderId() + " placed with " + currentOrderItems.size() + " item(s).");
        }
    }

    // Processes the next order from the pending queue
    public void processNextOrder() {
        System.out.println("\n--- Processing Order ---");
        // Poll retrieves and removes the head of the queue
        Order orderToProcess = pendingOrders.poll();

        if (orderToProcess == null) {
            System.err.println("Error: No pending orders to process.");
        } else {
            System.out.println("Processing Order #" + orderToProcess.getOrderId() + "...");
            orderToProcess.setStatus("Completed");
            completedOrders.add(orderToProcess); // Add to completed list
            System.out.println("Order #" + orderToProcess.getOrderId() + " completed.");
        }
    }

    // Displays all orders currently in the pending queue
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : pendingOrders) {
                System.out.print(order); // Order.toString() handles formatting
            }
        }
        System.out.println("--------------------");
    }

    // Displays all orders that have been completed
    public void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            // Iterate through the list
            for (Order order : completedOrders) {
                System.out.print(order); // Order.toString() handles formatting
            }
        }
        System.out.println("----------------------");
    }

    // Displays the main menu options to the user
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order Management ---");
        System.out.println("1. View Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. View Completed Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main application loop
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMainMenu();
                int choice = -1;
                try {
                    // Read the entire line to avoid issues with nextInt/nextLine mix
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        viewCompletedOrders();
                        break;
                    case 6:
                        running = false; // Exit the loop
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handle choices outside the defined range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.run();
    }
}
