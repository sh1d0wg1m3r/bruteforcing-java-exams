/*
 * Exam Question #892
 * Generated on: 2025-05-12 16:56:03
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:** Design and implement a simple command-line application to simulate a print job management system. The system should allow users to add print jobs to a waiting queue, process the next job from the queue, view the current queue, and view a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, input/output, control flow, and error handling. Specifically, you **must** use **ALL** of the following Java components in a meaningful way:
 * 
 * 1.  `java.util.Queue`: To hold print jobs waiting to be processed (First-In, First-Out).
 * 2.  `java.util.ArrayList`: To store the history of completed print jobs.
 * 3.  `java.util.List` interface: The history variable should be declared using the `List` interface type.
 * 4.  `java.util.Scanner`: To read user commands and print job details from standard input.
 * 5.  `switch` statement: To handle the different user commands.
 * 6.  `System.err`: To output error messages (e.g., invalid input, processing errors).
 * 7.  `System.out`: To output normal information (menu, prompts, queue status, history, success messages).
 * 8.  Class-wide exception handling with `try-catch` blocks: To gracefully handle potential runtime issues within the main application loop.
 * 
 * **Task Description:**
 * 
 * Create a Java program that:
 * 
 * 1.  Defines a simple `PrintJob` class with a `String` description and appropriate methods (constructor, getter, `toString`).
 * 2.  In the `main` method or a dedicated manager class:
 *     *   Initialize a `Queue` for waiting jobs and a `List` (implemented by `ArrayList`) for completed jobs.
 *     *   Initialize a `Scanner` to read user input.
 *     *   Enter a loop that continues until the user chooses to exit.
 *     *   Inside the loop, display a menu of options:
 *         *   Add Job
 *         *   Process Next Job
 *         *   View Queue
 *         *   View History
 *         *   Exit
 *     *   Prompt the user for their choice.
 *     *   Use a `switch` statement to handle the user's command.
 *     *   **Add Job:**
 *         *   Prompt the user for the job description.
 *         *   Validate that the description is not empty. If empty, print an error to `System.err` and do not add the job.
 *         *   Create a new `PrintJob` object and add it to the waiting `Queue`.
 *         *   Print a confirmation message to `System.out`.
 *     *   **Process Next Job:**
 *         *   Attempt to retrieve and remove the next job from the `Queue`.
 *         *   If the `Queue` is empty, print a message to `System.out` indicating that there are no jobs to process.
 *         *   If a job is successfully retrieved, add it to the `completedJobs` `List`.
 *         *   Print a message to `System.out` indicating which job was processed.
 *     *   **View Queue:**
 *         *   Print the descriptions of all jobs currently in the waiting `Queue` to `System.out`. Indicate if the queue is empty. The order should reflect the processing order.
 *     *   **View History:**
 *         *   Print the descriptions of all jobs in the `completedJobs` `List` to `System.out`. Indicate if the history is empty. The order should reflect the completion order.
 *     *   **Exit:**
 *         *   Terminate the loop and close the `Scanner`.
 *         *   Print a polite exit message.
 *     *   **Invalid Command:**
 *         *   If the user enters an invalid command, print an error message to `System.err`.
 *     *   Implement a `try-catch(Exception e)` block around the main command processing logic within the loop to catch any unexpected errors and print an informative message to `System.err` before continuing the loop (or exiting gracefully if preferred).
 * 3.  Follow best practices:
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary.
 *     *   Ensure proper encapsulation in the `PrintJob` class.
 *     *   Handle potential input issues (e.g., empty job description).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying menus, prompts, status updates, and error messages as described above.
 * 
 * ```
 * --- Print Job Management System ---
 * Choose an option:
 * 1. Add Job
 * 2. Process Next Job
 * 3. View Queue
 * 4. View History
 * 5. Exit
 * Enter command (number):
 * ```
 * (Example interaction for adding a job)
 * `Enter command (number): 1`
 * `Enter job description: Report.pdf`
 * `Job added: Report.pdf`
 * 
 * (Example interaction for processing)
 * `Enter command (number): 2`
 * `Processed job: Report.pdf`
 * 
 * (Example interaction for viewing queue)
 * `Enter command (number): 3`
 * `--- Current Job Queue ---`
 * `1. Image_Batch.jpg`
 * `2. Presentation.pptx`
 * `-------------------------`
 * 
 * (Example interaction for viewing history)
 * `Enter command (number): 4`
 * `--- Completed Jobs History ---`
 * `1. Report.pdf`
 * `------------------------------`
 * 
 * (Example interaction for invalid input)
 * `Enter command (number): 99`
 * `Error: Invalid command. Please enter a number between 1 and 5.`
 * 
 * (Example interaction for empty queue process)
 * `Enter command (number): 2`
 * `No jobs in the queue to process.`
 * 
 * (Example interaction for empty queue view)
 * `Enter command (number): 3`
 * `Job queue is empty.`
 * 
 * (Example interaction for empty history view)
 * `Enter command (number): 4`
 * `No jobs have been completed yet.`
 * 
 * (Example interaction for exit)
 * `Enter command (number): 5`
 * `Exiting Print Job Management System. Goodbye!`
 * 
 * **Note:** You can implement the logic directly within the `main` method of a single class for simplicity in an exam setting, or create separate classes if you prefer, as long as all requirements are met.
 *
 * EXPLANATION:
 * This solution implements the Print Job Management System as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * 1.  **`PrintJob` Class:** A simple class is created to encapsulate the data for a print job, specifically its `description`. It includes a constructor, a getter method (`getDescription`), and overrides `toString` for easy printing. The `description` field is `private`, adhering to encapsulation.
 * 
 * 2.  **`PrintJobManager` Class:** This class contains the core logic of the application.
 *     *   **Collections:**
 *         *   `jobQueue`: Declared as `Queue<PrintJob>` and initialized with a `LinkedList`. `Queue` is used because print jobs are processed in the order they are added (FIFO - First-In, First-Out), which is the fundamental behavior of a queue. `LinkedList` is a common and efficient implementation for a queue in Java.
 *         *   `completedJobs`: Declared as `List<PrintJob>` and initialized with an `ArrayList`. `List` is used because it's a general interface for ordered collections, and `ArrayList` is chosen as a suitable implementation for storing a dynamic list of completed jobs. We use the `List` interface type for the variable to promote good practice (programming to an interface).
 *     *   **`Scanner`:** An instance of `Scanner` is created to read input from `System.in`. It's closed when the application exits to release system resources.
 *     *   **`start()` Method:** This method contains the main application loop.
 *         *   It runs until the `running` flag is set to `false` (when the user chooses to exit).
 *         *   **`try-catch` Block:** The core logic inside the loop (reading input, parsing, and the `switch` statement) is wrapped in a `try-catch(Exception e)` block. This provides a general safety net to catch unexpected runtime exceptions that might occur (e.g., issues with reading from the console) and prevents the program from crashing abruptly. It prints the error message to `System.err`. A specific `catch (NumberFormatException e)` is also included *before* the general `Exception` catch to handle cases where the user enters non-numeric input for the command, providing a more specific error message using `System.err`.
 *         *   **`switch` Statement:** After reading and parsing the user's command (ensuring it's an integer), a `switch` statement is used to direct the program flow to the appropriate method (`addJob`, `processNextJob`, etc.) based on the command number. The `default` case handles invalid command numbers, printing an error to `System.err`.
 *     *   **Helper Methods (`addJob`, `processNextJob`, `viewQueue`, `viewHistory`):** These private methods encapsulate the logic for each menu option, improving code organization and readability.
 *         *   `addJob`: Reads the description, performs input validation (checks if empty using `trim().isEmpty()`), prints an error to `System.err` if invalid, otherwise creates a `PrintJob` and uses `jobQueue.offer()` to add it. Confirmation goes to `System.out`.
 *         *   `processNextJob`: Uses `jobQueue.poll()` to get and remove the next job. `poll()` is preferred over `remove()` for queues as it returns `null` if the queue is empty, allowing graceful handling. If a job is retrieved, it's added to the `completedJobs` `List` using `completedJobs.add()`. Status messages go to `System.out`.
 *         *   `viewQueue`: Checks if the `jobQueue` is empty. If not, it iterates through the queue (using a for-each loop, which doesn't remove elements) and prints each job's description to `System.out`.
 *         *   `viewHistory`: Checks if the `completedJobs` `List` is empty. If not, it iterates through the list (using an indexed for loop) and prints each completed job's description to `System.out`.
 *     *   **Input/Output:** `System.out` is used for all standard output (menu, prompts, successful actions, status displays). `System.err` is specifically used for reporting errors (invalid command, empty job description, unexpected exceptions).
 * 
 * This structure effectively utilizes the required Java features in a cohesive, practical application, demonstrating understanding of collections, control flow, input handling, and error management.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single print job with a description.
 */
class PrintJob {
    private String description;

    /**
     * Constructs a new PrintJob with the given description.
     * @param description The description of the print job.
     */
    public PrintJob(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the print job.
     * @return The job description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the print job.
     * @return The job description.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a queue of print jobs and a history of completed jobs.
 */
public class PrintJobManager {

    // Use Queue for waiting jobs (FIFO)
    private Queue<PrintJob> jobQueue;
    // Use List (implemented by ArrayList) for completed jobs history
    private List<PrintJob> completedJobs;
    private Scanner scanner;

    /**
     * Constructs a new PrintJobManager, initializing the collections and scanner.
     */
    public PrintJobManager() {
        // LinkedList is a common implementation of the Queue interface
        jobQueue = new LinkedList<>();
        // ArrayList is used to implement the List interface for history
        completedJobs = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Starts the main application loop for managing print jobs.
     */
    public void start() {
        System.out.println("--- Print Job Management System ---");
        boolean running = true;

        while (running) {
            printMenu();

            try {
                System.out.print("Enter command (number): ");
                String commandInput = scanner.nextLine();
                int command = Integer.parseInt(commandInput); // Potential NumberFormatException

                // Use switch statement for flow control based on command
                switch (command) {
                    case 1: // Add Job
                        addJob();
                        break;
                    case 2: // Process Next Job
                        processNextJob();
                        break;
                    case 3: // View Queue
                        viewQueue();
                        break;
                    case 4: // View History
                        viewHistory();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid command errors
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Handle cases where input is not a valid number
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Class-wide exception handling for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("Choose an option:");
        System.out.println("1. Add Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Queue");
        System.out.println("4. View History");
        System.out.println("5. Exit");
    }

    /**
     * Prompts for and adds a new print job to the queue.
     */
    private void addJob() {
        System.out.print("Enter job description: ");
        String description = scanner.nextLine().trim(); // Trim whitespace

        // Input validation: check if description is empty
        if (description.isEmpty()) {
            System.err.println("Error: Job description cannot be empty.");
        } else {
            PrintJob newJob = new PrintJob(description);
            jobQueue.offer(newJob); // Use offer() for adding to queue
            System.out.println("Job added: " + newJob.getDescription());
        }
    }

    /**
     * Processes the next job from the queue, moving it to history.
     */
    private void processNextJob() {
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        PrintJob processedJob = jobQueue.poll();

        if (processedJob == null) {
            System.out.println("No jobs in the queue to process.");
        } else {
            completedJobs.add(processedJob); // Add to the history list
            System.out.println("Processed job: " + processedJob.getDescription());
        }
    }

    /**
     * Displays the current jobs in the waiting queue.
     */
    private void viewQueue() {
        if (jobQueue.isEmpty()) {
            System.out.println("Job queue is empty.");
        } else {
            System.out.println("--- Current Job Queue ---");
            // Iterate through the queue without removing elements
            int i = 1;
            for (PrintJob job : jobQueue) {
                System.out.println(i++ + ". " + job.getDescription());
            }
            System.out.println("-------------------------");
        }
    }

    /**
     * Displays the history of completed print jobs.
     */
    private void viewHistory() {
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            System.out.println("--- Completed Jobs History ---");
            // Iterate through the list
            for (int i = 0; i < completedJobs.size(); i++) {
                System.out.println((i + 1) + ". " + completedJobs.get(i).getDescription());
            }
            System.out.println("------------------------------");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.start();
    }
}
