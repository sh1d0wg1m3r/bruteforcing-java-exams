/*
 * Exam Question #369
 * Generated on: 2025-05-11 23:01:16
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Request Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based technical support request management system. The system should allow users to submit new support requests, process the oldest pending request, view the list of pending requests, and view a history of processed requests.
 * 
 * The system should manage requests in a First-In, First-Out (FIFO) manner for processing. Processed requests should be stored in a historical list.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` (specifically `java.util.Queue`) to hold pending support requests. The requests should be processed in the order they were submitted.
 *     *   Use an `ArrayList` (specifically `java.util.ArrayList`) to store a history of requests that have been processed.
 *     *   Declare the history list using the `List` interface (`java.util.List`).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         *   Submit New Request
 *         *   Process Next Pending Request
 *         *   View Pending Requests
 *         *   View Processed Requests
 *         *   Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 3.  **Request Representation:**
 *     *   Create a class named `SupportRequest` to represent a single request.
 *     *   Each `SupportRequest` should have:
 *         *   A unique integer ID.
 *         *   A String description of the problem.
 *         *   A status (e.g., PENDING, PROCESSED). An enum `RequestStatus` is recommended for this.
 * 4.  **System Logic:**
 *     *   When a request is submitted, assign it a unique ID and add it to the pending `Queue`.
 *     *   When a request is processed, remove the oldest request from the `Queue`, update its status, and add it to the processed `List`. Handle the case where there are no pending requests.
 *     *   Provide methods to display the contents of the pending `Queue` and the processed `List`.
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for all normal output (menu, request details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, trying to process an empty queue, invalid input type).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main user interaction loop to catch unexpected errors and prevent the program from crashing abruptly. Handle specific potential exceptions like `InputMismatchException`.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement input validation (e.g., ensure menu choice is an integer within the valid range).
 *     *   Maintain a clean and organized code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and provide appropriate feedback. Examples:
 * 
 * *   Submitting a request: "Request [ID] submitted."
 * *   Processing a request: "Processed request [ID]: [Description]" or "No pending requests to process."
 * *   Viewing requests: Lists of pending/processed requests with their ID, description, and status.
 * *   Invalid input: Error message on `System.err`.
 * *   Unexpected error: Error message on `System.err`.
 * 
 * Your solution should be a single Java file containing all necessary classes (`SupportRequest`, `RequestManager`, `RequestStatus` enum if used, and the main class with `main` method).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the system logic (FIFO processing, status updates, ID generation).
 * *   Effective use of encapsulation and meaningful names.
 * *   Proper input validation and error handling with appropriate output streams.
 * *   Clean code structure and comments.
 *
 * EXPLANATION:
 * This solution implements a simple Technical Support Request Management System demonstrating the required Java concepts.
 * 
 * 1.  **`SupportRequest` Class:** Represents a single request with an ID, description, and status. It uses an `enum` (`RequestStatus`) for clarity in defining possible states. Encapsulation is applied by making fields `private` and providing `public` getters and a setter for the status. The `toString()` method provides a convenient way to print request details.
 * 
 * 2.  **`RequestManager` Class:**
 *     *   Manages the collections of requests.
 *     *   `pendingRequests`: Declared as `Queue<SupportRequest>` and initialized with `LinkedList`. This ensures requests are processed in FIFO order using `offer()` to add and `poll()` to remove.
 *     *   `processedRequests`: Declared as `List<SupportRequest>` and initialized with `ArrayList`. This stores the history of completed requests.
 *     *   `nextRequestId`: A simple counter to generate unique IDs for new requests.
 *     *   **`submitRequest(String description)`:** Creates a new `SupportRequest` with a unique ID and `PENDING` status, then adds it to the `pendingRequests` queue using `offer()`. Includes basic input validation for the description.
 *     *   **`processNextRequest()`:** Uses `poll()` to get and remove the element at the head of the `pendingRequests` queue. If the queue is empty, `poll()` returns `null`, which is handled by printing a message. If a request is retrieved, its status is updated to `PROCESSED`, and it's added to the `processedRequests` list.
 *     *   **`viewPendingRequests()` and `viewProcessedRequests()`:** Iterate through the respective collections (`Queue` and `List`) and print each request's details using the `toString()` method. They check if the collections are empty before iterating.
 *     *   **`run()`:** This is the main interaction loop.
 *         *   A `Scanner` is created to read user input.
 *         *   The core of the interaction loop is wrapped in a `try-catch` block. This serves as the "class-wide" exception handling, catching potential exceptions that might occur during user interaction or method calls.
 *         *   Inside the loop, a menu is printed (`printMenu()`).
 *         *   Input validation is performed using `scanner.hasNextInt()` before attempting to read an integer choice with `scanner.nextInt()`. This prevents `InputMismatchException` if the user enters non-numeric text. The invalid input is consumed using `scanner.next()`.
 *         *   A `switch` statement handles the valid integer choices, calling the appropriate `RequestManager` methods.
 *         *   A `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *         *   The `catch (Exception e)` block catches any unhandled exceptions within the `try` block, prints an error message to `System.err`, and includes a stack trace for debugging. A specific `catch (InputMismatchException e)` is also included, although the `hasNextInt()` check mitigates this, it demonstrates catching specific exceptions.
 *         *   A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop exited normally.
 *     *   **`main(String[] args)`:** The entry point of the program, which creates a `RequestManager` instance and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all required components, follows best practices for structure and error handling, and simulates a practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for request status
enum RequestStatus {
    PENDING,
    PROCESSED
}

// Represents a single support request
class SupportRequest {
    private int id;
    private String description;
    private RequestStatus status;

    /**
     * Constructs a new SupportRequest.
     * @param id The unique ID for the request.
     * @param description The description of the technical issue.
     */
    public SupportRequest(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = RequestStatus.PENDING; // New requests start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public RequestStatus getStatus() {
        return status;
    }

    // --- Setter for status (used during processing) ---
    public void setStatus(RequestStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the request.
     * @return A formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return "Request [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Manages the collection of support requests
class RequestManager {
    // Queue for pending requests (FIFO)
    private Queue<SupportRequest> pendingRequests;
    // List for processed requests history
    private List<SupportRequest> processedRequests;
    // Counter for generating unique request IDs
    private int nextRequestId;

    /**
     * Constructs a new RequestManager, initializing data structures.
     */
    public RequestManager() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.processedRequests = new ArrayList<>(); // ArrayList implements List
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Submits a new support request.
     * @param description The description of the request.
     */
    public void submitRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Request description cannot be empty.");
            return;
        }
        SupportRequest newRequest = new SupportRequest(nextRequestId++, description.trim());
        pendingRequests.offer(newRequest); // offer is preferred over add for queues (returns false on failure)
        System.out.println("Request " + newRequest.getId() + " submitted.");
    }

    /**
     * Processes the oldest pending request.
     */
    public void processNextRequest() {
        SupportRequest requestToProcess = pendingRequests.poll(); // poll retrieves and removes the head
        if (requestToProcess != null) {
            requestToProcess.setStatus(RequestStatus.PROCESSED);
            processedRequests.add(requestToProcess);
            System.out.println("Processed request " + requestToProcess.getId() + ": '" + requestToProcess.getDescription() + "'");
        } else {
            System.out.println("No pending requests to process.");
        }
    }

    /**
     * Displays all pending requests.
     */
    public void viewPendingRequests() {
        System.out.println("\n--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            pendingRequests.forEach(System.out::println);
        }
        System.out.println("----------------------\n");
    }

    /**
     * Displays all processed requests.
     */
    public void viewProcessedRequests() {
        System.out.println("\n--- Processed Requests History ---");
        if (processedRequests.isEmpty()) {
            System.out.println("No processed requests yet.");
        } else {
            // Iterate through the list
            processedRequests.forEach(System.out::println);
        }
        System.out.println("--------------------------------\n");
    }

    /**
     * Runs the main application loop for user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main interaction loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                System.out.print("Enter your choice: ");
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        submitRequest(description);
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewProcessedRequests();
                        break;
                    case 0:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                }
            }
        } catch (InputMismatchException e) {
             // This catch block might be redundant if nextInt() check is robust,
             // but good for demonstrating catch block for specific input issues
             System.err.println("Input error: Please enter a valid number for the menu choice.");
        }
        catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Support Request System Menu ---");
        System.out.println("1. Submit New Request");
        System.out.println("2. Process Next Pending Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Processed Requests");
        System.out.println("0. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RequestManager manager = new RequestManager();
        manager.run();
    }
}
