/*
 * Exam Question #830
 * Generated on: 2025-05-12 16:47:35
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Project and Task Management Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified console-based project and task management system. This system should allow users to manage multiple projects, add tasks to specific projects, mark tasks as complete, view the status of projects and their tasks, and manage a separate queue for urgent tasks that need immediate attention regardless of their project affiliation.
 * 
 * Your solution must demonstrate a strong understanding of object-oriented design, data structures, and error handling in Java.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow adding new projects with a unique ID and name.
 *     *   Allow adding new tasks to an existing project. Each task should have a unique ID within its project, a description, and a completion status (initially incomplete).
 *     *   Allow marking a specific task within a specific project as complete.
 *     *   Allow viewing the details and status of all tasks within a given project.
 *     *   Allow adding tasks to a global "Urgent Task Queue". These tasks are outside of specific projects for quick handling.
 *     *   Allow processing (completing) the next task from the Urgent Task Queue.
 *     *   Provide a menu-driven interface for the user to interact with the system.
 * 
 * 2.  **Required Java Components:** Your solution *must* utilize *all* of the following Java components:
 *     *   `java.util.Queue` (specifically `java.util.LinkedList` or `java.util.ArrayDeque` implementation is acceptable for the queue)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (use this for declaring project lists and task lists within projects)
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu navigation
 *     *   `System.err` for displaying error messages (e.g., project not found, invalid input)
 *     *   `System.out` for displaying normal output (menu, status, confirmations)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., handling `InputMismatchException` from Scanner, potential null pointers, or custom exceptions if desired). The main application loop should be wrapped in a `try-catch`.
 * 
 * 3.  **Design and Best Practices:**
 *     *   Use object-oriented design: Create classes for `Task` and `Project`.
 *     *   Implement proper encapsulation: Use `private` fields and `public` methods.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc documentation for classes and methods.
 *     *   Implement input validation: Check if projects/tasks exist before performing operations. Handle cases where user input is not in the expected format.
 *     *   Implement proper error handling: Catch exceptions, provide informative error messages using `System.err`.
 *     *   Structure your code cleanly into appropriate classes and methods.
 * 
 * **Input/Output:**
 * 
 * The system should present a menu to the user. Based on the user's choice, it should prompt for necessary details (project ID, task description, etc.) and display the results or error messages.
 * 
 * *   **Input:** User choices (integers), project details (string, int), task details (string, int).
 * *   **Output:** Menu, prompts, confirmations, project/task status, error messages (`System.err`).
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * Project and Task Management System
 * 1. Add New Project
 * 2. Add Task to Project
 * 3. Mark Task Complete
 * 4. View Project Status
 * 5. Add Urgent Task
 * 6. Process Urgent Task Queue
 * 7. Exit
 * Enter your choice: 1
 * Enter project name: Website Redesign
 * Project 'Website Redesign' added with ID: 1
 * 
 * Project and Task Management System
 * 1. Add New Project
 * ...
 * Enter your choice: 2
 * Enter project ID to add task to: 1
 * Enter task description: Design homepage layout
 * Task 'Design homepage layout' added to Project 1 with ID: 1
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 4
 * Enter project ID to view status: 1
 * Project: Website Redesign (ID: 1)
 *   Task ID: 1, Description: Design homepage layout, Status: Incomplete
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 5
 * Enter urgent task description: Fix critical bug in payment gateway
 * Urgent task added to queue.
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 6
 * Processing urgent task...
 * Completed urgent task: Fix critical bug in payment gateway (ID: 1)
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 3
 * Enter project ID: 1
 * Enter task ID to mark complete: 1
 * Task 1 in Project 1 marked as complete.
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 4
 * Enter project ID to view status: 1
 * Project: Website Redesign (ID: 1)
 *   Task ID: 1, Description: Design homepage layout, Status: Complete
 * 
 * Project and Task Management System
 * ...
 * Enter your choice: 7
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of the implemented functionality.
 * *   Adherence to all specified Java component requirements.
 * *   Quality of object-oriented design and encapsulation.
 * *   Effectiveness of input validation and error handling.
 * *   Clarity, readability, and documentation of the code.
 * *   Use of best practices.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simplified project and task management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Object-Oriented Design:**
 *     *   The problem is broken down into two core entities: `Task` and `Project`, each represented by a class.
 *     *   `Task` holds details like ID, description, and completion status. A static counter ensures unique task IDs globally (though they are only unique *within* the system run, not across runs, which is acceptable for this exam scenario).
 *     *   `Project` holds details like ID, name, and a list of `Task` objects associated with it. A static counter provides unique project IDs.
 *     *   The `ProjectManagementSystem` class acts as the controller, managing the collections of projects and urgent tasks and handling user interaction.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `urgentTaskQueue` is declared as a `Queue<Task>` and instantiated using `java.util.LinkedList`. `LinkedList` is a common implementation for `Queue`. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove tasks from the head of the queue, simulating a FIFO (First-In, First-Out) processing order for urgent items.
 *     *   `java.util.ArrayList`: `ArrayList` is used to implement the `List` of projects (`projectList` in `ProjectManagementSystem`) and the `List` of tasks within each project (`tasks` in the `Project` class). `ArrayList` provides dynamic resizing and efficient element access by index, suitable for these lists.
 *     *   `java.util.List interface`: Both `projectList` and the `tasks` field in `Project` are declared using the `List` interface (`List<Project>`, `List<Task>`). This promotes good practice by programming to the interface rather than the specific implementation (`ArrayList`), making the code more flexible if a different List implementation were needed later.
 *     *   `java.util.Scanner`: A `Scanner` object is used in `ProjectManagementSystem` to read user input from `System.in` for menu choices and details like project names, task descriptions, and IDs.
 *     *   `switch statement`: The `switch (choice)` block in the `run()` method is used to control the program flow based on the user's menu selection, directing execution to the appropriate method.
 *     *   `System.err`: `System.err.println()` is used to print error messages to the standard error stream. This is used for invalid input (non-numeric choices, empty strings) and when requested resources (projects, tasks) are not found.
 *     *   `System.out`: `System.out.println()` is used for all normal output, including the menu, prompts, success messages, and project/task status displays.
 *     *   Class-wide exception handling (`try-catch`): The main `run()` method is wrapped in a `try-catch` block. This provides a top-level handler for any unexpected runtime exceptions that might occur during the program's execution, preventing the program from crashing abruptly and printing an informative error message to `System.err`. Additionally, specific `try-catch(InputMismatchException)` blocks are used around `scanner.nextInt()` calls to handle cases where the user enters non-numeric input when a number is expected, preventing the program from entering an infinite loop due to the `Scanner` state. The `finally` blocks ensure the newline character is consumed correctly after `nextInt()`.
 * 
 * 3.  **Design and Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `Project` classes (`id`, `description`, `isCompleted`, `name`, `tasks`) are declared `private`. Public getter methods (`getId`, `getDescription`, etc.) and specific methods to modify state (`setCompleted`, `addTask`) are provided, controlling access to the internal data. The `getTasks()` method in `Project` directly returns the list for simplicity in this exam scenario, but in a production system, returning an unmodifiable list or providing methods to interact with tasks would be better encapsulation.
 *     *   **Meaningful Names:** Class names (`Task`, `Project`, `ProjectManagementSystem`), variable names (`projectList`, `urgentTaskQueue`, `taskDescription`, `projectId`), and method names (`addProject`, `markTaskComplete`, `processUrgentTaskQueue`) are descriptive and indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and key methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points (like static counters or Scanner handling).
 *     *   **Input Validation:** The code checks for empty project names and task descriptions. It also checks if a `Project` or `Task` exists (by ID) before attempting to perform operations on them, printing error messages to `System.err` if not found. `InputMismatchException` handling specifically validates numeric input.
 *     *   **Error Handling:** `try-catch` blocks are used for handling specific input errors (`InputMismatchException`) and a general catch-all for unexpected exceptions. Error messages are directed to `System.err`.
 *     *   **Clean Code Structure:** The code is organized into logical classes. Methods are relatively small and focused on a single responsibility (e.g., `addProject`, `markTaskComplete`). The main application logic is contained within the `run()` method of `ProjectManagementSystem`.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating key object-oriented principles, data structure usage, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task within a project or as an urgent task.
 */
class Task {
    private static int nextTaskId = 1; // Global task ID counter for unique IDs

    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * Assigns a unique ID automatically.
     *
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextTaskId++;
        this.description = description;
        this.isCompleted = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // --- Setters ---
    public void setCompleted(boolean completed) {
        isCompleted = completed;
    }

    /**
     * Returns a string representation of the task status.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description + ", Status: " + (isCompleted ? "Complete" : "Incomplete");
    }
}

/**
 * Represents a project containing multiple tasks.
 */
class Project {
    private static int nextProjectId = 1; // Global project ID counter for unique IDs

    private int id;
    private String name;
    private List<Task> tasks; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new Project.
     * Assigns a unique ID automatically and initializes an empty task list.
     *
     * @param name The name of the project.
     */
    public Project(String name) {
        this.id = nextProjectId++;
        this.name = name;
        this.tasks = new ArrayList<>(); // Using ArrayList implementation
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    /**
     * Returns the list of tasks in this project.
     * Note: Returning the list directly breaks encapsulation slightly for simplicity in this exam context.
     * In a real-world scenario, you might return an unmodifiable list or provide methods to interact with tasks.
     */
    public List<Task> getTasks() {
        return tasks;
    }

    // --- Methods ---

    /**
     * Adds a task to the project's task list.
     *
     * @param task The task to add.
     */
    public void addTask(Task task) {
        this.tasks.add(task);
    }

    /**
     * Finds a task within this project by its ID.
     *
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    public Task findTaskById(int taskId) {
        for (Task task : tasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found in this project
    }

    /**
     * Returns a string representation of the project and its tasks.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Project: ").append(name).append(" (ID: ").append(id).append(")\n");
        if (tasks.isEmpty()) {
            sb.append("  No tasks in this project.");
        } else {
            for (Task task : tasks) {
                sb.append("  ").append(task).append("\n");
            }
        }
        return sb.toString();
    }
}

/**
 * The main class managing projects and an urgent task queue.
 */
public class ProjectManagementSystem {

    private List<Project> projectList; // Using List interface, implemented by ArrayList
    private Queue<Task> urgentTaskQueue; // Using Queue interface, implemented by LinkedList
    private Scanner scanner;

    /**
     * Constructs the ProjectManagementSystem.
     * Initializes the project list, urgent task queue, and scanner.
     */
    public ProjectManagementSystem() {
        projectList = new ArrayList<>(); // Using ArrayList implementation
        urgentTaskQueue = new LinkedList<>(); // Using LinkedList implementation for Queue
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new project to the system.
     */
    public void addProject() {
        System.out.print("Enter project name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Project name cannot be empty.");
            return;
        }
        Project newProject = new Project(name.trim());
        projectList.add(newProject);
        System.out.println("Project '" + newProject.getName() + "' added with ID: " + newProject.getId());
    }

    /**
     * Adds a task to an existing project.
     */
    public void addTaskToProject() {
        System.out.print("Enter project ID to add task to: ");
        int projectId;
        try {
            projectId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid project ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character left by nextInt()
        }


        Project project = findProjectById(projectId);
        if (project == null) {
            System.err.println("Error: Project with ID " + projectId + " not found.");
            return;
        }

        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
         if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(description.trim());
        project.addTask(newTask);
        System.out.println("Task '" + newTask.getDescription() + "' added to Project " + project.getId() + " with ID: " + newTask.getId());
    }

    /**
     * Marks a specific task within a project as complete.
     */
    public void markTaskComplete() {
        System.out.print("Enter project ID: ");
        int projectId;
         try {
            projectId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid project ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character
        }

        Project project = findProjectById(projectId);
        if (project == null) {
            System.err.println("Error: Project with ID " + projectId + " not found.");
            return;
        }

        System.out.print("Enter task ID to mark complete: ");
        int taskId;
         try {
            taskId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid task ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character
        }

        Task task = project.findTaskById(taskId);
        if (task == null) {
            System.err.println("Error: Task with ID " + taskId + " not found in Project " + projectId + ".");
            return;
        }

        if (task.isCompleted()) {
             System.out.println("Task " + taskId + " in Project " + projectId + " was already complete.");
        } else {
            task.setCompleted(true);
            System.out.println("Task " + taskId + " in Project " + projectId + " marked as complete.");
        }
    }

    /**
     * Views the status of all tasks within a specific project.
     */
    public void viewProjectStatus() {
        System.out.print("Enter project ID to view status: ");
        int projectId;
         try {
            projectId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid project ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character
        }

        Project project = findProjectById(projectId);
        if (project == null) {
            System.err.println("Error: Project with ID " + projectId + " not found.");
            return;
        }

        System.out.println(project); // Project's toString handles task listing
    }

    /**
     * Adds a task to the urgent task queue.
     */
    public void addUrgentTask() {
        System.out.print("Enter urgent task description: ");
        String description = scanner.nextLine();
         if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Urgent task description cannot be empty.");
            return;
        }
        Task urgentTask = new Task(description.trim());
        urgentTaskQueue.offer(urgentTask); // Add to the end of the queue
        System.out.println("Urgent task added to queue.");
    }

    /**
     * Processes (completes) the next task from the urgent task queue.
     */
    public void processUrgentTaskQueue() {
        System.out.println("Processing urgent task...");
        Task nextUrgentTask = urgentTaskQueue.poll(); // Retrieve and remove the head of the queue

        if (nextUrgentTask == null) {
            System.out.println("No urgent tasks in the queue.");
        } else {
            nextUrgentTask.setCompleted(true); // Mark as complete upon processing
            System.out.println("Completed urgent task: " + nextUrgentTask.getDescription() + " (ID: " + nextUrgentTask.getId() + ")");
        }
    }

    /**
     * Finds a project by its ID.
     *
     * @param projectId The ID of the project to find.
     * @return The Project object if found, null otherwise.
     */
    private Project findProjectById(int projectId) {
        for (Project project : projectList) {
            if (project.getId() == projectId) {
                return project;
            }
        }
        return null; // Project not found
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Project and Task Management System ---");
        System.out.println("1. Add New Project");
        System.out.println("2. Add Task to Project");
        System.out.println("3. Mark Task Complete");
        System.out.println("4. View Project Status");
        System.out.println("5. Add Urgent Task");
        System.out.println("6. Process Urgent Task Queue");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        // Class-wide try-catch block for the main application loop
        try {
            while (choice != 7) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline after reading int

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addProject();
                            break;
                        case 2:
                            addTaskToProject();
                            break;
                        case 3:
                            markTaskComplete();
                            break;
                        case 4:
                            viewProjectStatus();
                            break;
                        case 5:
                            addUrgentTask();
                            break;
                        case 6:
                            processUrgentTaskQueue();
                            break;
                        case 7:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number corresponding to the menu option.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue the loop
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProjectManagementSystem system = new ProjectManagementSystem();
        system.run();
    }
}
