/*
 * Exam Question #769
 * Generated on: 2025-05-12 16:38:15
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Print Job Management System**
 * 
 * **Objective:** Design and implement a simple command-line Print Job Management System. The system should allow users to add print jobs to a queue, process the next available job, and view lists of pending and completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store print jobs that are waiting to be processed (pending jobs).
 *     *   Use a `java.util.List` (implemented by `java.util.ArrayList`) to store print jobs that have been successfully processed (completed jobs).
 * 
 * 2.  **Classes:**
 *     *   Create a `PrintJob` class to represent a single print job. It must have private fields for `jobId` (int), `fileName` (String), and `pages` (int), along with appropriate public getter methods and a constructor. Include a meaningful `toString()` method.
 *     *   Create a `PrintManager` class that manages the `Queue` and `List`. It should contain the core logic for handling commands.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   The system should continuously prompt the user for commands until the "EXIT" command is entered.
 * 
 * 4.  **Commands:** Implement the following commands using a `switch` statement in the main command processing loop:
 *     *   `ADD <id> <filename> <pages>`: Adds a new `PrintJob` to the pending queue. `<id>` must be a positive integer, `<filename>` a non-empty string, and `<pages>` a positive integer.
 *     *   `PROCESS`: Takes the next job from the pending queue, simulates processing (e.g., prints a message), and moves it to the completed jobs list.
 *     *   `LIST PENDING`: Displays all jobs currently in the pending queue, in the order they will be processed.
 *     *   `LIST COMPLETED`: Displays all jobs that have been moved to the completed list.
 *     *   `EXIT`: Terminates the program.
 *     *   Any other input should be treated as an invalid command.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for the `ADD` command parameters (`id`, `filename`, `pages`). If validation fails, print an error message and do not add the job.
 *     *   Handle the case where the `PROCESS` command is issued but the pending queue is empty. Print an informative message using `System.err`.
 *     *   Handle potential exceptions during input parsing (e.g., `NumberFormatException` if the user enters non-numeric values for id or pages). Use a `try-catch` block that wraps the command processing logic in the main loop for class-wide exception handling. Print error messages using `System.err`.
 *     *   For invalid commands, print an error message using `System.err`.
 * 
 * 6.  **Output:**
 *     *   Use `System.out.println()` for prompts, command success messages, and listing jobs.
 *     *   Use `System.err.println()` for all error messages (validation errors, empty queue for process, invalid commands, exceptions).
 * 
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation where necessary.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Enter command: ADD 1 Report.pdf 10
 * Job 1 added to the queue.
 * Enter command: ADD 2 Image.jpg 2
 * Job 2 added to the queue.
 * Enter command: LIST PENDING
 * Pending Jobs:
 * [Job ID: 1, File: Report.pdf, Pages: 10]
 * [Job ID: 2, File: Image.jpg, Pages: 2]
 * Enter command: PROCESS
 * Processing job: [Job ID: 1, File: Report.pdf, Pages: 10]
 * Job 1 processed and moved to completed list.
 * Enter command: ADD 3 Presentation.pptx 25
 * Job 3 added to the queue.
 * Enter command: LIST PENDING
 * Pending Jobs:
 * [Job ID: 2, File: Image.jpg, Pages: 2]
 * [Job ID: 3, File: Presentation.pptx, Pages: 25]
 * Enter command: LIST COMPLETED
 * Completed Jobs:
 * [Job ID: 1, File: Report.pdf, Pages: 10]
 * Enter command: PROCESS
 * Processing job: [Job ID: 2, File: Image.jpg, Pages: 2]
 * Job 2 processed and moved to completed list.
 * Enter command: PROCESS
 * Processing job: [Job ID: 3, File: Presentation.pptx, Pages: 25]
 * Job 3 processed and moved to completed list.
 * Enter command: PROCESS
 * Error: No pending jobs to process.
 * Enter command: ADD -5 Invalid.txt 10
 * Error: Invalid job parameters. Job ID and Pages must be positive, Filename must not be empty.
 * Enter command: ADD 4 Valid.doc -10
 * Error: Invalid job parameters. Job ID and Pages must be positive, Filename must not be empty.
 * Enter command: ADD 5 "" 10
 * Error: Invalid job parameters. Job ID and Pages must be positive, Filename must not be empty.
 * Enter command: INVALID_COMMAND
 * Error: Unknown command. Please use ADD, PROCESS, LIST PENDING, LIST COMPLETED, or EXIT.
 * Enter command: ADD 6 Correct.pdf ABC
 * Error during command execution: For input string: "ABC"
 * Enter command: EXIT
 * Exiting Print Job Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements the Print Job Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Encapsulates job data (`jobId`, `fileName`, `pages`) using private fields.
 *     *   Provides public getter methods to access the data.
 *     *   Includes a constructor to initialize the job object.
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Manages the core data structures:
 *         *   `pendingJobs`: Declared as `Queue<PrintJob>` and instantiated as `LinkedList<PrintJob>`. `LinkedList` is a common implementation of `Queue` providing FIFO behavior suitable for a job queue.
 *         *   `completedJobs`: Declared as `List<PrintJob>` and instantiated as `ArrayList<PrintJob>`. `ArrayList` is a dynamic array implementation of `List`, suitable for storing processed items. Using `List` as the type demonstrates polymorphism.
 *     *   `scanner`: A `Scanner` object is created to read input from `System.in`.
 *     *   **`addJob` Method:**
 *         *   Takes job details as parameters.
 *         *   Performs input validation: checks if `id` and `pages` are positive and `fileName` is not empty or just whitespace.
 *         *   Uses `System.err.println()` for validation errors.
 *         *   If validation passes, it creates a `PrintJob` object and adds it to the `pendingJobs` queue using `offer()`. `offer()` is generally preferred over `add()` for queues as it doesn't throw an exception if the queue is full (though `LinkedList` is unbounded).
 *     *   **`processNextJob` Method:**
 *         *   Uses `pendingJobs.poll()` to retrieve and remove the job at the head of the queue. `poll()` returns `null` if the queue is empty, which is handled gracefully with a `System.err` message.
 *         *   If a job is retrieved, it prints a processing message using `System.out` and then adds the job to the `completedJobs` list using `add()`.
 *     *   **`listPendingJobs` Method:**
 *         *   Iterates through the `pendingJobs` queue using an enhanced for loop. This iterates over the elements without removing them, which is appropriate for listing.
 *         *   Prints each job's `toString()` representation using `System.out`.
 *     *   **`listCompletedJobs` Method:**
 *         *   Iterates through the `completedJobs` list.
 *         *   Prints each job's `toString()` representation using `System.out`.
 *     *   **`run` Method:**
 *         *   Contains the main application loop controlled by the `running` boolean.
 *         *   Prompts the user for input using `System.out.print()`.
 *         *   Reads the entire line of input using `scanner.nextLine()`.
 *         *   Splits the input line into parts based on whitespace.
 *         *   Uses a `switch` statement on the uppercase version of the first part (`command`) to determine the action.
 *         *   **Class-wide Exception Handling:** The entire `switch` block (which contains the core command execution logic) is wrapped in a `try-catch (Exception e)` block. This demonstrates a "class-wide" approach where a single handler catches potential runtime errors (like `NumberFormatException` if `Integer.parseInt` fails, or other unexpected issues) occurring during command processing. Error messages are printed using `System.err`. A specific `catch (NumberFormatException e)` is included first for more targeted handling of common parsing errors, followed by the general `Exception` catch.
 *         *   Handles the specific command logic within each `case`, including checking for the correct number of parameters.
 *         *   Handles the `LIST` command using a nested `switch` statement for `PENDING` or `COMPLETED`.
 *         *   Sets `running` to `false` for the `EXIT` command.
 *         *   Prints an error message using `System.err` for unknown commands.
 *         *   Closes the `scanner` when the loop terminates.
 *     *   **`main` Method:**
 *         *   The entry point of the application.
 *         *   Creates an instance of `PrintManager` and calls its `run()` method to start the system.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated structure, demonstrating advanced understanding of Java programming concepts including data structures, object-oriented design, input/output, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Required for Scanner issues, though general Exception might catch it

/**
 * Represents a single print job with an ID, filename, and number of pages.
 */
class PrintJob {
    private final int jobId;
    private final String fileName;
    private final int pages;

    /**
     * Constructs a new PrintJob.
     *
     * @param jobId    The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the file.
     */
    public PrintJob(int jobId, String fileName, int pages) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.pages = pages;
    }

    /**
     * Gets the job ID.
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the file name.
     * @return The file name.
     */
    public String getFileName() {
        return fileName;
    }

    /**
     * Gets the number of pages.
     * @return The number of pages.
     */
    public int getPages() {
        return pages;
    }

    /**
     * Returns a string representation of the PrintJob.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "[Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages + "]";
    }
}

/**
 * Manages the queue of pending print jobs and a list of completed jobs.
 * Handles user commands, input validation, and error reporting.
 */
public class PrintManager {
    // Queue for jobs waiting to be processed (FIFO)
    private Queue<PrintJob> pendingJobs;
    // List for jobs that have been processed
    private List<PrintJob> completedJobs;
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing the job queues and scanner.
     */
    public PrintManager() {
        // Use LinkedList as an implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedJobs = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the pending queue after validating parameters.
     *
     * @param id       The job ID.
     * @param fileName The file name.
     * @param pages    The number of pages.
     */
    public void addJob(int id, String fileName, int pages) {
        // Input validation
        if (id <= 0 || fileName == null || fileName.trim().isEmpty() || pages <= 0) {
            System.err.println("Error: Invalid job parameters. Job ID and Pages must be positive, Filename must not be empty.");
            return;
        }

        PrintJob newJob = new PrintJob(id, fileName.trim(), pages);
        pendingJobs.offer(newJob); // offer is preferred over add for queues
        System.out.println("Job " + id + " added to the queue.");
    }

    /**
     * Processes the next job from the pending queue.
     * Removes the job from the queue and adds it to the completed list.
     */
    public void processNextJob() {
        PrintJob jobToProcess = pendingJobs.poll(); // poll retrieves and removes the head of the queue

        if (jobToProcess == null) {
            System.err.println("Error: No pending jobs to process.");
        } else {
            System.out.println("Processing job: " + jobToProcess);
            // Simulate processing time if needed (optional)
            // try { Thread.sleep(100); } catch (InterruptedException e) {}
            completedJobs.add(jobToProcess);
            System.out.println("Job " + jobToProcess.getJobId() + " processed and moved to completed list.");
        }
    }

    /**
     * Lists all jobs currently in the pending queue.
     */
    public void listPendingJobs() {
        System.out.println("Pending Jobs:");
        if (pendingJobs.isEmpty()) {
            System.out.println("(No pending jobs)");
        } else {
            // Iterate through the queue without removing elements
            for (PrintJob job : pendingJobs) {
                System.out.println(job);
            }
        }
    }

    /**
     * Lists all jobs that have been moved to the completed list.
     */
    public void listCompletedJobs() {
        System.out.println("Completed Jobs:");
        if (completedJobs.isEmpty()) {
            System.out.println("(No completed jobs)");
        } else {
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
    }

    /**
     * Runs the main command processing loop.
     * Reads user input, parses commands, and calls appropriate methods.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Print Job Management System started. Enter commands (ADD, PROCESS, LIST PENDING, LIST COMPLETED, EXIT).");

        boolean running = true;
        while (running) {
            System.out.print("Enter command: ");
            String inputLine = scanner.nextLine().trim();
            String[] parts = inputLine.split("\\s+", 4); // Split into up to 4 parts

            if (parts.length == 0 || parts[0].isEmpty()) {
                continue; // Skip empty input
            }

            String command = parts[0].toUpperCase(); // Convert command to uppercase for case-insensitivity

            // Class-wide exception handling for command execution
            try {
                switch (command) {
                    case "ADD":
                        if (parts.length == 4) {
                            int id = Integer.parseInt(parts[1]);
                            String fileName = parts[2];
                            int pages = Integer.parseInt(parts[3]);
                            addJob(id, fileName, pages);
                        } else {
                            System.err.println("Error: ADD command requires parameters: ADD <id> <filename> <pages>");
                        }
                        break;

                    case "PROCESS":
                        if (parts.length == 1) {
                            processNextJob();
                        } else {
                             System.err.println("Error: PROCESS command does not take parameters.");
                        }
                        break;

                    case "LIST":
                        if (parts.length == 2) {
                            String listType = parts[1].toUpperCase();
                            switch (listType) {
                                case "PENDING":
                                    listPendingJobs();
                                    break;
                                case "COMPLETED":
                                    listCompletedJobs();
                                    break;
                                default:
                                    System.err.println("Error: Invalid LIST type. Use LIST PENDING or LIST COMPLETED.");
                                    break;
                            }
                        } else {
                             System.err.println("Error: LIST command requires a type: LIST PENDING or LIST COMPLETED.");
                        }
                        break;

                    case "EXIT":
                        if (parts.length == 1) {
                             running = false;
                             System.out.println("Exiting Print Job Management System.");
                        } else {
                            System.err.println("Error: EXIT command does not take parameters.");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please use ADD, PROCESS, LIST PENDING, LIST COMPLETED, or EXIT.");
                        break;
                }
            } catch (NumberFormatException e) {
                System.err.println("Error during command execution: Invalid number format for ID or Pages. " + e.getMessage());
            } catch (Exception e) {
                // General catch-all for unexpected errors during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Main method to start the Print Job Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run();
    }
}
