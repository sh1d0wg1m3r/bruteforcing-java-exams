/*
 * Exam Question #424
 * Generated on: 2025-05-11 23:09:11
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Delivery Routing Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation of a package delivery dispatch system. The system manages incoming packages waiting to be assigned to delivery routes and allows for the creation and inspection of these routes.
 * 
 * Your program should allow a dispatcher to perform the following operations via a command-line interface:
 * 
 * 1.  **Add Package:** Add a new package to a waiting queue. Each package has a unique ID (String) and a destination address (String).
 * 2.  **Dispatch Package:** Take the next package from the waiting queue. The dispatcher must then specify an existing route ID (String) to which the package is conceptually assigned (for this simulation, just remove it from the queue and confirm dispatch with the assigned route ID). Handle the case where the queue is empty.
 * 3.  **List Waiting Packages:** Display all packages currently in the waiting queue in the order they were added.
 * 4.  **Create Route:** Define a new delivery route with a unique ID (String) and a sequence of initial stop addresses (Strings). A route must have at least one stop.
 * 5.  **Show Route:** Display the sequence of stops for a given route ID. Handle the case where the route ID does not exist.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must strictly adhere to the following requirements:
 * 
 * 1.  Use `java.util.Queue` (specifically `LinkedList` as the implementation) to manage the waiting packages.
 * 2.  Use `java.util.ArrayList` to store the collection of available delivery routes.
 * 3.  Use `java.util.List` as the type for the stops within a `DeliveryRoute` object (implemented using `ArrayList`).
 * 4.  Use `java.util.Scanner` to read user input from the console.
 * 5.  Use a `switch` statement to process user commands.
 * 6.  Use `System.err` exclusively for printing error messages (e.g., invalid input, queue empty, route not found).
 * 7.  Use `System.out` exclusively for printing normal output (prompts, confirmations, lists, route details).
 * 8.  Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during command processing (e.g., input mismatches, though Scanner's methods handle some of this, a general catch for the main loop is required).
 * 9.  Implement proper encapsulation for your classes (private fields, public methods).
 * 10. Use meaningful variable and method names.
 * 11. Include appropriate comments to explain complex logic.
 * 12. Implement basic input validation (e.g., ensuring IDs/addresses are not empty, checking for route existence).
 * 13. Ensure resources like `Scanner` are closed properly.
 * 
 * **Classes:**
 * 
 * You should define at least the following classes:
 * 
 * *   `Package`: Represents a package with `packageId` and `destinationAddress`.
 * *   `DeliveryRoute`: Represents a route with `routeId` and a `List<String>` of stops.
 * *   `DeliverySystem`: The main class containing the `main` method and managing the queue of packages and the list of routes. This class will handle the user interaction loop.
 * 
 * **Input Format:**
 * 
 * Commands will be entered as follows (case-insensitive):
 * 
 * *   `ADD_PACKAGE <packageId> <destinationAddress>`
 * *   `DISPATCH_PACKAGE <routeId>` (Reads routeId on the next line after confirmation)
 * *   `LIST_QUEUE`
 * *   `CREATE_ROUTE <routeId>` (Reads stops on subsequent lines, one per line, until an empty line is entered. Must have at least one stop.)
 * *   `SHOW_ROUTE <routeId>`
 * *   `EXIT`
 * 
 * **Expected Output:**
 * 
 * *   Clear prompts for input.
 * *   Confirmation messages for successful operations.
 * *   Lists of packages or route stops formatted clearly.
 * *   Error messages printed to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Enter command: ADD_PACKAGE P001 123 Main St
 * Package P001 added to queue.
 * Enter command: ADD_PACKAGE P002 456 Oak Ave
 * Package P002 added to queue.
 * Enter command: LIST_QUEUE
 * Waiting Packages:
 * - P001 (Destination: 123 Main St)
 * - P002 (Destination: 456 Oak Ave)
 * Enter command: CREATE_ROUTE R1
 * Enter stops (one per line, empty line to finish):
 * Stop A
 * Stop B
 * Stop C
 * 
 * Route R1 created with 3 stops.
 * Enter command: SHOW_ROUTE R1
 * Route R1 Stops:
 * 1. Stop A
 * 2. Stop B
 * 3. Stop C
 * Enter command: DISPATCH_PACKAGE
 * Next package P001 (Destination: 123 Main St) ready for dispatch. Enter Route ID: R1
 * Package P001 dispatched and assigned to Route R1.
 * Enter command: LIST_QUEUE
 * Waiting Packages:
 * - P002 (Destination: 456 Oak Ave)
 * Enter command: EXIT
 * Exiting Delivery System.
 * ```
 * 
 * Your task is to implement the `Package`, `DeliveryRoute`, and `DeliverySystem` classes along with the main logic in `DeliverySystem.main` to fulfill all requirements.
 *
 * EXPLANATION:
 * This solution implements a `DeliverySystem` that simulates basic package dispatch using core Java collections and control flow structures as required.
 * 
 * 1.  **`Package` Class:**
 *     *   Encapsulates package data (`packageId`, `destinationAddress`) with private fields.
 *     *   Provides public getter methods (`getPackageId`, `getDestinationAddress`).
 *     *   Includes basic input validation in the constructor, throwing `IllegalArgumentException` for null or empty strings.
 *     *   Provides a helpful `toString()` method for easy printing.
 * 
 * 2.  **`DeliveryRoute` Class:**
 *     *   Encapsulates route data (`routeId`, `stops`).
 *     *   Uses `List<String>` for `stops`, demonstrating the use of the `List` interface.
 *     *   Initializes `stops` with an `ArrayList`, fulfilling the `ArrayList` requirement.
 *     *   Provides a public getter for `routeId`.
 *     *   `addStop` method adds a stop to the list with validation.
 *     *   `getStops` returns a *defensive copy* of the stops list (`new ArrayList<>(stops)`) to prevent external code from modifying the route's internal stop list directly, adhering to good encapsulation practices.
 *     *   `hasStops` checks if the route has any stops, used during route creation validation.
 *     *   Provides a formatted `toString()` for displaying route details.
 *     *   Constructor validates the `routeId`.
 * 
 * 3.  **`DeliverySystem` Class:**
 *     *   **State:** Holds the core data structures:
 *         *   `waitingPackagesQueue`: A `Queue<Package>` implemented using `LinkedList`. This naturally handles packages in a First-In, First-Out (FIFO) manner, suitable for a waiting queue.
 *         *   `availableRoutes`: An `ArrayList<DeliveryRoute>` to store all defined routes.
 *     *   **Constructor:** Takes a `Scanner` instance, allowing the main method to manage the `Scanner` lifecycle.
 *     *   **Operations (`addPackage`, `dispatchNextPackage`, `listWaitingPackages`, `createRoute`, `showRoute`):**
 *         *   Each method implements one of the required functionalities.
 *         *   They interact with the `waitingPackagesQueue` and `availableRoutes` collections.
 *         *   `addPackage` uses `queue.offer()` which is a safe way to add to a queue.
 *         *   `dispatchNextPackage` uses `queue.peek()` to look at the next package without removing it first, allowing for validation (like finding the route) before permanently removing it with `queue.poll()`. This handles the empty queue case gracefully.
 *         *   `listWaitingPackages` iterates through the queue using `forEach` without removing elements.
 *         *   `createRoute` handles reading multiple lines for stops using a loop and checks for an empty line to terminate input. It validates that at least one stop is added and that the route ID is unique.
 *         *   `showRoute` uses the `findRouteById` helper and prints the route's `toString()`.
 *     *   **`findRouteById`:** A private helper method to search the `availableRoutes` list for a route by its ID.
 *     *   **`run` Method:**
 *         *   Contains the main application loop.
 *         *   Reads user commands line by line using the `Scanner`.
 *         *   Splits the input line to extract the command and arguments.
 *         *   Uses a `switch` statement on the command (converted to uppercase for case-insensitivity) to direct execution to the appropriate operation method. This fulfills the `switch` requirement.
 *         *   Includes basic validation for the number of arguments for each command, printing errors to `System.err`.
 *         *   The core of the `while` loop (processing a single command) is wrapped in a `try-catch(Exception e)` block. This demonstrates class-wide exception handling for unexpected errors during command execution, printing a generic error message to `System.err`.
 *         *   Handles the "EXIT" command to terminate the loop.
 *         *   Includes a check for `scanner.hasNextLine()` to gracefully exit if the input stream is closed.
 *     *   **`main` Method:**
 *         *   The entry point of the program.
 *         *   Uses a `try-with-resources` block (`try (Scanner scanner = new Scanner(System.in))`) to ensure the `Scanner` resource is automatically closed when the block is exited, preventing resource leaks.
 *         *   Creates an instance of `DeliverySystem` and calls its `run` method.
 *         *   Includes a `catch` block outside the `try-with-resources` to handle potential errors during the initial setup or Scanner creation, printing to `System.err`.
 * 
 * 4.  **Error Handling and Output:**
 *     *   `System.err.println()` is used for all error messages (input validation failures, queue empty, route not found, unknown commands, unexpected exceptions).
 *     *   `System.out.println()` is used for all normal output (prompts, confirmations, lists, route details).
 *     *   Input validation is performed at multiple levels: in class constructors (`Package`, `DeliveryRoute`), in operation methods (`addPackage`, `createRoute`, `showRoute`, `dispatchNextPackage`), and by checking command arguments in the `run` method.
 * 
 * This solution effectively integrates all required Java components within a practical simulation, demonstrating understanding of collections, control flow, object-oriented principles (encapsulation), and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Useful for queue operations, though poll is safer

// Represents a package waiting for delivery
class Package {
    private String packageId;
    private String destinationAddress;

    public Package(String packageId, String destinationAddress) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destinationAddress == null || destinationAddress.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination address cannot be null or empty.");
        }
        this.packageId = packageId.trim();
        this.destinationAddress = destinationAddress.trim();
    }

    public String getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    @Override
    public String toString() {
        return packageId + " (Destination: " + destinationAddress + ")";
    }
}

// Represents a delivery route with a sequence of stops
class DeliveryRoute {
    private String routeId;
    private List<String> stops; // Use List interface, implemented by ArrayList

    public DeliveryRoute(String routeId) {
        if (routeId == null || routeId.trim().isEmpty()) {
            throw new IllegalArgumentException("Route ID cannot be null or empty.");
        }
        this.routeId = routeId.trim();
        this.stops = new ArrayList<>(); // Use ArrayList for the implementation
    }

    public String getRouteId() {
        return routeId;
    }

    public List<String> getStops() {
        // Return a defensive copy to prevent external modification
        return new ArrayList<>(stops);
    }

    public void addStop(String stop) {
        if (stop == null || stop.trim().isEmpty()) {
            throw new IllegalArgumentException("Stop address cannot be null or empty.");
        }
        this.stops.add(stop.trim());
    }

    public boolean hasStops() {
        return !stops.isEmpty();
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder("Route " + routeId + " Stops:\n");
        if (stops.isEmpty()) {
            sb.append("  (No stops defined)");
        } else {
            for (int i = 0; i < stops.size(); i++) {
                sb.append("  ").append(i + 1).append(". ").append(stops.get(i)).append("\n");
            }
        }
        return sb.toString();
    }
}

// Main class managing the delivery system operations
public class DeliverySystem {

    // Use Queue interface, implemented by LinkedList
    private Queue<Package> waitingPackagesQueue = new LinkedList<>();

    // Use ArrayList to store DeliveryRoute objects
    private ArrayList<DeliveryRoute> availableRoutes = new ArrayList<>();

    private Scanner scanner;

    public DeliverySystem(Scanner scanner) {
        this.scanner = scanner;
    }

    // --- Operations ---

    public void addPackage(String packageId, String destination) {
        try {
            Package newPackage = new Package(packageId, destination);
            if (waitingPackagesQueue.offer(newPackage)) { // offer is safer than add, returns false on failure
                System.out.println("Package " + newPackage.getPackageId() + " added to queue.");
            } else {
                System.err.println("Error: Could not add package " + packageId + " to queue.");
            }
        } catch (IllegalArgumentException e) {
            System.err.println("Input Error: " + e.getMessage());
        }
    }

    public void dispatchNextPackage() {
        Package packageToDispatch = waitingPackagesQueue.peek(); // Use peek to check without removing
        if (packageToDispatch == null) {
            System.err.println("Error: No packages waiting in the queue.");
            return;
        }

        System.out.println("Next package " + packageToDispatch + " ready for dispatch. Enter Route ID:");
        String routeId = scanner.nextLine().trim();

        if (routeId.isEmpty()) {
            System.err.println("Input Error: Route ID cannot be empty.");
            return;
        }

        DeliveryRoute targetRoute = findRouteById(routeId);

        if (targetRoute == null) {
            System.err.println("Error: Route with ID '" + routeId + "' not found.");
            // Optionally put the package back if peek was used, but poll is better here
            // If using poll() below, no need to put back.
        } else {
            // Now actually remove the package as we have a valid route
            packageToDispatch = waitingPackagesQueue.poll(); // Use poll to remove and get the head, returns null if empty
            if (packageToDispatch != null) {
                System.out.println("Package " + packageToDispatch.getPackageId() + " dispatched and assigned to Route " + targetRoute.getRouteId() + ".");
            } else {
                 // This case should ideally not happen right after peek unless queue modified concurrently
                 System.err.println("Internal Error: Failed to retrieve package from queue after validation.");
            }
        }
    }

    public void listWaitingPackages() {
        System.out.println("Waiting Packages:");
        if (waitingPackagesQueue.isEmpty()) {
            System.out.println("  (Queue is empty)");
        } else {
            // Iterate without removing elements
            waitingPackagesQueue.forEach(pkg -> System.out.println("  - " + pkg));
        }
    }

    public void createRoute(String routeId) {
         try {
            DeliveryRoute newRoute = new DeliveryRoute(routeId);

            if (findRouteById(routeId) != null) {
                 System.err.println("Error: Route with ID '" + routeId + "' already exists.");
                 // Consume remaining input for stops if any
                 System.out.println("Enter stops (one per line, empty line to finish):");
                 while (scanner.hasNextLine()) {
                     String stopLine = scanner.nextLine();
                     if (stopLine.trim().isEmpty()) break;
                 }
                 return;
            }

            System.out.println("Enter stops (one per line, empty line to finish):");
            String stop;
            int stopCount = 0;
            while (scanner.hasNextLine()) {
                stop = scanner.nextLine();
                if (stop.trim().isEmpty()) {
                    break; // Stop reading stops on empty line
                }
                try {
                    newRoute.addStop(stop);
                    stopCount++;
                } catch (IllegalArgumentException e) {
                    System.err.println("Input Error adding stop: " + e.getMessage() + ". Skipping this stop.");
                }
            }

            if (stopCount == 0) {
                System.err.println("Error: Cannot create route '" + routeId + "'. A route must have at least one stop.");
            } else {
                availableRoutes.add(newRoute);
                System.out.println("Route " + newRoute.getRouteId() + " created with " + stopCount + " stops.");
            }

        } catch (IllegalArgumentException e) {
             System.err.println("Input Error: " + e.getMessage());
             // If routeId was invalid, subsequent stop reading isn't needed, but let's be safe
             System.out.println("Enter stops (one per line, empty line to finish):");
             while (scanner.hasNextLine()) {
                 String stopLine = scanner.nextLine();
                 if (stopLine.trim().isEmpty()) break;
             }
        }
    }

    public void showRoute(String routeId) {
        if (routeId == null || routeId.trim().isEmpty()) {
             System.err.println("Input Error: Route ID cannot be empty.");
             return;
        }
        DeliveryRoute route = findRouteById(routeId);
        if (route == null) {
            System.err.println("Error: Route with ID '" + routeId + "' not found.");
        } else {
            System.out.print(route.toString()); // DeliveryRoute.toString() formats the output
        }
    }

    // Helper method to find a route by ID
    private DeliveryRoute findRouteById(String routeId) {
        for (DeliveryRoute route : availableRoutes) {
            if (route.getRouteId().equalsIgnoreCase(routeId.trim())) {
                return route;
            }
        }
        return null; // Not found
    }

    // --- Main Application Loop ---

    public void run() {
        System.out.println("Delivery System Simulation Started. Type 'EXIT' to quit.");
        System.out.println("Available commands: ADD_PACKAGE <id> <dest>, DISPATCH_PACKAGE, LIST_QUEUE, CREATE_ROUTE <id>, SHOW_ROUTE <id>, EXIT");

        boolean running = true;
        while (running) {
            System.out.print("Enter command: ");
            if (!scanner.hasNextLine()) {
                 running = false; // Handle end of input stream
                 System.out.println("\nEnd of input detected. Exiting.");
                 break;
            }

            String line = scanner.nextLine().trim();
            if (line.isEmpty()) {
                continue; // Skip empty lines
            }

            String[] parts = line.split(" ", 3); // Split into command and up to 2 arguments
            String command = parts[0].toUpperCase();

            // Class-wide exception handling for the main command loop
            try {
                switch (command) {
                    case "ADD_PACKAGE":
                        if (parts.length < 3) {
                            System.err.println("Input Error: ADD_PACKAGE requires Package ID and Destination.");
                        } else {
                            addPackage(parts[1], parts[2]);
                        }
                        break;

                    case "DISPATCH_PACKAGE":
                        if (parts.length > 1) {
                             System.err.println("Input Error: DISPATCH_PACKAGE does not take arguments on the command line.");
                        }
                        dispatchNextPackage(); // This method prompts for route ID separately
                        break;

                    case "LIST_QUEUE":
                        if (parts.length > 1) {
                             System.err.println("Input Error: LIST_QUEUE does not take arguments.");
                        }
                        listWaitingPackages();
                        break;

                    case "CREATE_ROUTE":
                         if (parts.length < 2) {
                             System.err.println("Input Error: CREATE_ROUTE requires a Route ID.");
                         } else if (parts.length > 2) {
                              System.err.println("Input Error: CREATE_ROUTE only takes Route ID on the command line.");
                         }
                        createRoute(parts[1]); // This method prompts for stops separately
                        break;

                    case "SHOW_ROUTE":
                        if (parts.length < 2) {
                            System.err.println("Input Error: SHOW_ROUTE requires a Route ID.");
                        } else if (parts.length > 2) {
                            System.err.println("Input Error: SHOW_ROUTE only takes Route ID on the command line.");
                        } else {
                            showRoute(parts[1]);
                        }
                        break;

                    case "EXIT":
                        running = false;
                        System.out.println("Exiting Delivery System.");
                        break;

                    default:
                        System.err.println("Unknown command: " + command);
                        System.err.println("Available commands: ADD_PACKAGE, DISPATCH_PACKAGE, LIST_QUEUE, CREATE_ROUTE, SHOW_ROUTE, EXIT");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging purposes
            }
        }
    }

    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            DeliverySystem system = new DeliverySystem(scanner);
            system.run();
        } catch (Exception e) {
             // Catch potential exceptions during Scanner initialization or system setup
             System.err.println("A critical error occurred during system startup: " + e.getMessage());
             // e.printStackTrace(); // Uncomment for debugging
        }
    }
}
