/*
 * Exam Question #710
 * Generated on: 2025-05-12 16:29:03
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation of a task processing system. The system manages tasks submitted by users, processes them in the order they were received, and keeps a history of all tasks, noting their final status (Completed or Failed).
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task.
 *     *   It must have private fields for `id` (an integer, unique), `description` (a String), and `status` (an enum, see below).
 *     *   Include a constructor to initialize a task with an ID and description. The initial status must be `PENDING`.
 *     *   Include public getter methods for all fields.
 *     *   Include a method `simulateProcessing()` that simulates the task being processed. This method should:
 *         *   Change the task's status to `PROCESSING`.
 *         *   Simulate work (e.g., using `Thread.sleep` for a short duration, though this might be too slow for an exam, so simply print a message).
 *         *   Randomly decide if the task succeeds (e.g., 80% chance) or fails (e.g., 20% chance).
 *         *   If it succeeds, change the status to `COMPLETED`.
 *         *   If it fails, change the status to `FAILED` and print an error message to `System.err` indicating the failure.
 *         *   This method should be designed such that the main processing logic can call it and handle its outcome. It doesn't necessarily *throw* an exception itself, but its result (status change) indicates success or failure.
 * 
 * 2.  **TaskStatus Enum:** Create an enum `TaskStatus` with the following values: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 * 
 * 3.  **Task Processing System:** Create a class named `TaskProcessingSystem` to manage the tasks.
 *     *   It must have a private `Queue<Task>` to store tasks that are waiting to be processed (`pendingTasks`). Use a suitable `Queue` implementation like `LinkedList`.
 *     *   It must have a private `List<Task>` (use `ArrayList`) to store a history of all tasks that have been processed (either completed or failed) (`taskHistory`).
 *     *   Include a private counter for generating unique task IDs.
 *     *   Include a public method `submitTask(String description)`:
 *         *   Validates that the description is not null or empty. If invalid, prints an error to `System.err` and does not add the task.
 *         *   Creates a new `Task` object with a unique ID and the given description.
 *         *   Adds the new task to the `pendingTasks` queue.
 *         *   Prints a confirmation message to `System.out`.
 *     *   Include a public method `processNextTask()`:
 *         *   Checks if the `pendingTasks` queue is empty. If so, prints a message to `System.out` and returns.
 *         *   Retrieves and removes the next task from the `pendingTasks` queue.
 *         *   Calls the task's `simulateProcessing()` method.
 *         *   After `simulateProcessing()` completes, adds the task to the `taskHistory` list.
 *         *   Prints the final status of the processed task to `System.out`.
 *     *   Include public methods `getPendingTasks()` and `getTaskHistory()` that return a `List<Task>` representing the current pending tasks and the task history, respectively. These methods should return copies or unmodifiable views to protect internal state (though for exam simplicity, returning the collection reference might be acceptable if noted). Returning `List<Task>` is required.
 * 
 * 4.  **Main Application:** Create a main class (e.g., `TaskApp`) with a `main` method to run the system.
 *     *   Instantiate `TaskProcessingSystem` and `Scanner`.
 *     *   Implement a command-line interface loop that presents the user with options:
 *         *   1. Submit New Task
 *         *   2. Process Next Task
 *         *   3. View Pending Tasks
 *         *   4. View Task History
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Read user input using `Scanner`.
 *     *   Call the appropriate methods of the `TaskProcessingSystem` instance based on the user's choice.
 *     *   Display output clearly using `System.out`.
 *     *   Handle invalid menu choices using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command loop to catch any unexpected errors during execution and print an error message to `System.err`. Ensure the `Scanner` is closed properly.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`.
 * *   You must use a `switch` statement.
 * *   You must use `System.err` for all error output and `System.out` for all normal output (prompts, results, status updates).
 * *   You must use `try-catch` blocks for exception handling, including a general one around the main application loop.
 * *   Adhere to best practices: encapsulation, meaningful names, comments, basic input validation (for task description and menu choice).
 * 
 * **Expected Output (Example Flow):**
 * 
 * ```
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Clean the room
 * Task 1 submitted: Clean the room
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Do laundry
 * Task 2 submitted: Do laundry
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task 1 [PENDING]: Clean the room
 * Task 2 [PENDING]: Do laundry
 * ---------------------
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 2
 * Processing Task 1: Clean the room...
 * Task 1 processed. Status: COMPLETED
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 2
 * Processing Task 2: Do laundry...
 * Task 2 processed. Status: FAILED
 * Error processing Task 2: Do laundry failed.
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 4
 * --- Task History ---
 * Task 1 [COMPLETED]: Clean the room
 * Task 2 [FAILED]: Do laundry
 * --------------------
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * Task Processing System Menu:
 * 1. Submit New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation and usage of all required Java components.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Correct logic for task submission, processing, and history tracking.
 * *   Effective use of `switch` for control flow.
 * *   Proper handling of input validation and errors using `System.err` and `System.out`.
 * *   Implementation of `try-catch` for exception handling as specified.
 * *   Code readability, comments, and adherence to best practices.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple task processing system, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in, providing type safety and readability compared to using integers or strings for status.
 * 2.  **`Task` Class:**
 *     *   Encapsulates the data related to a single task (`id`, `description`, `status`) using private fields and public getters.
 *     *   The `simulateProcessing()` method demonstrates state change (`PENDING` -> `PROCESSING` -> `COMPLETED`/`FAILED`) and includes a simulated failure condition using `Random`. It prints status updates to `System.out` and error messages on failure to `System.err`, as required. The `Thread.sleep` is included to make the "processing" feel more real, though it's commented as optional for exam time constraints.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 3.  **`TaskProcessingSystem` Class:**
 *     *   Manages the collection of tasks using appropriate data structures:
 *         *   `Queue<Task> pendingTasks`: A `LinkedList` is used here because it efficiently implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior essential for processing tasks in submission order (`offer` to add, `poll` to retrieve and remove).
 *         *   `List<Task> taskHistory`: An `ArrayList` is used to store tasks after they have been processed. `ArrayList` is suitable for storing and iterating over a collection where elements are added sequentially and accessed by index or iteration.
 *     *   `submitTask()`: Adds a new task to the `pendingTasks` queue after basic input validation (checking for empty description) and increments a counter (`nextTaskId`) to ensure unique IDs. It uses `System.err` for validation errors and `System.out` for success messages.
 *     *   `processNextTask()`: Removes the task at the front of the `pendingTasks` queue using `poll()`, calls its `simulateProcessing()` method, and then moves the task to the `taskHistory` list. It handles the case where the queue is empty.
 *     *   `getPendingTasks()` and `getTaskHistory()`: These methods return `List<Task>` as required by the problem. Returning `new ArrayList<>(collection)` creates a new list containing the elements, which is a good practice to prevent external code from modifying the internal state of the `TaskProcessingSystem`'s collections directly.
 * 4.  **`TaskApp` Class (Main Application):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   Creates instances of `TaskProcessingSystem` and `Scanner`.
 *     *   Implements the main application loop using a `while` loop and a `boolean running` flag.
 *     *   Uses a `switch` statement to handle the user's integer input for menu navigation. Each case corresponds to a menu option and calls the appropriate method in the `TaskProcessingSystem`.
 *     *   Input validation for the menu choice is done by checking `scanner.hasNextInt()` and handling the invalid input case in the `default` block of the `switch`, printing an error to `System.err`. The `scanner.nextLine()` call after reading the integer is crucial to consume the newline character left in the input buffer.
 *     *   **Class-wide Exception Handling:** A `try-catch (Exception e)` block wraps the entire `while` loop. This catches any unexpected runtime exceptions that might occur during the execution of the main application logic (e.g., issues with scanner, unexpected null pointers not handled elsewhere) and prints an error message and stack trace to `System.err`.
 *     *   A `finally` block ensures that the `Scanner` resource is closed when the application loop terminates or an exception occurs, preventing resource leaks.
 *     *   `System.out` is used for all user prompts, menu display, success messages, and task listing. `System.err` is strictly used for error messages (invalid input, task failure, unexpected exceptions).
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a structured, object-oriented design that simulates a real-world task management process, demonstrating advanced understanding of Java programming concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Random; // Needed for random failure simulation

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    // Constructor
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // Initial status is PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Method to simulate task processing
    public void simulateProcessing() {
        this.status = TaskStatus.PROCESSING;
        System.out.println("Processing Task " + id + ": " + description + "...");

        // Simulate some work (optional, can be removed for faster execution)
        try {
            Thread.sleep(100); // Simulate 100ms processing time
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // Restore interrupt status
            System.err.println("Task processing interrupted.");
        }

        // Simulate success or failure (e.g., 80% success chance)
        Random random = new Random();
        if (random.nextDouble() < 0.8) {
            this.status = TaskStatus.COMPLETED;
        } else {
            this.status = TaskStatus.FAILED;
            System.err.println("Error processing Task " + id + ": " + description + " failed.");
        }
    }

    @Override
    public String toString() {
        return "Task " + id + " [" + status + "]: " + description;
    }
}

// Manages the queue of pending tasks and the history of processed tasks
class TaskProcessingSystem {
    private Queue<Task> pendingTasks;
    private List<Task> taskHistory;
    private int nextTaskId; // Counter for unique task IDs

    // Constructor
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.taskHistory = new ArrayList<>();   // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    // Submits a new task to the system
    public void submitTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // Add task to the end of the queue
        System.out.println("Task " + newTask.getId() + " submitted: " + newTask.getDescription());
    }

    // Processes the next task in the queue
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
            return;
        }

        Task taskToProcess = pendingTasks.poll(); // Get and remove the head of the queue
        if (taskToProcess != null) {
            taskToProcess.simulateProcessing(); // Simulate the work
            taskHistory.add(taskToProcess);     // Add the processed task to history
            System.out.println("Task " + taskToProcess.getId() + " processed. Status: " + taskToProcess.getStatus());
        }
    }

    // Returns a list of tasks currently pending
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This provides a snapshot and protects the internal queue state
        return new ArrayList<>(pendingTasks);
    }

    // Returns a list of all tasks that have been processed
    public List<Task> getTaskHistory() {
        // Return a copy of the history list
        return new ArrayList<>(taskHistory);
    }
}

// Main application class
public class TaskApp {

    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling around the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input line
                    scanner.next();
                    choice = -1; // Set to invalid choice
                }
                // Consume the rest of the line after reading the integer choice
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        system.submitTask(description);
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        List<Task> pending = system.getPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No tasks pending.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;
                    case 4:
                        List<Task> history = system.getTaskHistory();
                        System.out.println("--- Task History ---");
                        if (history.isEmpty()) {
                            System.out.println("No task history available.");
                        } else {
                            for (Task task : history) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("--------------------");
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Submit New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Task History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }
}
