/*
 * Exam Question #1029
 * Generated on: 2025-05-12 17:14:53
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing Simulator
 * 
 * **Objective:** Design and implement a simple console-based application that simulates a task processing system. The system manages tasks that are added to a queue for processing and then moved to a history list upon completion or failure.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private attributes:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "Pending", "Processed", "Failed").
 *     *   Include a constructor and public getter methods for these attributes.
 * 
 * 2.  **Task Scheduler Logic:** Create a `TaskScheduler` class that manages the task flow.
 *     *   It must contain a `private Queue<Task>` to hold tasks waiting to be processed. Use `java.util.Queue`.
 *     *   It must contain a `private List<Task>` to store processed tasks history. Use `java.util.ArrayList` but declare the field using the `java.util.List` interface type.
 *     *   Include a private counter for generating unique task IDs.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with status "Pending", assigns a unique ID, and adds it to the pending task queue. Should validate that the description is not empty.
 *         *   `processNextTask()`: Removes the next task from the front of the pending queue. Simulates processing: randomly assign status "Processed" (e.g., 90% chance) or "Failed" (e.g., 10% chance). Moves the task to the history list. Handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns the `Queue` of pending tasks (for viewing).
 *         *   `getTaskHistory()`: Returns the `List` of task history (for viewing).
 * 
 * 3.  **User Interface:** Create a main class (e.g., `TaskSimulatorApp`) with a `main` method to handle user interaction via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Task History
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, empty queue processing attempt, empty description).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the task description (must not be empty).
 *     *   Handle the scenario where the user attempts to process a task when the pending queue is empty.
 *     *   Implement **class-wide exception handling** using a `try-catch` block in the main application loop to catch any unexpected runtime exceptions and report them using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate data types and access modifiers (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Expected Output:**
 * The application should run interactively. Upon starting, it should display the menu. Based on user input, it should perform the corresponding action, printing results or errors to the console using `System.out` or `System.err` as specified. Example interaction might look like:
 * 
 * ```
 * Task Processing Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Task added successfully.
 * 
 * Task Processing Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ID: 1, Description: Implement feature X, Status: Pending
 * ---------------------
 * 
 * Task Processing Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 2
 * Processing task ID: 1... Status: Processed.
 * 
 * Task Processing Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 4
 * --- Task History ---
 * ID: 1, Description: Implement feature X, Status: Processed
 * --------------------
 * 
 * Task Processing Simulator Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 5
 * Exiting simulator.
 * ```
 * (Error messages should go to System.err)
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (including the use of specified Java components and error handling), code structure, readability, and best practices.
 *
 * EXPLANATION:
 * The solution implements a simple task processing simulator as required.
 * 
 * 1.  **`Task` Class:** This is a basic Plain Old Java Object (POJO) representing a task. It has private fields (`id`, `description`, `status`) and public getter methods, demonstrating encapsulation. A setter for `status` is included to allow the `TaskScheduler` to update the task's state after processing. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskScheduler` Class:** This class encapsulates the core logic of the simulator.
 *     *   `pendingTasks`: A `Queue<Task>` is used via `java.util.LinkedList`. The `Queue` interface is ideal for managing tasks in a First-In, First-Out (FIFO) manner, ensuring tasks are processed in the order they are added. `offer()` is used for adding tasks and `poll()` for removing them, which are standard `Queue` operations that handle capacity issues gracefully (though not strictly necessary for `LinkedList`).
 *     *   `taskHistory`: An `ArrayList<Task>` is used, but the field is declared as `List<Task>`, demonstrating polymorphism and the use of the `List` interface. This list stores tasks after they have been processed (either successfully or failed).
 *     *   `nextTaskId`: A simple counter to generate unique IDs for tasks.
 *     *   `random`: Used to simulate the outcome of task processing.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue. It includes basic input validation for the description, printing an error to `System.err` if invalid.
 *     *   `processNextTask()`: Removes the task at the head of the `pendingTasks` queue using `poll()`. If `poll()` returns `null` (meaning the queue was empty), it indicates there are no tasks to process. Otherwise, it simulates a processing outcome using `random.nextDouble()`, updates the task's status, and adds the task to the `taskHistory` list. It returns a string indicating the result. Error messages for processing an empty queue are handled by the caller (`TaskSimulatorApp`) based on the return value.
 *     *   `getPendingTasks()` and `getTaskHistory()`: These methods provide access to the internal collections for displaying purposes. While returning the collections directly is done for simplicity in an exam context, in a production system, returning unmodifiable views or copies might be preferred for stricter encapsulation.
 * 
 * 3.  **`TaskSimulatorApp` Class:** This is the main application class.
 *     *   It contains the `main` method where execution begins.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is displayed using `System.out`.
 *     *   User input is read. A nested `try-catch` block specifically handles `InputMismatchException` if the user enters non-integer input for the menu choice, preventing crashes and infinite loops. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character.
 *     *   A `switch` statement directs the program flow based on the user's valid integer choice.
 *     *   Each case in the `switch` calls the appropriate method on the `TaskScheduler` instance and handles the output or potential errors. `System.out` is used for menu display, successful task additions, and displaying task lists. `System.err` is used for reporting invalid menu choices and the "No pending tasks" condition returned by `processNextTask`.
 *     *   `viewTasks` is a helper method to print the contents of a collection of tasks, used for both pending and history lists. It iterates over an `Iterable<Task>`, making it usable with both `Queue` and `List`.
 * 
 * 4.  **Error Handling:**
 *     *   Input validation for task description is done in `TaskScheduler.addTask()`.
 *     *   Attempting to process an empty queue is detected in `TaskScheduler.processNextTask()` and reported by `TaskSimulatorApp` using `System.err`.
 *     *   **Class-wide Exception Handling:** The main `try-catch(Exception e)` block wraps the entire `while` loop in the `main` method. This structure catches any unhandled `Exception` that might occur during the execution of the simulation loop (e.g., errors during collection operations, null pointer exceptions if logic errors exist, or other unexpected runtime issues). When an exception is caught, an error message and the stack trace are printed to `System.err`, fulfilling the requirement for class-wide exception handling using `try-catch` and `System.err`.
 *     *   The `finally` block ensures the `Scanner` is closed when the application exits, regardless of whether it exited normally or due to an exception, which is a good practice for resource management.
 * 
 * 5.  **Best Practices:** The code uses private fields, public methods, meaningful names (`Task`, `TaskScheduler`, `pendingTasks`, `processNextTask`), and comments explaining key parts. Encapsulation is applied by keeping data private within classes and exposing functionality through public methods.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, simulated scenario, demonstrating core Java concepts and good programming practices.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random; // For simulating processing outcome

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private String status;

    public Task(int id, String description, String status) {
        this.id = id;
        this.description = description;
        this.status = status;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used by scheduler)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the queue of pending tasks and the history list
class TaskScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> taskHistory;
    private int nextTaskId;
    private Random random; // For simulating processing outcome

    public TaskScheduler() {
        // Using LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.taskHistory = new ArrayList<>();
        this.nextTaskId = 1;
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return true if task was added, false if description was invalid.
     */
    public boolean addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        Task newTask = new Task(nextTaskId++, description.trim(), "Pending");
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added successfully.");
        return true;
    }

    /**
     * Processes the next task from the queue.
     * @return A string indicating the outcome ("Processed", "Failed", or "No tasks").
     */
    public String processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess == null) {
            return "No tasks";
        }

        System.out.println("Processing task ID: " + taskToProcess.getId() + "...");

        // Simulate processing outcome (e.g., 90% success, 10% failure)
        if (random.nextDouble() < 0.1) { // 10% chance of failure
            taskToProcess.setStatus("Failed");
            System.err.println("Task ID: " + taskToProcess.getId() + " failed.");
        } else {
            taskToProcess.setStatus("Processed");
            System.out.println("Task ID: " + taskToProcess.getId() + " completed successfully.");
        }

        taskHistory.add(taskToProcess); // Add the task to history regardless of status
        return taskToProcess.getStatus();
    }

    /**
     * Returns the queue of pending tasks.
     * Note: Returning the actual queue allows external iteration for viewing.
     * For stricter encapsulation, one might return an unmodifiable view or a copy.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Returns the list of task history.
     * Note: Returning the actual list allows external iteration for viewing.
     * For stricter encapsulation, one might return an unmodifiable view or a copy.
     */
    public List<Task> getTaskHistory() {
        return taskHistory;
    }
}

// Main application class handling user interaction
public class TaskSimulatorApp {

    private static void displayMenu() {
        System.out.println("\nTask Processing Simulator Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Task History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    private static void viewTasks(String title, Iterable<Task> tasks) {
        System.out.println("\n--- " + title + " ---");
        if (!tasks.iterator().hasNext()) {
            System.out.println("No tasks found.");
        } else {
            for (Task task : tasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();

                // Use a nested try-catch for reading the integer choice
                // to handle non-integer input specifically
                int choice = -1; // Default invalid choice
                try {
                    choice = scanner.nextInt();
                } catch (java.util.InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        scheduler.addTask(description);
                        break;
                    case 2:
                        String outcome = scheduler.processNextTask();
                        if ("No tasks".equals(outcome)) {
                            System.err.println("No pending tasks to process.");
                        }
                        // Outcome messages for Processed/Failed are printed within processNextTask
                        break;
                    case 3:
                        viewTasks("Pending Tasks", scheduler.getPendingTasks());
                        break;
                    case 4:
                        viewTasks("Task History", scheduler.getTaskHistory());
                        break;
                    case 5:
                        System.out.println("Exiting simulator.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }
}
