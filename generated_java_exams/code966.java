/*
 * Exam Question #966
 * Generated on: 2025-05-12 17:06:17
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Prioritization and Execution System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a task management system. This system allows users to add tasks, view pending tasks, execute the next task based on arrival order, view completed tasks, and exit. Each task has a unique ID, a description, and a priority level (an integer). The system should manage pending tasks in a queue and store completed tasks in a history list.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `priority` (int). Include a constructor, public getter methods for all fields, and a meaningful `toString()` method to represent a task.
 * 2.  **Task Scheduler Logic:** Create a `TaskScheduler` class responsible for managing the tasks.
 *     *   It must have a private `Queue<Task>` field to store pending tasks. Use a concrete implementation like `java.util.LinkedList`.
 *     *   It must have a private `List<Task>` field to store completed tasks. Use a concrete implementation like `java.util.ArrayList`.
 *     *   It must maintain a private counter for generating unique task IDs.
 *     *   Implement a public method `addTask(String description, int priority)`: Creates a new `Task` object with a unique ID and the provided description and priority. Add the new task to the pending tasks queue. Include basic validation (e.g., description not empty, priority within a reasonable range like 1-10).
 *     *   Implement a public method `executeNextTask()`: Removes the task at the front of the pending tasks queue. If a task is successfully removed, add it to the completed tasks list and return a success message including the executed task's details. If the queue is empty, return an appropriate error message.
 *     *   Implement a public method `getPendingTasks()`: Returns the `Queue` of pending tasks (or a copy/view to prevent external modification, though returning the reference is acceptable for this exam context).
 *     *   Implement a public method `getCompletedTasks()`: Returns the `List` of completed tasks (or a copy/view).
 * 3.  **Command-Line Interface:** Create a main class (e.g., `TaskSchedulerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a loop that continuously prompts the user for commands until they enter 'exit'.
 *     *   Process commands using a `switch` statement based on the first word of the input line. The supported commands are:
 *         *   `add <description> <priority>`: Adds a new task. The description can be multiple words. The priority is an integer. Example: `add Buy groceries 5`
 *         *   `execute`: Executes the next task in the queue.
 *         *   `view pending`: Displays all tasks currently in the pending queue.
 *         *   `view completed`: Displays all tasks in the completed list.
 *         *   `exit`: Terminates the application.
 *     *   Use `System.out` for all normal output (prompts, task details, list contents, success messages).
 *     *   Use `System.err` for all error messages (invalid command, incorrect command format, validation errors, attempting to execute from an empty queue).
 * 4.  **Error Handling:**
 *     *   Implement input validation within `addTask` and the command processing logic.
 *     *   Use `try-catch` blocks for exception handling. Specifically, handle potential `NumberFormatException` when parsing the priority input. A broader `try-catch` around the main command processing loop is also required to demonstrate class-wide handling.
 *     *   Provide informative error messages using `System.err`.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should interact with the user as follows (example flow):
 * 
 * ```
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): add Task A 3
 * Task added: Task{id=1, description='Task A', priority=3}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): add Task B 7
 * Task added: Task{id=2, description='Task B', priority=7}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): view pending
 * Pending Tasks:
 * Task{id=1, description='Task A', priority=3}
 * Task{id=2, description='Task B', priority=7}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): execute
 * Executed Task: Task{id=1, description='Task A', priority=3}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): view completed
 * Completed Tasks:
 * Task{id=1, description='Task A', priority=3}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): execute
 * Executed Task: Task{id=2, description='Task B', priority=7}
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): execute
 * Error: No tasks in the pending queue.
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): add Invalid Priority Task ABC
 * Error: Invalid command format. Use 'add <description> <priority>'. Priority must be an integer.
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): add Task C 15
 * Error: Priority must be between 1 and 10.
 * Enter command (add <desc> <prio>, execute, view pending, view completed, exit): exit
 * Exiting Task Scheduler.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Components Required:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling (`try-catch`)
 *
 * EXPLANATION:
 * This solution implements the Task Prioritization and Execution System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **1. Task Class:**
 * *   Represents the data structure for a single task.
 * *   `private` fields (`id`, `description`, `priority`) ensure encapsulation.
 * *   Public getter methods provide controlled access to the task's properties.
 * *   The `toString()` method provides a convenient way to print task information.
 * 
 * **2. TaskScheduler Class:**
 * *   Manages the collection of tasks.
 * *   Uses a `Queue<Task>` (`LinkedList` implementation) for `pendingTasks`. The `Queue` interface methods (`offer` for adding, `poll` for removing from the front) are used, fulfilling the `Queue` requirement and providing FIFO behavior for task execution.
 * *   Uses a `List<Task>` (`ArrayList` implementation) for `completedTasks`. The `List` interface requirement is met, and `ArrayList` provides dynamic resizing and efficient addition of completed tasks.
 * *   `nextTaskId` ensures each task gets a unique ID.
 * *   `addTask`: Creates a `Task` object and adds it to the `pendingTasks` queue using `offer()`. It includes input validation for description and priority, throwing `IllegalArgumentException` if validation fails.
 * *   `executeNextTask`: Removes the next task from the `pendingTasks` queue using `poll()`. If a task is retrieved (`poll()` returns non-null), it's added to the `completedTasks` list. It handles the case where the queue is empty, printing an error to `System.err`.
 * *   `getPendingTasks` and `getCompletedTasks`: Provide access to the task collections.
 * 
 * **3. TaskSchedulerApp Class (Main Application):**
 * *   Contains the `main` method, the entry point of the application.
 * *   A `Scanner` is used to read user input from `System.in`. This fulfills the `Scanner` requirement.
 * *   A `while` loop keeps the application running until the user enters 'exit'.
 * *   Input parsing splits the command line into parts.
 * *   A `switch` statement is used to process the different commands (`add`, `execute`, `view`, `exit`), fulfilling the `switch` requirement.
 * *   **Error Handling:**
 *     *   Specific `try-catch` blocks are used within the `add` case to handle `NumberFormatException` if the priority cannot be parsed as an integer and `IllegalArgumentException` thrown by `TaskScheduler.addTask` for validation errors. Error messages are printed to `System.err`.
 *     *   `System.err` is also used for invalid command formats or when attempting to execute from an empty queue (`TaskScheduler.executeNextTask`). This fulfills the `System.err` requirement.
 *     *   A broader `try-catch (Exception e)` block wraps the main command processing loop. This demonstrates class-wide exception handling, catching any unexpected runtime errors that might occur during command processing and preventing the application from crashing immediately. This fulfills the class-wide `try-catch` requirement.
 * *   `System.out` is used for all normal output, such as prompts, success messages, and displaying task lists. This fulfills the `System.out` requirement.
 * *   Resource Management: The `Scanner` is closed in a `finally` block to ensure it's released regardless of whether an exception occurs.
 * 
 * **Best Practices Demonstrated:**
 * *   **Encapsulation:** Private fields and public methods in `Task` and `TaskScheduler`.
 * *   **Meaningful Names:** Clear names like `pendingTasks`, `executeNextTask`, `addTask`, etc.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods.
 * *   **Input Validation:** Checks in `addTask` and command parsing logic.
 * *   **Error Handling:** Use of `try-catch`, specific exception handling, and informative error messages via `System.err`.
 * *   **Clean Code Structure:** Separation of concerns into `Task`, `TaskScheduler`, and `TaskSchedulerApp`.
 * 
 * This solution effectively integrates all the required Java components to create a functional and robust command-line application that simulates a real-world task management scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.StringJoiner;

/**
 * Represents a single task with an ID, description, and priority.
 */
class Task {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The task priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string representation.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               '}';
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 */
class TaskScheduler {
    private Queue<Task> pendingTasks; // Required: Queue
    private List<Task> completedTasks; // Required: List (implemented by ArrayList)
    private int nextTaskId;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // Concrete implementation of Queue
        this.completedTasks = new ArrayList<>(); // Concrete implementation of List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue after validation.
     * @param description The task description.
     * @param priority The task priority.
     * @throws IllegalArgumentException if description is empty or priority is out of range.
     */
    public void addTask(String description, int priority) throws IllegalArgumentException {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 1 || priority > 10) { // Example priority range
            throw new IllegalArgumentException("Priority must be between 1 and 10.");
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        pendingTasks.offer(newTask); // Add task to the queue
        System.out.println("Task added: " + newTask); // Required: System.out
    }

    /**
     * Executes the next task from the pending queue.
     * @return The executed task, or null if the queue was empty.
     */
    public Task executeNextTask() {
        Task taskToExecute = pendingTasks.poll(); // Remove task from the front of the queue
        if (taskToExecute != null) {
            completedTasks.add(taskToExecute); // Add task to the completed list
            System.out.println("Executed Task: " + taskToExecute); // Required: System.out
            return taskToExecute;
        } else {
            System.err.println("Error: No tasks in the pending queue."); // Required: System.err
            return null;
        }
    }

    /**
     * Gets the queue of pending tasks.
     * @return The pending tasks queue.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Gets the list of completed tasks.
     * @return The completed tasks list.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Task Scheduler command-line interface.
 */
public class TaskSchedulerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Required: Scanner
        TaskScheduler scheduler = new TaskScheduler();
        boolean running = true;

        System.out.println("Task Scheduler System");

        // Required: Class-wide exception handling with try-catch
        try {
            while (running) {
                System.out.print("Enter command (add <desc> <prio>, execute, view pending, view completed, exit): ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue;
                }

                String[] parts = inputLine.split(" ", 3); // Split into command, potentially desc, and priority
                String command = parts[0].toLowerCase();

                // Required: Switch statement for flow control
                switch (command) {
                    case "add":
                        if (parts.length == 3) {
                            try {
                                // Attempt to parse priority
                                int priority = Integer.parseInt(parts[2]);
                                String description = parts[1];
                                scheduler.addTask(description, priority);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid priority format. Priority must be an integer."); // Required: System.err
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage()); // Required: System.err (for validation errors)
                            }
                        } else {
                            System.err.println("Error: Invalid command format. Use 'add <description> <priority>'."); // Required: System.err
                        }
                        break;

                    case "execute":
                        scheduler.executeNextTask();
                        break;

                    case "view":
                        if (parts.length == 2) {
                            String viewType = parts[1].toLowerCase();
                            if ("pending".equals(viewType)) {
                                System.out.println("Pending Tasks:"); // Required: System.out
                                if (scheduler.getPendingTasks().isEmpty()) {
                                    System.out.println("  (None)");
                                } else {
                                    for (Task task : scheduler.getPendingTasks()) {
                                        System.out.println("  " + task); // Required: System.out
                                    }
                                }
                            } else if ("completed".equals(viewType)) {
                                System.out.println("Completed Tasks:"); // Required: System.out
                                if (scheduler.getCompletedTasks().isEmpty()) {
                                    System.out.println("  (None)");
                                } else {
                                    for (Task task : scheduler.getCompletedTasks()) {
                                        System.out.println("  " + task); // Required: System.out
                                    }
                                }
                            } else {
                                System.err.println("Error: Invalid view type. Use 'view pending' or 'view completed'."); // Required: System.err
                            }
                        } else {
                            System.err.println("Error: Invalid command format. Use 'view pending' or 'view completed'."); // Required: System.err
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Scheduler."); // Required: System.out
                        break;

                    default:
                        System.err.println("Error: Unknown command. Available commands: add, execute, view, exit."); // Required: System.err
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage()); // Required: System.err
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Close the scanner
        }
    }
}
