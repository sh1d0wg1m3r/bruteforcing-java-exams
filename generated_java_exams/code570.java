/*
 * Exam Question #570
 * Generated on: 2025-05-11 23:30:57
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based Task Management System. This system should allow users to add new tasks, process the next task in line, view a list of completed tasks, and peek at the next task without processing it. The system must handle user input and potential errors gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. Each task should have a `description` (String). The description cannot be null or empty.
 * 2.  **Task Management Logic:** Create a `TaskManager` class that will manage the tasks.
 *     *   It should maintain a collection of *pending* tasks using a `Queue`. Tasks should be processed in the order they are added (FIFO - First-In, First-Out).
 *     *   It should maintain a collection of *completed* tasks using an `ArrayList` (declared as a `List`).
 *     *   It should use a `Scanner` to read user input from the console.
 * 3.  **Functionality:** Implement the following actions in the `TaskManager`:
 *     *   **Add New Task:** Prompt the user for a task description and add it to the queue of pending tasks. Validate that the description is not empty.
 *     *   **Process Next Task:** Remove the task at the front of the pending queue and move it to the list of completed tasks. If the queue is empty, report an error.
 *     *   **List Completed Tasks:** Display all tasks currently in the completed list, numbered sequentially. If the list is empty, report that no tasks are completed.
 *     *   **View Next Task:** Display the task at the front of the pending queue without removing it. If the queue is empty, report that no tasks are pending.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:** Implement a simple command-line menu using `System.out` to guide the user. Read the user's choice using the `Scanner`.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid input, queue is empty, task description is empty).
 *     *   Implement exception handling using `try-catch` blocks. Include a "class-wide" `try-catch` block in the main execution loop (e.g., in the method that runs the system) to catch unexpected runtime errors. Also, handle specific expected exceptions like invalid input or trying to operate on an empty queue.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments.
 *     *   Ensure input validation is performed where necessary.
 *     *   Manage the `Scanner` resource properly (e.g., close it when done).
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept integer input for choices, and print relevant output (`System.out` for success/information, `System.err` for errors) based on the user's actions. Example flow:
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description:
 * Write exam question
 * Task added: Write exam question
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description:
 * 
 * Error adding task: Task description cannot be empty.
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 4
 * Next task to process: Write exam question
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Write exam question
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Completed Tasks ---
 * 1. Write exam question
 * -----------------------
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Completed Tasks
 * 4. View Next Task
 * 5. Exit
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Task Management System ---
 * ... (continues until 5 is chosen)
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * **Deliverables:**
 * 
 * A single Java file containing all necessary classes (`Task`, `TaskManager`, and a main class to start the application).
 *
 * EXPLANATION:
 * This solution implements the Task Management System as described, utilizing all the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:** This simple class encapsulates the task data (the `description`). It demonstrates encapsulation with a private field and a public getter. The constructor includes input validation, throwing an `IllegalArgumentException` if the description is invalid, adhering to the principle of failing fast and validating input at the source.
 * 
 * 2.  **`TaskManager` Class:** This is the core of the system.
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used here because it implements the `Queue` interface and provides efficient FIFO operations (`offer`, `poll`, `peek`). It correctly represents the waiting line of tasks.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used and declared using the `List` interface. This is good practice as it allows flexibility to change the underlying implementation later if needed. It stores tasks that have been processed.
 *     *   **`Scanner scanner`**: Used to read user input from `System.in`. It's a private field initialized in the constructor.
 * 
 * 3.  **Functionality Methods (`addTask`, `processNextTask`, `listCompletedTasks`, `viewNextTask`):**
 *     *   These methods implement the core logic using the `pendingTasks` queue and `completedTasks` list.
 *     *   `addTask` uses `queue.offer()` to add a task. It also includes a `try-catch` block to handle the `IllegalArgumentException` that might be thrown by the `Task` constructor if the description is empty.
 *     *   `processNextTask` uses `queue.poll()`. `poll()` is used instead of `remove()` because it returns `null` if the queue is empty, allowing for graceful handling of the "No pending tasks" scenario without throwing a `NoSuchElementException`. The processed task is then added to the `completedTasks` list using `list.add()`.
 *     *   `listCompletedTasks` iterates through the `completedTasks` list using a standard `for` loop and `list.get()`.
 *     *   `viewNextTask` uses `queue.peek()`. `peek()` is used instead of `element()` because it returns `null` if the queue is empty, allowing graceful handling similar to `poll()`.
 *     *   All these methods use `System.out` for successful operations and `System.err` for reporting specific errors related to their function (like queue being empty).
 * 
 * 4.  **`displayMenu()` and `runSystem()`:**
 *     *   `displayMenu()` simply prints the menu options using `System.out`.
 *     *   `runSystem()` contains the main application loop. It repeatedly displays the menu, reads the user's choice using `scanner.nextInt()`, and uses a `switch` statement to call the appropriate method based on the choice.
 * 
 * 5.  **Control Flow (`switch`):** The `switch` statement in `runSystem` effectively directs the program flow based on the user's integer input, mapping choices to specific actions. The `default` case handles invalid integer inputs.
 * 
 * 6.  **Error Handling (`System.err`, `try-catch`):**
 *     *   `System.err` is consistently used for all error messages as required.
 *     *   **Specific Exception Handling:** `addTask` catches `IllegalArgumentException` from the `Task` constructor. `runSystem` specifically catches `InputMismatchException` which occurs if the user enters non-integer input when `scanner.nextInt()` is expected. It also catches `NoSuchElementException` and `IllegalStateException` which can occur with `Scanner`.
 *     *   **Class-wide Exception Handling:** The main `while` loop in `runSystem` is wrapped in a `try-catch(Exception e)`. This demonstrates a "class-wide" catch-all for the main execution flow of the `TaskManager`'s `runSystem` method. While specific catches are better, this outer catch ensures that if any unexpected runtime error occurs during the system's operation within the loop, it is caught, reported to `System.err`, and the program can potentially exit gracefully (or at least print the stack trace for debugging). The `finally` block ensures the `Scanner` is closed.
 * 
 * 7.  **Best Practices:**
 *     *   Encapsulation is achieved in both `Task` and `TaskManager`.
 *     *   Variable and method names (`pendingTasks`, `processNextTask`, `listCompletedTasks`) are descriptive.
 *     *   Comments are included to explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation is done in the `Task` constructor and implicitly handled for menu input via `InputMismatchException` catching.
 *     *   The `Scanner` is closed in a `finally` block in `runSystem` to release the system resource.
 *     *   The code is structured into logical classes, enhancing readability and maintainability. The handling of the newline character after `scanner.nextInt()` (`scanner.nextLine()` call in `addTask`) is a crucial detail for correct `Scanner` usage when mixing `nextInt()` and `nextLine()`.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating advanced understanding of data structures, object-oriented principles, user input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Cannot be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task: \"" + description + "\"";
    }
}

/**
 * Manages a collection of pending and completed tasks.
 */
class TaskManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing task collections and scanner.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts the user for a task description and adds a new task to the pending queue.
     * Handles empty description input.
     */
    public void addTask() {
        System.out.println("Enter task description:");
        // Consume the newline character left from previous input (e.g., nextInt())
        scanner.nextLine();
        String description = scanner.nextLine();

        try {
            Task newTask = new Task(description);
            // offer() is generally preferred over add() for queues as it handles capacity constraints
            // gracefully (though LinkedList is not capacity-constrained).
            if (pendingTasks.offer(newTask)) {
                System.out.println("Task added: " + newTask.getDescription());
            } else {
                // This case is unlikely for LinkedList but included for robustness
                System.err.println("Failed to add task. Queue might be full.");
            }
        } catch (IllegalArgumentException e) {
            // Catch specific error for invalid task description
            System.err.println("Error adding task: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during task creation/addition
            System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the pending queue by moving it to the completed list.
     * Reports an error if the pending queue is empty.
     */
    public void processNextTask() {
        try {
            // poll() retrieves and removes the head of the queue, returns null if empty
            Task nextTask = pendingTasks.poll();
            if (nextTask != null) {
                completedTasks.add(nextTask);
                System.out.println("Processed task: " + nextTask.getDescription());
            } else {
                System.err.println("No pending tasks to process.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during processing
            System.err.println("An unexpected error occurred while processing task: " + e.getMessage());
        }
    }

    /**
     * Lists all tasks that have been moved to the completed list.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the List and print each completed task
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i).getDescription());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Views (peeks at) the next task in the pending queue without removing it.
     * Reports an error if the pending queue is empty.
     */
    public void viewNextTask() {
        try {
            // peek() retrieves, but does not remove, the head of the queue, returns null if empty
            Task nextTask = pendingTasks.peek();
            if (nextTask != null) {
                System.out.println("Next task to process: " + nextTask.getDescription());
            } else {
                System.err.println("No pending tasks in the queue.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors while viewing
             System.err.println("An unexpected error occurred while viewing next task: " + e.getMessage());
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Completed Tasks");
        System.out.println("4. View Next Task");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main loop of the Task Management System.
     * Includes class-wide exception handling for the main execution flow.
     */
    public void runSystem() {
        boolean running = true;
        // Class-wide try-catch block covering the main system loop
        try {
            while (running) {
                displayMenu();
                int choice = scanner.nextInt(); // May throw InputMismatchException

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        listCompletedTasks();
                        break;
                    case 4:
                        viewNextTask();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (InputMismatchException e) {
            // Handle cases where the user enters non-integer input for the menu choice
            System.err.println("Invalid input. Please enter a number.");
            // Consume the invalid input to prevent an infinite loop
            scanner.next();
            // Continue the loop to display the menu again
            runSystem(); // Recursive call or simply let the loop continue
        } catch (NoSuchElementException e) {
             // Handle cases where the input stream is closed or exhausted unexpectedly
             System.err.println("Input stream is exhausted or closed unexpectedly. Exiting.");
        } catch (IllegalStateException e) {
             // Handle cases where the scanner is used after being closed
             System.err.println("Scanner is closed unexpectedly. Exiting.");
        }
        catch (Exception e) {
            // Catch any other unexpected runtime exceptions during the main loop
            System.err.println("An unexpected error occurred during system execution: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
             // Ensure scanner is closed even if an exception occurs
             if (scanner != null) {
                 scanner.close();
             }
        }
    }
}

/**
 * Main class to start the Task Management System application.
 */
public class TaskManagementExam {
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.runSystem();
    }
}
