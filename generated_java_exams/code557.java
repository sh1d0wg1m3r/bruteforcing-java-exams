/*
 * Exam Question #557
 * Generated on: 2025-05-11 23:29:13
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Priority Job Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple system to manage and process jobs based on their priority. The system should allow users to add new jobs to a queue, process the next job waiting in the queue, and view lists of pending and completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this job processing system. Your solution must adhere to the following:
 * 
 * 1.  **Classes:**
 *     *   A `Job` class to represent a single job. It should contain:
 *         *   A unique integer `id`.
 *         *   A `String` `description`.
 *         *   An integer `priority`.
 *         *   A `String` `status` (e.g., "Pending", "Completed").
 *         *   Proper encapsulation (private fields, public getters).
 *         *   A constructor to initialize a new job.
 *         *   An appropriate `toString()` method for displaying job details.
 *     *   A `JobProcessor` class to manage the collection of jobs. It should contain:
 *         *   A `Queue<Job>` to hold jobs waiting to be processed.
 *         *   An `ArrayList<Job>` to hold jobs that have been completed.
 *         *   Methods to:
 *             *   `addJob(String description, int priority)`: Creates a new `Job` and adds it to the pending queue. Assign a unique ID (you can use a simple counter).
 *             *   `processNextJob()`: Takes the next job from the pending queue, changes its status to "Completed", and moves it to the completed list. Handle the case where the queue is empty.
 *             *   `getPendingJobs()`: Returns a `List<Job>` containing all jobs currently in the pending queue.
 *             *   `getCompletedJobs()`: Returns a `List<Job>` containing all jobs currently in the completed list.
 *     *   A main application class (e.g., `JobProcessingApp`) containing the `main` method to handle user interaction.
 * 
 * 2.  **Core Java Concepts:**
 *     *   Use `java.util.Queue` for the pending jobs collection.
 *     *   Use `java.util.ArrayList` for the completed jobs collection.
 *     *   Use `java.util.List` interface as the return type for methods that provide lists of jobs (`getPendingJobs`, `getCompletedJobs`).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement in the `main` method to handle the user's menu selections.
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process an empty queue).
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and job lists.
 *     *   Implement class-wide exception handling using `try-catch` blocks to manage potential runtime errors (e.g., non-integer input).
 * 
 * 3.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments to explain complex parts or logic.
 *     *   Implement basic input validation (e.g., ensuring priority is a positive integer, handling non-integer input for menu choice/priority).
 *     *   Provide clear error messages using `System.err`.
 *     *   Structure the code logically with separate classes for data and processing logic.
 * 
 * **User Interaction:**
 * 
 * The program should present a menu to the user with the following options:
 * 
 * 1.  Add New Job
 * 2.  Process Next Job
 * 3.  View Pending Jobs
 * 4.  View Completed Jobs
 * 5.  Exit
 * 
 * The program should loop, displaying the menu and processing user input until the user chooses to exit.
 * 
 * **Input Format:**
 * 
 * *   Menu choice: A single integer (1-5).
 * *   Add Job:
 *     *   Job Description (String, can contain spaces)
 *     *   Job Priority (Integer, must be positive)
 * 
 * **Output Format:**
 * 
 * *   Menu: Clearly numbered options.
 * *   Prompts: Clear messages asking for input (e.g., "Enter job description:").
 * *   Job Lists: Display each job on a new line, showing ID, description, priority, and status.
 * *   Success Messages: Confirm actions (e.g., "Job added successfully.", "Job processed.").
 * *   Error Messages: Use `System.err.println()` for errors (e.g., "Invalid menu choice.", "Error: No jobs in the pending queue.").
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Task A
 * Enter job priority: 5
 * Job added successfully.
 * 
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Task B
 * Enter job priority: 10
 * Job added successfully.
 * 
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Jobs ---
 * ID: 1, Description: Task A, Priority: 5, Status: Pending
 * ID: 2, Description: Task B, Priority: 10, Status: Pending
 * 
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Job ID 1 processed successfully.
 * 
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Jobs ---
 * ID: 1, Description: Task A, Priority: 5, Status: Completed
 * 
 * --- Job Processing Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 5
 * Exiting Job Processing System.
 * ```
 * 
 * Your code should compile and run, demonstrating the required functionality and use of all specified Java components and best practices.
 *
 * EXPLANATION:
 * This solution implements a basic Job Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`Job` Class:**
 *     *   Represents the data structure for a single job.
 *     *   Uses `private` fields (`id`, `description`, `priority`, `status`) for encapsulation.
 *     *   A `static int nextId` ensures each job gets a unique ID upon creation.
 *     *   Provides public getter methods to access job details.
 *     *   Includes a `setStatus` setter as the status changes during processing.
 *     *   Overrides `toString()` for easy printing of job information.
 * 
 * 2.  **`JobProcessor` Class:**
 *     *   Manages the collections of jobs.
 *     *   `private Queue<Job> pendingJobs`: A `LinkedList` is used here as a concrete implementation of the `Queue` interface. `LinkedList` provides a standard FIFO queue behavior suitable for this simple processing order (first in, first out).
 *     *   `private List<Job> completedJobs`: An `ArrayList` is used here to store completed jobs. `ArrayList` is suitable for storing and iterating over a list of items where element access by index or iteration is common.
 *     *   `addJob(String description, int int priority)`: Creates a new `Job` instance and adds it to the `pendingJobs` queue using `offer()`. `offer()` is generally preferred over `add()` for queues as it returns `false` if the operation fails (e.g., queue is full), whereas `add()` throws an exception.
 *     *   `processNextJob()`: Uses `poll()` to retrieve and remove the job at the head of the `pendingJobs` queue. `poll()` is suitable because it returns `null` if the queue is empty, which is handled to display an error message using `System.err`. If a job is retrieved, its status is updated, and it's added to the `completedJobs` `ArrayList`.
 *     *   `getPendingJobs()` and `getCompletedJobs()`: These methods return a `List<Job>`. Crucially, they return *new* `ArrayList` instances populated with the contents of the internal collections (`pendingJobs` and `completedJobs`). This is a good practice to prevent external code from directly modifying the internal state of the `JobProcessor`'s collections. Returning the `List` interface type promotes programming to interfaces.
 * 
 * 3.  **`JobProcessingApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the program.
 *     *   Uses `Scanner` to read user input from the console. `scanner.nextLine()` is used consistently to avoid issues with newline characters left behind by methods like `nextInt()`. Input parsing (`Integer.parseInt`) is done carefully within `try-catch` blocks.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   A `try-catch` block is wrapped around the main `while` loop. This provides class-wide exception handling, catching any unexpected errors that might occur during the application's execution and printing an error message to `System.err`. A specific `catch` for `NumberFormatException` is included within the loop to handle invalid integer input for menu choices and priority more gracefully.
 *     *   A `switch` statement is used to control the flow based on the user's menu choice, directing execution to the appropriate logic block (add job, process, view, exit).
 *     *   Input validation is performed for job priority (must be positive) and description (cannot be empty) before adding a job. Invalid inputs trigger error messages on `System.err` and the loop continues.
 *     *   `System.out` is used for displaying the menu, prompts, and the contents of the job lists.
 *     *   `System.err` is specifically used for error messages like invalid menu choices, invalid input for priority, or attempting to process an empty queue.
 *     *   The `finally` block ensures the `Scanner` resource is closed when the application exits or an unexpected exception occurs.
 * 
 * This solution effectively uses all the required Java components in a practical scenario, demonstrates object-oriented principles like encapsulation, and includes error handling and input validation following best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single job in the processing system.
 */
class Job {
    private static int nextId = 1; // Static counter for unique job IDs

    private int id;
    private String description;
    private int priority;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Job with a unique ID, description, and priority.
     * Status is initially set to "Pending".
     * @param description The description of the job.
     * @param priority The priority level of the job.
     */
    public Job(String description, int priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Job.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %d, Status: %s",
                             id, description, priority, status);
    }
}

/**
 * Manages the queue of pending jobs and the list of completed jobs.
 */
class JobProcessor {
    // Use LinkedList as a Queue implementation for pending jobs (FIFO)
    private Queue<Job> pendingJobs;
    // Use ArrayList to store completed jobs
    private List<Job> completedJobs;

    /**
     * Constructs a new JobProcessor, initializing the job collections.
     */
    public JobProcessor() {
        this.pendingJobs = new LinkedList<>(); // Queue implementation
        this.completedJobs = new ArrayList<>(); // List implementation
    }

    /**
     * Creates a new Job and adds it to the pending queue.
     * @param description The description of the job.
     * @param priority The priority level of the job.
     */
    public void addJob(String description, int priority) {
        Job newJob = new Job(description, priority);
        pendingJobs.offer(newJob); // offer() is preferred over add() for queues
        System.out.println("Job added successfully.");
    }

    /**
     * Processes the next job from the pending queue.
     * Removes the job from the queue, updates its status, and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextJob() {
        Job jobToProcess = pendingJobs.poll(); // poll() retrieves and removes the head, returns null if empty

        if (jobToProcess != null) {
            jobToProcess.setStatus("Completed");
            completedJobs.add(jobToProcess);
            System.out.println("Job ID " + jobToProcess.getId() + " processed successfully.");
        } else {
            System.err.println("Error: No jobs in the pending queue to process.");
        }
    }

    /**
     * Returns a list of all jobs currently in the pending queue.
     * Returns a new ArrayList created from the queue elements to avoid external modification
     * of the internal queue state.
     * @return A List of pending Jobs.
     */
    public List<Job> getPendingJobs() {
        // Return a new list containing elements from the queue
        return new ArrayList<>(pendingJobs);
    }

    /**
     * Returns a list of all jobs currently in the completed list.
     * Returns a new ArrayList created from the completedJobs list to avoid external modification
     * of the internal list state.
     * @return A List of completed Jobs.
     */
    public List<Job> getCompletedJobs() {
        // Return a new list containing elements from the completedJobs list
        return new ArrayList<>(completedJobs);
    }
}

/**
 * Main application class for the Job Processing System.
 * Handles user interaction and orchestrates the JobProcessor.
 */
public class JobProcessingApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        JobProcessor processor = new JobProcessor();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read the entire line to handle potential non-integer input correctly
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine); // Attempt to parse as integer
                } catch (NumberFormatException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for menu control
                switch (choice) {
                    case 1: // Add New Job
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine(); // Read description

                        System.out.print("Enter job priority: ");
                        int priority = -1;
                        try {
                            String priorityInput = scanner.nextLine();
                            priority = Integer.parseInt(priorityInput); // Read and parse priority

                            if (priority <= 0) {
                                System.err.println("Invalid priority. Priority must be a positive integer.");
                                continue; // Skip adding job if priority is invalid
                            }
                            if (description.trim().isEmpty()) {
                                System.err.println("Invalid description. Description cannot be empty.");
                                continue; // Skip adding job if description is empty
                            }

                            processor.addJob(description.trim(), priority); // Add job
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input for priority. Please enter a valid integer.");
                        }
                        break;

                    case 2: // Process Next Job
                        processor.processNextJob();
                        break;

                    case 3: // View Pending Jobs
                        List<Job> pending = processor.getPendingJobs(); // Use List interface
                        System.out.println("\n--- Pending Jobs ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending jobs.");
                        } else {
                            for (Job job : pending) {
                                System.out.println(job); // Uses Job's toString()
                            }
                        }
                        System.out.println("--------------------\n");
                        break;

                    case 4: // View Completed Jobs
                        List<Job> completed = processor.getCompletedJobs(); // Use List interface
                        System.out.println("\n--- Completed Jobs ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed jobs.");
                        } else {
                            for (Job job : completed) {
                                System.out.println(job); // Uses Job's toString()
                            }
                        }
                        System.out.println("----------------------\n");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Job Processing System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging in exam context
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu to the console.
     */
    private static void printMenu() {
        System.out.println("--- Job Processing Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
