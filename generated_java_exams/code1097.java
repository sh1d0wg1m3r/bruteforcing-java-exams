/*
 * Exam Question #1097
 * Generated on: 2025-05-12 17:24:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to manage a queue of tasks. New tasks are added to the end of a waiting queue. Tasks are processed one by one from the front of the queue. Once processed, tasks are moved to a list of completed tasks. The user interacts with the system through a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the queue of waiting tasks.
 *     *   Use a `java.util.ArrayList` to store completed tasks. Declare the variable using the `java.util.List` interface type.
 *     *   Create a simple `Task` class with private fields: a unique integer ID and a String description. Include a constructor and public getter methods for these fields. Implement a meaningful `toString()` method for easy printing.
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Waiting Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 3.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description, create a new `Task` object (assigning a unique ID, e.g., using a simple counter), and add it to the waiting task queue. Print a confirmation message using `System.out`.
 *     *   **Process Next Task:** Remove the task at the front of the waiting queue. If the queue is not empty, move the removed task to the completed tasks list and print a confirmation message using `System.out`. If the queue is empty, print an error message to `System.err`.
 *     *   **View Waiting Tasks:** Display all tasks currently in the waiting queue in their current order. If the queue is empty, print a message using `System.out` indicating that.
 *     *   **View Completed Tasks:** Display all tasks in the completed tasks list. If the list is empty, print a message using `System.out` indicating that.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically to handle potential issues like invalid input (e.g., non-integer input for the menu choice) using `java.util.InputMismatchException`.
 *     *   For invalid menu options (outside the valid range), print an error message to `System.err`.
 *     *   Use `System.err` for all error messages and `System.out` for all normal output (menu, prompts, confirmations, task lists).
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation for the `Task` class.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Validate user input where necessary (at least for the menu choice).
 *     *   Structure the code cleanly.
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Users enter numbers corresponding to menu options. The output should guide the user, display task information, confirmations, and error messages as described above, using `System.out` and `System.err` appropriately.
 * 
 * Example interaction flow (user input shown after `>`):
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 1
 * Enter task description: > Implement login feature
 * Task ID 1 added to the queue.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 1
 * Enter task description: > Write API documentation
 * Task ID 2 added to the queue.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 3
 * Waiting Tasks:
 * Task ID: 1, Description: Implement login feature
 * Task ID: 2, Description: Write API documentation
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 2
 * Processing task: Task ID: 1, Description: Implement login feature
 * Task ID 1 moved to completed tasks.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 3
 * Waiting Tasks:
 * Task ID: 2, Description: Write API documentation
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 4
 * Completed Tasks:
 * Task ID: 1, Description: Implement login feature
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > abc
 * Error: Invalid input. Please enter a number.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: > 5
 * Exiting Task Processing System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing the necessary classes.
 *
 * EXPLANATION:
 * The solution implements a simple Task Processing System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class encapsulates the data for a single task: `id` and `description`.
 *     *   `private` fields ensure encapsulation.
 *     *   `public` getter methods (`getId`, `getDescription`) provide controlled access to the data.
 *     *   A `static int nextId` is used to automatically generate unique IDs for each new `Task` instance, incrementing the counter in the constructor.
 *     *   The `toString()` method provides a convenient way to represent a task as a string for printing.
 * 
 * 2.  **`TaskProcessorApp` Class:**
 *     *   This is the main application class.
 *     *   **Data Structures:**
 *         *   `Queue<Task> waitingTasks = new LinkedList<>();`: A `Queue` is used for waiting tasks, enforcing FIFO order. `LinkedList` is a common implementation of the `Queue` interface.
 *         *   `List<Task> completedTasks = new ArrayList<>();`: An `ArrayList` is used for completed tasks. It is declared using the `List` interface type, adhering to the requirement and good practice of programming to interfaces.
 *     *   **`run()` Method:**
 *         *   This method contains the main application loop.
 *         *   **`Scanner`:** A `Scanner` object is created to read user input from `System.in`. It is placed within a `try-with-resources` block (`try (Scanner scanner = new Scanner(System.in))`) to ensure the `Scanner` is automatically closed when the block is exited, preventing resource leaks.
 *         *   **Main Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *         *   **Menu Display:** The `displayMenu()` method is called to show the options.
 *         *   **Input Reading and Validation:**
 *             *   The code attempts to read an integer using `scanner.nextInt()`.
 *             *   A `try-catch` block specifically catches `InputMismatchException` if the user enters non-integer text. An error message is printed to `System.err`, and `scanner.next()` is called to consume the invalid input (otherwise, the loop would repeat infinitely trying to read the same bad input). `continue` skips to the next loop iteration.
 *             *   A general `catch (Exception e)` is included as a fallback for any other unexpected errors during input reading, printing details to `System.err`.
 *         *   **`switch` Statement:** The validated integer `choice` is used in a `switch` statement to direct the program flow to the appropriate action method (`addNewTask`, `processNextTask`, etc.).
 *         *   **Default Case:** The `default` case in the `switch` handles integer inputs that are outside the valid menu range (1-5), printing an error to `System.err`.
 *         *   **Exit:** Case 5 sets the `running` flag to `false`, terminating the `while` loop.
 *     *   **Action Methods (`addNewTask`, `processNextTask`, `viewWaitingTasks`, `viewCompletedTasks`):**
 *         *   These private methods encapsulate the logic for each menu option, promoting code organization and reusability.
 *         *   `addNewTask`: Reads the description, creates a `Task` object, and uses `waitingTasks.offer()` to add it to the queue. Includes basic validation for empty description.
 *         *   `processNextTask`: Uses `waitingTasks.poll()` to get and remove the head of the queue. Checks if the result is `null` (meaning the queue was empty) to print an error to `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *         *   `viewWaitingTasks`: Iterates through the `waitingTasks` queue using a `for-each` loop. This iterates over the elements without removing them, fulfilling the requirement to view the queue's contents. Checks if the queue is empty. Output is to `System.out`.
 *         *   `viewCompletedTasks`: Iterates through the `completedTasks` list using a `for-each` loop. Checks if the list is empty. Output is to `System.out`.
 *     *   **`System.out` and `System.err`:** Used consistently as required: `System.out` for menu, prompts, confirmations, and lists; `System.err` for all error messages (invalid input, empty queue processing, invalid menu choice).
 *     *   **Class-wide Exception Handling:** The `try-catch` block around the `scanner.nextInt()` specifically handles expected input errors. The `try-with-resources` block around the `Scanner` itself has a general `catch (Exception e)` to handle any other potential unhandled exceptions that might occur within the `run()` method's scope, directing these critical errors to `System.err`.
 *     *   **`main()` Method:** The standard entry point which creates an instance of `TaskProcessorApp` and calls its `run()` method.
 * 
 * This solution effectively uses all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, follows best practices like encapsulation and clear naming, and includes robust error handling for a command-line application.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList; // LinkedList is a common implementation of Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task with an ID and a description.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;

    /**
     * Constructs a new Task with an auto-generated unique ID.
     *
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign current ID and increment counter
        this.description = description;
    }

    /**
     * Gets the unique ID of the task.
     *
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description;
    }
}

/**
 * Main application class for the Task Processing System.
 * Manages a queue of waiting tasks and a list of completed tasks.
 */
public class TaskProcessorApp {

    // Use LinkedList as an implementation of Queue
    private Queue<Task> waitingTasks = new LinkedList<>();
    // Use ArrayList as an implementation of List
    private List<Task> completedTasks = new ArrayList<>();

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Processing System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the waiting queue.
     *
     * @param scanner Scanner object for reading user input.
     */
    private void addNewTask(Scanner scanner) {
        System.out.print("Enter task description: ");
        // Consume the leftover newline character from previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return;
        }

        Task newTask = new Task(description);
        waitingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task ID " + newTask.getId() + " added to the queue.");
    }

    /**
     * Processes the next task from the waiting queue.
     */
    private void processNextTask() {
        Task taskToProcess = waitingTasks.poll(); // poll removes the head, returns null if empty

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " moved to completed tasks.");
        } else {
            System.err.println("Error: No tasks in the waiting queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    private void viewWaitingTasks() {
        System.out.println("\nWaiting Tasks:");
        if (waitingTasks.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : waitingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\nCompleted Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        // Use try-with-resources to ensure the scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt(); // Read integer input for menu choice
                } catch (InputMismatchException e) {
                    // Handle non-integer input
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration of the while loop
                } catch (Exception e) {
                     // Catch any other unexpected exceptions during input
                     System.err.println("An unexpected error occurred during input: " + e.getMessage());
                     e.printStackTrace(System.err); // Print stack trace to err
                     continue; // Skip to the next iteration
                }

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addNewTask(scanner);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewWaitingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu choice (integer outside 1-5)
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
             // Class-wide catch for any unhandled exceptions outside the input loop
             System.err.println("An unrecoverable error occurred: " + e.getMessage());
             e.printStackTrace(System.err);
        }
        // Scanner is automatically closed by try-with-resources
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorApp app = new TaskProcessorApp();
        app.run();
    }
}
