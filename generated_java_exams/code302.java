/*
 * Exam Question #302
 * Generated on: 2025-05-11 22:51:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Simulation Task Processor
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified simulation task processing system. This system manages a queue of tasks waiting to be processed and keeps a record of tasks that have been completed. Tasks have a type (A, B, or C), a unique integer ID, and some associated string data.
 * 
 * The system should interact with the user via the console, allowing them to:
 * 1.  Add a new task to the processing queue.
 * 2.  Process the next task from the queue.
 * 3.  View all tasks currently in the processing queue.
 * 4.  View all tasks that have been completed.
 * 5.  Exit the application.
 * 
 * Different task types (A, B, C) have slightly different processing logic simulated by printing specific messages.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be a single Java program containing multiple classes as needed. It must demonstrate proficiency in using the following Java components and concepts:
 * 
 * 1.  **`java.util.Queue`**: Used to store tasks waiting to be processed (the processing queue).
 * 2.  **`java.util.ArrayList`**: Used internally to store completed tasks.
 * 3.  **`java.util.List` interface**: Variables referencing the completed tasks collection should be declared using the `List` interface type.
 * 4.  **`java.util.Scanner`**: Used to read user commands and task details from standard input.
 * 5.  **`switch` statement**: Used to handle the different user commands (Add, Process, View Queue, View Completed, Exit).
 * 6.  **`System.err`**: Used exclusively for printing error messages (e.g., invalid input, queue empty).
 * 7.  **`System.out`**: Used for all normal output (prompts, task details, success messages).
 * 8.  **Class-wide exception handling**: A top-level `try-catch` block (or blocks) should be used to catch potential exceptions during the main program loop, ensuring the program doesn't crash unexpectedly and prints an informative error message to `System.err`. Specific input validation errors should also be handled gracefully.
 * 
 * **Design and Best Practices Requirements:**
 * 
 * *   **Encapsulation**: Use private fields and public methods within your classes.
 * *   **Meaningful Names**: Use descriptive names for variables, methods, and classes.
 * *   **Comments and Documentation**: Include Javadoc comments for classes and methods, and inline comments for complex logic.
 * *   **Input Validation**: Validate user input (e.g., task type, task ID) and handle invalid input gracefully using `System.err`.
 * *   **Error Handling**: Implement specific error handling for conditions like trying to process from an empty queue.
 * *   **Clean Code Structure**: Organize your code logically into appropriate methods and classes.
 * 
 * **Program Flow and User Interaction:**
 * 
 * The program should present a menu of options to the user. After each operation (except Exit), the menu should be displayed again.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task Type (A, B, C): A
 * Enter Task ID (integer): 101
 * Enter Task Data: Initial simulation data
 * Task added to the queue.
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task Type (A, B, C): B
 * Enter Task ID (integer): 102
 * Enter Task Data: Secondary process data
 * Task added to the queue.
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Queue ---
 * Task ID: 101, Type: A, Data: Initial simulation data
 * Task ID: 102, Type: B, Data: Secondary process data
 * --------------------------
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing Task ID: 101, Type: A...
 * Simulating Type A processing...
 * Task 101 processed and moved to completed.
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing Task ID: 102, Type: B...
 * Simulating Type B processing...
 * Task 102 processed and moved to completed.
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Queue ---
 * Queue is empty.
 * --------------------------
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 101, Type: A, Data: Initial simulation data
 * Task ID: 102, Type: B, Data: Secondary process data
 * --------------------------
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processor Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Processing Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processor.
 * ```
 * 
 * Your solution should handle invalid inputs gracefully (e.g., non-integer input for choice or ID, invalid task type) using `System.err`.
 * 
 * **Expected Output Format:**
 * 
 * Follow the format shown in the example interaction for menu display, task details, queue view, and completed tasks view. Error messages should be printed to `System.err` prefixed with "Error: ". Normal output should go to `System.out`.
 * 
 * **Submission:**
 * 
 * Provide the complete Java source code for your solution.
 *
 * EXPLANATION:
 * This solution implements the `Simulation Task Processor` system as described in the exam question, fulfilling all technical and design requirements.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Task` class**: A simple Plain Old Java Object (POJO) representing a single task. It has private fields (`id`, `type`, `data`) and public getter methods, demonstrating encapsulation. The constructor includes basic validation for `id` (must be positive) and `type` (must be 'A', 'B', or 'C'), throwing an `IllegalArgumentException` if validation fails. The `toString()` method provides a convenient string representation for printing.
 * 2.  **`TaskProcessingSystem` class**: This class encapsulates the core logic of the system.
 *     *   It uses a `private Queue<Task> processingQueue` to manage tasks waiting to be processed. `java.util.LinkedList` is used as a concrete implementation of the `Queue` interface. `offer()` is used for adding tasks and `poll()` for retrieving and removing the next task, which are standard `Queue` operations suitable for this scenario.
 *     *   It uses a `private List<Task> completedTasks` to store tasks after they are processed. `java.util.ArrayList` is used as a concrete implementation, and the variable is declared using the `List` interface type as required.
 *     *   Methods like `addTask()`, `processNextTask()`, `viewProcessingQueue()`, and `viewCompletedTasks()` provide the public interface for interacting with the system, adhering to encapsulation.
 *     *   `processNextTask()` demonstrates the use of a `switch` statement to simulate different processing logic based on the task `type`. It also handles the case of an empty queue using `System.err`.
 *     *   `viewProcessingQueue()` iterates through the `processingQueue` using a for-each loop, which utilizes the queue's iterator without removing elements. `viewCompletedTasks()` iterates through the `completedTasks` `List`.
 * 3.  **`TaskProcessorApp` class**: This is the main entry point of the application.
 *     *   It contains the `main` method which drives the program flow.
 *     *   A `static Scanner` is used for reading user input from `System.in`. It's declared `static final` as it's shared across the class and only needs one instance.
 *     *   A `static final TaskProcessingSystem` instance is created to manage the tasks.
 *     *   The main program loop is enclosed in a **top-level `try-catch` block**, fulfilling the "Class-wide exception handling" requirement. This block catches any unexpected `Exception` that might occur during the execution of the command loop, printing an error message and the stack trace to `System.err` before the `finally` block ensures the scanner is closed.
 *     *   Inside the loop, `printMenu()` displays the options.
 *     *   `getUserChoice()` reads the user's command. It includes a specific `try-catch` block to handle `InputMismatchException` if the user enters non-integer input, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. It also consumes the newline character using `scanner.nextLine()` in a `finally` block to avoid issues with subsequent `nextLine()` calls.
 *     *   A **`switch` statement** handles the valid user choices, calling the appropriate methods on the `TaskProcessingSystem` or the `addTaskHandler`.
 *     *   `addTaskHandler()` is a separate method responsible for prompting the user for task details and creating the `Task` object. It performs input validation for the task type and ID. It uses `scanner.nextLine()` to read the task type and data, and `scanner.nextInt()` for the ID, carefully managing the newline character consumption. It wraps the `Task` creation and addition in a `try-catch` block to gracefully handle `IllegalArgumentException` thrown by the `Task` constructor for invalid ID or type, printing the error message to `System.err`.
 *     *   `System.out.println()` is used for all normal output (menu, prompts, success messages, task details).
 *     *   `System.err.println()` is used exclusively for printing error messages (invalid input, queue empty, unexpected errors).
 *     *   The `finally` block in `main` ensures the `Scanner` is closed when the program exits, releasing system resources.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Practical use of `Queue` for managing a processing order (FIFO - First-In, First-Out) and `List` for storing a collection of completed items.
 * *   **Interfaces vs. Implementations:** Declaring variables using the `List` interface while instantiating with `ArrayList`, promoting flexibility.
 * *   **Object-Oriented Programming:** Encapsulation through private fields and public methods, separation of concerns into different classes (`Task`, `TaskProcessingSystem`, `TaskProcessorApp`).
 * *   **Input/Output:** Using `Scanner` for console input, careful handling of different input types (`int`, `String`) and the newline character issue. Using `System.out` and `System.err` for distinct output streams.
 * *   **Control Flow:** Using `while` loop for the main application loop and `switch` statement for command handling.
 * *   **Exception Handling:** Using specific `try-catch` blocks for anticipated errors (input format, invalid task data) and a top-level `try-catch` for unexpected runtime exceptions, printing errors to `System.err`.
 * *   **Input Validation:** Checking user input for correctness (range, format) and providing feedback via `System.err`.
 * 
 * This solution provides a robust and well-structured implementation that effectively utilizes all the required Java components and follows best practices, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the simulation.
 */
class Task {
    private int id;
    private char type;
    private String data;

    /**
     * Constructs a new Task.
     * @param id The unique integer ID of the task. Must be positive.
     * @param type The type of the task ('A', 'B', or 'C').
     * @param data The string data associated with the task.
     * @throws IllegalArgumentException if id is not positive or type is invalid.
     */
    public Task(int id, char type, String data) {
        if (id <= 0) {
            throw new IllegalArgumentException("Task ID must be positive.");
        }
        if (type != 'A' && type != 'B' && type != 'C') {
            throw new IllegalArgumentException("Task type must be A, B, or C.");
        }
        this.id = id;
        this.type = type;
        this.data = data;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public char getType() {
        return type;
    }

    public String getData() {
        return data;
    }

    /**
     * Returns a string representation of the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Type: " + type + ", Data: " + data;
    }
}

/**
 * Manages the task processing system, including pending and completed tasks.
 */
class TaskProcessingSystem {
    // Queue to hold tasks waiting to be processed
    private Queue<Task> processingQueue;
    // List to hold tasks that have been processed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessingSystem.
     */
    public TaskProcessingSystem() {
        // LinkedList is a common implementation of the Queue interface
        this.processingQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the processing queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        processingQueue.offer(task); // offer is preferred over add in queues
        System.out.println("Task added to the queue.");
    }

    /**
     * Processes the next task from the queue.
     * @return The processed task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = processingQueue.poll(); // poll retrieves and removes the head
        if (taskToProcess == null) {
            System.err.println("Error: Processing queue is empty. No tasks to process.");
            return null;
        }

        System.out.println("Processing " + taskToProcess + "...");
        // Simulate processing based on task type using a switch statement
        switch (taskToProcess.getType()) {
            case 'A':
                System.out.println("Simulating Type A processing logic...");
                // Add specific logic for Type A here if needed
                break;
            case 'B':
                System.out.println("Simulating Type B processing logic...");
                // Add specific logic for Type B here if needed
                break;
            case 'C':
                System.out.println("Simulating Type C processing logic...");
                // Add specific logic for Type C here if needed
                break;
            default:
                // This case should ideally not be reached due to Task constructor validation,
                // but included for robustness.
                System.err.println("Warning: Unknown task type encountered during processing: " + taskToProcess.getType());
                break;
        }

        completedTasks.add(taskToProcess);
        System.out.println("Task " + taskToProcess.getId() + " processed and moved to completed.");
        return taskToProcess;
    }

    /**
     * Displays all tasks currently in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : processingQueue) {
                System.out.println(task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the completed tasks list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("--------------------------");
    }
}

/**
 * Main class for the Task Processor application. Handles user interaction.
 */
public class TaskProcessorApp {

    private static final Scanner scanner = new Scanner(System.in);
    private static final TaskProcessingSystem system = new TaskProcessingSystem();

    public static void main(String[] args) {
        boolean running = true;

        // Top-level try-catch for class-wide exception handling
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Using switch statement for flow control
                switch (choice) {
                    case 1:
                        addTaskHandler();
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        system.viewProcessingQueue();
                        break;
                    case 4:
                        system.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processor.");
                        running = false;
                        break;
                    default:
                        // Handled by getUserChoice validation, but included for robustness
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Application terminated.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Processor Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input errors.
     * @return The valid integer choice.
     */
    private static int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle case where input is not an integer
            System.err.println("Error: Invalid input. Please enter a number.");
            // Consume the invalid input to prevent infinite loop
            scanner.next();
            choice = -1; // Indicate invalid choice
        } finally {
             // Consume the rest of the line, including the newline character,
             // regardless of whether nextInt() succeeded or failed.
             // This prevents issues with subsequent nextLine() calls.
             scanner.nextLine();
        }
        return choice;
    }

    /**
     * Handles the process of getting task details from the user and adding the task.
     * Includes input validation for task type and ID.
     */
    private static void addTaskHandler() {
        System.out.print("Enter Task Type (A, B, C): ");
        String typeInput = scanner.nextLine().trim().toUpperCase(); // Read as line, trim, convert to uppercase
        if (typeInput.length() != 1 || (typeInput.charAt(0) != 'A' && typeInput.charAt(0) != 'B' && typeInput.charAt(0) != 'C')) {
            System.err.println("Error: Invalid task type. Must be A, B, or C.");
            return; // Exit the handler method
        }
        char taskType = typeInput.charAt(0);

        int taskId = -1;
        System.out.print("Enter Task ID (integer): ");
        try {
            taskId = scanner.nextInt();
            // Consume the rest of the line after reading integer
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for Task ID. Please enter an integer.");
            scanner.nextLine(); // Consume the invalid input
            return; // Exit the handler method
        }

        System.out.print("Enter Task Data: ");
        String taskData = scanner.nextLine();

        try {
            // Create the task object, constructor validates ID and type
            Task newTask = new Task(taskId, taskType, taskData);
            system.addTask(newTask);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor
            System.err.println("Error creating task: " + e.getMessage());
        }
    }
}
