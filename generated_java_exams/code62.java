/*
 * Exam Question #62
 * Generated on: 2025-05-11 22:07:35
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Team Task Manager
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line based Team Task Manager application. This application will allow users to add new tasks, view pending tasks, view completed tasks, and mark tasks as complete. The system should manage tasks using a queue for pending tasks and a list for completed tasks, demonstrating robust input handling and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `int id`: A unique identifier for the task, automatically generated.
 *     *   `String description`: A brief description of the task.
 *     *   `String priority`: Can be "High", "Medium", or "Low".
 *     *   `boolean isCompleted`: Indicates if the task is completed.
 *     *   Implement appropriate constructor(s), getters, and a meaningful `toString()` method.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing tasks. It must internally use:
 *     *   A `java.util.Queue<Task>` to store tasks that are currently pending.
 *     *   A `java.util.List<Task>` (specifically, use `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` with a unique ID, validates the priority string, sets `isCompleted` to `false`, and adds it to the pending tasks queue. Returns the ID of the newly added task or throws an exception if validation fails.
 *         *   `completeTask(int taskId)`: Finds the task with the given ID in the pending queue, removes it from the queue, sets its `isCompleted` status to `true`, and adds it to the completed tasks list. Returns `true` if a task was found and completed, `false` otherwise (e.g., ID not found or task already completed).
 *         *   `getPendingTasks()`: Returns a `java.util.List<Task>` containing all tasks currently in the pending queue. The returned list should be a copy to prevent external modification of the internal queue.
 *         *   `getCompletedTasks()`: Returns a `java.util.List<Task>` containing all tasks in the completed tasks list. The returned list should be a copy.
 * 3.  **User Interface:** Create a main class (e.g., `TaskApp`) with a `main` method to handle user interaction via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View Completed Tasks
 *         4.  Mark Task as Complete
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation for user choices and task details (like priority).
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, especially around user input (e.g., non-integer input when expecting an integer).
 *     *   Use `System.err` to display error messages to the user (e.g., invalid menu choice, invalid task ID, invalid priority).
 *     *   Use `System.out` for all normal output (menu, task lists, success messages).
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The application should loop, displaying the menu, accepting input, and performing actions.
 * - Adding a task should prompt for description and priority, then confirm with the new task ID.
 * - Viewing tasks should list tasks with their ID, description, priority, and status.
 * - Completing a task should prompt for the task ID and confirm completion or report if the ID was invalid/not found.
 * - Invalid input or operations should result in an informative error message printed to `System.err`.
 * - Exiting should terminate the program gracefully.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Team Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Mark Task as Complete
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * Enter priority (High, Medium, Low): High
 * Task added successfully with ID: 1
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 1
 * Enter task description: Create UI
 * Enter priority (High, Medium, Low): Medium
 * Task added successfully with ID: 2
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 2
 * Pending Tasks:
 * ID: 1, Description: Implement Task Class, Priority: High, Status: Pending
 * ID: 2, Description: Create UI, Priority: Medium, Status: Pending
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 4
 * Enter task ID to complete: 1
 * Task with ID 1 marked as complete.
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 2
 * Pending Tasks:
 * ID: 2, Description: Create UI, Priority: Medium, Status: Pending
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 3
 * Completed Tasks:
 * ID: 1, Description: Implement Task Class, Priority: High, Status: Completed
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 4
 * Enter task ID to complete: 99
 * Error: Task with ID 99 not found or already completed.
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Team Task Manager ---
 * ... (menu displayed again)
 * Enter your choice: 5
 * Exiting Task Manager.
 * ```
 * 
 * Implement the complete Java code for this application.
 *
 * EXPLANATION:
 * The solution implements a simple Team Task Manager application, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Class:** A standard POJO (`Task.java`) is created with `id`, `description`, `priority`, and `isCompleted` fields. A static `nextId` ensures unique IDs for each task. Getters are provided for encapsulation, and a `setCompleted` method allows updating the status. The `toString()` method provides a convenient formatted output for task details.
 * 
 * 2.  **TaskManager Class:** This class (`TaskManager.java`) acts as the core logic handler.
 *     *   `private Queue<Task> pendingTasks = new LinkedList<>();`: A `LinkedList` is used because it implements the `Queue` interface, satisfying the requirement. It naturally supports adding to the end (`offer`) and removal. While a standard `Queue` doesn't provide easy mid-queue removal or lookup by ID, `LinkedList` does via its `remove(Object)` method, which is leveraged in `completeTask`.
 *     *   `private List<Task> completedTasks = new ArrayList<>();`: An `ArrayList` is used to store completed tasks, satisfying both the `List` interface and `ArrayList` requirements.
 *     *   `addTask(String description, String priorityStr)`: This method creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. It includes basic validation for the `priorityStr`, throwing an `IllegalArgumentException` if the input is not one of the expected values ("High", "Medium", "Low").
 *     *   `completeTask(int taskId)`: This method iterates through the `pendingTasks` queue to find the task by its ID. If found, it uses `pendingTasks.remove(taskToComplete)` (a method available on `LinkedList`) to remove it from the queue, updates its status, and adds it to the `completedTasks` list. It returns a boolean indicating success or failure.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: These methods return `new ArrayList<>(collection)` copies of the internal collections. This is important for encapsulation; it prevents external code from directly manipulating the internal `Queue` or `List` references and potentially breaking the manager's state. They return `List<Task>`, fulfilling the `List` interface requirement.
 * 
 * 3.  **User Interface (TaskApp):** The `main` method in `TaskApp.java` provides the command-line interface.
 *     *   A `Scanner` is initialized to read input from `System.in`.
 *     *   A `while(true)` loop keeps the application running until the user chooses to exit.
 *     *   `displayMenu()` prints the options using `System.out`.
 *     *   `scanner.nextInt()` reads the user's choice. `scanner.nextLine()` is crucial after reading an integer to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   A `switch` statement directs the flow based on the user's integer input, calling the appropriate helper methods (`addTask`, `viewPendingTasks`, `viewCompletedTasks`, `completeTask`).
 *     *   The "Exit" case (`case 5`) uses `return;` to terminate the `main` method and thus the program.
 *     *   The `default` case in the `switch` handles invalid menu numbers, printing an error to `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   A `try-catch` block wraps the core logic inside the main loop.
 *     *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input when an integer (like menu choice or task ID) is expected by `scanner.nextInt()`. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   `catch (IllegalArgumentException e)` catches the exception thrown by `addTask` if an invalid priority is entered. The error message from the exception is printed to `System.err`.
 *     *   `catch (Exception e)` provides a general safety net for any other unexpected runtime exceptions, printing a generic error message and the exception details to `System.err`.
 *     *   Validation for the task ID in `completeTask` is handled by the `boolean` return value of the `TaskManager` method; the `TaskApp` then prints an error to `System.err` if `false` is returned.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`. Access and modification are controlled via public methods. Returning copies of collections (`getPendingTasks`, `getCompletedTasks`) further protects internal state.
 *     *   **Meaningful Names:** Classes (`Task`, `TaskManager`, `TaskApp`), methods (`addTask`, `completeTask`, `getPendingTasks`), and variables (`description`, `priority`, `pendingTasks`) have names reflecting their purpose.
 *     *   **Comments/Documentation:** Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific logic points (like consuming the newline or the approach to removing from the queue).
 *     *   **Input Validation:** Priority input is validated in `addTask`. Integer input is handled with `InputMismatchException`. The validity of a task ID for completion is checked by the `completeTask` method's return value.
 *     *   **Error Handling:** As detailed above, `try-catch` and `System.err` are used effectively.
 *     *   **Clean Code Structure:** The logic is separated into distinct classes (`Task`, `TaskManager`, `TaskApp`) with clear responsibilities. Helper methods (`displayMenu`, `addTask`, etc.) in `TaskApp` improve readability and modularity. The `Scanner` is closed implicitly when the program exits or could be explicitly closed in a `finally` block if needed, though for a simple console app, relying on program termination is common.
 * 
 * This solution effectively demonstrates the use of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, well-structured application following Java best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the task management system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // High, Medium, Low
    private boolean isCompleted;

    private static int nextId = 1; // Static counter for unique IDs

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task ("High", "Medium", or "Low").
     */
    public Task(String description, String priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // --- Setters (only for completion status) ---
    public void setCompleted(boolean completed) {
        isCompleted = completed;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string showing task details.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %s, Status: %s",
                             id, description, priority, isCompleted ? "Completed" : "Pending");
    }
}

/**
 * Manages the collection of tasks, separating pending and completed ones.
 */
class TaskManager {
    // Queue for pending tasks (FIFO processing assumption, though completion is by ID)
    private Queue<Task> pendingTasks;
    // List for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a TaskManager, initializing the task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Validates the priority string.
     * @param description The task description.
     * @param priorityStr The priority string ("High", "Medium", or "Low").
     * @return The ID of the newly added task.
     * @throws IllegalArgumentException if the priority string is invalid.
     */
    public int addTask(String description, String priorityStr) {
        // Input validation for priority
        String lowerPriority = priorityStr.toLowerCase();
        if (!lowerPriority.equals("high") && !lowerPriority.equals("medium") && !lowerPriority.equals("low")) {
            throw new IllegalArgumentException("Invalid priority: " + priorityStr + ". Must be High, Medium, or Low.");
        }

        Task newTask = new Task(description, priorityStr);
        pendingTasks.offer(newTask); // Add to the end of the queue
        return newTask.getId();
    }

    /**
     * Finds and marks a task as complete.
     * Removes the task from the pending queue and adds it to the completed list.
     * @param taskId The ID of the task to complete.
     * @return true if a task with the given ID was found and completed, false otherwise.
     */
    public boolean completeTask(int taskId) {
        // Need to find and remove the task from the queue
        // Iterating and removing from a Queue directly can be tricky.
        // LinkedList's remove(Object) works, but requires finding the object first.
        // A more robust way for lookup by ID in a Queue would be to iterate and use an auxiliary list,
        // or use a different data structure for pending tasks (like a List or Map) if frequent lookup by ID is needed.
        // Given the requirement for Queue, we will iterate and remove using LinkedList's capability.

        Task taskToComplete = null;
        // Create a temporary list to hold tasks that are NOT the one being completed,
        // then clear the queue and re-add them. This is one way to "remove" from Queue mid-iteration.
        // Alternatively, LinkedList allows direct removal:
        for (Task task : pendingTasks) {
            if (task.getId() == taskId) {
                taskToComplete = task;
                break; // Found the task
            }
        }

        if (taskToComplete != null) {
            // Remove from the queue (LinkedList's remove method)
            boolean removed = pendingTasks.remove(taskToComplete);
            if (removed) {
                taskToComplete.setCompleted(true);
                completedTasks.add(taskToComplete); // Add to the completed list
                return true;
            }
            // Should not happen if taskToComplete was found in the loop, but good practice
            return false;
        }

        return false; // Task not found
    }

    /**
     * Returns a list of all pending tasks.
     * @return A new ArrayList containing the pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     * @return A new ArrayList containing the completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy
        return new ArrayList<>(completedTasks);
    }
}

/**
 * Main class to run the Task Management application.
 * Handles user interaction and delegates to TaskManager.
 */
public class TaskApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Team Task Manager ---");

        while (true) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over after nextInt()

                // Use switch for menu handling
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        viewCompletedTasks();
                        break;
                    case 4:
                        completeTask();
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager.");
                        return; // Exit the application
                    default:
                        // Invalid menu choice handled here
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice or task ID
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException e) {
                // Handle validation errors from TaskManager methods (e.g., invalid priority)
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a blank line for readability between operations
        }
    }

    /**
     * Displays the main menu options to the user.
     * Uses System.out.
     */
    private static void displayMenu() {
        System.out.println("--- Team Task Manager ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Mark Task as Complete");
        System.out.println("5. Exit");
    }

    /**
     * Handles the process of adding a new task based on user input.
     * Uses System.out and System.err.
     */
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter priority (High, Medium, Low): ");
        String priority = scanner.nextLine();

        try {
            int taskId = taskManager.addTask(description, priority);
            System.out.println("Task added successfully with ID: " + taskId);
        } catch (IllegalArgumentException e) {
            // This catch is redundant due to the general catch in main,
            // but demonstrates handling specific exceptions at the call site if needed.
            // We'll rely on the main loop's catch for simplicity in this exam context.
            throw e; // Re-throw to be caught by the main loop's handler
        }
    }

    /**
     * Displays all pending tasks to the user.
     * Uses System.out.
     */
    private static void viewPendingTasks() {
        List<Task> pending = taskManager.getPendingTasks();
        System.out.println("Pending Tasks:");
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            for (Task task : pending) {
                System.out.println(task); // Task's toString() is used
            }
        }
    }

    /**
     * Displays all completed tasks to the user.
     * Uses System.out.
     */
    private static void viewCompletedTasks() {
        List<Task> completed = taskManager.getCompletedTasks();
        System.out.println("Completed Tasks:");
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completed) {
                System.out.println(task); // Task's toString() is used
            }
        }
    }

    /**
     * Handles the process of marking a task as complete based on user input.
     * Uses System.out and System.err.
     */
    private static void completeTask() {
        System.out.print("Enter task ID to complete: ");
        try {
            int taskId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            boolean success = taskManager.completeTask(taskId);

            if (success) {
                System.out.println("Task with ID " + taskId + " marked as complete.");
            } else {
                System.err.println("Error: Task with ID " + taskId + " not found or already completed.");
            }
        } catch (InputMismatchException e) {
            // This catch is redundant due to the general catch in main,
            // but demonstrates handling specific exceptions at the call site if needed.
            // We'll rely on the main loop's catch for simplicity in this exam context.
             throw e; // Re-throw to be caught by the main loop's handler
        }
    }
}
