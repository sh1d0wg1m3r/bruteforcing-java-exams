/*
 * Exam Question #419
 * Generated on: 2025-05-11 23:08:30
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Ticket Management System
 * 
 * **Objective:** Design and implement a console-based technical support ticket management system. The system should allow users to add new support tickets, process the oldest pending ticket, and view a list of all tickets in the system (both pending and processed).
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class to represent a single support ticket. It should have private fields for:
 *     *   A unique integer ID.
 *     *   A String description of the issue.
 *     *   A String status (e.g., "PENDING", "PROCESSING", "RESOLVED").
 *     *   Include appropriate constructor(s), getters, and a method to update the status.
 * 
 * 2.  **System Management:** Create a `SupportSystem` class to manage the collection of tickets. This class should:
 *     *   Use a `java.util.Queue<Ticket>` to hold tickets that are currently pending and awaiting processing. The queue should enforce FIFO (First-In, First-Out) order for processing.
 *     *   Use a `java.util.List<Ticket>` (specifically an `ArrayList`) to maintain a complete history of *all* tickets ever added to the system, regardless of their status. Program to the `List` interface.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `Ticket` with status "PENDING", adds it to both the queue and the list. Assign a simple incrementing ID.
 *         *   `processNextTicket()`: Removes the oldest ticket from the queue, updates its status in the list (find it by ID) to "PROCESSING" or "RESOLVED" (your choice, but indicate it's being handled), and returns the processed ticket. Handle the case where the queue is empty.
 *         *   `getAllTickets()`: Returns the `List<Ticket>` containing all tickets.
 * 
 * 3.  **User Interface:** Implement a main class (`SupportApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`. The interface should present a menu with options:
 *     *   Add New Ticket
 *     *   Process Next Pending Ticket
 *     *   View All Tickets
 *     *   Exit
 *     *   Handle user input using a `switch` statement based on their menu choice.
 * 
 * 4.  **Error Handling & Input Validation:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, attempting to process a ticket when none are pending, invalid input format).
 *     *   Use `System.out` for normal output (menu, prompts, ticket details, success messages).
 *     *   Implement input validation for the ticket description (e.g., ensure it's not empty).
 *     *   Wrap the main application loop or critical sections in a `try-catch` block to demonstrate class-wide exception handling. Catch general `Exception` or more specific exceptions as appropriate and print an error message using `System.err`.
 *     *   Handle potential `java.util.InputMismatchException` if the user enters non-integer input for the menu choice.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts.
 *     *   Ensure proper encapsulation in the `Ticket` and `SupportSystem` classes.
 *     *   Program to interfaces (`List` interface).
 * 
 * **Execution Flow:**
 * 
 * The program should start, display the menu, and repeatedly prompt the user for input until they choose to exit.
 * 
 * **Example Interaction (Expected Output Format):**
 * 
 * ```
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * Ticket #1 added.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: Network connectivity issue
 * Ticket #2 added.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Processing Ticket #1: Printer not working
 * Ticket #1 status updated to PROCESSING.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 3
 * --- All Tickets ---
 * ID: 1, Description: Printer not working, Status: PROCESSING
 * ID: 2, Description: Network connectivity issue, Status: PENDING
 * --- End of List ---
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Processing Ticket #2: Network connectivity issue
 * Ticket #2 status updated to PROCESSING.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Error: No pending tickets to process. Queue is empty.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 4
 * Exiting system. Goodbye!
 * ```
 * 
 * **Note:** Your implementation might use "RESOLVED" instead of "PROCESSING" upon removal from the queue, which is acceptable as long as the status update logic is clear.
 *
 * EXPLANATION:
 * This solution implements a simple technical support ticket management system demonstrating the required Java concepts.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `SupportSystem` class uses a `Queue<Ticket>` named `pendingTickets`. A `LinkedList` is used as the concrete implementation because `LinkedList` implements the `Queue` interface. The `addTicket` method uses `offer()` to add tickets to the end of the queue, and `processNextTicket` uses `poll()` to retrieve and remove the ticket from the front of the queue. This correctly models the FIFO (First-In, First-Out) processing order required for support tickets.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `SupportSystem` uses an `ArrayList<Ticket>` named `allTickets`. This list serves as a complete record of every ticket ever created in the system, regardless of its current status. New tickets are added to this list in `addTicket`.
 * 3.  **`List` interface (`java.util.List`)**: The `allTickets` variable in `SupportSystem` is declared as type `List<Ticket>`, not `ArrayList<Ticket>`. The concrete object created is an `ArrayList`, but programming to the `List` interface makes the code more flexible; the underlying implementation could be changed to `LinkedList` or another `List` type later without affecting the parts of the code that interact with `allTickets` only through the `List` interface methods.
 * 4.  **`Scanner` (`java.util.Scanner`)**: The `SupportApp` class uses a `Scanner` object to read user input from the console (System.in) for menu choices and ticket descriptions.
 * 5.  **`Switch` statement**: The `main` method in `SupportApp` uses a `switch` statement to control the program flow based on the integer choice entered by the user from the menu. Each case corresponds to a specific action (add, process, view, exit, or invalid input).
 * 6.  **`System.err`**: Used throughout the `SupportApp` class to print error messages, such as when the user enters an invalid menu choice, provides an empty ticket description, attempts to process tickets when the queue is empty, or when an unexpected system error occurs. This differentiates error output from normal program messages.
 * 7.  **`System.out`**: Used for all normal output, including printing the menu, prompting the user for input, confirming ticket additions, displaying processing messages, and listing all tickets.
 * 8.  **`try-catch` blocks**:
 *     *   A large `try-catch(Exception e)` block is wrapped around the main `while` loop in `SupportApp`. This provides class-wide exception handling, catching any unexpected runtime errors that might occur within the application's main execution flow and preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 *     *   A specific `try-catch(InputMismatchException e)` block is used around `scanner.nextInt()` to handle cases where the user enters non-integer input for the menu choice.
 *     *   A `try-catch(IllegalArgumentException e)` is used around the call to `system.addTicket` to catch the validation error thrown by the `SupportSystem` if the description is empty.
 *     *   A `finally` block is used to ensure the `Scanner` is closed when the program exits, regardless of whether an exception occurred or the user chose to exit normally.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** The `Ticket` and `SupportSystem` classes have private fields and public methods (getters, `setStatus`, `addTicket`, `processNextTicket`, `getAllTickets`) to control access to their internal state.
 * *   **Meaningful Names:** Classes (`Ticket`, `SupportSystem`, `SupportApp`), variables (`pendingTickets`, `allTickets`, `description`, `choice`), and methods (`addTicket`, `processNextTicket`, `getAllTickets`, `printMenu`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Comments are used to explain the purpose of classes, methods, and specific code blocks. Javadoc-style comments are used for method documentation (`@param`, `@return`, `@throws`).
 * *   **Input Validation:** The `addTicket` method in `SupportSystem` explicitly checks if the provided description is null or empty and throws an `IllegalArgumentException`, which is then caught and handled in the `main` method.
 * *   **Error Handling:** Multiple layers of error handling are implemented using `try-catch` blocks and conditional checks (e.g., checking if `processedTicket` is null). Error messages are directed to `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical classes (`Ticket` for data, `SupportSystem` for logic/state, `SupportApp` for UI/entry point). Methods are relatively short and focused on a single task.
 * 
 * This solution effectively integrates the required components to create a functional, albeit simple, system that models a real-world scenario while adhering to good programming practices and demonstrating robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "PROCESSING", "RESOLVED"

    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the collection of support tickets
class SupportSystem {
    private Queue<Ticket> pendingTickets; // Tickets waiting to be processed (FIFO)
    private List<Ticket> allTickets;     // All tickets ever created (for history/viewing)
    private int nextTicketId;            // Counter for unique ticket IDs

    public SupportSystem() {
        // Use LinkedList as it implements Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as it implements List
        this.allTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start IDs from 1
    }

    /**
     * Adds a new ticket to the system.
     * @param description The description of the ticket issue.
     * @return The newly created Ticket object.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Ticket addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // Add to the end of the queue
        allTickets.add(newTicket);      // Add to the list of all tickets
        return newTicket;
    }

    /**
     * Processes the next oldest pending ticket.
     * Removes the ticket from the queue and updates its status in the allTickets list.
     * @return The ticket that was processed, or null if the queue is empty.
     */
    public Ticket processNextTicket() {
        Ticket ticketToProcess = pendingTickets.poll(); // Get and remove the head of the queue

        if (ticketToProcess != null) {
            // Find the ticket in the allTickets list and update its status
            // We iterate because the object reference in the list is the same as the one from the queue
            // Alternatively, if we only stored copies, we'd search by ID.
            for (Ticket ticket : allTickets) {
                if (ticket.getId() == ticketToProcess.getId()) {
                    ticket.setStatus("PROCESSING"); // Or "RESOLVED"
                    // The ticketToProcess object itself is also updated because it's the same object reference
                    break; // Found and updated
                }
            }
            // The status is also updated on ticketToProcess because it's the same object
            // Let's update it explicitly for clarity, though technically redundant here
             ticketToProcess.setStatus("PROCESSING"); // Update the returned object's status too
        }
        return ticketToProcess;
    }

    /**
     * Gets a list of all tickets in the system.
     * @return A List containing all tickets (pending and processed).
     */
    public List<Ticket> getAllTickets() {
        return allTickets; // Return the list of all tickets
    }
}

// Main class to run the support system application
public class SupportApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem();
        boolean running = true;

        // Class-wide exception handling using try-catch for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to next loop iteration
                }

                switch (choice) {
                    case 1: // Add New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        try {
                            Ticket newTicket = system.addTicket(description);
                            System.out.println("Ticket #" + newTicket.getId() + " added.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Pending Ticket
                        Ticket processedTicket = system.processNextTicket();
                        if (processedTicket != null) {
                            System.out.println("Processing Ticket #" + processedTicket.getId() + ": " + processedTicket.getDescription());
                            System.out.println("Ticket #" + processedTicket.getId() + " status updated to " + processedTicket.getStatus() + ".");
                        } else {
                            System.err.println("Error: No pending tickets to process. Queue is empty.");
                        }
                        break;

                    case 3: // View All Tickets
                        System.out.println("\n--- All Tickets ---");
                        List<Ticket> allTickets = system.getAllTickets(); // Using the List interface
                        if (allTickets.isEmpty()) {
                            System.out.println("No tickets in the system yet.");
                        } else {
                            for (Ticket ticket : allTickets) {
                                System.out.println(ticket); // Uses Ticket's toString()
                            }
                        }
                        System.out.println("--- End of List ---\n");
                        break;

                    case 4: // Exit
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            scanner.close();
        }
    }

    private static void printMenu() {
        System.out.println("Technical Support System Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View All Tickets");
        System.out.println("4. Exit");
    }
}
