/*
 * Exam Question #604
 * Generated on: 2025-05-12 16:13:42
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line application for managing customer support tickets. The system should simulate the process of submitting new tickets, having support agents process the oldest pending tickets, and allowing users to view the status of all tickets in the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   **Submit Ticket:** Allow a user to submit a new support ticket by providing a description. Each ticket must be assigned a unique, automatically generated ID. Newly submitted tickets are initially in a "pending" state.
 *     *   **Process Ticket:** Simulate a support agent taking the next available ticket for processing. The system should process tickets in the order they were submitted (First-In, First-Out). Processing a ticket should change its status. If no tickets are pending, the system should indicate this error.
 *     *   **List Tickets:** Display a list of all tickets currently known to the system, showing their ID, description, and current status.
 *     *   **Exit:** Allow the user to gracefully exit the application.
 * 
 * 2.  **Data Structures and Components:** Your solution *must* utilize the following Java components:
 *     *   `java.util.Queue` to manage the collection of tickets waiting to be processed.
 *     *   `java.util.ArrayList` to store a comprehensive list of all tickets ever submitted.
 *     *   `java.util.List` interface: When retrieving the collection of all tickets, the method signature should use the `List` interface.
 *     *   `java.util.Scanner` to read user commands and input from the console.
 *     *   `switch` statement for handling different user commands.
 *     *   `System.err` for outputting error messages.
 *     *   `System.out` for all normal output (menu, prompts, success messages, ticket listings).
 *     *   Implement class-wide exception handling using `try-catch` blocks to manage potential runtime errors during the application's execution cycle.
 * 
 * 3.  **Best Practices:**
 *     *   Design your classes using proper encapsulation (private fields, public methods where necessary).
 *     *   Use meaningful and descriptive names for variables, methods, and classes.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for key classes/methods).
 *     *   Implement basic input validation (e.g., ensuring a ticket description is not empty).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * *   The system should display a clear menu of available commands upon startup and after each operation.
 * *   Prompts should guide the user when input is required (e.g., "Enter ticket description:").
 * *   Successful operations should be confirmed with messages printed to `System.out`.
 * *   Listing tickets should clearly display each ticket's details using `System.out`.
 * *   Error conditions (like an invalid command, attempting to process an empty queue, or invalid input) must result in an informative message printed to `System.err`.
 * *   Unexpected runtime errors should be caught by the class-wide exception handling and reported via `System.err`, possibly including stack trace information for debugging.
 * 
 * Your task is to provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a basic Customer Support Ticket System as described in the exam question, demonstrating the required advanced Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is divided into two main classes:
 *     *   `Ticket`: An object representing a single support ticket. It encapsulates the ticket's state (`id`, `description`, `status`) and provides methods to access and modify this state (`getters`, `setStatus`). An `enum` `TicketStatus` is used for clear status representation. The constructor includes basic input validation for the description.
 *     *   `SupportSystem`: This class acts as the controller and data manager for the system. It holds the collections of tickets and contains the logic for handling commands.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `Queue<Ticket> pendingTickets`: A `LinkedList` (which implements `Queue`) is used here. `Queue` is ideal for managing items in a First-In, First-Out (FIFO) manner, perfectly simulating a waiting line for tickets to be processed. The `offer()` method adds tickets to the end, and `poll()` retrieves and removes the ticket from the front.
 *     *   `ArrayList<Ticket> allTickets`: An `ArrayList` is used to store a reference to every `Ticket` object created. This allows easy iteration and listing of all tickets, regardless of whether they are currently pending in the queue or have been processed.
 *     *   `List<Ticket> getAllTickets()`: The method that provides access to all tickets returns a `List<Ticket>`. This demonstrates coding to the interface, which is a key Java best practice, allowing flexibility if the underlying implementation of `allTickets` were to change (though in this case, it remains an `ArrayList`).
 * 
 * 3.  **User Input and Control Flow (`Scanner`, `switch`):**
 *     *   `Scanner scanner`: An instance of `Scanner` is used to read lines of input from `System.in`, capturing user commands and ticket descriptions.
 *     *   `switch (command)`: Inside the `run()` method's main loop, a `switch` statement is used to direct the program flow based on the user's typed command ("submit", "process", "list", "exit", or invalid input). This provides a clear and efficient way to handle multiple distinct command options.
 * 
 * 4.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println(...)`: Used for all standard output, including the menu, prompts, success messages confirming actions (like ticket submission or processing), and the formatted list of all tickets.
 *     *   `System.err.println(...)`: Used specifically for error messages. This includes reporting invalid user commands, indicating when there are no pending tickets to process, reporting validation errors during submission, and outputting details of any unexpected exceptions caught by the general error handling. Using `System.err` separates error output from normal program output, which is useful in real-world scenarios (e.g., for logging or redirection).
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   **Class-wide Handling:** The main `while` loop in the `run()` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level safety net, catching any unexpected runtime exceptions that might occur during the processing of commands and preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 *     *   **Specific Handling:** The `submitTicket` method includes a `try-catch(IllegalArgumentException e)` block specifically to catch validation errors thrown by the `Ticket` constructor if the description is empty. This allows for a more specific error message to be printed via `System.err` for this known error condition.
 *     *   **Resource Management (`finally`):** The `run()` method's `try-catch` block includes a `finally` block. This ensures that the `scanner.close()` method is called whether the loop finishes normally (due to the "exit" command) or if an unexpected exception occurs, releasing the system resource.
 * 
 * 6.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Fields in `Ticket` and `SupportSystem` are `private`, accessed and modified via public or package-private methods.
 *     *   **Meaningful Names:** Variables (`pendingTickets`, `nextTicketId`), methods (`submitTicket`, `processNextTicket`, `displayMenu`), and classes (`Ticket`, `SupportSystem`) have names that clearly indicate their purpose.
 *     *   **Documentation:** Javadoc comments are included for classes and key methods, explaining their function, parameters, and potential exceptions.
 *     *   **Input Validation:** The `Ticket` constructor explicitly checks for null or empty descriptions, throwing an `IllegalArgumentException`. This validation is handled in the `submitTicket` method.
 *     *   **Clean Structure:** The code is organized into logical classes, and the `run` method orchestrates the main application flow by calling dedicated methods for specific tasks (submit, process, list, display menu).
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of collections, control flow, I/O streams, and robust error handling techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum to represent the possible states of a support ticket
enum TicketStatus {
    PENDING, PROCESSING, RESOLVED
}

/**
 * Represents a single support ticket in the system.
 * Encapsulates ticket details like ID, description, and status.
 */
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    /**
     * Constructs a new Ticket with a given ID and description.
     * Status is initialized to PENDING.
     * @param id The unique identifier for the ticket.
     * @param description A brief description of the issue.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Ticket(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = TicketStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the ticket.
     * @param status The new status for the ticket.
     */
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     * @return Formatted string showing ticket details.
     */
    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: \"%s\", Status: %s", id, description, status);
    }
}

/**
 * Manages the collection of support tickets.
 * Handles submission, processing, and listing of tickets.
 * Uses Queue for pending tickets and ArrayList for all tickets.
 */
class SupportSystem {
    // Queue holding tickets that are pending processing (FIFO)
    private Queue<Ticket> pendingTickets;
    // List holding ALL tickets ever created (for listing purposes)
    private List<Ticket> allTickets;
    // Counter to generate unique ticket IDs
    private int nextTicketId;
    // Scanner to read user input
    private Scanner scanner;

    /**
     * Constructs a new SupportSystem, initializing collections and scanner.
     */
    public SupportSystem() {
        // LinkedList is a common implementation of the Queue interface
        this.pendingTickets = new LinkedList<>();
        // ArrayList is used for general list storage
        this.allTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Submits a new support ticket.
     * Creates a Ticket object, adds it to the pending queue and the all-tickets list.
     * Reports success or validation errors.
     * @param description The user-provided description for the ticket.
     */
    public void submitTicket(String description) {
        try {
            // Ticket constructor handles validation for empty description
            Ticket newTicket = new Ticket(nextTicketId, description);
            pendingTickets.offer(newTicket); // Add to the end of the queue (non-blocking)
            allTickets.add(newTicket); // Add to the list of all tickets
            System.out.println("Successfully submitted ticket with ID: " + nextTicketId);
            nextTicketId++; // Prepare for the next ticket
        } catch (IllegalArgumentException e) {
            // Specific error handling for invalid description input
            System.err.println("Submission failed: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during submission
            System.err.println("An unexpected error occurred during submission: " + e.getMessage());
            // Optionally, log the full stack trace for debugging:
            // e.printStackTrace(System.err);
        }
    }

    /**
     * Processes the next ticket from the pending queue (FIFO).
     * Removes the ticket from the queue and updates its status in the all-tickets list.
     * Reports success or error if queue is empty.
     */
    public void processNextTicket() {
        // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        Ticket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess != null) {
            // Update the status of the ticket object. Since the object is the same
            // in both pendingTickets (before poll) and allTickets, updating it here
            // reflects the change when listing from allTickets.
            ticketToProcess.setStatus(TicketStatus.PROCESSING);
            System.out.println("Started processing ticket: " + ticketToProcess.getId());
            // Simulate completion immediately for this example
            ticketToProcess.setStatus(TicketStatus.RESOLVED);
            System.out.println("Ticket " + ticketToProcess.getId() + " is now RESOLVED.");
        } else {
            // Handle the case where the queue is empty using System.err
            System.err.println("Error: No pending tickets to process.");
        }
    }

    /**
     * Retrieves a list of all tickets currently managed by the system.
     * Uses the List interface as the return type.
     * @return A List containing all tickets.
     */
    public List<Ticket> getAllTickets() {
        // Return the ArrayList. The method signature uses the List interface.
        return allTickets;
    }

    /**
     * Displays the menu of available commands to the user.
     * Prints to System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Support System Menu ---");
        System.out.println("submit   - Submit a new ticket");
        System.out.println("process  - Process the next pending ticket");
        System.out.println("list     - List all tickets");
        System.out.println("exit     - Exit the application");
        System.out.println("---------------------------");
    }

    /**
     * Runs the main interactive loop of the support system.
     * Reads user commands, delegates to appropriate methods, and handles errors.
     * Implements class-wide exception handling.
     */
    public void run() {
        System.out.println("Welcome to the Customer Support Ticket System!");
        boolean running = true;

        // Class-wide exception handling block wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase(); // Read command, trim whitespace, lowercase

                // Switch statement to handle different commands
                switch (command) {
                    case "submit":
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine(); // Read the description
                        submitTicket(description); // Delegate to submit method
                        break; // End of submit case

                    case "process":
                        processNextTicket(); // Delegate to process method
                        break; // End of process case

                    case "list":
                        List<Ticket> tickets = getAllTickets(); // Get all tickets using List interface
                        if (tickets.isEmpty()) {
                            System.out.println("No tickets in the system yet.");
                        } else {
                            System.out.println("\n--- All Tickets ---");
                            for (Ticket ticket : tickets) {
                                System.out.println(ticket); // Uses Ticket's toString()
                            }
                            System.out.println("-------------------");
                        }
                        break; // End of list case

                    case "exit":
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to terminate the loop
                        break; // End of exit case

                    default:
                        // Handle unrecognized commands using System.err
                        System.err.println("Error: Invalid command '" + command + "'. Please enter 'submit', 'process', 'list', or 'exit'.");
                        break; // End of default case
                } // End of switch statement

            } // End of while(running) loop
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that weren't specifically handled
            System.err.println("\nAn unrecoverable error occurred during system operation:");
            // Print the stack trace to standard error for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure resources are cleaned up, specifically closing the Scanner
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation message
            }
        }
    }

    /**
     * Main method to start the Support System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run(); // Start the main application loop
    }
}
