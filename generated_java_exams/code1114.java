/*
 * Exam Question #1114
 * Generated on: 2025-05-12 17:26:48
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Entry Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system to manage attendees for a popular event. The system needs to handle ticket sales and control entry into the event venue. People arrive and form a queue to enter, but they can only enter if they have previously purchased a ticket.
 * 
 * Your program should simulate this process with a menu-driven interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of names of people who have successfully purchased a ticket. Use `java.util.ArrayList` and declare it using the `java.util.List` interface.
 *     *   Maintain a queue of names representing people currently waiting in line to enter the event. Use `java.util.Queue`. A `LinkedList` is a common implementation for a Queue.
 * 
 * 2.  **User Interface:**
 *     *   Present a menu with the following options:
 *         1.  Buy Ticket
 *         2.  Join Entry Queue
 *         3.  Process Entry Queue (attempt to let people enter)
 *         4.  Display Status (show ticket holders and queue)
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read user input for menu choices and attendee names.
 * 
 * 3.  **Functionality:**
 *     *   **Buy Ticket:** Prompt for a name. Add the name to the list of ticket holders. Print a success message using `System.out`. If the name is empty or null, print an error using `System.err`.
 *     *   **Join Entry Queue:** Prompt for a name. Add the name to the end of the entry queue. Print a message indicating they have joined the queue using `System.out`. If the name is empty or null, print an error using `System.err`.
 *     *   **Process Entry Queue:** This action simulates checking people at the front of the line.
 *         *   Check if the queue is empty. If so, print a message using `System.out`.
 *         *   If not empty, peek at the name at the front of the queue (`queue.peek()`).
 *         *   Check if this name exists in the list of ticket holders.
 *         *   If the name is found in the ticket holders list:
 *             *   Remove the person from the *front* of the queue (`queue.poll()`).
 *             *   Print a success message using `System.out` indicating they have entered.
 *             *   (Optional but recommended for realism) Remove the name from the ticket holders list to simulate using the ticket once.
 *         *   If the name is *not* found in the ticket holders list:
 *             *   Print an error message using `System.err` indicating they do not have a ticket and cannot enter *yet*. The person remains at the front of the queue until they get a ticket or leave the line (which this simple system doesn't simulate, but the core requirement is they don't enter).
 *     *   **Display Status:** Print the current list of ticket holders and the current state of the entry queue using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling:**
 *     *   Use a `switch` statement for the main menu navigation.
 *     *   Handle invalid menu inputs (non-numeric, out of range) using `System.err` and prompt again.
 *     *   Implement robust input validation for names (check for empty strings or nulls). Use `System.err` for validation errors.
 *     *   Wrap the main application loop or critical sections in a `try-catch` block to catch potential runtime exceptions (e.g., `InputMismatchException` if reading non-integer for menu, although checking `hasNextInt` is better, a general catch demonstrates the requirement). Print error details using `System.err`.
 *     *   Use `System.out` for all successful operations and informational messages.
 *     *   Use `System.err` for all error messages and invalid inputs.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic.
 *     *   Ensure proper encapsulation (private fields, public methods where necessary).
 *     *   Structure the code logically within a class.
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu, process user commands, and output status or error messages as described above, until the user chooses to exit.
 * 
 * Example interaction snippets:
 * ```
 * --- Event Entry System Menu ---
 * 1. Buy Ticket
 * 2. Join Entry Queue
 * 3. Process Entry Queue
 * 4. Display Status
 * 5. Exit
 * Enter choice: 1
 * Enter name to buy ticket: Alice
 * Ticket purchased for Alice.
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 2
 * Enter name to join queue: Bob
 * Bob joined the entry queue.
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 2
 * Enter name to join queue: Alice
 * Alice joined the entry queue.
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 4
 * --- System Status ---
 * Ticket Holders: [Alice]
 * Entry Queue: [Bob, Alice]
 * ---------------------
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 3
 * Processing entry queue...
 * Bob does not have a ticket and cannot enter.
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 3
 * Processing entry queue...
 * Alice entered the event!
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 4
 * --- System Status ---
 * Ticket Holders: [] // Alice removed if you implement that
 * Entry Queue: [Bob]
 * ---------------------
 * 
 * --- Event Entry System Menu ---
 * ...
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing the `EventManager` class (or similar) and the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple event entry management system demonstrating the required Java concepts.
 * 
 * 1.  **Data Structures (`List`, `ArrayList`, `Queue`)**:
 *     *   `ticketHolders`: Declared as `List<String>` and initialized with `new ArrayList<>()`. This shows the use of the `List` interface and the `ArrayList` implementation. `ArrayList` is suitable here because we need to store a dynamic list of names and efficiently check for the presence of a name (`contains`).
 *     *   `entryQueue`: Declared as `Queue<String>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing efficient insertion at the tail (`offer`) and removal/peeking at the head (`peek`, `poll`), which is exactly what's needed for a queueing system.
 * 
 * 2.  **User Input (`Scanner`)**:
 *     *   A `Scanner` object is created to read input from `System.in`.
 *     *   `scanner.nextLine()` is used to read names, which handles potential spaces in names and consumes the newline character.
 *     *   `scanner.hasNextInt()` and `scanner.nextInt()` are used carefully to read the menu choice, followed by `scanner.nextLine()` to consume the leftover newline, preventing issues in subsequent `nextLine()` calls.
 * 
 * 3.  **Flow Control (`switch`)**:
 *     *   A `switch` statement is used within the main `run` loop to direct execution based on the user's integer choice from the menu. This provides a clear and readable way to handle multiple discrete options.
 * 
 * 4.  **Output Streams (`System.out`, `System.err`)**:
 *     *   `System.out.println()` is used for all standard output, including the menu, success messages, status displays, and informational messages.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid input, validation failures (empty name), or logical errors (person in queue has no ticket). This is good practice for separating normal output from error information, which can be useful for logging or redirection.
 * 
 * 5.  **Exception Handling (`try-catch`)**:
 *     *   A `try-catch` block is wrapped around the main `while` loop in the `run()` method. This provides a broad, class-wide catch for any unexpected `Exception` that might occur during the execution of the program loop (e.g., issues with `Scanner`, although specific checks like `hasNextInt` reduce the likelihood of `InputMismatchException` here, a general catch demonstrates the requirement).
 *     *   The `catch` block prints a generic error message and the stack trace to `System.err` for debugging.
 *     *   A `finally` block ensures the `Scanner` resource is closed properly when the loop finishes or an exception occurs.
 * 
 * 6.  **Core Logic (`buyTicket`, `joinQueue`, `processQueue`, `displayStatus`)**:
 *     *   `buyTicket`: Adds a validated name to the `ticketHolders` `ArrayList`. Includes a check for empty names.
 *     *   `joinQueue`: Adds a validated name to the `entryQueue` `LinkedList` using `offer()`. Includes a check for empty names.
 *     *   `processQueue`: Implements the core logic for entry. It `peek()`s at the front of the queue. If the name is in `ticketHolders`, it `poll()`s (removes) the name from the queue and removes it from `ticketHolders`. Otherwise, it prints an error to `System.err`, and the person remains in the queue (at the front). It also handles the empty queue case.
 *     *   `displayStatus`: Prints the contents of both the `ticketHolders` list and the `entryQueue` using their default `toString()` methods, providing a snapshot of the system's state.
 * 
 * 7.  **Best Practices**:
 *     *   **Encapsulation**: `ticketHolders`, `entryQueue`, and `scanner` are private fields, accessed and modified only through the class's methods.
 *     *   **Naming**: Method names (`buyTicket`, `joinQueue`, `processQueue`, `displayStatus`, `run`), variable names (`ticketHolders`, `entryQueue`, `choice`, `name`), and class name (`EventManager`) are descriptive.
 *     *   **Comments**: Javadoc comments explain the purpose of the class and methods, and inline comments clarify specific logic points.
 *     *   **Input Validation**: Checks for empty names and validates menu choice input type and range.
 *     *   **Error Handling**: Explicitly uses `System.err` for errors and includes the `try-catch` block.
 *     *   **Structure**: The code is organized into a single class with a `main` method to start execution and dedicated private methods for each distinct action.
 * 
 * This solution effectively integrates all specified Java components into a practical scenario, demonstrating a good understanding of data structures, control flow, I/O, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages event attendees, handling ticket sales and entry queue processing.
 * Demonstrates usage of List, ArrayList, Queue, Scanner, switch, System.out/err,
 * and basic exception handling.
 */
public class EventManager {

    private List<String> ticketHolders; // List of people who bought tickets
    private Queue<String> entryQueue; // Queue of people waiting to enter
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs an EventManager with empty ticket list and entry queue.
     */
    public EventManager() {
        this.ticketHolders = new ArrayList<>(); // Use ArrayList implementation
        this.entryQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Entry System Menu ---");
        System.out.println("1. Buy Ticket");
        System.out.println("2. Join Entry Queue");
        System.out.println("3. Process Entry Queue");
        System.out.println("4. Display Status");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Prompts user for a name and adds it to the ticket holders list.
     */
    private void buyTicket() {
        System.out.print("Enter name to buy ticket: ");
        String name = scanner.nextLine().trim(); // Read entire line and trim whitespace

        if (name.isEmpty()) {
            System.err.println("Error: Name cannot be empty.");
            return;
        }

        if (ticketHolders.contains(name)) {
             System.out.println(name + " already has a ticket.");
        } else {
            ticketHolders.add(name);
            System.out.println("Ticket purchased for " + name + ".");
        }
    }

    /**
     * Prompts user for a name and adds it to the entry queue.
     */
    private void joinQueue() {
        System.out.print("Enter name to join queue: ");
        String name = scanner.nextLine().trim(); // Read entire line and trim whitespace

        if (name.isEmpty()) {
            System.err.println("Error: Name cannot be empty.");
            return;
        }

        // In a real system, you might prevent duplicates in queue, but for this
        // problem, we allow it to keep the queue simple.
        entryQueue.offer(name); // offer is generally preferred over add for queues
        System.out.println(name + " joined the entry queue.");
    }

    /**
     * Processes the person at the front of the entry queue.
     * Checks if they have a ticket and allows entry if they do.
     */
    private void processQueue() {
        System.out.println("Processing entry queue...");

        if (entryQueue.isEmpty()) {
            System.out.println("Entry queue is empty. No one is waiting.");
            return;
        }

        String personInLine = entryQueue.peek(); // Look at the person at the front without removing

        if (ticketHolders.contains(personInLine)) {
            // Person has a ticket, allow entry
            String enteredPerson = entryQueue.poll(); // Remove the person from the queue
            System.out.println(enteredPerson + " entered the event!");
            // Optional: Remove from ticket holders to simulate ticket usage
             ticketHolders.remove(enteredPerson);
        } else {
            // Person does not have a ticket
            System.err.println(personInLine + " does not have a ticket and cannot enter.");
            // Person remains at the front of the queue
        }
    }

    /**
     * Displays the current status of ticket holders and the entry queue.
     */
    private void displayStatus() {
        System.out.println("\n--- System Status ---");
        System.out.println("Ticket Holders: " + ticketHolders);
        System.out.println("Entry Queue: " + entryQueue);
        System.out.println("---------------------");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();

                // Check if the next input is an integer before reading
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Use switch for flow control based on user choice
                switch (choice) {
                    case 1:
                        buyTicket();
                        break;
                    case 2:
                        joinQueue();
                        break;
                    case 3:
                        processQueue();
                        break;
                    case 4:
                        displayStatus();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
