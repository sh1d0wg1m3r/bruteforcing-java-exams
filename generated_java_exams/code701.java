/*
 * Exam Question #701
 * Generated on: 2025-05-12 16:27:53
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Task Processing System Simulation**
 * 
 * You are tasked with developing a simple command-line application to simulate a basic task processing system. The system should allow users to add new tasks to a queue, process the next task from the queue, view the current tasks in the queue, and view a history of completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** A task can be represented by a simple `String` description.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold tasks that are waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Ensure at least one method returns or accepts a `java.util.List` interface type, even if the underlying implementation is `ArrayList`.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands and task descriptions from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Task
 *         2.  Process Next Task
 *         3.  View Task Queue
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 4.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement input validation (e.g., ensuring task description is not empty, handling non-integer input for the menu).
 *     *   Use `try-catch` blocks for exception handling. Specifically, include class-wide or method-level exception handling to catch potential runtime errors and gracefully inform the user.
 *     *   Handle the specific case of attempting to process a task when the queue is empty.
 * 6.  **Best Practices:**
 *     *   Design a class (e.g., `TaskProcessor`) to encapsulate the queue and completed tasks list.
 *     *   Use private fields and public methods (`addTask`, `processNextTask`, `getTaskQueue`, `getCompletedTasks`).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain the purpose of classes, methods, or complex logic.
 *     *   Ensure clean code structure and indentation.
 * 
 * **Execution Flow:**
 * 
 * 1.  The program starts, displays the menu.
 * 2.  It prompts the user for a menu choice.
 * 3.  Based on the choice, it performs the corresponding action:
 *     *   **Add Task:** Prompts for a task description, adds it to the queue. Validates input.
 *     *   **Process Next Task:** Removes the task at the front of the queue and adds it to the completed list. If the queue is empty, print an error message to `System.err`.
 *     *   **View Task Queue:** Prints all tasks currently in the queue.
 *     *   **View Completed Tasks:** Prints all tasks that have been processed.
 *     *   **Exit:** Terminates the program.
 * 4.  The menu is displayed again after an action (unless exiting).
 * 5.  Input errors (like non-integer menu choice) should be caught, reported using `System.err`, and the menu re-displayed.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Task Processing Menu ---
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write Exam Question
 * Task added: Write Exam Question
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Write Exam Question
 * Task completed.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Task Queue ---
 * (Queue is empty)
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * - Write Exam Question
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 2
 * Error: The task queue is currently empty. (printed to System.err)
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. (printed to System.err)
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processor.
 * ```
 * 
 * Write the complete Java code for this application.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Processing System as requested, utilizing all the specified Java components and adhering to best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `TaskProcessor` class uses a `LinkedList` (which implements the `Queue` interface) named `taskQueue` to store tasks that are waiting to be processed. `offer()` is used to add tasks to the end of the queue, and `poll()` is used to retrieve and remove tasks from the front (head) of the queue. This correctly simulates a First-In, First-Out (FIFO) processing order.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `TaskProcessor` class uses an `ArrayList` named `completedTasks` to store tasks that have been processed. The `add()` method is used to append completed tasks to this list.
 * 3.  **`List` interface (`java.util.List`)**: The `TaskProcessor` methods `getTaskQueue()` and `getCompletedTasks()` are declared to return `List<String>`. Although the internal implementation uses `ArrayList` and `LinkedList` (copied into an ArrayList for return), returning the `List` interface type promotes good design principles, allowing the caller to work with the general `List` contract without knowing the specific implementation details.
 * 4.  **`Scanner` (`java.util.Scanner`)**: The `TaskProcessorApp` class uses a `Scanner` object (`scanner`) to read user input from `System.in` for menu choices and task descriptions. `nextInt()` is used for the integer menu choice, and `nextLine()` is used for reading the task description (and consuming the newline after `nextInt()`).
 * 5.  **`Switch` statement**: The `run()` method in `TaskProcessorApp` uses a `switch` statement to direct the program flow based on the user's integer choice from the menu, calling the appropriate private methods (`addTask`, `processNextTask`, etc.).
 * 6.  **`System.err`**: `System.err.println()` is used in `TaskProcessorApp` to display error messages for invalid menu choices (`default` case in `switch`), `InputMismatchException`, empty task descriptions, and within `TaskProcessor.processNextTask()` when attempting to process a task from an empty queue.
 * 7.  **`System.out`**: `System.out.println()` is used for displaying the menu, prompts, successful action messages (task added, task completed), and listing the contents of the queue and completed tasks list.
 * 8.  **Class-wide Exception Handling (`try-catch`)**: A `try-catch` block is wrapped around the core `while` loop in the `run()` method of `TaskProcessorApp`. This block specifically catches `InputMismatchException` for handling non-integer input gracefully and includes a general `catch (Exception e)` to handle any other unexpected runtime errors, demonstrating a robust approach to program execution. Specific error conditions like an empty queue are handled closer to where they occur (in `TaskProcessor.processNextTask`) but reported using `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `TaskProcessor` class encapsulates the `taskQueue` and `completedTasks` data structures. These fields are `private`, and interaction with them is done through public methods (`addTask`, `processNextTask`, `getTaskQueue`, `getCompletedTasks`), hiding the internal implementation details.
 * *   **Meaningful Names:** Variable names (`taskQueue`, `completedTasks`, `choice`, `description`) and method names (`addTask`, `processNextTask`, `displayMenu`, `run`) are descriptive and indicate their purpose.
 * *   **Comments:** Basic comments are included to explain the purpose of classes, methods, and key logic sections.
 * *   **Input Validation:** The `addTask` method checks if the task description is empty after trimming whitespace and reports an error using `System.err` if it is. The `try-catch` for `InputMismatchException` handles invalid input types for the menu choice.
 * *   **Error Handling:** Explicit checks for an empty queue are made in `TaskProcessor.processNextTask()`, and an error is reported. The `try-catch` blocks handle input errors and general exceptions.
 * *   **Clean Code Structure:** The code is divided into two classes (`TaskProcessorApp` for the UI/main loop and `TaskProcessor` for the core logic), promoting separation of concerns. Methods are relatively short and focused on single responsibilities. Indentation and formatting are consistent.
 * 
 * This solution effectively demonstrates the required Java concepts and best practices within a practical, albeit simple, simulation scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a simple Task Processor application.
 * Manages a queue of tasks to be processed and a list of completed tasks.
 */
public class TaskProcessorApp {

    private TaskProcessor taskProcessor;
    private Scanner scanner;

    /**
     * Constructor to initialize the TaskProcessor and Scanner.
     */
    public TaskProcessorApp() {
        this.taskProcessor = new TaskProcessor();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling for robustness.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewTaskQueue();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processor.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Handles adding a new task based on user input.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Trim whitespace

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
        } else {
            taskProcessor.addTask(description);
            System.out.println("Task added: " + description);
        }
    }

    /**
     * Handles processing the next task from the queue.
     */
    private void processNextTask() {
        String task = taskProcessor.processNextTask();
        if (task != null) {
            System.out.println("Processing task: " + task);
            System.out.println("Task completed.");
        } else {
            // Error message handled within TaskProcessor, but we could add more here if needed
        }
    }

    /**
     * Displays the current tasks in the queue.
     */
    private void viewTaskQueue() {
        System.out.println("--- Current Task Queue ---");
        List<String> queueTasks = taskProcessor.getTaskQueue(); // Get as List
        if (queueTasks.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            for (int i = 0; i < queueTasks.size(); i++) {
                System.out.println((i + 1) + ". " + queueTasks.get(i));
            }
        }
    }

    /**
     * Displays the list of completed tasks.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        List<String> completed = taskProcessor.getCompletedTasks(); // Get as List
        if (completed.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            for (int i = 0; i < completed.size(); i++) {
                System.out.println("- " + completed.get(i));
            }
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorApp app = new TaskProcessorApp();
        app.run();
    }
}

/**
 * Manages the task queue and completed tasks list.
 * Demonstrates encapsulation.
 */
class TaskProcessor {
    // Using LinkedList as a Queue implementation
    private Queue<String> taskQueue;
    // Using ArrayList to store completed tasks
    private ArrayList<String> completedTasks;

    /**
     * Constructor to initialize the data structures.
     */
    public TaskProcessor() {
        this.taskQueue = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task description to the task queue.
     *
     * @param taskDescription The description of the task to add.
     */
    public void addTask(String taskDescription) {
        // Offer adds to the tail of the queue
        taskQueue.offer(taskDescription);
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue and adds it to the completed list.
     *
     * @return The description of the processed task, or null if the queue was empty.
     */
    public String processNextTask() {
        // Poll retrieves and removes the head of the queue, returns null if empty
        String nextTask = taskQueue.poll();
        if (nextTask != null) {
            completedTasks.add(nextTask);
            return nextTask;
        } else {
            System.err.println("Error: The task queue is currently empty.");
            return null;
        }
    }

    /**
     * Gets an unmodifiable view of the current task queue.
     * Returns a List interface type.
     *
     * @return A List containing the tasks currently in the queue (order preserved).
     */
    public List<String> getTaskQueue() {
        // Return a new ArrayList copy to prevent external modification of the internal queue
        // Although not strictly necessary by the requirements, it's good practice.
        // Returning List<String> demonstrates using the interface type.
        return new ArrayList<>(taskQueue);
    }

    /**
     * Gets an unmodifiable view of the completed tasks list.
     * Returns a List interface type.
     *
     * @return A List containing the completed tasks.
     */
    public List<String> getCompletedTasks() {
        // Returning List<String> demonstrates using the interface type.
        return new ArrayList<>(completedTasks); // Return a copy
    }
}
