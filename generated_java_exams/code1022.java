/*
 * Exam Question #1022
 * Generated on: 2025-05-12 17:14:10
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Objective:** Design and implement a simple command-line Task Management System that allows users to add tasks to a pending queue, process the next task, view pending tasks, and view completed tasks. This task requires you to demonstrate your understanding of fundamental and intermediate Java concepts, including collections, input handling, control flow, and exception management.
 * 
 * **Scenario:** You are building a basic system to manage tasks in a First-In, First-Out (FIFO) manner. New tasks are added to a waiting list (queue). When a task is processed, it is removed from the waiting list and moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store tasks that are waiting to be processed (pending tasks).
 *     *   Use `java.util.ArrayList` (declared as `java.util.List`) to store tasks that have been completed.
 * 
 * 2.  **Task Representation:**
 *     *   Create a simple `Task` class with a private field for the task description (String) and appropriate constructor and getter methods. Include a `toString()` method for easy printing.
 * 
 * 3.  **Task Management Logic:**
 *     *   Create a `TaskManager` class that encapsulates the `Queue` of pending tasks and the `List` of completed tasks.
 *     *   Implement methods in `TaskManager`:
 *         *   `addTask(String description)`: Adds a new `Task` to the pending queue. Should validate that the description is not null or empty.
 *         *   `processNextTask()`: Removes the next task from the pending queue and adds it to the completed tasks list. Should handle the case where the pending queue is empty.
 *         *   `viewPendingTasks()`: Displays the tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Displays the tasks currently in the completed tasks list.
 * 
 * 4.  **User Interface:**
 *     *   Create a main application class (e.g., `TaskManagerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should loop until the user chooses to exit.
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   Validate user input for the menu choice (ensure it's a valid number within the range).
 *     *   Validate the task description (ensure it's not empty).
 *     *   Handle the scenario where the user tries to process a task when the pending queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `main` method's operational loop to catch potential runtime errors (e.g., non-integer input for menu choice).
 *     *   Use `System.out` for normal output (menu, prompts, task lists, success messages).
 *     *   Use `System.err` for error messages (invalid input, trying to process an empty queue, etc.).
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested actions, printing status messages or task lists to `System.out`. Invalid operations or inputs should result in error messages printed to `System.err`.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: Buy groceries
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task added: Pay bills
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Buy groceries
 * 2. Pay bills
 * --------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Buy groceries
 * Task completed: Buy groceries
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Pay bills
 * --------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Buy groceries
 * --------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Pay bills
 * Task completed: Pay bills
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System following the requirements. Let's break down how each required component and best practice is applied.
 * 
 * 1.  **Scenario and Structure:** The problem simulates a basic task processing flow. The system is structured into three classes:
 *     *   `Task`: Represents the data for a single task.
 *     *   `TaskManager`: Contains the core logic and data structures for managing tasks.
 *     *   `TaskManagerApp`: Contains the `main` method, handling user interaction and driving the application. This separation promotes modularity and encapsulation.
 * 
 * 2.  **Required Java Components:**
 *     *   **`java.util.Queue`**: The `TaskManager` class uses a `Queue<Task>` named `pendingTasks`. A `LinkedList` is used as the concrete implementation because it efficiently supports queue operations (`offer` for adding, `poll` for removing from the head). This correctly models the FIFO requirement for tasks waiting to be processed.
 *     *   **`java.util.ArrayList`**: The `TaskManager` class uses an `ArrayList<Task>` to store `completedTasks`. `ArrayList` is suitable here because we primarily add to the end and iterate through the list, which `ArrayList` handles efficiently.
 *     *   **`java.util.List`**: The `completedTasks` variable in `TaskManager` is declared as `List<Task>`, but instantiated as `new ArrayList<>()`. This demonstrates programming to the interface (`List`) rather than the concrete implementation (`ArrayList`), which is a core principle of good design, allowing for easier changes to the underlying list implementation in the future if needed.
 *     *   **`java.util.Scanner`**: The `TaskManagerApp` class uses `Scanner` in its `main` method to read user input from `System.in` for menu choices and task descriptions.
 *     *   **`switch` statement**: The `main` method uses a `switch` statement based on the user's integer choice to navigate between the different menu options (Add Task, Process Task, etc.).
 *     *   **`System.err`**: `System.err.println()` is used specifically for printing error messages, such as when the user enters invalid input (non-numeric choice, choice out of range) or attempts an invalid operation (processing a task when the queue is empty).
 *     *   **`System.out`**: `System.out.println()` is used for all normal output, including the menu, prompts, confirmation messages (task added, task completed), and displaying the lists of pending and completed tasks.
 *     *   **Class-wide exception handling with `try-catch`**: The `main` method's primary `while` loop, which contains the core application logic, is wrapped in a `try-catch` block. This fulfills the requirement for "class-wide" handling by catching potential exceptions that might occur during the application's runtime loop. Additionally, a specific `try-catch(InputMismatchException)` is used around `scanner.nextInt()` to gracefully handle cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt for input again.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** The `Task` class has a private `description` field accessed only via a public getter. The `TaskManager` class has private `pendingTasks` and `completedTasks` collections, accessed only through public methods (`addTask`, `processNextTask`, etc.). This hides the internal state and implementation details.
 *     *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskManagerApp`), method names (`addTask`, `processNextTask`, `viewPendingTasks`), and variable names (`description`, `pendingTasks`, `completedTasks`, `scanner`, `choice`) are descriptive and indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and public methods explaining their purpose, parameters, and return values. Inline comments are used for specific details, like explaining the `Scanner` `nextLine()` consumption.
 *     *   **Input Validation:** The `addTask` method checks if the description is null or empty. The `main` method checks if the menu choice is within the valid range (1-5) and uses `try-catch` for non-integer input.
 *     *   **Error Handling:** Specific error messages are provided for invalid operations (empty queue) and invalid input (wrong type, out of range). `System.err` is used for these messages. The `try-catch` blocks handle exceptions gracefully.
 *     *   **Clean Code Structure:** The code is divided into logical classes. Methods are relatively small and focused on a single responsibility. Indentation and formatting are consistent.
 * 
 * 4.  **Additional Details:**
 *     *   The `Scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues when reading the task description string afterwards.
 *     *   The `TaskManager.processNextTask()` method returns a boolean to indicate whether a task was actually processed (useful for the caller, although not strictly necessary based on the prompt's output format, it's good practice).
 *     *   Iterating through the `Queue` in `viewPendingTasks` uses a simple `for-each` loop, which traverses the elements without removing them, as required for viewing.
 * 
 * This solution effectively integrates all specified Java components and demonstrates adherence to good programming practices within the context of a practical, albeit simplified, application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return The task description.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 */
class TaskManager {
    // Use Queue for FIFO pending tasks
    private Queue<Task> pendingTasks;
    // Use List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the description is not null or empty.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list.
     * Handles the case where the pending queue is empty.
     * @return true if a task was processed, false otherwise.
     */
    public boolean processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return false;
        }
        Task taskToProcess = pendingTasks.poll(); // poll removes and returns the head
        completedTasks.add(taskToProcess);
        System.out.println("Processing task: " + taskToProcess.getDescription());
        System.out.println("Task completed: " + taskToProcess.getDescription());
        return true;
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate and print tasks in the queue without removing them
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate and print tasks in the list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("--------------------");
    }
}

/**
 * Main application class for the Task Management System.
 * Provides a command-line interface for interacting with the TaskManager.
 */
public class TaskManagerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("--- Welcome to Task Management System ---");

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                // Try-catch block for handling non-integer input
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;
                    case 3: // View Pending Tasks
                        taskManager.viewPendingTasks();
                        break;
                    case 4: // View Completed Tasks
                        taskManager.viewCompletedTasks();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(); // Print stack trace for debugging in an exam context
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
