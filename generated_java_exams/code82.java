/*
 * Exam Question #82
 * Generated on: 2025-05-11 22:10:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Scenario:**
 * 
 * A small clinic needs a simple command-line application to manage patient flow and appointments. Patients arrive and are added to a waiting list. When a doctor is available, the next patient from the waiting list can be scheduled for an appointment with a specific doctor at a given time. The system should also allow viewing the current waiting list and a specific doctor's scheduled appointments.
 * 
 * **Your Task:**
 * 
 * Design and implement a Java application named `HospitalSystem` that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a **waiting list** of patients using a `java.util.Queue`. Patients should be processed in First-In, First-Out (FIFO) order.
 *     *   Maintain a central list of all **scheduled appointments** using a `java.util.List` (specifically, an `ArrayList`).
 * 
 * 2.  **Classes:**
 *     *   Create a `Patient` class with private fields for `id` (int) and `name` (String). Include a constructor and public getter methods.
 *     *   Create an `Appointment` class with private fields for `patient` (Patient object), `doctorName` (String), and `time` (String). Include a constructor and public getter methods.
 *     *   Create a `HospitalSystem` class containing the main logic and data structures. This class should have private fields for the waiting queue and the appointment list.
 * 
 * 3.  **Functionality (via a command-line menu):**
 *     *   **Add Patient to Waiting List:** Prompt for patient's name. Generate a unique integer ID for each patient automatically (start from 1). Add the new `Patient` object to the waiting queue.
 *     *   **Schedule Next Appointment:** Dequeue the next patient from the waiting list. Prompt for the doctor's name and appointment time. Create an `Appointment` object and add it to the appointment list. If the waiting list is empty, display an error message.
 *     *   **View Waiting List:** Display the list of patients currently in the waiting queue, showing their ID and name. If the queue is empty, indicate that.
 *     *   **View Doctor Schedule:** Prompt for a doctor's name. Display all appointments scheduled for that specific doctor, showing patient ID, patient name, doctor name, and time. If no appointments are scheduled for that doctor or the appointment list is empty, indicate that.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **Required Java Components:**
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used for variable declaration)
 *     *   `java.util.Scanner` (for user input)
 *     *   `switch` statement (for menu handling)
 *     *   `System.err` (for error messages, e.g., empty queue when scheduling, invalid input)
 *     *   `System.out` (for menu display, prompts, success messages, list/schedule output)
 *     *   Class-wide exception handling using `try-catch` blocks to handle potential issues like invalid input (non-integer when expecting integer) in the main application loop.
 * 
 * 5.  **Best Practices:**
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining key parts of the code.
 *     *   Implement input validation where necessary (e.g., checking if input is empty or incorrect type).
 *     *   Handle cases where lists/queues are empty gracefully, using `System.err` for errors.
 *     *   Structure the code logically within the `HospitalSystem` class.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the requested action, printing appropriate messages to `System.out` for normal operations and `System.err` for errors.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * Hospital Appointment System Menu:
 * 1. Add Patient to Waiting List
 * 2. Schedule Next Appointment
 * 3. View Waiting List
 * 4. View Doctor Schedule
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Patient Alice (ID: 1) added to waiting list.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 1
 * Enter patient name: Bob
 * Patient Bob (ID: 2) added to waiting list.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting List ---
 * ID: 1, Name: Alice
 * ID: 2, Name: Bob
 * --------------------
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 2
 * Enter doctor name: Dr. Smith
 * Enter appointment time (e.g., 10:00 AM): 10:30 AM
 * Scheduled appointment for patient Alice (ID: 1) with Dr. Smith at 10:30 AM.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting List ---
 * ID: 2, Name: Bob
 * --------------------
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 4
 * Enter doctor name: Dr. Smith
 * --- Dr. Smith's Schedule ---
 * Patient: Alice (ID: 1), Time: 10:30 AM
 * ----------------------------
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 4
 * Enter doctor name: Dr. Jones
 * --- Dr. Jones's Schedule ---
 * No appointments scheduled for Dr. Jones.
 * ----------------------------
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 2
 * Error: Waiting list is empty. Cannot schedule appointment.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: exit (or any non-integer)
 * Error: Invalid input. Please enter a number.
 * 
 * Hospital Appointment System Menu:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Implement the `HospitalSystem` class and necessary helper classes (`Patient`, `Appointment`) to meet all requirements.
 * 
 * **Submission:** Provide the complete Java code for all classes.
 *
 * EXPLANATION:
 * This solution implements the `HospitalSystem` based on the requirements, demonstrating the use of the specified Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` and `Appointment` classes are simple data holders with private fields and public getters, adhering to encapsulation principles. `toString()` methods are overridden for easy printing.
 *     *   `HospitalSystem` is the main class orchestrating the logic. It holds the core data structures (`waitingQueue` and `appointments`) and the methods corresponding to the menu options.
 * 
 * 2.  **Data Structures:**
 *     *   `private Queue<Patient> waitingQueue = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface. This provides efficient FIFO operations (`offer` for adding, `poll` for removing from the front).
 *     *   `private List<Appointment> appointments = new ArrayList<>();`: An `ArrayList` is used to implement the `List` interface. This stores all scheduled appointments and allows easy iteration and searching.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `addPatientToWaitingList()`: Reads patient name, generates a unique ID using `nextPatientId++`, creates a `Patient` object, and adds it to the `waitingQueue` using `offer()`. Includes basic validation for empty names.
 *     *   `scheduleNextAppointment()`: Checks if the `waitingQueue` is empty using `isEmpty()`. If not empty, it removes the next patient using `poll()`. It then reads doctor name and time, creates an `Appointment` object, and adds it to the `appointments` `List` using `add()`. Error messages for empty queue and empty doctor/time input are printed to `System.err`.
 *     *   `viewWaitingList()`: Iterates through the `waitingQueue` using an enhanced for loop. This loop iterates over the elements without removing them, which is suitable for viewing. Checks for an empty queue first. Output goes to `System.out`.
 *     *   `viewDoctorSchedule()`: Reads the doctor's name. Iterates through the entire `appointments` `List`. For each appointment, it checks if the doctor's name matches (case-insensitive). Matching appointments are printed to `System.out`. A flag (`foundAppointments`) is used to determine if the "No appointments found" message should be displayed. Checks for an empty appointment list first. Includes validation for empty doctor name input.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   `run()`: Contains the main application loop (`while (choice != 5)`). It calls `displayMenu()`, reads user input, and uses a `switch` statement to dispatch to the appropriate method based on the user's integer choice.
 * 
 * 4.  **Required Component Usage:**
 *     *   `Queue`: Used for `waitingQueue`, with `offer()` and `poll()`.
 *     *   `ArrayList`: Used for `appointments`, initialized as `new ArrayList<>()`.
 *     *   `List`: The `appointments` variable is declared as `List<Appointment>`, demonstrating programming to the interface.
 *     *   `Scanner`: An instance `scanner` is created to read input from `System.in`. `nextInt()` and `nextLine()` are used. `nextLine()` is used after `nextInt()` to consume the leftover newline character.
 *     *   `switch`: Used in the `run()` method to handle the main menu options based on the integer `choice`.
 *     *   `System.err`: Used specifically for printing error messages (e.g., empty queue, invalid menu choice, invalid input type).
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and the contents of the waiting list and doctor schedules.
 *     *   `try-catch`: A `try-catch` block wraps the input reading and switch statement within the `run()` loop. It specifically catches `InputMismatchException` for handling non-integer input from `scanner.nextInt()`, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. A general `catch (Exception e)` is also included as a class-wide handler for any other unexpected runtime errors within the loop, printing the error message and stack trace to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** `Patient`, `Appointment`, and `HospitalSystem` classes have private fields accessed via public methods.
 *     *   **Naming:** Variable and method names like `waitingQueue`, `addPatientToWaitingList`, `doctorName`, `patientToSchedule` are descriptive.
 *     *   **Comments:** Basic comments explain the purpose of classes, fields, and key methods.
 *     *   **Input Validation:** Checks for empty strings for patient name, doctor name, and time are included. The `try-catch` block handles incorrect input types for the menu choice.
 *     *   **Error Handling:** Empty data structures (`waitingQueue`, `appointments`) are checked before attempting operations, and appropriate error messages are printed to `System.err`. Invalid menu choices and input type errors are caught and reported.
 *     *   **Clean Structure:** The logic is divided into methods within the `HospitalSystem` class, making the code modular and readable. The `main` method simply creates an instance and calls the `run()` method to start the application. The `Scanner` is closed when the application exits.
 * 
 * This solution effectively integrates all required components into a functional simulation of a hospital appointment system, demonstrating intermediate to advanced Java programming skills.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient in the system
class Patient {
    private int id;
    private String name;

    // Constructor
    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Getter for patient ID
    public int getId() {
        return id;
    }

    // Getter for patient name
    public String getName() {
        return name;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private String doctorName;
    private String time;

    // Constructor
    public Appointment(Patient patient, String doctorName, String time) {
        this.patient = patient;
        this.doctorName = doctorName;
        this.time = time;
    }

    // Getter for the patient object
    public Patient getPatient() {
        return patient;
    }

    // Getter for doctor's name
    public String getDoctorName() {
        return doctorName;
    }

    // Getter for appointment time
    public String getTime() {
        return time;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return "Patient: " + patient.getName() + " (ID: " + patient.getId() + "), Doctor: " + doctorName + ", Time: " + time;
    }
}

// Main class managing the hospital system logic
public class HospitalSystem {
    // Queue to hold patients waiting for an appointment (FIFO)
    private Queue<Patient> waitingQueue;
    // List to hold all scheduled appointments
    private List<Appointment> appointments;
    // Counter for generating unique patient IDs
    private int nextPatientId;
    // Scanner for reading user input
    private Scanner scanner;

    // Constructor
    public HospitalSystem() {
        // Initialize the waiting queue using LinkedList as a Queue implementation
        this.waitingQueue = new LinkedList<>();
        // Initialize the appointments list using ArrayList
        this.appointments = new ArrayList<>();
        // Start patient IDs from 1
        this.nextPatientId = 1;
        // Initialize the scanner
        this.scanner = new Scanner(System.in);
    }

    // Adds a new patient to the waiting list
    public void addPatientToWaitingList() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine().trim(); // Read full line and trim whitespace

        if (name.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return; // Exit method if name is empty
        }

        // Create a new patient with the next available ID
        Patient newPatient = new Patient(nextPatientId++, name);
        // Add the patient to the end of the waiting queue
        waitingQueue.offer(newPatient); // offer() is preferred over add() for capacity-constrained queues, but works fine here.

        System.out.println("Patient " + newPatient.getName() + " (ID: " + newPatient.getId() + ") added to waiting list.");
    }

    // Schedules the next patient from the waiting list with a doctor
    public void scheduleNextAppointment() {
        // Check if the waiting list is empty
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting list is empty. Cannot schedule appointment.");
            return; // Exit method if queue is empty
        }

        // Dequeue the next patient (FIFO)
        Patient patientToSchedule = waitingQueue.poll(); // poll() returns null if queue is empty, but we already checked

        System.out.print("Enter doctor name: ");
        String doctorName = scanner.nextLine().trim();

        if (doctorName.isEmpty()) {
             System.err.println("Error: Doctor name cannot be empty. Patient returned to queue.");
             // Optionally, put the patient back if input is invalid, but for simplicity,
             // let's just error out and the patient is effectively lost from this attempt.
             // For this problem, let's assume the patient is *not* put back for simplicity.
             // waitingQueue.offer(patientToSchedule); // If we wanted to put them back
             return;
        }


        System.out.print("Enter appointment time (e.g., 10:00 AM): ");
        String time = scanner.nextLine().trim();

         if (time.isEmpty()) {
             System.err.println("Error: Appointment time cannot be empty. Patient returned to queue.");
              // Similar to doctor name, patient is not put back for simplicity
             return;
        }


        // Create a new appointment object
        Appointment newAppointment = new Appointment(patientToSchedule, doctorName, time);
        // Add the appointment to the list of scheduled appointments
        appointments.add(newAppointment);

        System.out.println("Scheduled appointment for patient " + patientToSchedule.getName() +
                           " (ID: " + patientToSchedule.getId() + ") with " + doctorName +
                           " at " + time + ".");
    }

    // Displays the current patients in the waiting list
    public void viewWaitingList() {
        System.out.println("--- Waiting List ---");
        // Check if the waiting list is empty
        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements (using enhanced for loop)
            for (Patient patient : waitingQueue) {
                System.out.println(patient); // Uses Patient's toString()
            }
        }
        System.out.println("--------------------");
    }

    // Displays appointments for a specific doctor
    public void viewDoctorSchedule() {
        System.out.print("Enter doctor name: ");
        String doctorName = scanner.nextLine().trim();

        if (doctorName.isEmpty()) {
             System.err.println("Error: Doctor name cannot be empty.");
             return;
        }

        System.out.println("--- " + doctorName + "'s Schedule ---");
        boolean foundAppointments = false; // Flag to check if any appointments are found

        // Check if the overall appointments list is empty
        if (appointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            // Iterate through the list of all appointments
            for (Appointment appointment : appointments) {
                // Check if the appointment is for the specified doctor (case-insensitive comparison)
                if (appointment.getDoctorName().equalsIgnoreCase(doctorName)) {
                    System.out.println(appointment); // Uses Appointment's toString()
                    foundAppointments = true; // Mark that we found at least one appointment
                }
            }

            // If no appointments were found for the doctor after checking the list
            if (!foundAppointments) {
                System.out.println("No appointments scheduled for " + doctorName + ".");
            }
        }
        System.out.println("----------------------------");
    }

    // Displays the main menu options
    private void displayMenu() {
        System.out.println("\nHospital Appointment System Menu:");
        System.out.println("1. Add Patient to Waiting List");
        System.out.println("2. Schedule Next Appointment");
        System.out.println("3. View Waiting List");
        System.out.println("4. View Doctor Schedule");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main application loop
    public void run() {
        int choice = -1; // Initialize choice outside the loop

        // Main application loop
        while (choice != 5) {
            displayMenu(); // Show the menu

            try {
                // Read user input as an integer
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addPatientToWaitingList(); // Call method to add patient
                        break;
                    case 2:
                        scheduleNextAppointment(); // Call method to schedule appointment
                        break;
                    case 3:
                        viewWaitingList(); // Call method to view waiting list
                        break;
                    case 4:
                        viewDoctorSchedule(); // Call method to view doctor's schedule
                        break;
                    case 5:
                        System.out.println("Exiting system."); // Exit message
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the loop iteration
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to standard error
                 // Decide how to handle critical errors - here, we just log and continue loop
            }
        }

        // Close the scanner when the loop exits
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem(); // Create an instance of the system
        system.run(); // Start the main application loop
    }
}
