/*
 * Exam Question #51
 * Generated on: 2025-05-11 22:05:37
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Print Queue Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application to simulate a print queue management system. The system should allow users to add documents to a queue, process (print) the next document in the queue, view the current documents waiting in the queue, and view a history of processed documents.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   **Add Document:** Allow the user to add a document name (String) to the print queue.
 *     *   **Process Next Document:** Remove and "process" (simulate printing) the document at the front of the queue. If the queue is empty, report an error.
 *     *   **View Queue:** Display all documents currently in the queue without removing them.
 *     *   **View History:** Display all documents that have been successfully processed.
 *     *   **Exit:** Terminate the application.
 * 
 * 2.  **Required Java Components:** Your solution *must* use and demonstrate understanding of the following:
 *     *   `java.util.Queue` (use an appropriate concrete implementation like `LinkedList`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (use `List` as the variable type when declaring the history list)
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for handling user menu choices.
 *     *   `System.err` for outputting error messages (e.g., trying to process an empty queue, invalid input).
 *     *   `System.out` for all normal output (prompts, confirmations, list displays).
 *     *   Class-wide exception handling: Implement a `try-catch` block that wraps the main application loop to catch potential unexpected errors.
 * 
 * 3.  **Best Practices:**
 *     *   Implement the core logic within a dedicated class (e.g., `PrintManager`) with private fields and public methods (encapsulation).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include basic input validation (e.g., checking if a document name is empty).
 *     *   Add appropriate comments (including Javadoc for the main class and methods) to explain the code.
 *     *   Ensure proper error handling using `System.err` and the required `try-catch`.
 *     *   Structure the code cleanly.
 * 
 * **User Interface:**
 * The application should present a menu to the user like this:
 * ```
 * Print Queue Management System
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Queue
 * 4. View History
 * 5. Exit
 * Enter your choice: 
 * ```
 * After processing a choice, the menu should reappear until the user selects '5'.
 * 
 * **Expected Output:**
 * *   Adding a document: `Document 'document_name' added to queue.`
 * *   Processing a document: `Processing document: 'document_name'.` If queue is empty: `System.err: No documents in the queue to process.`
 * *   Viewing Queue: Display list of documents in the queue, or `Queue is empty.`
 * *   Viewing History: Display list of processed documents, or `No documents processed yet.`
 * *   Invalid choice: `System.err: Invalid choice. Please enter a number between 1 and 5.`
 * *   Empty document name: `System.err: Document name cannot be empty.`
 * *   General unexpected error: `System.err: An unexpected error occurred: [error message]`
 * 
 * **Constraints:**
 * *   Document names are simple strings.
 * *   Assume a single printer/processing unit.
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a command-line Print Queue Management System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Scenario and Structure:** The code defines a `PrintManager` class that encapsulates the state (the queue and history) and the operations (add, process, view). The `main` method in the same class creates a `PrintManager` instance and calls its `run` method to start the interactive loop, promoting good object-oriented design.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: A `java.util.Queue<String>` named `printQueue` is declared and initialized with a `LinkedList`. `LinkedList` is a common implementation of `Queue` suitable for this scenario, allowing efficient adding to the end (`offer`) and removing from the beginning (`poll`).
 *     *   `ArrayList`: A `java.util.ArrayList<String>` named `processedDocuments` is used to store the history of documents that have been processed. `ArrayList` is suitable for storing a dynamic list where elements are added sequentially and viewed/iterated over.
 *     *   `List interface`: The `processedDocuments` variable is explicitly declared using the `java.util.List<String>` interface type (`List<String> processedDocuments = new ArrayList<>();`). This demonstrates programming to the interface, which is a best practice for flexibility and abstraction.
 *     *   `Scanner`: A `java.util.Scanner` is used to read user input from `System.in` in the `run` method. It's properly closed in the `finally` block.
 *     *   `switch statement`: A `switch` statement is used in the `run` method to handle the different integer choices provided by the user from the menu. This provides a clear and structured way to direct program flow based on discrete input values.
 *     *   `System.err`: `System.err.println()` is used specifically for outputting error messages, such as when the queue is empty during processing, when the user enters an invalid menu choice, when a document name is empty, or when an unexpected exception occurs. This separates error output from normal program output.
 *     *   `System.out`: `System.out.println()` is used for all normal output, including the menu, prompts, confirmations of actions (like adding a document), and displaying the contents of the queue and history.
 *     *   `try-catch`: A `try-catch(Exception e)` block is wrapped around the main `while` loop in the `run` method. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur during the execution of the command loop and reporting them using `System.err`. There's also an inner `try-catch` specifically for `InputMismatchException` when reading the user's menu choice, preventing the program from crashing on non-integer input.
 * 
 * 3.  **Best Practices Implementation:**
 *     *   **Encapsulation:** The `printQueue` and `processedDocuments` fields are declared as `private`, accessible only through the public methods (`addDocument`, `processNextDocument`, `viewQueue`, `viewHistory`).
 *     *   **Naming:** Variable and method names (`printQueue`, `processedDocuments`, `addDocument`, `processNextDocument`, `viewQueue`, `viewHistory`, `displayMenu`, `run`) are descriptive and follow Java conventions.
 *     *   **Input Validation:** The `addDocument` method checks if the input `documentName` is null or empty/whitespace using `trim().isEmpty()`. The menu input handling checks for `InputMismatchException` and handles invalid choice numbers in the `switch`'s `default` case.
 *     *   **Error Handling:** Specific error conditions (empty queue, invalid input) are checked and reported using `System.err`. The main `try-catch` provides a fallback for unexpected errors.
 *     *   **Comments:** Javadoc comments are provided for the class and public methods, explaining their purpose. Inline comments explain specific implementation details (like using `LinkedList` for `Queue`).
 *     *   **Clean Code Structure:** The code is organized logically with methods for distinct operations. The main application loop is contained within the `run` method, separating it from the core data structure operations. The `Scanner` is managed carefully, including consuming the newline character after reading an integer and ensuring it's closed.
 * 
 * This solution effectively demonstrates the required Java concepts and best practices within a practical, albeit simplified, application scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages a print queue and a history of processed documents.
 */
public class PrintManager {

    private Queue<String> printQueue;
    private List<String> processedDocuments;
    private Scanner scanner;

    /**
     * Constructs a new PrintManager.
     */
    public PrintManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.printQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List for history
        this.processedDocuments = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a document to the print queue.
     *
     * @param documentName The name of the document to add.
     */
    public void addDocument(String documentName) {
        if (documentName == null || documentName.trim().isEmpty()) {
            System.err.println("Document name cannot be empty.");
            return;
        }
        printQueue.offer(documentName.trim()); // offer() is preferred for capacity-constrained queues, but works fine here
        System.out.println("Document '" + documentName.trim() + "' added to queue.");
    }

    /**
     * Processes (simulates printing) the next document in the queue.
     * Moves the processed document to the history list.
     */
    public void processNextDocument() {
        String documentToProcess = printQueue.poll(); // poll() retrieves and removes the head of the queue
        if (documentToProcess == null) {
            System.err.println("No documents in the queue to process.");
        } else {
            System.out.println("Processing document: '" + documentToProcess + "'.");
            processedDocuments.add(documentToProcess);
        }
    }

    /**
     * Displays the documents currently waiting in the print queue.
     */
    public void viewQueue() {
        System.out.println("--- Current Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate without removing
            int i = 1;
            for (String doc : printQueue) {
                System.out.println(i++ + ". " + doc);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays the history of documents that have been processed.
     */
    public void viewHistory() {
        System.out.println("--- Processed Documents History ---");
        if (processedDocuments.isEmpty()) {
            System.out.println("No documents processed yet.");
        } else {
            int i = 1;
            for (String doc : processedDocuments) {
                System.out.println(i++ + ". " + doc);
            }
        }
        System.out.println("-----------------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nPrint Queue Management System");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Queue");
        System.out.println("4. View History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter document name: ");
                        String docName = scanner.nextLine();
                        addDocument(docName);
                        break;
                    case 2:
                        processNextDocument();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewHistory();
                        break;
                    case 5:
                        System.out.println("Exiting Print Queue Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run();
    }
}
