/*
 * Exam Question #181
 * Generated on: 2025-05-11 22:27:17
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Server Task Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified server task scheduler. This scheduler manages incoming tasks, processes them one by one, and keeps a record of completed tasks. The system interacts with a user via the console to receive commands.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this server task scheduler. Your solution must adhere to the following:
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a task. Each task should have:
 *     *   A unique integer `id`.
 *     *   A `String` `type` (valid types are "CPU", "IO", "NETWORK").
 *     *   Appropriate private fields and public getter methods.
 * 
 * 2.  **Scheduler Logic:** Create a class `ServerScheduler` that manages the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed (`pendingTasks`).
 *     *   A `List<Task>` (implemented using `ArrayList`) to hold tasks that have been processed (`completedTasks`).
 *     *   Methods to:
 *         *   `addTask(Task task)`: Adds a task to the `pendingTasks` queue.
 *         *   `processNextTask()`: Removes the next task from `pendingTasks`, simulates processing it (by printing a message), and adds it to the `completedTasks` list. This method should handle the case where the queue is empty.
 *         *   `listPendingTasks()`: Prints the details of all tasks currently in the `pendingTasks` queue.
 *         *   `listCompletedTasks()`: Prints the details of all tasks currently in the `completedTasks` list.
 * 
 * 3.  **User Interface:** Implement the main application logic in a class (e.g., `SchedulerApp`) with a `main` method. This class should:
 *     *   Use `Scanner` to read user commands from the console.
 *     *   Support the following commands:
 *         *   `add <id> <type>`: Creates a new task with the given ID and type and adds it to the scheduler's pending queue. Validate that the ID is a positive integer and the type is one of the valid types ("CPU", "IO", "NETWORK").
 *         *   `process`: Tells the scheduler to process the next task in the queue.
 *         *   `list-pending`: Prints the list of tasks waiting in the queue.
 *         *   `list-completed`: Prints the list of tasks that have been processed.
 *         *   `exit`: Terminates the program.
 *     *   Use a `switch` statement to handle the different commands.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch potential errors (e.g., invalid input format).
 *     *   Use `System.err.println()` to display error messages to the user (e.g., invalid command, invalid task parameters, trying to process an empty queue).
 *     *   Use `System.out.println()` for all normal output (prompts, successful operations, task lists).
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (at least for classes and methods).
 *     *   Implement input validation for the `add` command parameters.
 * 
 * **Expected Output Format:**
 * 
 * *   Prompts for user input should be clear (e.g., "Enter command: ").
 * *   Successful task addition: "Task added: Task{id=..., type=...}"
 * *   Successful task processing: "Processing task: Task{id=..., type=...}" followed by "Task completed: Task{id=..., type=...}"
 * *   Processing empty queue: "No tasks in the pending queue."
 * *   Listing tasks: Print each task on a new line, using the `Task` object's `toString()` representation. Indicate whether it's the pending or completed list.
 * *   Error messages: Printed to `System.err`, clearly indicating the nature of the error (e.g., "Error: Invalid command.", "Error: Invalid task ID. Must be a positive integer.", "Error: Invalid task type. Must be CPU, IO, or NETWORK.").
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command: add 101 CPU
 * Task added: Task{id=101, type=CPU}
 * Enter command: add 102 IO
 * Task added: Task{id=102, type=IO}
 * Enter command: list-pending
 * Pending Tasks:
 * Task{id=101, type=CPU}
 * Task{id=102, type=IO}
 * Enter command: process
 * Processing task: Task{id=101, type=CPU}
 * Task completed: Task{id=101, type=CPU}
 * Enter command: list-completed
 * Completed Tasks:
 * Task{id=101, type=CPU}
 * Enter command: process
 * Processing task: Task{id=102, type=IO}
 * Task completed: Task{id=102, type=IO}
 * Enter command: process
 * No tasks in the pending queue.
 * Enter command: list-completed
 * Completed Tasks:
 * Task{id=101, type=CPU}
 * Task{id=102, type=IO}
 * Enter command: add invalid_id NET
 * Error: Invalid task ID format. Please enter a valid integer.
 * Enter command: add 103 INVALID_TYPE
 * Error: Invalid task type. Must be CPU, IO, or NETWORK.
 * Enter command: exit
 * Exiting scheduler.
 * ```
 * 
 * Your solution should compile and run, demonstrating the correct usage of all required Java components and error handling.
 *
 * EXPLANATION:
 * This solution implements the `Server Task Scheduler` as required, demonstrating the use of all specified Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class encapsulates the data for a task (`id` and `type`).
 *     *   Fields are `private` for encapsulation.
 *     *   Public `getId()` and `getType()` methods provide controlled access.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`ServerScheduler` Class:**
 *     *   Manages the core logic of the scheduler.
 *     *   `pendingTasks` is declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. `LinkedList` is a common implementation of the `Queue` interface suitable for this purpose (FIFO - First-In, First-Out). Tasks are added to the tail (`add`) and removed from the head (`poll`).
 *     *   `completedTasks` is declared as `List<Task>` and instantiated as `ArrayList<Task>`. `ArrayList` is a suitable dynamic array implementation for storing the history of completed tasks. Tasks are added to the end (`add`).
 *     *   `addTask()`: Simple method to add a task to the `pendingTasks` queue.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. It checks if `poll()` returned `null` (indicating an empty queue) and handles that case. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `listPendingTasks()` and `listCompletedTasks()`: Iterate through the respective collections and print each task's `toString()` representation. They also handle the case where the lists are empty.
 * 
 * 3.  **`SchedulerApp` Class (`main` method):**
 *     *   This is the entry point of the application.
 *     *   A `Scanner` is used to read input lines from the console (`System.in`).
 *     *   A `ServerScheduler` instance is created.
 *     *   A `while` loop keeps the application running until the user enters the "exit" command.
 *     *   User input is read, trimmed, and split into command parts.
 *     *   A `switch` statement is used to determine the action based on the first part of the input string (the command). This fulfills the requirement for using a switch statement for flow control based on user input.
 *     *   **Input Validation:** Inside the "add" case, the code attempts to parse the ID as an integer and checks if it's positive. It also checks if the task type is one of the predefined valid types (`VALID_TASK_TYPES` list). If validation fails, an error message is printed to `System.err`, and the `continue` statement skips adding the invalid task.
 *     *   **Error Handling (`try-catch`):** The entire `switch` block (or at least the parts that could throw exceptions like `NumberFormatException`) is wrapped in a `try-catch` block. This demonstrates class-wide exception handling. The `catch` block catches any general `Exception` (or more specific ones if needed, like `NumberFormatException` which is handled specifically for 'add') and prints an error message to `System.err`. This ensures that unexpected errors during command processing don't crash the application loop. A specific `try-catch` is nested for the `NumberFormatException` within the "add" case for more granular error reporting for invalid IDs.
 *     *   **Output:** `System.out.println()` is used for all successful operations, prompts, and list outputs. `System.err.println()` is exclusively used for printing error messages, fulfilling the requirement to distinguish between normal and error output streams.
 *     *   The `Scanner` is closed when the loop finishes to release system resources.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** `Task` and `ServerScheduler` fields are private with public accessors/mutators where necessary.
 *     *   **Naming:** Variable names (`pendingTasks`, `completedTasks`, `taskToProcess`, `inputLine`) and method names (`addTask`, `processNextTask`, `listPendingTasks`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc-style comments are provided for classes and methods explaining their purpose.
 *     *   **Input Validation:** Explicit checks are performed for task ID (positive integer) and type (valid enum/list).
 *     *   **Error Handling:** `try-catch` blocks and specific error messages using `System.err` are implemented.
 *     *   **Clean Structure:** The code is separated into logical classes, each with a clear responsibility. The `main` method focuses on user interaction and delegating tasks to the `ServerScheduler`.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating competence in data structures, object-oriented programming, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task with an ID and type.
 */
class Task {
    private int id;
    private String type;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param type The type of the task (e.g., "CPU", "IO").
     */
    public Task(int id, String type) {
        this.id = id;
        this.type = type;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task type.
     * @return The task type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the task.
     * @return A string in the format "Task{id=..., type=...}".
     */
    @Override
    public String toString() {
        return "Task{id=" + id + ", type=" + type + "}";
    }
}

/**
 * Manages the queue of pending tasks and a list of completed tasks.
 */
class ServerScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new ServerScheduler, initializing task queues and lists.
     */
    public ServerScheduler() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending tasks queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        pendingTasks.add(task);
        System.out.println("Task added: " + task);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task, simulates processing, and moves it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            // Simulate processing delay or work here if needed
            completedTasks.add(taskToProcess);
            System.out.println("Task completed: " + taskToProcess);
        } else {
            System.out.println("No tasks in the pending queue.");
        }
    }

    /**
     * Prints all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Prints all tasks currently in the completed list.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main application class for the Server Task Scheduler.
 * Handles user input and interacts with the ServerScheduler.
 */
public class SchedulerApp {

    private static final List<String> VALID_TASK_TYPES = List.of("CPU", "IO", "NETWORK");

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ServerScheduler scheduler = new ServerScheduler();
        boolean running = true;

        System.out.println("Server Task Scheduler");
        System.out.println("Available commands: add <id> <type>, process, list-pending, list-completed, exit");

        while (running) {
            System.out.print("Enter command: ");
            String inputLine = scanner.nextLine().trim();
            String[] parts = inputLine.split("\\s+"); // Split by one or more spaces
            String command = parts[0].toLowerCase();

            try {
                // Using a switch statement for command handling
                switch (command) {
                    case "add":
                        if (parts.length == 3) {
                            try {
                                int id = Integer.parseInt(parts[1]);
                                String type = parts[2].toUpperCase(); // Normalize type

                                // Input validation for ID
                                if (id <= 0) {
                                    System.err.println("Error: Invalid task ID. Must be a positive integer.");
                                    continue; // Skip adding the task
                                }

                                // Input validation for Type
                                if (!VALID_TASK_TYPES.contains(type)) {
                                    System.err.println("Error: Invalid task type. Must be CPU, IO, or NETWORK.");
                                    continue; // Skip adding the task
                                }

                                Task newTask = new Task(id, type);
                                scheduler.addTask(newTask);

                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid task ID format. Please enter a valid integer.");
                            }
                        } else {
                            System.err.println("Error: 'add' command requires an ID and a Type. Usage: add <id> <type>");
                        }
                        break;

                    case "process":
                        if (parts.length == 1) {
                            scheduler.processNextTask();
                        } else {
                             System.err.println("Error: 'process' command does not take arguments. Usage: process");
                        }
                        break;

                    case "list-pending":
                        if (parts.length == 1) {
                            scheduler.listPendingTasks();
                        } else {
                            System.err.println("Error: 'list-pending' command does not take arguments. Usage: list-pending");
                        }
                        break;

                    case "list-completed":
                         if (parts.length == 1) {
                            scheduler.listCompletedTasks();
                        } else {
                            System.err.println("Error: 'list-completed' command does not take arguments. Usage: list-completed");
                        }
                        break;

                    case "exit":
                        if (parts.length == 1) {
                            running = false;
                            System.out.println("Exiting scheduler.");
                        } else {
                             System.err.println("Error: 'exit' command does not take arguments. Usage: exit");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command. Available commands: add, process, list-pending, list-completed, exit");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development/testing:
                // e.printStackTrace();
            }
        }

        scanner.close(); // Close the scanner when done
    }
}
