/*
 * Exam Question #1037
 * Generated on: 2025-05-12 17:16:05
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple, command-line based system to manage and process tasks. The system should allow users to add new tasks to a queue, process tasks one by one from the queue, and view the status of all tasks (pending, completed, or failed).
 * 
 * Your implementation must adhere to the following requirements:
 * 
 * 1.  **Core Data Structures:**
 *     *   Use a `java.util.Queue` to hold tasks that are waiting to be processed.
 *     *   Use `java.util.ArrayList` instances, referenced by the `java.util.List` interface, to store tasks that have been completed successfully and tasks that have failed.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the standard input.
 *     *   The system should present a menu of options to the user.
 *     *   Valid commands are:
 *         *   `add <task description>`: Adds a new task with the given description to the queue.
 *         *   `process`: Processes the next task from the queue.
 *         *   `status`: Displays the status of all tasks (pending in queue, completed, failed).
 *         *   `exit`: Terminates the program.
 * 
 * 3.  **Task Processing Logic:**
 *     *   When `process` is called, take the task at the head of the queue.
 *     *   Simulate task processing. For this simulation, if the task description contains the word "fail" (case-insensitive), the task should be marked as FAILED. Otherwise, it should be marked as COMPLETED.
 *     *   Move the processed task from the queue to the appropriate list (`completedTasks` or `failedTasks`).
 *     *   Handle the case where the queue is empty when `process` is called.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, task status, and successful operation messages (e.g., "Task added", "Task processed successfully").
 *     *   Use `System.err` for displaying error messages (e.g., "Invalid command", "Task queue is empty", errors during processing).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially related to input processing or unexpected issues during task simulation.
 * 
 * 5.  **Code Structure and Best Practices:**
 *     *   Create a `Task` class to represent individual tasks. It should have fields for a unique ID, description, and status (e.g., using an enum). Use proper encapsulation (private fields, public getters).
 *     *   Create a main class (e.g., `TaskProcessorSystem`) that contains the `main` method and manages the task queue and lists.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Perform basic input validation (e.g., check if task description is empty).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it should display the menu. Based on user input, it should perform the requested action and print relevant messages to `System.out` or `System.err`. The `status` command should clearly list tasks in the queue, completed tasks, and failed tasks with their IDs and descriptions.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Task Management Menu:
 * add <description> - Add a new task
 * process           - Process the next task
 * status            - View task status
 * exit              - Exit the system
 * Enter command: add Clean room
 * Task 1 added to the queue.
 * Enter command: add Write report (fail)
 * Task 2 added to the queue.
 * Enter command: status
 * --- Task Status ---
 * Pending (Queue):
 * ID: 1, Description: Clean room
 * ID: 2, Description: Write report (fail)
 * Completed:
 * (None)
 * Failed:
 * (None)
 * --- End Status ---
 * Enter command: process
 * Processing task 1: Clean room...
 * Task 1 completed successfully.
 * Enter command: process
 * Processing task 2: Write report (fail)...
 * Task 2 failed.
 * Enter command: status
 * --- Task Status ---
 * Pending (Queue):
 * (None)
 * Completed:
 * ID: 1, Description: Clean room
 * Failed:
 * ID: 2, Description: Write report (fail)
 * --- End Status ---
 * Enter command: process
 * Error: Task queue is empty.
 * Enter command: exit
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class encapsulates the data for a single task: `id`, `description`, and `status`.
 *     *   An `enum TaskStatus` is used for clarity and type safety regarding the task's state.
 *     *   Fields are `private`, and public getters are provided, adhering to encapsulation principles.
 *     *   A `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **TaskProcessorSystem Class:**
 *     *   This is the main class containing the application logic.
 *     *   **Data Structures:**
 *         *   `taskQueue`: Declared as `Queue<Task>`, initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and an implementation. `offer()` is used for adding tasks and `poll()` for retrieving and removing tasks from the head, standard `Queue` operations.
 *         *   `completedTasks` and `failedTasks`: Declared as `List<Task>`, initialized with `new ArrayList<>()`. This demonstrates using the `List` interface and the `ArrayList` implementation. Tasks are added using the `add()` method.
 *     *   **User Input:**
 *         *   A `Scanner` object is used to read user input from `System.in`.
 *     *   **Control Flow:**
 *         *   The `runSystem()` method contains the main loop that reads commands.
 *         *   A `switch` statement is used to handle the different user commands (`add`, `process`, `status`, `exit`), providing clear and efficient flow control.
 *     *   **Methods:**
 *         *   `displayMenu()`: Prints the available commands to `System.out`.
 *         *   `addTask(String description)`: Creates a new `Task` object, assigns a unique ID using `nextTaskId`, performs basic input validation on the description, and adds the task to the `taskQueue`.
 *         *   `processNextTask()`: Retrieves the head task from the `taskQueue` using `poll()`. If the queue is empty, it prints an error to `System.err`. Otherwise, it simulates processing, checks the description for "fail" (case-insensitive using `toLowerCase(Locale.ROOT)`), updates the task's status, and moves it to the appropriate `completedTasks` or `failedTasks` list.
 *         *   `viewTaskStatus()`: Iterates through the `taskQueue`, `completedTasks`, and `failedTasks` lists and prints the details of each task to `System.out`. It clearly labels each section and indicates if a list is empty.
 *     *   **Error Handling:**
 *         *   `System.err.println()` is used specifically for printing error messages, separating them from normal output.
 *         *   A `try-catch (Exception e)` block is wrapped around the main `while` loop in `runSystem()`. This provides class-wide exception handling, catching any unexpected errors that might occur during command processing or input handling within the loop.
 *         *   Specific error checks are also done within methods (e.g., empty queue in `processNextTask`, empty description in `addTask`).
 *         *   A `finally` block ensures the `Scanner` is closed when the program exits or an unhandled exception occurs.
 *         *   A `try-catch` block is also used within `processNextTask` specifically around the task simulation logic to catch potential errors during that phase.
 *     *   **Best Practices:**
 *         *   Meaningful names are used for variables, methods, and classes (`taskQueue`, `processNextTask`, `TaskProcessorSystem`).
 *         *   Input validation is performed for the task description.
 *         *   The code is structured into logical methods.
 *         *   Basic comments and Javadoc are included.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles (encapsulation), and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive check

// Enum to represent Task status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Class to represent a Task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setters (used internally by the processor)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description;
    }
}

// Main class for the Task Management System
public class TaskProcessorSystem {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private List<Task> failedTasks;
    private int nextTaskId;
    private Scanner scanner;

    public TaskProcessorSystem() {
        taskQueue = new LinkedList<>(); // LinkedList implements Queue
        completedTasks = new ArrayList<>(); // ArrayList implements List
        failedTasks = new ArrayList<>();   // ArrayList implements List
        nextTaskId = 1;
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("add <description> - Add a new task");
        System.out.println("process           - Process the next task");
        System.out.println("status            - View task status");
        System.out.println("exit              - Exit the system");
        System.out.print("Enter command: ");
    }

    /**
     * Adds a new task to the queue.
     * @param description The description of the task.
     */
    private void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.offer(newTask); // Use offer for adding to queue
        System.out.println("Task " + newTask.getId() + " added to the queue.");
    }

    /**
     * Processes the next task from the queue.
     */
    private void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // Use poll to retrieve and remove head

        if (taskToProcess == null) {
            System.err.println("Error: Task queue is empty.");
            return;
        }

        System.out.println("Processing task " + taskToProcess.getId() + ": " + taskToProcess.getDescription() + "...");
        taskToProcess.setStatus(TaskStatus.PROCESSING);

        // Simulate processing and potential failure
        try {
            // Simple simulation logic: fail if description contains "fail"
            if (taskToProcess.getDescription().toLowerCase(Locale.ROOT).contains("fail")) {
                taskToProcess.setStatus(TaskStatus.FAILED);
                failedTasks.add(taskToProcess);
                System.out.println("Task " + taskToProcess.getId() + " failed.");
            } else {
                taskToProcess.setStatus(TaskStatus.COMPLETED);
                completedTasks.add(taskToProcess);
                System.out.println("Task " + taskToProcess.getId() + " completed successfully.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during processing simulation
            taskToProcess.setStatus(TaskStatus.FAILED);
            failedTasks.add(taskToProcess);
            System.err.println("Error processing task " + taskToProcess.getId() + ": " + e.getMessage());
            // e.printStackTrace(System.err); // Optionally print stack trace for debugging
        }
    }

    /**
     * Displays the status of all tasks.
     */
    private void viewTaskStatus() {
        System.out.println("\n--- Task Status ---");

        System.out.println("Pending (Queue):");
        if (taskQueue.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }

        System.out.println("Completed:");
        if (completedTasks.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }

        System.out.println("Failed:");
        if (failedTasks.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Task task : failedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Status ---");
    }

    /**
     * Runs the main system loop.
     */
    public void runSystem() {
        boolean running = true;

        // Class-wide exception handling around the main processing loop
        try {
            while (running) {
                displayMenu();
                String inputLine = scanner.nextLine();
                String[] parts = inputLine.trim().split(" ", 2);
                String command = parts[0].toLowerCase(Locale.ROOT);
                String argument = parts.length > 1 ? parts[1] : "";

                // Using switch for flow control based on command
                switch (command) {
                    case "add":
                        addTask(argument);
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "status":
                        viewTaskStatus();
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(System.err); // Optional: print stack trace
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void main(String[] args) {
        TaskProcessorSystem system = new TaskProcessorSystem();
        system.runSystem();
    }
}
