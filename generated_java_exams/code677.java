/*
 * Exam Question #677
 * Generated on: 2025-05-12 16:24:11
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Network Packet Processing Simulator**
 * 
 * **Scenario:**
 * You are tasked with building a simplified simulator for a network device that processes incoming data packets. The device has a limited buffer (queue) for incoming packets and logs all successfully processed packets. Different packet types require different processing logic, and errors can occur during processing or if the buffer overflows.
 * 
 * Your program should simulate receiving packets, processing them one by one from the buffer, displaying the status of the buffer and processed log, and handling various error conditions gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Packet Representation:** Create a `Packet` class with fields for `id` (int), `type` (enum `PacketType`), and `payload` (String). Include a constructor and appropriate getter methods.
 * 2.  **Packet Types:** Define an enum `PacketType` with values `DATA`, `CONTROL`, `ERROR`.
 * 3.  **Packet Processor:** Create a class `PacketProcessor` that manages the packet queue and the processed packet log.
 *     *   It must have a `private Queue<Packet>` to hold incoming packets.
 *     *   It must have a `private List<Packet>` to store successfully processed packets. Use the `List` interface type for the variable.
 *     *   It must have a `private int maxQueueSize` to limit the buffer size.
 *     *   Implement a method `receivePacket(Packet packet)` that adds a packet to the queue. If the queue is full, throw a custom exception `QueueFullException`.
 *     *   Implement a method `processNextPacket()` that removes a packet from the front of the queue, processes it based on its `PacketType` using a `switch` statement, and adds it to the processed list if successful.
 *         *   If the queue is empty, throw a custom exception `EmptyQueueException`.
 *         *   Processing `DATA` packets: Print "Processing DATA packet [id]".
 *         *   Processing `CONTROL` packets: Print "Processing CONTROL packet [id]".
 *         *   Processing `ERROR` packets: Simulate a processing failure by throwing a custom exception `ProcessingException`.
 *     *   Implement methods `getQueueStatus()` and `getProcessedLog()` to display the current state.
 * 4.  **Custom Exceptions:** Define three custom exception classes: `QueueFullException`, `EmptyQueueException`, and `ProcessingException`.
 * 5.  **Main Application:**
 *     *   In your `main` method, create a `PacketProcessor` instance with a reasonable `maxQueueSize` (e.g., 5).
 *     *   Use a `Scanner` to read commands from the user. The commands should be single characters (case-insensitive):
 *         *   `R`: Receive a new packet. Prompt the user for packet ID (integer), type (DATA, CONTROL, ERROR), and payload (string). Validate input where necessary.
 *         *   `P`: Process the next packet from the queue.
 *         *   `S`: Display queue status.
 *         *   `L`: Display processed packet log.
 *         *   `Q`: Quit the application.
 *     *   Use a `switch` statement to handle the user commands.
 *     *   Implement class-wide exception handling: Wrap the main command processing loop in a `try-catch` block to catch your custom exceptions and print informative error messages using `System.err`. Also, include a general `catch (Exception e)` for unexpected errors.
 * 6.  **Output:**
 *     *   Use `System.out` for the menu, prompts, successful processing messages, status, and log display.
 *     *   Use `System.err` for all error messages (invalid input, caught exceptions).
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Validate user input for packet creation (ID must be positive, type must be valid).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Interaction Example (Illustrative):**
 * 
 * ```
 * Packet Processor Simulator
 * Enter command (R=Receive, P=Process, S=Status, L=Log, Q=Quit): R
 * Enter Packet ID: 101
 * Enter Packet Type (DATA, CONTROL, ERROR): DATA
 * Enter Packet Payload: Hello World
 * Packet 101 (DATA) received and queued.
 * Enter command (R, P, S, L, Q): R
 * Enter Packet ID: 102
 * Enter Packet Type (DATA, CONTROL, ERROR): ERROR
 * Enter Packet Payload: Corrupted Data
 * Packet 102 (ERROR) received and queued.
 * Enter command (R, P, S, L, Q): S
 * Queue Status: 2/5 packets
 * Enter command (R, P, S, L, Q): P
 * Processing DATA packet 101
 * Enter command (R, P, S, L, Q): P
 * Error during packet processing: Processing failed for ERROR packet.
 * Enter command (R, P, S, L, Q): L
 * Processed Packets Log:
 * [ID: 101, Type: DATA, Payload: Hello World]
 * Enter command (R, P, S, L, Q): Q
 * Exiting simulator.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * This solution implements a network packet processing simulator, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Scenario and Structure:** The simulation involves receiving packets into a limited queue (`packetQueue`), processing them based on type, and logging successful processing (`processedPackets`). The `PacketProcessor` class encapsulates this core logic, separating it from the main application flow in `NetworkSimulator`.
 * 2.  **Required Components:**
 *     *   `Queue`: A `java.util.LinkedList` is used to implement the `Queue` interface for `packetQueue`. `LinkedList` is a common choice for queues due to efficient add/remove operations at both ends.
 *     *   `ArrayList`: A `java.util.ArrayList` is used to store the `processedPackets`.
 *     *   `List interface`: The `processedPackets` variable is declared as `List<Packet>`, adhering to the best practice of programming to interfaces rather than concrete implementations where possible.
 *     *   `Scanner`: `java.util.Scanner` is used in the `main` method to read user commands and packet details from standard input (`System.in`). It's closed in a `finally` block to ensure resource cleanup.
 *     *   `Switch statement`: Used in two key places:
 *         *   In `PacketProcessor.processNextPacket()` to execute different logic based on the `PacketType` enum.
 *         *   In `NetworkSimulator.main()` to handle different user commands (R, P, S, L, Q).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid user input, queue full errors, empty queue errors, processing failures, and unexpected exceptions.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, queue status, and processed log.
 *     *   `Class-wide exception handling with try-catch`: The main `while` loop in the `NetworkSimulator.main` method is wrapped in a `try-catch` block. This block catches the custom exceptions (`QueueFullException`, `EmptyQueueException`, `ProcessingException`) thrown by the `PacketProcessor` methods, as well as a general `Exception` catch for any other potential runtime errors that might occur within the loop. This demonstrates handling exceptions originating from the core logic within the main execution context. Specific `try-catch` blocks are also used within the 'R' command handling to manage input validation exceptions (`NumberFormatException`, `IllegalArgumentException`) and the `QueueFullException` from `receivePacket` locally.
 * 3.  **Custom Exceptions:** `QueueFullException`, `EmptyQueueException`, and `ProcessingException` are defined as custom checked exceptions, forcing the caller (`NetworkSimulator.main`) to handle them explicitly. This improves code clarity and robustness by signaling specific error conditions.
 * 4.  **Packet and PacketType:** The `Packet` class is a simple Plain Old Java Object (POJO) with private fields and public getters, demonstrating encapsulation. The `PacketType` enum provides a type-safe way to represent the different categories of packets, which is then used by the `switch` statement.
 * 5.  **Input Validation and Error Handling:**
 *     *   Input for Packet ID is validated to be a positive integer.
 *     *   Input for Packet Type is validated against the `PacketType` enum using `valueOf` within a `try-catch`.
 *     *   `QueueFullException` is thrown if `receivePacket` is called when the queue is full.
 *     *   `EmptyQueueException` is thrown if `processNextPacket` is called when the queue is empty.
 *     *   `ProcessingException` is thrown specifically when an `ERROR` type packet is processed, simulating a failure.
 *     *   `NumberFormatException` and `IllegalArgumentException` are caught during input parsing to handle invalid user input formats.
 *     *   A general `catch (Exception e)` is included in the main loop's outer `try-catch` for robustness against unforeseen issues.
 * 6.  **Best Practices:**
 *     *   Private fields and public methods in `Packet` and `PacketProcessor` ensure encapsulation.
 *     *   Variable names (`packetQueue`, `processedPackets`, `maxQueueSize`, `newPacket`, `command`) are descriptive.
 *     *   Method names (`receivePacket`, `processNextPacket`, `getQueueStatus`, `getProcessedLog`) clearly indicate their purpose.
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Resource management is demonstrated by closing the `Scanner` in a `finally` block.
 *     *   Code is structured logically into separate classes for clear responsibility.
 * 
 * This solution effectively integrates all required components to solve a simulated real-world problem, demonstrating understanding of data structures, control flow, object-oriented principles, and robust exception handling in Java.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// Custom Exception for a full queue
class QueueFullException extends Exception {
    public QueueFullException(String message) {
        super(message);
    }
}

// Custom Exception for processing an empty queue
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Custom Exception for errors during packet processing
class ProcessingException extends Exception {
    public ProcessingException(String message) {
        super(message);
    }
}

// Enum for different packet types
enum PacketType {
    DATA,
    CONTROL,
    ERROR
}

// Represents a network packet
class Packet {
    private int id;
    private PacketType type;
    private String payload;

    /**
     * Constructs a new Packet.
     * @param id The packet ID.
     * @param type The type of the packet.
     * @param payload The payload data.
     */
    public Packet(int id, PacketType type, String payload) {
        this.id = id;
        this.type = type;
        this.payload = payload;
    }

    // Getters
    public int getId() {
        return id;
    }

    public PacketType getType() {
        return type;
    }

    public String getPayload() {
        return payload;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Type: " + type + ", Payload: " + payload + "]";
    }
}

// Manages the packet queue and processed log
class PacketProcessor {
    private Queue<Packet> packetQueue;
    private List<Packet> processedPackets; // Use List interface type
    private int maxQueueSize;

    /**
     * Constructs a PacketProcessor.
     * @param maxQueueSize The maximum number of packets the queue can hold.
     */
    public PacketProcessor(int maxQueueSize) {
        this.maxQueueSize = maxQueueSize;
        this.packetQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedPackets = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Receives a packet and adds it to the queue.
     * @param packet The packet to receive.
     * @throws QueueFullException if the queue is already at max capacity.
     */
    public void receivePacket(Packet packet) throws QueueFullException {
        if (packetQueue.size() >= maxQueueSize) {
            throw new QueueFullException("Packet queue is full. Cannot receive packet ID: " + packet.getId());
        }
        packetQueue.add(packet);
        System.out.println("Packet " + packet.getId() + " (" + packet.getType() + ") received and queued.");
    }

    /**
     * Processes the next packet from the queue.
     * @throws EmptyQueueException if the queue is empty.
     * @throws ProcessingException if an error occurs during packet processing (specifically for ERROR packets).
     */
    public void processNextPacket() throws EmptyQueueException, ProcessingException {
        if (packetQueue.isEmpty()) {
            throw new EmptyQueueException("Packet queue is empty. No packets to process.");
        }

        Packet packet = packetQueue.poll(); // Get and remove the head of the queue
        if (packet == null) {
             // Should not happen if isEmpry() check passes, but good practice
             throw new EmptyQueueException("Failed to retrieve packet from queue.");
        }

        // Use switch statement for processing based on packet type
        switch (packet.getType()) {
            case DATA:
                System.out.println("Processing DATA packet " + packet.getId() + "...");
                // Simulate processing time or logic here if needed
                processedPackets.add(packet);
                System.out.println("DATA packet " + packet.getId() + " processed successfully.");
                break;
            case CONTROL:
                System.out.println("Processing CONTROL packet " + packet.getId() + "...");
                 // Simulate processing time or logic here
                processedPackets.add(packet);
                System.out.println("CONTROL packet " + packet.getId() + " processed successfully.");
                break;
            case ERROR:
                System.err.println("Attempting to process ERROR packet " + packet.getId() + "...");
                // Simulate an error specifically for ERROR packet type
                throw new ProcessingException("Processing failed for ERROR packet ID: " + packet.getId());
            default:
                // Should not be reached with current enum, but good practice
                System.err.println("Unknown packet type encountered for packet ID: " + packet.getId());
                // Decide whether to add to processed list or discard on unknown type
                // For this simulation, let's discard unknown types
                break;
        }
    }

    /**
     * Displays the current status of the packet queue.
     */
    public void getQueueStatus() {
        System.out.println("Queue Status: " + packetQueue.size() + "/" + maxQueueSize + " packets");
    }

    /**
     * Displays the list of processed packets.
     */
    public void getProcessedLog() {
        System.out.println("Processed Packets Log:");
        if (processedPackets.isEmpty()) {
            System.out.println("  (No packets processed yet)");
        } else {
            for (Packet p : processedPackets) {
                System.out.println("  " + p);
            }
        }
    }
}

// Main class to run the simulator
public class NetworkSimulator {

    public static void main(String[] args) {
        final int MAX_QUEUE_SIZE = 5; // Define max queue size
        PacketProcessor processor = new PacketProcessor(MAX_QUEUE_SIZE);
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Network Packet Processor Simulator ---");

        // Class-wide exception handling for the main loop
        try {
            boolean running = true;
            while (running) {
                System.out.println("\nEnter command (R=Receive, P=Process, S=Status, L=Log, Q=Quit):");
                String command = scanner.nextLine().trim().toUpperCase();

                // Use switch statement for command handling
                switch (command) {
                    case "R":
                        // --- Receive Packet ---
                        try {
                            System.out.print("Enter Packet ID: ");
                            int id = Integer.parseInt(scanner.nextLine());
                            if (id <= 0) {
                                System.err.println("Error: Packet ID must be positive.");
                                continue; // Skip to next command
                            }

                            System.out.print("Enter Packet Type (DATA, CONTROL, ERROR): ");
                            String typeStr = scanner.nextLine().trim().toUpperCase();
                            PacketType type;
                            try {
                                type = PacketType.valueOf(typeStr);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: Invalid Packet Type. Please use DATA, CONTROL, or ERROR.");
                                continue; // Skip to next command
                            }

                            System.out.print("Enter Packet Payload: ");
                            String payload = scanner.nextLine();

                            Packet newPacket = new Packet(id, type, payload);
                            processor.receivePacket(newPacket);

                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid input for Packet ID. Please enter a number.");
                        } catch (QueueFullException e) {
                            System.err.println("Error: " + e.getMessage());
                        } catch (Exception e) {
                             // Catch any other unexpected errors during receive input
                             System.err.println("An unexpected error occurred during packet reception input: " + e.getMessage());
                        }
                        break;

                    case "P":
                        // --- Process Packet ---
                        try {
                            processor.processNextPacket();
                        } catch (EmptyQueueException e) {
                            System.err.println("Error: " + e.getMessage());
                        } catch (ProcessingException e) {
                            System.err.println("Error during packet processing: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during processing
                             System.err.println("An unexpected error occurred during packet processing: " + e.getMessage());
                        }
                        break;

                    case "S":
                        // --- Show Status ---
                        processor.getQueueStatus();
                        break;

                    case "L":
                        // --- Show Log ---
                        processor.getProcessedLog();
                        break;

                    case "Q":
                        // --- Quit ---
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please use R, P, S, L, or Q.");
                        break;
                }
            }
        } catch (Exception e) {
            // General catch-all for any unhandled exceptions from the main loop operations
            System.err.println("\nAn unexpected fatal error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
