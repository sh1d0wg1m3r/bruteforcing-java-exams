/*
 * Exam Question #516
 * Generated on: 2025-05-11 23:23:01
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * **Objective:** Design and implement a simple console-based Task Management system. The system should allow users to add new tasks, process the next pending task, view pending tasks, and view completed tasks. This task requires you to demonstrate your understanding of core Java concepts, including collections, input/output, control flow, object-oriented programming, and exception handling.
 * 
 * **Scenario:** You are building a basic system for managing a queue of tasks that need to be processed sequentially. Once a task is processed, it moves to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. It should have:
 *     *   A unique integer ID (automatically generated).
 *     *   A `String` description.
 *     *   A status (e.g., `PENDING`, `COMPLETED`). Use an `enum` for the status.
 *     *   A constructor that takes the description and initializes the task with a unique ID and `PENDING` status.
 *     *   A method to mark the task as `COMPLETED`.
 *     *   Appropriate getter methods.
 *     *   Override `toString()` to provide a user-friendly representation of the task (including ID, description, and status).
 * 
 * 2.  **Task Management Logic:** Create a class `TaskManager` that manages the collections of tasks. It must use:
 *     *   A `java.util.Queue<Task>` to store tasks that are pending processing. New tasks are added here.
 *     *   A `java.util.List<Task>` (implemented using `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Methods:
 *         *   `void addTask(String description)`: Creates a new `Task` object and adds it to the pending queue. Should validate that the description is not empty or null.
 *         *   `void processNextTask()`: Takes the next task from the head of the pending queue, marks it as `COMPLETED`, and moves it to the completed tasks list. Should handle the case where the pending queue is empty.
 *         *   `List<Task> getPendingTasks()`: Returns a `List` of tasks currently in the pending queue.
 *         *   `List<Task> getCompletedTasks()`: Returns a `List` of tasks that have been completed.
 * 
 * 3.  **User Interface (Console):** Create a main class (e.g., `TaskApp`) with a `main` method to interact with the user via the console. This class must:
 *     *   Use `java.util.Scanner` to read user input (menu choices and task descriptions).
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Pending Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, empty task description, no pending tasks to process).
 * 
 * 4.  **Exception Handling:** Implement robust exception handling using `try-catch` blocks.
 *     *   Handle potential input errors from `Scanner` (e.g., non-integer input for menu choice).
 *     *   Handle validation errors (e.g., empty task description). The `addTask` method or `Task` constructor should throw an appropriate exception (like `IllegalArgumentException`), which should be caught and reported using `System.err` in the `TaskApp`.
 *     *   Handle the case where `processNextTask` is called when the pending queue is empty. Define and throw a custom exception (e.g., `EmptyQueueException`) from `TaskManager`, and catch it in `TaskApp`, reporting the error via `System.err`.
 *     *   Include a top-level `try-catch` block in the `main` method or around the main loop in `TaskApp` to catch any unexpected exceptions and print an error message using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Follow encapsulation principles (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc where applicable).
 *     *   Implement input validation where necessary.
 *     *   Ensure proper resource management (e.g., close the `Scanner`).
 *     *   Structure the code into logical classes.
 * 
 * **Required Java Components Checklist:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks (class-wide handling within the main application logic)
 * 
 * **Expected Output:** The output should clearly display the menu, prompts for input, task lists when requested, and informative messages (success or error) to the user. Error messages MUST go to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * ===========================
 *  Simple Task Manager App
 * ===========================
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: Buy groceries
 * Enter your choice: 1
 * Enter task description:
 * Error adding task: Task description cannot be empty.
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Description: "Buy groceries", Status: PENDING
 * ---------------------
 * 
 * Enter your choice: 2
 * Task processed: Buy groceries
 * Enter your choice: 2
 * Error processing task: No pending tasks to process.
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Description: "Buy groceries", Status: COMPLETED
 * -----------------------
 * 
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this Task Management system.
 *
 * EXPLANATION:
 * This solution implements the Task Management system according to the requirements, demonstrating the use of various Java concepts and best practices.
 * 
 * **Code Structure:**
 * The solution is organized into three main classes:
 * 1.  `Task`: Represents the data structure for a single task.
 * 2.  `TaskManager`: Encapsulates the business logic and holds the collections (`Queue` and `List`).
 * 3.  `TaskApp`: Contains the `main` method and handles user interaction via the console.
 * 
 * **Required Components Usage:**
 * 
 * *   **`java.util.Queue`:** The `TaskManager` class uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList`. This correctly models the requirement for tasks to be processed in a FIFO (First-In, First-Out) manner. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove the head task.
 * *   **`java.util.ArrayList`:** The `TaskManager` class uses an `ArrayList<Task>` to store `completedTasks`. This provides a dynamic, index-based list for storing completed items.
 * *   **`java.util.List` interface:** `completedTasks` is declared as `List<Task>`, demonstrating programming to the interface. The `getPendingTasks()` and `getCompletedTasks()` methods also return `List<Task>`, allowing the caller to work with the list abstraction rather than the specific implementation. `Collections.unmodifiableList` is used for `getCompletedTasks()` to prevent external modification of the internal list, a good practice for encapsulation.
 * *   **`java.util.Scanner`:** The `TaskApp` class uses `Scanner` to read integer choices and string descriptions from `System.in`.
 * *   **`switch` statement:** The `TaskApp.run()` method uses a `switch` statement to direct the program flow based on the user's numeric menu choice.
 * *   **`System.err`:** Used extensively in `TaskApp` within `catch` blocks and the `default` case of the switch to output error messages related to invalid input, validation failures, and operational errors (like processing an empty queue). The top-level catch in `main` also uses `System.err`.
 * *   **`System.out`:** Used in `TaskApp` for displaying the welcome message, menu, prompts, success messages after adding/processing tasks, and listing the pending and completed tasks.
 * *   **`try-catch` blocks:**
 *     *   A top-level `try-catch` in `TaskApp.main` catches any unhandled exceptions during the application's execution.
 *     *   A `try-catch` block surrounds the input reading and `switch` statement within the `TaskApp.run()` loop to catch `InputMismatchException` (for non-integer input) and other general exceptions occurring during the main loop's execution.
 *     *   Specific `try-catch` blocks are used within the `switch` cases in `TaskApp.run()` to handle exceptions thrown by `TaskManager` methods:
 *         *   `IllegalArgumentException` is caught when `addTask` is called with an invalid description (validation handled in the `Task` constructor).
 *         *   A custom `TaskManager.EmptyQueueException` is caught when `processNextTask` is called on an empty queue.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, accessed via `public` methods (getters, `markCompleted`, `addTask`, `processNextTask`, etc.).
 * *   **Meaningful Names:** Classes (`Task`, `TaskManager`, `TaskApp`), variables (`pendingTasks`, `completedTasks`, `description`, `choice`), methods (`addTask`, `processNextTask`, `getPendingTasks`, `displayMenu`), and the `TaskStatus` enum have clear, descriptive names.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes, methods, and key parameters/exceptions. Inline comments clarify specific logic points.
 * *   **Input Validation:** The `Task` constructor validates that the description is not null or empty. `TaskApp` handles non-integer input from the `Scanner`.
 * *   **Proper Error Handling:** Specific exceptions are used (`IllegalArgumentException`, custom `EmptyQueueException`, `InputMismatchException`) and caught where appropriate, providing informative error messages to the user via `System.err`.
 * *   **Clean Code Structure:** The logic is separated into distinct classes based on responsibility. The `TaskApp` class focuses on I/O and control flow, while `TaskManager` handles data storage and manipulation. The `Scanner` resource is closed when the application exits.
 * 
 * This solution effectively integrates the required Java components into a functional application, demonstrating robust error handling, adherence to object-oriented principles, and practical use of collections and control structures, making it a challenging yet solvable exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collections; // For unmodifiable list
import java.util.concurrent.atomic.AtomicInteger; // For unique ID

// --- Task Class ---
/**
 * Represents a single task with a unique ID, description, and status.
 */
class Task {
    private static final AtomicInteger idCounter = new AtomicInteger();
    private final int id;
    private String description;
    private TaskStatus status;

    /**
     * Enum for task status.
     */
    public enum TaskStatus {
        PENDING, COMPLETED
    }

    /**
     * Constructs a new Task with a description.
     * Automatically assigns a unique ID and sets status to PENDING.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = idCounter.incrementAndGet();
        this.description = description.trim();
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Marks the task status as COMPLETED.
     */
    public void markCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return Formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: \"%s\", Status: %s",
                             id, description, status);
    }
}

// --- TaskManager Class ---
/**
 * Manages collections of pending and completed tasks.
 */
class TaskManager {
    private final Queue<Task> pendingTasks;
    private final List<Task> completedTasks; // Implemented using ArrayList

    /**
     * Custom exception for indicating an empty queue condition.
     */
    public static class EmptyQueueException extends Exception {
        public EmptyQueueException(String message) {
            super(message);
        }
    }

    /**
     * Constructs a new TaskManager with empty task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if description is null or empty (delegated to Task constructor).
     */
    public void addTask(String description) {
        // Task constructor handles validation and throws IllegalArgumentException
        Task newTask = new Task(description);
        pendingTasks.offer(newTask); // offer is a safe way to add to a queue
        System.out.println("Task added: " + newTask.getDescription()); // Success message to System.out
    }

    /**
     * Processes the next task from the pending queue, marking it as completed.
     *
     * @throws EmptyQueueException if there are no pending tasks to process.
     */
    public void processNextTask() throws EmptyQueueException {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head, returns null if empty

        if (taskToProcess == null) {
            throw new EmptyQueueException("No pending tasks to process.");
        }

        taskToProcess.markCompleted();
        completedTasks.add(taskToProcess);
        System.out.println("Task processed: " + taskToProcess.getDescription()); // Success message to System.out
    }

    /**
     * Gets an unmodifiable list of tasks currently in the pending queue.
     *
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList copy to prevent external modification of the internal queue structure
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets an unmodifiable list of tasks that have been completed.
     *
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return an unmodifiable list to protect the internal completedTasks list
        return Collections.unmodifiableList(completedTasks);
    }
}

// --- Main Application Class ---
/**
 * Console application to manage tasks using TaskManager.
 */
public class TaskApp {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs a new TaskApp, initializing TaskManager and Scanner.
     */
    public TaskApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Main method to start the application.
     * Includes a top-level try-catch for unexpected errors.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        try {
            TaskApp app = new TaskApp();
            app.run();
        } catch (Exception e) {
            // Catch any unexpected exceptions not handled elsewhere
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        int choice = -1;
        displayWelcomeMessage();

        // Main application loop continues until the user chooses to exit (choice 5)
        while (choice != 5) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                // Read integer input for menu choice
                choice = scanner.nextInt();
                // Consume the leftover newline character after reading the integer
                scanner.nextLine();

                // Use switch statement to handle different menu options
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            // Call taskManager method, handle potential validation error
                            taskManager.addTask(description);
                        } catch (IllegalArgumentException e) {
                            // Report validation errors to System.err
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;
                    case 2: // Process Next Task
                        try {
                            // Call taskManager method, handle potential empty queue error
                            taskManager.processNextTask();
                        } catch (TaskManager.EmptyQueueException e) {
                            // Report specific processing errors to System.err
                            System.err.println("Error processing task: " + e.getMessage());
                        }
                        break;
                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = taskManager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate and print pending tasks using System.out
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------\n");
                        break;
                    case 4: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = taskManager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            // Iterate and print completed tasks using System.out
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("-----------------------\n");
                        break;
                    case 5: // Exit
                        System.out.println("Exiting Task Manager. Goodbye!"); // Exit message to System.out
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                // Consume the incorrect input to prevent an infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to ensure loop continues
            } catch (Exception e) {
                 // Catch any other unexpected errors that might occur within the loop's try block
                 System.err.println("An error occurred during operation: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }
        }

        // Close the scanner resource when the application loop finishes
        scanner.close();
    }

    /**
     * Displays the welcome message.
     */
    private void displayWelcomeMessage() {
        System.out.println("===========================");
        System.out.println(" Simple Task Manager App");
        System.out.println("===========================");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
