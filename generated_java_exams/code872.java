/*
 * Exam Question #872
 * Generated on: 2025-05-12 16:53:14
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Scheduling System
 * 
 * **Scenario:** You are tasked with building a simple, console-based task scheduling system. The system should allow users to add new tasks, process the next available task, view tasks waiting to be processed, and view tasks that have been completed.
 * 
 * **Task Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (higher number means higher priority, though for this simplified system, processing is FIFO regardless of priority, but the field must exist).
 *     *   Include a constructor to initialize these fields and public getter methods for each. Implement a `toString()` method to provide a readable representation of the task.
 * 
 * 2.  **System Core:** Create a class named `ExamTaskScheduler` that manages the tasks. This class should have:
 *     *   A private `Queue` to store tasks waiting to be processed.
 *     *   A private `List` (implemented using `ArrayList`) to store completed tasks.
 * 
 * 3.  **Functionality:** Implement the following functionalities within the `ExamTaskScheduler` class, accessible via a console menu:
 *     *   **Add Task:** Prompt the user for a task description and priority. Create a `Task` object and add it to the queue of pending tasks. Generate a simple unique `taskId` (e.g., an auto-incrementing counter). Perform input validation for priority (must be a positive integer).
 *     *   **Process Next Task:** Remove the task at the front of the pending task queue and move it to the list of completed tasks. If the queue is empty, inform the user.
 *     *   **View Pending Tasks:** Display all tasks currently in the pending task queue, in the order they would be processed.
 *     *   **View Completed Tasks:** Display all tasks that have been moved to the completed list.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:** Implement a simple command-line interface using `Scanner` to interact with the user. Display a menu of options (Add, Process, View Pending, View Completed, Exit) and use a `switch` statement to handle user commands.
 * 
 * 5.  **Required Java Components:** Your solution **MUST** utilize **ALL** of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as the declared type for the completed tasks collection)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for displaying error messages, e.g., invalid input, processing error)
 *     *   `System.out` (for displaying menu, prompts, task lists, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially related to user input (e.g., non-integer input when expecting an integer).
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc for classes and methods.
 *     *   Implement robust input validation and error handling using `try-catch` and `System.err`.
 *     *   Structure the code clearly.
 * 
 * **Expected Output:**
 * 
 * *   Menu displayed on `System.out`.
 * *   Prompts for input on `System.out`.
 * *   Task lists and success messages on `System.out`.
 * *   Error messages (like invalid command, invalid priority, input type mismatch) on `System.err`.
 * *   The program should handle incorrect input gracefully without crashing.
 * 
 * Your solution should be a single `.java` file containing the `Task` class and the `ExamTaskScheduler` class with a `main` method to start the system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Scheduling System that fulfills all the requirements of the exam question, demonstrating the practical use of the specified Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses `private` fields (`taskId`, `description`, `priority`) to enforce encapsulation.
 *     *   Provides `public` getter methods to access the fields.
 *     *   Includes a constructor for object creation.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`ExamTaskScheduler` Class:**
 *     *   **Collections:**
 *         *   `private Queue<Task> pendingTasks`: Declared as a `Queue` interface type and initialized with `LinkedList`. This collection stores tasks waiting to be processed in a First-In, First-Out (FIFO) manner, which is the natural behavior for a simple processing queue.
 *         *   `private List<Task> completedTasks`: Declared as a `List` interface type and initialized with `ArrayList`. This collection stores tasks after they have been processed. `ArrayList` is suitable here for storing a dynamic list of items where order of completion is maintained and easy iteration is needed.
 *     *   **`Scanner`:** A `private Scanner scanner` is used to read user input from `System.in`. It's initialized in the constructor and closed when the program exits.
 *     *   **`nextTaskId`:** A simple counter to generate unique IDs for new tasks.
 *     *   **`addTask()` Method:**
 *         *   Prompts the user for task details using `System.out`.
 *         *   Reads input using the `Scanner`.
 *         *   Includes a `while` loop and a `try-catch(InputMismatchException)` block specifically for reading and validating the `priority` input. If the input is not a valid integer or is not positive, an error message is printed to `System.err`, and the loop continues until valid input is received. The `scanner.next()` and `scanner.nextLine()` calls within the catch block are crucial to consume the invalid input and prevent an infinite loop caused by `nextInt()` not consuming the newline or invalid token.
 *         *   Creates a new `Task` object with the next available ID.
 *         *   Adds the new task to the `pendingTasks` queue using `offer()`.
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextTask()` Method:**
 *         *   Uses `pendingTasks.poll()` to retrieve and remove the task at the head of the queue. `poll()` is safe as it returns `null` if the queue is empty.
 *         *   Checks if `poll()` returned a task (`!= null`).
 *         *   If a task is retrieved, it's added to the `completedTasks` list using `completedTasks.add()`.
 *         *   Prints a success message to `System.out` indicating which task was processed.
 *         *   If the queue was empty, prints an informative message to `System.out`.
 *     *   **`viewPendingTasks()` Method:**
 *         *   Checks if the `pendingTasks` queue is empty.
 *         *   If not empty, it iterates through the queue using a `for-each` loop. This iteration does *not* remove elements from the queue, allowing them to remain pending.
 *         *   Prints each pending task using `System.out`.
 *     *   **`viewCompletedTasks()` Method:**
 *         *   Checks if the `completedTasks` list is empty.
 *         *   If not empty, it iterates through the list using a `for-each` loop.
 *         *   Prints each completed task using `System.out`.
 *     *   **`displayMenu()` Method:** A helper method to print the menu options to `System.out`.
 *     *   **`run()` Method:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   Displays the menu.
 *         *   **Class-Wide Exception Handling:** The core logic inside the loop (reading the choice and the `switch` statement) is wrapped in a `try-catch` block.
 *             *   `catch (InputMismatchException e)`: Catches errors if the user enters non-integer input for the menu choice. An error message is printed to `System.err`, and the invalid input is consumed from the scanner.
 *             *   `catch (Exception e)`: A general catch block for any other unexpected runtime errors. It prints a generic error message and the stack trace to `System.err`.
 *         *   **`switch` Statement:** Processes the user's integer choice. Each `case` corresponds to a menu option and calls the appropriate method (`addTask`, `processNextTask`, etc.). The `default` case handles invalid integer choices, printing an error to `System.err`.
 *         *   The loop continues until the user chooses the 'Exit' option (`choice == 5`).
 *         *   The `scanner` is closed after the loop terminates.
 *     *   **`main()` Method:** The entry point of the program. It creates an instance of `ExamTaskScheduler` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical task management scenario, demonstrating good programming practices like encapsulation, input validation, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the scheduling system.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // Priority is stored but not used for processing order in this simple FIFO system

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Priority=" + priority + "]";
    }
}

/**
 * A simple console-based task scheduling system using Queue and List.
 */
public class ExamTaskScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs
    private Scanner scanner;

    /**
     * Constructs a new ExamTaskScheduler.
     * Initializes the pending and completed task collections and the task ID counter.
     */
    public ExamTaskScheduler() {
        // Using LinkedList as a common implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as the implementation for the List of completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue after validating input.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        int priority = -1; // Use -1 to indicate invalid initial state
        boolean validPriority = false;

        // Input validation loop for priority
        while (!validPriority) {
            System.out.print("Enter task priority (positive integer): ");
            try {
                priority = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
                if (priority > 0) {
                    validPriority = true;
                } else {
                    System.err.println("Error: Priority must be a positive integer.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for priority.");
                // Consume the invalid input to prevent infinite loop
                scanner.next();
                // Consume the newline character left by next()
                scanner.nextLine();
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue, moving it to completed tasks.
     */
    public void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");
        Task nextTask = pendingTasks.poll(); // poll() retrieves and removes the head of the queue, returns null if empty

        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed: " + nextTask);
        } else {
            System.out.println("No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list
            int i = 1;
            for (Task task : completedTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main loop of the task scheduler application.
     * Handles user input and dispatches commands.
     */
    public void run() {
        boolean running = true;

        while (running) {
            displayMenu();
            int choice = -1; // Default to an invalid choice

            // --- Class-wide Exception Handling for User Input ---
            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // --- Switch Statement for Flow Control ---
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        break;
                    default:
                        // --- System.err for Error Messages ---
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // --- System.err for Error Messages ---
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                // Consume the invalid input to prevent infinite loop
                scanner.next();
                // Consume the newline character left by next()
                scanner.nextLine(); // Consume the rest of the line
            } catch (Exception e) {
                // --- General Exception Handling with System.err ---
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to err stream
                // Optionally, decide if the program should exit on unexpected errors
                // running = false;
            }
        }
        scanner.close(); // Close the scanner when done
    }

    /**
     * The main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ExamTaskScheduler scheduler = new ExamTaskScheduler();
        scheduler.run();
    }
}
