/*
 * Exam Question #551
 * Generated on: 2025-05-11 23:28:14
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Cloud Service Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified task management system for a cloud service. The system receives tasks, queues them for processing, processes them one by one, and keeps a record of completed tasks. The system should be interactive, allowing an operator to manage the tasks via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this task management system. Your solution must adhere to the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with at least a private field for the task description (`String`) and appropriate public methods (constructor, getter for description, `toString`).
 * 2.  **Task Management System:** Create a `TaskProcessorSystem` class that manages the tasks.
 *     *   It must have a private `Queue<Task>` to hold tasks waiting to be processed.
 *     *   It must have a private `List<Task>` (specifically initialized as an `ArrayList`) to store completed tasks.
 *     *   Implement the following public methods in `TaskProcessorSystem`:
 *         *   `addTask(String description)`: Adds a new `Task` to the pending queue. Validate that the description is not null or empty.
 *         *   `processNextTask()`: Removes the next task from the queue, simulates processing (e.g., print a message), and moves it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `viewPendingTasks()`: Prints the descriptions of all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Prints the descriptions of all tasks currently in the completed tasks list.
 *         *   Include appropriate encapsulation (private fields, public methods).
 * 3.  **User Interface:** In your main application class (e.g., `Main`), create a command-line interface using `java.util.Scanner`.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as the type for the completed tasks field)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` for error messages (e.g., invalid menu input, trying to process an empty queue, invalid task description).
 *     *   `System.out` for normal output (menu, task details, system messages).
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., around the main input loop or critical operations).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (menu choice, task description).
 *     *   Handle errors gracefully using `try-catch` and `System.err`.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Examples of output include:
 * 
 * *   Menu display.
 * *   Confirmation messages (e.g., "Task added successfully.").
 * *   Messages during processing (e.g., "Processing task: [Description]").
 * *   Lists of pending and completed tasks.
 * *   Error messages printed to `System.err` (e.g., "Error: Invalid menu choice.", "Error: Cannot process task. Queue is empty.").
 * 
 * Your solution should be a single `.java` file containing all necessary classes for submission (or clearly indicate how multiple files would be structured).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and functionality according to requirements.
 * *   Proper usage of all specified Java components.
 * *   Implementation of best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic class representing a task with a description and a completion status. It includes input validation in the constructor to ensure the description is not empty, throwing an `IllegalArgumentException`. Encapsulation is used with private fields and public methods.
 * 
 * 2.  **`TaskProcessorSystem` Class:** This is the core logic class.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to store tasks waiting for processing. A queue naturally models a waiting line where tasks are processed in the order they arrive (FIFO - First-In, First-Out).
 *     *   It uses a `java.util.List<Task>` (`completedTasks`) implemented by `java.util.ArrayList` to store tasks after they have been processed. A list is suitable here as we just need to keep a collection of completed items. `ArrayList` provides dynamic resizing and efficient element addition/access by index (though we only iterate here).
 *     *   `addTask()`: Uses `queue.offer()` to add a new task to the pending queue. It wraps the `Task` constructor call in a `try-catch` to potentially handle the `IllegalArgumentException` from `Task`, although it re-throws it to be caught by the main loop's more general handling.
 *     *   `processNextTask()`: Checks if the queue is empty using `isEmpty()`. If not empty, it uses `queue.poll()` to remove and return the task at the head of the queue. This task is then marked as completed and added to the `completedTasks` list using `list.add()`. If the queue is empty, it prints an error message using `System.err`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections (Queue and List) to print the task descriptions using `System.out`.
 * 
 * 3.  **`Main` Class:** This class contains the `main` method and handles the user interface.
 *     *   `java.util.Scanner` is used to read user input from the console.
 *     *   A `while` loop keeps the system running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed to `System.out`.
 *     *   The user's choice is read.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer input, calling the appropriate methods of the `TaskProcessorSystem`.
 *     *   **Input Validation and Error Handling:**
 *         *   A `try-catch (InputMismatchException e)` block is used inside the loop to catch non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   A `try-catch (IllegalArgumentException e)` is used specifically around the `system.addTask()` call in the `switch` case 1 to catch the validation error from the `Task` constructor and print it using `System.err`.
 *         *   A general `try-catch (Exception e)` is included inside the loop to catch any other unexpected runtime exceptions that might occur during the processing of a valid menu choice, printing an error to `System.err`.
 *         *   A top-level `try-catch (Exception mainException)` block is placed around the entire main `while` loop. This serves as the "class-wide" exception handling for the `Main` class's operational logic, catching any exceptions that might escape the inner handlers and ensuring a controlled shutdown (e.g., printing a final error message).
 *     *   `System.err.println()` is used specifically for error messages as required.
 *     *   `System.out.println()` is used for all normal program output (menu, prompts, confirmations, task lists).
 *     *   The `finally` block ensures the `Scanner` resource is closed properly when the main loop finishes or an exception is caught by the outer `try-catch`.
 * 
 * This structure effectively uses all the required components in a practical scenario, demonstrates proper encapsulation, naming, input validation, and layered exception handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return True if completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task.
     * @return String representation including description and completion status.
     */
    @Override
    public String toString() {
        return description + (isCompleted ? " (Completed)" : " (Pending)");
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class TaskProcessorSystem {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessorSystem.
     * Initializes the pending tasks queue and completed tasks list.
     */
    public TaskProcessorSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is invalid.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            pendingTasks.offer(newTask); // offer is preferred over add for bounded queues, but safe here
            System.out.println("Task added successfully: \"" + description + "\"");
        } catch (IllegalArgumentException e) {
            // Re-throw or handle, but the main loop will catch it.
            // System.err.println("Error adding task: " + e.getMessage()); // Could print here too
            throw e; // Propagate for main loop try-catch
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes it from the queue and adds it to the completed list.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: Cannot process task. Queue is empty.");
            return; // Exit method if queue is empty
        }

        Task taskToProcess = pendingTasks.poll(); // Remove task from head of queue
        if (taskToProcess != null) {
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess); // Add to the list of completed tasks
            System.out.println("Processing task: \"" + taskToProcess.getDescription() + "\"");
            System.out.println("Task marked as completed.");
        } else {
             // This case should theoretically not happen if isEmpty() check passes,
             // but good practice to handle null return from poll().
             System.err.println("Error: Failed to retrieve task from queue.");
        }
    }

    /**
     * Prints all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            int index = 1;
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Prints all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            int index = 1;
            // Iterate through the list
            for (Task task : completedTasks) {
                // Although Task toString includes status, we can just print description here
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("-----------------------\n");
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction via a command-line menu.
 */
public class Main {

    /**
     * Main method to run the task management system.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessorSystem system = new TaskProcessorSystem();
        boolean running = true;

        System.out.println("--- Cloud Service Task Manager ---");

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use a switch statement for menu control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            try {
                                system.addTask(description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 2:
                            system.processNextTask();
                            break;
                        case 3:
                            system.viewPendingTasks();
                            break;
                        case 4:
                            system.viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Manager. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during menu processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } catch (Exception mainException) {
             // This outer catch block handles exceptions that might escape the inner loop handling,
             // though the inner one is designed to catch most expected issues.
             // Demonstrates a top-level catch for the main class execution flow.
             System.err.println("A critical error stopped the application: " + mainException.getMessage());
             // mainException.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nChoose an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
