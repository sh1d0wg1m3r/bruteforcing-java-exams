/*
 * Exam Question #230
 * Generated on: 2025-05-11 22:36:13
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Research Lab Task Management System
 * 
 * **Problem Description:**
 * 
 * A research lab needs a simple console-based system to manage incoming tasks. Researchers submit tasks, which are then added to a queue for processing. The system should allow adding new tasks, processing the next task in line, viewing the current queue of pending tasks, and viewing a history of all tasks (pending, completed, or failed).
 * 
 * You are required to implement this system demonstrating your understanding of core Java data structures, flow control, input/output, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (unique integer, auto-generated)
 *     *   `description` (String)
 *     *   `priority` (String, e.g., "High", "Medium", "Low")
 *     *   `state` (Enum: `Pending`, `Processing`, `Completed`, `Failed`)
 *     *   Implement appropriate getters and a `toString()` method. Ensure attributes are private.
 * 
 * 2.  **Task State:** Create an enum `TaskState` with values `Pending`, `Processing`, `Completed`, `Failed`.
 * 
 * 3.  **Task Management Logic:** Create a `TaskManager` class responsible for managing tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks that are currently pending processing.
 *     *   It must use a `java.util.List<Task>` (specifically a `java.util.ArrayList<Task>`) to maintain a history of *all* tasks ever added to the system, regardless of their current state. Program against the `List` interface.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` (assigning a unique ID), adds it to the pending queue, and also adds it to the history list. The initial state is `Pending`.
 *         *   `processNextTask()`: Removes the next task from the pending queue (FIFO). Updates its state to `Processing`. Simulate processing (e.g., print a message). Then, update the task's state in the history list to either `Completed` or `Failed` (you can simulate success/failure randomly or just set to `Completed`). Print the outcome. Handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns an unmodifiable view of the pending tasks queue.
 *         *   `getAllTasksHistory()`: Returns an unmodifiable view of the all tasks history list.
 *     *   Use private fields for the collections.
 * 
 * 4.  **Console Application:** Create a main class `LabTaskManagerApp` with a `main` method to provide a console interface.
 *     *   Use `java.util.Scanner` to read user input for menu choices and task details.
 *     *   Implement a menu with the following options using a `switch` statement:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks Queue
 *         4.  View All Tasks History
 *         5.  Exit
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty during processing).
 *     *   Implement input validation where necessary (e.g., check if priority is a valid string like "High", "Medium", "Low"). If input is invalid, print an error to `System.err` and do not proceed with the action.
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main application loop or critical sections (like input reading or processing) to catch potential exceptions (e.g., `java.util.InputMismatchException` when reading numbers, or potential exceptions from `processNextTask`). Print informative error messages using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Handle errors gracefully and inform the user using `System.err`.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Lab Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks Queue
 * 4. View All Tasks History
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Analyze sample data
 * Enter priority (High, Medium, Low): High
 * Task added successfully! Task ID: 1
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Write report section
 * Enter priority (High, Medium, Low): Medium
 * Task added successfully! Task ID: 2
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 1, Description: Analyze sample data, Priority: High, State: Pending
 * Task ID: 2, Description: Write report section, Priority: Medium, State: Pending
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task ID: 1 - Analyze sample data
 * Task ID 1 completed successfully.
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 2, Description: Write report section, Priority: Medium, State: Pending
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 4
 * --- All Tasks History ---
 * Task ID: 1, Description: Analyze sample data, Priority: High, State: Completed
 * Task ID: 2, Description: Write report section, Priority: Medium, State: Pending
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task ID: 2 - Write report section
 * Task ID 2 completed successfully.
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Lab Task Management System ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Implement the necessary classes and the main application logic to fulfill these requirements.
 *
 * EXPLANATION:
 * 
 */

import java.util.*;

// Enum for Task State
enum TaskState {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Class representing a Task
class Task {
    private int taskId;
    private String description;
    private String priority; // Using String as per requirement, could be enum
    private TaskState state;

    // Static counter for unique task IDs
    private static int nextTaskId = 1;

    /**
     * Constructor for Task.
     * @param description The task description.
     * @param priority The task priority (e.g., High, Medium, Low).
     */
    public Task(String description, String priority) {
        this.taskId = nextTaskId++;
        this.description = description;
        this.priority = priority;
        this.state = TaskState.PENDING; // New tasks start as Pending
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public TaskState getState() {
        return state;
    }

    // Setter for state (used by TaskManager)
    public void setState(TaskState state) {
        this.state = state;
    }

    @Override
    public String toString() {
        return "Task ID: " + taskId +
               ", Description: " + description +
               ", Priority: " + priority +
               ", State: " + state;
    }
}

// Class managing tasks
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to keep track of all tasks ever added (history)
    private List<Task> allTasksHistory;

    /**
     * Constructor for TaskManager.
     * Initializes the collections.
     */
    public TaskManager() {
        // Using LinkedList as a common Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as required for history list
        this.allTasksHistory = new ArrayList<>();
    }

    /**
     * Adds a new task to the system.
     * Creates a Task object, adds it to the pending queue and the history list.
     * @param description The task description.
     * @param priority The task priority string.
     */
    public void addTask(String description, String priority) {
        Task newTask = new Task(description, priority);
        pendingTasks.offer(newTask); // Add to the end of the queue
        allTasksHistory.add(newTask); // Add to the history list
        System.out.println("Task added successfully! " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task, updates its state, simulates processing, and updates state in history.
     * Handles empty queue case.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Get and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        System.out.println("Processing task ID: " + taskToProcess.getTaskId() + " - " + taskToProcess.getDescription());

        // Find the task in the history list to update its state
        Task taskInHistory = findTaskInHistory(taskToProcess.getTaskId());

        if (taskInHistory != null) {
            taskInHistory.setState(TaskState.PROCESSING); // Set state to Processing

            // Simulate processing (e.g., random success/failure or just success)
            // For simplicity, let's just mark it as Completed
            taskInHistory.setState(TaskState.COMPLETED);
            System.out.println("Task ID " + taskToProcess.getTaskId() + " completed successfully.");

            // If we wanted random failure:
            /*
            Random random = new Random();
            if (random.nextBoolean()) { // 50% chance of success
                taskInHistory.setState(TaskState.COMPLETED);
                System.out.println("Task ID " + taskToProcess.getTaskId() + " completed successfully.");
            } else { // 50% chance of failure
                 taskInHistory.setState(TaskState.FAILED);
                 System.err.println("Task ID " + taskToProcess.getTaskId() + " failed during processing.");
            }
            */

        } else {
            // This case should ideally not happen if tasks are added correctly
            System.err.println("Error: Task ID " + taskToProcess.getTaskId() + " not found in history list.");
            // Re-add to queue or handle as error? Let's just report error for exam.
        }
    }

    /**
     * Helper method to find a task in the history list by ID.
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskInHistory(int taskId) {
        for (Task task : allTasksHistory) {
            if (task.getTaskId() == taskId) {
                return task;
            }
        }
        return null;
    }


    /**
     * Returns an unmodifiable view of the pending tasks queue.
     * @return A Collection view of pending tasks.
     */
    public Collection<Task> getPendingTasks() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableCollection(pendingTasks);
    }

    /**
     * Returns an unmodifiable view of the all tasks history list.
     * @return An unmodifiable List view of all tasks history.
     */
    public List<Task> getAllTasksHistory() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableList(allTasksHistory);
    }

    /**
     * Validates if the given priority string is one of the accepted values.
     * @param priority The priority string to validate.
     * @return true if valid, false otherwise.
     */
    public static boolean isValidPriority(String priority) {
        if (priority == null) {
            return false;
        }
        String lowerPriority = priority.trim().toLowerCase();
        return lowerPriority.equals("high") || lowerPriority.equals("medium") || lowerPriority.equals("low");
    }
}

// Main Application Class
public class LabTaskManagerApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Lab Task Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            runSystem();
        } catch (InputMismatchException e) {
             System.err.println("Error: Invalid input type. Please enter a number for the menu choice.");
             // Consume the invalid input
             scanner.next();
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated.");
        }
    }

    /**
     * Runs the main application loop and handles user interaction.
     */
    private static void runSystem() {
        int choice = -1;

        while (choice != 5) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read integer choice
                scanner.nextLine(); // Consume the newline character after reading int

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewAllTasksHistory();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            }
            System.out.println(); // Add a blank line for readability
        }
    }

    /**
     * Displays the main menu options.
     */
    private static void displayMenu() {
        System.out.println("--- Lab Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks Queue");
        System.out.println("4. View All Tasks History");
        System.out.println("5. Exit");
    }

    /**
     * Handles the "Add New Task" menu option.
     * Prompts user for description and priority, validates priority, and adds the task.
     */
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter priority (High, Medium, Low): ");
        String priority = scanner.nextLine();

        // Input validation for priority
        if (!TaskManager.isValidPriority(priority)) {
            System.err.println("Error: Invalid priority. Please enter High, Medium, or Low.");
            return; // Stop the task addition process
        }

        taskManager.addTask(description, priority);
    }

    /**
     * Handles the "View Pending Tasks Queue" menu option.
     * Displays tasks currently in the pending queue.
     */
    private static void viewPendingTasks() {
        Collection<Task> pending = taskManager.getPendingTasks();
        System.out.println("--- Pending Tasks ---");
        if (pending.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            for (Task task : pending) {
                System.out.println(task);
            }
        }
    }

    /**
     * Handles the "View All Tasks History" menu option.
     * Displays all tasks ever added, regardless of state.
     */
    private static void viewAllTasksHistory() {
        List<Task> history = taskManager.getAllTasksHistory();
        System.out.println("--- All Tasks History ---");
        if (history.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            for (Task task : history) {
                System.out.println(task);
            }
        }
    }
}
