/*
 * Exam Question #306
 * Generated on: 2025-05-11 22:52:29
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Topic:** Collections, I/O, Control Flow, and Exception Handling
 * **Duration:** 45-60 minutes
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line **Task Management System** for a small team. The system should allow users to add new tasks, view pending tasks, view completed tasks, and process the next task in the queue.
 * 
 * The system will manage tasks using two primary data structures:
 * 1.  A queue for tasks that are pending and waiting to be processed (First-In, First-Out).
 * 2.  A list for tasks that have been completed.
 * 
 * Your application should interact with the user via the console, presenting a menu of options and processing their input.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (e.g., 1 for High, 2 for Medium, 3 for Low).
 *     *   `status` (enum `Status`): An enum `Status` with values `PENDING` and `COMPLETED`.
 *     *   Include a constructor, public getter methods for all fields, and override the `toString()` method to provide a user-friendly representation of the task.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the collections of tasks. This class should have:
 *     *   A private `Queue<Task>` field to store pending tasks. Use a suitable implementation like `LinkedList`.
 *     *   A private `List<Task>` field to store completed tasks. Use `ArrayList`.
 *     *   A private counter for generating unique task IDs.
 *     *   Public methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` with status `PENDING`, assigns a unique ID, and adds it to the pending task queue.
 *         *   `getPendingTasks()`: Returns a `List<Task>` view of the pending tasks (do not remove them from the queue). The order should reflect the queue's order.
 *         *   `getCompletedTasks()`: Returns the `List<Task>` of completed tasks.
 *         *   `processNextTask()`: Removes the next task from the pending queue, changes its status to `COMPLETED`, and adds it to the completed tasks list. If the pending queue is empty, it should indicate this gracefully (e.g., return `false` or throw a custom exception, but for this exam, a simple return value or message is sufficient).
 * 
 * 3.  **User Interface and Application Flow:** Create a main class (e.g., `TaskManagementApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View Completed Tasks
 *         4.  Process Next Task
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid input type for priority, attempting to process when the queue is empty).
 *     *   Implement input validation for priority (e.g., ensure it's a positive integer).
 *     *   Use `try-catch` blocks to handle potential input errors from the `Scanner` (e.g., `InputMismatchException` if the user enters non-numeric input when expecting a number). Implement a class-wide `try-catch` mechanism, perhaps wrapping the main application loop, to catch unexpected runtime errors and provide a robust execution environment.
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments or Javadoc where necessary.
 *     *   Ensure clean code structure and separation of concerns between classes.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, prompt for input, and perform actions based on the input.
 * *   Adding a task should confirm the task was added.
 * *   Viewing tasks should list them with their details.
 * *   Processing a task should indicate which task was processed or if the queue was empty.
 * *   Invalid input or errors should result in an error message printed to `System.err`.
 * *   Exiting should terminate the program.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Fix login bug
 * Enter task priority (1-3): 1
 * Task added: Task{id=1, description='Fix login bug', priority=1, status=PENDing}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Pending Tasks:
 * Task{id=1, description='Fix login bug', priority=1, status=PENDING}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing next task...
 * Task processed: Task{id=1, description='Fix login bug', priority=1, status=COMPLETED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing next task...
 * No tasks in the pending queue.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Completed Tasks:
 * Task{id=1, description='Fix login bug', priority=1, status=COMPLETED}
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * ```
 * 
 * Your solution must compile and run correctly, demonstrating the use of all specified Java components and adhering to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   A simple POJO (`Task`) is created to hold task data (`taskId`, `description`, `priority`, `status`).
 *     *   An `enum Status` is used for clarity regarding task states (`PENDING`, `COMPLETED`).
 *     *   Private fields and public getters ensure encapsulation.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **TaskManager Class:**
 *     *   This class encapsulates the core logic and data structures.
 *     *   A `Queue<Task>` (`pendingTasks`) is used to store tasks waiting for processing. `LinkedList` is a common `Queue` implementation used here. The FIFO nature of the queue ensures tasks are processed in the order they were added.
 *     *   A `List<Task>` (`completedTasks`) is used to store tasks once they are finished. `ArrayList` provides dynamic resizing and easy storage/retrieval of completed tasks.
 *     *   `addTask`: Creates a new `Task` instance with a unique ID (managed by `nextTaskId`) and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `getPendingTasks`: Returns a `List` view of the pending tasks. Crucially, it returns a *new* `ArrayList` populated from the queue elements (`new ArrayList<>(pendingTasks)`). This adheres to good practice by not exposing the internal `Queue` directly, preventing external code from modifying the queue's structure unexpectedly. It also fulfills the requirement of using the `List` interface for returning collections.
 *     *   `getCompletedTasks`: Returns a `List` view of the completed tasks, again returning a copy (`new ArrayList<>(completedTasks)`) to protect the internal list.
 *     *   `processNextTask`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. If the queue is empty, `poll()` returns `null`, which is handled gracefully by printing an error message to `System.err`. If a task is retrieved, its status is updated, and it's added to the `completedTasks` `ArrayList`.
 * 
 * 3.  **TaskManagementApp Class:**
 *     *   The `main` method serves as the application's entry point and user interface handler.
 *     *   `java.util.Scanner` is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `printMenu()` method displays the available options.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice. This directly addresses the `switch` requirement.
 *     *   `System.out` is used for printing the menu, lists of tasks, and confirmation messages.
 *     *   `System.err` is used specifically for printing error messages, such as invalid input or attempting to process an empty queue. This fulfills the `System.err` requirement.
 * 
 * 4.  **Input Validation and Exception Handling:**
 *     *   The code includes `try-catch` blocks around `scanner.nextInt()` calls to catch `InputMismatchException` if the user enters non-integer text. This prevents the program from crashing.
 *     *   After catching `InputMismatchException`, `scanner.next()` is used to consume the invalid token, and `scanner.nextLine()` in the `finally` block consumes the rest of the line, preventing infinite loops caused by the scanner not advancing past the invalid input.
 *     *   Basic validation for priority (must be positive) is included.
 *     *   A top-level `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might occur within the loop and preventing the program from terminating abruptly. It prints the error message and stack trace to `System.err` before the `finally` block ensures the `Scanner` is closed.
 *     *   The `processNextTask` method in `TaskManager` checks if `poll()` returns `null` and prints an error to `System.err` if the queue is empty, handling this specific scenario gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is maintained through private fields and public methods in `Task` and `TaskManager`.
 *     *   Variable and method names (e.g., `pendingTasks`, `processNextTask`, `printMenu`) are descriptive.
 *     *   Comments are used to explain the purpose of classes, methods, and key logic sections.
 *     *   Using `List` as the return type for methods like `getPendingTasks` and `getCompletedTasks` promotes programming to interfaces rather than concrete implementations.
 *     *   The code is structured into logical classes with clear responsibilities.
 * 
 * This solution effectively integrates all the required Java components and demonstrates robust handling of user input and potential errors within a practical scenario, suitable for an advanced programming exam.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents the status of a task
enum Status {
    PENDING,
    COMPLETED
}

// Represents a single task
class Task {
    private int taskId;
    private String description;
    private int priority; // e.g., 1: High, 2: Medium, 3: Low
    private Status status;

    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter for Status (used when processing) ---
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{" +
               "id=" + taskId +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               ", status=" + status +
               '}';
    }
}

// Manages the collection of tasks
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for unique IDs

    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Does not remove tasks from the queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This prevents external modification of the internal queue structure
        // and allows iterating over the queue's current state.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of tasks that have been completed.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return new ArrayList<>(completedTasks); // Return a copy
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed.
     * @return The processed Task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        System.out.println("Processing next task...");
        Task nextTask = pendingTasks.poll(); // poll returns null if queue is empty

        if (nextTask != null) {
            nextTask.setStatus(Status.COMPLETED);
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask);
            return nextTask;
        } else {
            System.err.println("No tasks in the pending queue.");
            return null;
        }
    }
}

// Main application class for user interaction
public class TaskManagementApp {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling wrapping the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default to an invalid choice

                // --- Input Handling for Menu Choice ---
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                } finally {
                     scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                // --- Switch statement for menu options ---
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        int priority = -1;
                        boolean validPriority = false;
                        // --- Input Handling for Priority ---
                        while (!validPriority) {
                            try {
                                System.out.print("Enter task priority (e.g., 1 for High, 2 for Medium, 3 for Low): ");
                                priority = scanner.nextInt();
                                if (priority > 0) { // Basic validation for positive priority
                                    validPriority = true;
                                } else {
                                    System.err.println("Error: Priority must be a positive number.");
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input. Please enter a number for priority.");
                                scanner.next(); // Consume invalid input
                            } finally {
                                scanner.nextLine(); // Consume newline
                            }
                        }
                        taskManager.addTask(description, priority);
                        break;

                    case 2: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = taskManager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 3: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = taskManager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // Process Next Task
                        taskManager.processNextTask(); // TaskManager handles empty queue message
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid Choice
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Process Next Task");
        System.out.println("5. Exit");
    }
}
