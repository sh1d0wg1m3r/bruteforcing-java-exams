/*
 * Exam Question #684
 * Generated on: 2025-05-12 16:25:20
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Restaurant Kitchen Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified back-end system for a restaurant kitchen. The system needs to manage incoming customer orders, allow kitchen staff to process them, and display the current status of pending orders and the restaurant's menu.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this kitchen workflow. The program should manage a queue of incoming orders and allow a user (simulating kitchen staff) to interact with the system via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `MenuItem`: A class representing an item on the menu. It should have private fields for `name` (String) and `price` (double). Include a constructor and public getter methods.
 *     *   `Order`: A class representing a customer order. It should have a unique `orderId` (int), a `List` of `MenuItem` objects representing the items ordered, and a `status` (e.g., PENDING, READY - you can use a String or Enum). Include a constructor, public getters, and a method to update the status.
 *     *   `RestaurantKitchenSystem`: The main class that orchestrates the system. It should contain:
 *         *   A `Queue` of `Order` objects to hold orders waiting to be processed.
 *         *   A `List` of `MenuItem` objects representing the restaurant's fixed menu.
 *         *   Methods for:
 *             *   Initializing the menu.
 *             *   Adding a new order to the queue (this should prompt the user to select items from the menu).
 *             *   Processing the next order in the queue (dequeues the order and updates its status).
 *             *   Viewing the current queue of pending orders.
 *             *   Viewing the menu.
 *             *   A main loop to handle user input and dispatch actions.
 * 
 * 2.  **Functionality:**
 *     *   The system should start with a pre-defined menu (at least 3-4 items).
 *     *   The main loop should repeatedly present the user with options (Add Order, Process Next Order, View Queue, View Menu, Exit).
 *     *   **Add Order:**
 *         *   Generate a simple unique `orderId` (e.g., incrementing counter).
 *         *   Prompt the user to select menu items by number and specify quantity for each. Allow adding multiple items to a single order.
 *         *   Create an `Order` object with the selected items and initial status (PENDING).
 *         *   Add the new `Order` to the `Queue`.
 *     *   **Process Next Order:**
 *         *   Dequeue the next order from the `Queue`.
 *         *   If the queue is empty, display an appropriate message using `System.out`.
 *         *   If an order is dequeued, update its status (e.g., to READY) and display confirmation using `System.out`.
 *     *   **View Queue:**
 *         *   Display the `orderId` and status of all orders currently in the `Queue`. If the queue is empty, display an appropriate message. Use `System.out`.
 *     *   **View Menu:**
 *         *   Display the list of menu items with their numbers, names, and prices. Use `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **Required Java Components:**
 *     *   `java.util.Queue` (use a concrete implementation like `LinkedList`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for flow control based on user action
 *     *   `System.err` for displaying error messages (e.g., invalid menu item selection, invalid quantity, invalid command input).
 *     *   `System.out` for displaying normal output (menu, queue status, confirmations, prompts).
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid user input (non-numeric where numbers are expected) or operations on an empty queue where an element is expected.
 * 
 * 4.  **Best Practices:**
 *     *   Use private fields and public getter methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs are a plus).
 *     *   Implement input validation for user choices (menu options, item numbers, quantities).
 *     *   Handle errors gracefully using `try-catch` and `System.err`.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu of options to the user, accept input, and produce output (menu, queue status, confirmations, or error messages) based on the chosen action. Examples:
 * 
 * ```
 * --- Kitchen System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Menu
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Order ---
 * Menu:
 * 1. Burger ($8.99)
 * 2. Pizza ($12.50)
 * 3. Fries ($3.49)
 * Enter item number to add (or 0 to finish order): 1
 * Enter quantity: 2
 * Added 2 x Burger to order.
 * Enter item number to add (or 0 to finish order): 3
 * Enter quantity: 1
 * Added 1 x Fries to order.
 * Enter item number to add (or 0 to finish order): 0
 * Order #1 created and added to queue.
 * 
 * --- Kitchen System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Menu
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Orders ---
 * Order #1 (PENDING) - Items: [Burger, Burger, Fries]
 * Queue size: 1
 * 
 * --- Kitchen System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Menu
 * 5. Exit
 * Enter your choice: 2
 * Processing order #1...
 * Order #1 status updated to READY.
 * 
 * --- Kitchen System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Menu
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Orders ---
 * No orders currently pending.
 * Queue size: 0
 * 
 * --- Kitchen System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Menu
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * ```
 * 
 * This task requires you to integrate multiple Java concepts and standard library classes to build a functional, albeit simplified, system. Good luck!
 *
 * EXPLANATION:
 * This solution implements a simplified restaurant kitchen order management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple Plain Old Java Object (POJO) with private fields (`name`, `price`) and public getters, showcasing encapsulation.
 *     *   `Order`: Represents an order, holding an `orderId`, a `List<MenuItem>` for the items, and a `status`. It also uses encapsulation with private fields and public methods (`getOrderId`, `getItems`, `getStatus`, `setStatus`). The `toString()` method provides a convenient representation for printing. A defensive copy is made for the items list in the constructor and getter to prevent external modification of the order's internal state.
 *     *   `RestaurantKitchenSystem`: The main class orchestrating the system. It holds the core data structures (`pendingOrdersQueue`, `restaurantMenu`) and the application logic.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `Queue`: The `pendingOrdersQueue` is declared as `Queue<Order>` and initialized with `new LinkedList<>()`. The `offer()` method is used to add orders to the end of the queue, and `poll()` is used to retrieve and remove the order from the front (head) of the queue. `poll()` is used specifically because it returns `null` if the queue is empty, which is handled gracefully.
 *     *   `ArrayList`: Used to implement the `restaurantMenu` (`new ArrayList<>()`) and the `items` list within the `Order` class (`new ArrayList<>()`). This demonstrates `ArrayList` for dynamic, index-based lists.
 *     *   `List interface`: Variables like `restaurantMenu` and the `items` field in `Order` are declared using the `List<T>` interface type (`List<MenuItem>`). This promotes good practice by programming to the interface rather than the concrete implementation where appropriate.
 *     *   `Scanner`: An instance `scanner` is created to read user input from `System.in` for menu choices, item numbers, and quantities. `scanner.nextInt()` and `scanner.nextLine()` are used, paying attention to consuming the newline character after reading numbers.
 *     *   `Switch statement`: The `switch (choice)` block in the `run()` method is used to direct the program flow based on the user's main menu selection, clearly separating the different actions.
 *     *   `System.err`: Used specifically for displaying error messages, such as invalid user input (non-numeric, out of range menu choices, invalid quantities) or unexpected issues caught by the general exception handler.
 *     *   `System.out`: Used for all normal program output, including displaying the main menu, the restaurant menu, prompts for input, confirmations of actions (order added, order processed), and the status of the pending orders queue.
 *     *   `try-catch`: Exception handling is implemented in several places:
 *         *   Around `scanner.nextInt()` calls in `run()` and `addNewOrder()` to catch `InputMismatchException` if the user enters non-integer input.
 *         *   Around the core logic within the `run()` loop with a general `catch (Exception e)` block. While specific catches are preferred, a broad catch around the main loop demonstrates a form of "class-wide" handling for unexpected runtime issues in an exam context. More specific catches for `NoSuchElementException` (if scanner runs out of input) or `IllegalStateException` (if scanner is closed) are also included for robustness.
 *         *   Within `addNewOrder()` to handle potential exceptions during the item selection process.
 *         *   The `processNextOrder()` method implicitly handles the empty queue case using `poll()` and checking for `null`, which is a common and recommended pattern for queues.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters/setters are used in `MenuItem` and `Order`. The `RestaurantKitchenSystem` manages its internal state (`queue`, `menu`) privately.
 *     *   **Meaningful Names:** Variables (`pendingOrdersQueue`, `restaurantMenu`, `nextOrderId`, `itemChoice`, `quantity`) and methods (`initializeMenu`, `displayMainMenu`, `addNewOrder`, `processNextOrder`, `viewPendingOrders`, `displayMenu`, `run`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** JavaDocs are included for classes and methods explaining their roles, parameters, and return values. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Checks are performed to ensure user input for menu choices, item numbers, and quantities are within valid ranges or are positive numbers. Invalid input triggers error messages on `System.err`.
 *     *   **Error Handling:** `try-catch` blocks are used to prevent the program from crashing due to user input errors or unexpected runtime issues. Error messages are directed to `System.err`.
 *     *   **Clean Code Structure:** The code is organized into logical classes and methods, making it easier to read and understand. The main `run()` method drives the application flow, delegating specific tasks to other methods. The scanner is closed when the application exits.
 * 
 * This solution effectively integrates the required Java components into a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and exception handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a single menu item in the restaurant.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The item price.
     */
    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name; // Simplified for display in order list
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private int orderId;
    private List<MenuItem> items;
    private String status; // Could be an Enum for better type safety

    // Using String for status as per exam requirements flexibility
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_READY = "READY";

    /**
     * Constructs a new Order.
     * @param orderId The unique identifier for the order.
     * @param items The list of items in the order.
     */
    public Order(int orderId, List<MenuItem> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a defensive copy
        this.status = STATUS_PENDING; // Orders start as PENDING
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of menu items.
     */
    public List<MenuItem> getItems() {
        return new ArrayList<>(items); // Return a defensive copy
    }

    /**
     * Gets the current status of the order.
     * @return The order status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the order.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Order #" + orderId + " (" + status + ") - Items: " + items;
    }
}

/**
 * The main system managing the kitchen workflow.
 */
public class RestaurantKitchenSystem {

    private Queue<Order> pendingOrdersQueue;
    private List<MenuItem> restaurantMenu;
    private Scanner scanner;
    private int nextOrderId = 1; // Simple counter for unique order IDs

    /**
     * Constructs the RestaurantKitchenSystem.
     */
    public RestaurantKitchenSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingOrdersQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List for the menu
        this.restaurantMenu = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        initializeMenu();
    }

    /**
     * Initializes the restaurant menu with some default items.
     */
    private void initializeMenu() {
        restaurantMenu.add(new MenuItem("Burger", 8.99));
        restaurantMenu.add(new MenuItem("Pizza", 12.50));
        restaurantMenu.add(new MenuItem("Fries", 3.49));
        restaurantMenu.add(new MenuItem("Soda", 2.00));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Kitchen System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Menu");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the process of adding a new order based on user input.
     */
    private void addNewOrder() {
        System.out.println("\n--- Add New Order ---");
        List<MenuItem> currentOrderItems = new ArrayList<>();
        boolean addingItems = true;

        while (addingItems) {
            displayMenu(); // Show menu to user

            int itemChoice = -1;
            try {
                System.out.print("Enter item number to add (or 0 to finish order): ");
                itemChoice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                if (itemChoice == 0) {
                    addingItems = false;
                    continue; // Exit item selection loop
                }

                if (itemChoice < 1 || itemChoice > restaurantMenu.size()) {
                    System.err.println("Invalid item number. Please select from the menu.");
                    continue; // Ask again
                }

                int quantity = -1;
                System.out.print("Enter quantity: ");
                quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                if (quantity <= 0) {
                    System.err.println("Quantity must be positive.");
                    continue; // Ask again
                }

                // Get the selected item (index is choice - 1)
                MenuItem selectedItem = restaurantMenu.get(itemChoice - 1);

                // Add the item multiple times based on quantity
                for (int i = 0; i < quantity; i++) {
                    currentOrderItems.add(selectedItem);
                }
                System.out.println("Added " + quantity + " x " + selectedItem.getName() + " to order.");

            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions during item selection
                System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                // Decide if to continue or break, for an exam, continuing might be acceptable
            }
        }

        if (!currentOrderItems.isEmpty()) {
            Order newOrder = new Order(nextOrderId++, currentOrderItems);
            pendingOrdersQueue.offer(newOrder); // Add order to the queue
            System.out.println("Order #" + newOrder.getOrderId() + " created and added to queue.");
        } else {
            System.out.println("No items added to order. Order not created.");
        }
    }

    /**
     * Processes the next order in the queue.
     */
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        // Using poll() is safer than remove() as it returns null if queue is empty
        Order orderToProcess = pendingOrdersQueue.poll();

        if (orderToProcess == null) {
            System.out.println("No orders currently pending to process.");
        } else {
            System.out.println("Processing order #" + orderToProcess.getOrderId() + "...");
            // Simulate processing by changing status
            orderToProcess.setStatus(Order.STATUS_READY);
            System.out.println("Order #" + orderToProcess.getOrderId() + " status updated to " + orderToProcess.getStatus() + ".");
            // In a real system, this might move to a 'completed orders' list
        }
    }

    /**
     * Displays the orders currently in the pending queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrdersQueue.isEmpty()) {
            System.out.println("No orders currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : pendingOrdersQueue) {
                System.out.println(order); // Order's toString() provides details
            }
        }
        System.out.println("Queue size: " + pendingOrdersQueue.size());
    }

    /**
     * Displays the restaurant menu.
     */
    private void displayMenu() {
        System.out.println("Menu:");
        // Use List interface variable
        List<MenuItem> menuList = restaurantMenu;
        for (int i = 0; i < menuList.size(); i++) {
            MenuItem item = menuList.get(i);
            System.out.printf("%d. %s ($%.2f)%n", (i + 1), item.getName(), item.getPrice());
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMainMenu();

            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addNewOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewPendingOrders();
                        break;
                    case 4:
                        displayMenu();
                        break;
                    case 5:
                        System.out.println("Exiting Kitchen System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid command input
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for the main menu choice
                System.err.println("Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (NoSuchElementException e) {
                 // This might occur if the input stream is closed unexpectedly
                 System.err.println("Input stream closed unexpectedly. Exiting.");
                 choice = 5; // Exit loop
            } catch (IllegalStateException e) {
                 // This might occur if the scanner is closed elsewhere
                 System.err.println("Scanner is closed. Exiting.");
                 choice = 5; // Exit loop
            } catch (Exception e) {
                // Class-wide catch for any other unexpected runtime exceptions
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging in exam context
                // Depending on severity, you might exit or try to continue
                // For this exam, we'll let the loop continue if possible
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantKitchenSystem system = new RestaurantKitchenSystem();
        system.run();
    }
}
