/*
 * Exam Question #121
 * Generated on: 2025-05-11 22:17:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Kitchen Order Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified backend system for managing kitchen orders in a restaurant. The system should allow kitchen staff to:
 * 1.  Place new orders (add them to a queue for processing).
 * 2.  Process the next available order from the queue.
 * 3.  View the list of orders currently waiting to be processed.
 * 4.  View the list of orders that have been completed.
 * 5.  Exit the system.
 * 
 * The system must be interactive, taking commands via standard input.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store orders that are waiting to be processed (pending orders). Orders should be processed in the order they were received (FIFO).
 *     *   Use an `ArrayList` to store orders that have been completed.
 *     *   Declare variables holding these collections using the `List` and `Queue` interfaces where appropriate.
 * 
 * 2.  **Order Representation:**
 *     *   Create a class `Order` to represent a single kitchen order.
 *     *   Each `Order` must have:
 *         *   A unique integer order ID.
 *         *   A list of items included in the order (e.g., "Burger", "Fries", "Coke").
 *         *   A status (e.g., PENDING, COMPLETED). Use an `enum` for the status.
 *     *   Implement proper encapsulation (private fields, public getters).
 *     *   Include a method to update the order's status (e.g., `markAsCompleted()`).
 *     *   Provide a meaningful `toString()` method for easy printing of order details.
 * 
 * 3.  **Manager Class:**
 *     *   Create a class `KitchenOrderManager` that encapsulates the logic for managing orders.
 *     *   This class should hold the `Queue` of pending orders and the `List` of completed orders as private fields.
 *     *   It should have public methods for:
 *         *   `placeOrder(List<String> items)`: Creates a new `Order` object, adds it to the pending queue, and returns the new order ID.
 *         *   `processNextOrder()`: Takes the next order from the pending queue, updates its status to COMPLETED, and moves it to the completed list. Should handle the case where the pending queue is empty.
 *         *   `getPendingOrders()`: Returns a `List` view of the pending orders (without removing them from the queue).
 *         *   `getCompletedOrders()`: Returns the `List` of completed orders.
 * 
 * 4.  **User Interface (in `main` method):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Place Order, Process Next, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   For placing an order, prompt the user to enter items one by one until they enter a specific keyword (e.g., "DONE"). An order must have at least one item.
 * 
 * 5.  **Error Handling:**
 *     *   Use `try-catch` blocks for class-wide exception handling, particularly for input validation (e.g., handling non-integer input for menu choices) and handling the case where `processNextOrder` is called when the pending queue is empty.
 *     *   Use `System.err` to print error messages (e.g., invalid input, no pending orders).
 *     *   Use `System.out` for all normal output (menu, prompts, order details, success messages).
 *     *   Implement input validation where necessary (e.g., ensure an order has items).
 * 
 * 6.  **Code Quality:**
 *     *   Follow Java coding conventions.
 *     *   Use meaningful names for classes, methods, and variables.
 *     *   Include comments to explain complex logic or sections.
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, prompting for input, and printing results or errors based on the user's actions. Examples:
 * 
 * *   **Menu:** Display options 1-5.
 * *   **Place Order:** Prompt for items, then print "Order [ID] placed with items: [item1, item2, ...]".
 * *   **Process Next:** If queue not empty, print "Processing Order [ID]: [item1, item2, ...]" and "Order [ID] marked as COMPLETED.". If queue empty, print "No pending orders to process." to `System.err`.
 * *   **View Pending:** Print "Pending Orders:" followed by details of each order in the queue. If empty, print "No orders currently pending."
 * *   **View Completed:** Print "Completed Orders:" followed by details of each order in the completed list. If empty, print "No orders have been completed yet."
 * *   **Invalid Input/Choice:** Print an error message to `System.err` (e.g., "Invalid input. Please enter a number.", "Invalid choice. Please enter a number between 1 and 5.").
 * *   **Exit:** Print a farewell message and terminate.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required features and data structures.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Effective encapsulation and class design.
 * *   Robust error handling and input validation.
 * *   Clean code structure, meaningful names, and appropriate comments.
 * *   Adherence to output requirements.
 *
 * EXPLANATION:
 * This solution implements the Kitchen Order Management System following all the specified requirements.
 * 
 * 1.  **Problem Structure:** The problem is broken down into logical components: an `Order` class to represent the data, a `KitchenOrderManager` class to handle the business logic (managing the collections and operations), and a `KitchenApp` class with the `main` method to handle user interaction and the application loop. This demonstrates good object-oriented design principles.
 * 
 * 2.  **Data Structures:**
 *     *   `Queue<Order> pendingOrders`: A `LinkedList` is used to implement the `Queue` interface. This correctly models the FIFO (First-In, First-Out) nature of kitchen orders waiting to be processed. `pendingOrders.add()` adds to the end, and `pendingOrders.poll()` removes from the front.
 *     *   `List<Order> completedOrders`: An `ArrayList` is used to implement the `List` interface. This is suitable for storing completed orders, allowing easy iteration and retrieval.
 *     *   The variables are declared using the `Queue` and `List` interfaces (`private Queue<Order> pendingOrders;`, `private List<Order> completedOrders;`), promoting flexibility and adherence to interface-based programming.
 * 
 * 3.  **`Order` Class:**
 *     *   Encapsulation is used with `private` fields (`orderId`, `items`, `status`) and `public` getters.
 *     *   An `enum OrderStatus` is used for clarity and type safety regarding the order status.
 *     *   The constructor validates that an order must have items, throwing an `IllegalArgumentException` if not.
 *     *   Defensive copies are made in the constructor and `getItems()` getter to protect the internal `items` list from external modification.
 *     *   `markAsCompleted()` provides a controlled way to change the status.
 *     *   `toString()` provides a convenient, readable representation of an order.
 * 
 * 4.  **`KitchenOrderManager` Class:**
 *     *   This class encapsulates the core logic and manages the state (the two collections and the next order ID).
 *     *   `placeOrder()`: Creates a new `Order`, adds it to the `pendingOrders` queue using `add()`, and manages the unique `nextOrderId`.
 *     *   `processNextOrder()`: Uses `pendingOrders.poll()` to get and remove the next order. It throws an `IllegalStateException` if the queue is empty, which is caught and handled in the `main` method. It updates the status and adds the processed order to the `completedOrders` list.
 *     *   `getPendingOrders()` and `getCompletedOrders()`: These methods provide read-only access to the current state of the collections, returning `ArrayList` copies to maintain encapsulation.
 * 
 * 5.  **User Interface (`KitchenApp.main`):**
 *     *   `Scanner` is used for reading input. `try-with-resources` ensures the `Scanner` is automatically closed.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to direct execution based on the user's numeric menu choice. This fulfills the requirement for using a `switch`.
 *     *   Input for placing an order involves a nested `while` loop, prompting the user until they enter "DONE". It also includes basic validation to prevent adding empty item names.
 * 
 * 6.  **Error Handling:**
 *     *   A `try-catch` block wraps the core logic within the `while` loop in `main`.
 *     *   `InputMismatchException` is caught specifically to handle non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input (`scanner.nextLine()`) to prevent an infinite loop.
 *     *   `IllegalArgumentException` is caught when `placeOrder` is called with an empty item list (validation done in the `Order` constructor), printing an error to `System.err`.
 *     *   `IllegalStateException` is caught when `processNextOrder` is called on an empty queue, printing a specific error message to `System.err`.
 *     *   A general `Exception` catch is included as a fallback for any other unexpected errors, printing to `System.err`.
 *     *   All normal user prompts and output use `System.out`. Error messages consistently use `System.err`.
 * 
 * 7.  **Code Quality:**
 *     *   Meaningful names are used (e.g., `pendingOrders`, `processNextOrder`, `placeOrder`, `OrderStatus`).
 *     *   Comments explain the purpose of methods and key logic sections.
 *     *   The code is structured into logical classes and methods.
 * 
 * This solution effectively demonstrates the use of all required components in a practical, cohesive application, incorporating essential best practices like encapsulation, error handling, and input validation, making it a suitable challenging exam question.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Order Status
enum OrderStatus {
    PENDING,
    COMPLETED
}

// Class to represent a single Order
class Order {
    private int orderId;
    private List<String> items;
    private OrderStatus status;

    // Constructor
    public Order(int orderId, List<String> items) {
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("Order must contain at least one item.");
        }
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a defensive copy
        this.status = OrderStatus.PENDING;
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public List<String> getItems() {
        return new ArrayList<>(items); // Return a defensive copy
    }

    public OrderStatus getStatus() {
        return status;
    }

    // Method to mark order as completed
    public void markAsCompleted() {
        this.status = OrderStatus.COMPLETED;
    }

    @Override
    public String toString() {
        return "Order #" + orderId + " [" + status + "] - Items: " + items;
    }
}

// Class to manage Kitchen Orders
class KitchenOrderManager {
    // Using Queue interface, implemented by LinkedList for FIFO
    private Queue<Order> pendingOrders;
    // Using List interface, implemented by ArrayList for dynamic storage
    private List<Order> completedOrders;
    private int nextOrderId; // To generate unique order IDs

    // Constructor
    public KitchenOrderManager() {
        this.pendingOrders = new LinkedList<>();
        this.completedOrders = new ArrayList<>();
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Places a new order with the given items.
     *
     * @param items The list of items for the order. Must not be empty.
     * @return The ID of the newly placed order.
     * @throws IllegalArgumentException if the items list is null or empty.
     */
    public int placeOrder(List<String> items) {
        Order newOrder = new Order(nextOrderId, items);
        pendingOrders.add(newOrder); // Add to the end of the queue
        System.out.println("Order #" + newOrder.getOrderId() + " placed with items: " + newOrder.getItems());
        return nextOrderId++; // Increment for the next order
    }

    /**
     * Processes the next order from the pending queue.
     * Moves the order to the completed list after processing.
     *
     * @return The processed Order object.
     * @throws IllegalStateException if there are no pending orders.
     */
    public Order processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Order nextOrder = pendingOrders.poll();

        if (nextOrder == null) {
            throw new IllegalStateException("No pending orders to process.");
        }

        System.out.println("Processing Order #" + nextOrder.getOrderId() + ": " + nextOrder.getItems());
        nextOrder.markAsCompleted(); // Update status
        completedOrders.add(nextOrder); // Add to the completed list
        System.out.println("Order #" + nextOrder.getOrderId() + " marked as COMPLETED.");

        return nextOrder;
    }

    /**
     * Returns a list of orders currently waiting in the pending queue.
     * The orders remain in the queue.
     *
     * @return A List containing the pending orders. Returns an empty list if no orders are pending.
     */
    public List<Order> getPendingOrders() {
        // Create a new ArrayList from the queue elements without removing them
        return new ArrayList<>(pendingOrders);
    }

    /**
     * Returns a list of all completed orders.
     *
     * @return A List containing the completed orders. Returns an empty list if no orders are completed.
     */
    public List<Order> getCompletedOrders() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(completedOrders);
    }
}

// Main application class
public class KitchenApp {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            KitchenOrderManager orderManager = new KitchenOrderManager();
            boolean running = true;

            // Class-wide exception handling structure within the main loop
            while (running) {
                printMenu();
                int choice = -1;

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer input
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1: // Place Order
                            System.out.println("--- Place New Order ---");
                            List<String> items = new ArrayList<>();
                            System.out.println("Enter items one by one. Type 'DONE' when finished.");
                            String item;
                            while (true) {
                                System.out.print("Enter item (or DONE): ");
                                item = scanner.nextLine().trim();
                                if (item.equalsIgnoreCase("DONE")) {
                                    break;
                                }
                                if (!item.isEmpty()) {
                                    items.add(item);
                                } else {
                                    System.out.println("Item name cannot be empty. Please try again.");
                                }
                            }

                            try {
                                orderManager.placeOrder(items);
                            } catch (IllegalArgumentException e) {
                                // Handle case where no items were entered before typing DONE
                                System.err.println("Error placing order: " + e.getMessage());
                            }
                            break;

                        case 2: // Process Next Order
                            System.out.println("--- Process Next Order ---");
                            try {
                                orderManager.processNextOrder();
                            } catch (IllegalStateException e) {
                                // Handle case where pending queue is empty
                                System.err.println(e.getMessage());
                            }
                            break;

                        case 3: // View Pending Orders
                            System.out.println("--- Pending Orders ---");
                            List<Order> pending = orderManager.getPendingOrders(); // Use List interface
                            if (pending.isEmpty()) {
                                System.out.println("No orders currently pending.");
                            } else {
                                for (Order order : pending) {
                                    System.out.println(order); // Uses Order's toString()
                                }
                            }
                            break;

                        case 4: // View Completed Orders
                            System.out.println("--- Completed Orders ---");
                            List<Order> completed = orderManager.getCompletedOrders(); // Use List interface
                            if (completed.isEmpty()) {
                                System.out.println("No orders have been completed yet.");
                            } else {
                                for (Order order : completed) {
                                    System.out.println(order); // Uses Order's toString()
                                }
                            }
                            break;

                        case 5: // Exit
                            System.out.println("Exiting Kitchen Order System. Goodbye!");
                            running = false;
                            break;

                        default: // Handle invalid menu numbers
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("--- Kitchen Order System Menu ---");
        System.out.println("1. Place New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.println("---------------------------------");
    }
}
