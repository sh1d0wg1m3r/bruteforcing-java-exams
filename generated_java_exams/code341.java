/*
 * Exam Question #341
 * Generated on: 2025-05-11 22:57:47
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam - Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team or individual. The system should allow users to add new tasks, complete the next task in a processing queue, view pending tasks, and view completed tasks.
 * 
 * Your solution must demonstrate proficiency in using various core Java constructs and collections.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. It should have a private field for the task description (`String`) and a public method to retrieve the description.
 * 2.  **Task Manager:** Create a class named `TaskManager` that will manage the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (the "processing queue"). Use a concrete implementation like `LinkedList`.
 *     *   It must use a `java.util.List<Task>` (declared as the interface type `List`) to store tasks that have been completed. Use a concrete implementation like `ArrayList`.
 *     *   Implement methods for:
 *         *   Adding a new task to the processing queue.
 *         *   Completing the next task: removes the task from the head of the processing queue and adds it to the completed tasks list. This operation should handle the case where the processing queue is empty.
 *         *   Listing all tasks currently in the processing queue.
 *         *   Listing all completed tasks.
 *     *   The `TaskManager` class should contain the main application logic, including the user interaction loop.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (e.g., Add Task, Complete Task, List Pending, List Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, listing tasks, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to complete a task when the queue is empty).
 * 5.  **Error Handling & Validation:**
 *     *   Implement input validation for the menu choice. If the user enters non-integer input or an invalid integer choice, display an error message using `System.err` and prompt them again.
 *     *   Handle the specific case of trying to complete a task when the processing queue is empty, displaying an appropriate message using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main user interaction loop within the `TaskManager` class to catch unexpected runtime exceptions.
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs or inline comments).
 *     *   Ensure clean code structure.
 * 
 * **Execution:**
 * 
 * The program should start, display the menu, and continuously accept user input until the 'Exit' option is chosen.
 * 
 * **Expected Output Format:**
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 
 * ```
 * 
 * (Followed by output relevant to the chosen option, using `System.out` for success/lists and `System.err` for errors).
 * 
 * **Example Interaction:**
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write Java Exam Question
 * Task added: Write Java Exam Question
 * Enter your choice: 1
 * Enter task description: Grade Student Papers
 * Task added: Grade Student Papers
 * Enter your choice: 3
 * Pending Tasks:
 * 1. Write Java Exam Question
 * 2. Grade Student Papers
 * Enter your choice: 2
 * Completed task: Write Java Exam Question
 * Enter your choice: 3
 * Pending Tasks:
 * 1. Grade Student Papers
 * Enter your choice: 4
 * Completed Tasks:
 * 1. Write Java Exam Question
 * Enter your choice: 2
 * Completed task: Grade Student Papers
 * Enter your choice: 3
 * Pending Tasks:
 * (Queue is empty)
 * Enter your choice: 4
 * Completed Tasks:
 * 1. Write Java Exam Question
 * 2. Grade Student Papers
 * Enter your choice: 2
 * Error: No tasks in the queue to complete.
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number between 1 and 5.
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java source code for the `Task` and `TaskManager` classes in a single file or clearly separated code blocks.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a task. It has a private `description` field and a public getter method, adhering to encapsulation principles. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **`TaskManager` Class:** This is the core of the application.
 *     *   **Data Structures:** It uses a `java.util.Queue<Task>` (`processingQueue`) implemented by `LinkedList` to manage tasks waiting to be done in a FIFO (First-In, First-Out) manner. It uses a `java.util.List<Task>` (`completedTasks`) declared as the interface type and implemented by `ArrayList` to store completed tasks, allowing easy storage and retrieval by index if needed (though iteration is used here). Using the `List` interface is a best practice, promoting flexibility.
 *     *   **Methods:**
 *         *   `addTask()`: Creates a `Task` object and adds it to the `processingQueue` using `offer()`. Includes basic validation for the description.
 *         *   `completeNextTask()`: Uses `poll()` to remove the head of the `processingQueue`. `poll()` is safe as it returns `null` if the queue is empty, which is handled with an `if` condition and an error message via `System.err`. If successful, the task is added to the `completedTasks` `ArrayList`.
 *         *   `listPendingTasks()` and `listCompletedTasks()`: These methods iterate through the respective collections and print the task descriptions using `System.out`. They check if the collections are empty.
 *         *   `displayMenu()`: A helper method to print the menu options using `System.out`.
 *         *   `run()`: Contains the main application loop. It continuously displays the menu, reads user input, and performs actions based on the input.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`):**
 *     *   A `Scanner` object reads input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement processes the integer menu choice, directing execution to the appropriate `TaskManager` method.
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   Normal messages, menu display, and task listings are printed using `System.out`.
 *     *   Error conditions, such as invalid input or trying to complete a task from an empty queue, are reported using `System.err`.
 * 
 * 5.  **Error Handling (`try-catch`, Validation):**
 *     *   **Input Validation:** Before reading the integer choice, `scanner.hasNextInt()` checks if the next input is an integer. If not, an error message is printed to `System.err`, the invalid input is consumed (`scanner.next()`), and the loop continues. This prevents `InputMismatchException` for non-integer input at the point of reading the integer.
 *     *   **Logical Error Handling:** The `completeNextTask()` method explicitly checks if `processingQueue.poll()` returns `null` (meaning the queue was empty) and prints an error to `System.err` in that specific case.
 *     *   **Class-wide Exception Handling:** The entire `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)`. This acts as a catch-all for any unexpected runtime exceptions that might occur within the main application flow, printing an error message and the stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is applied in both `Task` and `TaskManager` classes by making fields private.
 *     *   Method and variable names are descriptive (e.g., `processingQueue`, `completeNextTask`).
 *     *   Comments explain the purpose of classes and methods (Javadocs style) and clarify specific logic points.
 *     *   The code is structured into two logical classes (`Task` and `TaskManager`) with clear responsibilities.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of collections, control flow, input/output, error handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task with the given description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a collection of tasks, separating pending and completed tasks.
 */
public class TaskManager {

    private Queue<Task> processingQueue;
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing task collections and scanner.
     */
    public TaskManager() {
        // Use LinkedList as a concrete implementation for Queue
        processingQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation for List
        completedTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the processing queue.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        processingQueue.offer(newTask); // offer is generally preferred for queues
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Completes the next task in the processing queue.
     * Moves the task from the processing queue to the completed tasks list.
     * Handles the case where the processing queue is empty.
     */
    public void completeNextTask() {
        Task completedTask = processingQueue.poll(); // poll returns null if queue is empty
        if (completedTask != null) {
            completedTasks.add(completedTask);
            System.out.println("Completed task: " + completedTask.getDescription());
        } else {
            System.err.println("Error: No tasks in the queue to complete.");
        }
    }

    /**
     * Lists all tasks currently in the processing queue.
     */
    public void listPendingTasks() {
        System.out.println("Pending Tasks:");
        if (processingQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            int index = 1;
            // Iterate over the queue elements without removing them
            for (Task task : processingQueue) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
    }

    /**
     * Lists all tasks that have been completed.
     */
    public void listCompletedTasks() {
        System.out.println("Completed Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                // Input validation for integer choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for flow control based on choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        completeNextTask();
                        break;
                    case 3:
                        listPendingTasks();
                        break;
                    case 4:
                        listCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;
                    default:
                        // Handles integer choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch-all for unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
