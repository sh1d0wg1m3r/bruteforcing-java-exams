/*
 * Exam Question #788
 * Generated on: 2025-05-12 16:40:50
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Software Development Task Prioritization and Execution System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified system for managing software development tasks. Tasks are added to a queue for processing. Once a task is processed, it is moved to a list of completed tasks. The system should allow users to add new tasks, process the next pending task, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private attributes:
 *     *   `taskId` (an integer, automatically generated and unique)
 *     *   `description` (a String)
 *     *   `priority` (an integer, lower number indicates higher priority - *Note: While a `PriorityQueue` exists, you are required to use a standard `Queue` for pending tasks and manage processing logic based on simple FIFO or user choice, demonstrating basic queue manipulation.* For this problem, a standard `LinkedList` implementing `Queue` will suffice, and the `priority` field will be stored but not used for automatic queue ordering by the `Queue` itself.)
 *     *   `status` (a String, e.g., "Pending", "Completed")
 *     *   Include a constructor, public getter methods for all attributes, and a method to mark the task as completed.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class with the following features:
 *     *   Maintain a `Queue<Task>` to hold tasks that are pending processing. Use a concrete implementation like `java.util.LinkedList`.
 *     *   Maintain a `List<Task>` (specifically, an `ArrayList<Task>`) to hold tasks that have been processed/completed.
 *     *   Implement a method `addTask(String description, int priority)` that creates a new `Task` object with a unique ID and "Pending" status, and adds it to the pending tasks queue.
 *     *   Implement a method `processNextTask()` that removes the task at the front of the pending tasks queue, marks its status as "Completed", and adds it to the completed tasks list. Handle the case where the queue is empty.
 *     *   Implement methods `getPendingTasks()` and `getCompletedTasks()` that return the respective collections. Ensure `getCompletedTasks()` returns a `List<Task>`.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `TaskApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   Display a menu of options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle user input for menu selection.
 *     *   Prompt the user for necessary details (description, priority) when adding a task. Include basic input validation (e.g., priority is a positive integer).
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, task details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, invalid input for task details, attempting to process task when queue is empty).
 *     *   Implement **class-wide exception handling** using a `try-catch` block around the main application loop to catch potential runtime exceptions (e.g., `InputMismatchException` from `Scanner`, exceptions from `TaskManager` if methods throw them for error conditions like empty queue). The catch block should print an informative message to `System.err`.
 * 
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate the usage of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as a type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` block (class-wide)
 * 
 * 6.  **Best Practices:** Apply principles of good object-oriented design:
 *     *   Proper encapsulation (private fields, public getters/setters where appropriate).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Clean code structure and formatting.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Examples of expected output include:
 * 
 * *   Displaying the menu.
 * *   Prompting for task details.
 * *   Confirming task addition.
 * *   Reporting when a task is processed or if the queue is empty.
 * *   Listing pending and completed tasks with their details.
 * *   Displaying error messages to `System.err` for invalid input or operations.
 * *   Exiting cleanly.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of the implementation.
 * *   Adherence to all specified requirements, including the use of mandatory components.
 * *   Quality of object-oriented design, encapsulation, and code structure.
 * *   Effectiveness of input validation and error handling.
 * *   Clarity and readability of the code, including comments.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Software Development Task Prioritization and Execution System as described, utilizing all the required Java components and adhering to best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Task` Class:** Represents a single task with attributes for ID, description, priority, and status. It includes a static counter (`nextId`) to ensure unique task IDs. Getters provide access to the private fields, and `markAsCompleted()` allows updating the status. The `toString()` method provides a convenient string representation for printing. This demonstrates proper encapsulation.
 * 
 * 2.  **`TaskManager` Class:** Acts as the core logic handler.
 *     *   It uses a `Queue<Task>` (`LinkedList` implementation) to manage tasks waiting to be processed in FIFO order.
 *     *   It uses a `List<Task>` (`ArrayList` implementation) to store tasks once they are completed.
 *     *   `addTask()` creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. It includes basic input validation for description and priority, throwing `IllegalArgumentException` on failure.
 *     *   `processNextTask()` removes the head of the `pendingTasks` queue using `poll()`. If `poll()` returns `null` (meaning the queue is empty), it throws an `IllegalStateException`. Otherwise, it marks the task as completed and adds it to the `completedTasks` list.
 *     *   `getPendingTasks()` and `getCompletedTasks()` return `List<Task>` views of the respective collections. Returning a *new* `ArrayList` instance prevents external code from modifying the internal state of the `TaskManager`'s collections directly, upholding encapsulation.
 * 
 * 3.  **`TaskApp` Class:** Contains the `main` method and handles the user interface.
 *     *   It initializes a `TaskManager` and a `Scanner`.
 *     *   The `run()` method contains the main application loop. This loop is wrapped in a `try-catch` block, providing **class-wide exception handling**.
 *     *   Inside the loop, it displays the menu and reads user input using `Scanner`.
 *     *   A `switch` statement is used to direct execution based on the user's menu choice, fulfilling another requirement.
 *     *   Methods like `addTask()`, `processTask()`, `viewPendingTasks()`, and `viewCompletedTasks()` encapsulate the logic for each menu option, interacting with the `TaskManager`.
 *     *   Input validation is handled within `addTask()` (both `InputMismatchException` for non-integer priority and `IllegalArgumentException` from `TaskManager` for invalid values).
 *     *   Error messages for invalid menu choices, input errors, and operational errors (like processing an empty queue) are directed to `System.err`, while normal output goes to `System.out`.
 * 
 * **Required Components Usage:**
 * 
 * *   `java.util.Queue`: Used in `TaskManager` to store `pendingTasks`.
 * *   `java.util.ArrayList`: Used in `TaskManager` to store `completedTasks` and returned by `getPendingTasks`/`getCompletedTasks` as a concrete `List`.
 * *   `java.util.List`: Used as the return type for `getCompletedTasks()` and `getPendingTasks()`, demonstrating polymorphism and adherence to the interface requirement.
 * *   `java.util.Scanner`: Used in `TaskApp` to read user input from the console.
 * *   `switch` statement: Used in `TaskApp.run()` for menu navigation.
 * *   `System.err`: Used in `TaskApp` to print error messages.
 * *   `System.out`: Used throughout `TaskApp` and `TaskManager` for normal output and prompts.
 * *   `try-catch` block: A large `try-catch` block wraps the `while(running)` loop in `TaskApp.run()`, providing class-wide handling for unexpected runtime exceptions. Smaller `try-catch` blocks are used in `addTask()` and `processTask()` for more specific error handling related to user input or `TaskManager` operations.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Private fields in `Task` and `TaskManager`, accessed/modified via public methods.
 * *   **Meaningful Names:** Classes, variables, and methods have names reflecting their purpose (`Task`, `TaskManager`, `pendingTasks`, `addTask`, `processNextTask`, etc.).
 * *   **Comments/Documentation:** Javadoc-style comments are included for classes and key methods, explaining their purpose and parameters.
 * *   **Input Validation:** Basic validation is performed for task description and priority in `addTask()`. `InputMismatchException` is handled for non-integer input.
 * *   **Error Handling:** Specific exceptions (`IllegalArgumentException`, `IllegalStateException`, `InputMismatchException`) are caught and handled with informative messages printed to `System.err`. The class-wide `try-catch` provides a fallback for unexpected errors.
 * *   **Clean Code:** The code is structured into logical classes, methods are focused on single responsibilities, and indentation/formatting are consistent. The `finally` block ensures resources like the `Scanner` are closed.
 * 
 * This solution effectively combines various core and advanced Java concepts to build a functional, well-structured, and robust application that meets all specified requirements.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a software development task.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // Lower number = higher priority (not used for queue order in this implementation)
    private String status;

    private static int nextId = 1; // Static counter for unique task IDs

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority level of the task.
     */
    public Task(String description, int priority) {
        this.taskId = nextId++;
        this.description = description;
        this.priority = priority;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Pri=" + priority + ", Status=" + status + "]";
    }
}

/**
 * Manages a collection of tasks, separating pending and completed tasks.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager with empty task lists.
     */
    public TaskManager() {
        // Using LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending tasks queue.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public void addTask(String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
            // Basic validation
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority <= 0) {
             // Basic validation
            throw new IllegalArgumentException("Task priority must be a positive integer.");
        }

        Task newTask = new Task(description.trim(), priority);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes it from pending, marks it as completed, and adds it to completed list.
     *
     * @throws IllegalStateException if the pending tasks queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue

        if (taskToProcess == null) {
            throw new IllegalStateException("No tasks pending to process.");
        }

        taskToProcess.markAsCompleted();
        completedTasks.add(taskToProcess);
        System.out.println("Task processed: " + taskToProcess);
    }

    /**
     * Returns an immutable view of the pending tasks queue.
     *
     * @return A List containing the pending tasks (order reflects queue order).
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns an immutable view of the completed tasks list.
     *
     * @return A List containing the completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a new ArrayList to prevent external modification of the internal list
        // Returning as List<Task> as required
        return new ArrayList<>(completedTasks);
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and orchestrates TaskManager operations.
 */
public class TaskApp {

    private TaskManager taskManager;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs the TaskApp.
     */
    public TaskApp() {
        this.taskManager = new TaskManager();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop. Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide exception handling around the main loop
        try {
            while (running) {
                displayMenu();
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (InputMismatchException e) {
             // Catch non-integer input for menu choice
            System.err.println("Error: Invalid input. Please enter a number.");
            // Consume the invalid input to prevent infinite loop
            scanner.nextLine();
            // Optionally, continue the loop or exit depending on desired behavior
            // For this exam, we'll just print error and continue
            run(); // Restart the loop (can be simplified by managing 'running' flag differently)
        } catch (Exception e) {
             // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Handles the process of adding a new task based on user input.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        int priority = -1;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter task priority (positive integer, lower = higher): ");
            try {
                priority = scanner.nextInt();
                scanner.nextLine(); // Consume newline
                taskManager.addTask(description, priority); // Validate and add via TaskManager
                validPriority = true; // If addTask succeeds, priority was valid
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a positive integer for priority.");
                scanner.nextLine(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                // Catch validation errors from TaskManager
                System.err.println("Error adding task: " + e.getMessage());
                validPriority = true; // Exit loop as task couldn't be added with this input
            }
        }
    }

    /**
     * Handles the process of processing the next pending task.
     */
    private void processTask() {
        try {
            taskManager.processNextTask();
        } catch (IllegalStateException e) {
            // Catch specific error from TaskManager when queue is empty
            System.err.println("Error processing task: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
        }
    }

    /**
     * Displays all pending tasks.
     */
    private void viewPendingTasks() {
        List<Task> pending = taskManager.getPendingTasks();
        if (pending.isEmpty()) {
            System.out.println("No tasks are pending.");
        } else {
            System.out.println("\n--- Pending Tasks ---");
            for (Task task : pending) {
                System.out.println(task);
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all completed tasks.
     */
    private void viewCompletedTasks() {
        List<Task> completed = taskManager.getCompletedTasks();
        if (completed.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("\n--- Completed Tasks ---");
            for (Task task : completed) {
                System.out.println(task);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskApp app = new TaskApp();
        app.run();
    }
}
