/*
 * Exam Question #529
 * Generated on: 2025-05-11 23:25:08
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting to be done, view tasks that have been completed, and complete the next task in line. Tasks should be processed in a First-In, First-Out (FIFO) manner for completion.
 * 
 * Your solution must be written in Java and adhere to the requirements and best practices listed below.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are pending/waiting to be completed. The system should process tasks from the head of the queue.
 *     *   Use a `java.util.List` (instantiated as `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Create a `Task` class to represent individual tasks. It should have attributes like a unique ID, description, and priority.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with options for:
 *         *   Add New Task
 *         *   View Pending Tasks
 *         *   View Completed Tasks
 *         *   Complete Next Task
 *         *   Exit
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and successful operation messages.
 *     *   Use `System.err` for displaying error messages, warnings (e.g., attempting to complete a task when none are pending), and unexpected exceptions.
 * 
 * 5.  **Error Handling:**
 *     *   Implement exception handling using `try-catch` blocks.
 *     *   Include a class-wide `try-catch` block (or one covering the main operational loop) to catch unexpected exceptions.
 *     *   Handle potential input errors (e.g., non-integer input for menu choice).
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc comments).
 *     *   Implement basic input validation (e.g., checking for valid integer input for choices, non-empty description).
 *     *   Ensure resources like `Scanner` are closed properly.
 *     *   Structure your code cleanly with separate classes where appropriate (`Task` and the main management class).
 * 
 * **Task Details:**
 * 
 * *   **Task Class:** Should have `private` fields: `id` (int), `description` (String), `priority` (String). Provide a constructor and public getter methods. Override `toString()` for easy printing.
 * *   **Task Management Logic:** Your main class should manage the `Queue` of pending tasks and the `List` of completed tasks. It should contain methods for adding, completing, and viewing tasks. Generate unique task IDs starting from 1.
 * *   **Complete Next Task:** When the user chooses to complete the next task, take the task from the *front* of the pending queue (`Queue.poll()`) and add it to the completed list. If the queue is empty, display an error message using `System.err`.
 * *   **Viewing Tasks:** When viewing pending or completed tasks, iterate through the respective collection and print the details of each task using its `toString()` method. If a collection is empty, print a message indicating that.
 * 
 * **Expected Output Structure (Example Interaction):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Enter task priority (e.g., High, Medium, Low): High
 * Task added successfully.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Create solution code
 * Enter task priority (e.g., High, Medium, Low): High
 * Task added successfully.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Description: Write exam question, Priority: High
 * Task ID: 2, Description: Create solution code, Priority: High
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 4
 * 
 * Attempting to complete the next task...
 * Successfully completed the next task.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * Task ID: 2, Description: Create solution code, Priority: High
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 3
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Description: Write exam question, Priority: High
 * ---------------------
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 4
 * 
 * Attempting to complete the next task...
 * Successfully completed the next task.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 4
 * 
 * Attempting to complete the next task...
 * No pending tasks available to complete. // Using System.err
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. // Using System.err
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Complete Next Task
 * 5. Exit
 * ----------------------------
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Task Management System, designed to demonstrate advanced Java concepts as required by the exam task.
 * 
 * **Core Concepts Demonstrated:**
 * 
 * 1.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `java.util.Queue` (`pendingTasks`) is used to store tasks waiting to be completed. The `LinkedList` class is chosen as a concrete implementation because it efficiently supports the head-oriented operations required by the `Queue` interface (like `offer()` for adding to the tail and `poll()` for removing from the head), naturally implementing the FIFO (First-In, First-Out) processing order for tasks.
 *     *   A `java.util.List` (`completedTasks`) is used to store tasks once they are finished. The `ArrayList` class is chosen as a concrete implementation, providing dynamic array capabilities suitable for storing completed tasks in order of completion or simply as a growing collection. Declaring it as `List` rather than `ArrayList` demonstrates coding to the interface.
 * 
 * 2.  **Object-Orientated Programming (`Task` class, Encapsulation):**
 *     *   A separate `Task` class encapsulates the data related to a single task (ID, description, priority).
 *     *   Fields are declared `private`, and public getter methods (`getId`, `getDescription`, `getPriority`) are provided, adhering to the principle of encapsulation.
 *     *   The `toString()` method is overridden in the `Task` class to provide a convenient string representation for displaying task details.
 * 
 * 3.  **User Interaction (`Scanner`, `System.out`, `System.err`):**
 *     *   `java.util.Scanner` is used to read input from `System.in`, allowing the user to interact with the menu.
 *     *   `System.out.println()` and `System.out.print()` are used for standard output, such as displaying the menu, prompts, and task listings.
 *     *   `System.err.println()` is used specifically for error messages, warnings (like trying to complete a task when none are pending), and messages related to invalid input, distinguishing them from normal program output.
 * 
 * 4.  **Control Flow (`switch`, `while` loop):**
 *     *   A `while(true)` loop maintains the main program execution flow, allowing the user to repeatedly select menu options until they choose to exit.
 *     *   A `switch` statement is used inside the loop to direct execution based on the integer choice entered by the user, providing a clear and structured way to handle multiple distinct commands.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A comprehensive `try-catch` block wraps the main `while` loop in the `run()` method. This serves as a class-wide handler for any unexpected exceptions that might occur during the program's execution, printing the error details to `System.err` and ensuring a more graceful (though terminating) exit than crashing.
 *     *   An inner `try-catch` block is used specifically around the `scanner.nextInt()` call to handle potential `InputMismatchException` or other issues that might arise when reading the user's menu choice, preventing the program from crashing on invalid input and allowing the loop to continue after informing the user via `System.err`.
 *     *   The `finally` block ensures that the `Scanner` resource is closed properly when the `run()` method exits, whether normally or due to an exception, preventing resource leaks.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names (`pendingTasks`, `completeNextTask`, `nextTaskId`, etc.) enhance code readability.
 *     *   Comments and Javadoc documentation explain the purpose of classes, methods, and key code sections.
 *     *   Basic input validation (`hasNextInt()`, checking for empty description) improves the robustness of the application.
 *     *   The code is structured into logical units (`Task` class, methods in `TaskManager`) for better organization.
 * 
 * **Solution Approach:**
 * 
 * The `TaskManager` class orchestrates the system. It holds the `pendingTasks` queue and `completedTasks` list. The `run()` method contains the main application loop. Inside the loop, it displays a menu, prompts for user input using `Scanner`, and uses a `switch` statement to process the chosen option.
 * 
 * *   Adding a task involves creating a `Task` object with a unique ID (managed by `nextTaskId`) and adding it to the `pendingTasks` queue using `offer()`.
 * *   Viewing tasks involves iterating through the `pendingTasks` queue (by first copying it to a temporary `ArrayList` to avoid modifying the queue during iteration) or the `completedTasks` list and printing each `Task`'s `toString()` representation.
 * *   Completing a task involves calling `pendingTasks.poll()`, which removes the next task from the queue. If `poll()` returns a task (i.e., the queue was not empty), the task is added to the `completedTasks` list. If `poll()` returns `null`, it indicates the queue was empty, and an error message is printed to `System.err`.
 * *   Input validation for the menu choice ensures that the program handles non-integer input gracefully using `hasNextInt()` and `System.err`. A broader `try-catch` handles other potential runtime issues.
 * 
 * This structure effectively utilizes the required Java components to build a functional, albeit simple, task management system while demonstrating good programming practices and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Import for specific exception handling

/**
 * Represents a single task with an ID, description, and priority.
 * Demonstrates encapsulation.
 */
class Task {
    private int id;
    private String description;
    private String priority;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task (e.g., High, Medium, Low).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task for display.
     * @return A formatted string showing task details.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Priority: %s",
                             id, description, priority);
    }
}

/**
 * Manages a collection of tasks using a Queue for pending tasks (FIFO)
 * and a List for completed tasks. Provides a console-based interface.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch,
 * System.out, System.err, and try-catch for exception handling.
 */
public class TaskManager {

    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;

    // List for tasks that have been completed
    private List<Task> completedTasks;

    private int nextTaskId; // Counter to generate unique IDs for new tasks

    /**
     * Constructs a new TaskManager.
     * Initializes the pending and completed task collections and the task ID counter.
     */
    public TaskManager() {
        // LinkedList is a common implementation of Queue that supports FIFO
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List for dynamic arrays
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Task IDs start from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     * A unique ID is generated for the task.
     * Basic validation ensures description is not empty.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String description, String priority) {
        // Basic validation for description
        if (description == null || description.trim().isEmpty()) {
            // Using System.err for validation failure message
            System.err.println("Task description cannot be empty. Task not added.");
            return; // Exit method if validation fails
        }

        // Use a default priority if none is provided or it's empty
        String taskPriority = (priority == null || priority.trim().isEmpty()) ? "Medium" : priority.trim();

        // Create the new Task object
        Task newTask = new Task(nextTaskId++, description.trim(), taskPriority);
        // Add the new task to the tail of the pending tasks queue
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
    }

    /**
     * Completes the next task available in the pending queue (FIFO).
     * Retrieves and removes the task from the head of the queue and adds it
     * to the list of completed tasks.
     * @return true if a task was successfully completed, false if the pending queue was empty.
     */
    public boolean completeNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task taskToComplete = pendingTasks.poll();
        if (taskToComplete != null) {
            completedTasks.add(taskToComplete); // Add the completed task to the list
            return true; // Indicate success
        }
        return false; // Indicate failure (queue was empty)
    }

    /**
     * Returns a reference to the pending tasks queue.
     * Used for viewing the current state of pending tasks.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        // Returning the reference allows iteration for display purposes.
        // In a more complex system, one might return a copy or unmodifiable view.
        return pendingTasks;
    }

    /**
     * Returns a reference to the completed tasks list.
     * Used for viewing the current state of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
         // Returning the reference allows iteration for display purposes.
        return completedTasks;
    }

    /**
     * Displays the main menu options to the user on System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Complete Next Task");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Runs the main interactive loop for the Task Management System.
     * Handles user input using Scanner, processes choices using a switch statement,
     * and manages exceptions with try-catch blocks, directing output to
     * System.out and errors to System.err.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);

        // Outer try-catch block for handling any unexpected exceptions during the main execution flow
        try {
            while (true) { // Main loop for the menu
                displayMenu(); // Show menu options
                System.out.print("Enter your choice: "); // Prompt user for input

                int choice = -1; // Variable to store user's menu choice

                // Inner try-catch block specifically for handling potential errors during integer input reading
                try {
                    // Check if the next input token is an integer
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt(); // Read the integer choice
                    } else {
                        // If not an integer, print an error message to System.err
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input token to prevent infinite loop
                        continue; // Skip the rest of this loop iteration and show the menu again
                    }
                } catch (InputMismatchException e) {
                     // This catch handles cases where nextInt() receives non-integer input.
                     // The hasNextInt() check above makes this specific catch less critical
                     // but it's good practice for robustness or different input patterns.
                     System.err.println("Input mismatch error: Please enter a valid integer choice.");
                     scanner.next(); // Consume the invalid input
                     continue; // Skip to the next iteration
                } catch (Exception e) {
                    // Catch any other unexpected error during the input reading process
                    System.err.println("An error occurred while reading input: " + e.getMessage());
                    // e.printStackTrace(System.err); // Uncomment for detailed debugging output
                    scanner.next(); // Attempt to consume the problematic input
                    continue; // Skip to the next iteration
                }

                // Consume the rest of the line after reading the integer choice
                // This is necessary because nextInt() only reads the integer, not the newline
                scanner.nextLine();

                // Use a switch statement to perform actions based on the user's valid integer choice
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (e.g., High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        // addTask handles validation and prints error if description is empty
                        addTask(description, priority);
                        // Print success message only if description was valid (addTask didn't print error)
                        if (!(description == null || description.trim().isEmpty())) {
                             System.out.println("Task added successfully.");
                        }
                        break;

                    case 2: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        // Get the current queue of pending tasks
                        Queue<Task> currentPending = getPendingTasks();
                        if (currentPending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate through the queue elements for display.
                            // Creating a temporary list is a safe way to iterate without
                            // removing elements from the queue itself.
                            List<Task> pendingListForDisplay = new ArrayList<>(currentPending);
                            for (Task task : pendingListForDisplay) {
                                System.out.println(task); // Task's toString() is called implicitly
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 3: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        // Get the current list of completed tasks
                        List<Task> currentCompleted = getCompletedTasks();
                        if (currentCompleted.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            // Iterate through the list of completed tasks
                            for (Task task : currentCompleted) {
                                System.out.println(task); // Task's toString() is called implicitly
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 4: // Complete Next Task
                        System.out.println("\nAttempting to complete the next task...");
                        // Call method to complete the next task from the queue
                        if (completeNextTask()) {
                            System.out.println("Successfully completed the next task.");
                        } else {
                            // If completeNextTask returns false, the queue was empty.
                            // Use System.err for this operational warning.
                            System.err.println("No pending tasks available to complete.");
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        return; // Exit the run method, which ends the program

                    default: // Handle integer choices that are not between 1 and 5
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // This catch block handles any unexpected exceptions that occur within the main loop
            // that were not caught by the more specific inner try-catch or handled internally.
            // Use System.err for critical, unexpected system errors.
            System.err.println("An unexpected system error occurred. The application will terminate.");
            e.printStackTrace(System.err); // Print the full stack trace to the error stream for debugging
        } finally {
            // The finally block ensures that the scanner resource is closed
            // regardless of whether the loop exits normally or an exception occurs.
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Management System application.
     * Creates a TaskManager instance and calls its run method.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
