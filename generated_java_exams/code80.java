/*
 * Exam Question #80
 * Generated on: 2025-05-11 22:10:02
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Airport Baggage Handling System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified simulation of an airport baggage handling system. The system will manage baggage items as they move from check-in to sorting.
 * 
 * Checked-in bags are initially placed into a waiting area, which operates like a queue (First-In, First-Out). A sorting process then takes the next bag from the waiting queue, assigns it to a destination gate, and moves it to a sorted area. The system should allow users to check in new bags, process bags from the queue, view bags in both areas, and find a specific bag by its ID.
 * 
 * Your solution must be written in Java and adhere to the following requirements:
 * 
 * 1.  **Class Structure:**
 *     *   Create a `Baggage` class to represent a single piece of luggage. It should store at least: a unique `String bagId`, a `String passengerName`, a `String destinationGate` (initially "Not Assigned"), and a `String status` (initially "Waiting"). Implement appropriate constructors, getters, and a `toString()` method.
 *     *   Create a `BaggageHandlingSystem` class to manage the collection of bags. This class must contain:
 *         *   A `java.util.Queue<Baggage>` to store bags waiting for processing.
 *         *   A `java.util.List<Baggage>` (specifically implemented using `java.util.ArrayList`) to store bags that have been processed and sorted.
 *     *   Create a main application class (e.g., `AirportBaggageApp`) containing the `main` method to handle user interaction and application flow.
 * 
 * 2.  **Functionality (Menu-Driven):** The main application class must present a menu to the user via the console using `java.util.Scanner` and process their choice using a `switch` statement. The menu options should be:
 *     *   **1. Check In New Bag:** Prompt for Bag ID and Passenger Name. Create a `Baggage` object and add it to the waiting queue. Ensure the Bag ID is not already in the system (either queue or sorted list).
 *     *   **2. Sort Next Bag from Queue:** Remove the next bag from the waiting queue. Prompt for a Destination Gate. Update the bag's `destinationGate` and set its `status` to "Sorted". Add the bag to the sorted bags list. Handle the case where the waiting queue is empty.
 *     *   **3. View Waiting Bags:** Display all bags currently in the waiting queue in order.
 *     *   **4. View Sorted Bags:** Display all bags currently in the sorted bags list.
 *     *   **5. Find Bag by ID:** Prompt for a Bag ID and search for it in both the waiting queue and the sorted bags list. Display the bag's details if found.
 *     *   **6. Exit:** Terminate the program.
 * 
 * 3.  **Java Components Usage:** You must explicitly use and demonstrate understanding of all the following components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as the declared type for the sorted bags collection)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for menu, prompts, and normal output)
 *     *   Class-wide exception handling using `try-catch` blocks (especially around user input parsing and operations that might fail).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation using `private` fields and `public` methods (getters, setters where appropriate).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for methods).
 *     *   Implement input validation (e.g., check for empty strings, handle non-integer input for menu choice).
 *     *   Provide clear error messages using `System.err` when operations fail (e.g., invalid input, bag not found, queue empty).
 *     *   Ensure the code has a clean and logical structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu, handle user input robustly, perform the requested operations, and display results or error messages appropriately. Error messages should be directed to `System.err`. Normal output (menu, prompts, bag details, success messages) should go to `System.out`. The program should continue to display the menu until the user chooses to exit.
 * 
 * Example Interaction Flow (similar to the problem description's example):
 * 
 * ```
 * --- Airport Baggage Handling System ---
 * Menu:
 * 1. Check In New Bag
 * 2. Sort Next Bag from Queue
 * 3. View Waiting Bags
 * 4. View Sorted Bags
 * 5. Find Bag by ID
 * 6. Exit
 * Enter your choice: 1
 * --- Check In Bag ---
 * Enter Bag ID: BAG123
 * Enter Passenger Name: John Doe
 * Bag BAG123 checked in and added to waiting queue.
 * 
 * Menu:
 * ...
 * Enter your choice: 2
 * --- Sort Next Bag ---
 * Enter Destination Gate for the bag: G22
 * Bag BAG123 processed, assigned to gate G22, and moved to sorted bags.
 * 
 * Menu:
 * ...
 * Enter your choice: 3
 * --- Waiting Bags ---
 * No bags in the waiting queue.
 * 
 * Menu:
 * ...
 * Enter your choice: 4
 * --- Sorted Bags ---
 * 1. Baggage [ID=BAG123, Passenger=John Doe, Gate=G22, Status=Sorted]
 * 
 * Menu:
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a valid integer for the menu choice.
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * --- Find Bag ---
 * Enter Bag ID to search: BAG123
 * Bag found: Baggage [ID=BAG123, Passenger=John Doe, Gate=G22, Status=Sorted]
 * 
 * Menu:
 * ...
 * Enter your choice: 5
 * --- Find Bag ---
 * Enter Bag ID to search: UNKNOWNBAG
 * Bag with ID UNKNOWNBAG not found in the system.
 * 
 * Menu:
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simplified Airport Baggage Handling System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Baggage`: A simple Plain Old Java Object (POJO) representing a bag with essential attributes (`bagId`, `passengerName`, `destinationGate`, `status`). It includes a constructor with basic input validation and standard getters. A `toString()` method provides a convenient way to print bag details. Fields are `private` for encapsulation.
 *     *   `BaggageHandlingSystem`: This class acts as the core logic handler. It holds the two main data structures:
 *         *   `waitingQueue`: Declared as `Queue<Baggage>` and instantiated as `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing FIFO behavior suitable for a waiting line. Bags are added using `offer()` and removed using `poll()`.
 *         *   `sortedBags`: Declared as `List<Baggage>` and instantiated as `new ArrayList<>()`. `ArrayList` implements the `List` interface, providing a dynamic array that is efficient for storing, iterating, and searching through the processed bags.
 *     *   `AirportBaggageApp`: This class contains the `main` method and handles all user interaction. It creates an instance of `BaggageHandlingSystem` and uses a `Scanner` to read input.
 * 
 * 2.  **Functionality and Control Flow:**
 *     *   The `main` method in `AirportBaggageApp` runs a loop that repeatedly displays a menu (`printMenu()`) and prompts the user for input.
 *     *   `java.util.Scanner` is used to read the user's input from the console (`System.in`). `scanner.nextLine()` is used to read the entire line, which is generally safer than `nextInt()` when mixing integer and line inputs.
 *     *   `Integer.parseInt()` attempts to convert the input string into an integer menu choice.
 *     *   A `switch` statement is used to direct the program flow based on the integer `choice`. Each case calls a corresponding private helper method (`checkInBag`, `sortNextBag`, etc.) that interacts with the `BaggageHandlingSystem`.
 *     *   A `default` case in the `switch` handles invalid menu numbers.
 * 
 * 3.  **Required Java Components:**
 *     *   `Queue`: Used for `waitingQueue` to manage bags in a FIFO manner.
 *     *   `ArrayList`: Used to implement the `sortedBags` `List`.
 *     *   `List`: `sortedBags` is declared using the `List` interface, demonstrating programming to the interface. Methods like `getWaitingBags()` and `getSortedBags()` also return `List`, further emphasizing interface usage.
 *     *   `Scanner`: Used in `AirportBaggageApp` to read user input.
 *     *   `switch`: Used in the `main` method to handle menu selections.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input, queue empty, bag not found, and exceptions caught.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and the details of bags when viewing lists or finding a bag.
 *     *   `try-catch`: A primary `try-catch` block wraps the core menu loop in `main` to handle potential exceptions during input reading (`NumberFormatException`) or exceptions thrown by the system logic (`IllegalArgumentException`, and a general `Exception` for robustness). Specific methods like `checkInBag`, `sortNextBag`, and `findBag` also have their own `try-catch` blocks to handle `IllegalArgumentException` thrown by the `Baggage` constructor or `BaggageHandlingSystem` methods due to invalid data (like empty strings). This demonstrates class-wide handling in the sense that the main application class handles exceptions originating from other parts of the system.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Baggage` and `BaggageHandlingSystem` are `private`, accessed only through public methods.
 *     *   **Meaningful Names:** Classes (`Baggage`, `BaggageHandlingSystem`, `AirportBaggageApp`), fields (`waitingQueue`, `sortedBags`, `bagId`), and methods (`addBagToWaitingQueue`, `processNextBag`, `findBagById`, `printMenu`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes, constructors, and public methods. Inline comments clarify specific code logic.
 *     *   **Input Validation:** The `Baggage` constructor and relevant `BaggageHandlingSystem` methods check for null or empty strings. The `main` method handles `NumberFormatException` for menu input.
 *     *   **Error Handling:** Errors are explicitly checked (e.g., queue size before processing, bag existence before adding) and reported using `System.err`. Exceptions are caught using `try-catch`.
 *     *   **Clean Structure:** The code is divided into logical classes, each responsible for a specific part of the system. The `AirportBaggageApp` class focuses on the UI, delegating business logic to `BaggageHandlingSystem`. Helper methods like `printMenu`, `checkInBag`, etc., keep the `main` method clean.
 * 
 * This solution effectively integrates the required Java components into a practical scenario, demonstrating advanced concepts like interface usage (`List`), collection types (`Queue`, `ArrayList`), robust input handling, and structured error management using `try-catch` and distinct output streams (`System.out`, `System.err`).
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // Used for safe iteration/search if needed, but not strictly required for simple search.

/**
 * Represents a single piece of baggage in the system.
 */
class Baggage {
    private String bagId;
    private String passengerName;
    private String destinationGate; // Assigned after sorting
    private String status; // e.g., "Waiting", "Sorted"

    /**
     * Constructs a new Baggage object.
     *
     * @param bagId The unique ID of the bag.
     * @param passengerName The name of the passenger.
     * @throws IllegalArgumentException if bagId or passengerName are null or empty.
     */
    public Baggage(String bagId, String passengerName) {
        if (bagId == null || bagId.trim().isEmpty()) {
            throw new IllegalArgumentException("Bag ID cannot be empty.");
        }
        if (passengerName == null || passengerName.trim().isEmpty()) {
             throw new IllegalArgumentException("Passenger Name cannot be empty.");
        }
        this.bagId = bagId.trim();
        this.passengerName = passengerName.trim();
        this.status = "Waiting"; // Initial status
        this.destinationGate = "Not Assigned"; // Initial state
    }

    // --- Getters ---
    public String getBagId() {
        return bagId;
    }

    public String getPassengerName() {
        return passengerName;
    }

    public String getDestinationGate() {
        return destinationGate;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (Used internally by the system) ---
    public void setDestinationGate(String destinationGate) {
        if (destinationGate == null || destinationGate.trim().isEmpty()) {
             throw new IllegalArgumentException("Destination gate cannot be empty.");
        }
        this.destinationGate = destinationGate.trim();
    }

    public void setStatus(String status) {
         if (status == null || status.trim().isEmpty()) {
             throw new IllegalArgumentException("Status cannot be empty.");
         }
        this.status = status.trim();
    }

    /**
     * Returns a string representation of the Baggage object.
     */
    @Override
    public String toString() {
        return "Baggage [ID=" + bagId + ", Passenger=" + passengerName + ", Gate=" + destinationGate + ", Status=" + status + "]";
    }
}

/**
 * Manages the baggage handling process using a queue and a list.
 */
class BaggageHandlingSystem {
    // Queue for bags waiting to be processed/sorted (FIFO)
    private Queue<Baggage> waitingQueue;

    // List for bags that have been sorted and are ready for loading (Allows easy iteration/search)
    private List<Baggage> sortedBags;

    /**
     * Constructs a new BaggageHandlingSystem.
     */
    public BaggageHandlingSystem() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.sortedBags = new ArrayList<>();   // ArrayList implements List
    }

    /**
     * Adds a new bag to the waiting queue.
     * Checks for duplicate bag IDs before adding.
     *
     * @param bag The Baggage object to add.
     * @return true if the bag was added successfully, false otherwise (e.g., duplicate ID).
     */
    public boolean addBagToWaitingQueue(Baggage bag) {
        if (bag == null) {
            System.err.println("Error: Cannot add a null bag.");
            return false;
        }
        // Check if bag ID already exists in either queue or sorted list
        if (findBagById(bag.getBagId()) != null) {
            System.err.println("Error: Bag with ID '" + bag.getBagId() + "' already exists in the system.");
            return false;
        }
        waitingQueue.offer(bag); // Use offer() which is generally preferred over add() for queues
        System.out.println("Bag '" + bag.getBagId() + "' checked in and added to waiting queue.");
        return true;
    }

    /**
     * Processes the next bag from the waiting queue, assigns it a gate,
     * and moves it to the sorted list.
     *
     * @param destinationGate The destination gate to assign.
     * @return The processed Baggage object, or null if the queue was empty or gate is invalid.
     * @throws IllegalArgumentException if destinationGate is null or empty.
     */
    public Baggage processNextBag(String destinationGate) {
        if (destinationGate == null || destinationGate.trim().isEmpty()) {
             throw new IllegalArgumentException("Destination gate cannot be empty for processing.");
        }

        Baggage nextBag = waitingQueue.poll(); // Remove and return the head of the queue
        if (nextBag != null) {
            nextBag.setDestinationGate(destinationGate.trim());
            nextBag.setStatus("Sorted");
            sortedBags.add(nextBag);
            System.out.println("Bag '" + nextBag.getBagId() + "' processed, assigned to gate '" + destinationGate.trim() + "', and moved to sorted bags.");
            return nextBag;
        } else {
            System.err.println("Error: Waiting queue is empty. No bags to process.");
            return null;
        }
    }

    /**
     * Gets a list of bags currently in the waiting queue.
     * Returns a new ArrayList containing the elements to prevent external modification of the queue.
     *
     * @return A List containing the bags in the waiting queue.
     */
    public List<Baggage> getWaitingBags() {
        return new ArrayList<>(waitingQueue); // Return as ArrayList copy
    }

    /**
     * Gets a list of bags currently in the sorted bags list.
     * Returns a new ArrayList containing the elements to prevent external modification of the list.
     *
     * @return A List containing the sorted bags.
     */
    public List<Baggage> getSortedBags() {
        return new ArrayList<>(sortedBags); // Return as ArrayList copy
    }

    /**
     * Finds a bag by its ID in either the waiting queue or the sorted list.
     *
     * @param bagId The ID of the bag to find.
     * @return The Baggage object if found, otherwise null.
     * @throws IllegalArgumentException if bagId is null or empty.
     */
    public Baggage findBagById(String bagId) {
        if (bagId == null || bagId.trim().isEmpty()) {
            throw new IllegalArgumentException("Bag ID cannot be empty for search.");
        }
        String searchId = bagId.trim();

        // Search in waiting queue
        for (Baggage bag : waitingQueue) {
            if (bag.getBagId().equals(searchId)) {
                return bag;
            }
        }

        // Search in sorted bags list
        for (Baggage bag : sortedBags) {
            if (bag.getBagId().equals(searchId)) {
                return bag;
            }
        }

        return null; // Not found
    }

    /**
     * Gets the current number of bags in the waiting queue.
     * @return The size of the waiting queue.
     */
    public int getWaitingQueueSize() {
        return waitingQueue.size();
    }

     /**
     * Gets the current number of bags in the sorted bags list.
     * @return The size of the sorted bags list.
     */
    public int getSortedBagsSize() {
        return sortedBags.size();
    }
}


/**
 * Main application class for the Airport Baggage Handling System.
 * Handles user interaction via a menu.
 */
public class AirportBaggageApp {

    // Static instances for the system and scanner, accessible by static methods
    private static BaggageHandlingSystem system = new BaggageHandlingSystem();
    private static Scanner scanner = new Scanner(System.in);

    /**
     * Main method - the entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("--- Airport Baggage Handling System ---");

        int choice = -1;
        // Loop until the user chooses to exit (choice 6)
        while (choice != 6) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                // Read the entire line to avoid issues with nextInt() followed by nextLine()
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine); // Attempt to parse the input as an integer

                // Use a switch statement to handle menu options
                switch (choice) {
                    case 1:
                        checkInBag();
                        break;
                    case 2:
                        sortNextBag();
                        break;
                    case 3:
                        viewWaitingBags();
                        break;
                    case 4:
                        viewSortedBags();
                        break;
                    case 5:
                        findBag();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (NumberFormatException e) {
                // Catch exception if user enters non-integer input
                System.err.println("Invalid input. Please enter a valid integer for the menu choice.");
            } catch (IllegalArgumentException e) {
                 // Catch exceptions thrown by Baggage or BaggageHandlingSystem methods due to invalid data
                 System.err.println("Operation failed due to invalid data: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: uncomment for detailed debugging
            }
            System.out.println(); // Add a blank line for readability between menu interactions
        }

        scanner.close(); // Close the scanner resource when the application exits
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Check In New Bag");
        System.out.println("2. Sort Next Bag from Queue");
        System.out.println("3. View Waiting Bags");
        System.out.println("4. View Sorted Bags");
        System.out.println("5. Find Bag by ID");
        System.out.println("6. Exit");
    }

    /**
     * Handles the "Check In New Bag" menu option.
     * Prompts for bag details and adds the bag to the system.
     */
    private static void checkInBag() {
        System.out.println("\n--- Check In Bag ---");
        System.out.print("Enter Bag ID: ");
        String bagId = scanner.nextLine();
        System.out.print("Enter Passenger Name: ");
        String passengerName = scanner.nextLine();

        try {
            // Create Baggage object, which validates input
            Baggage newBag = new Baggage(bagId, passengerName);
            // Add bag to the system, which checks for duplicates and adds to queue
            system.addBagToWaitingQueue(newBag);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Baggage constructor
            System.err.println("Error creating bag: " + e.getMessage());
        }
    }

    /**
     * Handles the "Sort Next Bag from Queue" menu option.
     * Processes a bag from the waiting queue.
     */
    private static void sortNextBag() {
        System.out.println("\n--- Sort Next Bag ---");
        // Check if there are bags to process before prompting for gate
        if (system.getWaitingQueueSize() == 0) {
            System.err.println("Waiting queue is empty. Cannot sort.");
            return;
        }

        System.out.print("Enter Destination Gate for the bag: ");
        String destinationGate = scanner.nextLine();

        try {
            // Process the bag, which validates the gate and moves the bag
            system.processNextBag(destinationGate);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from processNextBag
            System.err.println("Error processing bag: " + e.getMessage());
        }
    }

    /**
     * Handles the "View Waiting Bags" menu option.
     * Displays all bags currently in the waiting queue.
     */
    private static void viewWaitingBags() {
        System.out.println("\n--- Waiting Bags ---");
        List<Baggage> waitingBags = system.getWaitingBags(); // Get a copy of the waiting bags

        if (waitingBags.isEmpty()) {
            System.out.println("No bags in the waiting queue.");
        } else {
            System.out.println("Bags in waiting queue (" + waitingBags.size() + "):");
            // Iterate and print each bag
            for (int i = 0; i < waitingBags.size(); i++) {
                System.out.println((i + 1) + ". " + waitingBags.get(i));
            }
        }
    }

    /**
     * Handles the "View Sorted Bags" menu option.
     * Displays all bags currently in the sorted list.
     */
    private static void viewSortedBags() {
        System.out.println("\n--- Sorted Bags ---");
        List<Baggage> sortedBags = system.getSortedBags(); // Get a copy of the sorted bags

         if (sortedBags.isEmpty()) {
            System.out.println("No bags in the sorted list.");
        } else {
            System.out.println("Sorted bags (" + sortedBags.size() + "):");
             // Iterate and print each bag
            for (int i = 0; i < sortedBags.size(); i++) {
                System.out.println((i + 1) + ". " + sortedBags.get(i));
            }
        }
    }

    /**
     * Handles the "Find Bag by ID" menu option.
     * Prompts for a bag ID and searches for the bag in the system.
     */
    private static void findBag() {
        System.out.println("\n--- Find Bag ---");
        System.out.print("Enter Bag ID to search: ");
        String bagId = scanner.nextLine();

        try {
            Baggage foundBag = system.findBagById(bagId); // Search for the bag

            if (foundBag != null) {
                System.out.println("Bag found: " + foundBag);
            } else {
                // Use System.err as per requirement for "not found" which is a type of error/failure
                System.err.println("Bag with ID '" + bagId + "' not found in the system.");
            }
        } catch (IllegalArgumentException e) {
             // Catch validation errors from findBagById
            System.err.println("Error searching for bag: " + e.getMessage());
        }
    }
}
