/*
 * Exam Question #708
 * Generated on: 2025-05-12 16:28:40
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Task Management System with Retry Queue
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Task Management System. This system needs to keep track of all tasks, allow users to add new tasks, process tasks one by one, and manage tasks that fail processing by placing them into a retry queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (higher number = higher priority).
 *     *   `status` (enum `TaskStatus`): The current status of the task. Define an enum `TaskStatus` with at least the following states: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 *     *   Implement appropriate getters and setters (at least for status).
 *     *   Implement a `toString()` method for easy display.
 *     *   Ensure proper encapsulation (private fields).
 * 
 * 2.  **Task Manager:** Create a `TaskManager` class that manages the tasks. It must use:
 *     *   A `List<Task>` (specifically an `ArrayList`) to store *all* tasks ever added to the system.
 *     *   A `Queue<Task>` (specifically using a concrete class like `LinkedList` that implements `Queue`) to store tasks that have `FAILED` and are waiting to be retried.
 *     *   A `Scanner` for user input in the main interaction loop.
 * 
 * 3.  **Functionality:** The `TaskManager` should provide the following operations via a command-line interface:
 *     *   **Add Task:** Prompt the user for a description and priority. Create a new `Task` with a unique ID (e.g., a simple counter starting from 1), set its status to `PENDING`, and add it to the `allTasks` list.
 *     *   **Process Next Ready Task:** This is the core processing logic.
 *         *   First, check the `retryQueue`. If it's not empty, take the next task from the `retryQueue`.
 *         *   If the `retryQueue` is empty, find the first task in the `allTasks` list that has the status `PENDING`.
 *         *   If no task is found (neither in retry queue nor pending in all tasks), inform the user.
 *         *   If a task is found:
 *             *   Mark its status as `PROCESSING`.
 *             *   Simulate processing (e.g., print messages indicating processing starts/ends).
 *             *   Simulate a random chance of failure (e.g., 30% chance).
 *             *   If processing succeeds: Mark the task's status as `COMPLETED`. Print a success message.
 *             *   If processing fails: Mark the task's status as `FAILED`. Add the task to the `retryQueue`. Print a failure message.
 *     *   **View All Tasks:** Display details (ID, Description, Priority, Status) of all tasks currently in the `allTasks` list.
 *     *   **View Retry Queue:** Display details (ID, Description, Priority, Status) of tasks currently waiting in the `retryQueue`.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:** Implement a simple command-line interface using `Scanner` and a `switch` statement to handle user commands (e.g., 'add', 'process', 'view all', 'view retry', 'exit').
 * 
 * 5.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly around user input (e.g., non-integer priority).
 *     *   Use `System.err.println()` for error messages (e.g., invalid input, exception details).
 *     *   Use `System.out.println()` for normal output (prompts, success messages, task lists).
 *     *   Implement input validation where necessary (e.g., ensure priority is an integer).
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add appropriate comments and documentation (Javadoc where applicable).
 *     *   Ensure code is well-structured and readable.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user, accepting commands and printing results or errors. Example interaction might look like:
 * 
 * ```
 * Task Management System
 * Enter command (add, process, view all, view retry, exit): add
 * Enter task description: Write report
 * Enter priority: 5
 * Task added with ID: 1
 * 
 * Enter command (add, process, view all, view retry, exit): add
 * Enter task description: Code review
 * Enter priority: 3
 * Task added with ID: 2
 * 
 * Enter command (add, process, view all, view retry, exit): process
 * Processing task 1 (Write report)...
 * Task 1 completed successfully.
 * 
 * Enter command (add, process, view all, view retry, exit): process
 * Processing task 2 (Code review)...
 * Task 2 failed processing. Added to retry queue.
 * 
 * Enter command (add, process, view all, view retry, exit): view all
 * --- All Tasks ---
 * ID: 1, Description: Write report, Priority: 5, Status: COMPLETED
 * ID: 2, Description: Code review, Priority: 3, Status: FAILED
 * -----------------
 * 
 * Enter command (add, process, view all, view retry, exit): view retry
 * --- Retry Queue ---
 * ID: 2, Description: Code review, Priority: 3, Status: FAILED
 * -------------------
 * 
 * Enter command (add, process, view all, view retry, exit): process
 * Processing task 2 (Code review)...
 * Task 2 completed successfully.
 * 
 * Enter command (add, process, view all, view retry, exit): exit
 * Exiting Task Management System.
 * ```
 * (Note: Simulated success/failure will vary due to random chance).
 * 
 * **Constraint Checklist:**
 * 1.  `Queue` (from `java.util.Queue`): YES
 * 2.  `ArrayList` (from `java.util.ArrayList`): YES
 * 3.  `List` interface (from `java.util.List`): YES
 * 4.  `Scanner` for user input (from `java.util.Scanner`): YES
 * 5.  `Switch` statement for flow control: YES
 * 6.  `System.err` for error messages: YES
 * 7.  `System.out` for normal output: YES
 * 8.  Class-wide exception handling with `try-catch`: YES (around main loop and specific operations)
 * 
 * You must provide a complete, runnable Java solution.
 *
 * EXPLANATION:
 * This solution implements the Task Management System as described, utilizing all the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, `priority`, and `status`.
 *     *   An `enum TaskStatus` is defined for clear state representation (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Fields are `private` for encapsulation.
 *     *   Public getters provide access to task details. A `setStatus` setter allows changing the task's state.
 *     *   `toString()` is overridden for convenient printing of task information.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This class orchestrates the system's operations.
 *     *   `allTasks`: A `java.util.List` reference, specifically implemented using `java.util.ArrayList`, holds every task created. This provides easy access by index and allows iteration over the entire collection.
 *     *   `retryQueue`: A `java.util.Queue` reference, implemented using `java.util.LinkedList`. This queue manages tasks that failed processing and are awaiting another attempt. `Queue` methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used, adhering to the First-In, First-Out (FIFO) principle for retries in this specific implementation (though the problem didn't strictly require FIFO for retries, `Queue` is the required component).
 *     *   `scanner`: A `java.util.Scanner` reads user input from the console (`System.in`).
 *     *   `nextTaskId`: An integer counter ensures unique IDs for new tasks.
 *     *   `random`: Used to simulate the success or failure of task processing.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `run()`: Contains the main application loop. It repeatedly prompts the user for commands and uses a `switch` statement to dispatch to the appropriate private methods (`addTask`, `processNextReadyTask`, `viewAllTasks`, `viewRetryQueue`). The loop continues until the user enters 'exit'.
 *     *   `addTask()`: Reads description and priority from the user. It includes a `try-catch` block and a loop to handle `NumberFormatException` if the user enters non-integer input for priority, ensuring robust input handling. A new `Task` object is created with `PENDING` status and added to the `allTasks` list.
 *     *   `processNextReadyTask()`: Implements the core logic. It prioritizes tasks in the `retryQueue` using `poll()`. If the retry queue is empty, it iterates through `allTasks` to find the first `PENDING` task. If a task is found, its status is set to `PROCESSING`, processing is simulated (via print statements and random chance), and the status is updated to `COMPLETED` or `FAILED`. If `FAILED`, the task is added to the `retryQueue` using `offer()`. If no task is found in either location, a message is printed.
 *     *   `viewAllTasks()`: Iterates through the `allTasks` list and prints each task's details using its `toString()` method.
 *     *   `viewRetryQueue()`: Iterates through the `retryQueue`. Note that iterating a `Queue` (like `LinkedList`) with a for-each loop views elements without removing them, which is suitable for displaying the queue's contents.
 * 
 * 4.  **Error Handling (`try-catch`, `System.err`, `System.out`):**
 *     *   A main `try-catch(Exception e)` block wraps the `switch` statement within the `run` loop. This catches any unexpected exceptions during command execution and prints an error message to `System.err`.
 *     *   Specific `try-catch(NumberFormatException)` is used in `addTask` to handle invalid priority input, printing an error to `System.err`.
 *     *   `System.out.println()` is used for all normal user interactions: prompts, success messages, task lists, and exit messages.
 *     *   `System.err.println()` is reserved for printing error conditions like invalid commands or input format issues.
 * 
 * 5.  **Best Practices:**
 *     *   Private fields and public methods demonstrate good encapsulation.
 *     *   Method and variable names (`addTask`, `retryQueue`, `processNextReadyTask`, `description`, `status`) are descriptive.
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation is performed for the priority input.
 *     *   The code is structured logically with separate methods for each distinct operation.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating an understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Task Class
class Task {
    private int id;
    private String description;
    private int priority;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status (allows state transitions)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %d, Status: %s",
                             id, description, priority, status);
    }
}

// Task Manager Class
class TaskManager {
    private List<Task> allTasks;
    private Queue<Task> retryQueue;
    private Scanner scanner;
    private int nextTaskId;
    private Random random; // For simulating processing failure

    /**
     * Constructs a TaskManager.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Using ArrayList for the List interface
        this.retryQueue = new LinkedList<>(); // Using LinkedList for the Queue interface
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
        this.random = new Random();
    }

    /**
     * Runs the main interactive loop of the Task Manager.
     */
    public void run() {
        System.out.println("Task Management System");
        boolean running = true;

        while (running) {
            System.out.println("\nEnter command (add, process, view all, view retry, exit):");
            String command = scanner.nextLine().trim().toLowerCase();

            try {
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "process":
                        processNextReadyTask();
                        break;
                    case "view all":
                        viewAllTasks();
                        break;
                    case "view retry":
                        viewRetryQueue();
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Invalid command. Please try again.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input format. Please try again.");
                scanner.nextLine(); // Consume the invalid input line
            } catch (Exception e) {
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Adds a new task based on user input.
     */
    private void addTask() {
        System.out.println("Enter task description:");
        String description = scanner.nextLine();

        int priority = 0;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.println("Enter priority (integer):");
            try {
                priority = Integer.parseInt(scanner.nextLine());
                validPriority = true;
            } catch (NumberFormatException e) {
                System.err.println("Invalid priority format. Please enter an integer.");
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Finds and processes the next ready task (retry queue first, then pending).
     */
    private void processNextReadyTask() {
        Task taskToProcess = null;

        // 1. Check retry queue first
        if (!retryQueue.isEmpty()) {
            taskToProcess = retryQueue.poll(); // Get and remove from retry queue
            System.out.println("Attempting retry for task " + taskToProcess.getId() + " (" + taskToProcess.getDescription() + ")...");
        } else {
            // 2. If retry queue is empty, find the first PENDING task in allTasks
            for (Task task : allTasks) {
                if (task.getStatus() == TaskStatus.PENDING) {
                    taskToProcess = task;
                    break; // Found a pending task, process it
                }
            }
            if (taskToProcess != null) {
                 System.out.println("Processing pending task " + taskToProcess.getId() + " (" + taskToProcess.getDescription() + ")...");
            }
        }

        // 3. Process the found task or report none found
        if (taskToProcess != null) {
            taskToProcess.setStatus(TaskStatus.PROCESSING);

            // Simulate processing time/work (optional, using print messages instead)
            // System.out.println("Simulating work...");

            // Simulate success or failure (e.g., 30% chance of failure)
            boolean success = random.nextDouble() > 0.3;

            if (success) {
                taskToProcess.setStatus(TaskStatus.COMPLETED);
                System.out.println("Task " + taskToProcess.getId() + " completed successfully.");
                // If it was from retry queue, it's now completed in allTasks. No need to remove from allTasks.
            } else {
                taskToProcess.setStatus(TaskStatus.FAILED);
                retryQueue.offer(taskToProcess); // Add back to retry queue
                System.out.println("Task " + taskToProcess.getId() + " failed processing. Added to retry queue.");
            }
        } else {
            System.out.println("No tasks ready to process (retry queue empty and no pending tasks).");
        }
    }

    /**
     * Displays all tasks in the system.
     */
    private void viewAllTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks added yet.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Displays tasks currently in the retry queue.
     */
    private void viewRetryQueue() {
        System.out.println("--- Retry Queue ---");
        if (retryQueue.isEmpty()) {
            System.out.println("Retry queue is empty.");
        } else {
            // Iterate without removing elements
            for (Task task : retryQueue) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
