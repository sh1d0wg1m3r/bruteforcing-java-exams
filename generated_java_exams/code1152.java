/*
 * Exam Question #1152
 * Generated on: 2025-05-12 17:32:06
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Event Session Management System
 * 
 * **Objective:** Design and implement a simplified event session management system. The system allows managing attendees for different sessions, each with a limited capacity. When a session is full, attendees are placed on a waiting list.
 * 
 * **Task:** Create a Java program that simulates this system. Your program should allow users to interact with the system via a command-line interface to perform actions related to session registration and status checking.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Represent each session with a class (e.g., `Session`).
 *     *   Inside the `Session` class, use a `java.util.List` (specifically implemented with `java.util.ArrayList`) to store registered attendees.
 *     *   Inside the `Session` class, use a `java.util.Queue` (use `java.util.LinkedList` as the implementation) to store attendees on the waiting list.
 *     *   Maintain a collection of `Session` objects (you can use an `ArrayList` in the main management class).
 * 
 * 2.  **Functionality:**
 *     *   **Add Session:** (You can pre-populate a few sessions for simplicity, or add a command to add them).
 *     *   **Register Attendee:**
 *         *   Prompt the user for the session name and the attendee's name.
 *         *   If the session exists and has capacity, add the attendee to the registered list.
 *         *   If the session exists but is full, add the attendee to the waiting list.
 *         *   If the session does not exist, display an error.
 *         *   An attendee cannot be registered or waitlisted more than once for the same session.
 *     *   **Check Status:**
 *         *   Prompt the user for the session name and the attendee's name.
 *         *   Report if the attendee is registered, on the waiting list, or not found for that specific session.
 *     *   **List Registered Attendees:**
 *         *   Prompt the user for the session name.
 *         *   List all attendees currently registered for that session.
 *         *   If the session doesn't exist or has no registered attendees, report accordingly.
 *     *   **List Waitlisted Attendees:**
 *         *   Prompt the user for the session name.
 *         *   List all attendees currently on the waiting list for that session (in queue order).
 *         *   If the session doesn't exist or has no waitlisted attendees, report accordingly.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Register, Check Status, List Registered, List Waitlisted, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling (e.g., a `try-catch` block around the main interaction loop or input processing) to catch potential issues like invalid input types.
 *     *   Use `System.err.println()` to display error messages (e.g., "Session not found!", "Invalid input!", "Attendee already registered/waitlisted!").
 *     *   Use `System.out.println()` for all normal output (menu, prompts, success messages, lists).
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Implement proper encapsulation (private fields, public methods) in your classes.
 *     *   Include basic comments or Javadoc where necessary to explain complex parts.
 *     *   Validate user input where appropriate (e.g., ensuring session names are not empty).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept integer input for the choice, and then prompt for session and attendee names based on the chosen action. Output should clearly indicate the result of each action (success, failure, status, lists). Error messages must go to standard error.
 * 
 * ```
 * --- Event Session Management ---
 * 1. Register Attendee
 * 2. Check Status
 * 3. List Registered Attendees
 * 4. List Waitlisted Attendees
 * 5. Exit
 * Enter your choice:
 * ```
 * (Example interaction after choosing 1)
 * ```
 * Enter session name: Java Basics
 * Enter attendee name: Alice
 * Alice successfully registered for Java Basics.
 * ```
 * (Example interaction after choosing 1 when full)
 * ```
 * Enter session name: Java Basics
 * Enter attendee name: Bob
 * Java Basics is full. Bob added to waitlist.
 * ```
 * (Example interaction after choosing 3)
 * ```
 * Enter session name: Java Basics
 * Registered attendees for Java Basics:
 * - Alice
 * ```
 * (Example interaction after choosing 4)
 * ```
 * Enter session name: Java Basics
 * Waitlist for Java Basics:
 * - Bob
 * ```
 * (Example interaction with error)
 * ```
 * Enter session name: NonExistentSession
 * Enter attendee name: Charlie
 * Session 'NonExistentSession' not found.
 * ```
 * (Error output using System.err)
 * ```
 * ERROR: Session 'NonExistentSession' not found.
 * ```
 * 
 * **Constraints:**
 * 
 * *   The system is simplified; attendees don't "unregister" or move from the waitlist automatically.
 * *   Focus on correctly using the required Java components in a cohesive application.
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The solution implements an `EventManager` class that manages a collection of `Session` objects. Each `Session` represents a specific event session with a limited capacity.
 * 
 * 1.  **`Session` Class:**
 *     *   It encapsulates the data for a session: `name`, `capacity`, `registeredAttendees`, and `waitlist`.
 *     *   `registeredAttendees` is declared as `List<String>` and initialized with `ArrayList<String>`. This demonstrates using the interface type for the variable while using a concrete implementation. `ArrayList` is suitable here for storing a dynamic list of registered attendees where order doesn't strictly matter after registration, but easy iteration and checking presence (`contains`) are needed.
 *     *   `waitlist` is declared as `Queue<String>` and initialized with `LinkedList<String>`. `LinkedList` is a common `Queue` implementation that maintains insertion order, which is appropriate for a waiting list (first-come, first-served). The `Queue` interface methods like `offer()` (add to end) are used.
 *     *   Methods like `isFull()`, `addRegistered()`, `addToWaitlist()`, `isRegistered()`, and `isOnWaitlist()` provide encapsulated access and manipulation of the session's state. Getters return copies of the lists/queue to prevent external modification.
 * 
 * 2.  **`EventManager` Class:**
 *     *   It holds an `ArrayList<Session>` (`sessions`) to manage all the sessions.
 *     *   It uses a `Scanner` (`scanner`) to read input from `System.in`.
 *     *   The `run()` method contains the main application loop.
 *     *   **Switch Statement:** Inside the `run()` method, a `switch` statement is used to direct program flow based on the user's integer input, calling the appropriate private helper methods (`registerAttendee`, `checkStatus`, etc.).
 *     *   **Scanner Usage:** The `Scanner` is used to read both integer choices (`nextInt()`) and string inputs (`nextLine()`). Note the use of `scanner.nextLine()` after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   **System.out & System.err:** `System.out.println()` is used for all standard output, including menus, prompts, success messages, and lists. `System.err.println()` is specifically used for displaying error messages, as required.
 *     *   **Class-wide Exception Handling:** A `try-catch` block wraps the core logic inside the `run()` loop. This catches potential `InputMismatchException` if the user enters non-integer input for the menu choice. It also includes a general `Exception` catch-all for unexpected errors, demonstrating robust handling. The `catch` block for `InputMismatchException` includes consuming the invalid input (`scanner.nextLine()`) to prevent an infinite loop.
 *     *   **Input Validation:** Basic validation is done within the methods, such as checking if a session exists (`findSession`) before attempting to register or check status. It also prevents duplicate registrations/waitlist entries.
 *     *   **Helper Methods:** Private methods like `findSession`, `registerAttendee`, `checkStatus`, `listRegisteredAttendees`, and `listWaitlistedAttendees` break down the functionality into smaller, manageable units, improving code organization and readability.
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated, and error-handled application structure. The use of `Queue` for the waitlist and `List` (`ArrayList`) for registered attendees directly maps to their typical use cases.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single session with a limited capacity,
 * managing registered attendees and a waitlist.
 */
class Session {
    private String name;
    private int capacity;
    private List<String> registeredAttendees; // Using List interface, implemented by ArrayList
    private Queue<String> waitlist; // Using Queue interface, implemented by LinkedList

    /**
     * Constructs a new Session.
     * @param name The name of the session.
     * @param capacity The maximum number of registered attendees.
     */
    public Session(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>();
        this.waitlist = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Gets the name of the session.
     * @return The session name.
     */
    public String getName() {
        return name;
    }

    /**
     * Checks if the session is currently full.
     * @return true if registered attendees equals or exceeds capacity, false otherwise.
     */
    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    /**
     * Adds an attendee to the registered list if capacity allows.
     * @param attendeeName The name of the attendee.
     * @return true if added successfully, false otherwise (e.g., full).
     */
    public boolean addRegistered(String attendeeName) {
        if (!isFull()) {
            registeredAttendees.add(attendeeName);
            return true;
        }
        return false;
    }

    /**
     * Adds an attendee to the waitlist.
     * @param attendeeName The name of the attendee.
     */
    public void addToWaitlist(String attendeeName) {
        waitlist.offer(attendeeName); // offer is preferred over add for queues
    }

    /**
     * Checks if an attendee is currently registered for this session.
     * @param attendeeName The name of the attendee.
     * @return true if the attendee is in the registered list, false otherwise.
     */
    public boolean isRegistered(String attendeeName) {
        return registeredAttendees.contains(attendeeName);
    }

    /**
     * Checks if an attendee is currently on the waitlist for this session.
     * Note: Checking presence in a LinkedList queue can be O(n).
     * @param attendeeName The name of the attendee.
     * @return true if the attendee is in the waitlist, false otherwise.
     */
    public boolean isOnWaitlist(String attendeeName) {
        return waitlist.contains(attendeeName);
    }

    /**
     * Gets the list of registered attendees.
     * @return A List of registered attendee names.
     */
    public List<String> getRegisteredAttendees() {
        return new ArrayList<>(registeredAttendees); // Return a copy to prevent external modification
    }

    /**
     * Gets the list of waitlisted attendees.
     * @return A List of waitlisted attendee names (order preserved).
     */
    public List<String> getWaitlist() {
        return new ArrayList<>(waitlist); // Return a copy, order is preserved from queue
    }
}

/**
 * Manages multiple sessions and handles user interactions.
 */
public class EventManager {
    private List<Session> sessions; // Using List interface, implemented by ArrayList
    private Scanner scanner;

    /**
     * Constructs a new EventManager and initializes sessions.
     */
    public EventManager() {
        this.sessions = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        // Pre-populate some sessions
        sessions.add(new Session("Java Basics", 2));
        sessions.add(new Session("Advanced SQL", 3));
        sessions.add(new Session("Cloud Computing 101", 1));
    }

    /**
     * Finds a session by its name.
     * @param sessionName The name of the session to find.
     * @return The Session object if found, null otherwise.
     */
    private Session findSession(String sessionName) {
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(sessionName.trim())) {
                return session;
            }
        }
        return null;
    }

    /**
     * Handles the registration process for an attendee.
     */
    private void registerAttendee() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session == null) {
            System.err.println("ERROR: Session '" + sessionName + "' not found.");
            return;
        }

        // Check if attendee is already registered or waitlisted
        if (session.isRegistered(attendeeName)) {
            System.err.println("ERROR: Attendee '" + attendeeName + "' is already registered for '" + sessionName + "'.");
            return;
        }
        if (session.isOnWaitlist(attendeeName)) {
            System.err.println("ERROR: Attendee '" + attendeeName + "' is already on the waitlist for '" + sessionName + "'.");
            return;
        }

        if (session.addRegistered(attendeeName)) {
            System.out.println(attendeeName + " successfully registered for " + sessionName + ".");
        } else {
            session.addToWaitlist(attendeeName);
            System.out.println(sessionName + " is full. " + attendeeName + " added to waitlist.");
        }
    }

    /**
     * Handles checking the status of an attendee for a session.
     */
    private void checkStatus() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session == null) {
            System.err.println("ERROR: Session '" + sessionName + "' not found.");
            return;
        }

        if (session.isRegistered(attendeeName)) {
            System.out.println(attendeeName + " is registered for " + sessionName + ".");
        } else if (session.isOnWaitlist(attendeeName)) {
            System.out.println(attendeeName + " is on the waitlist for " + sessionName + ".");
        } else {
            System.out.println(attendeeName + " is not registered or waitlisted for " + sessionName + ".");
        }
    }

    /**
     * Handles listing registered attendees for a session.
     */
    private void listRegisteredAttendees() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session == null) {
            System.err.println("ERROR: Session '" + sessionName + "' not found.");
            return;
        }

        List<String> registered = session.getRegisteredAttendees();
        if (registered.isEmpty()) {
            System.out.println("No attendees registered for " + sessionName + ".");
        } else {
            System.out.println("Registered attendees for " + sessionName + ":");
            for (String attendee : registered) {
                System.out.println("- " + attendee);
            }
        }
    }

    /**
     * Handles listing waitlisted attendees for a session.
     */
    private void listWaitlistedAttendees() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();

        Session session = findSession(sessionName);

        if (session == null) {
            System.err.println("ERROR: Session '" + sessionName + "' not found.");
            return;
        }

        List<String> waitlist = session.getWaitlist(); // Get as List to iterate
        if (waitlist.isEmpty()) {
            System.out.println("No attendees on the waitlist for " + sessionName + ".");
        } else {
            System.out.println("Waitlist for " + sessionName + ":");
            // Iterate through the list representation of the queue
            for (String attendee : waitlist) {
                System.out.println("- " + attendee);
            }
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Session Management ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Check Status");
        System.out.println("3. List Registered Attendees");
        System.out.println("4. List Waitlisted Attendees");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use a switch statement for flow control
                switch (choice) {
                    case 1:
                        registerAttendee();
                        break;
                    case 2:
                        checkStatus();
                        break;
                    case 3:
                        listRegisteredAttendees();
                        break;
                    case 4:
                        listWaitlistedAttendees();
                        break;
                    case 5:
                        System.out.println("Exiting Event Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling for non-integer input
                System.err.println("ERROR: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to standard error
                // Optionally, decide if the program should exit or continue
            }
        }
        scanner.close(); // Close the scanner when done
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
