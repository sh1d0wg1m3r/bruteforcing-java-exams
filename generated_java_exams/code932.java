/*
 * Exam Question #932
 * Generated on: 2025-05-12 17:01:33
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a print job management system. The system should manage a queue of print jobs waiting to be processed and maintain a history of jobs that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class named `PrintJob` to represent a single print job.
 *     *   It should have private fields for `jobId` (int), `fileName` (String), and `pages` (int).
 *     *   Implement a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the print job (e.g., "Job ID: [id], File: [fileName], Pages: [pages]").
 * 
 * 2.  **`PrintJobManager` Class:**
 *     *   Create a class named `PrintJobManager` to manage the print jobs.
 *     *   It must have a private field that is a `java.util.Queue` to store pending `PrintJob` objects. Use a suitable implementation like `LinkedList`.
 *     *   It must have a private field that is a `java.util.List` (implemented using `java.util.ArrayList`) to store completed `PrintJob` objects.
 *     *   Include a private field to track the next available `jobId` (start from 1).
 *     *   Include a private field for `java.util.Scanner` to handle user input within the manager's interaction loop.
 * 
 * 3.  **Core Functionality Methods (`PrintJobManager`):**
 *     *   `addJob(String fileName, int pages)`: Creates a new `PrintJob` with the next available ID and adds it to the job queue.
 *         *   Implement input validation: `fileName` cannot be null or empty after trimming whitespace, `pages` must be greater than 0. If validation fails, throw an `IllegalArgumentException`.
 *     *   `processNextJob()`: Removes the job at the front of the queue, simulates processing (print a message), and adds it to the history list. If the queue is empty, print a message indicating that there are no jobs to process.
 *     *   `viewQueue()`: Prints the details of all jobs currently in the queue without removing them. If the queue is empty, print a message indicating so.
 *     *   `viewHistory()`: Prints the details of all jobs in the history list. If history is empty, print a message indicating so.
 * 
 * 4.  **User Interface (`PrintJobManager`):**
 *     *   Implement a method (e.g., `start()`) that contains the main application loop.
 *     *   Inside the loop, display a menu of options to the user:
 *         1.  Add Print Job
 *         2.  Process Next Job
 *         3.  View Job Queue
 *         4.  View History
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read the user's menu choice and any required input (filename, pages).
 *     *   Use a `switch` statement to handle the different menu options, calling the appropriate `PrintJobManager` methods.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful actions (job added, job processed), and job lists/history.
 *     *   Use `System.err` for displaying error messages, such as invalid input during job creation or invalid menu choices.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks.
 *         *   Wrap the main application loop in a `try-catch` block to catch unexpected runtime exceptions, printing an error message and stack trace to `System.err`.
 *         *   Handle specific exceptions like `NumberFormatException` when parsing user input for menu choice or pages, printing an error message to `System.err`.
 *         *   Catch the `IllegalArgumentException` thrown by `addJob` in the user interface logic and print the error message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments to explain complex parts of the code.
 *     *   Structure the code logically.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and provide feedback using `System.out` for normal operations and `System.err` for errors. The queue should follow FIFO order for processing, and history should show jobs in the order they were processed.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Print Job Management System ---
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Added job: Job ID: 1, File: report.pdf, Pages: 15
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 1
 * Enter file name: presentation.pptx
 * Enter number of pages: 30
 * Added job: Job ID: 2, File: presentation.pptx, Pages: 30
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 3
 * --- Current Job Queue ---
 * Job ID: 1, File: report.pdf, Pages: 15
 * Job ID: 2, File: presentation.pptx, Pages: 30
 * -------------------------
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 2
 * Processing job: Job ID: 1, File: report.pdf, Pages: 15
 * Job processed and moved to history.
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 3
 * --- Current Job Queue ---
 * Job ID: 2, File: presentation.pptx, Pages: 30
 * -------------------------
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 4
 * --- Processed Job History ---
 * Job ID: 1, File: report.pdf, Pages: 15
 * -----------------------------
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 1
 * Enter file name: test.txt
 * Enter number of pages: -5
 * Error adding job: Number of pages must be positive.
 * 
 * Menu:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View History
 * 5. Exit
 * Enter choice: 5
 * Exiting system.
 * System shutdown complete.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `PrintJobManagementSystem` simulation using the required Java components and best practices.
 * 
 * 1.  **`PrintJob` Class:** This simple class serves as a data structure (`POJO`) to hold the details of a single print job. It has private fields (`id`, `fileName`, `pages`), a constructor, public getters for encapsulation, and overrides `toString()` for easy printing.
 * 
 * 2.  **`PrintJobManager` Class:** This is the core class managing the system's state and logic.
 *     *   **`Queue<PrintJob> jobQueue`**: A `java.util.Queue` is used to store pending print jobs. `LinkedList` is chosen as a common implementation that efficiently supports queue operations (adding to the end, removing from the front). The `Queue` interface guarantees FIFO (First-In, First-Out) behavior, which is essential for a print queue. `offer()` is used to add jobs, and `poll()` is used to remove and retrieve the next job.
 *     *   **`List<PrintJob> history`**: A `java.util.List` is used to store completed jobs. `ArrayList` is chosen for its efficient storage and retrieval of elements, suitable for maintaining a history. Jobs are added to the end of this list using the `add()` method after being processed.
 *     *   **`int nextJobId`**: A simple counter to assign unique IDs to each new job.
 *     *   **`Scanner scanner`**: An instance of `java.util.Scanner` is used to read user input from the console (`System.in`). It's managed as a class field and closed in the `finally` block.
 * 
 * 3.  **Core Functionality Methods:**
 *     *   `addJob(String fileName, int pages)`: This method encapsulates the logic for creating and adding a job. It includes crucial input validation using `if` statements. Invalid input results in an `IllegalArgumentException` being thrown, which is a standard way to signal bad arguments to a method.
 *     *   `processNextJob()`: Demonstrates queue processing. `jobQueue.poll()` retrieves and removes the job at the head of the queue (the oldest job). If the queue is empty, `poll()` returns `null`, which is handled gracefully. The processed job is then added to the `history` `List`.
 *     *   `viewQueue()`: Iterates through the `jobQueue` using an `Iterator` to display its contents without modifying the queue.
 *     *   `viewHistory()`: Iterates through the `history` `List` using an enhanced for loop to display completed jobs.
 * 
 * 4.  **User Interface and `switch`:**
 *     *   The `start()` method contains the main loop that drives the application.
 *     *   A menu is printed using `System.out`.
 *     *   User input for the menu choice is read using `scanner.nextLine()` and then parsed to an integer. Reading the whole line and parsing is safer than `scanner.nextInt()` as it consumes the newline character, preventing potential issues in subsequent `nextLine()` calls.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, calling the appropriate methods (`addJobFromInput`, `processNextJob`, `viewQueue`, `viewHistory`).
 * 
 * 5.  **Error Handling (`System.err`, `try-catch`):**
 *     *   `System.err` is used specifically for displaying error messages, such as invalid menu choices (in the `default` case of the `switch`), `NumberFormatException` during input parsing, and the messages from `IllegalArgumentException` thrown by `addJob`.
 *     *   `System.out` is used for all normal, non-error output (menu, prompts, success messages, job lists).
 *     *   Multiple `try-catch` blocks are used:
 *         *   A top-level `try-catch` in the `start()` method's `while` loop catches any unexpected `Exception` that might occur during a menu operation, providing a robust shield for the main application flow and printing details to `System.err`.
 *         *   Specific `catch (NumberFormatException e)` blocks handle cases where the user enters non-numeric input when a number is expected (menu choice, pages).
 *         *   A `catch (IllegalArgumentException e)` block in the main loop handles the validation errors thrown by the `addJob` method when the user provides invalid job details.
 *         *   A `finally` block ensures the `Scanner` resource is closed when the application exits, regardless of whether an exception occurred.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in both classes are `private`, and access is provided via `public` methods.
 *     *   **Meaningful Names:** Variables (`jobQueue`, `nextJobId`), methods (`processNextJob`, `viewHistory`), and classes (`PrintJob`, `PrintJobManager`) have names that clearly indicate their purpose.
 *     *   **Comments:** Javadoc comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific logic points.
 *     *   **Clean Structure:** The code is divided into logical classes, and the main loop clearly orchestrates the interactions. Input handling for adding a job is delegated to a separate helper method (`addJobFromInput`) for better organization.
 * 
 * This solution effectively demonstrates the use of the required Java components in a practical scenario, incorporating essential programming practices like input validation, error handling, and object-oriented design principles, fulfilling the requirements of a challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Implementation of Queue
import java.util.List;
import java.util.ArrayList; // Implementation of List
import java.util.Scanner; // For user input
import java.util.Iterator; // Useful for iterating through the queue safely

/**
 * Represents a single print job with an ID, file name, and number of pages.
 */
class PrintJob {
    private int id;
    private String fileName;
    private int pages;

    /**
     * Constructs a new PrintJob.
     *
     * @param id The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the file.
     */
    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
    }

    // --- Public Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + id + ", File: " + fileName + ", Pages: " + pages;
    }
}

/**
 * Manages a queue of print jobs and a history of processed jobs.
 * Handles user interaction via a command-line menu.
 */
public class PrintJobManager { // Changed to public class to be runnable
    // --- Private Fields ---
    private Queue<PrintJob> jobQueue; // Queue for pending jobs
    private List<PrintJob> history;   // List for completed jobs
    private int nextJobId;            // Counter for unique job IDs
    private Scanner scanner;          // Scanner for reading user input

    /**
     * Constructs a new PrintJobManager, initializing the queue, history,
     * job ID counter, and scanner.
     */
    public PrintJobManager() {
        this.jobQueue = new LinkedList<>(); // LinkedList implements Queue (FIFO)
        this.history = new ArrayList<>();   // ArrayList implements List
        this.nextJobId = 1;                 // Start job IDs from 1
        this.scanner = new Scanner(System.in); // Initialize scanner for standard input
    }

    /**
     * Starts the main application loop, displaying the menu and handling user input.
     * Includes class-wide exception handling.
     */
    public void start() {
        System.out.println("--- Print Job Management System ---");
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                try {
                    // Read the entire line to avoid issues with nextInt() and newlines
                    String choiceStr = scanner.nextLine();
                    int choice = Integer.parseInt(choiceStr); // Parse the input string to an integer

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addJobFromInput(); // Delegate input handling for adding a job
                            break;
                        case 2:
                            processNextJob();
                            break;
                        case 3:
                            viewQueue();
                            break;
                        case 4:
                            viewHistory();
                            break;
                        case 5:
                            System.out.println("Exiting system.");
                            running = false; // Set running to false to exit the loop
                            break;
                        default:
                            // Handle invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Catch error if user input is not a valid integer
                    System.err.println("Invalid input. Please enter a number.");
                } catch (IllegalArgumentException e) {
                    // Catch validation errors thrown by addJob method
                    System.err.println("Error: " + e.getMessage());
                } catch (Exception e) {
                     // Catch any other unexpected exceptions during menu processing
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     e.printStackTrace(System.err); // Print stack trace to standard error stream
                }
                System.out.println(); // Add a newline for better readability between menu cycles
            }
        } catch (Exception e) {
            // Top-level catch block for critical errors in the main system loop
            System.err.println("A critical error occurred in the system loop: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error stream
        } finally {
             // Ensure the scanner is closed when the application exits
             if (scanner != null) {
                 scanner.close();
             }
             System.out.println("System shutdown complete.");
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Job Queue");
        System.out.println("4. View History");
        System.out.println("5. Exit");
    }

    /**
     * Prompts user for job details and calls addJob. Handles input parsing errors.
     */
    private void addJobFromInput() {
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine(); // Read file name

        System.out.print("Enter number of pages: ");
        String pagesStr = scanner.nextLine(); // Read pages as string first
        int pages = -1; // Default invalid value

        try {
            pages = Integer.parseInt(pagesStr); // Attempt to parse pages string to integer
            // Call the core logic method, which includes validation and queue addition
            addJob(fileName, pages);
        } catch (NumberFormatException e) {
            // Catch error if pages input is not a valid integer
            System.err.println("Invalid number format for pages.");
        }
        // IllegalArgumentException from addJob is caught in the main start() loop's try-catch
    }


    /**
     * Adds a new PrintJob to the queue after validating input.
     *
     * @param fileName The name of the file.
     * @param pages The number of pages.
     * @throws IllegalArgumentException if fileName is invalid or pages is not positive.
     */
    public void addJob(String fileName, int pages) {
        // --- Input Validation ---
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be empty.");
        }
        if (pages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }

        // Create new job and add to queue
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim(), pages);
        jobQueue.offer(newJob); // offer() is the preferred method for adding to a queue
        System.out.println("Added job: " + newJob);
    }

    /**
     * Processes (removes) the next job from the queue and adds it to history.
     */
    public void processNextJob() {
        PrintJob jobToProcess = jobQueue.poll(); // poll() retrieves and removes the head of the queue

        if (jobToProcess != null) {
            System.out.println("Processing job: " + jobToProcess);
            // Simulate processing time if needed (not required by prompt)
            history.add(jobToProcess); // Add the processed job to the history list
            System.out.println("Job processed and moved to history.");
        } else {
            // Message when queue is empty
            System.out.println("Job queue is empty. Nothing to process.");
        }
    }

    /**
     * Displays the details of all jobs currently in the queue.
     */
    public void viewQueue() {
        if (jobQueue.isEmpty()) {
            System.out.println("Job queue is empty.");
        } else {
            System.out.println("--- Current Job Queue ---");
            // Iterate through the queue without removing elements
            Iterator<PrintJob> iterator = jobQueue.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
            System.out.println("-------------------------");
        }
    }

    /**
     * Displays the details of all jobs in the history list.
     */
    public void viewHistory() {
        if (history.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            System.out.println("--- Processed Job History ---");
            // Iterate through the history list (ArrayList)
            for (PrintJob job : history) {
                System.out.println(job);
            }
            System.out.println("-----------------------------");
        }
    }

    /**
     * Main method to create and start the PrintJobManager application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.start(); // Start the application loop
    }
}
