/*
 * Exam Question #176
 * Generated on: 2025-05-11 22:26:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Simple Job Queue System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application that simulates a basic job processing queue. The system should allow users to add new jobs, process the oldest pending job, view all pending jobs, and view all completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Job Representation:** For simplicity, each job will be represented by a `String` describing the task (e.g., "Process report", "Send email to client").
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store jobs that are waiting to be processed (pending jobs). The queue should process jobs in First-In, First-Out (FIFO) order.
 *     *   Use a `java.util.ArrayList` to store jobs that have been successfully processed (completed jobs).
 *     *   Declare the variable holding the completed jobs list using the `java.util.List` interface type.
 * 3.  **User Interface:**
 *     *   The system should present a menu to the user with options:
 *         1.  Add New Job
 *         2.  Process Next Job
 *         3.  List Pending Jobs
 *         4.  List Completed Jobs
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read the user's menu choice and any necessary input (like the job description).
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   The system should loop, presenting the menu and processing commands until the user chooses to exit.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and lists of jobs.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, attempting to process a job when the queue is empty, invalid input format).
 * 5.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's a valid number within the range of options).
 *     *   Implement validation for the job description when adding a job (ensure it's not empty).
 *     *   Handle the case where the user attempts to process a job when the pending queue is empty.
 *     *   Include class-wide exception handling using `try-catch` blocks to catch potential issues like non-integer input for the menu choice or other unexpected runtime errors during the main command loop.
 * 6.  **Best Practices:**
 *     *   Organize the code within a single class (`JobQueueSystem` or similar).
 *     *   Use private fields for the data structures and scanner.
 *     *   Implement public methods for the core operations (add, process, list, etc.) to demonstrate encapsulation (though a single class structure might limit the full scope of this, aim for logical separation into methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic or requirements.
 *     *   Ensure the `Scanner` resource is properly closed upon exiting the application.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Job Queue System Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Pending Jobs
 * 4. List Completed Jobs
 * 5. Exit
 * Enter your choice: [User Input]
 * 
 * // Based on choice, output will vary:
 * // Add New Job:
 * Enter job description: [User Input]
 * Job added: [Job Description]
 * 
 * // Process Next Job:
 * Processing job: [Job Description]
 * Job completed.
 * // OR (if queue empty):
 * Error: No pending jobs to process. (via System.err)
 * 
 * // List Pending Jobs:
 * --- Pending Jobs ---
 * [Job 1]
 * [Job 2]
 * ...
 * (Or "No pending jobs." if empty)
 * 
 * // List Completed Jobs:
 * --- Completed Jobs ---
 * [Job 1]
 * [Job 2]
 * ...
 * (Or "No completed jobs." if empty)
 * 
 * // Invalid Choice or Input Error:
 * Error: Invalid input. Please enter a number between 1 and 5. (via System.err)
 * Error: Invalid input. Please enter a valid integer choice. (via System.err - for non-integer)
 * Error: Job description cannot be empty. (via System.err)
 * 
 * // Exit:
 * Exiting Job Queue System.
 * ```
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Job Queue System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Scenario Simulation:** The program simulates a basic system where tasks (jobs) are added to a queue and processed in order, then moved to a list of completed tasks. This is a common pattern in task processing or workflow systems.
 * 
 * 2.  **Required Java Components:**
 *     *   **`Queue`**: The `pendingJobs` field is declared as a `Queue<String>` and initialized with `new LinkedList<>()`. A `Queue` is chosen because jobs need to be processed in the order they are added (FIFO). `LinkedList` is a suitable implementation for a queue. The `offer()` method is used to add jobs, and `poll()` is used to remove and retrieve the head of the queue.
 *     *   **`ArrayList`**: The `completedJobs` list is initialized with `new ArrayList<>()`. `ArrayList` provides a dynamic array to store completed jobs, allowing easy addition (`add()`) and iteration.
 *     *   **`List`**: The `completedJobs` field is declared with the interface type `List<String>`, even though it's instantiated as an `ArrayList`. This is a best practice that promotes flexibility; if we later decided to change the implementation (e.g., to `LinkedList` or another `List` type), only the instantiation line would need to change, not the type declaration or the methods that use the `List` interface.
 *     *   **`Scanner`**: The `scanner` field is used to read user input from `System.in`. It's initialized in the constructor and used within the `run()` method and `addNewJob()` to read menu choices and job descriptions.
 *     *   **`switch`**: The `switch (choice)` statement in the `run()` method is used to direct the program flow based on the user's integer input, executing the corresponding method for each menu option.
 *     *   **`System.err`**: Used specifically for printing error messages, such as invalid menu choices, non-integer input, empty job descriptions, or attempting to process an empty queue. This visually distinguishes errors from normal output.
 *     *   **`System.out`**: Used for all standard output, including the menu display, prompts, success messages, and listing the jobs.
 *     *   **`try-catch`**: A large `try-catch` block is wrapped around the core command processing logic within the `run()` method.
 *         *   It specifically catches `InputMismatchException` to handle cases where the user enters non-integer input for the menu choice, preventing the program from crashing and prompting the user to try again. `scanner.next()` is called within the catch block to consume the invalid input token.
 *         *   A general `catch (Exception e)` block is included as a class-wide handler to catch any other unexpected runtime errors that might occur during the execution loop, printing an error message and the stack trace before exiting gracefully.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** The data structures (`pendingJobs`, `completedJobs`, `scanner`) are declared as `private` fields within the `JobQueueSystem` class. Access and modification are done through the class's public or private methods (`addNewJob`, `processNextJob`, `listPendingJobs`, `listCompletedJobs`, `run`).
 *     *   **Meaningful Names:** Variable names (`pendingJobs`, `completedJobs`, `jobDescription`, `choice`) and method names (`displayMenu`, `addNewJob`, `processNextJob`, `listPendingJobs`, `listCompletedJobs`, `run`) are descriptive and indicate their purpose.
 *     *   **Comments:** Comments are included to explain the purpose of the class, fields, methods, and specific code sections (like why `LinkedList` is used for the queue or the purpose of `scanner.nextLine()` after `nextInt()`).
 *     *   **Input Validation:**
 *         *   The `switch` statement's `default` case handles invalid integer inputs outside the 1-5 range.
 *         *   The `InputMismatchException` catch block handles non-integer inputs.
 *         *   The `addNewJob()` method explicitly checks if the `jobDescription` is empty or contains only whitespace using `.trim().isEmpty()`.
 *     *   **Error Handling:** As detailed in point 2, multiple levels of error handling are implemented using `if` conditions, `switch default`, `System.err`, and `try-catch` blocks.
 *     *   **Clean Code Structure:** The code is organized into a class with separate methods for distinct functionalities, making it more readable and maintainable. The main logic is contained within the `run()` method, called from `main()`.
 *     *   **Resource Management:** The `scanner.close()` method is called after the main loop finishes (when the user chooses to exit), releasing the system resource associated with the `Scanner`.
 * 
 * This solution effectively integrates the required Java components into a functional system while adhering to important programming principles, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A simple command-line application simulating a job processing queue.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch,
 * System.err, System.out, and try-catch for exception handling.
 */
public class JobQueueSystem {

    // Use Queue for pending jobs (FIFO)
    private Queue<String> pendingJobs;

    // Use List/ArrayList for completed jobs
    private List<String> completedJobs;

    // Scanner for user input
    private Scanner scanner;

    /**
     * Constructor to initialize the job queues and scanner.
     */
    public JobQueueSystem() {
        pendingJobs = new LinkedList<>(); // LinkedList is a common Queue implementation
        completedJobs = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Job Queue System Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. List Pending Jobs");
        System.out.println("4. List Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new job to the pending queue.
     * Validates that the job description is not empty.
     */
    private void addNewJob() {
        System.out.print("Enter job description: ");
        scanner.nextLine(); // Consume the newline character left by nextInt()
        String jobDescription = scanner.nextLine().trim();

        if (jobDescription.isEmpty()) {
            System.err.println("Error: Job description cannot be empty.");
        } else {
            pendingJobs.offer(jobDescription); // offer is preferred over add for queues
            System.out.println("Job added: " + jobDescription);
        }
    }

    /**
     * Processes the next job from the pending queue.
     * Moves the job to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void processNextJob() {
        String nextJob = pendingJobs.poll(); // poll retrieves and removes the head of the queue, returns null if empty

        if (nextJob == null) {
            System.err.println("Error: No pending jobs to process.");
        } else {
            System.out.println("Processing job: " + nextJob);
            completedJobs.add(nextJob);
            System.out.println("Job completed.");
        }
    }

    /**
     * Lists all jobs currently in the pending queue.
     */
    private void listPendingJobs() {
        System.out.println("\n--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (String job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Lists all jobs currently in the completed list.
     */
    private void listCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No completed jobs.");
        } else {
            // Iterate through the list
            int index = 1;
            for (String job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Runs the main application loop, displaying the menu and handling user input.
     * Includes class-wide try-catch for general error handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();

            try {
                choice = scanner.nextInt();

                switch (choice) {
                    case 1:
                        addNewJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        listPendingJobs();
                        break;
                    case 4:
                        listCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Job Queue System.");
                        break;
                    default:
                        System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a valid integer choice.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
                choice = 5; // Exit on unexpected error
            }
        }

        // Close the scanner resource when exiting the loop
        scanner.close();
        System.out.println("Scanner closed.");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        JobQueueSystem system = new JobQueueSystem();
        system.run();
    }
}
