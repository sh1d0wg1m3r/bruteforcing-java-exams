/*
 * Exam Question #949
 * Generated on: 2025-05-12 17:04:01
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Exam Question:** Advanced Java Programming - Help Desk Ticket Management System
 * 
 * **Scenario:**
 * Develop a simplified command-line application to simulate a Help Desk Ticket Management System. The system should allow users (simulating agents or administrators) to add new support tickets, process the oldest pending ticket, and view the status of all tickets. Pending tickets are processed in the order they are received. Completed tickets are moved to an archive.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` (specifically implemented by `java.util.LinkedList`) to manage tickets that are pending and waiting to be processed.
 *     *   Use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store tickets that have been processed and archived.
 * 
 * 2.  **Ticket Class:**
 *     *   Create a `Ticket` class with private fields: `id` (int, unique identifier), `description` (String), and `status` (String, e.g., "Pending", "Completed").
 *     *   Include a constructor to initialize a ticket with an ID and description, setting the initial status to "Pending".
 *     *   Provide public getter methods for all fields.
 *     *   Include a public method `markCompleted()` to change the ticket's status to "Completed".
 *     *   Override the `toString()` method to provide a user-friendly string representation of the ticket (e.g., "Ticket #ID: Description [Status]").
 * 
 * 3.  **HelpDeskSystem Class:**
 *     *   Implement the main application logic within a `HelpDeskSystem` class.
 *     *   This class should manage the `Queue` of pending tickets and the `List` of archived tickets.
 *     *   Implement a command-line interface using `java.util.Scanner` to interact with the user.
 *     *   Use a `switch` statement to handle user menu choices.
 * 
 * 4.  **Functionality:**
 *     *   **Add New Ticket (Menu Option 1):**
 *         *   Prompt the user for a ticket description.
 *         *   Create a new `Ticket` object with a unique, auto-incrementing ID.
 *         *   Add the new ticket to the pending queue.
 *         *   Display a confirmation message using `System.out`.
 *         *   Validate that the description is not empty. If empty, display an error using `System.err` and do not add the ticket.
 *     *   **Process Next Pending Ticket (Menu Option 2):**
 *         *   Remove the ticket at the front of the pending queue using a Queue method that handles empty state gracefully (e.g., `poll()`).
 *         *   Call the `markCompleted()` method on the removed ticket.
 *         *   Add the completed ticket to the archived list.
 *         *   Display a confirmation message using `System.out`.
 *         *   If the pending queue is empty, display an error message using `System.err`.
 *     *   **List All Tickets (Menu Option 3):**
 *         *   Display all tickets currently in the system.
 *         *   List pending tickets first, then archived tickets.
 *         *   Use the `toString()` method of the `Ticket` class to display ticket details using `System.out`.
 *         *   Clearly indicate which list is being displayed (Pending or Archived).
 *     *   **Exit (Menu Option 4):**
 *         *   Terminate the application gracefully. Display an exit message using `System.out`.
 * 
 * 5.  **Error Handling:**
 *     *   Implement a class-wide exception handling mechanism using a `try-catch` block around the main application loop (`runSystem` method) to catch unexpected runtime errors.
 *     *   Specifically handle `java.util.InputMismatchException` if the user enters non-integer input for the menu choice, displaying an error using `System.err` and preventing the program from crashing or entering an infinite loop.
 *     *   Use `System.err` for all error messages (invalid input, operational errors like empty queue, validation errors).
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include brief comments where necessary to explain complex logic or purpose.
 *     *   Ensure a clean and readable code structure.
 *     *   Manage the `Scanner` resource properly (e.g., close it in a `finally` block).
 * 
 * **Expected Output:**
 * The application should start by displaying a menu. User interactions (adding, processing, listing) should result in appropriate output on `System.out`. Errors (invalid input, trying to process an empty queue, empty description) should be reported on `System.err`. Selecting the Exit option should terminate the program after a final message on `System.out`.
 *
 * EXPLANATION:
 * This solution implements a simple Help Desk Ticket Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:** This class encapsulates the data for a single ticket (`id`, `description`, `status`). It provides a constructor, public getters for accessing the data, and a `markCompleted()` method to change the status, adhering to encapsulation principles. The `toString()` method provides a convenient way to print ticket details.
 * 
 * 2.  **`HelpDeskSystem` Class:** This is the main class that orchestrates the system.
 *     *   **Data Structures:** It uses a `java.util.Queue<Ticket>` (`pendingTickets`) implemented by `java.util.LinkedList` to maintain the order of incoming tickets (First-In, First-Out). It uses a `java.util.List<Ticket>` (`archivedTickets`) implemented by `java.util.ArrayList` to store completed tickets. This fulfills the requirement of using both `Queue`, `List`, and `ArrayList`.
 *     *   **Functionality Methods:** Private methods (`displayMenu`, `addTicket`, `processNextTicket`, `listAllTickets`) handle the specific operations, promoting modularity and encapsulation of logic.
 *     *   **`Scanner` and `switch`:** The `runSystem` method uses `java.util.Scanner` to read user input from the console. A `switch` statement is used to direct the program flow based on the user's numeric menu choice, fulfilling these requirements.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for all standard output, such as the menu, confirmation messages, and ticket lists. `System.err.println()` is used specifically for displaying error messages, including input validation failures (empty description), operational errors (trying to process an empty queue), invalid menu choices, and unexpected system errors, meeting these requirements.
 * 
 * 3.  **Error Handling:**
 *     *   A `try-catch(InputMismatchException e)` block is specifically used inside the main loop to handle cases where the user enters non-integer input for the menu choice. This catches the specific exception thrown by `scanner.nextInt()`, prints an informative error message using `System.err`, consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop, and continues the loop to redisplay the menu.
 *     *   A broader `try-catch(Exception e)` block is wrapped around the entire `while` loop in `runSystem`. This serves as a class-wide exception handler, catching any other unexpected runtime exceptions that might occur during the execution of the main application logic, printing a general error message using `System.err`, and allowing for a more graceful termination or logging.
 *     *   Operational errors, such as attempting to process a ticket when the `pendingTickets` queue is empty, are explicitly checked (`pendingTickets.isEmpty()`) and reported using `System.err`.
 *     *   Input validation for the ticket description is performed, reporting errors via `System.err`.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in both `Ticket` and `HelpDeskSystem` are private, with controlled access via public methods where necessary.
 *     *   **Meaningful Names:** Variable names (`pendingTickets`, `archivedTickets`, `nextTicketId`), method names (`addTicket`, `processNextTicket`, `listAllTickets`, `runSystem`), and class names (`Ticket`, `HelpDeskSystem`) are descriptive.
 *     *   **Comments:** Basic comments are included to explain the purpose of classes, fields, and key methods.
 *     *   **Clean Structure:** The code is organized into logical classes and methods. The main application loop is contained within `runSystem`, making the `main` method simple.
 *     *   **Resource Management:** The `Scanner` resource is created at the beginning of `runSystem` and closed in a `finally` block, ensuring it is released even if an exception occurs.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrates robust error handling using `try-catch`, `System.err`, and input validation, and adheres to fundamental best practices for writing clean and maintainable Java code.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // For specific input error handling

// Represents a single help desk ticket
class Ticket {
    private int id;
    private String description;
    private String status;

    // Constructor to create a new ticket
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // New tickets start as Pending
    }

    // Public getters for ticket details
    public int getId() { return id; }
    public String getDescription() { return description; }
    public String getStatus() { return status; }

    // Method to mark the ticket as completed
    public void markCompleted() {
        this.status = "Completed";
    }

    // Override toString for easy printing of ticket details
    @Override
    public String toString() {
        return "Ticket #" + id + ": " + description + " [" + status + "]";
    }
}

// Main class for the Help Desk System
public class HelpDeskSystem {
    // Queue to hold tickets waiting to be processed (FIFO)
    private Queue<Ticket> pendingTickets;
    // List to hold tickets that have been processed (Archived)
    private List<Ticket> archivedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    // Constructor to initialize the system
    public HelpDeskSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.archivedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    // Displays the main menu options to the user
    private void displayMenu() {
        System.out.println("--- Help Desk Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. List All Tickets");
        System.out.println("4. Exit");
        System.out.println("----------------------");
    }

    // Adds a new ticket based on user input
    private void addTicket(Scanner scanner) {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine().trim(); // Read description and trim whitespace

        // Input validation: Description cannot be empty
        if (description.isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit the method if validation fails
        }

        // Create a new ticket with the next ID and add it to the pending queue
        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.offer(newTicket); // offer() is a safe way to add to queue

        System.out.println("Success: Ticket #" + newTicket.getId() + " added to the pending queue.");
    }

    // Processes the next ticket in the pending queue
    private void processNextTicket() {
        // Check if the pending queue is empty
        if (pendingTickets.isEmpty()) {
            System.err.println("Error: No pending tickets to process.");
            return; // Exit the method if queue is empty
        }

        // Remove the head of the queue (the oldest ticket)
        Ticket ticketToProcess = pendingTickets.poll(); // poll() returns null if empty, but we checked

        // Process the ticket if one was retrieved
        if (ticketToProcess != null) {
            ticketToProcess.markCompleted(); // Mark ticket as completed
            archivedTickets.add(ticketToProcess); // Move ticket to the archived list
            System.out.println("Success: Ticket #" + ticketToProcess.getId() + " processed and archived.");
        }
    }

    // Lists all tickets, pending and archived
    private void listAllTickets() {
        System.out.println("\n--- Ticket List ---");

        // List Pending Tickets
        System.out.println("--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("  No pending tickets.");
        } else {
            // Iterate and print each pending ticket
            for (Ticket ticket : pendingTickets) {
                System.out.println("  " + ticket);
            }
        }

        // List Archived Tickets
        System.out.println("\n--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("  No archived tickets.");
        } else {
            // Iterate and print each archived ticket
            for (Ticket ticket : archivedTickets) {
                System.out.println("  " + ticket);
            }
        }
        System.out.println("-------------------");
    }

    // Main method to run the help desk system
    public void runSystem() {
        Scanner scanner = new Scanner(System.in);
        // Class-wide exception handling for the main application loop
        try {
            // Main application loop
            while (true) {
                displayMenu(); // Show menu
                System.out.print("Enter your choice: ");

                int choice = -1;
                // Specific try-catch for handling non-integer input
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Input Error: Invalid input. Please enter a number from the menu.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement to handle menu choices
                switch (choice) {
                    case 1:
                        addTicket(scanner); // Pass scanner as it's needed for description input
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        listAllTickets();
                        break;
                    case 4:
                        System.out.println("Exiting Help Desk System. Goodbye!");
                        return; // Exit the runSystem method, effectively ending the program
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Input Error: Invalid menu choice. Please enter a number between 1 and 4.");
                }
                System.out.println(); // Add a newline for better output separation between interactions
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging: e.printStackTrace();
        } finally {
            // Ensure the scanner resource is closed regardless of how the system exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Entry point of the application
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.runSystem(); // Start the system
    }
}
