/*
 * Exam Question #433
 * Generated on: 2025-05-11 23:10:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting for processing, process the next task in line, and view tasks that have been completed.
 * 
 * Tasks arrive in a queue and are processed in a First-In, First-Out (FIFO) manner. Completed tasks should be stored separately. The system must be interactive, accepting commands from the user via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId`: An integer, automatically assigned and incrementing for each new task.
 *     *   `description`: A String describing the task.
 *     *   `priority`: An integer indicating the task's priority (a positive integer).
 *     *   Implement appropriate getters and a `toString()` method for easy display.
 * 
 * 2.  **Task Scheduler Class:** Create a `TaskScheduler` class that manages the tasks. It should contain:
 *     *   A `Queue` to hold tasks waiting for processing.
 *     *   A `List` to store completed tasks.
 *     *   Methods for the following operations:
 *         *   Adding a new task (takes description and priority as input, assigns next ID, adds to queue).
 *         *   Processing the next task (removes from queue, adds to completed list).
 *         *   Viewing the current task queue.
 *         *   Viewing completed tasks.
 *         *   A main loop to interact with the user via a menu.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options: Add Task, Process Next Task, View Queue, View Completed, Exit.
 *     *   Use a `switch` statement to handle the different menu choices.
 * 
 * 4.  **Data Structures:**
 *     *   Use `java.util.Queue` for the waiting tasks queue. A concrete implementation like `LinkedList` is suitable.
 *     *   Use `java.util.ArrayList` to store completed tasks, referencing it via the `java.util.List` interface.
 * 
 * 5.  **Input Validation & Error Handling:**
 *     *   Validate user input for priority (must be a positive integer).
 *     *   Handle cases where the user enters non-integer input when expecting a number.
 *     *   Handle attempts to process a task when the queue is empty.
 *     *   Use `System.err` to display error messages (e.g., invalid input, queue empty).
 *     *   Use `System.out` for all normal output (menu, task details, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during the main application loop.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially for methods and complex logic).
 *     *   Ensure resources like `Scanner` are managed correctly (e.g., using try-with-resources).
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, prompt for input, and perform actions based on the user's choice. Output should clearly indicate the action taken, task details, or error messages.
 * 
 * *   Adding a task: Prompt for description and priority, confirm task added.
 * *   Processing task: If queue is not empty, display processed task details. If empty, print an error to `System.err`.
 * *   Viewing queue: List tasks in the queue in order. Indicate if the queue is empty.
 * *   Viewing completed: List completed tasks. Indicate if no tasks are completed.
 * *   Invalid input: Print an error message to `System.err`.
 * *   Unexpected errors: Catch with `try-catch` and print a general error message to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Task Management Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Queue
 * 4. View Completed
 * 5. Exit
 * Enter choice: 1
 * Enter task description: Implement login
 * Enter priority (positive integer): 3
 * Task added: Task{id=1, description='Implement login', priority=3}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 1
 * Enter task description: Design UI
 * Enter priority (positive integer): 1
 * Task added: Task{id=2, description='Design UI', priority=1}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 3
 * Current Task Queue:
 * Task{id=1, description='Implement login', priority=3}
 * Task{id=2, description='Design UI', priority=1}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 2
 * Processing task: Task{id=1, description='Implement login', priority=3}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 3
 * Current Task Queue:
 * Task{id=2, description='Design UI', priority=1}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 4
 * Completed Tasks:
 * Task{id=1, description='Implement login', priority=3}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 2
 * Processing task: Task{id=2, description='Design UI', priority=1}
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 2
 * Error: Task queue is empty. No tasks to process. (Output to System.err)
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. (Output to System.err)
 * 
 * Task Management Menu:
 * ...
 * Enter choice: abc
 * Error: Invalid input. Please enter a number. (Output to System.err)
 * 
 * Task Management Menu:
 * ...
 * Enter choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Implement the system according to the requirements.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System adhering to all specified requirements.
 * 
 * 1.  **`Task` Class:** A simple POJO (Plain Old Java Object) representing a task with private fields (`taskId`, `description`, `priority`), a constructor, and public getter methods. The `toString()` method is overridden for easy printing of task details. This demonstrates **encapsulation** and basic object-oriented principles.
 * 
 * 2.  **`TaskScheduler` Class:** This is the core class managing the system state.
 *     *   It holds a `Queue<Task>` named `taskQueue` using a `LinkedList` implementation. `LinkedList` is a common choice for `Queue` as it efficiently supports adding to the tail (`offer`) and removing from the head (`poll`).
 *     *   It holds a `List<Task>` named `completedTasks` using an `ArrayList` implementation. `ArrayList` is suitable here as completed tasks are primarily stored and iterated over. Using `List` as the type for `completedTasks` demonstrates programming to the interface.
 *     *   `nextTaskId` is a private field ensuring each task gets a unique, incrementing ID.
 * 
 * 3.  **Methods:**
 *     *   `addTask(String description, int priority)`: Creates a new `Task` object with the next available ID, adds it to the `taskQueue` using `offer()`, and prints a confirmation to `System.out`. It includes basic validation for priority.
 *     *   `processNextTask()`: Checks if the `taskQueue` is empty using `isEmpty()`. If not, it removes the head of the queue using `poll()`, adds the task to the `completedTasks` list, and prints the processed task details to `System.out`. If the queue is empty, it prints an error to `System.err`.
 *     *   `viewTaskQueue()`: Iterates through the `taskQueue` (using a for-each loop, which doesn't remove elements) and prints each task to `System.out`. Indicates if the queue is empty.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` `List` and prints each task to `System.out`. Indicates if the list is empty.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   `run()`: This is the main application loop. It contains a `while` loop that continues until the user chooses to exit.
 * 
 * 4.  **User Interaction and Control Flow:**
 *     *   `Scanner` is used within a `try-with-resources` block in the `run()` method. This ensures the `Scanner` resource is automatically closed when the block is exited, preventing resource leaks.
 *     *   A `displayMenu()` method presents the options.
 *     *   The user's choice is read using `scanner.nextInt()`. A specific `try-catch(InputMismatchException)` block handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid token to prevent an infinite loop.
 *     *   A `switch` statement is used to direct the program flow based on the valid menu choice, calling the appropriate methods (`addTask`, `processNextTask`, etc.).
 *     *   Input for task details (description, priority) is handled within the `case 1` block. `scanner.nextLine()` is used for the description after consuming the newline left by `nextInt()`. Priority input also has its own `try-catch(InputMismatchException)` for validation.
 * 
 * 5.  **Error Handling:**
 *     *   Specific input validation is done for priority (`priority <= 0`).
 *     *   `InputMismatchException` is caught specifically when reading integer inputs (menu choice and priority) to handle non-numeric input.
 *     *   The `processNextTask()` method explicitly checks `taskQueue.isEmpty()` before attempting to `poll()`, preventing errors from processing an empty queue.
 *     *   `System.err` is used consistently for all error messages (invalid input, empty queue, unexpected errors).
 *     *   A broad `try-catch(Exception e)` block is wrapped around the main `while(running)` loop in the `run()` method. This serves as the **class-wide exception handling**, catching any unforeseen exceptions that might occur during the application's execution and printing a general error message and stack trace to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   All fields in `Task` and `TaskScheduler` are `private`, accessed via `public` methods, demonstrating **encapsulation**.
 *     *   Variable and method names are descriptive (e.g., `taskQueue`, `completedTasks`, `processNextTask`).
 *     *   Comments are included to explain the purpose of classes, methods, and key logic blocks.
 *     *   Input validation and specific error handling (`InputMismatchException`, `isEmpty()` check) are implemented.
 *     *   The `try-with-resources` statement for `Scanner` ensures proper resource management.
 *     *   The code is structured into logical classes (`Task`, `TaskScheduler`) with clear responsibilities.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, interactive application scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-integer input

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     *
     * @param taskId      The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority    The priority level of the task (positive integer).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string including task details.
     */
    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "', priority=" + priority + "}";
    }
}

/**
 * Manages the task queue and completed tasks.
 */
public class TaskScheduler { // Changed class name slightly to avoid conflict if TaskScheduler was the main class name
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskScheduler.
     * Initializes the task queue and completed tasks list.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the queue.
     *
     * @param description The description of the new task.
     * @param priority    The priority of the new task (positive integer).
     */
    public void addTask(String description, int priority) {
        if (priority <= 0) {
            System.err.println("Error: Priority must be a positive integer.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description, priority);
        taskQueue.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the queue and adds it to the completed list.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. No tasks to process.");
            return;
        }
        Task processedTask = taskQueue.poll(); // poll retrieves and removes the head of the queue
        completedTasks.add(processedTask);
        System.out.println("Processing task: " + processedTask);
    }

    /**
     * Displays the tasks currently in the waiting queue.
     */
    public void viewTaskQueue() {
        System.out.println("--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Queue");
        System.out.println("4. View Completed");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Class-wide try-catch block for the main application loop
            try {
                while (running) {
                    displayMenu();
                    int choice = -1; // Default invalid choice

                    // Input handling for menu choice
                    try {
                        choice = scanner.nextInt();
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip to the next iteration of the while loop
                    } finally {
                         // Consume the newline character left by nextInt()
                         // This is crucial before reading strings with nextLine()
                         if(scanner.hasNextLine()) {
                             scanner.nextLine();
                         }
                    }


                    // Use switch statement for menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine(); // Read the whole line
                            int priority = -1; // Default invalid priority

                            System.out.print("Enter priority (positive integer): ");
                            try {
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline after reading int
                                addTask(description, priority);
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input for priority. Please enter an integer.");
                                scanner.next(); // Consume the invalid input
                                // No need to consume newline here as we are ending this case
                            }
                            break;

                        case 2:
                            processNextTask();
                            break;

                        case 3:
                            viewTaskQueue();
                            break;

                        case 4:
                            viewCompletedTasks();
                            break;

                        case 5:
                            System.out.println("Exiting Task Management System.");
                            running = false; // Set flag to exit loop
                            break;

                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions within the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the Task Scheduler application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
