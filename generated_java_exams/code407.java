/*
 * Exam Question #407
 * Generated on: 2025-05-11 23:06:25
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for a restaurant's order management. The system needs to handle incoming customer orders, move them to an active preparation list, allow marking orders as completed, and provide views of the current order status.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must strictly adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold orders that have just been placed and are waiting for the kitchen to start preparing.
 *     *   Use a `java.util.List` (specifically, `java.util.ArrayList`) to hold orders that are currently being prepared or have been completed.
 * 
 * 2.  **Order Representation:**
 *     *   Create a class named `Order` to represent a single customer order.
 *     *   The `Order` class must have private fields for:
 *         *   `orderId` (an integer, unique identifier)
 *         *   `items` (a `List<String>` representing the food/drink items)
 *         *   `status` (a `String`, e.g., "Pending", "Preparing", "Completed")
 *     *   Include a constructor, public getter methods for all fields, and methods to add items and update the status.
 * 
 * 3.  **Order Management Logic:**
 *     *   Create a class named `RestaurantOrderManager` that encapsulates the `Queue` and `List` data structures and the logic for managing orders.
 *     *   Implement the following functionalities as public methods within `RestaurantOrderManager`:
 *         *   `placeOrder(List<String> items)`: Creates a new `Order` object with a unique ID, sets its status to "Pending", and adds it to the incoming orders `Queue`.
 *         *   `processNextIncomingOrder()`: Takes the next order from the incoming orders `Queue`, changes its status to "Preparing", and moves it to the active orders `List`. Handle the case where the queue is empty.
 *         *   `completeOrder(int orderId)`: Finds an order with the given ID in the active orders `List` and changes its status to "Completed". Handle the case where the order ID is not found.
 *         *   `viewAllOrders()`: Displays details (ID, items, status) of all orders currently in both the incoming `Queue` and the active `List`.
 *         *   `viewIncomingOrders()`: Displays details of orders only in the incoming `Queue`.
 *         *   `viewActiveOrders()`: Displays details of orders only in the active `List`.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user (e.g., Place Order, Process Next, Complete Order, View All, View Incoming, View Active, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice and call the appropriate methods of `RestaurantOrderManager`.
 * 
 * 5.  **Error Handling:**
 *     *   Implement comprehensive exception handling using `try-catch` blocks.
 *     *   Handle potential issues such as:
 *         *   Invalid input format from the user (e.g., entering text when an integer is expected).
 *         *   Attempting to process an order when the incoming queue is empty.
 *         *   Attempting to complete an order with an invalid or non-existent ID.
 *     *   Use `System.err` to print error messages.
 *     *   Use `System.out` for all normal output (menu, prompts, order details, success messages).
 * 
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods) in both `Order` and `RestaurantOrderManager`.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs where applicable).
 *     *   Validate user input where necessary (e.g., menu choice range, order ID existence).
 *     *   Structure the code cleanly into classes and methods.
 * 
 * **Execution:**
 * 
 * The program should start by displaying the menu. The user interacts by entering numbers corresponding to menu options. The program should continue running until the user selects the "Exit" option.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. Place Order
 * 2. Process Next Incoming Order
 * 3. Complete Order
 * 4. View All Orders
 * 5. View Incoming Orders
 * 6. View Active Orders
 * 7. Exit
 * Enter your choice: 1
 * Enter items for the order (comma-separated, e.g., Burger,Fries,Coke): Pizza,Salad
 * Order placed with ID: 1
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 5
 * --- Incoming Orders ---
 * Order ID: 1, Items: [Pizza, Salad], Status: Pending
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 2
 * Order 1 moved to preparation.
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 6
 * --- Active Orders ---
 * Order ID: 1, Items: [Pizza, Salad], Status: Preparing
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 3
 * Enter Order ID to complete: 1
 * Order 1 marked as Completed.
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 6
 * --- Active Orders ---
 * Order ID: 1, Items: [Pizza, Salad], Status: Completed
 * 
 * --- Restaurant Order Management ---
 * ... (menu again)
 * Enter your choice: 7
 * Exiting system.
 * ```
 * 
 * **Deliverables:**
 * 
 * Provide the complete, runnable Java code for the `Order` and `RestaurantOrderManager` classes (or a single class containing both if preferred for exam simplicity, but maintain the logical separation and encapsulation).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Proper implementation of the required functionalities.
 * *   Effective error handling and input validation.
 * *   Adherence to encapsulation and code structure best practices.
 * *   Clarity and readability of the code and comments.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Restaurant Order Management System using the required Java components and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Order` Class:**
 *     *   This class models a single order with `orderId`, `items` (a `List<String>`), and `status` (a `String`).
 *     *   It uses private fields and public getter methods (`getOrderId`, `getItems`, `getStatus`) to enforce **encapsulation**.
 *     *   The `getItems()` method returns a *copy* of the items list (`new ArrayList<>(items)`) to prevent external code from modifying the order's items directly, further enhancing encapsulation.
 *     *   It includes a `setStatus` method to allow changing the order's status.
 *     *   The `toString()` method provides a convenient string representation for printing order details.
 * 
 * 2.  **`RestaurantOrderManager` Class:**
 *     *   This is the main class containing the application logic and data structures.
 *     *   It holds two key data structures as private fields:
 *         *   `incomingOrders`: A `Queue<Order>` implemented using `LinkedList`. This queue follows the FIFO (First-In, First-Out) principle, perfect for orders waiting to be picked up by the kitchen.
 *         *   `activeOrders`: A `List<Order>` implemented using `ArrayList`. This list holds orders currently being prepared or already completed, allowing easy iteration and lookup (though lookup by ID is done via iteration in this simple version).
 *     *   `nextOrderId`: A static integer is used to generate unique IDs for each new order.
 *     *   **Encapsulation:** The collections (`incomingOrders`, `activeOrders`) are private, and all operations on them are exposed through public methods (`placeOrder`, `processNextIncomingOrder`, etc.).
 * 
 * **Required Component Usage:**
 * 
 * *   **`Queue` (`java.util.Queue`)**: Used for `incomingOrders`. The `offer()` method adds new orders to the tail, and `poll()` retrieves and removes the next order from the head, simulating the kitchen taking the next order in line.
 * *   **`ArrayList` (`java.util.ArrayList`)**: Used as the concrete implementation for the `activeOrders` `List`. Orders are added to this list once they move from the incoming queue (`add()` method).
 * *   **`List` interface (`java.util.List`)**: `activeOrders` is declared using the `List` interface type, promoting flexibility (could easily change to `LinkedList` later if needed) and adhering to good practice (program to interfaces). The `items` field in the `Order` class is also declared as `List<String>`.
 * *   **`Scanner` (`java.util.Scanner`)**: Used in the `main` method to read user input from `System.in` (console). It reads integers for menu choices and order IDs, and lines for order items.
 * *   **`switch` statement**: Used in the `main` method to direct program flow based on the user's integer menu choice, calling the appropriate `RestaurantOrderManager` methods.
 * *   **`System.err`**: Used to print error messages (e.g., invalid input, order not found, queue empty). This directs error output to the standard error stream, which is good practice for separating normal output from errors.
 * *   **`System.out`**: Used for all normal program output, including the menu, prompts, success messages, and order details.
 * *   **`try-catch` blocks**: Implemented in the `main` method to handle potential exceptions:
 *     *   An outer `try-catch` handles general exceptions during the main loop execution.
 *     *   An inner `try-catch` specifically handles `InputMismatchException` when reading integer inputs (menu choice, order ID), preventing the program from crashing if the user enters non-numeric text. It also includes a general `Exception` catch for unexpected errors during operations.
 *     *   The `processNextIncomingOrder` method implicitly handles an empty queue by checking if `poll()` returns `null`.
 *     *   The `completeOrder` method explicitly checks if the order was found before attempting to update its status.
 * 
 * **Functionality and Logic:**
 * 
 * *   **Placing an Order:** The user enters items (comma-separated string), which is split into a `List<String>`. A new `Order` object is created with a unique ID and "Pending" status and added to the `incomingOrders` queue.
 * *   **Processing Next:** The `processNextIncomingOrder` method polls the `incomingOrders` queue. If successful, the order's status is changed to "Preparing", and it's added to the `activeOrders` list. If the queue is empty, an error message is printed to `System.err`.
 * *   **Completing an Order:** The user enters an order ID. The `completeOrder` method iterates through the `activeOrders` list to find the matching order. If found, its status is updated to "Completed". If not found, an error is printed to `System.err`.
 * *   **Viewing Orders:** Methods are provided to iterate and print details of orders in the incoming queue, active list, or both.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Strictly applied in both `Order` and `RestaurantOrderManager`.
 * *   **Meaningful Names:** Classes, variables, and methods have descriptive names (e.g., `incomingOrders`, `processNextIncomingOrder`, `placeOrder`).
 * *   **Comments and Documentation:** JavaDocs are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic.
 * *   **Input Validation:** Checks are made for empty item input when placing an order. `InputMismatchException` is caught for invalid numeric input. Existence checks are performed before attempting to complete an order.
 * *   **Error Handling:** `try-catch` blocks are used effectively to manage exceptions and provide informative error messages via `System.err`. The `finally` block ensures the `Scanner` is closed.
 * *   **Clean Code Structure:** The code is organized into logical classes, and the `main` method handles the user interaction loop separately from the core management logic within `RestaurantOrderManager`.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating an understanding of data structures, object-oriented principles, user interaction handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Arrays;

/**
 * Represents a single customer order in the restaurant system.
 */
class Order {
    private int orderId;
    private List<String> items;
    private String status; // e.g., "Pending", "Preparing", "Completed"

    /**
     * Constructs a new Order.
     * @param orderId The unique identifier for the order.
     * @param items The list of items in the order.
     */
    public Order(int orderId, List<String> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a copy to ensure encapsulation
        this.status = "Pending"; // Default status
    }

    // --- Getters ---

    public int getOrderId() {
        return orderId;
    }

    public List<String> getItems() {
        return new ArrayList<>(items); // Return a copy to prevent external modification
    }

    public String getStatus() {
        return status;
    }

    // --- Setters / Status Update ---

    /**
     * Updates the status of the order.
     * @param status The new status (e.g., "Preparing", "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Items: " + items + ", Status: " + status;
    }
}

/**
 * Manages the flow of orders through the restaurant system.
 */
public class RestaurantOrderManager { // Using public class for main method access

    // Using LinkedList for Queue implementation as it's efficient for add/remove from ends
    private Queue<Order> incomingOrders;
    // Using ArrayList for active orders as we might need to iterate or access by index (though not strictly required by problem, it's common)
    private List<Order> activeOrders;

    private static int nextOrderId = 1; // Static to generate unique IDs across all orders

    /**
     * Constructs a new RestaurantOrderManager.
     */
    public RestaurantOrderManager() {
        this.incomingOrders = new LinkedList<>();
        this.activeOrders = new ArrayList<>();
    }

    /**
     * Places a new order by adding it to the incoming orders queue.
     * @param items The list of items for the order.
     */
    public void placeOrder(List<String> items) {
        if (items == null || items.isEmpty()) {
             System.err.println("Error: Cannot place an order with no items.");
             return;
        }
        Order newOrder = new Order(nextOrderId++, items);
        incomingOrders.offer(newOrder); // offer is preferred over add for queues (returns false on failure)
        System.out.println("Order placed with ID: " + newOrder.getOrderId());
    }

    /**
     * Moves the next pending order from the incoming queue to the active list
     * and updates its status to "Preparing".
     */
    public void processNextIncomingOrder() {
        Order nextOrder = incomingOrders.poll(); // poll retrieves and removes the head of the queue
        if (nextOrder != null) {
            nextOrder.setStatus("Preparing");
            activeOrders.add(nextOrder);
            System.out.println("Order " + nextOrder.getOrderId() + " moved to preparation.");
        } else {
            System.err.println("Error: No incoming orders to process.");
        }
    }

    /**
     * Finds an order in the active list by its ID and updates its status to "Completed".
     * @param orderId The ID of the order to complete.
     */
    public void completeOrder(int orderId) {
        boolean found = false;
        // Iterate through active orders to find the one with the matching ID
        for (Order order : activeOrders) {
            if (order.getOrderId() == orderId) {
                order.setStatus("Completed");
                System.out.println("Order " + orderId + " marked as Completed.");
                found = true;
                break; // Found the order, no need to continue searching
            }
        }
        if (!found) {
            System.err.println("Error: Order with ID " + orderId + " not found in active orders.");
        }
    }

    /**
     * Displays details of all orders in both incoming and active lists.
     */
    public void viewAllOrders() {
        System.out.println("--- All Orders ---");
        if (incomingOrders.isEmpty() && activeOrders.isEmpty()) {
            System.out.println("No orders in the system.");
            return;
        }

        System.out.println("--- Incoming Orders ---");
        if (incomingOrders.isEmpty()) {
            System.out.println("  (None)");
        } else {
            for (Order order : incomingOrders) {
                System.out.println("  " + order);
            }
        }

        System.out.println("--- Active Orders ---");
        if (activeOrders.isEmpty()) {
            System.out.println("  (None)");
        } else {
            for (Order order : activeOrders) {
                 // Could potentially filter out completed orders here if desired,
                 // but requirement is to show all in active list.
                System.out.println("  " + order);
            }
        }
    }

     /**
     * Displays details of orders only in the incoming queue.
     */
    public void viewIncomingOrders() {
        System.out.println("--- Incoming Orders ---");
        if (incomingOrders.isEmpty()) {
            System.out.println("  (None)");
        } else {
            for (Order order : incomingOrders) {
                System.out.println("  " + order);
            }
        }
    }

    /**
     * Displays details of orders only in the active list.
     */
    public void viewActiveOrders() {
        System.out.println("--- Active Orders ---");
        if (activeOrders.isEmpty()) {
            System.out.println("  (None)");
        } else {
            for (Order order : activeOrders) {
                System.out.println("  " + order);
            }
        }
    }


    /**
     * Main method to run the restaurant order management system.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantOrderManager manager = new RestaurantOrderManager();
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Outer try-catch for general exceptions during the main loop
        try {
            while (choice != 7) {
                printMenu();

                // Inner try-catch for handling input specific exceptions
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1: // Place Order
                            System.out.print("Enter items for the order (comma-separated, e.g., Burger,Fries,Coke): ");
                            String itemsInput = scanner.nextLine().trim();
                            if (itemsInput.isEmpty()) {
                                System.err.println("Error: No items entered.");
                            } else {
                                List<String> items = Arrays.asList(itemsInput.split("\\s*,\\s*"));
                                manager.placeOrder(items);
                            }
                            break;
                        case 2: // Process Next Incoming Order
                            manager.processNextIncomingOrder();
                            break;
                        case 3: // Complete Order
                            System.out.print("Enter Order ID to complete: ");
                            // Inner try-catch specifically for the integer input of Order ID
                            try {
                                int orderIdToComplete = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                manager.completeOrder(orderIdToComplete);
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid input. Please enter a valid integer for Order ID.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;
                        case 4: // View All Orders
                            manager.viewAllOrders();
                            break;
                        case 5: // View Incoming Orders
                            manager.viewIncomingOrders();
                            break;
                        case 6: // View Active Orders
                            manager.viewActiveOrders();
                            break;
                        case 7: // Exit
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a valid integer for the menu choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any exception that might escape the inner try-catch blocks
            System.err.println("A critical error occurred: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Ensure scanner is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Restaurant Order Management ---");
        System.out.println("1. Place Order");
        System.out.println("2. Process Next Incoming Order");
        System.out.println("3. Complete Order");
        System.out.println("4. View All Orders");
        System.out.println("5. View Incoming Orders");
        System.out.println("6. View Active Orders");
        System.out.println("7. Exit");
    }
}
