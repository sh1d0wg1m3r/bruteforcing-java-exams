/*
 * Exam Question #1087
 * Generated on: 2025-05-12 17:23:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Warehouse Inventory & Order Fulfillment System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified warehouse management system. This system should allow managing inventory, accepting customer orders, and processing those orders based on available stock. The system will operate via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java program file (`WarehouseSystem.java`) and must demonstrate proficiency in using the following Java components and best practices:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to hold incoming customer orders awaiting processing.
 *     *   Use `java.util.ArrayList` to store the list of items in the warehouse inventory.
 *     *   Use the `java.util.List` interface type when declaring variables that hold `ArrayList` instances (e.g., `List<Item> inventory = new ArrayList<>();`).
 * 
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands and input from the console (`System.in`).
 *     *   Use `System.out.println()` for displaying menus, prompts, inventory lists, and successful operation messages.
 *     *   Use `System.err.println()` for displaying all error messages (e.g., invalid input, insufficient stock, item not found).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands selected from the main menu.
 * 
 * 4.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensuring quantities are positive integers).
 *     *   Use `try-catch` blocks for exception handling, particularly for potential `NumberFormatException` during input parsing.
 *     *   Implement "class-wide" exception handling by wrapping the main command processing loop in a `try-catch` block to catch unexpected runtime errors and prevent the program from crashing abruptly.
 *     *   Handle business logic errors gracefully (e.g., attempting to process an order with insufficient stock).
 * 
 * 5.  **Object-Oriented Principles:**
 *     *   Design appropriate classes (`Item`, `Warehouse`, `Order`, `OrderProcessor`, and the main application class).
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments and documentation (e.g., class purpose, method descriptions).
 * 
 * **Functionality:**
 * 
 * The system should support the following commands via the console:
 * 
 * *   `add_item`: Prompts for item ID (String), name (String), and initial quantity (int). Adds the item to the warehouse inventory. If an item with the same ID already exists, update its quantity.
 * *   `view_inventory`: Displays the current list of items in the warehouse inventory, including ID, name, and quantity.
 * *   `place_order`: Prompts for an order ID (String). Then, repeatedly prompts the user to enter item IDs and quantities for the order. The user should be able to enter multiple items for one order. A specific input (e.g., entering "done" for item ID) should signal the end of adding items to the order. Creates an `Order` object and adds it to the order queue.
 * *   `process_order`: Takes the next order from the queue and attempts to fulfill it. For an order to be fulfilled, *all* requested items must be available in sufficient quantity in the warehouse.
 *     *   If fulfillment is successful: Deduct the quantities from the inventory, remove the order from the queue, and print a success message (`System.out`).
 *     *   If fulfillment fails (due to insufficient stock for *any* item): Do *not* deduct any quantities from the inventory, remove the order from the queue, and print a failure message (`System.err`) indicating which item(s) caused the failure.
 * *   `view_orders`: Displays the list of order IDs currently in the processing queue.
 * *   `exit`: Terminates the program.
 * 
 * **Expected Output:**
 * 
 * The program should provide clear prompts for input, display information formatted cleanly, and use `System.out` for normal operation messages/data and `System.err` for all error conditions.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add Item
 * 2. View Inventory
 * 3. Place Order
 * 4. Process Next Order
 * 5. View Order Queue
 * 6. Exit
 * Enter command number: 1
 * Enter Item ID: A101
 * Enter Item Name: Laptop
 * Enter Initial Quantity: 5
 * Item A101 (Laptop) added/updated.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 1
 * Enter Item ID: B202
 * Enter Item Name: Mouse
 * Enter Initial Quantity: 10
 * Item B202 (Mouse) added/updated.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 2
 * --- Current Inventory ---
 * ID: A101, Name: Laptop, Quantity: 5
 * ID: B202, Name: Mouse, Quantity: 10
 * -------------------------
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 3
 * Enter Order ID: ORD001
 * Enter Item ID for order (or 'done' to finish): A101
 * Enter Quantity for A101: 2
 * Enter Item ID for order (or 'done' to finish): B202
 * Enter Quantity for B202: 3
 * Enter Item ID for order (or 'done' to finish): done
 * Order ORD001 placed and added to queue.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 5
 * --- Pending Orders ---
 * Order ID: ORD001
 * --------------------
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 4
 * Processing Order ORD001...
 * Order ORD001 fulfilled successfully. Inventory updated.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 2
 * --- Current Inventory ---
 * ID: A101, Name: Laptop, Quantity: 3
 * ID: B202, Name: Mouse, Quantity: 7
 * -------------------------
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 3
 * Enter Order ID: ORD002
 * Enter Item ID for order (or 'done' to finish): A101
 * Enter Quantity for A101: 5  <-- Requesting more than available (3)
 * Enter Item ID for order (or 'done' to finish): done
 * Order ORD002 placed and added to queue.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 4
 * Processing Order ORD002...
 * Error: Order ORD002 failed to fulfill due to insufficient stock. Item A101 requires 5 but only 3 available.
 * Order ORD002 removed from queue.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 5
 * --- Pending Orders ---
 * (Queue is empty)
 * --------------------
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter command number: 6
 * Exiting system.
 * ```
 * 
 * **Grading Rubric Focus:**
 * 
 * *   Correct usage of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Implementation of all required functionality.
 * *   Proper error handling and input validation.
 * *   Adherence to object-oriented principles and best practices (encapsulation, naming, structure).
 * *   Code clarity and readability.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the requested Warehouse Inventory & Order Fulfillment System, incorporating all specified Java components and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `OrderProcessor` class uses a `Queue<Order>` (`orderQueue`) to manage incoming orders. `LinkedList` is chosen as the concrete implementation because it provides efficient `offer()` (add to end) and `poll()` (remove from front) operations required for queue behavior. `peek()` is used to look at the next order without removing it during the processing check.
 * 2.  **`java.util.ArrayList`:** The `Warehouse` class uses an `ArrayList<Item>` (`inventory`) to store the list of items currently in stock. The `Order` class uses an `ArrayList<Item>` (`requestedItems`) to store the list of items and quantities requested in that specific order.
 * 3.  **`java.util.List` interface:** The `inventory` field in `Warehouse` and `requestedItems` field in `Order` are declared using the `List` interface type (`List<Item>`) while being initialized with `ArrayList`. This follows best practice by programming to the interface rather than the concrete implementation.
 * 4.  **`java.util.Scanner`:** The `main` method in `WarehouseSystem` uses a `Scanner` object (`scanner`) to read user input from `System.in` for commands and data like item details or order items.
 * 5.  **`switch` statement:** The `main` method uses a `switch` statement based on the integer command entered by the user to direct the program flow to the appropriate handler method (`handleAddItem`, `handlePlaceOrder`, or direct calls to `Warehouse` and `OrderProcessor` methods).
 * 6.  **`System.err`:** `System.err.println()` is used exclusively for displaying error messages. This includes messages for invalid command numbers, `NumberFormatException` during input parsing, `IllegalArgumentException` caught from constructors/methods due to invalid data (like negative quantities or empty IDs), and failure messages during order processing (e.g., insufficient stock).
 * 7.  **`System.out`:** `System.out.println()` is used for all normal output, such as the menu, prompts, successful operation confirmations (item added/updated, order placed, order fulfilled), and the inventory and order queue listings.
 * 8.  **`try-catch` blocks:**
 *     *   A large `try-catch (Exception e)` block wraps the core `switch` statement inside the `while(running)` loop in the `main` method. This provides "class-wide" handling for any unexpected runtime exceptions that might occur during the execution of a command, preventing the program from crashing and allowing the loop to continue.
 *     *   Specific `catch (NumberFormatException e)` blocks are used when parsing integer input (like quantity) to handle cases where the user enters non-numeric text.
 *     *   Specific `catch (IllegalArgumentException e)` blocks are used around calls that might throw this exception (like `Item` or `Order` constructors) to catch validation errors and report them gracefully.
 *     *   The `handleAddItem` and `handlePlaceOrder` methods also contain `try-catch` blocks specifically for input parsing and validation errors related to those operations, providing more localized error reporting before potentially falling back to the main loop's general catch.
 * 
 * **Object-Oriented Design and Best Practices:**
 * 
 * *   **Encapsulation:** Fields in classes (`Item`, `Warehouse`, `Order`, `OrderProcessor`) are declared as `private`. Access and modification are controlled via `public` getter and setter methods (`Item::getQuantity`, `Item::setQuantity`).
 * *   **Meaningful Names:** Classes (`Item`, `Warehouse`, `Order`, `OrderProcessor`), variables (`inventory`, `orderQueue`, `requestedItems`, `orderId`), and methods (`addItem`, `findItemById`, `checkStock`, `processNextOrder`, `handlePlaceOrder`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Basic comments explain the purpose of classes and key methods. Javadoc-style comments are used for method descriptions where helpful.
 * *   **Input Validation:** Validation is performed at the point where data is used or constructed. For example, the `Item` constructor validates quantity and ID/name, and the `Order` constructor validates ID and the item list. Input parsing errors (`NumberFormatException`) are caught.
 * *   **Error Handling:** As detailed above, multiple layers of error handling are implemented, from specific input validation catches to a general catch in the main loop, using `System.err` for clear error reporting. Business logic errors like insufficient stock are checked explicitly in `Warehouse::checkStock` before attempting modification.
 * *   **Clean Code Structure:** The code is divided into logical classes, each responsible for a specific part of the system. The `main` method acts as a controller, delegating tasks to the appropriate objects. Helper methods (`printMenu`, `handleAddItem`, `handlePlaceOrder`) keep the `main` method clean. The order processing logic (`OrderProcessor::processNextOrder`) checks stock *before* deducting to ensure atomicity for the order fulfillment attempt.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, structured, and error-resilient manner suitable for an advanced programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Optional; // Used for finding items

// Represents an item in the warehouse or requested in an order
class Item {
    private String id;
    private String name;
    private int quantity;

    // Constructor for inventory items
    public Item(String id, String name, int quantity) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Item ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Item name cannot be null or empty.");
        }
        if (quantity < 0) {
             throw new IllegalArgumentException("Item quantity cannot be negative.");
        }
        this.id = id.trim();
        this.name = name.trim();
        this.quantity = quantity;
    }

    // Constructor for items requested in an order (name might be null, quantity is needed)
     public Item(String id, int quantity) {
         if (id == null || id.trim().isEmpty()) {
             throw new IllegalArgumentException("Item ID cannot be null or empty.");
         }
         if (quantity <= 0) {
              throw new IllegalArgumentException("Requested quantity must be positive.");
         }
         this.id = id.trim();
         this.name = null; // Name is not required for order items
         this.quantity = quantity;
     }


    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
         if (quantity < 0) {
             throw new IllegalArgumentException("Item quantity cannot be negative.");
         }
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        // Display name only if available (for inventory)
        return "ID: " + id + (name != null ? ", Name: " + name : "") + ", Quantity: " + quantity;
    }
}

// Manages the warehouse inventory
class Warehouse {
    private List<Item> inventory;

    public Warehouse() {
        this.inventory = new ArrayList<>();
    }

    /**
     * Adds a new item or updates the quantity of an existing item.
     * @param newItem The item to add or update.
     */
    public void addItem(Item newItem) {
        Optional<Item> existingItem = findItemById(newItem.getId());

        if (existingItem.isPresent()) {
            // Update quantity of existing item
            Item item = existingItem.get();
            item.setQuantity(item.getQuantity() + newItem.getQuantity());
             System.out.println("Item " + newItem.getId() + " (" + newItem.getName() + ") quantity updated. New quantity: " + item.getQuantity());
        } else {
            // Add new item
            inventory.add(newItem);
            System.out.println("Item " + newItem.getId() + " (" + newItem.getName() + ") added to inventory.");
        }
    }

    /**
     * Finds an item in the inventory by its ID.
     * @param itemId The ID of the item to find.
     * @return An Optional containing the Item if found, otherwise empty.
     */
    public Optional<Item> findItemById(String itemId) {
        for (Item item : inventory) {
            if (item.getId().equals(itemId)) {
                return Optional.of(item);
            }
        }
        return Optional.empty();
    }

     /**
      * Checks if sufficient stock is available for a list of requested items.
      * @param requestedItems The list of items with requested quantities.
      * @return True if sufficient stock is available for all items, false otherwise.
      *         Returns a message indicating which item caused the failure if false.
      */
     public StockCheckResult checkStock(List<Item> requestedItems) {
         for (Item requestedItem : requestedItems) {
             Optional<Item> inventoryItemOpt = findItemById(requestedItem.getId());

             if (!inventoryItemOpt.isPresent()) {
                 return new StockCheckResult(false, "Item " + requestedItem.getId() + " not found in inventory.");
             }

             Item inventoryItem = inventoryItemOpt.get();
             if (inventoryItem.getQuantity() < requestedItem.getQuantity()) {
                 return new StockCheckResult(false, "Item " + requestedItem.getId() + " requires " + requestedItem.getQuantity() + " but only " + inventoryItem.getQuantity() + " available.");
             }
         }
         return new StockCheckResult(true, "Stock sufficient for all items.");
     }

    /**
     * Deducts the quantities of items from the inventory.
     * Assumes stock has already been checked and is sufficient.
     * @param itemsToDeduct The list of items with quantities to deduct.
     */
    public void deductStock(List<Item> itemsToDeduct) {
        for (Item itemToDeduct : itemsToDeduct) {
            Optional<Item> inventoryItemOpt = findItemById(itemToDeduct.getId());
            // This should always be present if checkStock passed
            if (inventoryItemOpt.isPresent()) {
                Item inventoryItem = inventoryItemOpt.get();
                inventoryItem.setQuantity(inventoryItem.getQuantity() - itemToDeduct.getQuantity());
            } else {
                 // This indicates a logic error if checkStock passed but item not found for deduction
                 System.err.println("Internal Error: Item " + itemToDeduct.getId() + " not found during stock deduction.");
            }
        }
    }


    /**
     * Displays the current inventory.
     */
    public void displayInventory() {
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
            return;
        }
        System.out.println("--- Current Inventory ---");
        for (Item item : inventory) {
            System.out.println(item);
        }
        System.out.println("-------------------------");
    }

    // Helper class to return result and message from stock check
    static class StockCheckResult {
        boolean isSufficient;
        String message;

        StockCheckResult(boolean isSufficient, String message) {
            this.isSufficient = isSufficient;
            this.message = message;
        }
    }
}

// Represents a customer order
class Order {
    private String orderId;
    private List<Item> requestedItems; // Items with requested quantities

    public Order(String orderId, List<Item> requestedItems) {
         if (orderId == null || orderId.trim().isEmpty()) {
             throw new IllegalArgumentException("Order ID cannot be null or empty.");
         }
         if (requestedItems == null || requestedItems.isEmpty()) {
              throw new IllegalArgumentException("Order must contain at least one item.");
         }
        this.orderId = orderId.trim();
        this.requestedItems = new ArrayList<>(requestedItems); // Create a defensive copy
    }

    public String getOrderId() {
        return orderId;
    }

    public List<Item> getRequestedItems() {
        return new ArrayList<>(requestedItems); // Return a defensive copy
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        sb.append("  Items:\n");
        for (Item item : requestedItems) {
            sb.append("    - ").append(item.getId()).append(" (Qty: ").append(item.getQuantity()).append(")\n");
        }
        return sb.toString();
    }
}

// Processes orders from a queue
class OrderProcessor {
    private Queue<Order> orderQueue;

    public OrderProcessor() {
        this.orderQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds an order to the processing queue.
     * @param order The order to add.
     */
    public void addOrder(Order order) {
        orderQueue.offer(order); // offer is preferred over add for queues
        System.out.println("Order " + order.getOrderId() + " added to queue.");
    }

    /**
     * Processes the next order in the queue.
     * @param warehouse The warehouse to check stock and deduct items from.
     */
    public void processNextOrder(Warehouse warehouse) {
        Order order = orderQueue.peek(); // Peek to check without removing

        if (order == null) {
            System.out.println("Order queue is empty. No orders to process.");
            return;
        }

        System.out.println("Processing Order " + order.getOrderId() + "...");

        // 1. Check stock for all items in the order
        Warehouse.StockCheckResult checkResult = warehouse.checkStock(order.getRequestedItems());

        if (checkResult.isSufficient) {
            // 2. If stock is sufficient, deduct items from inventory
            warehouse.deductStock(order.getRequestedItems());
            orderQueue.poll(); // Remove the order from the queue
            System.out.println("Order " + order.getOrderId() + " fulfilled successfully. Inventory updated.");
        } else {
            // 3. If stock is insufficient for any item, the order fails
            System.err.println("Error: Order " + order.getOrderId() + " failed to fulfill due to insufficient stock. " + checkResult.message);
            orderQueue.poll(); // Remove the order from the queue even if failed
            System.err.println("Order " + order.getOrderId() + " removed from queue.");
        }
    }

     /**
      * Displays the order IDs currently in the queue.
      */
     public void displayOrderQueue() {
         if (orderQueue.isEmpty()) {
             System.out.println("Order queue is empty.");
             return;
         }
         System.out.println("--- Pending Orders ---");
         for (Order order : orderQueue) {
             System.out.println("Order ID: " + order.getOrderId());
         }
         System.out.println("--------------------");
     }
}

// Main application class
public class WarehouseSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Warehouse warehouse = new Warehouse();
        OrderProcessor orderProcessor = new OrderProcessor();
        boolean running = true;

        System.out.println("--- Warehouse Inventory & Order Fulfillment System ---");

        while (running) {
            printMenu();
            System.out.print("Enter command number: ");

            // Class-wide exception handling for the main loop
            try {
                int command = Integer.parseInt(scanner.nextLine());

                switch (command) {
                    case 1: // Add Item
                        handleAddItem(scanner, warehouse);
                        break;
                    case 2: // View Inventory
                        warehouse.displayInventory();
                        break;
                    case 3: // Place Order
                        handlePlaceOrder(scanner, orderProcessor);
                        break;
                    case 4: // Process Next Order
                        orderProcessor.processNextOrder(warehouse);
                        break;
                    case 5: // View Order Queue
                         orderProcessor.displayOrderQueue();
                         break;
                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid command number. Please try again.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid input. Please enter a valid number for the command.");
            } catch (IllegalArgumentException e) {
                 // Catching specific validation errors from constructors/setters
                 System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
            }
            System.out.println(); // Add a newline for better readability between commands
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add Item");
        System.out.println("2. View Inventory");
        System.out.println("3. Place Order");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Order Queue");
        System.out.println("6. Exit");
    }

    private static void handleAddItem(Scanner scanner, Warehouse warehouse) {
        System.out.print("Enter Item ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Item Name: ");
        String name = scanner.nextLine();
        System.out.print("Enter Initial Quantity: ");
        String quantityStr = scanner.nextLine();

        try {
            int quantity = Integer.parseInt(quantityStr);
            Item newItem = new Item(id, name, quantity); // Validation happens in Item constructor
            warehouse.addItem(newItem);
        } catch (NumberFormatException e) {
            System.err.println("Invalid quantity format. Please enter an integer.");
        } catch (IllegalArgumentException e) {
             // Catch validation errors from Item constructor
             System.err.println("Error adding item: " + e.getMessage());
        }
    }

    private static void handlePlaceOrder(Scanner scanner, OrderProcessor orderProcessor) {
        System.out.print("Enter Order ID: ");
        String orderId = scanner.nextLine();

        List<Item> requestedItems = new ArrayList<>();
        System.out.println("Enter Item ID and Quantity for order (or type 'done' for Item ID to finish):");

        while (true) {
            System.out.print("Enter Item ID: ");
            String itemId = scanner.nextLine();
            if (itemId.equalsIgnoreCase("done")) {
                break;
            }

            System.out.print("Enter Quantity for " + itemId + ": ");
            String quantityStr = scanner.nextLine();

            try {
                int quantity = Integer.parseInt(quantityStr);
                // Use Item constructor for order items (validates positive quantity)
                requestedItems.add(new Item(itemId, quantity));
            } catch (NumberFormatException e) {
                System.err.println("Invalid quantity format. Please enter an integer. Skipping this item.");
            } catch (IllegalArgumentException e) {
                 // Catch validation errors from Item constructor (e.g., quantity <= 0)
                 System.err.println("Error adding item to order: " + e.getMessage() + ". Skipping this item.");
            }
        }

        if (requestedItems.isEmpty()) {
            System.err.println("Order cannot be placed with no items.");
            return;
        }

        try {
             // Validation happens in Order constructor (e.g., orderId not empty)
             Order newOrder = new Order(orderId, requestedItems);
             orderProcessor.addOrder(newOrder);
        } catch (IllegalArgumentException e) {
             System.err.println("Error placing order: " + e.getMessage());
        }
    }
}
