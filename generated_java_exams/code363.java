/*
 * Exam Question #363
 * Generated on: 2025-05-11 23:00:35
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Work Order Management System
 * 
 * **Objective:** Design and implement a simplified Work Order Management System that processes work orders in a first-in, first-out manner. This system should demonstrate your understanding of core Java data structures, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are building a backend system for managing incoming work orders. Work orders arrive and are placed in a queue. Technicians process the orders one by one from the front of the queue. The system needs to allow adding new orders, processing the next available order, viewing the current queue, and viewing a history of processed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **WorkOrder Class:** Create a simple class named `WorkOrder` with private fields for `type` (String) and `description` (String). Include a constructor and public getter methods for these fields.
 * 2.  **WorkOrderProcessor Class:** Create a class named `WorkOrderProcessor` to manage the system's logic.
 *     *   It must have private fields:
 *         *   A `Queue<WorkOrder>` to hold incoming work orders.
 *         *   A `List<WorkOrder>` to store processed work orders.
 *         *   A `List<String>` containing a predefined list of valid work order types (e.g., "Repair", "Maintenance", "Installation", "Inspection").
 *         *   A `Scanner` object for reading user input.
 *     *   Implement a constructor to initialize these fields. Use `java.util.LinkedList` as the concrete implementation for the `Queue` and `java.util.ArrayList` for the `List`s, but declare them using the `Queue` and `List` interfaces respectively.
 *     *   Implement a `run()` method that contains the main application loop. This loop should:
 *         *   Display a menu of options to the user (Add Work Order, Process Next Order, View Order Queue, View Processed History, Exit).
 *         *   Read the user's choice using the `Scanner`.
 *         *   Use a `switch` statement to handle the different menu options.
 *         *   The loop should continue until the user chooses to exit.
 *         *   Implement class-wide exception handling using a `try-catch(Exception e)` block around the core logic within the loop to catch any unexpected errors during an operation and print an error message to `System.err`.
 *     *   Implement the following methods, called by the `switch` statement:
 *         *   `addWorkOrder()`: Prompts the user for the work order type and description. Validates the entered type against the list of valid types. If valid, creates a `WorkOrder` object and adds it to the queue. If invalid, prints an error message to `System.err`. Handles potential input issues (e.g., empty input).
 *         *   `processNextOrder()`: Removes the next work order from the front of the queue (if available), prints its details to `System.out`, and adds it to the processed history list. If the queue is empty, prints a message to `System.err` indicating that there are no orders to process.
 *         *   `viewOrderQueue()`: Prints the details of all work orders currently in the queue to `System.out`. If the queue is empty, prints a message to `System.out` indicating the queue is empty.
 *         *   `viewProcessedHistory()`: Prints the details of all work orders in the processed history list to `System.out`. If the history is empty, prints a message to `System.out` indicating no orders have been processed yet.
 *     *   Implement a helper method `getIntegerInput(String prompt)` that displays the prompt, reads an integer from the user, and handles `InputMismatchException` if the user enters non-integer input, prompting them to try again until valid input is received. This helper should use `System.err` for error messages related to invalid input type.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments.
 *     *   Use `System.out` for normal output (prompts, successful operations, list contents) and `System.err` for error messages (invalid input, operation failures like empty queue).
 * 3.  **Main Method:** Create a `main` method in a separate class (or in `WorkOrderProcessor`) that creates an instance of `WorkOrderProcessor` and calls its `run()` method to start the application.
 * 4.  **Input Validation & Error Handling:**
 *     *   Validate menu input (must be an integer within the valid range). Use the `getIntegerInput` helper.
 *     *   Validate work order type input (must be one of the predefined valid types).
 *     *   Handle the case of an empty queue when trying to process.
 *     *   Handle the case of empty lists when viewing.
 *     *   Use `try-catch` for potential input errors and general operation exceptions as specified.
 * 
 * **Expected Output:** The system should interactively respond to user commands, displaying prompts, status messages, list contents, and error messages appropriately.
 * 
 * ```
 * Work Order Management System
 * Menu:
 * 1. Add Work Order
 * 2. Process Next Order
 * 3. View Order Queue
 * 4. View Processed History
 * 5. Exit
 * Enter your choice: 1
 * Enter Work Order Type (Valid types: Repair, Maintenance, Installation, Inspection): Repair
 * Enter Work Order Description: Fix leaky faucet in bathroom
 * Work Order added to queue.
 * 
 * Enter your choice: 1
 * Enter Work Order Type (Valid types: Repair, Maintenance, Installation, Inspection): Installation
 * Enter Work Order Description: Install new server rack in data center
 * Work Order added to queue.
 * 
 * Enter your choice: 3
 * --- Current Work Order Queue ---
 * Type: Repair, Description: Fix leaky faucet in bathroom
 * Type: Installation, Description: Install new server rack in data center
 * ----------------------------------
 * 
 * Enter your choice: 2
 * Processing Work Order: Type: Repair, Description: Fix leaky faucet in bathroom
 * Work Order processed and moved to history.
 * 
 * Enter your choice: 3
 * --- Current Work Order Queue ---
 * Type: Installation, Description: Install new server rack in data center
 * ----------------------------------
 * 
 * Enter your choice: 4
 * --- Processed Work Order History ---
 * Type: Repair, Description: Fix leaky faucet in bathroom
 * ------------------------------------
 * 
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Enter your choice: abc
 * Error: Invalid input. Please enter an integer.
 * Enter your choice: 5
 * Exiting Work Order Management System.
 * ```
 * 
 * This task requires combining several Java concepts and data structures to build a functional, albeit simple, interactive application.
 *
 * EXPLANATION:
 * This solution implements a simple Work Order Management System according to the requirements, demonstrating the use of the specified Java components and best practices.
 * 
 * 1.  **`WorkOrder` Class:** This class is a simple Plain Old Java Object (POJO) representing a work order. It has private fields (`type`, `description`) and public getter methods, adhering to encapsulation principles. The `toString()` method is overridden for easy printing of order details.
 * 
 * 2.  **`WorkOrderProcessor` Class:** This is the core class managing the system's state and logic.
 *     *   **Fields:**
 *         *   `workOrderQueue` (`Queue<WorkOrder>`): Declared as `Queue` interface but initialized with `LinkedList`. `LinkedList` implements `Queue` and is efficient for adding/removing from both ends, suitable for a queue. It stores incoming work orders in FIFO order.
 *         *   `processedOrdersHistory` (`List<WorkOrder>`): Declared as `List` interface but initialized with `ArrayList`. `ArrayList` is suitable for storing the history as we might need to iterate through it or potentially access elements by index (though not strictly required by this problem, `ArrayList` is a common `List` implementation choice).
 *         *   `validOrderTypes` (`List<String>`): Declared as `List` interface and initialized with `ArrayList` containing the predefined valid types. This list is used for input validation.
 *         *   `scanner` (`Scanner`): Used to read input from `System.in`.
 *     *   **Constructor:** Initializes all fields, including populating `validOrderTypes` and creating the `Scanner`.
 *     *   **`run()` Method:** Contains the main `while` loop that keeps the application running until the user chooses to exit.
 *         *   It displays the menu, gets user input using the `getIntegerInput` helper, and uses a `switch` statement to dispatch to the appropriate method based on the choice.
 *         *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the `switch` statement. This block is designed to catch *any* unexpected runtime exception that might occur within the operation methods (`addWorkOrder`, `processNextOrder`, etc.), preventing the program from crashing abruptly and printing a generic error message to `System.err`.
 *     *   **`displayMenu()`:** A simple helper method to print the available options to `System.out`.
 *     *   **`getIntegerInput(String prompt)`:** This is a robust helper method for reading integer input. It uses a `while` loop to repeatedly prompt the user until a valid integer is entered. A `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer text, printing an error message to `System.err` and consuming the invalid input line (`scanner.nextLine()`) to prevent an infinite loop.
 *     *   **`addWorkOrder()`:**
 *         *   Prompts for type and description using `System.out`.
 *         *   Reads input using `scanner.nextLine()`.
 *         *   Validates the entered `type` by checking if it exists in the `validOrderTypes` list. If not valid, it prints an error to `System.err` and returns.
 *         *   Basic check for empty description is included.
 *         *   If valid, creates a `WorkOrder` object and adds it to the `workOrderQueue` using `offer()`. `offer()` is generally preferred over `add()` for queues as it handles capacity-constrained queues gracefully (though `LinkedList` is unbounded).
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextOrder()`:**
 *         *   Uses `workOrderQueue.poll()` to retrieve and remove the element at the front of the queue. `poll()` returns `null` if the queue is empty, which is handled gracefully.
 *         *   If `poll()` returns `null`, it prints a message to `System.err`.
 *         *   If an order is retrieved, it prints its details to `System.out` and adds it to the `processedOrdersHistory` list using `add()`.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewOrderQueue()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the `workOrderQueue` is empty using `isEmpty()`. If so, prints a message to `System.out`.
 *         *   If not empty, it iterates through the queue using a for-each loop. This iteration does *not* remove elements from the queue, allowing the user to view the current state.
 *         *   Prints each `WorkOrder` using its `toString()` method to `System.out`.
 *         *   Prints a footer to `System.out`.
 *     *   **`viewProcessedHistory()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the `processedOrdersHistory` list is empty using `isEmpty()`. If so, prints a message to `System.out`.
 *         *   If not empty, it iterates through the list and prints each `WorkOrder` to `System.out`.
 *         *   Prints a footer to `System.out`.
 * 
 * 3.  **`main` Method:** Located within the `WorkOrderProcessor` class for simplicity in this example. It creates an instance of `WorkOrderProcessor` and calls `run()` to start the application loop. It also ensures the `Scanner` is closed when the application exits.
 * 
 * This solution effectively uses `Queue` for FIFO processing, `List` for history and valid types, `Scanner` for interactive input, `switch` for menu navigation, `System.out` for normal output, `System.err` for errors, and `try-catch` blocks for robust input handling and general exception catching, fulfilling all requirements. Encapsulation, meaningful names, and comments contribute to code clarity and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single Work Order
class WorkOrder {
    private String type;
    private String description;

    public WorkOrder(String type, String description) {
        this.type = type;
        this.description = description;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Type: " + type + ", Description: " + description;
    }
}

// Manages the Work Order Queue and History
public class WorkOrderProcessor {

    private Queue<WorkOrder> workOrderQueue;
    private List<WorkOrder> processedOrdersHistory;
    private List<String> validOrderTypes;
    private Scanner scanner;

    public WorkOrderProcessor() {
        // Use LinkedList for Queue implementation
        this.workOrderQueue = new LinkedList<>();
        // Use ArrayList for List implementations
        this.processedOrdersHistory = new ArrayList<>();
        this.validOrderTypes = new ArrayList<>(List.of("Repair", "Maintenance", "Installation", "Inspection")); // Java 9+ List.of
        // For Java 8, use:
        // this.validOrderTypes = new ArrayList<>();
        // this.validOrderTypes.add("Repair");
        // this.validOrderTypes.add("Maintenance");
        // this.validOrderTypes.add("Installation");
        // this.validOrderTypes.add("Inspection");

        this.scanner = new Scanner(System.in);
    }

    // Main application loop
    public void run() {
        System.out.println("Work Order Management System");
        boolean running = true;

        while (running) {
            displayMenu();
            try {
                int choice = getIntegerInput("Enter your choice: ");

                // Class-wide exception handling around the switch
                try {
                    switch (choice) {
                        case 1:
                            addWorkOrder();
                            break;
                        case 2:
                            processNextOrder();
                            break;
                        case 3:
                            viewOrderQueue();
                            break;
                        case 4:
                            viewProcessedHistory();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Work Order Management System.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (Exception e) {
                    // Catch any unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during the operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging
                }

            } catch (Exception e) {
                // This catch is mainly for issues from getIntegerInput if it were not handled internally,
                // or other rare input stream issues. getIntegerInput handles InputMismatchException internally.
                 System.err.println("An error occurred while reading input: " + e.getMessage());
                 scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
            }
            System.out.println(); // Add a newline for better readability between operations
        }
        scanner.close(); // Close the scanner when done
    }

    // Displays the menu options
    private void displayMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add Work Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Order Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
    }

    // Gets integer input from user with validation
    private int getIntegerInput(String prompt) {
        while (true) {
            System.out.print(prompt);
            try {
                int input = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over
                return input;
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter an integer.");
                scanner.nextLine(); // Consume the invalid input line
            }
        }
    }

    // Adds a new work order to the queue
    private void addWorkOrder() {
        System.out.print("Enter Work Order Type (Valid types: " + String.join(", ", validOrderTypes) + "): ");
        String type = scanner.nextLine().trim();

        if (!validOrderTypes.contains(type)) {
            System.err.println("Error: Invalid work order type.");
            return;
        }

        System.out.print("Enter Work Order Description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
             System.err.println("Error: Description cannot be empty.");
             return;
        }

        WorkOrder newOrder = new WorkOrder(type, description);
        workOrderQueue.offer(newOrder); // offer is generally preferred over add for queues (returns false if failed)
        System.out.println("Work Order added to queue.");
    }

    // Processes the next work order from the queue
    private void processNextOrder() {
        WorkOrder nextOrder = workOrderQueue.poll(); // poll returns null if queue is empty

        if (nextOrder == null) {
            System.err.println("No work orders in the queue to process.");
        } else {
            System.out.println("Processing Work Order: " + nextOrder);
            processedOrdersHistory.add(nextOrder);
            System.out.println("Work Order processed and moved to history.");
        }
    }

    // Views the current work order queue
    private void viewOrderQueue() {
        System.out.println("--- Current Work Order Queue ---");
        if (workOrderQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (WorkOrder order : workOrderQueue) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------------------");
    }

    // Views the processed work order history
    private void viewProcessedHistory() {
        System.out.println("--- Processed Work Order History ---");
        if (processedOrdersHistory.isEmpty()) {
            System.out.println("No work orders have been processed yet.");
        } else {
            for (WorkOrder order : processedOrdersHistory) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        WorkOrderProcessor processor = new WorkOrderProcessor();
        processor.run();
    }
}
