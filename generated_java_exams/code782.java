/*
 * Exam Question #782
 * Generated on: 2025-05-12 16:40:05
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Team Task Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified command-line application for a small team to manage tasks. The system should allow users to view predefined task types, add new tasks to a queue for processing, process the next task in the queue, and view the current tasks waiting in the queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available, predefined `TaskType` objects. Each `TaskType` should have a name and a description. Use `java.util.List` and `java.util.ArrayList`.
 *     *   Maintain a queue of `Task` objects representing tasks waiting to be processed. Each `Task` should include a reference to its `TaskType` and potentially a unique ID or note. Use `java.util.Queue`.
 * 
 * 2.  **User Interface:**
 *     *   Implement a command-line menu interface using `java.util.Scanner` for user input.
 *     *   The menu should present the following options:
 *         1.  View Available Task Types
 *         2.  Add New Task to Queue
 *         3.  Process Next Task
 *         4.  View Task Queue
 *         5.  Exit
 * 
 * 3.  **Functionality:**
 *     *   **View Available Task Types:** Display the list of predefined task types with their names and descriptions.
 *     *   **Add New Task to Queue:**
 *         *   Display the available task types with numbers for selection.
 *         *   Prompt the user to select a task type by number.
 *         *   Prompt the user for an optional note for the task.
 *         *   Create a `Task` object with the selected type and note.
 *         *   Add the newly created `Task` to the task queue.
 *     *   **Process Next Task:**
 *         *   Retrieve and remove the task at the front of the queue.
 *         *   If the queue is empty, inform the user.
 *         *   If a task is retrieved, display its details, simulating processing.
 *     *   **View Task Queue:**
 *         *   Display the tasks currently waiting in the queue without removing them.
 *         *   If the queue is empty, inform the user.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   Handle cases where the user enters non-numeric input for menu choices or task type selection. Report errors using `System.err`.
 *     *   Handle cases where the user enters an invalid number for menu choice or task type selection (out of range). Report errors using `System.err`.
 *     *   Handle attempts to process or view an empty queue gracefully using `System.out`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential unexpected errors during the application's execution. Ensure resources like `Scanner` are closed.
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) for classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation where necessary.
 *     *   Use `System.out` for normal output and `System.err` for error messages.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and display results or errors based on the user's choices.
 * *   Valid operations should print information to `System.out`.
 * *   Invalid inputs (non-numeric, out of range) should print error messages to `System.err`.
 * *   Attempting to process/view an empty queue should print an informative message to `System.out`.
 * *   Upon exiting, a farewell message should be printed to `System.out`.
 * *   Any unhandled exceptions should be caught by the class-wide handler and reported to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 1
 * --- Available Task Types ---
 * 1. Bug Fix: Resolve a software defect
 * 2. Feature Request: Implement a new feature
 * 3. Code Review: Review peer's code
 * 4. Documentation: Write or update documentation
 * 
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 2
 * --- Available Task Types ---
 * 1. Bug Fix: Resolve a software defect
 * 2. Feature Request: Implement a new feature
 * 3. Code Review: Review peer's code
 * 4. Documentation: Write or update documentation
 * Enter the number of the task type to add: 2
 * Enter a brief note for the task (optional, press Enter to skip): Add user profile feature
 * Task added to queue: Feature Request
 * 
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 4
 * --- Current Task Queue ---
 * 1. Task #1 [Feature Request] - Add user profile feature
 * 
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Next Task ---
 * Processing: Task #1 [Feature Request] - Add user profile feature
 * Task #1 processed successfully.
 * 
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Next Task ---
 * Task queue is empty. Nothing to process.
 * 
 * --- Task Manager Menu ---
 * 1. View Available Task Types
 * 2. Add New Task to Queue
 * 3. Process Next Task
 * 4. View Task Queue
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * ... (and so on)
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements the Team Task Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`**: The `taskQueue` variable is declared using the `Queue` interface and implemented using `java.util.LinkedList`. This correctly models a waiting line where tasks are processed in First-In, First-Out (FIFO) order.
 *     *   `taskQueue.offer(newTask)` is used in `addTaskToQueue` to add a task to the end of the queue. `offer()` is preferred over `add()` as it returns `false` if the element cannot be added due to capacity restrictions (though `LinkedList` is unbounded), whereas `add()` would throw an exception.
 *     *   `taskQueue.poll()` is used in `processNextTask` to retrieve and remove the task at the head of the queue. `poll()` is preferred over `remove()` as it returns `null` if the queue is empty, avoiding an exception.
 *     *   Iteration over the queue in `viewTaskQueue` uses an enhanced for loop (`for (Task task : taskQueue)`), which utilizes the queue's iterator. This allows viewing elements without removing them, fulfilling the requirement.
 * 
 * 2.  **`java.util.ArrayList`**: The `availableTaskTypes` variable is initialized as an `ArrayList` and declared using the `List` interface. This is suitable for storing a dynamic, ordered collection of task types that need to be accessed by index.
 *     *   `availableTaskTypes.add(...)` is used in `initializeTaskTypes` to populate the list.
 *     *   `availableTaskTypes.size()` and `availableTaskTypes.get(index)` are used in `viewAvailableTaskTypes` and `addTaskToQueue` to iterate through and select task types by their index.
 * 
 * 3.  **`java.util.List` interface**: The `availableTaskTypes` is declared as `List<TaskType>`, demonstrating the use of the interface type rather than the specific implementation type (`ArrayList`). This is a best practice that promotes flexibility.
 * 
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used to read input from `System.in`.
 *     *   `scanner.nextLine()` is used consistently to read entire lines of input, which helps avoid issues with leftover newline characters after reading numbers.
 * 
 * 5.  **`switch` statement**: The `switch (choice)` statement in the `run` method is used to efficiently direct the program flow based on the user's numeric menu selection. The `default` case handles invalid numeric choices.
 * 
 * 6.  **`System.err`**: Used specifically for reporting error conditions, such as invalid input (non-numeric, out of range) or inability to perform an action (e.g., cannot add task if no types exist). This separates error output from normal program output.
 * 
 * 7.  **`System.out`**: Used for all standard output, including the menu display, lists of task types and tasks, confirmations of successful actions (task added, task processed), and informative messages (queue empty, exiting).
 * 
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   The main `run()` method's logic is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unexpected exceptions that might occur during the program's execution, preventing the program from crashing abruptly and providing a basic error report to `System.err`.
 *     *   More specific `try-catch(NumberFormatException e)` blocks are used within the loop (for menu choice parsing) and in `addTaskToQueue` (for task type choice parsing). These specific handlers catch expected input format errors and allow the program to report the error and continue execution without terminating the main loop.
 *     *   A `finally` block in `run()` ensures that the `scanner.close()` method is called, releasing the system resource, regardless of whether the loop finishes normally or an exception is caught.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** The `TaskType`, `Task`, and `TaskManager` classes have private fields and public methods (`getters`) to access data, controlling how the data is modified and accessed.
 * *   **Meaningful Names:** Variables (`availableTaskTypes`, `taskQueue`, `scanner`, `choice`, `selectedType`), methods (`initializeTaskTypes`, `printMenu`, `addTaskToQueue`, `processNextTask`, `viewTaskQueue`), and classes (`TaskType`, `Task`, `TaskManager`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are included for classes and methods, explaining their roles, parameters, and return values. Inline comments explain specific logic steps.
 * *   **Input Validation:** The code explicitly checks if input strings can be parsed as integers and if the resulting integer values fall within valid ranges (menu options, task type indices).
 * *   **Error Handling:** Different types of errors (input format, invalid range, unexpected exceptions) are caught and handled appropriately, using `System.err` for errors and providing informative messages.
 * *   **Clean Code Structure:** The code is organized into logical classes. The `TaskManager` class orchestrates the application flow, delegating specific tasks (like viewing or adding) to dedicated private methods, improving readability and maintainability. Using `LinkedList` as a `Queue` implementation is appropriate for this scenario.
 * 
 * This solution effectively combines the required Java components in a realistic scenario, demonstrating understanding of collection types, user interaction, control flow, and robust error handling, making it a suitable challenging exam question.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a predefined type of task.
 */
class TaskType {
    private String name;
    private String description;

    /**
     * Constructs a new TaskType.
     * @param name The name of the task type.
     * @param description The description of the task type.
     */
    public TaskType(String name, String description) {
        this.name = name;
        this.description = description;
    }

    /**
     * Gets the name of the task type.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the description of the task type.
     * @return The description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the TaskType.
     * @return Formatted string.
     */
    @Override
    public String toString() {
        return name + ": " + description;
    }
}

/**
 * Represents an instance of a task waiting to be processed.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private TaskType type;
    private String note; // Optional note for the specific task instance

    /**
     * Constructs a new Task instance.
     * @param type The type of task.
     * @param note An optional note for this task instance.
     */
    public Task(TaskType type, String note) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.type = type;
        this.note = note;
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the type of the task.
     * @return The TaskType.
     */
    public TaskType getType() {
        return type;
    }

    /**
     * Gets the note associated with the task.
     * @return The note.
     */
    public String getNote() {
        return note;
    }

    /**
     * Returns a string representation of the Task.
     * @return Formatted string including ID, type, and note.
     */
    @Override
    public String toString() {
        return "Task #" + id + " [" + type.getName() + "] - " + (note != null && !note.isEmpty() ? note : "No note");
    }
}

/**
 * Manages the available task types and the queue of tasks to be processed.
 * Contains the main application logic and user interaction.
 */
public class TaskManager {
    // List to hold predefined task types (uses List interface, implemented by ArrayList)
    private List<TaskType> availableTaskTypes;
    // Queue to hold tasks waiting for processing (uses Queue interface, implemented by LinkedList)
    private Queue<Task> taskQueue;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a TaskManager, initializes collections and Scanner,
     * and populates initial task types.
     */
    public TaskManager() {
        availableTaskTypes = new ArrayList<>(); // Initialize ArrayList
        taskQueue = new LinkedList<>(); // Initialize LinkedList as Queue
        scanner = new Scanner(System.in);
        initializeTaskTypes(); // Populate the initial list of types
    }

    /**
     * Populates the list of available task types.
     */
    private void initializeTaskTypes() {
        availableTaskTypes.add(new TaskType("Bug Fix", "Resolve a software defect"));
        availableTaskTypes.add(new TaskType("Feature Request", "Implement a new feature"));
        availableTaskTypes.add(new TaskType("Code Review", "Review peer's code"));
        availableTaskTypes.add(new TaskType("Documentation", "Write or update documentation"));
        // Example: Add more task types here
        // availableTaskTypes.add(new TaskType("Testing", "Perform unit or integration tests"));
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block for handling potential unexpected exceptions
        try {
            while (running) {
                printMenu();
                String choiceStr = scanner.nextLine(); // Read input as string

                int choice = -1;
                try {
                    // Attempt to parse the input string as an integer
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // Handle non-numeric input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        viewAvailableTaskTypes();
                        break;
                    case 2:
                        addTaskToQueue();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewTaskQueue();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                // Add a blank line for better readability between operations
                System.out.println();
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed when the application exits or errors
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- Task Manager Menu ---");
        System.out.println("1. View Available Task Types");
        System.out.println("2. Add New Task to Queue");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Task Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the list of predefined task types.
     */
    private void viewAvailableTaskTypes() {
        System.out.println("--- Available Task Types ---");
        if (availableTaskTypes.isEmpty()) {
            System.out.println("No task types defined.");
        } else {
            // Iterate through the ArrayList and print each TaskType
            for (int i = 0; i < availableTaskTypes.size(); i++) {
                System.out.println((i + 1) + ". " + availableTaskTypes.get(i));
            }
        }
    }

    /**
     * Guides the user through adding a new task to the queue.
     * Includes input validation for task type selection.
     */
    private void addTaskToQueue() {
        viewAvailableTaskTypes(); // Show types first
        if (availableTaskTypes.isEmpty()) {
            System.err.println("Cannot add task: No task types available.");
            return; // Exit method if no types exist
        }

        System.out.print("Enter the number of the task type to add: ");
        String typeChoiceStr = scanner.nextLine(); // Read type choice as string

        int typeIndex = -1;
        try {
            // Attempt to parse the task type number
            typeIndex = Integer.parseInt(typeChoiceStr) - 1; // Adjust for 0-based index
        } catch (NumberFormatException e) {
            // Handle non-numeric input for task type
            System.err.println("Invalid input. Please enter a valid task type number.");
            return; // Exit method on error
        }

        // Validate the task type index against the list bounds
        if (typeIndex < 0 || typeIndex >= availableTaskTypes.size()) {
            System.err.println("Invalid task type number.");
            return; // Exit method on invalid index
        }

        // Get the selected TaskType from the ArrayList
        TaskType selectedType = availableTaskTypes.get(typeIndex);

        System.out.print("Enter a brief note for the task (optional, press Enter to skip): ");
        String note = scanner.nextLine(); // Read the optional note

        // Create a new Task object
        Task newTask = new Task(selectedType, note);
        // Add the new task to the Queue
        taskQueue.offer(newTask); // offer() is a safe way to add to a queue

        System.out.println("Task added to queue: " + newTask.getType().getName());
    }

    /**
     * Processes (removes and displays) the next task from the queue.
     */
    private void processNextTask() {
        System.out.println("--- Processing Next Task ---");
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty. Nothing to process.");
        } else {
            // Retrieve and remove the head of the queue using poll()
            Task processedTask = taskQueue.poll();
            System.out.println("Processing: " + processedTask);
            // Simulate work being done...
            System.out.println("Task #" + processedTask.getId() + " processed successfully.");
        }
    }

    /**
     * Displays the tasks currently in the queue without removing them.
     */
    private void viewTaskQueue() {
        System.out.println("--- Current Task Queue ---");
        // Check if the queue is empty
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty.");
        } else {
            // Iterate through the queue using its iterator (doesn't remove elements)
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
            // Alternatively, could use taskQueue.peek() repeatedly if needed,
            // or print the queue object directly if its toString is sufficient.
        }
    }

    /**
     * The main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
