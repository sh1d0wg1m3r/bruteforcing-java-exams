/*
 * Exam Question #1157
 * Generated on: 2025-05-12 17:32:46
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Shipment Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified automated warehouse management system. The system handles incoming product shipments that need to be processed and then stored. Incoming shipments are placed in a queue waiting for processing. Once processed, they are moved to a list of completed shipments. The system should allow a user to add new shipments, process the next shipment in the queue, view completed shipments, and exit.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this warehouse system. Your solution MUST adhere to the following:
 * 
 * 1.  Use a `java.util.Queue` to manage incoming shipments waiting for processing.
 * 2.  Use a `java.util.ArrayList` as the concrete implementation for a collection of completed shipments.
 * 3.  Declare the variable holding the completed shipments using the `java.util.List` interface.
 * 4.  Use `java.util.Scanner` to read user input from the console.
 * 5.  Use a `switch` statement to handle different user commands from the main menu.
 * 6.  Use `System.err` exclusively for printing error messages (e.g., invalid input, attempting to process an empty queue).
 * 7.  Use `System.out` for all normal output (menu, prompts, success messages, displaying lists).
 * 8.  Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential `NumberFormatException` when parsing user input for shipment details and include a general catch-all for unexpected errors in the main application loop.
 * 9.  Create a separate class (`Shipment`) to represent a shipment with appropriate fields (e.g., ID, description, quantity).
 * 10. Apply best practices:
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Implement basic input validation (e.g., check for positive ID/quantity, non-empty description).
 *     *   Ensure proper error handling for specific scenarios (like an empty queue) and general exceptions.
 *     *   Structure the code cleanly into logical methods.
 * 
 * **Functionality:**
 * 
 * The system should present a menu with the following options:
 * 1.  **Add New Incoming Shipment:** Prompt the user for Shipment ID (integer), Description (string), and Quantity (integer). Create a `Shipment` object and add it to the incoming queue. Validate input (ID and Quantity must be positive integers, Description cannot be empty). Report validation errors using `System.err`. Handle `NumberFormatException` during parsing using `try-catch` and report the error using `System.err`.
 * 2.  **Process Next Shipment:** Take the next shipment from the head of the incoming queue and move it to the completed shipments list. If the queue is empty, print an error message using `System.err`. Print a success message using `System.out` if a shipment was processed.
 * 3.  **View Completed Shipments:** Display the details of all shipments currently in the completed shipments list. If the list is empty, print a message using `System.out`.
 * 4.  **Exit:** Terminate the program.
 * 
 * **Expected Output:**
 * 
 * -   The program should start by printing a welcome message to `System.out`.
 * -   The menu should be displayed repeatedly to `System.out` until the user chooses to exit.
 * -   Prompts for input should be printed to `System.out`.
 * -   Successful operations (adding, processing, viewing) should print confirmation/details to `System.out`.
 * -   Error conditions (invalid menu choice, empty queue, invalid input format, input validation failures, unexpected exceptions) must print messages to `System.err`.
 * 
 * **Constraints:**
 * 
 * -   You must use the exact specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * -   The solution should be contained within a few classes (`Shipment`, `WarehouseManager`).
 * -   Focus on demonstrating the required concepts correctly.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Warehouse Shipment Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Shipment` Class:** A simple POJO (Plain Old Java Object) representing a shipment. It encapsulates the shipment's data (`id`, `description`, `quantity`) with private fields and public getters, following encapsulation principles. The `toString()` method provides a convenient way to print shipment details.
 * 
 * 2.  **`WarehouseManager` Class:** This is the main class managing the warehouse operations.
 *     *   **Data Structures:**
 *         *   `incomingShipmentsQueue`: Declared as `Queue<Shipment>` and instantiated as `LinkedList`. This correctly uses the `Queue` interface and a common implementation. It models the "waiting line" of shipments. `offer()` is used for adding (preferred over `add()` in queues as it handles capacity constraints, though `LinkedList` is unbounded), and `poll()` is used for retrieving and removing the head element (returns `null` if empty, which is handled).
 *         *   `completedShipmentsList`: Declared as `List<Shipment>` and instantiated as `ArrayList`. This meets the requirement of using the `List` interface with an `ArrayList` implementation. It stores shipments that have been processed. `add()` is used to append processed shipments, and iteration is done using a standard `for` loop with `get()`.
 *     *   **User Interaction:**
 *         *   `scanner`: An instance of `Scanner` reads input from `System.in`. Using `scanner.nextLine()` followed by parsing (`Integer.parseInt`) for numeric input is a robust way to handle potential non-numeric input without causing the scanner's state to become inconsistent, which can happen with `nextInt()`.
 *         *   `start()`: Contains the main application loop (`while(running)`). It repeatedly calls `displayMenu()` and reads user input.
 *         *   `switch`: Used within `start()` to direct execution flow based on the user's menu choice, satisfying the `switch` statement requirement.
 *         *   `displayMenu()`: Prints the available options to `System.out`.
 *     *   **Functionality Methods:**
 *         *   `addShipment()`: Prompts for shipment details. It includes basic input validation (`id > 0`, `quantity > 0`, `description` not empty) using `if` statements and returning early on failure, printing errors to `System.err`. Crucially, it uses a `try-catch` block specifically around the `Integer.parseInt()` calls to catch `NumberFormatException` if the user enters non-numeric text for ID or Quantity, reporting the error to `System.err`.
 *         *   `processNextShipment()`: Uses `incomingShipmentsQueue.poll()`. It checks if the result is `null` (meaning the queue was empty) and prints an error to `System.err`. If a shipment is retrieved, it's added to `completedShipmentsList`, and a success message is printed to `System.out`.
 *         *   `viewCompletedShipments()`: Checks if `completedShipmentsList` is empty, printing a message to `System.out`. Otherwise, it iterates through the list and prints each shipment's details to `System.out`.
 *     *   **Error Handling & Output Streams:**
 *         *   `System.err`: Used consistently for all error messages, including invalid menu choices, validation failures, parsing errors (`NumberFormatException`), and operational errors (empty queue).
 *         *   `System.out`: Used for all normal output, including the welcome message, menu display, input prompts, success confirmations, and the list of completed shipments.
 *         *   `try-catch`: A specific `try-catch` in `addShipment` handles `NumberFormatException`. A broader `try-catch` wraps the main `while` loop in `start()` to catch any other unexpected `Exception` that might occur during the command handling process, fulfilling the "class-wide exception handling" requirement. The `finally` block ensures the `scanner` is closed.
 *     *   **Best Practices:** Encapsulation is used in both classes. Method and variable names are descriptive. Basic comments explain the purpose of classes and methods. Input validation and specific error handling (empty queue, parsing errors) are implemented. The code is structured logically.
 *     *   **Resource Management:** The `closeScanner()` method is called in the `finally` block of `start()` to ensure the `Scanner` resource is closed properly, preventing resource leaks.
 * 
 * This solution effectively integrates the required Java components into a functional application, demonstrating understanding of data structures, control flow, user interaction, input handling, validation, and robust error management using the specified output streams and exception handling mechanisms.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although nextLine+parseInt is used, good to know.

/**
 * Represents a single product shipment.
 */
class Shipment {
    private int id;
    private String description;
    private int quantity;

    /**
     * Constructs a new Shipment object.
     * @param id The unique identifier for the shipment (must be positive).
     * @param description A brief description of the shipment contents.
     * @param quantity The number of items in the shipment (must be positive).
     */
    public Shipment(int id, String description, int quantity) {
        this.id = id;
        this.description = description;
        this.quantity = quantity;
    }

    // --- Getters ---
    public int getId() { return id; }
    public String getDescription() { return description; }
    public int getQuantity() { return quantity; }

    /**
     * Returns a string representation of the Shipment.
     * @return A formatted string describing the shipment.
     */
    @Override
    public String toString() {
        return "Shipment [ID=" + id + ", Description='" + description + "', Quantity=" + quantity + "]";
    }
}

/**
 * Manages incoming and completed shipments using a queue and a list.
 * Handles user interaction, input validation, and error reporting.
 */
public class WarehouseManager {
    // Queue to hold shipments waiting to be processed (incoming)
    private Queue<Shipment> incomingShipmentsQueue;
    // List to hold shipments that have been processed (completed)
    private List<Shipment> completedShipmentsList;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new WarehouseManager, initializing the queue, list, and scanner.
     */
    public WarehouseManager() {
        // Using LinkedList as a concrete implementation for the Queue interface
        this.incomingShipmentsQueue = new LinkedList<>();
        // Using ArrayList as a concrete implementation for the List interface
        this.completedShipmentsList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the main application loop, displaying the menu and handling user input.
     * Includes class-wide exception handling.
     */
    public void start() {
        System.out.println("Warehouse Shipment Management System Started.");
        boolean running = true;

        // Class-wide exception handling for the main interaction loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");
                String choice = scanner.nextLine(); // Read the whole line

                // Use switch statement for flow control based on user choice
                switch (choice.trim()) { // Use trim() to handle leading/trailing spaces
                    case "1":
                        addShipment();
                        break;
                    case "2":
                        processNextShipment();
                        break;
                    case "3":
                        viewCompletedShipments();
                        break;
                    case "4":
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Use System.err for invalid command errors
                        System.err.println("Error: Invalid choice. Please enter 1, 2, 3, or 4.");
                }
                System.out.println(); // Add a newline for better readability between interactions
            }
        } catch (Exception e) {
            // General catch-all for any unexpected runtime errors during the main loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging, to the error stream
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the application exits
            closeScanner();
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Displays the main menu options to the user via System.out.
     */
    private void displayMenu() {
        System.out.println("--- Warehouse Menu ---");
        System.out.println("1. Add New Incoming Shipment");
        System.out.println("2. Process Next Shipment");
        System.out.println("3. View Completed Shipments");
        System.out.println("4. Exit");
        System.out.println("----------------------");
    }

    /**
     * Prompts the user for shipment details, validates input, and adds a new
     * Shipment to the incoming queue. Handles NumberFormatException for integer inputs.
     */
    private void addShipment() {
        System.out.println("--- Add New Shipment ---");
        int id = -1;
        String description = null;
        int quantity = -1;

        // Use try-catch specifically for handling potential NumberFormatException
        try {
            System.out.print("Enter Shipment ID (integer > 0): ");
            // Read line and parse to handle non-integer input without crashing scanner
            String idStr = scanner.nextLine();
            id = Integer.parseInt(idStr);

            // Input validation for ID
            if (id <= 0) {
                 System.err.println("Validation Error: Shipment ID must be a positive integer.");
                 return; // Exit the method on validation failure
            }

            System.out.print("Enter Shipment Description: ");
            description = scanner.nextLine();

            // Input validation for description
            if (description == null || description.trim().isEmpty()) {
                System.err.println("Validation Error: Shipment description cannot be empty.");
                return; // Exit the method on validation failure
            }

            System.out.print("Enter Shipment Quantity (integer > 0): ");
            String quantityStr = scanner.nextLine();
            quantity = Integer.parseInt(quantityStr);

            // Input validation for quantity
            if (quantity <= 0) {
                System.err.println("Validation Error: Shipment quantity must be a positive integer.");
                return; // Exit the method on validation failure
            }

            // Create Shipment object and add to the queue
            Shipment newShipment = new Shipment(id, description.trim(), quantity);
            incomingShipmentsQueue.offer(newShipment); // offer() is preferred over add() for queues

            // Use System.out for success message
            System.out.println("Success: Shipment added to incoming queue -> " + newShipment);

        } catch (NumberFormatException e) {
            // Use System.err for reporting parsing errors
            System.err.println("Input Error: Invalid number format. Please enter integers for ID and Quantity.");
        } catch (Exception e) {
             // Catch any other unexpected errors during the add process
             System.err.println("An unexpected error occurred while adding shipment: " + e.getMessage());
             // e.printStackTrace(System.err);
        }
    }

    /**
     * Processes the next shipment from the incoming queue (removes it)
     * and adds it to the completed shipments list. Reports error if queue is empty.
     */
    private void processNextShipment() {
        System.out.println("--- Processing Shipment ---");
        // poll() retrieves and removes the head of the queue, returns null if empty
        Shipment shipmentToProcess = incomingShipmentsQueue.poll();

        if (shipmentToProcess != null) {
            completedShipmentsList.add(shipmentToProcess); // Add the processed shipment to the list
            // Use System.out for success message
            System.out.println("Success: Processed and moved to completed -> " + shipmentToProcess);
        } else {
            // Use System.err for error message when the queue is empty
            System.err.println("Processing Error: No incoming shipments to process. Queue is empty.");
        }
    }

    /**
     * Displays details of all shipments currently in the completed shipments list.
     * Reports message if the list is empty.
     */
    private void viewCompletedShipments() {
        System.out.println("--- Completed Shipments ---");
        if (completedShipmentsList.isEmpty()) {
            // Use System.out for normal informational message
            System.out.println("No shipments have been completed yet.");
        } else {
            // Iterate through the List and print each shipment's details using System.out
            for (int i = 0; i < completedShipmentsList.size(); i++) {
                 Shipment s = completedShipmentsList.get(i);
                 System.out.println((i + 1) + ". " + s);
            }
        }
    }

    /**
     * Closes the scanner resource to prevent resource leaks.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the Warehouse Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        manager.start();
    }
}
