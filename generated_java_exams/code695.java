/*
 * Exam Question #695
 * Generated on: 2025-05-12 16:26:46
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Appointment and Waiting List Management
 * 
 * **Objective:** Implement a simplified hospital appointment scheduling system that manages appointments and waiting lists for a set of doctors. The system should allow scheduling, viewing appointments, viewing the waiting list, and simulating the completion of an appointment to potentially schedule a patient from the waiting list.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available `Doctor` objects.
 *     *   Maintain a list of scheduled `Appointment` objects.
 *     *   Maintain a waiting list for patients who couldn't get an immediate appointment. This must use `java.util.Queue`.
 *     *   Use `java.util.ArrayList` for storing the lists of doctors and appointments.
 *     *   Declare variables holding lists using the `java.util.List` interface type.
 * 
 * 2.  **Classes:**
 *     *   Create a `Doctor` class (simple, perhaps just a name).
 *     *   Create a `Patient` class (simple, perhaps just a name).
 *     *   Create an `Appointment` class (linking a `Patient` and a `Doctor`).
 *     *   Create an `AppointmentScheduler` class which contains the `main` method and manages all data structures and application logic.
 * 
 * 3.  **Functionality (Menu-driven):** The `AppointmentScheduler` class should present a menu to the user with the following options, handled by a `switch` statement:
 *     *   **1. Schedule Appointment:**
 *         *   Prompt for patient name and desired doctor name.
 *         *   Find the doctor. If not found, print an error to `System.err`.
 *         *   Check if the requested doctor currently has a scheduled appointment. For simplicity, assume a doctor can only have one appointment at a time in this system.
 *         *   If the doctor is free, create and add the `Appointment` to the scheduled list and print a success message to `System.out`.
 *         *   If the doctor is busy, inform the user and ask if they want to join the waiting list. If 'Y' (case-insensitive), add the patient's name to the `Queue` and print a confirmation to `System.out`. Otherwise, print a cancellation message.
 *     *   **2. View Scheduled Appointments:** List all currently scheduled appointments, printing details to `System.out`. If none, print a message.
 *     *   **3. View Waiting List:** List all patients currently in the waiting `Queue`, printing details to `System.out`. If empty, print a message.
 *     *   **4. Simulate Appointment Completion:**
 *         *   Prompt for the doctor's name whose appointment has finished.
 *         *   Find the scheduled appointment for this doctor. If none found, print an error to `System.err`.
 *         *   If found, remove the appointment from the scheduled list. Print a completion message to `System.out`.
 *         *   After removing the appointment, check the waiting `Queue`. If it's not empty, dequeue the next patient. Attempt to schedule this patient with the now-free doctor. Create a new `Appointment` and add it to the scheduled list. Print a message indicating the patient from the queue has been scheduled to `System.out`.
 *     *   **5. Exit:** Terminate the program.
 * 
 * 4.  **Error Handling and Input Validation:**
 *     *   Use `Scanner` for all user input.
 *     *   Validate user input where necessary (e.g., checking if doctor exists, handling non-numeric input for menu options - although a simple `Scanner.nextLine` followed by parsing is sufficient for this exam).
 *     *   Use `System.err` for all error messages (e.g., doctor not found, invalid menu option, trying to complete a non-existent appointment).
 *     *   Use `System.out` for all normal output (menus, prompts, confirmations, lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential runtime errors during the main execution loop.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs optional for brevity, but inline comments explaining complex parts are required).
 *     *   Structure the code logically across classes.
 * 
 * **Initial Setup:**
 * *   Start with a pre-defined list of doctors (e.g., "Dr. Smith", "Dr. Jones", "Dr. Williams").
 * 
 * **Expected Interaction Flow:**
 * The program should repeatedly display the menu, accept user input, perform the requested action, and handle errors gracefully until the user chooses to exit.
 * 
 * **Example Output Snippets:**
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Schedule Appointment
 * 2. View Scheduled Appointments
 * 3. View Waiting List
 * 4. Simulate Appointment Completion
 * 5. Exit
 * Enter choice: 1
 * Enter patient name: Alice
 * Enter doctor name: Dr. Smith
 * Appointment scheduled for Alice with Dr. Smith.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 1
 * Enter patient name: Bob
 * Enter doctor name: Dr. Smith
 * Dr. Smith is currently busy. Join waiting list? (Y/N): Y
 * Bob added to the waiting list for Dr. Smith.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 2
 * Scheduled Appointments:
 * - Alice with Dr. Smith
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 3
 * Waiting List:
 * - Bob
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 4
 * Enter doctor name whose appointment finished: Dr. Smith
 * Appointment for Alice with Dr. Smith completed.
 * Patient Bob from the waiting list scheduled with Dr. Smith.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 2
 * Scheduled Appointments:
 * - Bob with Dr. Smith
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 3
 * Waiting List:
 * (Waiting list is empty)
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter choice: 6
 * java.lang.NumberFormatException: For input string: "invalid" // Example of System.err output for invalid input
 * Exiting system.
 * ```
 * 
 * Implement the full Java code solution meeting all the above requirements.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Doctor`, `Patient`, and `Appointment` are simple classes representing the core entities. They use private fields and public getters, adhering to **encapsulation**.
 *     *   `AppointmentScheduler` is the main class containing the application logic and data structures.
 * 
 * 2.  **Data Structures:**
 *     *   `doctorsList`: An `ArrayList<Doctor>` stores the available doctors. Declared as `List<Doctor>` to use the **List interface**.
 *     *   `scheduledAppointments`: An `ArrayList<Appointment>` stores the currently scheduled appointments. Declared as `List<Appointment>`.
 *     *   `waitingQueue`: A `LinkedList<Patient>` is used. `LinkedList` implements the `Queue` interface, making it suitable for a waiting list (FIFO - First-In, First-Out). Declared as `Queue<Patient>` to use the **Queue interface**.
 * 
 * 3.  **Required Components Usage:**
 *     *   `java.util.Queue`: Explicitly used for `waitingQueue`. `offer()` is used to add patients to the end, and `poll()` is used to retrieve and remove the patient at the front when a doctor becomes free.
 *     *   `java.util.ArrayList`: Used for the concrete implementations of `doctorsList` and `scheduledAppointments`.
 *     *   `java.util.List`: Used as the type declaration for `doctorsList` and `scheduledAppointments`, promoting flexibility.
 *     *   `java.util.Scanner`: An instance `scanner` is used to read user input from `System.in`.
 *     *   `switch` statement: Used in the `run()` method to direct the program flow based on the user's menu choice.
 *     *   `System.err`: Used consistently for printing error messages (e.g., "Doctor not found", "Invalid input", "No scheduled appointment found").
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, and listing appointments/waiting patients.
 *     *   `try-catch` blocks:
 *         *   A main `try-catch(Exception e)` block wraps the entire `run()` method's `while` loop for **class-wide exception handling**, catching any unexpected runtime errors.
 *         *   A specific `try-catch(NumberFormatException e)` is used within the loop to handle cases where the user enters non-numeric input for the menu choice, printing an error to `System.err`.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `findDoctorByName` and `isDoctorBusy` are helper methods demonstrating simple search logic.
 *     *   `scheduleAppointment`: Implements the core scheduling logic, checking doctor availability and using `waitingQueue.offer()` if the doctor is busy. Includes input validation for empty names.
 *     *   `viewScheduledAppointments`: Iterates through the `scheduledAppointments` list and prints details.
 *     *   `viewWaitingList`: Iterates through the `waitingQueue` (using a simple for-each loop which doesn't remove elements) and prints patient names.
 *     *   `simulateAppointmentCompletion`: Finds and removes an appointment using an `Iterator` (necessary for safe removal while looping). It then checks `waitingQueue` using `poll()` and schedules the next patient if available. Includes input validation for empty doctor name and error handling if no appointment is found for the doctor.
 *     *   `displayMenu` and `run` manage the user interaction loop.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Achieved by making fields private and providing public getters.
 *     *   **Meaningful Names:** Variables (`doctorsList`, `waitingQueue`, `scheduledAppointments`), classes (`AppointmentScheduler`, `Doctor`), and methods (`scheduleAppointment`, `simulateAppointmentCompletion`) have clear, descriptive names.
 *     *   **Comments:** Inline comments explain the purpose of key sections and data structures.
 *     *   **Input Validation:** Checks for empty input strings are included in `scheduleAppointment` and `simulateAppointmentCompletion`. `NumberFormatException` is caught for menu input.
 *     *   **Error Handling:** `System.err` is used for errors, and `try-catch` handles exceptions. A `finally` block ensures the `Scanner` is closed.
 *     *   **Clean Code Structure:** Logic is separated into methods, and the main `run` method orchestrates the process.
 * 
 * This solution effectively integrates all required Java components into a practical, albeit simplified, application, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration

// Represents a Doctor
class Doctor {
    private String name;

    public Doctor(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a Patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private Doctor doctor;

    public Appointment(Patient patient, Doctor doctor) {
        this.patient = patient;
        this.doctor = doctor;
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    @Override
    public String toString() {
        return patient.getName() + " with " + doctor.getName();
    }
}

// Main class managing appointments and waiting list
public class AppointmentScheduler {

    // Use List interface type for flexibility
    private List<Doctor> doctorsList;
    private List<Appointment> scheduledAppointments;
    // Use Queue for the waiting list
    private Queue<Patient> waitingQueue;
    private Scanner scanner;

    public AppointmentScheduler() {
        // Initialize data structures using ArrayList and LinkedList (for Queue)
        doctorsList = new ArrayList<>();
        scheduledAppointments = new ArrayList<>();
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        scanner = new Scanner(System.in);

        // Add some initial doctors
        doctorsList.add(new Doctor("Dr. Smith"));
        doctorsList.add(new Doctor("Dr. Jones"));
        doctorsList.add(new Doctor("Dr. Williams"));
        doctorsList.add(new Doctor("Dr. Garcia"));
    }

    // Finds a doctor by name
    private Doctor findDoctorByName(String name) {
        for (Doctor doctor : doctorsList) {
            if (doctor.getName().equalsIgnoreCase(name)) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    // Checks if a doctor is currently busy (has a scheduled appointment)
    private boolean isDoctorBusy(Doctor doctor) {
        for (Appointment appointment : scheduledAppointments) {
            if (appointment.getDoctor().equals(doctor)) {
                return true; // Doctor has an appointment
            }
        }
        return false; // Doctor is free
    }

    // Schedules a new appointment or adds to waiting list
    private void scheduleAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine();
        if (patientName.trim().isEmpty()) {
            System.err.println("Patient name cannot be empty.");
            return;
        }

        System.out.print("Enter desired doctor name: ");
        String doctorName = scanner.nextLine();
        if (doctorName.trim().isEmpty()) {
             System.err.println("Doctor name cannot be empty.");
            return;
        }

        Doctor doctor = findDoctorByName(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        Patient patient = new Patient(patientName);

        if (!isDoctorBusy(doctor)) {
            // Doctor is free, schedule the appointment
            Appointment newAppointment = new Appointment(patient, doctor);
            scheduledAppointments.add(newAppointment);
            System.out.println("Appointment scheduled for " + patient.getName() + " with " + doctor.getName() + ".");
        } else {
            // Doctor is busy, offer to add to waiting list
            System.out.println(doctor.getName() + " is currently busy.");
            System.out.print("Join waiting list? (Y/N): ");
            String choice = scanner.nextLine().trim();

            if (choice.equalsIgnoreCase("Y")) {
                waitingQueue.offer(patient); // Add patient to the end of the queue
                System.out.println(patient.getName() + " added to the waiting list for " + doctor.getName() + ".");
            } else {
                System.out.println("Appointment not scheduled. Patient did not join waiting list.");
            }
        }
    }

    // Displays all scheduled appointments
    private void viewScheduledAppointments() {
        System.out.println("\n--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("(No appointments scheduled)");
        } else {
            for (Appointment appointment : scheduledAppointments) {
                System.out.println("- " + appointment);
            }
        }
        System.out.println("------------------------------");
    }

    // Displays all patients in the waiting list
    private void viewWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("(Waiting list is empty)");
        } else {
            // Iterate over the queue without removing elements
            for (Patient patient : waitingQueue) {
                System.out.println("- " + patient.getName());
            }
        }
        System.out.println("--------------------");
    }

    // Simulates appointment completion for a doctor and potentially schedules from queue
    private void simulateAppointmentCompletion() {
        System.out.print("Enter doctor name whose appointment finished: ");
        String doctorName = scanner.nextLine();
         if (doctorName.trim().isEmpty()) {
             System.err.println("Doctor name cannot be empty.");
            return;
        }

        Doctor doctor = findDoctorByName(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        // Find and remove the appointment for this doctor
        Appointment completedAppointment = null;
        // Use Iterator for safe removal during iteration
        Iterator<Appointment> iterator = scheduledAppointments.iterator();
        while (iterator.hasNext()) {
            Appointment appointment = iterator.next();
            if (appointment.getDoctor().equals(doctor)) {
                completedAppointment = appointment;
                iterator.remove(); // Safely remove the current element
                break; // Assuming only one appointment per doctor
            }
        }

        if (completedAppointment != null) {
            System.out.println("Appointment for " + completedAppointment.getPatient().getName() +
                               " with " + doctor.getName() + " completed.");

            // Check the waiting list for a patient
            if (!waitingQueue.isEmpty()) {
                Patient nextPatient = waitingQueue.poll(); // Get and remove the head of the queue
                // Schedule the dequeued patient with the now-free doctor
                Appointment newAppointment = new Appointment(nextPatient, doctor);
                scheduledAppointments.add(newAppointment);
                System.out.println("Patient " + nextPatient.getName() +
                                   " from the waiting list scheduled with " + doctor.getName() + ".");
            } else {
                System.out.println(doctor.getName() + " is now free, no patients waiting.");
            }
        } else {
            System.err.println("Error: No scheduled appointment found for " + doctor.getName() + ".");
        }
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. View Scheduled Appointments");
        System.out.println("3. View Waiting List");
        System.out.println("4. Simulate Appointment Completion");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    // Runs the main application loop
    public void run() {
        int choice = 0;
        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                displayMenu();
                String input = scanner.nextLine(); // Read input as string to handle non-numeric gracefully

                try {
                    choice = Integer.parseInt(input); // Attempt to parse input
                } catch (NumberFormatException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    choice = 0; // Reset choice to prevent accidental exit if 5 was part of invalid input
                    continue; // Go back to the start of the loop
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        scheduleAppointment();
                        break;
                    case 2:
                        viewScheduledAppointments();
                        break;
                    case 3:
                        viewWaitingList();
                        break;
                    case 4:
                        simulateAppointmentCompletion();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handle valid integer input that is out of range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void main(String[] args) {
        AppointmentScheduler app = new AppointmentScheduler();
        app.run();
    }
}
