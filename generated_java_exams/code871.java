/*
 * Exam Question #871
 * Generated on: 2025-05-12 16:53:09
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam - Airport Baggage Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for managing baggage at an airport. The system needs to handle a central queue of bags waiting to be loaded and a list of flights currently on the ground, each with a limited baggage capacity. The system should allow ground staff to add new bags to the queue, add new flights, load bags from the queue onto specific flights, and view the current status.
 * 
 * Your implementation must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a central waiting area for bags using a `java.util.Queue`. Bags are processed in First-In, First-Out (FIFO) order.
 *     *   Maintain a list of flights currently on the ground using a `java.util.List`.
 *     *   Each `Flight` object must store a list of `Bag` objects that have been loaded onto it.
 * 
 * 2.  **Classes:**
 *     *   Create a `Bag` class (simple representation, e.g., with a unique ID).
 *     *   Create a `Flight` class with properties for flight ID, baggage capacity, and a list of loaded bags. Include methods to add a bag and check if the flight is full or get remaining capacity.
 *     *   Create a main class (e.g., `AirportBaggageSystem`) that orchestrates the operations.
 * 
 * 3.  **Functionality (Menu-Driven):** The main system should present a menu to the user with the following options:
 *     *   `1. Add New Bag to Queue`: Prompt for bag details (e.g., ID) and add it to the central bag queue.
 *     *   `2. Add New Flight`: Prompt for flight ID and baggage capacity. Create a `Flight` object and add it to the list of flights. Validate capacity (must be positive). Check for duplicate flight IDs.
 *     *   `3. Load Bags onto Flight`: Prompt for a flight ID. Find the flight. If found, move bags one by one from the *front* of the central queue onto this flight until either the flight reaches its capacity or the central queue is empty. Report how many bags were loaded.
 *     *   `4. View System Status`: Display the number of bags currently in the central queue and list each flight with its ID, current number of loaded bags, and remaining capacity.
 *     *   `5. Exit`: Terminate the program.
 * 
 * 4.  **User Interaction:** Use `java.util.Scanner` to get input from the user for menu choices and operation details.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 
 * 6.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during execution (e.g., invalid input format, trying to find a non-existent flight).
 *     *   Use `System.err` to print error messages.
 *     *   Use `System.out` for normal output (menu, prompts, status, success messages).
 *     *   Validate user input where necessary (e.g., positive capacity, non-empty IDs).
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (JavaDocs are encouraged but not strictly required for all methods in an exam setting, focus on clarity).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, prompt for input based on the chosen option, and provide feedback (success messages, status updates, or error messages) using `System.out` or `System.err` as appropriate. The status view should clearly show the state of the bag queue and all flights.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Airport Baggage Management System
 * Please choose an option:
 * 1. Add New Bag to Queue
 * 2. Add New Flight
 * 3. Load Bags onto Flight
 * 4. View System Status
 * 5. Exit
 * Enter choice: 1
 * Enter Bag ID: BAG101
 * Bag BAG101 added to the queue.
 * 
 * Enter choice: 2
 * Enter Flight ID: AA123
 * Enter Baggage Capacity for AA123: 5
 * Flight AA123 with capacity 5 added.
 * 
 * Enter choice: 1
 * Enter Bag ID: BAG102
 * Bag BAG102 added to the queue.
 * 
 * Enter choice: 1
 * Enter Bag ID: BAG103
 * Bag BAG103 added to the queue.
 * 
 * Enter choice: 4
 * --- System Status ---
 * Bags in central queue: 2
 * Flights:
 *  - Flight ID: AA123, Loaded Bags: 0, Remaining Capacity: 5
 * ---------------------
 * 
 * Enter choice: 3
 * Enter Flight ID to load bags: AA123
 * Attempting to load bags onto Flight AA123...
 * Successfully loaded 2 bag(s) onto Flight AA123.
 * 
 * Enter choice: 4
 * --- System Status ---
 * Bags in central queue: 0
 * Flights:
 *  - Flight ID: AA123, Loaded Bags: 2, Remaining Capacity: 3
 * ---------------------
 * 
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a basic Airport Baggage Management System demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):** The `baggageQueue` is declared as a `Queue<Bag>` and initialized using `java.util.LinkedList`. `LinkedList` is a common implementation for `Queue` because it provides efficient insertion and removal from both ends. The `offer()` method is used to add bags to the tail (end) of the queue, and `poll()` is used to retrieve and remove bags from the head (front) of the queue during the loading process, adhering to the FIFO principle.
 * 2.  **`ArrayList` (`java.util.ArrayList`):** The `flights` list is declared as a `List<Flight>` and initialized using `java.util.ArrayList`. `ArrayList` is suitable here for storing and iterating over the flights. Inside the `Flight` class, `loadedBags` is also an `ArrayList`, used to store the bags successfully loaded onto that specific flight.
 * 3.  **`List` interface (`java.util.List`):** The `flights` collection and the `loadedBags` collection within `Flight` are both declared using the `List` interface, promoting good practice by programming to the interface rather than the concrete implementation (`ArrayList`).
 * 4.  **`Scanner` (`java.util.Scanner`):** Used in the `AirportBaggageSystem` class to read user input from `System.in` for menu choices, bag IDs, flight IDs, and capacities. Proper handling of the newline character after reading integers (`scanner.nextLine()`) is included.
 * 5.  **`switch` statement:** The `run()` method uses a `switch` statement to direct the program flow based on the user's menu choice, calling the appropriate private methods (`addBagToQueue`, `addFlight`, etc.).
 * 6.  **`System.err`:** Used specifically for printing error messages to the standard error stream (e.g., invalid input, flight not found, capacity errors), distinguishing them from normal program output.
 * 7.  **`System.out`:** Used for all standard output, including the menu, prompts, success messages, and the system status display.
 * 8.  **Class-wide exception handling (`try-catch`):** A large `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This provides a top-level safety net to catch unexpected exceptions that might occur during the execution of any menu option, preventing the program from crashing abruptly. More specific `try-catch` blocks are also used within individual methods (`addBagToQueue`, `addFlight`, `loadBagsOntoFlight`) to handle expected potential issues like `InputMismatchException` (for non-numeric input) or `IllegalArgumentException` (for invalid data used to construct objects), allowing for more specific error reporting using `System.err`. The `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Fields in `Bag` and `Flight` classes are `private`. Access is provided via public getter methods (`getBagId`, `getFlightId`, etc.). Methods like `addBag` encapsulate the logic for modifying the state of a `Flight` object.
 * *   **Meaningful Names:** Class names (`Bag`, `Flight`, `AirportBaggageSystem`), variable names (`baggageQueue`, `flights`, `loadedBags`, `flightId`, `capacity`, `bagsLoadedCount`), and method names (`addBagToQueue`, `loadBagsOntoFlight`, `viewSystemStatus`) are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Basic comments explain the purpose of classes and key methods. JavaDocs are used for the `addBag` method in `Flight`.
 * *   **Input Validation:** Input is validated in constructors (`Bag`, `Flight`) to prevent creating objects with invalid data (null/empty IDs, non-positive capacity). The `addFlight` method also checks for duplicate flight IDs and handles `InputMismatchException` for numeric input.
 * *   **Proper Error Handling:** Specific `try-catch` blocks handle expected errors (invalid input format, invalid data), printing informative messages to `System.err`. The top-level `try-catch` handles unexpected runtime errors.
 * *   **Clean Code Structure:** The code is divided into logical classes (`Bag`, `Flight`, `AirportBaggageSystem`). The main system class contains methods for each distinct operation, making the code modular and easier to understand. The `run` method manages the main loop and menu dispatch.
 * 
 * This solution effectively integrates the required components into a functional system that simulates a real-world scenario, demonstrating a solid understanding of core and advanced Java concepts suitable for an exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single piece of baggage
class Bag {
    private String bagId;

    public Bag(String bagId) {
        if (bagId == null || bagId.trim().isEmpty()) {
            throw new IllegalArgumentException("Bag ID cannot be null or empty.");
        }
        this.bagId = bagId.trim();
    }

    public String getBagId() {
        return bagId;
    }

    @Override
    public String toString() {
        return "Bag{" + bagId + "}";
    }
}

// Represents a flight with baggage capacity
class Flight {
    private String flightId;
    private int capacity;
    private List<Bag> loadedBags;

    public Flight(String flightId, int capacity) {
        if (flightId == null || flightId.trim().isEmpty()) {
            throw new IllegalArgumentException("Flight ID cannot be null or empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.flightId = flightId.trim();
        this.capacity = capacity;
        this.loadedBags = new ArrayList<>(); // Use ArrayList for loaded bags
    }

    public String getFlightId() {
        return flightId;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Bag> getLoadedBags() {
        return loadedBags;
    }

    public boolean isFull() {
        return loadedBags.size() >= capacity;
    }

    public int getRemainingCapacity() {
        return capacity - loadedBags.size();
    }

    /**
     * Adds a bag to the flight if there is remaining capacity.
     *
     * @param bag The bag to add.
     * @return true if the bag was added, false if the flight is full.
     */
    public boolean addBag(Bag bag) {
        if (!isFull()) {
            loadedBags.add(bag);
            return true;
        }
        return false;
    }

    @Override
    public String toString() {
        return "Flight{" +
               "flightId='" + flightId + '\'' +
               ", capacity=" + capacity +
               ", loadedBags=" + loadedBags.size() +
               ", remaining=" + getRemainingCapacity() +
               '}';
    }
}

// Main system class orchestrating operations
public class AirportBaggageSystem {

    // Use LinkedList as a Queue implementation
    private Queue<Bag> baggageQueue;
    // Use ArrayList as a List implementation
    private List<Flight> flights;
    private Scanner scanner;

    public AirportBaggageSystem() {
        this.baggageQueue = new LinkedList<>(); // Queue for waiting bags
        this.flights = new ArrayList<>(); // List for active flights
        this.scanner = new Scanner(System.in);
    }

    public static void main(String[] args) {
        AirportBaggageSystem system = new AirportBaggageSystem();
        system.run();
    }

    public void run() {
        System.out.println("Airport Baggage Management System");
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1:
                        addBagToQueue();
                        break;
                    case 2:
                        addFlight();
                        break;
                    case 3:
                        loadBagsOntoFlight();
                        break;
                    case 4:
                        viewSystemStatus();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions at the top level
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private void printMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Bag to Queue");
        System.out.println("2. Add New Flight");
        System.out.println("3. Load Bags onto Flight");
        System.out.println("4. View System Status");
        System.out.println("5. Exit");
    }

    private void addBagToQueue() {
        try {
            System.out.print("Enter Bag ID: ");
            String bagId = scanner.nextLine();
            Bag newBag = new Bag(bagId);
            baggageQueue.offer(newBag); // offer is preferred over add for queues
            System.out.println("Bag " + newBag.getBagId() + " added to the queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding bag: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding bag: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    private void addFlight() {
        try {
            System.out.print("Enter Flight ID: ");
            String flightId = scanner.nextLine();

            // Check for duplicate flight ID
            for (Flight flight : flights) {
                if (flight.getFlightId().equalsIgnoreCase(flightId.trim())) {
                    System.err.println("Error: Flight with ID '" + flightId + "' already exists.");
                    return; // Exit the method
                }
            }

            System.out.print("Enter Baggage Capacity for " + flightId + ": ");
            int capacity = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            Flight newFlight = new Flight(flightId, capacity);
            flights.add(newFlight);
            System.out.println("Flight " + newFlight.getFlightId() + " with capacity " + newFlight.getCapacity() + " added.");

        } catch (InputMismatchException e) {
            System.err.println("Invalid input for capacity. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding flight: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding flight: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    private void loadBagsOntoFlight() {
        try {
            System.out.print("Enter Flight ID to load bags: ");
            String flightIdToLoad = scanner.nextLine();

            Flight targetFlight = null;
            for (Flight flight : flights) {
                if (flight.getFlightId().equalsIgnoreCase(flightIdToLoad.trim())) {
                    targetFlight = flight;
                    break;
                }
            }

            if (targetFlight == null) {
                System.err.println("Error: Flight with ID '" + flightIdToLoad + "' not found.");
                return;
            }

            if (targetFlight.isFull()) {
                System.out.println("Flight " + targetFlight.getFlightId() + " is already full. No bags loaded.");
                return;
            }

            System.out.println("Attempting to load bags onto Flight " + targetFlight.getFlightId() + "...");

            int bagsLoadedCount = 0;
            // Loop while the queue is not empty AND the flight is not full
            while (!baggageQueue.isEmpty() && !targetFlight.isFull()) {
                Bag bagToLoad = baggageQueue.poll(); // Retrieve and remove the head of the queue
                if (bagToLoad != null) { // poll returns null if queue is empty, but we already checked
                     if (targetFlight.addBag(bagToLoad)) {
                         bagsLoadedCount++;
                     } else {
                         // This case should ideally not happen due to the outer loop condition,
                         // but as a safeguard:
                         System.err.println("Warning: Flight unexpectedly became full while attempting to add bag.");
                         baggageQueue.offer(bagToLoad); // Put the bag back if it couldn't be added
                         break; // Stop loading
                     }
                }
            }

            System.out.println("Successfully loaded " + bagsLoadedCount + " bag(s) onto Flight " + targetFlight.getFlightId() + ".");
            if (!baggageQueue.isEmpty()) {
                 System.out.println(baggageQueue.size() + " bag(s) remain in the central queue.");
            }
            if (targetFlight.isFull()) {
                 System.out.println("Flight " + targetFlight.getFlightId() + " is now full.");
            }

        } catch (Exception e) {
             System.err.println("An unexpected error occurred while loading bags: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    private void viewSystemStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Bags in central queue: " + baggageQueue.size());

        System.out.println("Flights:");
        if (flights.isEmpty()) {
            System.out.println(" - No flights currently added.");
        } else {
            for (Flight flight : flights) {
                System.out.println(" - Flight ID: " + flight.getFlightId() +
                                   ", Loaded Bags: " + flight.getLoadedBags().size() +
                                   ", Remaining Capacity: " + flight.getRemainingCapacity());
            }
        }
        System.out.println("---------------------");
    }
}
