/*
 * Exam Question #700
 * Generated on: 2025-05-12 16:27:27
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Exam Question - Automated Job Processing System**
 * 
 * **Scenario:**
 * You are tasked with creating a simplified backend system for managing automated jobs. The system should maintain a queue of jobs waiting to be processed and an archive of jobs that have been completed. Users interact with the system via a command-line interface to add new jobs, process the next available job, and view the current state of the system.
 * 
 * **Job Definition:**
 * Each job should have:
 * -   A unique integer ID.
 * -   A string description (cannot be empty).
 * -   A status (either PENDING or COMPLETED).
 * 
 * **System Components:**
 * 1.  **Pending Queue:** Holds jobs that are waiting to be processed. Jobs are processed in the order they were added (FIFO).
 * 2.  **Completed Archive:** Holds jobs that have been successfully processed.
 * 
 * **User Interface:**
 * The system should present a menu to the user with the following options:
 * 1.  **Add New Job:** Prompts the user for a job description and adds it to the pending queue.
 * 2.  **Process Next Job:** Takes the next job from the pending queue, marks it as completed, and moves it to the completed archive.
 * 3.  **View Pending Jobs:** Displays all jobs currently in the pending queue.
 * 4.  **View Completed Jobs:** Displays all jobs in the completed archive.
 * 5.  **Exit:** Terminates the program.
 * 
 * **Implementation Requirements:**
 * 
 * Your solution must be a single Java program (one or more classes) and adhere to the following:
 * 
 * 1.  **Required Java Components:** You MUST use ALL of the following:
 *     *   `java.util.Queue` (specifically, use a concrete implementation like `LinkedList`) for the pending jobs.
 *     *   `java.util.ArrayList` for storing completed jobs.
 *     *   `java.util.List` interface (declare your completed jobs variable using this interface type).
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for handling the user's menu choice.
 *     *   `System.err` for printing all error messages (e.g., invalid input, trying to process an empty queue, adding a job with an empty description).
 *     *   `System.out` for printing all normal output (menu, prompts, successful actions, job lists).
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, particularly related to user input parsing and job creation/processing errors.
 * 
 * 2.  **Job Class:** Create a `Job` class to represent a single job. It should have private fields for ID, description, and status, with appropriate public getter methods. Include a method to mark the job as completed. Implement a `toString()` method for easy printing.
 * 3.  **Job Processor Class:** Create a class (e.g., `JobProcessor`) that manages the pending queue and completed list. It should contain methods corresponding to the menu options (add, process, view pending, view completed). This class should manage the unique job ID generation.
 * 4.  **Main Method:** Include a `main` method (either in `JobProcessor` or a separate class) that sets up the system, displays the menu, reads user input, and calls the appropriate `JobProcessor` methods using a loop.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include brief comments where necessary to explain logic.
 *     *   Implement input validation (e.g., job description not empty, menu choice is a valid number).
 *     *   Implement robust error handling using `try-catch` and `System.err`.
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Expected Output:**
 * 
 * Your program should produce output similar to the following examples, demonstrating various operations and error handling:
 * 
 * ```
 * --- Automated Job Processing System ---
 * 
 * Choose an action:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter job description: Clean database
 * Successfully added: Job [ID=1, Description='Clean database', Status=PENDING]
 * 
 * Choose an action:
 * ...
 * Enter choice: 1
 * Enter job description: Generate report
 * Successfully added: Job [ID=2, Description='Generate report', Status=PENDING]
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * 
 * --- Pending Jobs ---
 * 1. Job [ID=1, Description='Clean database', Status=PENDING]
 * 2. Job [ID=2, Description='Generate report', Status=PENDING]
 * --------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Processing job: Clean database
 * Job ID 1 marked as completed and moved to archive.
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * 
 * --- Pending Jobs ---
 * 1. Job [ID=2, Description='Generate report', Status=PENDING]
 * --------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 4
 * 
 * --- Completed Jobs ---
 * 1. Job [ID=1, Description='Clean database', Status=COMPLETED]
 * ----------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 1
 * Enter job description:
 * Error adding job: Job description cannot be null or empty.
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Processing job: Generate report
 * Job ID 2 marked as completed and moved to archive.
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Error: No pending jobs to process.
 * 
 * Choose an action:
 * ...
 * Enter choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * Choose an action:
 * ...
 * Enter choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Choose an action:
 * ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * System shut down.
 * ```
 * 
 * Your code will be evaluated on correctness, adherence to all requirements (especially the mandatory component usage), code quality, and error handling.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Automated Job Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Structure:** The solution is organized into three parts:
 *     *   `JobStatus` enum: Defines the possible states of a job (PENDING, COMPLETED).
 *     *   `Job` class: Represents a single job with its attributes (ID, description, status) and behavior (`markAsCompleted()`, `toString()`). It enforces data encapsulation by keeping fields private and providing public getters. The constructor includes input validation for the description.
 *     *   `JobProcessor` class: This is the core class that manages the system's state and operations. It holds the collections for pending and completed jobs and contains methods for adding, processing, and viewing jobs. It also contains the `main` method to run the application.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `pendingJobs` field is declared as a `Queue<Job>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` that provides FIFO behavior suitable for a processing queue. The `offer()` method is used to add jobs to the tail, and `poll()` is used to retrieve and remove jobs from the head.
 *     *   `java.util.ArrayList`: Used as the concrete implementation for the `completedJobs` list (`new ArrayList<>()`). `ArrayList` provides dynamic resizing and efficient element access, suitable for storing completed items where insertion order is maintained but FIFO processing is no longer required.
 *     *   `java.util.List`: The `completedJobs` field is declared using the `List<Job>` interface type (`private List<Job> completedJobs;`). This demonstrates programming to an interface, which promotes flexibility (e.g., you could change the implementation to `LinkedList` or `Vector` later without changing the variable's type).
 *     *   `java.util.Scanner`: An instance of `Scanner` is created in the `main` method (`new Scanner(System.in)`) to read user input from the console (`scanner.nextLine()`). The `Scanner` is properly closed using `scanner.close()` when the main loop finishes.
 *     *   `switch`: A `switch` statement in the `main` method is used to control the program flow based on the user's integer choice from the menu. Each case corresponds to a menu option, calling the appropriate method in the `JobProcessor` instance. The `default` case handles invalid numeric choices.
 *     *   `System.err`: Used specifically for printing error messages, such as when an invalid job description is provided (`addJob`), when attempting to process an empty queue (`processNextJob`), when the user enters non-numeric input (`main` catch block for `NumberFormatException`), or when the menu choice is out of the valid range (`main` switch default).
 *     *   `System.out`: Used for all standard output, including the welcome message, the menu, prompts for input (like job description), success messages after operations, and the formatted lists of pending and completed jobs.
 *     *   `try-catch`: Exception handling is implemented at multiple levels.
 *         *   The `Job` constructor has an `IllegalArgumentException` for invalid descriptions.
 *         *   The `addJob` method uses a `try-catch` block to handle the `IllegalArgumentException` thrown by the `Job` constructor and also catches general `Exception`, printing an error message to `System.err`.
 *         *   The `processNextJob` method includes a `try-catch` block to handle potential exceptions during the processing simulation (though simple here, it demonstrates the pattern).
 *         *   The `main` method has a `try-catch` block around the input reading and `switch` statement. This block specifically catches `NumberFormatException` if the user enters non-numeric input for the menu choice, printing an error to `System.err`. It also includes a general `catch (Exception e)` as a broader safety net for any other unexpected runtime issues within the loop, demonstrating "class-wide" or main application loop handling.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** The `Job` class's fields are private, accessible only through public getter methods. The `JobProcessor` manages its internal collections (`pendingJobs`, `completedJobs`) through its public methods.
 *     *   **Meaningful Names:** Variables (`pendingJobs`, `completedJobs`, `nextJobId`, `description`, `choice`, `running`), methods (`addJob`, `processNextJob`, `viewPendingJobs`, `viewCompletedJobs`, `markAsCompleted`), and the enum (`JobStatus`) have names that clearly indicate their purpose.
 *     *   **Comments:** Brief comments are included to explain the purpose of classes, methods, important variables, and specific code blocks (like `try-catch` usage or collection operations).
 *     *   **Input Validation:** The `Job` constructor validates the description, and the `main` method handles validation of the menu choice (checking if it's an integer and if it's within the valid range).
 *     *   **Error Handling:** Errors are caught using `try-catch`, reported using `System.err`, and handled gracefully (e.g., preventing invalid job creation, informing the user when the queue is empty).
 *     *   **Clean Code Structure:** The code is divided into logical classes and methods, making it readable and maintainable. The main loop clearly separates input reading, parsing, and action execution. The `Scanner` is closed properly.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, showcasing fundamental object-oriented principles, collection usage, and robust error handling techniques expected at an advanced beginner or intermediate level.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a job
enum JobStatus {
    PENDING,
    COMPLETED
}

// Class to represent a single Job
class Job {
    private int id;
    private String description;
    private JobStatus status;

    /**
     * Constructs a new Job with a unique ID and description.
     * Status is initialized to PENDING.
     *
     * @param id The unique ID for the job.
     * @param description The description of the job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Job(int id, String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = JobStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public JobStatus getStatus() {
        return status;
    }

    /**
     * Marks the job's status as COMPLETED.
     */
    public void markAsCompleted() {
        this.status = JobStatus.COMPLETED;
    }

    /**
     * Provides a string representation of the Job object.
     */
    @Override
    public String toString() {
        return "Job [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Class to manage the job processing system
public class JobProcessor {

    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<Job> pendingJobs;
    // List to hold jobs that have been completed (using ArrayList implementation)
    private List<Job> completedJobs;
    // Static counter to generate unique job IDs
    private static int nextJobId = 1;

    /**
     * Constructs a new JobProcessor, initializing the pending queue and completed list.
     */
    public JobProcessor() {
        pendingJobs = new LinkedList<>(); // Implementation of Queue
        completedJobs = new ArrayList<>(); // Implementation of List
    }

    /**
     * Adds a new job to the pending queue.
     *
     * @param description The description of the job.
     * @return true if the job was added successfully, false otherwise.
     */
    public boolean addJob(String description) {
        // Use try-catch for potential exceptions during Job creation (e.g., validation)
        try {
            // Create a new Job with the next available ID
            Job newJob = new Job(nextJobId++, description);
            // Add the job to the tail of the pending queue
            pendingJobs.offer(newJob); // offer is generally preferred over add for queues
            System.out.println("Successfully added: " + newJob);
            return true;
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Job constructor
            System.err.println("Error adding job: " + e.getMessage());
            // Decrement ID if job creation failed after incrementing nextJobId
            nextJobId--; // Basic rollback
            return false;
        } catch (Exception e) {
             // Catch any other unexpected errors during the add process
             System.err.println("An unexpected error occurred while adding job: " + e.getMessage());
             nextJobId--; // Basic rollback
             return false;
        }
    }

    /**
     * Processes the next job in the pending queue (if any).
     * Moves the job from the pending queue to the completed list after marking it complete.
     */
    public void processNextJob() {
        // Check if the queue is empty before attempting to process
        if (pendingJobs.isEmpty()) {
            System.err.println("Error: No pending jobs to process.");
            return;
        }

        // Use try-catch for potential exceptions during processing
        try {
            // Retrieve and remove the head of the queue (FIFO)
            Job jobToProcess = pendingJobs.poll();

            // poll returns null if queue is empty, but we checked above.
            // This null check adds robustness in case of concurrent modification (not applicable here but good practice).
            if (jobToProcess != null) {
                System.out.println("Processing job: " + jobToProcess.getDescription());
                // Simulate processing...
                jobToProcess.markAsCompleted(); // Update job status
                completedJobs.add(jobToProcess); // Add to the completed list
                System.out.println("Job ID " + jobToProcess.getId() + " marked as completed and moved to archive.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during the processing step
            System.err.println("An unexpected error occurred during job processing: " + e.getMessage());
            // In a real system, you might log the error, re-queue the job, etc.
        }
    }

    /**
     * Displays all jobs currently residing in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs currently in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Job job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("--------------------\n");
    }

    /**
     * Displays all jobs that have been processed and moved to the completed archive.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list
            int index = 1;
            for (Job job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("----------------------\n");
    }

    /**
     * Main method to run the Automated Job Processing System.
     * Handles user interaction, menu display, and delegates tasks to JobProcessor instance.
     */
    public static void main(String[] args) {
        JobProcessor processor = new JobProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true; // Control variable for the main loop

        System.out.println("--- Automated Job Processing System ---");

        // Main application loop
        while (running) {
            System.out.println("\nChoose an action:");
            System.out.println("1. Add New Job");
            System.out.println("2. Process Next Job");
            System.out.println("3. View Pending Jobs");
            System.out.println("4. View Completed Jobs");
            System.out.println("5. Exit");
            System.out.print("Enter choice: ");

            String inputLine = scanner.nextLine(); // Read the entire line
            int choice = -1; // Default value for invalid choice

            // Use try-catch for input parsing and handling potential errors within the loop
            try {
                // Attempt to parse the user input as an integer
                choice = Integer.parseInt(inputLine);

                // Use switch statement to handle different menu choices
                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        processor.addJob(description); // Delegate to JobProcessor method
                        break;
                    case 2:
                        processor.processNextJob(); // Delegate to JobProcessor method
                        break;
                    case 3:
                        processor.viewPendingJobs(); // Delegate to JobProcessor method
                        break;
                    case 4:
                        processor.viewCompletedJobs(); // Delegate to JobProcessor method
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch exception if input cannot be parsed as an integer
                System.err.println("Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur within the try block
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected issues
            }
        }

        // Ensure the scanner is closed when the application exits
        scanner.close();
        System.out.println("System shut down.");
    }
}
