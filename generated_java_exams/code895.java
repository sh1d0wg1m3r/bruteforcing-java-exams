/*
 * Exam Question #895
 * Generated on: 2025-05-12 16:56:19
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Package Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based application for a small logistics hub. The system manages packages as they arrive, are processed, and are archived. Packages are received and placed into an incoming queue. A worker processes packages one by one from the front of this queue. Once a package is processed, it is moved to a historical list of completed items.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a class named `Package` to represent a package. This class must have the following **private** fields:
 *     *   `packageId` (String): A unique identifier for the package.
 *     *   `description` (String): A brief description of the package contents.
 *     *   `status` (String): Represents the current status of the package (e.g., "IN_QUEUE", "PROCESSED").
 *     Implement a constructor that initializes these fields (status should default to "IN_QUEUE"). Provide **public** getter methods for all fields and a public method `setStatus(String status)` to update the status. Override the `toString()` method to provide a clear string representation of the `Package` object. Ensure package ID and description are not null or empty strings upon creation (throw `IllegalArgumentException`).
 * 
 * 2.  **System Class:** Create a class named `LogisticsSystem` that manages the package flow. It must contain:
 *     *   A **private** field `incomingQueue` of type `java.util.Queue<Package>`. Use a `LinkedList` implementation.
 *     *   A **private** field `processedPackages` of type `java.util.List<Package>`. Use an `ArrayList` implementation.
 *     *   A **private** field `scanner` of type `java.util.Scanner` for reading user input.
 * 
 * 3.  **Functionality:** Implement the following methods within the `LogisticsSystem` class:
 *     *   `addPackage()`: Prompts the user to enter a package ID and description. Creates a new `Package` object using this input and adds it to the `incomingQueue`. Handle potential `IllegalArgumentException` from the `Package` constructor.
 *     *   `processNextPackage()`: Attempts to retrieve and remove the package at the front of the `incomingQueue`. If the queue is empty, print an error message to `System.err`. If successful, update the package's status to "PROCESSED" and add it to the `processedPackages` list. Print a success message to `System.out`.
 *     *   `viewIncomingQueue()`: Prints the details of all packages currently in the `incomingQueue` to `System.out`. Clearly indicate if the queue is empty.
 *     *   `viewProcessedPackages()`: Prints the details of all packages in the `processedPackages` list to `System.out`. Clearly indicate if the list is empty.
 *     *   `run()`: This method should contain the main application loop. It should repeatedly display a menu of options (Add Package, Process Next, View Queue, View Processed, Exit), read the user's choice, and use a **`switch` statement** to call the appropriate method. The loop should continue until the user chooses to exit.
 *     *   `closeScanner()`: A helper method to close the `Scanner` resource.
 * 
 * 4.  **User Interface & Input:** Use `System.out` for all normal output (menu, prompts, results, list/queue contents). Use `java.util.Scanner` to read user input for menu choices and package details.
 * 
 * 5.  **Error Handling:**
 *     *   Use **`System.err`** exclusively for printing error messages (e.g., invalid menu choice, queue empty, invalid package input).
 *     *   Implement **class-wide `try-catch` blocks** within the `run()` method to handle potential exceptions during the main loop execution, especially `InputMismatchException` when reading integer input for the menu choice. Ensure the program recovers gracefully from invalid input without crashing or entering an infinite loop.
 *     *   Handle the specific case of trying to process a package when the `incomingQueue` is empty.
 *     *   Handle the case of invalid input (empty ID/description) when creating a `Package`.
 * 
 * 6.  **Best Practices:** Adhere to Java best practices, including proper encapsulation, using meaningful variable and method names, adding comments where necessary, and ensuring resources (like the `Scanner`) are properly closed using a `finally` block or similar mechanism.
 * 
 * **Required Components Checklist:**
 * - [ ] `java.util.Queue`
 * - [ ] `java.util.ArrayList`
 * - [ ] `java.util.List` (used as type)
 * - [ ] `java.util.Scanner`
 * - [ ] `switch` statement
 * - [ ] `System.err`
 * - [ ] `System.out`
 * - [ ] Class-wide `try-catch`
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a menu. Based on user input, it should perform the requested action, display relevant information (package details, status), or print error messages using the correct stream (`System.out` or `System.err`). The program should continue running until the user selects the 'Exit' option. Viewing queue/list contents should print each package on a new line using its `toString()` representation.
 * 
 * ```
 * --- Logistics Package Processing System ---
 * 1. Add Package to Queue
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P101
 * Enter Package Description: Electronics
 * Package added to queue: P101
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * 
 * --- Incoming Queue ---
 * Package ID: P101, Description: Electronics, Status: IN_QUEUE
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processed package: P101
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * 
 * --- Processed Packages ---
 * Package ID: P101, Description: Electronics, Status: PROCESSED
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Incoming queue is empty. No packages to process. (This line should go to System.err)
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. (This line should go to System.err)
 * 
 * --- Logistics Package Processing System ---
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Logistics System. Goodbye!
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple Logistics Package Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   This class represents a single package with `packageId`, `description`, and `status` as **private** fields, enforcing encapsulation.
 *     *   The constructor validates that the `packageId` and `description` are not empty, throwing an `IllegalArgumentException` if they are. This is an example of input validation and specific exception usage.
 *     *   **Public** getter methods (`getPackageId`, `getDescription`, `getStatus`) provide controlled access to the data.
 *     *   A **public** `setStatus` method allows updating the package's state.
 *     *   The overridden `toString()` method provides a convenient way to print package details.
 * 
 * 2.  **`LogisticsSystem` Class:**
 *     *   This is the core class managing the system state and operations.
 *     *   It uses a **private** `java.util.Queue<Package>` named `incomingQueue`. A `java.util.LinkedList` is chosen as the implementation because it efficiently supports adding elements to the end (`offer`) and removing elements from the beginning (`poll`), which is characteristic of a queue (FIFO - First-In, First-Out).
 *     *   It uses a **private** `java.util.List<Package>` named `processedPackages`, specifically initialized as a `java.util.ArrayList`. An `ArrayList` is suitable here as processed items are stored historically, and we might need to iterate or access them later; `ArrayList` provides efficient random access and iteration. The use of the `List` interface for the variable declaration demonstrates polymorphism and good practice.
 *     *   A **private** `java.util.Scanner` is used to read input from `System.in`.
 * 
 * 3.  **Functionality Methods:**
 *     *   `displayMenu()`: A helper method using `System.out` to show the user the available options.
 *     *   `addPackage()`: Reads package details from the user, attempts to create a `Package` object, and uses `incomingQueue.offer()` to add it. It includes a `try-catch` block to specifically handle `IllegalArgumentException` thrown by the `Package` constructor if input validation fails, printing the error to `System.err`.
 *     *   `processNextPackage()`: Uses `incomingQueue.poll()` to retrieve and remove the next package. `poll()` is ideal as it returns `null` if the queue is empty, which is then checked to print an error message to `System.err`. If a package is retrieved, its status is updated, and it's added to the `processedPackages` list. Success messages go to `System.out`.
 *     *   `viewIncomingQueue()` and `viewProcessedPackages()`: These methods iterate through the respective collections (`Queue` and `List`) and print each package's details using its `toString()` method and `System.out`. They check if the collections are empty and report accordingly.
 *     *   `closeScanner()`: A simple method to close the `Scanner` resource, preventing resource leaks.
 * 
 * 4.  **User Interface and `switch`:**
 *     *   The `run()` method implements the main application loop.
 *     *   It repeatedly calls `displayMenu()` and reads the user's integer choice using `scanner.nextInt()`.
 *     *   A **`switch` statement** is used to direct execution based on the user's valid input (cases 1 through 5).
 *     *   `System.out` is used for menu display, prompts, and successful operation output.
 * 
 * 5.  **Error Handling and `try-catch`:**
 *     *   **`System.err`** is used for all error messages, such as "Invalid choice", "Incoming queue is empty", and "Error adding package".
 *     *   A **class-wide `try-catch` block** wraps the main `while` loop within the `run()` method. This block specifically catches `InputMismatchException` which occurs if the user enters non-integer input when prompted for a menu choice. When this exception is caught, an error is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input from the buffer, preventing an infinite loop.
 *     *   A general `catch (Exception e)` is included as a fallback within the class-wide block to catch any other unexpected runtime errors that might occur within the loop, printing the error and stack trace to `System.err`.
 *     *   The `processNextPackage` method handles the empty queue case by checking the `null` return value of `poll()`.
 *     *   The `addPackage` method handles invalid package input by catching the `IllegalArgumentException` from the `Package` constructor.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Achieved in the `Package` class with private fields and public methods.
 *     *   **Meaningful Names:** Variables (`incomingQueue`, `processedPackages`, `packageId`) and methods (`addPackage`, `processNextPackage`, `viewIncomingQueue`) have clear, descriptive names.
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** Done in the `Package` constructor and the `run` method's input reading loop.
 *     *   **Error Handling:** Comprehensive handling using `try-catch`, `System.err`, and specific checks (like `queue.isEmpty()` or `poll() == null`).
 *     *   **Clean Code Structure:** Logic is separated into distinct methods (`addPackage`, `processNextPackage`, etc.), making the code modular and readable.
 *     *   **Resource Management:** The `Scanner` is explicitly closed in a `finally` block within the `run()` method, ensuring it's closed even if exceptions occur.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating advanced understanding of collection usage, error handling, and application structure.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Package class adhering to encapsulation
class Package {
    private String packageId;
    private String description;
    private String status; // e.g., "IN_QUEUE", "PROCESSED"

    /**
     * Constructs a new Package.
     *
     * @param packageId   The unique ID of the package. Must not be null or empty.
     * @param description A description of the package. Must not be null or empty.
     * @throws IllegalArgumentException if packageId or description is null or empty.
     */
    public Package(String packageId, String description) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be empty.");
        }
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Package description cannot be empty.");
        }
        this.packageId = packageId.trim();
        this.description = description.trim();
        this.status = "IN_QUEUE"; // Initial status
    }

    // Public getters
    public String getPackageId() {
        return packageId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the package.
     * @param status The new status string.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Package ID: %s, Description: %s, Status: %s",
                             packageId, description, status);
    }
}

// LogisticsSystem class managing package flow
public class LogisticsSystem {
    // Use Queue for FIFO incoming packages
    private Queue<Package> incomingQueue;
    // Use List for processed packages history
    private List<Package> processedPackages;
    // Scanner for user input
    private Scanner scanner;

    /**
     * Constructs a new LogisticsSystem, initializing collections and scanner.
     */
    public LogisticsSystem() {
        // LinkedList implements Queue and is efficient for add/remove at ends
        this.incomingQueue = new LinkedList<>();
        // ArrayList is good for storing and iterating over processed items
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Logistics Package Processing System ---");
        System.out.println("1. Add Package to Queue");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts user for package details, creates a Package object, and adds it to the queue.
     * Handles invalid input for package creation.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine(); // Read ID

        System.out.print("Enter Package Description: ");
        String description = scanner.nextLine(); // Read Description

        try {
            // Attempt to create package - constructor validates input
            Package newPackage = new Package(id, description);
            // offer() is a safe way to add to queue, returns false on failure
            if (incomingQueue.offer(newPackage)) {
                System.out.println("Package added to queue: " + newPackage.getPackageId());
            } else {
                 // This case is rare with LinkedList but good practice
                 System.err.println("Failed to add package to queue.");
            }
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Package constructor
            System.err.println("Error adding package: " + e.getMessage());
        }
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves it to the processed list after updating status.
     * Handles empty queue scenario.
     */
    private void processNextPackage() {
        // poll() retrieves and removes the head, returns null if queue is empty
        Package packageToProcess = incomingQueue.poll();

        if (packageToProcess == null) {
            // Use System.err for error message
            System.err.println("Incoming queue is empty. No packages to process.");
        } else {
            packageToProcess.setStatus("PROCESSED");
            processedPackages.add(packageToProcess);
            // Use System.out for success message
            System.out.println("Processed package: " + packageToProcess.getPackageId());
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    private void viewIncomingQueue() {
        System.out.println("\n--- Incoming Queue ---");
        if (incomingQueue.isEmpty()) {
            System.out.println("The incoming queue is empty.");
        } else {
            // Iterate using forEach and Package's toString()
            incomingQueue.forEach(System.out::println);
        }
    }

    /**
     * Displays all packages that have been processed.
     */
    private void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Iterate using forEach and Package's toString()
            processedPackages.forEach(System.out::println);
        }
    }

    /**
     * Closes the scanner resource. Important for resource management.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            // System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * The main application loop and entry point for user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1; // Variable to store user's menu choice

        // Class-wide try-catch block wrapping the main operational loop
        try {
            // Loop continues until the user chooses option 5 (Exit)
            while (choice != 5) {
                displayMenu(); // Display the menu options

                try {
                    // Attempt to read the user's integer choice
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            addPackage(); // Call method to add a package
                            break;
                        case 2:
                            processNextPackage(); // Call method to process next package
                            break;
                        case 3:
                            viewIncomingQueue(); // Call method to view incoming queue
                            break;
                        case 4:
                            viewProcessedPackages(); // Call method to view processed packages
                            break;
                        case 5:
                            System.out.println("Exiting Logistics System. Goodbye!");
                            break; // Exit the loop
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.nextLine();
                    // Reset choice to a non-exit value to continue the loop
                    choice = -1;
                }
                // Note: Other exceptions from called methods (like IllegalArgumentException
                // from addPackage) are caught within those methods. This outer catch
                // is primarily for exceptions escaping those methods or general loop issues.

            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that occur during the main loop
            System.err.println("An unrecoverable error occurred: " + e.getMessage());
            // Print the stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed regardless of how the loop exits
            closeScanner();
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        LogisticsSystem system = new LogisticsSystem();
        system.run(); // Start the main application loop
        // The finally block in run() ensures closeScanner() is called upon exit.
    }
}
