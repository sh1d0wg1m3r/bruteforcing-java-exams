/*
 * Exam Question #553
 * Generated on: 2025-05-11 23:28:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Attendee Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple system to manage attendees for a popular event with a fixed capacity. Attendees can register to join a waiting queue. When capacity becomes available, attendees from the queue are admitted, with VIP ticket holders receiving priority over Standard ticket holders. The system needs to handle registration, admission, and provide status updates.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this event management system. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage attendees who are waiting for admission.
 *     *   Use `java.util.ArrayList` to store attendees who have been admitted to the event.
 *     *   Use `java.util.List` interface where appropriate (e.g., for method return types or parameters dealing with lists).
 * 
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands and data from standard input.
 *     *   Use `System.out.println` for all normal program output (success messages, lists, status).
 *     *   Use `System.err.println` for all error messages (invalid input, capacity full, attendee not found, etc.).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to process different user commands.
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for user commands and data (e.g., correct number of arguments, valid ticket types, positive numbers for admission count).
 *     *   Use `try-catch` blocks for exception handling. Implement a class-wide `try-catch` or wrap the main command processing loop in a `try-catch` to handle unexpected runtime errors gracefully, in addition to specific `try-catch` for potential input issues (`InputMismatchException`).
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Create an `Attendee` class with private fields (`id`, `name`, `ticketType`) and public getter methods. Ensure `id` is unique. Ticket types should be "VIP" or "Standard".
 *     *   Create an `EventManager` class that encapsulates the event logic. It should contain the `Queue` for waiting attendees, the `ArrayList` for admitted attendees, the total event capacity, and the current available capacity.
 *     *   Implement methods within `EventManager` for:
 *         *   `registerAttendee(int id, String name, String ticketType)`: Adds a new attendee to the waiting queue. Validates input and checks for duplicate IDs (in both waiting and admitted lists).
 *         *   `admitAttendees(int count)`: Attempts to admit up to `count` attendees from the waiting queue. Prioritizes VIP attendees over Standard attendees from the queue. Moves admitted attendees from the queue to the admitted list. Updates available capacity.
 *         *   `displayStatus()`: Prints the total capacity, available capacity, number of attendees waiting, and number of attendees admitted.
 *         *   `listAdmitted()`: Prints details of all admitted attendees.
 *         *   `listWaiting()`: Prints details of all attendees currently in the waiting queue.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc-style documentation.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Write clean, readable code.
 * 
 * **Commands:**
 * 
 * The program should accept the following commands from the user:
 * 
 * *   `register <id> <name> <ticketType>`: Registers an attendee. `<ticketType>` must be "VIP" or "Standard". `<id>` must be an integer.
 * *   `admit <count>`: Attempts to admit up to `<count>` attendees. `<count>` must be a positive integer.
 * *   `status`: Displays the current event status.
 * *   `list_admitted`: Lists all admitted attendees.
 * *   `list_waiting`: Lists all attendees in the waiting queue.
 * *   `exit`: Terminates the program.
 * 
 * **Initial State:**
 * 
 * The event manager should be initialized with a fixed total capacity (e.g., 10). Initially, the waiting queue and admitted list are empty, and available capacity equals total capacity.
 * 
 * **Expected Output:**
 * 
 * *   Successful command execution should print informative messages using `System.out`.
 * *   Invalid commands, incorrect arguments, or operational failures (e.g., registering duplicate ID, admitting more than available capacity) should print error messages using `System.err`.
 * *   `status`, `list_admitted`, and `list_waiting` commands should clearly format and print the requested information using `System.out`.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Enter command: status
 * Event Status:
 * Capacity: 10
 * Available: 10
 * Waiting: 0
 * Admitted: 0
 * 
 * Enter command: register 101 Alice VIP
 * Attendee 101 (Alice) registered successfully. Waiting in queue.
 * 
 * Enter command: register 102 Bob Standard
 * Attendee 102 (Bob) registered successfully. Waiting in queue.
 * 
 * Enter command: register 103 Charlie VIP
 * Attendee 103 (Charlie) registered successfully. Waiting in queue.
 * 
 * Enter command: status
 * Event Status:
 * Capacity: 10
 * Available: 10
 * Waiting: 3
 * Admitted: 0
 * 
 * Enter command: list_waiting
 * Waiting Queue:
 * ID: 101, Name: Alice, Type: VIP
 * ID: 102, Name: Bob, Type: Standard
 * ID: 103, Name: Charlie, Type: VIP
 * 
 * Enter command: admit 1
 * Admitted 1 attendee.
 * 
 * Enter command: status
 * Event Status:
 * Capacity: 10
 * Available: 9
 * Waiting: 2
 * Admitted: 1
 * 
 * Enter command: list_admitted
 * Admitted Attendees:
 * ID: 101, Name: Alice, Type: VIP
 * 
 * Enter command: admit 2
 * Admitted 2 attendees.
 * 
 * Enter command: list_admitted
 * Admitted Attendees:
 * ID: 103, Name: Charlie, Type: VIP
 * ID: 102, Name: Bob, Type: Standard
 * 
 * Enter command: status
 * Event Status:
 * Capacity: 10
 * Available: 7
 * Waiting: 0
 * Admitted: 3
 * 
 * Enter command: register 102 David Standard
 * Error: Attendee with ID 102 already exists.
 * 
 * Enter command: admit -5
 * Error: Admission count must be a positive number.
 * 
 * Enter command: exit
 * Exiting Event Management System.
 * ```
 * 
 * Implement the necessary classes and logic to fulfill all requirements.
 *
 * EXPLANATION:
 * This solution implements a simple event management system as described in the problem, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Attendee Class:**
 *     *   A basic class `Attendee` is created to hold attendee data (`id`, `name`, `ticketType`).
 *     *   Fields are `private` and accessed via public getter methods, ensuring encapsulation.
 *     *   `toString()` is overridden for easy printing.
 *     *   `equals()` and `hashCode()` are overridden based on the `id` to correctly check for duplicate attendees in lists/queues.
 * 
 * 2.  **EventManager Class:**
 *     *   This is the main class containing the application logic.
 *     *   It holds the core data structures:
 *         *   `waitingQueue`: Declared as `Queue<Attendee>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior. Attendees register and are added here.
 *         *   `admittedList`: Declared as `List<Attendee>` and initialized with an `ArrayList`. `ArrayList` is suitable for storing admitted attendees where random access and iteration are common operations.
 *     *   `totalCapacity` and `availableCapacity` track the event's capacity.
 *     *   The constructor initializes these fields and validates the initial capacity.
 * 
 * 3.  **Required Component Usage:**
 *     *   `Queue`: Used for `waitingQueue`. `offer()` adds to the tail, `poll()` removes from the head (used indirectly during admission processing), and methods like `size()` and iteration are used.
 *     *   `ArrayList`: Used for `admittedList`. `add()` is used to add admitted attendees. Iteration is used for listing.
 *     *   `List`: `admittedList` is declared using the `List` interface type, promoting good practice by programming to interfaces. Temporary lists used in `admitAttendees` are also `List` or `ArrayList`.
 *     *   `Scanner`: An instance is created in `main` to read input lines from `System.in`.
 *     *   `Switch statement`: Used in the `main` loop to dispatch execution based on the user's command.
 *     *   `System.err`: Used exclusively for printing error messages (e.g., invalid commands, full capacity, duplicate IDs, invalid input).
 *     *   `System.out`: Used for all normal output (success messages, status, lists).
 *     *   `try-catch`:
 *         *   A general `try-catch(Exception e)` wraps the main `while` loop in `main` to catch any unexpected exceptions that might occur during command processing, preventing the program from crashing abruptly.
 *         *   Specific `try-catch(NumberFormatException e)` is used within the loop to handle cases where command arguments expected to be integers (like ID or count) cannot be parsed. `InputMismatchException` and `NoSuchElementException` catches are included for robustness, although `nextLine()` makes them less likely in this specific input pattern.
 * 
 * 4.  **Key Method Logic:**
 *     *   `registerAttendee`: Checks for duplicate IDs across *both* waiting and admitted lists using the `findAttendeeById` helper. Validates ticket type. If valid and unique, creates an `Attendee` object and adds it to the `waitingQueue` using `offer()`.
 *     *   `admitAttendees`: This method is the most complex due to the VIP priority requirement while using a standard `Queue`.
 *         *   It first validates the input count and checks for available capacity and waiting attendees.
 *         *   To implement priority without a `PriorityQueue` (which wasn't required), it copies all waiting attendees into a temporary `ArrayList` (`waitingListForProcessing`).
 *         *   The original `waitingQueue` is cleared.
 *         *   It then iterates through the temporary list twice: first to select VIPs up to the admission limit, and second to select Standard attendees from the remaining, again up to the limit.
 *         *   Attendees selected for admission are added to `admittedThisBatch`.
 *         *   Attendees *not* selected for admission are collected into `remainingWaiting`.
 *         *   Attendees in `admittedThisBatch` are moved to the `admittedList`, and `availableCapacity` is decremented.
 *         *   The attendees in `remainingWaiting` are added back to the `waitingQueue`, preserving their relative order from the original queue for standard attendees.
 *     *   `displayStatus`, `listAdmitted`, `listWaiting`: These methods simply access the state variables and iterate through the respective collections (`admittedList` and `waitingQueue`) to print the required information using `System.out`. `listWaiting` iterates over the `Queue` without removing elements.
 *     *   `findAttendeeById`: A helper method used by `registerAttendee` to check for existing attendees in both lists.
 * 
 * 5.  **Main Method:**
 *     *   Sets up the `Scanner` and `EventManager`.
 *     *   Enters a `while(running)` loop to continuously accept commands.
 *     *   Reads a full line using `scanner.nextLine()` to handle names with spaces (though the current implementation splits only by space, a more robust parser would be needed for multi-word names).
 *     *   Splits the line into command and arguments.
 *     *   Uses a `switch` statement to process the command string.
 *     *   Calls the appropriate `EventManager` methods.
 *     *   Includes nested `try-catch` within the loop for command-specific parsing errors (`NumberFormatException`) and wraps the entire loop in a broader `try-catch` for unexpected issues, printing errors to `System.err`.
 *     *   Ensures the `Scanner` is closed in a `finally` block.
 * 
 * This solution effectively uses all required components in a practical scenario, demonstrates input validation, error handling with `System.err` and `try-catch`, and follows good object-oriented design principles. The admission logic specifically challenges the student to implement priority when the underlying `Queue` implementation doesn't natively support it for arbitrary elements, requiring temporary list manipulation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Iterator;

/**
 * Represents an attendee for the event.
 */
class Attendee {
    private int id;
    private String name;
    private String ticketType; // "VIP" or "Standard"

    /**
     * Constructs an Attendee object.
     * @param id The unique ID of the attendee.
     * @param name The name of the attendee.
     * @param ticketType The ticket type ("VIP" or "Standard").
     */
    public Attendee(int id, String name, String ticketType) {
        this.id = id;
        this.name = name;
        this.ticketType = ticketType;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getTicketType() {
        return ticketType;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Type: " + ticketType;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id == attendee.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

/**
 * Manages event attendees, including waiting queue and admitted list.
 */
public class EventManager {

    private Queue<Attendee> waitingQueue;
    private List<Attendee> admittedList;
    private final int totalCapacity;
    private int availableCapacity;

    /**
     * Constructs an EventManager with a specified capacity.
     * @param capacity The total capacity of the event.
     */
    public EventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.totalCapacity = capacity;
        this.availableCapacity = capacity;
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.admittedList = new ArrayList<>();
    }

    /**
     * Registers a new attendee, adding them to the waiting queue if capacity allows
     * or if they need to wait. Checks for duplicate IDs.
     * @param id The attendee's ID.
     * @param name The attendee's name.
     * @param ticketType The attendee's ticket type ("VIP" or "Standard").
     * @return true if registration was successful, false otherwise.
     */
    public boolean registerAttendee(int id, String name, String ticketType) {
        if (findAttendeeById(id) != null) {
            System.err.println("Error: Attendee with ID " + id + " already exists.");
            return false;
        }

        if (!ticketType.equalsIgnoreCase("VIP") && !ticketType.equalsIgnoreCase("Standard")) {
             System.err.println("Error: Invalid ticket type '" + ticketType + "'. Must be 'VIP' or 'Standard'.");
             return false;
        }

        Attendee newAttendee = new Attendee(id, name, ticketType);
        waitingQueue.offer(newAttendee); // Add to the end of the queue
        System.out.println("Attendee " + id + " (" + name + ") registered successfully. Waiting in queue.");
        return true;
    }

    /**
     * Attempts to admit a specified number of attendees from the waiting queue
     * into the event, prioritizing VIPs.
     * @param count The maximum number of attendees to admit in this batch.
     */
    public void admitAttendees(int count) {
        if (count <= 0) {
            System.err.println("Error: Admission count must be a positive number.");
            return;
        }

        if (availableCapacity == 0) {
            System.err.println("Error: Event is currently at full capacity.");
            return;
        }

        if (waitingQueue.isEmpty()) {
            System.out.println("No attendees waiting in the queue.");
            return;
        }

        int numToAdmitThisBatch = Math.min(count, availableCapacity);
        int admittedCount = 0;

        // Temporary list to hold attendees waiting for processing this batch
        List<Attendee> waitingListForProcessing = new ArrayList<>(waitingQueue);
        waitingQueue.clear(); // Clear the queue temporarily

        List<Attendee> admittedThisBatch = new ArrayList<>();
        List<Attendee> remainingWaiting = new ArrayList<>();

        // First Pass: Admit VIPs
        for (Attendee attendee : waitingListForProcessing) {
            if (admittedThisBatch.size() < numToAdmitThisBatch && attendee.getTicketType().equalsIgnoreCase("VIP")) {
                admittedThisBatch.add(attendee);
            } else {
                remainingWaiting.add(attendee);
            }
        }

        // Second Pass: Admit Standard attendees if more capacity/count available
        if (admittedThisBatch.size() < numToAdmitThisBatch) {
            List<Attendee> stillRemaining = new ArrayList<>(remainingWaiting);
            remainingWaiting.clear(); // Clear remainingWaiting to rebuild it

            for (Attendee attendee : stillRemaining) {
                 if (admittedThisBatch.size() < numToAdmitThisBatch && attendee.getTicketType().equalsIgnoreCase("Standard")) {
                    admittedThisBatch.add(attendee);
                } else {
                    remainingWaiting.add(attendee);
                }
            }
        }

        // Process admitted attendees
        for (Attendee attendee : admittedThisBatch) {
            admittedList.add(attendee);
            availableCapacity--;
            admittedCount++;
        }

        // Add remaining back to the queue
        waitingQueue.addAll(remainingWaiting);

        System.out.println("Admitted " + admittedCount + " attendee(s).");
    }

    /**
     * Displays the current status of the event.
     */
    public void displayStatus() {
        System.out.println("Event Status:");
        System.out.println("Capacity: " + totalCapacity);
        System.out.println("Available: " + availableCapacity);
        System.out.println("Waiting: " + waitingQueue.size());
        System.out.println("Admitted: " + admittedList.size());
    }

    /**
     * Lists all attendees who have been admitted to the event.
     */
    public void listAdmitted() {
        System.out.println("Admitted Attendees:");
        if (admittedList.isEmpty()) {
            System.out.println("None.");
        } else {
            for (Attendee attendee : admittedList) {
                System.out.println(attendee);
            }
        }
    }

    /**
     * Lists all attendees currently waiting in the queue.
     */
    public void listWaiting() {
        System.out.println("Waiting Queue:");
        if (waitingQueue.isEmpty()) {
            System.out.println("None.");
        } else {
             // Iterate without removing elements
            for (Attendee attendee : waitingQueue) {
                System.out.println(attendee);
            }
        }
    }

    /**
     * Helper method to find an attendee by ID in either the waiting queue or admitted list.
     * @param id The ID to search for.
     * @return The Attendee object if found, otherwise null.
     */
    private Attendee findAttendeeById(int id) {
        // Check admitted list first (more likely to need lookup here)
        for (Attendee attendee : admittedList) {
            if (attendee.getId() == id) {
                return attendee;
            }
        }
        // Check waiting queue
        for (Attendee attendee : waitingQueue) {
             if (attendee.getId() == id) {
                return attendee;
            }
        }
        return null;
    }


    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager(10); // Fixed capacity of 10
        boolean running = true;

        System.out.println("Event Management System Started.");
        System.out.println("Enter commands (register, admit, status, list_admitted, list_waiting, exit):");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.print("Enter command: ");
                String line = scanner.nextLine();
                String[] parts = line.trim().split("\\s+");
                String command = parts[0].toLowerCase();

                try {
                    switch (command) {
                        case "register":
                            if (parts.length == 4) {
                                int id = Integer.parseInt(parts[1]);
                                String name = parts[2];
                                String ticketType = parts[3];
                                eventManager.registerAttendee(id, name, ticketType);
                            } else {
                                System.err.println("Error: Invalid 'register' command format. Use: register <id> <name> <ticketType>");
                            }
                            break;

                        case "admit":
                            if (parts.length == 2) {
                                int count = Integer.parseInt(parts[1]);
                                eventManager.admitAttendees(count);
                            } else {
                                System.err.println("Error: Invalid 'admit' command format. Use: admit <count>");
                            }
                            break;

                        case "status":
                            if (parts.length == 1) {
                                eventManager.displayStatus();
                            } else {
                                 System.err.println("Error: Invalid 'status' command format. Use: status");
                            }
                            break;

                        case "list_admitted":
                             if (parts.length == 1) {
                                eventManager.listAdmitted();
                            } else {
                                 System.err.println("Error: Invalid 'list_admitted' command format. Use: list_admitted");
                            }
                            break;

                        case "list_waiting":
                             if (parts.length == 1) {
                                eventManager.listWaiting();
                            } else {
                                 System.err.println("Error: Invalid 'list_waiting' command format. Use: list_waiting");
                            }
                            break;

                        case "exit":
                            if (parts.length == 1) {
                                running = false;
                                System.out.println("Exiting Event Management System.");
                            } else {
                                System.err.println("Error: Invalid 'exit' command format. Use: exit");
                            }
                            break;

                        default:
                            System.err.println("Error: Unknown command '" + command + "'.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid number format for ID or count.");
                } catch (InputMismatchException e) {
                     System.err.println("Error: Invalid input type."); // Less likely with nextLine, but good practice
                } catch (NoSuchElementException e) {
                     System.err.println("Error: Input not available."); // Should not happen with console
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during command processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optional: e.printStackTrace(); // For debugging
                }
            }
        } catch (Exception e) {
             // Class-wide catch for exceptions outside the command processing block
             System.err.println("A critical error occurred: " + e.getMessage());
             e.printStackTrace();
        } finally {
             // Ensure scanner is closed
             if (scanner != null) {
                 scanner.close();
             }
        }
    }
}
