/*
 * Exam Question #960
 * Generated on: 2025-05-12 17:05:22
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified Task Management System for a small team. The system needs to handle incoming tasks, process them in the order they are received, and keep a log of completed tasks. Users should be able to add new tasks, process the next pending task, view the list of pending tasks, and view the history of completed tasks via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. Each `Task` should have:
 *     *   A unique integer `taskId`.
 *     *   A `String` `description`.
 *     *   An integer `priority`.
 *     *   Appropriate constructors and getter methods.
 *     *   A `toString()` method for easy display.
 * 2.  **Task Management Logic:** Create a class (e.g., `TaskManager`) that encapsulates the task management logic. This class must use:
 *     *   A `java.util.Queue` to store tasks that are waiting to be processed (pending tasks). Tasks should be processed in FIFO (First-In, First-Out) order.
 *     *   A `java.util.ArrayList` to store tasks that have been completed.
 *     *   Reference the completed tasks list using the `java.util.List` interface type.
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of a separate class (e.g., `TaskManagementApp`). This interface should:
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Use `System.out` for all normal output (menu, task details, success messages).
 *     *   Use `System.err` for all error messages (e.g., invalid input, attempting to process when no tasks are pending).
 * 4.  **Error Handling:**
 *     *   Implement input validation for adding tasks (e.g., ensure priority is non-negative).
 *     *   Handle potential exceptions during user input (e.g., non-integer input for choices or priority) using `try-catch`.
 *     *   Handle the case where the user tries to process a task when the pending queue is empty. Use a specific error message printed to `System.err`.
 *     *   Implement class-wide exception handling in the main loop of the `TaskManagementApp` to catch any unexpected runtime errors.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Enter task priority (integer): 10
 * Task added: Task{id=1, description='Design database schema', priority=10}
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Implement API endpoints
 * Enter task priority (integer): 20
 * Task added: Task{id=2, description='Implement API endpoints', priority=20}
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=1, description='Design database schema', priority=10}
 * Task{id=2, description='Implement API endpoints', priority=20}
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Design database schema', priority=10}
 * Task completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=2, description='Implement API endpoints', priority=20}
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=1, description='Design database schema', priority=10}
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=2, description='Implement API endpoints', priority=20}
 * Task completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Error: No tasks are currently pending.
 * --- Task Management System ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * --- Task Management System ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * --- Task Management System ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Note:** You should include all necessary classes and the `main` method in a single code block for the solution.
 *
 * EXPLANATION:
 * The provided solution implements a basic Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a task. It has `private` fields (`taskId`, `description`, `priority`) and `public` getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`TaskManager` Class:** This is the core logic class.
 *     *   It uses a `java.util.Queue<Task>` named `pendingTasks` to store tasks waiting for processing. `LinkedList` is used as a concrete implementation of the `Queue` interface, providing FIFO behavior for `offer()` (add) and `poll()` (retrieve and remove) operations.
 *     *   It uses a `java.util.ArrayList<Task>` named `completedTasks` to store tasks after they are processed. This list is referenced using the `java.util.List` interface type (`List<Task> completedTasks = new ArrayList<>();`), demonstrating the use of interfaces and polymorphism.
 *     *   `addTask()`: Creates a new `Task` object with an auto-incrementing ID and adds it to the `pendingTasks` queue using `offer()`. Basic validation for description and priority is included, throwing `IllegalArgumentException` if violated.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the task at the head of the `pendingTasks` queue. If the queue is empty, `poll()` returns `null`. This condition is checked, and a custom `EmptyQueueException` is thrown to signal the error. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue to display its contents without removing elements.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list to display its contents.
 *     *   `EmptyQueueException`: A simple nested static class extending `Exception` is defined within `TaskManager` to provide a specific exception type for the empty queue condition during processing.
 * 
 * 3.  **`TaskManagementApp` Class:** This class contains the `main` method and handles the user interface.
 *     *   `Scanner`: Used to read user input from `System.in`.
 *     *   Main Loop (`while(running)`): Continuously prompts the user for input until the 'Exit' option is chosen.
 *     *   **Class-Wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception mainException)` block. This serves as a safety net to catch any unhandled exceptions that might occur during the execution of the loop, preventing the program from crashing abruptly and printing an error message to `System.err`. A `finally` block ensures the `Scanner` is closed when the loop terminates.
 *     *   Inner `try-catch`: Inside the main loop, a smaller `try-catch` block is used specifically for handling potential exceptions during the input reading (`scanner.nextInt()`) and command processing within the `switch` statement. This allows for more granular error handling, such as catching `InputMismatchException` when the user enters non-integer input for the menu choice.
 *     *   `switch` Statement: Directs the program flow based on the user's integer choice.
 *     *   Command Handling: Each `case` in the `switch` calls the appropriate method on the `TaskManager` instance.
 *         *   Case 1 (`Add New Task`): Prompts for description and priority. Includes a nested `try-catch` to handle `IllegalArgumentException` thrown by `taskManager.addTask()`. Uses `scanner.nextLine()` after `scanner.nextInt()` to consume the leftover newline character.
 *         *   Case 2 (`Process Next Task`): Calls `taskManager.processNextTask()`. It specifically catches the `TaskManager.EmptyQueueException` and prints an error message to `System.err`.
 *         *   Case 3 & 4 (`View Tasks`): Call the respective `TaskManager` methods.
 *         *   Case 5 (`Exit`): Sets the `running` flag to `false` to terminate the loop.
 *         *   `default`: Handles invalid integer choices, printing an error to `System.err`.
 *     *   `System.out` and `System.err`: Used correctly for normal output (menu, task details) and error messages (input errors, processing errors).
 *     *   `scanner.close()`: Placed in the `finally` block to ensure the `Scanner` resource is released.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design (encapsulation) and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID, description, and priority.
 */
class Task {
    private int taskId;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The task priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "', priority=" + priority + "}";
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending and completed task collections.
     */
    public TaskManager() {
        // Use LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList for completed tasks, referenced by the List interface
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the new task.
     * @param priority The priority of the new task.
     * @throws IllegalArgumentException if description is null/empty or priority is negative.
     */
    public void addTask(String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 0) {
            throw new IllegalArgumentException("Task priority cannot be negative.");
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues (returns false if failed)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue and moves it to the completed list.
     * @throws EmptyQueueException if there are no tasks in the pending queue.
     */
    public void processNextTask() throws EmptyQueueException {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess == null) {
            // Custom exception or simply indicate the condition
             throw new EmptyQueueException("No tasks are currently pending.");
            // Or just print error here: System.err.println("Error: No tasks are currently pending."); return;
        } else {
            System.out.println("Processing task: " + taskToProcess);
            completedTasks.add(taskToProcess); // Add to the list of completed tasks
            System.out.println("Task completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            System.out.println("Pending Tasks:");
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
            // Alternative using iterator:
            // Iterator<Task> it = pendingTasks.iterator();
            // while(it.hasNext()) { System.out.println(it.next()); }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            System.out.println("Completed Tasks:");
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Simple custom exception for indicating an empty queue condition.
     */
    static class EmptyQueueException extends Exception {
        public EmptyQueueException(String message) {
            super(message);
        }
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and orchestrates TaskManager operations.
 */
public class TaskManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    int choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Handle user choice using a switch statement
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter task priority (integer): ");
                            int priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            try {
                                taskManager.addTask(description, priority);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                            break;

                        case 2: // Process Next Task
                            try {
                                taskManager.processNextTask();
                            } catch (TaskManager.EmptyQueueException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case 3: // View Pending Tasks
                            taskManager.viewPendingTasks();
                            break;

                        case 4: // View Completed Tasks
                            taskManager.viewCompletedTasks();
                            break;

                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting Task Management System.");
                            break;

                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions within the switch block
                    System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging unexpected errors
                }
                System.out.println(); // Add a newline for better readability between cycles

            }
        } catch (Exception mainException) {
            // This outer catch block handles exceptions that might escape the inner try-catch,
            // providing a final safety net before the program terminates.
            System.err.println("A critical error occurred in the application loop: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner is closed regardless of how the program exits the loop
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
