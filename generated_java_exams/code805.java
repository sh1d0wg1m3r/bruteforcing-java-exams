/*
 * Exam Question #805
 * Generated on: 2025-05-12 16:43:08
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Manufacturing Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified system to manage tasks on a manufacturing assembly line. Tasks arrive and are placed in a queue awaiting processing. A processor can take the next available task from the queue, complete it, and move it to a list of finished tasks. The system should allow a user to interact with this process via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with appropriate fields (e.g., ID, description, type, status) and methods (getters, a method to update status, `toString`). Use meaningful data types.
 * 2.  **Task Management Logic:** Create a `TaskProcessor` class that manages the collection of tasks.
 *     *   It must use a `java.util.Queue` to hold tasks that are pending processing.
 *     *   It must use a `java.util.ArrayList` to hold tasks that have been completed.
 *     *   Methods should include: `addTask(type, description)`, `processNextTask()`, `getPendingTasks()`, `getCompletedTasks()`.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in the `main` method or a separate class with a `main` method. The user should be presented with a menu and prompted for input.
 * 4.  **Control Flow:** Use a `switch` statement to handle different user commands (e.g., add task, process task, view pending, view completed, exit).
 * 5.  **Output:**
 *     *   Use `System.out` for normal program output (menus, task details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid input, attempting to process when the queue is empty).
 * 6.  **Error Handling:** Implement robust error handling.
 *     *   Use `try-catch` blocks for class-wide exception handling, particularly around the main command processing loop, to gracefully handle unexpected issues.
 *     *   Implement input validation (e.g., check if input for type/description is empty, handle non-integer input if parsing numbers).
 *     *   Handle specific operational errors (e.g., processing an empty queue) with clear messages to `System.err`.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc-style documentation where necessary.
 *     *   Ensure clean code structure and formatting.
 *     *   Use the `java.util.List` interface type where appropriate (e.g., as return types for methods returning lists).
 * 
 * **Program Flow:**
 * 
 * 1.  Start the system.
 * 2.  Display a menu of options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 3.  Prompt the user to enter a choice.
 * 4.  Use a `switch` statement to execute the chosen action.
 * 5.  For "Add New Task": Prompt for task type and description, create a `Task` object, add it to the pending queue.
 * 6.  For "Process Next Task": Take the task from the front of the pending queue, update its status to "COMPLETED", and move it to the completed list. If the queue is empty, print an error to `System.err`.
 * 7.  For "View Pending Tasks": Display all tasks currently in the pending queue.
 * 8.  For "View Completed Tasks": Display all tasks in the completed list.
 * 9.  For "Exit": Terminate the program.
 * 10. Handle invalid menu choices with an error message to `System.err`.
 * 11. The main interaction loop should continue until the user chooses to exit.
 * 12. Ensure the `Scanner` is closed properly upon exit.
 * 
 * **Expected Output Structure (Example):**
 * 
 * ```
 * Manufacturing Task Management System
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter choice: 1
 * Enter Task Type (e.g., Production, Maintenance): Production
 * Enter Task Description: Assemble Unit A
 * 
 * Task added successfully.
 * 
 * Enter choice: 1
 * Enter Task Type (e.g., Production, Maintenance): QualityControl
 * Enter Task Description: Inspect Unit B
 * 
 * Task added successfully.
 * 
 * Enter choice: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Type: Production, Description: Assemble Unit A, Status: PENDING
 * Task ID: 2, Type: QualityControl, Description: Inspect Unit B, Status: PENDING
 * ---------------------
 * 
 * Enter choice: 2
 * 
 * Processing task: Task ID: 1, Type: Production, Description: Assemble Unit A, Status: PENDING
 * Task ID 1 marked as COMPLETED.
 * 
 * Enter choice: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 2, Type: QualityControl, Description: Inspect Unit B, Status: PENDING
 * ---------------------
 * 
 * Enter choice: 4
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Type: Production, Description: Assemble Unit A, Status: COMPLETED
 * ---------------------
 * 
 * Enter choice: 2
 * 
 * Processing task: Task ID: 2, Type: QualityControl, Description: Inspect Unit B, Status: PENDING
 * Task ID 2 marked as COMPLETED.
 * 
 * Enter choice: 2
 * System.err: Error: No tasks in the pending queue to process.
 * 
 * Enter choice: 4
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Type: Production, Description: Assemble Unit A, Status: COMPLETED
 * Task ID: 2, Type: QualityControl, Description: Inspect Unit B, Status: COMPLETED
 * ---------------------
 * 
 * Enter choice: 6
 * System.err: Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Enter choice: 5
 * 
 * Exiting system.
 * ```
 * 
 * Your code should compile and run, demonstrating the correct usage of all required components and handling the described scenarios.
 *
 * EXPLANATION:
 * This solution implements the Manufacturing Task Management System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `type`, `description`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Getters provide controlled access to data.
 *     *   `markCompleted()` is a specific method to change the status, enforcing valid state transitions.
 *     *   The constructor includes basic input validation for `type` and `description`, throwing `IllegalArgumentException` if they are null or empty.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the core logic of the system.
 *     *   `private Queue<Task> pendingTasks;`: A `LinkedList` is used because it implements the `Queue` interface and is efficient for adding to the end (`offer`) and removing from the beginning (`poll`).
 *     *   `private List<Task> completedTasks;`: An `ArrayList` is used for storing completed tasks, as random access or iterating through the list is common, and order of completion is maintained.
 *     *   `private int nextTaskId;`: Manages unique IDs for tasks.
 *     *   `addTask()`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. Includes a `try-catch` block around the `Task` constructor call to handle potential `IllegalArgumentException` from invalid task details, printing an error to `System.err`.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the task at the head of the queue. If `poll()` returns `null` (meaning the queue is empty), it indicates there's nothing to process. Otherwise, the task's status is updated, and it's added to the `completedTasks` list.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: These methods return `List` interfaces, adhering to the requirement of using the `List` interface. They return `ArrayList` copies of the internal collections to prevent external code from modifying the queue or completed list directly, promoting data integrity.
 * 
 * 3.  **`ManufacturingSystem` Class (Main Entry Point):**
 *     *   Contains the `main` method and handles the user interaction loop.
 *     *   `private static TaskProcessor processor;`: An instance of the task management logic.
 *     *   `private static Scanner scanner;`: Used for reading user input from the console.
 *     *   `private static boolean running;`: A flag to control the main loop.
 *     *   **Class-Wide Exception Handling:** The core `while(running)` loop is wrapped in a `try-catch(Exception e)`. This provides a top-level safety net for any unhandled exceptions that might occur anywhere within the loop's execution (e.g., errors during input processing, unexpected issues within the `TaskProcessor`). Error details are printed to `System.err`, including a stack trace for debugging.
 *     *   `finally { scanner.close(); }`: Ensures the `Scanner` resource is always closed when the program exits, whether normally or due to an exception caught by the main `try-catch`.
 *     *   `printMenu()`: Displays the options to the user using `System.out`.
 *     *   `getUserChoice()`: Reads the user's input line. It uses `Integer.parseInt()` within a `try-catch` block to handle `NumberFormatException` if the user enters non-integer input. Invalid input results in an error message to `System.err` and returns -1.
 *     *   `processChoice(int choice)`: Uses a `switch` statement on the integer choice returned by `getUserChoice()` to direct execution to the appropriate action method (`addTaskAction`, `processTaskAction`, etc.). The `default` case handles invalid integer inputs, printing an error to `System.err`.
 *     *   Action Methods (`addTaskAction`, `processTaskAction`, etc.): These methods encapsulate the logic for each menu option.
 *         *   `addTaskAction`: Prompts for type and description using `scanner.nextLine()`. It wraps the call to `processor.addTask()` in a `try-catch` to specifically handle `IllegalArgumentException` originating from the `Task` constructor or `addTask` validation.
 *         *   `processTaskAction`: Calls `processor.processNextTask()`. It checks if the returned task is `null` to determine if the queue was empty, printing an appropriate message to `System.out` or `System.err`.
 *         *   `viewPendingTasksAction` and `viewCompletedTasksAction`: Retrieve the lists using `processor.getPendingTasks()` and `processor.getCompletedTasks()` (which return `List`). They iterate through the lists and print task details using `System.out`. They also check if the lists are empty.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks within a practical, object-oriented structure, demonstrating advanced Java programming concepts like encapsulation, input validation, and layered error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the manufacturing system.
 */
class Task {
    private int id;
    private String type;
    private String description;
    private String status;

    private static final String STATUS_PENDING = "PENDING";
    private static final String STATUS_COMPLETED = "COMPLETED";

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID of the task.
     * @param type The type of the task (e.g., Production, Maintenance).
     * @param description A description of the task.
     */
    public Task(int id, String type, String description) {
        if (type == null || type.trim().isEmpty() || description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Task type and description cannot be null or empty.");
        }
        this.id = id;
        this.type = type.trim();
        this.description = description.trim();
        this.status = STATUS_PENDING; // Tasks start as pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = STATUS_COMPLETED;
    }

    @Override
    public String toString() {
        return "Task ID: " + id + ", Type: " + type + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessor {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        // Use LinkedList as it implements Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList for completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param type The type of the task.
     * @param description The description of the task.
     * @return The added Task object.
     * @throws IllegalArgumentException if type or description are invalid.
     */
    public Task addTask(String type, String description) {
        Task newTask = new Task(nextTaskId++, type, description);
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        return newTask;
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list after marking it completed.
     *
     * @return The processed Task object, or null if the queue is empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head
        if (taskToProcess != null) {
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess);
        }
        return taskToProcess;
    }

    /**
     * Returns an immutable list of pending tasks.
     *
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the queue
        return new ArrayList<>(pendingTasks); // Convert queue elements to a list
    }

    /**
     * Returns an immutable list of completed tasks.
     *
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy to prevent external modification of the list
        return new ArrayList<>(completedTasks);
    }
}

/**
 * Main class to run the Manufacturing Task Management System.
 */
public class ManufacturingSystem {

    private static TaskProcessor processor = new TaskProcessor();
    private static Scanner scanner = new Scanner(System.in);
    private static boolean running = true;

    public static void main(String[] args) {
        System.out.println("Manufacturing Task Management System");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();
                processChoice(choice);
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to err
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated.");
        }
    }

    /**
     * Prints the main menu options.
     */
    private static void printMenu() {
        System.out.println("\nMenu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Gets the user's menu choice from input.
     * Handles non-integer input gracefully.
     *
     * @return The integer choice, or -1 if input is invalid.
     */
    private static int getUserChoice() {
        try {
            // Use hasNextInt to check before reading
            if (scanner.hasNextLine()) {
                 String line = scanner.nextLine();
                 return Integer.parseInt(line);
            }
            return -1; // Indicate error if no line is available (unlikely in interactive console)
        } catch (NumberFormatException e) {
            // Handle non-integer input
            System.err.println("Error: Invalid input. Please enter a number.");
            return -1; // Indicate invalid choice
        }
    }

    /**
     * Processes the user's menu choice using a switch statement.
     *
     * @param choice The integer choice entered by the user.
     */
    private static void processChoice(int choice) {
        switch (choice) {
            case 1:
                addTaskAction();
                break;
            case 2:
                processTaskAction();
                break;
            case 3:
                viewPendingTasksAction();
                break;
            case 4:
                viewCompletedTasksAction();
                break;
            case 5:
                running = false; // Set flag to exit loop
                System.out.println("Exiting system.");
                break;
            default:
                // Handle invalid numbers or -1 from getUserChoice
                if (choice != -1) { // Avoid double error message if getUserChoice already printed one
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                break;
        }
    }

    /**
     * Handles the 'Add New Task' action.
     * Prompts user for task details and adds the task.
     */
    private static void addTaskAction() {
        System.out.print("Enter Task Type (e.g., Production, Maintenance): ");
        String type = scanner.nextLine();

        System.out.print("Enter Task Description: ");
        String description = scanner.nextLine();

        try {
            Task newTask = processor.addTask(type, description);
            System.out.println("\nTask added successfully.");
            System.out.println(newTask); // Print details of the added task
        } catch (IllegalArgumentException e) {
            // Handle validation errors from Task constructor or addTask method
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Handles the 'Process Next Task' action.
     * Processes the task at the front of the queue.
     */
    private static void processTaskAction() {
        Task processedTask = processor.processNextTask();
        if (processedTask != null) {
            System.out.println("\nProcessing task: " + processedTask); // Shows task *before* status change
            System.out.println("Task ID " + processedTask.getId() + " marked as COMPLETED.");
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
        }
    }

    /**
     * Handles the 'View Pending Tasks' action.
     * Displays all tasks currently in the pending queue.
     */
    private static void viewPendingTasksAction() {
        List<Task> pending = processor.getPendingTasks();
        System.out.println("\n--- Pending Tasks ---");
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            for (Task task : pending) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Handles the 'View Completed Tasks' action.
     * Displays all tasks currently in the completed list.
     */
    private static void viewCompletedTasksAction() {
        List<Task> completed = processor.getCompletedTasks();
        System.out.println("\n--- Completed Tasks ---");
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completed) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }
}
