/*
 * Exam Question #1098
 * Generated on: 2025-05-12 17:24:36
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Order Fulfillment System Simulation
 * 
 * **Objective:** Design and implement a command-line application in Java that simulates a simple order fulfillment process. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** Imagine a small workshop that receives orders and processes them sequentially. Incoming orders are placed in a queue. When a worker is available, they take the next order from the queue, fulfill it, and add the completed items to a list of finished goods.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Implementation:**
 *     *   Implement a Java program that simulates this order fulfillment system.
 *     *   Use a `java.util.Queue` to manage incoming orders. Orders should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically a `java.util.ArrayList`) to store the names of completed items.
 *     *   Use `java.util.Scanner` to read user commands from the standard input.
 * 
 * 2.  **Commands:** Implement the following commands, processed via a `switch` statement:
 *     *   `ADD_ORDER <item_name> <quantity>`: Adds a new order for `<quantity>` units of `<item_name>` to the end of the order queue. `<quantity>` must be a positive integer.
 *     *   `PROCESS_NEXT`: Takes the next order from the front of the queue. For each unit specified in the order's quantity, add the item's name to the list of completed items.
 *     *   `VIEW_QUEUE`: Displays all current orders waiting in the queue, showing their item name and quantity.
 *     *   `VIEW_COMPLETED`: Displays the names of all items currently in the completed list.
 *     *   `EXIT`: Terminates the program.
 * 
 * 3.  **Input/Output:**
 *     *   Use `System.out` for displaying prompts, command success messages, and the contents of the queue and completed list.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid command, incorrect number of arguments, invalid quantity, attempting to process an empty queue).
 * 
 * 4.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Handle potential issues with user input, such as non-integer quantity for `ADD_ORDER` or incorrect command format.
 *     *   Handle the edge case of attempting to `PROCESS_NEXT` when the order queue is empty.
 *     *   Include a **class-wide** `try-catch` block wrapping the main execution logic (e.g., around the method that contains the command loop) to catch any unexpected runtime errors.
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate classes (e.g., an `Order` class) with private fields and public methods (getters) for proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments explaining key parts of the code.
 *     *   Validate user input where necessary (e.g., quantity must be positive).
 *     *   Handle edge cases gracefully (e.g., displaying appropriate messages when lists/queues are empty).
 *     *   Ensure a clean code structure.
 * 
 * **Expected Behavior:**
 * 
 * *   The program should start, display a welcome message and available commands, and then wait for user input.
 * *   Commands should be case-insensitive (though parsing can convert to uppercase for the `switch`).
 * *   After executing a command, the program should prompt for the next command, unless `EXIT` is entered.
 * *   Error messages should clearly indicate the problem and be printed to `System.err`.
 * *   The program should not crash due to invalid user input or empty collections.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Order Fulfillment System
 * Commands: ADD_ORDER <item_name> <quantity>, PROCESS_NEXT, VIEW_QUEUE, VIEW_COMPLETED, EXIT
 * > ADD_ORDER Widget 5
 * Added order: 5 x Widget
 * > ADD_ORDER Gadget 2
 * Added order: 2 x Gadget
 * > VIEW_QUEUE
 * --- Current Order Queue ---
 * 1. 5 x Widget
 * 2. 2 x Gadget
 * ---------------------------
 * > PROCESS_NEXT
 * Processing order: 5 x Widget
 * Completed 5 units of 'Widget'. Added to completed list.
 * > PROCESS_NEXT
 * Processing order: 2 x Gadget
 * Completed 2 units of 'Gadget'. Added to completed list.
 * > VIEW_COMPLETED
 * --- Completed Items ---
 * 1. Widget
 * 2. Widget
 * 3. Widget
 * 4. Widget
 * 5. Widget
 * 6. Gadget
 * 7. Gadget
 * -----------------------
 * > PROCESS_NEXT
 * Error: Order queue is empty. Nothing to process.
 * > ADD_ORDER Invalid -1
 * Error adding order: Quantity must be positive.
 * > VIEW_QUEUE
 * --- Current Order Queue ---
 * Queue is empty.
 * ---------------------------
 * > EXIT
 * Exiting system. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements the Order Fulfillment System simulation as described in the exam question, fulfilling all requirements.
 * 
 * 1.  **Core Components:**
 *     *   `java.util.Queue`: The `orderQueue` is declared as a `Queue<Order>` and initialized with `java.util.LinkedList`. `LinkedList` is a common implementation of `Queue` suitable for this purpose as it efficiently handles additions to the end (`offer`) and removals from the beginning (`poll`). This fulfills the FIFO requirement.
 *     *   `java.util.List` / `java.util.ArrayList`: The `completedItems` is declared as a `List<String>` and initialized with `java.util.ArrayList`. `ArrayList` provides dynamic resizing and allows storing the completed item names.
 *     *   `java.util.Scanner`: A `Scanner` object is used in the `run` method to read user input line by line from `System.in`.
 * 
 * 2.  **Program Structure:**
 *     *   A separate `Order` class encapsulates the data for an order (`itemName` and `quantity`). It includes a constructor with basic validation and getter methods, demonstrating encapsulation.
 *     *   The main logic resides in the `OrderFulfillmentSystem` class.
 *     *   The `main` method creates an instance of `OrderFulfillmentSystem` and calls its `run` method. This setup is common for command-line applications.
 *     *   The `run` method contains the main command processing loop.
 *     *   Private helper methods (`addOrder`, `processNextOrder`, `viewOrderQueue`, `viewCompletedItems`) are used to break down the functionality, promoting modularity and encapsulation.
 * 
 * 3.  **Command Processing:**
 *     *   The `run` method reads a full line of input using `scanner.nextLine()`.
 *     *   The input line is split into parts (command and arguments) using `String.split()`.
 *     *   The first part is converted to uppercase and used in a `switch` statement to determine the desired action. This effectively routes execution based on the user command.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   **Input Parsing:** When adding an order, `Integer.parseInt()` is used to convert the quantity string to an integer. A `try-catch (NumberFormatException e)` block is used specifically to catch errors if the user enters non-integer text for the quantity, printing an informative error message to `System.err`.
 *     *   **Argument Count:** Before processing commands like `ADD_ORDER`, the code checks if the correct number of arguments was provided using `parts.length`. If not, an error message is printed to `System.err`.
 *     *   **`Order` Constructor Validation:** The `Order` class constructor validates that the item name is not empty and the quantity is positive. If validation fails, it throws an `IllegalArgumentException`. This exception is caught in the `addOrder` method (and could also be caught by the `try-catch` in `run`), and an error message is printed to `System.err`.
 *     *   **Empty Queue:** The `processNextOrder` method uses `orderQueue.poll()`. `poll()` is safer than `remove()` because it returns `null` if the queue is empty, rather than throwing an exception. The code checks for this `null` return value and prints an error to `System.err` if the queue is empty.
 *     *   **Class-wide Exception Handling:** The `main` method includes a `try-catch (Exception e)` block around the call to `system.run()`. This serves as a fail-safe to catch any unhandled exceptions that might propagate up, preventing the program from crashing unexpectedly and printing the stack trace to `System.err` for debugging. A more specific `try-catch` is also placed inside the `run` loop around command processing to handle errors specific to a command execution without necessarily terminating the entire application loop.
 * 
 * 5.  **Output:**
 *     *   `System.out.println` is used for user prompts, confirmations (e.g., "Added order: ..."), and displaying the contents of the queue and completed lists.
 *     *   `System.err.println` is used exclusively for error messages, adhering to the standard practice of separating normal output from error output.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is achieved through the `Order` class and private fields/helper methods in `OrderFulfillmentSystem`.
 *     *   Variable and method names are descriptive (`orderQueue`, `processNextOrder`, `viewCompletedItems`, `itemName`, `quantity`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation is performed (quantity format, positive value, argument count).
 *     *   Edge cases like empty queue or empty completed list are explicitly checked and handled with informative messages.
 *     *   The code is structured logically with clear separation of concerns.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, cohesive application, including robust error handling and adherence to best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although parsing String and catching NFE is safer

// Represents an order placed in the system
class Order {
    private String itemName;
    private int quantity;

    /**
     * Constructs an Order object.
     * @param itemName The name of the item.
     * @param quantity The quantity of the item.
     * @throws IllegalArgumentException if item name is empty or quantity is not positive.
     */
    public Order(String itemName, int quantity) {
        // Basic validation in constructor
        if (itemName == null || itemName.trim().isEmpty()) {
            throw new IllegalArgumentException("Item name cannot be empty.");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.itemName = itemName.trim();
        this.quantity = quantity;
    }

    /**
     * Gets the item name for this order.
     * @return The item name.
     */
    public String getItemName() {
        return itemName;
    }

    /**
     * Gets the quantity for this order.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Returns a string representation of the order.
     * @return Formatted string like "quantity x itemName".
     */
    @Override
    public String toString() {
        return quantity + " x " + itemName;
    }
}

// Main class for the Order Fulfillment System
public class OrderFulfillmentSystem {

    // Use LinkedList as a Queue implementation for orders (FIFO)
    private Queue<Order> orderQueue = new LinkedList<>();
    // Use ArrayList as a List implementation for completed items
    private List<String> completedItems = new ArrayList<>();
    private Scanner scanner = new Scanner(System.in);

    /**
     * Main method to start the application.
     * Includes a class-wide try-catch block for unexpected errors.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Class-wide exception handling wrapping the main execution flow
        try {
            OrderFulfillmentSystem system = new OrderFulfillmentSystem();
            system.run();
        } catch (Exception e) {
            // Catch any unexpected exceptions that weren't handled internally
            System.err.println("An unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        }
    }

    /**
     * Runs the main command processing loop of the system.
     * Handles user input, command parsing, and execution.
     */
    public void run() {
        System.out.println("Order Fulfillment System");
        System.out.println("Commands: ADD_ORDER <item_name> <quantity>, PROCESS_NEXT, VIEW_QUEUE, VIEW_COMPLETED, EXIT");

        boolean running = true;
        // Main command processing loop
        while (running) {
            System.out.print("> ");
            String inputLine = scanner.nextLine().trim();

            // Use try-catch within the loop for handling errors during command processing
            try {
                if (inputLine.isEmpty()) {
                    continue; // Ignore empty lines
                }

                // Split input into command and arguments (max 3 parts: command, item_name, quantity)
                String[] parts = inputLine.split("\\s+", 3);
                String command = parts[0].toUpperCase(); // Convert command to uppercase for switch

                switch (command) {
                    case "ADD_ORDER":
                        if (parts.length < 3) {
                            System.err.println("Error: ADD_ORDER requires item name and quantity.");
                        } else {
                            String itemName = parts[1];
                            try {
                                // Attempt to parse quantity as an integer
                                int quantity = Integer.parseInt(parts[2]);
                                // Call private method to add order
                                addOrder(itemName, quantity);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid quantity format. Please enter an integer.");
                            } catch (IllegalArgumentException e) {
                                // Catch validation errors from Order constructor
                                System.err.println("Error adding order: " + e.getMessage());
                            }
                        }
                        break;

                    case "PROCESS_NEXT":
                        if (parts.length > 1) {
                             System.err.println("Error: PROCESS_NEXT does not take arguments.");
                        } else {
                             // Call private method to process next order
                             processNextOrder();
                        }
                        break;

                    case "VIEW_QUEUE":
                         if (parts.length > 1) {
                             System.err.println("Error: VIEW_QUEUE does not take arguments.");
                        } else {
                            // Call private method to view queue
                            viewOrderQueue();
                        }
                        break;

                    case "VIEW_COMPLETED":
                         if (parts.length > 1) {
                             System.err.println("Error: VIEW_COMPLETED does not take arguments.");
                        } else {
                            // Call private method to view completed items
                            viewCompletedItems();
                        }
                        break;

                    case "EXIT":
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;

                    default:
                        // Handle unknown commands
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected errors during the processing of a specific command
                // This is less likely with the specific catches above, but good practice
                System.err.println("An error occurred while processing command:");
                e.printStackTrace(System.err); // Print stack trace for debugging unexpected issues
            }
        }
        scanner.close(); // Close the scanner when the loop exits
    }

    /**
     * Adds a new order to the order queue.
     * @param itemName The name of the item.
     * @param quantity The quantity.
     * Handles potential validation errors from the Order constructor.
     */
    private void addOrder(String itemName, int quantity) {
        try {
             // Create Order object - validation happens in constructor
             Order order = new Order(itemName, quantity);
             // offer() is generally preferred over add() for queues as it handles capacity constraints
             if (orderQueue.offer(order)) {
                 System.out.println("Added order: " + order);
             } else {
                 // This case is unlikely with LinkedList unless memory is exhausted
                 System.err.println("Failed to add order to queue.");
             }
        } catch (IllegalArgumentException e) {
             // Re-throw or handle as appropriate; here we catch and print error
             // The outer catch in run() could also catch this, but catching here
             // allows for a more specific error message format.
             System.err.println("Error adding order: " + e.getMessage());
        }
    }

    /**
     * Processes the next order in the queue.
     * Removes the order from the queue and adds completed items to the list.
     */
    private void processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Order nextOrder = orderQueue.poll();

        if (nextOrder == null) {
            System.err.println("Error: Order queue is empty. Nothing to process.");
            return; // Exit the method if queue is empty
        }

        System.out.println("Processing order: " + nextOrder);
        String itemName = nextOrder.getItemName();
        int quantity = nextOrder.getQuantity();

        // Simulate processing by adding items to the completed list
        for (int i = 0; i < quantity; i++) {
            completedItems.add(itemName);
        }
        System.out.println("Completed " + quantity + " units of '" + itemName + "'. Added to completed list.");
    }

    /**
     * Displays the current orders waiting in the queue.
     */
    private void viewOrderQueue() {
        System.out.println("--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue using a for-each loop (doesn't remove elements)
            int index = 1;
            for (Order order : orderQueue) {
                System.out.println(index++ + ". " + order);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays the names of all items currently in the completed list.
     */
    private void viewCompletedItems() {
        System.out.println("--- Completed Items ---");
        if (completedItems.isEmpty()) {
            System.out.println("No items have been completed yet.");
        } else {
            // Iterate through the list using a for-each loop
            int index = 1;
            for (String item : completedItems) {
                System.out.println(index++ + ". " + item);
            }
        }
        System.out.println("-----------------------");
    }
}
