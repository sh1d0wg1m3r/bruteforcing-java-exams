/*
 * Exam Question #65
 * Generated on: 2025-05-11 22:07:41
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application that simulates a task processing system. The system manages a queue of tasks awaiting execution and keeps a record of tasks that have been successfully completed. Users interact with the system through a menu-driven interface to add tasks, process the next task, view pending tasks, view completed tasks, or exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each task must have:
 *     *   A unique integer `id`.
 *     *   A `String` `type` (e.g., "Data Processing", "Report Generation", "System Maintenance").
 *     *   A `String` `description`.
 *     *   Private fields with public getter methods.
 *     *   A constructor to initialize these fields.
 *     *   An appropriate `toString()` method for easy printing.
 * 
 * 2.  **Task Processor:** Create a class named `TaskProcessor` to manage the tasks. This class must contain:
 *     *   A `private Queue<Task>` to hold tasks waiting to be processed. Use a `LinkedList` as the implementation.
 *     *   A `private List<Task>` to hold completed tasks. Use an `ArrayList` as the implementation, but declare the field using the `List` interface type.
 *     *   A mechanism to generate unique task IDs (e.g., an internal counter).
 *     *   Public methods:
 *         *   `addTask(String type, String description)`: Creates a new `Task` with a unique ID and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the task from the front of the pending queue and adds it to the completed list. This method should handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` (or `Collection`) view of the tasks currently in the pending queue (do not return the internal queue directly).
 *         *   `getCompletedTasks()`: Returns a `List` view of the tasks in the completed list.
 * 
 * 3.  **Main Application Logic:** Implement the main application in a class (e.g., `TaskSystemApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console for menu choices and task details.
 *     *   Implement a menu with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the different menu choices.
 *     *   Display output to the user using `System.out` (menu, prompts, task details, success messages).
 *     *   Display error messages to the user using `System.err` (invalid input, attempting to process an empty queue, other errors).
 *     *   Implement robust error handling using `try-catch` blocks:
 *         *   Handle `InputMismatchException` or `NumberFormatException` if the user enters non-numeric input for the menu choice.
 *         *   Handle the scenario where the user attempts to process a task when the pending queue is empty. You can signal this using a return value, a custom exception, or by checking the result of `poll()`.
 *         *   Include a general `catch (Exception e)` block to catch any other unexpected errors during the program execution and print an informative error message to `System.err`.
 *         *   Ensure the program continues running after an error unless the user chooses to exit.
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments or Javadoc where necessary.
 *     *   Validate user input (e.g., ensure type/description are not empty strings, handle non-numeric input for menu).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and display task information or error messages based on the user's choice. Error messages *must* be printed to `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type: Data Processing
 * Enter task description: Clean and transform sales data
 * Task added: Task{id=1, type='Data Processing', description='Clean and transform sales data'}
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=1, type='Data Processing', description='Clean and transform sales data'}
 * Task processed successfully.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Task Processing Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`Task`, `TaskProcessor`, `TaskSystemApp`, etc.) in a single file or logically separated if preferred, ensuring it compiles and runs correctly.
 *
 * EXPLANATION:
 * This solution implements the Task Processing Simulation system as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses `private` fields (`id`, `type`, `description`) and `public` getter methods (`getId`, `getType`, `getDescription`) to enforce encapsulation.
 *     *   The constructor initializes the task properties.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the collection of tasks.
 *     *   Uses a `private Queue<Task>` (`LinkedList` implementation) named `pendingTasks` to store tasks awaiting processing. The `Queue` interface is ideal here because tasks are processed in FIFO (First-In, First-Out) order.
 *     *   Uses a `private List<Task>` (`ArrayList` implementation) named `completedTasks` to store tasks after they are processed. Declaring it as `List<Task>` demonstrates the use of the interface type, which is good practice.
 *     *   `nextTaskId` ensures unique IDs for new tasks.
 *     *   `addTask`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. Includes basic input validation for type and description.
 *     *   `processNextTask`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. `poll()` returns `null` if the queue is empty, which is checked to provide an appropriate error message to `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `getPendingTasks` and `getCompletedTasks`: These methods return *new* `ArrayList` instances populated with the current tasks from the internal collections. This prevents external code from directly modifying the processor's internal state, maintaining encapsulation. They return `List<Task>` as required.
 * 
 * 3.  **`TaskSystemApp` Class (Main Application):**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   A `Scanner` is used for reading user input from `System.in`.
 *     *   The main logic runs in a `while(running)` loop.
 *     *   `displayMenu()` prints the options to `System.out`.
 *     *   Input for the menu choice is read. A `try-catch(InputMismatchException)` block handles cases where the user enters non-numeric input, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. A `finally` block ensures `scanner.nextLine()` is called after `nextInt()` to consume the newline character, preventing issues with subsequent `nextLine()` calls for task details.
 *     *   A `switch` statement directs the program flow based on the valid menu choice.
 *     *   Cases 1-4 call the corresponding methods on the `TaskProcessor` instance.
 *     *   Case 1 (`addTask`): Prompts for task type and description using `System.out` and reads them using `scanner.nextLine()`.
 *     *   Cases 3 & 4 (Viewing Tasks): Retrieve the lists of tasks using the `getPendingTasks()` and `getCompletedTasks()` methods, then iterate through them using a `for` loop to print each task to `System.out`. Includes checks for empty lists.
 *     *   Case 2 (`processNextTask`): Calls the processor method, which includes its own check for an empty queue and prints the error to `System.err`.
 *     *   Case 5 sets `running` to `false` to exit the loop.
 *     *   The `default` case in the switch handles invalid numeric choices, printing an error to `System.err`.
 *     *   **Class-wide Exception Handling:** The main `while` loop and its contents are wrapped in a `try-catch(Exception e)` block. This serves as a general safety net to catch any unexpected runtime exceptions that might occur, printing an error message and stack trace to `System.err` before the `finally` block is executed.
 *     *   The `finally` block ensures the `Scanner` is closed when the application exits, releasing system resources.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks within a practical simulation, demonstrating key Java concepts and error handling best practices.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task in the system
class Task {
    private int id;
    private String type;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param type The type of the task (e.g., "Data Processing").
     * @param description A brief description of the task.
     */
    public Task(int id, String type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task{id=" + id + ", type='" + type + "', description='" + description + "'}";
    }
}

// Manages the queue of pending tasks and list of completed tasks
class TaskProcessor {
    // Queue for tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessor.
     * Initializes the pending queue and completed list.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // Queue implementation
        this.completedTasks = new ArrayList<>(); // List implementation
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Automatically assigns a unique ID.
     * @param type The type of the task.
     * @param description The description of the task.
     */
    public void addTask(String type, String description) {
        // Basic validation for input
        if (type == null || type.trim().isEmpty() || description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task type and description cannot be empty.");
            return; // Do not add the task if input is invalid
        }
        Task newTask = new Task(nextTaskId++, type.trim(), description.trim());
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for capacity-constrained queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * @return The processed Task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll() returns null if queue is empty
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            System.out.println("Processing task: " + taskToProcess);
            System.out.println("Task processed successfully.");
        } else {
            // Use System.err for error message as required
            System.err.println("Error: No tasks in the queue to process.");
        }
        return taskToProcess;
    }

    /**
     * Returns a copy of the current pending tasks list.
     * @return A List containing the tasks in the pending queue.
     */
    public List<Task> getPendingTasks() {
        // Return a new list to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a copy of the current completed tasks list.
     * @return A List containing the completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a new list to prevent external modification
        return new ArrayList<>(completedTasks);
    }
}

// Main application class
public class TaskSystemApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Task Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Task Processing Simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor processor = new TaskProcessor();
        boolean running = true;

        // Class-wide exception handling using try-catch block
        try {
            while (running) {
                displayMenu();

                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                } finally {
                     // Consume the rest of the line after reading the integer
                     // This prevents issues with reading strings later
                     scanner.nextLine();
                }


                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task type: ");
                        String type = scanner.nextLine();
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(type, description);
                        break;

                    case 2:
                        // processNextTask handles the empty queue error internally
                        processor.processNextTask();
                        break;

                    case 3:
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = processor.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No tasks in the pending queue.");
                        } else {
                            for (int i = 0; i < pending.size(); i++) {
                                System.out.println((i + 1) + ". " + pending.get(i));
                            }
                        }
                        break;

                    case 4:
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = processor.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No tasks have been completed yet.");
                        } else {
                            for (int i = 0; i < completed.size(); i++) {
                                System.out.println((i + 1) + ". " + completed.get(i));
                            }
                        }
                        break;

                    case 5:
                        System.out.println("Exiting Task Processing Simulation. Goodbye!");
                        running = false;
                        break;

                    default:
                        // Use System.err for invalid choice error
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // General catch block for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
