/*
 * Exam Question #630
 * Generated on: 2025-05-12 16:17:05
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Processing System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple, console-based system to manage and process tasks. Tasks are submitted, queued for processing, and then moved to lists of completed or failed tasks based on a simple processing rule.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:**
 *     *   Create a `Task` class with private fields: `taskId` (int, auto-generated), `description` (String), and `status` (an enum: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Include a constructor, appropriate getters, and a controlled setter for the status.
 *     *   Override `toString()` to provide a clear representation of a task.
 * 
 * 2.  **Task Processing Logic:**
 *     *   Create a `TaskProcessor` class.
 *     *   This class should manage three collections:
 *         *   A `Queue<Task>` to hold tasks waiting to be processed (`taskQueue`).
 *         *   A `List<Task>` to hold tasks that were successfully completed (`completedTasks`). Use `ArrayList` as the concrete implementation.
 *         *   A `List<Task>` to hold tasks that failed processing (`failedTasks`). Use `ArrayList` as the concrete implementation.
 *     *   Implement a method `addTask(String description)` that creates a new `Task` with a unique ID and `PENDING` status, and adds it to the `taskQueue`. Validate that the description is not empty or null.
 *     *   Implement a method `processNextTask()` that:
 *         *   Retrieves the next task from the `taskQueue`.
 *         *   If the queue is empty, report an error using `System.err`.
 *         *   If a task is retrieved, change its status to `PROCESSING`.
 *         *   Simulate processing: If the task description contains the word "FAIL" (case-insensitive), change the status to `FAILED` and move the task to the `failedTasks` list.
 *         *   Otherwise (if "FAIL" is not in the description), change the status to `COMPLETED` and move the task to the `completedTasks` list.
 *         *   Report the outcome (success or failure) using `System.out`.
 *     *   Implement methods to view the contents of the `taskQueue`, `completedTasks`, and `failedTasks` using `System.out`.
 * 
 * 3.  **User Interface:**
 *     *   In the `main` method, create a console-based menu using `Scanner` for user input.
 *     *   The menu should offer options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks (Queue)
 *         4.  View Completed Tasks
 *         5.  View Failed Tasks
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement input validation for the menu choice (ensure it's a number within the valid range).
 *     *   Use `System.out` for menu display and prompts.
 *     *   Use `System.err` for invalid input messages or processing errors (e.g., trying to process when the queue is empty).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks where necessary (e.g., around `Scanner` input, potential issues during processing). A general `catch(Exception e)` in the main loop handling user commands is recommended.
 * 
 * **Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (Javadocs are a plus).
 * *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting user input, performing the requested actions, and printing results or errors to the console (`System.out` or `System.err`) as appropriate. Example interactions could look like:
 * 
 * ```
 * --- Task Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View Failed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Clean the room
 * Task added with ID 1.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix the FAILing test
 * Task added with ID 2.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * [Task ID: 1, Description: Clean the room, Status: PENDING]
 * [Task ID: 2, Description: Fix the FAILing test, Status: PENDING]
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 2
 * Processing Task ID: 1...
 * Task ID 1 completed successfully.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 2
 * Processing Task ID: 2...
 * Task ID 2 failed processing.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * [Task ID: 1, Description: Clean the room, Status: COMPLETED]
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 5
 * Failed Tasks:
 * [Task ID: 2, Description: Fix the FAILing test, Status: FAILED]
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 9
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Processing System ---
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * This task requires integrating multiple core Java concepts and collections in a practical application, demonstrating understanding of data structures, object-oriented design, and robust programming practices.
 *
 * EXPLANATION:
 * This solution implements the Task Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** Represents the individual work items. It uses an `enum` (`TaskStatus`) for clear state management. Fields are `private` and accessed via `public` getters and a controlled `setStatus` method, adhering to encapsulation principles. The `toString()` method provides a user-friendly representation.
 * 
 * 2.  **TaskProcessor Class:** This is the core logic handler.
 *     *   It uses a `Queue<Task>` (`LinkedList` implementation) to manage tasks waiting for processing, leveraging the FIFO (First-In, First-Out) nature of a queue.
 *     *   It uses `List<Task>` types (`ArrayList` implementations) for `completedTasks` and `failedTasks`, providing dynamic arrays to store tasks after processing. Using the `List` interface for variable declaration promotes flexibility.
 *     *   `addTask`: Creates a new `Task`, assigns a unique ID using `nextTaskId`, and adds it to the `taskQueue` using `offer()`. It includes basic input validation for the description.
 *     *   `processNextTask`: Demonstrates queue manipulation using `poll()` to retrieve and remove the next task. It simulates processing by checking the description and updates the task's status before adding it to the appropriate `List` (`completedTasks` or `failedTasks`). It handles the case where the queue is empty.
 *     *   `view...Tasks` methods: Iterate through the respective collections and print task details using `System.out`. `taskQueue.forEach()` and `list.forEach()` are used for concise iteration.
 * 
 * 3.  **TaskSystem Class (Main):**
 *     *   The `main` method serves as the application entry point and user interface controller.
 *     *   It initializes `Scanner` for input and `TaskProcessor` for logic.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed, user input is read using `scanner.nextLine()`, and a `switch` statement directs the flow based on the parsed integer choice.
 *     *   **Exception Handling:** A `try-catch` block wraps the core logic inside the loop.
 *         *   `NumberFormatException` is caught specifically for invalid non-integer input when parsing the menu choice. `System.err` is used to report this error.
 *         *   `IllegalArgumentException` is caught to handle validation errors thrown by the `addTask` method. `System.err` is used.
 *         *   A general `catch(Exception e)` is included as a fallback for any other unexpected runtime errors within the command processing block, demonstrating class-wide handling within the main operational loop. `System.err` is used for reporting.
 *     *   `System.out` is used for menu display, prompts, and successful operation messages.
 *     *   `System.err` is used exclusively for error messages (invalid input, empty queue, validation failures, unexpected exceptions).
 *     *   The `Scanner` resource is closed when the application exits.
 * 
 * This solution effectively combines the required Java collection types (`Queue`, `ArrayList`, `List`), control flow (`switch`), input handling (`Scanner`), and error reporting (`System.out`, `System.err`, `try-catch`) within a structured, object-oriented design that simulates a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Represents a single task
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[Task ID: " + taskId + ", Description: " + description + ", Status: " + status + "]";
    }
}

// Manages the task queue and completed/failed lists
class TaskProcessor {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private List<Task> failedTasks;
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList for completed and failed tasks
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the queue.
     * @param description The description for the new task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.offer(newTask); // offer() is preferred over add() for capacity-constrained queues (though LinkedList is not)
        System.out.println("Task added with ID " + newTask.getTaskId() + ".");
    }

    /**
     * Processes the next task in the queue.
     * Moves the task to completed or failed list based on description.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        System.out.println("Processing Task ID: " + taskToProcess.getTaskId() + "...");
        taskToProcess.setStatus(TaskStatus.PROCESSING);

        // Simulate processing logic
        if (taskToProcess.getDescription().toUpperCase().contains("FAIL")) {
            taskToProcess.setStatus(TaskStatus.FAILED);
            failedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getTaskId() + " failed processing.");
        } else {
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getTaskId() + " completed successfully.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks (Queue) ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            completedTasks.forEach(System.out::println);
        }
    }

    /**
     * Displays all tasks that have failed processing.
     */
    public void viewFailedTasks() {
        System.out.println("\n--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("No tasks have failed processing yet.");
        } else {
            failedTasks.forEach(System.out::println);
        }
    }
}

// Main application class
public class TaskSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor processor = new TaskProcessor();
        boolean running = true;

        System.out.println("--- Welcome to the Task Processing System ---");

        // Main application loop with class-wide exception handling
        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter your choice: ");
                // Read the entire line to avoid issues with nextInt() followed by nextLine()
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine); // Attempt to parse input as integer

                // Use switch for command handling
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(description); // addTask handles its own validation and output
                        break;
                    case 2: // Process Next Task
                        processor.processNextTask(); // processNextTask handles its own empty queue check and output
                        break;
                    case 3: // View Pending Tasks
                        processor.viewPendingTasks();
                        break;
                    case 4: // View Completed Tasks
                        processor.viewCompletedTasks();
                        break;
                    case 5: // View Failed Tasks
                        processor.viewFailedTasks();
                        break;
                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Handle cases where input is not an integer
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (IllegalArgumentException e) {
                // Handle validation errors from addTask
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development/testing
                // e.printStackTrace();
            }

            // Add a small pause or prompt before showing menu again, unless exiting
            if (running) {
                 System.out.println("\n------------------------------");
            }
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Processing System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
    }
}
