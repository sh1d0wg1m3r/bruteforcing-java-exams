/*
 * Exam Question #135
 * Generated on: 2025-05-11 22:19:50
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Print Job Scheduler Simulation**
 * 
 * You are tasked with developing a simple command-line application that simulates a print job scheduling system. The system should manage print jobs waiting in a queue and track jobs that have been completed.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage print jobs waiting to be processed.
 *     *   Use `java.util.ArrayList` to store completed print jobs.
 *     *   Use the `java.util.List` interface type when referring to the collection of completed jobs.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Add Job, Process Next Job, View Job Queue, View Completed Jobs, Exit).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, job details, queue contents, completed job list, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue is empty).
 * 5.  **Error Handling:**
 *     *   Implement input validation for user choices.
 *     *   Handle potential errors (e.g., trying to process a job when the queue is empty).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during the main execution loop or input processing.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `PrintJob` class to represent a single print job. It should have private fields for `jobId` (int), `documentName` (String), and `status` (String, e.g., "Queued", "Processing", "Completed"). Provide public getter methods.
 *     *   Create a `PrintScheduler` class to manage the queue and completed jobs list. This class should contain the main application logic and the data structures.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining key parts of the code.
 * 
 * **Functionality Details:**
 * 
 * *   **Add Job:** Prompt the user for the document name. Create a new `PrintJob` with a unique ID (e.g., incrementing counter) and "Queued" status, and add it to the queue.
 * *   **Process Next Job:** If the queue is not empty, remove the next job from the queue, change its status to "Completed", and add it to the list of completed jobs. Print a message indicating which job was processed. If the queue is empty, print an error message to `System.err`.
 * *   **View Job Queue:** Display the details of all jobs currently in the queue, in order. Do not remove them from the queue.
 * *   **View Completed Jobs:** Display the details of all jobs that have been completed.
 * *   **Exit:** Terminate the application.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, presenting a menu, accepting input, and displaying output based on the selected option. Error messages should appear on `System.err`.
 * 
 * Example interaction:
 * 
 * ```
 * Print Job Scheduler Menu:
 * 1. Add Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter document name: MyReport.pdf
 * Job added: Job ID: 1, Document: MyReport.pdf, Status: Queued
 * 
 * Print Job Scheduler Menu:
 * ...
 * Enter your choice: 3
 * --- Job Queue ---
 * Job ID: 1, Document: MyReport.pdf, Status: Queued
 * -----------------
 * 
 * Print Job Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing job: Job ID: 1, Document: MyReport.pdf
 * Job completed: Job ID: 1, Document: MyReport.pdf, Status: Completed
 * 
 * Print Job Scheduler Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job ID: 1, Document: MyReport.pdf, Status: Completed
 * ----------------------
 * 
 * Print Job Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Error: The job queue is empty.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a basic print job scheduler simulation using the required Java components and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print job with `jobId`, `documentName`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A `setStatus` method is included, used internally by the scheduler.
 *     *   `toString()` provides a convenient way to display job information.
 * 
 * 2.  **`PrintScheduler` Class:**
 *     *   This is the main class containing the application logic.
 *     *   **`jobQueue` (Queue):** A `Queue<PrintJob>` (implemented using `LinkedList`) stores jobs waiting to be processed. The `offer()` method is used to add jobs, and `poll()` is used to remove and retrieve the next job. `isEmpty()` checks if the queue has elements. Iteration for `viewJobQueue` uses a for-each loop, which iterates without removing elements.
 *     *   **`completedJobs` (List):** A `List<PrintJob>` (typed as the interface `List` but implemented as `ArrayList`) stores jobs that have been processed. `add()` is used to add completed jobs. Iteration for `viewCompletedJobs` uses a for-each loop.
 *     *   **`scanner` (Scanner):** Used for reading user input from `System.in`.
 *     *   **`nextJobId`:** An integer counter to assign unique IDs to new jobs.
 *     *   **Methods:**
 *         *   `addJob()`: Prompts for input, creates a `PrintJob`, and adds it to the `jobQueue`. Includes basic validation for the document name.
 *         *   `processNextJob()`: Checks if the queue is empty using `isEmpty()`. If not, it removes the head job using `poll()`, updates its status, and adds it to `completedJobs`. If the queue is empty, it prints an error to `System.err`.
 *         *   `viewJobQueue()`: Iterates through the `jobQueue` to display its contents without modifying it.
 *         *   `viewCompletedJobs()`: Iterates through the `completedJobs` list to display its contents.
 *         *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *         *   `run()`: Contains the main application loop (`while`).
 *             *   It calls `displayMenu()` and reads user input using `scanner.nextInt()`.
 *             *   Crucially, it includes `scanner.nextLine()` after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls (like in `addJob`).
 *             *   Input validation is performed using `hasNextInt()` before calling `nextInt()` to prevent `InputMismatchException` if the user enters non-numeric input for the choice.
 *             *   A `switch` statement handles the different menu options, calling the appropriate methods.
 *             *   A `default` case in the switch handles invalid numeric choices.
 *             *   **Class-wide Exception Handling:** A `try-catch` block wraps the core logic inside the `while` loop. This allows catching exceptions like `InputMismatchException` (if the `hasNextInt` check were less robust or absent) or other unexpected runtime errors. Error messages are printed to `System.err`. The loop continues after catching an exception (unless a critical error occurs that would necessitate exiting).
 *     *   **`main()` Method:** Creates an instance of `PrintScheduler` and calls its `run()` method to start the application.
 * 
 * This solution effectively demonstrates the required components: `Queue` for managing waiting items, `List`/`ArrayList` for storing a collection of processed items, `Scanner` for interactive input, `switch` for menu control, `System.out` for normal output, `System.err` for errors, and `try-catch` for robust exception handling, all within a well-structured object-oriented design.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int jobId;
    private String documentName;
    private String status;

    // Constructor
    public PrintJob(int jobId, String documentName) {
        this.jobId = jobId;
        this.documentName = documentName;
        this.status = "Queued"; // Initial status
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getDocumentName() {
        return documentName;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status (used internally by scheduler)
    public void setStatus(String status) {
        this.status = status;
    }

    // String representation for display
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", Document: " + documentName + ", Status: " + status;
    }
}

// Manages the print job queue and completed jobs
class PrintScheduler {
    private Queue<PrintJob> jobQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId;
    private Scanner scanner;

    // Constructor
    public PrintScheduler() {
        // Use LinkedList as a concrete implementation of Queue
        this.jobQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the queue.
     */
    public void addJob() {
        System.out.print("Enter document name: ");
        String documentName = scanner.nextLine();
        if (documentName == null || documentName.trim().isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }
        PrintJob newJob = new PrintJob(nextJobId++, documentName.trim());
        jobQueue.offer(newJob); // offer is preferred over add for queues
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the queue.
     */
    public void processNextJob() {
        if (jobQueue.isEmpty()) {
            System.err.println("Error: The job queue is empty.");
            return;
        }

        PrintJob jobToProcess = jobQueue.poll(); // Retrieve and remove the head of the queue
        System.out.println("Processing job: " + jobToProcess);

        // Simulate processing time or complex logic (optional)
        // For this simulation, we just change status and move it

        jobToProcess.setStatus("Completed");
        completedJobs.add(jobToProcess);
        System.out.println("Job completed: " + jobToProcess);
    }

    /**
     * Displays all jobs currently in the queue without removing them.
     */
    public void viewJobQueue() {
        System.out.println("--- Job Queue ---");
        if (jobQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (PrintJob job : jobQueue) {
                System.out.println(job);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Displays all completed jobs.
     */
    public void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list of completed jobs
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\nPrint Job Scheduler Menu:");
        System.out.println("1. Add Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Job Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            try {
                displayMenu();

                // Check if the next input is an integer before reading
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input and report error
                    String invalidInput = scanner.next();
                    System.err.println("Error: Invalid input '" + invalidInput + "'. Please enter a number.");
                    choice = -1; // Reset choice to ensure loop continues and menu is shown
                    continue; // Skip the switch statement for this iteration
                }

                // Consume the rest of the line after reading the integer choice
                // This is crucial because nextInt() doesn't consume the newline character
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        addJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewJobQueue();
                        break;
                    case 4:
                        viewCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Scheduler. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                 // This catch block is technically redundant due to the hasNextInt() check,
                 // but kept here to demonstrate catching InputMismatchException explicitly
                 // as part of a broader exception handling strategy.
                 System.err.println("Error: Invalid input. Please enter a number.");
                 scanner.nextLine(); // Consume the invalid input line
                 choice = -1; // Reset choice
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
                // Decide whether to continue or exit based on the severity of the error
                // For this exam, we'll let it continue after reporting
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        PrintScheduler scheduler = new PrintScheduler();
        scheduler.run();
    }
}
