/*
 * Exam Question #124
 * Generated on: 2025-05-11 22:18:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Advanced Programming Exam Task: Event Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simple command-line based Event Management System for a conference. The system should manage a limited number of attendees and maintain a waiting list for those who cannot initially get a spot.
 * 
 * The system should support the following operations via a menu:
 * 1.  **Buy Ticket:** An individual attempts to buy a ticket. If the event is not full, they are added to the attendee list. If the event is full, they cannot buy a ticket but are informed. An individual cannot buy a ticket if they are already an attendee.
 * 2.  **Join Waiting List:** An individual requests to join the waiting list. They can only join if the event is full and they are not already an attendee or on the waiting list. They are added to the end of the waiting list.
 * 3.  **Cancel Ticket:** An attendee cancels their ticket. They are removed from the attendee list. If the waiting list is not empty, the first person on the waiting list is automatically moved to the attendee list.
 * 4.  **View Attendees:** Display the current list of attendees.
 * 5.  **View Waiting List:** Display the current waiting list.
 * 6.  **Exit:** Terminate the application.
 * 
 * The event has a fixed, small capacity (e.g., 5 attendees for testing).
 * 
 * **Requirements:**
 * 
 * *   Implement the system using standard Java collections and I/O.
 * *   Use a `java.util.Queue` to represent the waiting list (FIFO - First-In, First-Out).
 * *   Use a `java.util.ArrayList` to store the attendees.
 * *   Declare the attendee list using the `java.util.List` interface.
 * *   Use `java.util.Scanner` to read user input for menu choices and names.
 * *   Use a `switch` statement to handle the main menu navigation.
 * *   Use `System.err` to print error messages (e.g., invalid input, attempting to cancel a non-existent ticket, attempting to join waiting list when not full).
 * *   Use `System.out` for all normal output (menu, success messages, list displays).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues, particularly related to user input (e.g., non-integer input for menu).
 * *   Design the system with proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (basic Javadoc or inline comments explaining key parts).
 * *   Perform basic input validation (e.g., ensuring names are not empty, handling non-numeric menu input).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors. Example interactions might look like:
 * 
 * ```
 * Welcome to Java Dev Conference Ticket Management System!
 * 
 * --- Menu ---
 * 1. Buy Ticket
 * ...
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Ticket bought successfully for Alice.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Ticket bought successfully for Bob.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: Charlie
 * Ticket bought successfully for Charlie.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: David
 * Ticket bought successfully for David.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: Eve
 * Ticket bought successfully for Eve.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: Frank
 * Event is full. Frank cannot buy a ticket.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Enter your name for waiting list: Frank
 * Frank added to the waiting list.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Enter your name for waiting list: Grace
 * Grace added to the waiting list.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Attendees (5/5) ---
 * 1. Alice
 * 2. Bob
 * 3. Charlie
 * 4. David
 * 5. Eve
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * --- Waiting List (2) ---
 * 1. Frank
 * 2. Grace
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * Enter attendee name to cancel: Bob
 * Ticket cancelled for Bob.
 * A spot opened up! Frank from the waiting list has been added to attendees.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Attendees (5/5) ---
 * 1. Alice
 * 2. Charlie
 * 3. David
 * 4. Eve
 * 5. Frank
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * --- Waiting List (1) ---
 * 1. Grace
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Correct implementation of event logic (capacity, waiting list flow).
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Effective input validation and error handling.
 * *   Clean and readable code structure.
 *
 * EXPLANATION:
 * This solution implements a simple Event Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Scenario Mapping:** The core problem involves managing two groups of people: confirmed attendees and those waiting for a spot. This naturally maps to a `List` for attendees (where order doesn't strictly matter for logic, but indexed access is useful for display, making `ArrayList` a good fit) and a `Queue` for the waiting list (where the first person added is the first person to get a spot, fitting the FIFO nature of a queue).
 * 
 * 2.  **Class Structure:**
 *     *   `Attendee`: A simple class to hold attendee data (just a name in this case). Encapsulates attendee information.
 *     *   `Event`: This class encapsulates the state of the event (`capacity`, `attendees` list, `waitingList` queue) and the core business logic methods (`buyTicket`, `joinWaitingList`, `cancelTicket`, `viewAttendees`, `viewWaitingList`). This adheres to encapsulation principles.
 *     *   `EventManagementSystem`: Contains the `main` method, sets up the `Event` and `Scanner`, and manages the main application loop, user interaction, and menu handling.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: The `waitingList` field in the `Event` class is declared as `java.util.Queue<String>` and instantiated as a `java.util.LinkedList`. `LinkedList` is commonly used to implement `Queue` as it provides efficient additions to the tail (`offer`) and removals from the head (`poll`).
 *     *   `ArrayList`: The `attendees` field in the `Event` class is instantiated as `java.util.ArrayList<Attendee>`. This provides dynamic resizing and efficient element access by index or iteration.
 *     *   `List`: The `attendees` field is declared using the `java.util.List` interface, promoting good practice by programming to the interface rather than the specific implementation where possible.
 *     *   `Scanner`: Used in `EventManagementSystem` to read integer choices and string names from `System.in`.
 *     *   `Switch statement`: Used in the `EventManagementSystem.run()` method to direct program flow based on the user's menu choice.
 *     *   `System.err`: Used throughout the `EventManagementSystem` and `Event` classes to print error messages, distinguishing them from normal output.
 *     *   `System.out`: Used for printing the menu, success messages, and displaying the lists of attendees and waiting list members.
 *     *   `Try-catch blocks`: A primary `try-catch` block is wrapped around the menu input reading and the entire `switch` statement within the `EventManagementSystem.run()` method. This handles `InputMismatchException` if the user enters non-numeric input for the menu choice, preventing the program from crashing. A general `Exception` catch is also included for unexpected errors.
 * 
 * 4.  **Key Logic (Cancellation):** The `cancelTicket` method demonstrates the interaction between the `List` and the `Queue`. When a ticket is cancelled (removing an `Attendee` from the `ArrayList`), the code checks if the `waitingList` `Queue` is not empty. If it's not, it uses `waitingList.poll()` to retrieve and remove the first person from the queue, effectively moving them into the `attendees` `List`.
 * 
 * 5.  **Error Handling and Input Validation:**
 *     *   `InputMismatchException` is caught in the `EventManagementSystem.run()` method for invalid menu input.
 *     *   Business logic errors (e.g., event full, attendee not found, already on waiting list) are checked within the `Event` methods, and descriptive error messages are printed to `System.err`.
 *     *   Basic validation for empty names is done in the `EventManagementSystem.run()` method before calling `Event` methods.
 * 
 * 6.  **Best Practices:**
 *     *   Fields are `private`.
 *     *   Methods are `public` where they are part of the public interface, or `private` for internal helpers (`isAttendee`, `printMenu`).
 *     *   Variable and method names are descriptive (`attendees`, `waitingList`, `buyTicket`, `cancelTicket`, `viewAttendees`).
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   The code is structured logically into separate classes with clear responsibilities.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simple, application that simulates a real-world event management scenario, while adhering to good programming practices and including necessary error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an attendee for the event.
 */
class Attendee {
    private String name;

    /**
     * Constructs an Attendee object.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    // Optional: Override equals and hashCode if name uniqueness needs strict enforcement
    // For this problem, simple name comparison is sufficient in logic.
}

/**
 * Manages the event, including attendees and the waiting list.
 */
class Event {
    private String name;
    private int capacity;
    private List<Attendee> attendees; // Uses ArrayList implementation
    private Queue<String> waitingList; // Uses LinkedList implementation

    /**
     * Constructs an Event object.
     * @param name The name of the event.
     * @param capacity The maximum number of attendees.
     */
    public Event(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.attendees = new ArrayList<>(); // Use ArrayList for attendees
        this.waitingList = new LinkedList<>(); // Use LinkedList for Queue
    }

    /**
     * Gets the name of the event.
     * @return The event name.
     */
    public String getName() {
        return name;
    }

    /**
     * Attempts to buy a ticket for an individual.
     * @param attendeeName The name of the person buying the ticket.
     * @return true if the ticket was bought successfully, false otherwise.
     */
    public boolean buyTicket(String attendeeName) {
        if (isAttendee(attendeeName)) {
            System.err.println("Error: " + attendeeName + " is already an attendee.");
            return false;
        }

        if (attendees.size() < capacity) {
            attendees.add(new Attendee(attendeeName));
            System.out.println("Ticket bought successfully for " + attendeeName + ".");
            return true;
        } else {
            System.out.println("Event is full. " + attendeeName + " cannot buy a ticket.");
            return false;
        }
    }

    /**
     * Attempts to add an individual to the waiting list.
     * @param applicantName The name of the person joining the waiting list.
     * @return true if added to the waiting list, false otherwise.
     */
    public boolean joinWaitingList(String applicantName) {
        if (isAttendee(applicantName)) {
             System.out.println(applicantName + " is already an attendee. No need to join waiting list.");
             return false;
        }
        if (waitingList.contains(applicantName)) {
            System.out.println(applicantName + " is already on the waiting list.");
            return false;
        }
         if (attendees.size() < capacity) {
            System.err.println("Error: Event is not full. Please try to buy a ticket instead of joining the waiting list.");
            return false;
        }

        waitingList.offer(applicantName); // Add to the end of the queue
        System.out.println(applicantName + " added to the waiting list.");
        return true;
    }

    /**
     * Attempts to cancel a ticket for an attendee.
     * If successful and the waiting list is not empty, moves the next person
     * from the waiting list to the attendees.
     * @param attendeeName The name of the attendee cancelling the ticket.
     * @return true if the ticket was cancelled, false otherwise.
     */
    public boolean cancelTicket(String attendeeName) {
        Attendee attendeeToRemove = null;
        // Find the attendee in the list (case-insensitive comparison)
        for (Attendee a : attendees) {
            if (a.getName().equalsIgnoreCase(attendeeName)) {
                attendeeToRemove = a;
                break;
            }
        }

        if (attendeeToRemove != null) {
            attendees.remove(attendeeToRemove);
            System.out.println("Ticket cancelled for " + attendeeName + ".");

            // If there are people on the waiting list, move the first one to attendees
            if (!waitingList.isEmpty()) {
                String nextAttendeeName = waitingList.poll(); // Get and remove the head of the queue
                attendees.add(new Attendee(nextAttendeeName)); // Add to the attendees list
                System.out.println("A spot opened up! " + nextAttendeeName + " from the waiting list has been added to attendees.");
            }
            return true;
        } else {
            System.err.println("Error: " + attendeeName + " not found in the attendee list.");
            return false;
        }
    }

    /**
     * Displays the current list of attendees.
     * Uses System.out.
     */
    public void viewAttendees() {
        System.out.println("\n--- Attendees (" + attendees.size() + "/" + capacity + ") ---");
        if (attendees.isEmpty()) {
            System.out.println("No attendees yet.");
        } else {
            // Iterate and print attendees using the List interface
            for (int i = 0; i < attendees.size(); i++) {
                System.out.println((i + 1) + ". " + attendees.get(i).getName());
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the current waiting list.
     * Uses System.out.
     */
    public void viewWaitingList() {
        System.out.println("\n--- Waiting List (" + waitingList.size() + ") ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate the queue without removing elements
            int i = 1;
            for (String name : waitingList) {
                 System.out.println((i++) + ". " + name);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Helper method to check if a person is already an attendee.
     * @param name The name to check.
     * @return true if the person is an attendee, false otherwise.
     */
    private boolean isAttendee(String name) {
        // Iterate through the List to check for the name
        for (Attendee a : attendees) {
            if (a.getName().equalsIgnoreCase(name)) {
                return true;
            }
        }
        return false;
    }
}

/**
 * Main class to run the Event Management System.
 * Handles user interaction and the main application loop.
 */
public class EventManagementSystem {
    private static final int EVENT_CAPACITY = 5; // Fixed capacity for the event
    private static final String EVENT_NAME = "Java Dev Conference";

    private Event event;
    private Scanner scanner;

    /**
     * Constructs the EventManagementSystem.
     * Initializes the Event and Scanner.
     */
    public EventManagementSystem() {
        event = new Event(EVENT_NAME, EVENT_CAPACITY);
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Welcome to " + event.getName() + " Ticket Management System!");
        int choice = -1;

        // Main application loop
        while (choice != 0) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Buy Ticket
                        System.out.print("Enter attendee name: ");
                        String buyName = scanner.nextLine().trim();
                        if (buyName.isEmpty()) {
                            System.err.println("Error: Name cannot be empty.");
                        } else {
                            event.buyTicket(buyName);
                        }
                        break;
                    case 2: // Join Waiting List
                         System.out.print("Enter your name for waiting list: ");
                         String waitName = scanner.nextLine().trim();
                         if (waitName.isEmpty()) {
                            System.err.println("Error: Name cannot be empty.");
                        } else {
                            event.joinWaitingList(waitName);
                        }
                        break;
                    case 3: // Cancel Ticket
                        System.out.print("Enter attendee name to cancel: ");
                        String cancelName = scanner.nextLine().trim();
                         if (cancelName.isEmpty()) {
                            System.err.println("Error: Name cannot be empty.");
                        } else {
                            event.cancelTicket(cancelName);
                        }
                        break;
                    case 4: // View Attendees
                        event.viewAttendees();
                        break;
                    case 5: // View Waiting List
                        event.viewWaitingList();
                        break;
                    case 0: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 0 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure loop continues if input was invalid
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging detailed stack trace
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Prints the main menu options to the console.
     * Uses System.out.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Buy Ticket");
        System.out.println("2. Join Waiting List");
        System.out.println("3. Cancel Ticket");
        System.out.println("4. View Attendees");
        System.out.println("5. View Waiting List");
        System.out.println("0. Exit");
        System.out.println("------------");
    }

    /**
     * Main method to start the Event Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        new EventManagementSystem().run();
    }
}
