/*
 * Exam Question #776
 * Generated on: 2025-05-12 16:39:11
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Healthcare Clinic Patient Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified patient management system for a small healthcare clinic. The system should manage patients waiting to be seen and keep a record of patients who have been processed.
 * 
 * The system must allow users to:
 * 1.  **Add a new patient** to the waiting queue. Each patient has a unique ID (assigned by the system), a name, and a medical condition type (e.g., "Urgent", "Routine", "Consultation").
 * 2.  **Process the next patient** in the waiting queue. This action removes the patient from the front of the queue and moves them to a list of processed patients.
 * 3.  **View the current waiting queue**.
 * 4.  **View the list of processed patients**.
 * 5.  **Exit** the application.
 * 
 * **Technical Requirements:**
 * 
 * 1.  Implement a `Patient` class with appropriate fields (ID, name, condition) and methods (constructor, getters, `toString`). Ensure proper encapsulation.
 * 2.  Implement a `ClinicSystem` class that manages the waiting queue and the list of processed patients.
 *     *   Use `java.util.Queue` for the waiting patients.
 *     *   Use `java.util.List` (specifically, an `ArrayList`) for the processed patients.
 *     *   Provide public methods in `ClinicSystem` for adding patients, processing patients, and viewing the queue/processed lists.
 * 3.  The main application logic should reside in a separate class (e.g., `ClinicApp`).
 * 4.  Use `java.util.Scanner` to read user input for menu choices and patient details.
 * 5.  Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  Display normal output (menu, confirmations, lists) using `System.out`.
 * 7.  Display error messages (invalid input, operation on empty collections) using `System.err`.
 * 8.  Implement robust error handling using `try-catch` blocks. This should include handling potential `NumberFormatException` for menu input, and handling operations on empty queues/lists gracefully. The main application loop should be wrapped in a `try-catch` to demonstrate class-wide handling of potential unexpected errors.
 * 9.  Implement input validation:
 *     *   Patient name should not be empty.
 *     *   Patient condition should be one of the allowed types ("Urgent", "Routine", "Consultation").
 *     *   Menu choice should be a valid integer corresponding to an option.
 * 10. Ensure meaningful variable and method names, and add appropriate comments/documentation (Javadoc where applicable).
 * 
 * **Expected Output Structure:**
 * 
 * The application should present a menu to the user, accept input, perform the requested action, and display results or errors.
 * 
 * ```
 * --- Clinic Patient Management ---
 * 1. Add Patient
 * 2. Process Next Patient
 * 3. View Waiting Queue
 * 4. View Processed Patients
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * *   Adding patient: Prompt for name and condition. Confirm addition or report validation error.
 * *   Processing patient: Report which patient was processed or report error if queue is empty.
 * *   Viewing queue/processed: Display list of patients or report that the list is empty.
 * *   Errors: Use `System.err.println()` for validation failures or operational errors (e.g., "Error: The waiting queue is empty.").
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Proper use of object-oriented principles (encapsulation, class design).
 * *   Effective input validation and error handling.
 * *   Clean, readable code with meaningful names and comments.
 * *   Correct logic for queue and list operations.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Healthcare Clinic Patient Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Patient` Class:**
 *     *   Represents a single patient with `id`, `name`, and `condition`.
 *     *   Fields are `private` for encapsulation.
 *     *   Provides public `getters` to access the data.
 *     *   Includes a `toString()` method for easy printing of patient details.
 * 
 * 2.  **`ClinicSystem` Class:**
 *     *   Acts as the core manager of the clinic data.
 *     *   Uses a `java.util.Queue<Patient>` (`waitingQueue`) implemented by `LinkedList` to store patients waiting to be seen. `Queue` ensures FIFO (First-In, First-Out) order, which is typical for a waiting line. `offer()` is used for adding and `poll()` for removing, which are standard Queue operations that handle capacity issues gracefully (though not strictly necessary with `LinkedList`).
 *     *   Uses a `java.util.List<Patient>` (`processedPatients`) implemented by `ArrayList` to store patients who have been processed. `List` allows ordered storage and retrieval of processed records.
 *     *   Uses `AtomicInteger` to generate unique, sequential patient IDs in a thread-safe manner (though in this single-threaded app, a simple `int` counter would also work, `AtomicInteger` is a good practice for ID generation).
 *     *   `ALLOWED_CONDITIONS` is a `static final List` to hold valid condition types, used for input validation.
 *     *   `addPatient()`: Validates the provided name and condition. If valid, it creates a new `Patient` object with a generated ID and adds it to the `waitingQueue`. It prints a success message to `System.out` or an error message to `System.err`.
 *     *   `processNextPatient()`: Checks if the `waitingQueue` is empty using `isEmpty()`. If not empty, it removes the patient at the head of the queue using `poll()`, adds them to the `processedPatients` list, and prints a success message to `System.out`. If the queue is empty, it prints an error message to `System.err`.
 *     *   `viewWaitingQueue()` and `viewProcessedPatients()`: Iterate through the respective collections (`Queue` and `List`) and print patient details. They check for emptiness and print an appropriate message if the collection is empty. `Queue` iteration is done without removing elements.
 * 
 * 3.  **`ClinicApp` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Creates instances of `ClinicSystem` and `Scanner`.
 *     *   The main application loop runs indefinitely (`while(running)`) until the user chooses to exit.
 *     *   A `try-catch (Exception e)` block wraps the entire `while` loop. This demonstrates class-wide exception handling, catching any unexpected runtime errors that might occur within the main execution flow and printing an error message and stack trace using `System.err`.
 *     *   Inside the loop, `printMenu()` displays the options using `System.out`.
 *     *   It reads the user's choice using `scanner.nextLine()` and attempts to parse it into an integer. A `try-catch (NumberFormatException e)` block specifically handles cases where the user enters non-numeric input for the menu choice, printing an error to `System.err` and using `continue` to restart the loop.
 *     *   A `switch` statement is used to direct the program flow based on the validated user choice, calling the appropriate methods of the `ClinicSystem` object.
 *     *   The `default` case in the `switch` handles invalid numeric choices, printing an error to `System.err`.
 *     *   Option 5 sets `running` to `false`, exiting the loop.
 *     *   A `finally` block ensures the `Scanner` is closed when the application exits, releasing system resources.
 * 
 * **Demonstration of Required Components:**
 * 
 * *   **`Queue`**: Used for `waitingQueue` to manage patients in FIFO order.
 * *   **`ArrayList`**: Used as the concrete implementation for the `processedPatients` `List`.
 * *   **`List` interface**: `processedPatients` is declared as `List<Patient>`, demonstrating programming to the interface.
 * *   **`Scanner`**: Used in `ClinicApp` to read user input from the console.
 * *   **`switch` statement**: Used in `ClinicApp` to handle different user menu selections.
 * *   **`System.err`**: Used for displaying all error messages (invalid input, empty queue/list operations, unexpected errors).
 * *   **`System.out`**: Used for displaying the menu, prompts, success messages, and list contents.
 * *   **`try-catch`**: Used for specific input validation (`NumberFormatException`) and wrapped around the main loop for broader exception handling.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** `Patient` and `ClinicSystem` fields are `private`.
 * *   **Meaningful Names:** Variable names (`waitingQueue`, `processedPatients`, `patientIdCounter`, `name`, `condition`, `choice`) and method names (`addPatient`, `processNextPatient`, `viewWaitingQueue`) are descriptive.
 * *   **Comments/Documentation:** Javadoc comments are used for classes and key methods, and inline comments explain specific logic.
 * *   **Input Validation:** Explicit checks are performed for empty name, invalid condition type, and non-numeric menu input.
 * *   **Error Handling:** Specific exceptions (`NumberFormatException`) are caught, and checks for empty collections are performed before attempting operations (`poll()`, iteration). `System.err` is consistently used for error output.
 * *   **Clean Code Structure:** The code is divided into logical classes (`Patient`, `ClinicSystem`, `ClinicApp`), and methods are kept relatively short and focused.
 * 
 * This solution effectively integrates all required components into a practical simulation, demonstrating understanding of core Java data structures, control flow, error handling, and object-oriented principles.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For unique patient ID

// Represents a patient in the system
class Patient {
    private int id;
    private String name;
    private String condition;

    // Constructor
    public Patient(int id, String name, String condition) {
        this.id = id;
        this.name = name;
        this.condition = condition;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCondition() {
        return condition;
    }

    // String representation for display
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name='" + name + "', Condition='" + condition + "']";
    }
}

// Manages the clinic's patient queue and processed records
class ClinicSystem {
    // Queue for patients waiting to be seen (FIFO)
    private Queue<Patient> waitingQueue;
    // List for patients who have been processed
    private List<Patient> processedPatients;
    // AtomicInteger to generate unique patient IDs safely
    private AtomicInteger patientIdCounter;

    // Allowed patient condition types
    private static final List<String> ALLOWED_CONDITIONS = List.of("Urgent", "Routine", "Consultation");

    // Constructor
    public ClinicSystem() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedPatients = new ArrayList<>(); // ArrayList implements List
        this.patientIdCounter = new AtomicInteger(1); // Start IDs from 1
    }

    /**
     * Adds a new patient to the waiting queue after validation.
     *
     * @param name      The name of the patient.
     * @param condition The medical condition type.
     * @return true if the patient was added successfully, false otherwise.
     */
    public boolean addPatient(String name, String condition) {
        // Validate input
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return false;
        }
        if (condition == null || !ALLOWED_CONDITIONS.contains(condition)) {
            System.err.println("Error: Invalid condition type. Allowed types are: " + ALLOWED_CONDITIONS);
            return false;
        }

        // Generate unique ID and create patient object
        int newId = patientIdCounter.getAndIncrement();
        Patient newPatient = new Patient(newId, name.trim(), condition);

        // Add patient to the waiting queue
        waitingQueue.offer(newPatient); // offer is preferred over add for queues (returns false on failure)
        System.out.println("Patient added to queue: " + newPatient);
        return true;
    }

    /**
     * Processes the next patient in the waiting queue.
     * Removes the patient from the queue and adds them to the processed list.
     *
     * @return The processed Patient object, or null if the queue was empty.
     */
    public Patient processNextPatient() {
        // Check if the queue is empty
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: The waiting queue is empty. No patients to process.");
            return null;
        }

        // Remove patient from the front of the queue
        Patient processedPatient = waitingQueue.poll(); // poll returns null if queue is empty (checked above)

        // Add the processed patient to the list
        processedPatients.add(processedPatient);

        System.out.println("Processed patient: " + processedPatient);
        return processedPatient;
    }

    /**
     * Displays all patients currently in the waiting queue.
     */
    public void viewWaitingQueue() {
        System.out.println("\n--- Current Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            waitingQueue.forEach(System.out::println);
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays all patients who have been processed.
     */
    public void viewProcessedPatients() {
        System.out.println("\n--- Processed Patients ---");
        if (processedPatients.isEmpty()) {
            System.out.println("No patients have been processed yet.");
        } else {
            // Iterate through the list
            processedPatients.forEach(System.out::println);
        }
        System.out.println("--------------------------");
    }

    /**
     * Checks if the waiting queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isWaitingQueueEmpty() {
        return waitingQueue.isEmpty();
    }
}

// Main application class
public class ClinicApp {

    public static void main(String[] args) {
        ClinicSystem clinic = new ClinicSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                try {
                    System.out.print("Enter your choice: ");
                    choice = Integer.parseInt(scanner.nextLine()); // Read full line to avoid issues with nextInt/nextLine mix
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Go back to the beginning of the loop
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1: // Add Patient
                        System.out.print("Enter patient name: ");
                        String name = scanner.nextLine();
                        System.out.print("Enter condition (Urgent, Routine, Consultation): ");
                        String condition = scanner.nextLine();
                        clinic.addPatient(name, condition); // addPatient handles its own validation errors
                        break;

                    case 2: // Process Next Patient
                        clinic.processNextPatient(); // processNextPatient handles its own empty queue error
                        break;

                    case 3: // View Waiting Queue
                        clinic.viewWaitingQueue();
                        break;

                    case 4: // View Processed Patients
                        clinic.viewProcessedPatients();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Clinic Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Clinic Patient Management ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Process Next Patient");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Processed Patients");
        System.out.println("5. Exit");
        System.out.println("---------------------------------");
    }
}
