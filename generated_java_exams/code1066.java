/*
 * Exam Question #1066
 * Generated on: 2025-05-12 17:20:13
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Queue Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Print Queue Management System. This system simulates a print server that handles print jobs submitted by users. The system should allow users to add new print jobs, process the next job in the queue, view the list of jobs waiting in the queue, and view the list of jobs that have been successfully completed.
 * 
 * The system must be interactive, using the console for input and output. It should be robust enough to handle basic user input errors and potential issues during job processing.
 * 
 * **Core Functionality Requirements:**
 * 
 * 1.  **Add Print Job:** Users should be able to submit a new print job by providing a file name. Each job should be assigned a unique ID and added to a queue of waiting jobs.
 * 2.  **Process Next Job:** The system should take the next available job from the front of the waiting queue, simulate its processing (e.g., changing its status), and move it to a list of completed jobs. If the queue is empty, an appropriate message should be displayed.
 * 3.  **View Waiting Queue:** Display the list of all jobs currently waiting to be processed in the order they were added.
 * 4.  **View Completed Jobs:** Display the list of all jobs that have been successfully processed.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must explicitly use the following Java components:
 * 
 * *   `java.util.Queue` for managing the waiting print jobs.
 * *   `java.util.ArrayList` for storing the completed print jobs.
 * *   `java.util.List` interface (e.g., when returning lists of jobs).
 * *   `java.util.Scanner` for reading user input from the console.
 * *   A `switch` statement to handle the main menu options.
 * *   `System.err` for outputting error messages (e.g., invalid input, queue empty during processing).
 * *   `System.out` for all normal output (menu, prompts, job details, success messages).
 * *   Class-wide exception handling using `try-catch` blocks to manage potential runtime issues, especially around user input and simulated processing errors.
 * 
 * **Design and Best Practices Requirements:**
 * 
 * *   Implement a class `PrintJob` to represent a single print job with private fields (e.g., ID, file name, status) and public getter methods.
 * *   Implement a class `PrintQueueManager` that encapsulates the `Queue` of waiting jobs and the `List` of completed jobs. It should have public methods for adding, processing, and viewing jobs.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments (Javadoc and inline) to explain the code.
 * *   Implement basic input validation (e.g., ensuring file name is not empty, menu choice is valid).
 * *   Handle the scenario where the queue is empty when trying to process a job.
 * *   Simulate a potential processing error for demonstration purposes (e.g., throw a custom exception randomly or based on a specific input) and handle it.
 * *   Ensure proper encapsulation by making fields private and providing public accessors where necessary.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the requested action and print relevant output to the console. Error messages should go to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: document.txt
 * Job added: [ID: 1, File: document.txt, Status: WAITING]
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: image.jpg
 * Job added: [ID: 2, File: image.jpg, Status: WAITING]
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting Queue ---
 * [ID: 1, File: document.txt, Status: WAITING]
 * [ID: 2, File: image.jpg, Status: WAITING]
 * ---------------------
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Processing job: [ID: 1, File: document.txt, Status: WAITING]
 * Job processed successfully: [ID: 1, File: document.txt, Status: COMPLETED]
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting Queue ---
 * [ID: 2, File: image.jpg, Status: WAITING]
 * ---------------------
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Jobs ---
 * [ID: 1, File: document.txt, Status: COMPLETED]
 * ----------------------
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Waiting Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 5
 * Exiting Print Queue Management.
 * ```
 * 
 * Consider how to handle potential errors like non-integer input for the menu choice or an empty file name. Implement a custom exception for the simulated processing error and demonstrate its handling.
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simplified Print Queue Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `PrintJob`: A simple POJO (Plain Old Java Object) representing a print job. It has `private` fields (`id`, `fileName`, `status`) and `public` getters, enforcing encapsulation. The `toString()` method provides a convenient string representation.
 *     *   `PrintQueueManager`: This class acts as the core logic handler. It contains a `Queue<PrintJob>` (`waitingQueue`) for jobs waiting to be processed and a `List<PrintJob>` (`completedJobs`) for jobs that have finished (successfully or failed). It encapsulates the state (`waitingQueue`, `completedJobs`, `nextJobId`) and provides public methods (`addJob`, `processNextJob`, `getWaitingJobs`, `getCompletedJobs`) to interact with the queue and list, hiding the internal implementation details.
 *     *   `PrintSystem` (main class): Contains the `main` method, which handles the user interaction loop, reads input using `Scanner`, and uses a `switch` statement to dispatch commands to the `PrintQueueManager`.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: `waitingQueue` is declared as `Queue<PrintJob>` and initialized with `LinkedList`. `offer()` is used to add jobs, and `poll()` is used to retrieve and remove the next job for processing.
 *     *   `ArrayList`: `completedJobs` is declared and initialized as `ArrayList<PrintJob>` to store jobs after processing.
 *     *   `List interface`: The methods `getWaitingJobs()` and `getCompletedJobs()` return `List<PrintJob>`. This is good practice as it allows the caller to work with the returned collection using the generic `List` interface, making the code more flexible if the underlying implementation (`ArrayList`) were to change later. `getWaitingJobs()` returns a *copy* (`new ArrayList<>(waitingQueue)`) to prevent external code from modifying the internal queue structure directly, maintaining encapsulation. `getCompletedJobs()` returns the internal list reference in this specific solution for simplicity, but returning a copy would be stricter encapsulation.
 *     *   `Scanner`: Used in the `main` method to read integer choices and string file names from `System.in`.
 *     *   `Switch statement`: Used in the `main` loop to select the action based on the user's menu choice.
 *     *   `System.err`: Used to print error messages, such as invalid menu input, empty queue when processing, `IllegalArgumentException` from `addJob`, and messages from the `ProcessingException`.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, and displaying job details.
 *     *   Class-wide `try-catch`: The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unexpected exceptions that might propagate up, preventing the program from crashing abruptly and printing the error details to `System.err`. Specific operations like reading integer input (`scanner.nextInt()`) and calling `manager.addJob()` or `manager.processNextJob()` also have their own more specific `try-catch` blocks to handle expected exceptions (`InputMismatchException`, `IllegalArgumentException`, `IllegalStateException`, `ProcessingException`) closer to where they occur.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** `PrintJob` fields are private. `PrintQueueManager` manages its internal collections (`waitingQueue`, `completedJobs`) via public methods.
 *     *   **Meaningful Names:** Class names (`PrintJob`, `PrintQueueManager`, `PrintSystem`), variable names (`waitingQueue`, `completedJobs`, `nextJobId`, `fileName`, `choice`), and method names (`addJob`, `processNextJob`, `getWaitingJobs`, `printMenu`) are descriptive.
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods. Inline comments explain specific implementation details (e.g., why `poll` is used, why a copy is returned).
 *     *   **Input Validation:** `addJob` checks for empty file names. The main loop checks for non-integer input using `InputMismatchException` and invalid menu numbers using the `default` case in the `switch`.
 *     *   **Error Handling:** Specific exceptions (`IllegalArgumentException`, `IllegalStateException`, `ProcessingException`, `InputMismatchException`) are caught and handled appropriately, often printing messages to `System.err`. A custom exception (`ProcessingException`) is introduced to simulate a specific application error.
 *     *   **Clean Code Structure:** Code is divided into logical classes. Methods are relatively small and focused on a single task. The `main` method orchestrates the user interaction but delegates the core business logic to `PrintQueueManager`. The `finally` block in `main` ensures the `Scanner` is closed.
 * 
 * This solution effectively demonstrates the required Java components within a practical scenario, adhering to good object-oriented design principles and robust error handling practices suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for simulating processing errors
class ProcessingException extends Exception {
    public ProcessingException(String message) {
        super(message);
    }
}

// Represents a single print job
class PrintJob {
    private int id;
    private String fileName;
    private String status; // e.g., WAITING, PROCESSING, COMPLETED, FAILED

    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
        this.status = "WAITING"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (for status change) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", File: " + fileName + ", Status: " + status + "]";
    }
}

// Manages the print queue and completed jobs
class PrintQueueManager {
    private Queue<PrintJob> waitingQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId;

    public PrintQueueManager() {
        // Use LinkedList as a Queue implementation
        this.waitingQueue = new LinkedList<>();
        // Use ArrayList to store completed jobs
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the waiting queue.
     *
     * @param fileName The name of the file to print.
     * @return The PrintJob object that was added.
     * @throws IllegalArgumentException if the file name is null or empty.
     */
    public PrintJob addJob(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be empty.");
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim());
        waitingQueue.offer(newJob); // offer is preferred over add in queues
        return newJob;
    }

    /**
     * Processes the next job in the waiting queue.
     *
     * @throws ProcessingException if an error occurs during simulated processing.
     * @throws IllegalStateException if the waiting queue is empty.
     */
    public void processNextJob() throws ProcessingException, IllegalStateException {
        // poll retrieves and removes the head of the queue, returns null if empty
        PrintJob jobToProcess = waitingQueue.poll();

        if (jobToProcess == null) {
            throw new IllegalStateException("The waiting queue is empty. No jobs to process.");
        }

        System.out.println("Processing job: " + jobToProcess);

        // Simulate processing - could potentially fail
        try {
            simulateProcessing(jobToProcess);
            jobToProcess.setStatus("COMPLETED");
            System.out.println("Job processed successfully: " + jobToProcess);
        } catch (ProcessingException e) {
            jobToProcess.setStatus("FAILED"); // Mark as failed on error
            System.err.println("Error processing job " + jobToProcess.getId() + ": " + e.getMessage());
            throw e; // Re-throw the exception after updating status and logging
        } finally {
            // Always add the job (either completed or failed) to the completed list
            completedJobs.add(jobToProcess);
        }
    }

    /**
     * Simulates the print job processing with a chance of failure.
     * (For demonstration purposes)
     *
     * @param job The job being processed.
     * @throws ProcessingException if the simulation fails.
     */
    private void simulateProcessing(PrintJob job) throws ProcessingException {
        // Simulate a failure condition, e.g., if file name contains "error"
        if (job.getFileName().toLowerCase().contains("error")) {
            throw new ProcessingException("Simulated processing error for file: " + job.getFileName());
        }
        // Simulate some work...
        try {
            Thread.sleep(100); // Simulate processing time
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // Restore interrupted status
            throw new ProcessingException("Processing interrupted");
        }
        // Success if no exception thrown
    }


    /**
     * Returns a list of jobs currently waiting in the queue.
     * Note: Returns a new ArrayList copy to prevent external modification of the queue.
     *
     * @return A List of PrintJob objects in the waiting queue.
     */
    public List<PrintJob> getWaitingJobs() {
        // Return a copy to maintain encapsulation of the internal queue structure
        return new ArrayList<>(waitingQueue);
    }

    /**
     * Returns a list of jobs that have been processed (completed or failed).
     *
     * @return A List of PrintJob objects that are completed.
     */
    public List<PrintJob> getCompletedJobs() {
        // Return the internal list directly (or a copy if stricter encapsulation needed)
        return completedJobs;
    }

    /**
     * Checks if the waiting queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return waitingQueue.isEmpty();
    }
}

// Main class to run the Print Queue Management System
public class PrintSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager manager = new PrintQueueManager();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        try {
                            PrintJob addedJob = manager.addJob(fileName);
                            System.out.println("Job added: " + addedJob);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding job: " + e.getMessage());
                        }
                        break;
                    case 2:
                        try {
                            manager.processNextJob();
                        } catch (IllegalStateException e) {
                            System.err.println("Error processing job: " + e.getMessage());
                        } catch (ProcessingException e) {
                            // ProcessingException is already logged in processNextJob,
                            // but we catch it here to prevent loop termination
                            // or add further main-level handling if needed.
                            // System.err.println("Processing failed for a job."); // Optional: additional message
                        }
                        break;
                    case 3:
                        List<PrintJob> waiting = manager.getWaitingJobs();
                        System.out.println("--- Waiting Queue ---");
                        if (waiting.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            for (PrintJob job : waiting) {
                                System.out.println(job);
                            }
                        }
                        System.out.println("---------------------");
                        break;
                    case 4:
                        List<PrintJob> completed = manager.getCompletedJobs();
                        System.out.println("--- Completed Jobs ---");
                        if (completed.isEmpty()) {
                            System.out.println("No jobs completed yet.");
                        } else {
                            for (PrintJob job : completed) {
                                System.out.println(job);
                            }
                        }
                        System.out.println("----------------------");
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Print Queue Management.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better formatting
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions not handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Print Queue Management ---");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
