/*
 * Exam Question #640
 * Generated on: 2025-05-12 16:18:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Technical Support Queue Management System. Customers submit support tickets which are placed in a queue for processing. A single "agent" (simulated by the system) can pick up the next ticket from the queue to work on it. Once the agent finishes working on a ticket, they resolve it, and the ticket is moved to a history log. The system interacts with a user (acting as a supervisor or the agent) via a command-line interface.
 * 
 * **Your Task:**
 * 
 * Implement this system in Java, adhering to the requirements below.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Components:** Your solution must use ALL of the following Java components:
 *     *   `java.util.Queue` (for the pending tickets)
 *     *   `java.util.ArrayList` (for the resolved ticket history)
 *     *   `java.util.List` interface (used appropriately, e.g., for method return types)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling user commands)
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing normal output, menus, success messages, and list contents)
 *     *   Class-wide exception handling with `try-catch` blocks (e.g., wrapping the main command loop and handling input issues).
 * 
 * 2.  **Ticket Representation:** Create a `Ticket` class with the following:
 *     *   Private fields: an auto-generated unique integer ID, a String description, a status (e.g., PENDING, ACTIVE, RESOLVED), and a String for resolution details (only applicable when resolved).
 *     *   A constructor to create new tickets with a description. IDs should be sequentially generated starting from 1.
 *     *   Public getter methods for its fields.
 *     *   Methods to update its status (e.g., `activate()`, `resolve(String resolutionDetails)`).
 *     *   An appropriate `toString()` method for displaying ticket information.
 * 
 * 3.  **Support System Logic:** Create a `SupportSystem` class responsible for managing the tickets:
 *     *   Private fields: a `Queue` for pending tickets, a `List` for resolved tickets, and a field to hold the single `Ticket` currently being worked on (or `null` if none).
 *     *   Public methods:
 *         *   `addTicket(String description)`: Creates a new `Ticket` and adds it to the pending queue. Should validate that the description is not empty.
 *         *   `pickupNextTicket()`: Removes the next ticket from the pending queue, sets its status to ACTIVE, and makes it the current active ticket. Returns the picked-up ticket or indicates failure (e.g., returns `null` or throws) if the queue is empty or an agent is already active.
 *         *   `resolveActiveTicket(String resolutionDetails)`: Sets the status of the current active ticket to RESOLVED, adds it to the resolved history list, and clears the active ticket slot. Returns the resolved ticket or indicates failure if there is no active ticket or resolution details are empty.
 *         *   `viewPendingQueue()`: Returns a `List` view of the tickets currently in the pending queue (without removing them).
 *         *   `viewResolvedHistory()`: Returns the `List` of resolved tickets.
 *         *   `getActiveTicket()`: Returns the currently active ticket, or `null` if none.
 * 
 * 4.  **Command-Line Interface:** Create a main class (e.g., `SupportSystemApp`) with a `main` method that:
 *     *   Uses a `Scanner` to read user input in a loop.
 *     *   Presents a menu of options to the user.
 *     *   Uses a `switch` statement to process user commands.
 *     *   The available commands should be:
 *         *   `1`: Add new ticket (prompts for description).
 *         *   `2`: Pick up next ticket.
 *         *   `3`: Resolve active ticket (prompts for resolution details).
 *         *   `4`: View pending queue.
 *         *   `5`: View resolved history.
 *         *   `6`: View active ticket.
 *         *   `0`: Exit the program.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Handle invalid user input for menu choices (non-numeric or out of range) using `try-catch` and `System.err`.
 *     *   Handle business logic errors (e.g., trying to pick up from an empty queue, trying to resolve when no ticket is active, adding ticket with empty description, resolving with empty details) by printing informative messages to `System.err`.
 *     *   Implement a general `try-catch` block around the main command loop to catch any unexpected exceptions.
 * 
 * 6.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments.
 *     *   Structure your code clearly into classes.
 * 
 * **Expected Output:**
 * 
 * *   The system should print a menu of options.
 * *   Upon selecting an option, it should perform the action and print success messages or lists of tickets to `System.out`.
 * *   If an error occurs (invalid input, empty queue, etc.), an error message should be printed to `System.err`.
 * *   Viewing the queue or history should list tickets with their relevant details.
 * *   Exiting the program should print a goodbye message.
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `Technical Support Queue Management System` using the required Java components and best practices.
 * 
 * 1.  **`TicketStatus` Enum:** A simple enum defines the possible states of a ticket, providing clarity and type safety over using raw strings or integers for status.
 * 
 * 2.  **`Ticket` Class:**
 *     *   Encapsulates ticket data (`id`, `description`, `status`, `resolutionDetails`).
 *     *   Uses a `static int nextId` to ensure each ticket gets a unique, sequential ID upon creation.
 *     *   The constructor initializes a ticket to `PENDING` status.
 *     *   `activate()` and `resolve()` methods manage the state transitions of the ticket based on the system's workflow.
 *     *   `toString()` provides a convenient way to display ticket information.
 * 
 * 3.  **`SupportSystem` Class:**
 *     *   Manages the core state of the system: the `pendingTickets` `Queue`, the `resolvedTickets` `List`, and the single `activeTicket`.
 *     *   `pendingTickets` is implemented using `LinkedList`, which is a common choice for implementing the `Queue` interface due to efficient additions/removals from ends.
 *     *   `resolvedTickets` is implemented using `ArrayList`, suitable for storing a dynamic list of resolved items.
 *     *   `addTicket()` demonstrates adding an element to the `Queue` using `offer()` and includes basic input validation for the description.
 *     *   `pickupNextTicket()` demonstrates removing an element from the `Queue` using `poll()`, handling the case where the queue is empty (`poll()` returns `null`). It also manages the `activeTicket` state and validates if a ticket is already active.
 *     *   `resolveActiveTicket()` demonstrates adding an element to the `List` using `add()` and manages the `activeTicket` state. It includes validation for resolution details.
 *     *   `viewPendingQueue()` and `viewResolvedHistory()` return `List` objects. `viewPendingQueue()` returns a *copy* (`new ArrayList<>(pendingTickets)`) to prevent external code from modifying the internal queue structure, demonstrating good practice. `viewResolvedHistory()` returns the direct list reference, which is acceptable for this specific problem's requirements.
 *     *   `getActiveTicket()` provides access to the current active ticket.
 *     *   All fields are `private` and accessed via `public` methods, demonstrating encapsulation.
 * 
 * 4.  **`SupportSystemApp` Class:**
 *     *   Contains the `main` method, serving as the entry point and the command-line interface handler.
 *     *   Uses `Scanner` to read user input for menu choices, descriptions, and resolution details.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement effectively directs program flow based on the user's numeric input, mapping choices to `SupportSystem` methods.
 *     *   **Exception Handling:**
 *         *   An inner `try-catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   `try-catch (IllegalArgumentException e)` blocks wrap calls to `addTicket` and `resolveActiveTicket` to catch and report validation errors (like empty description/resolution) to `System.err`.
 *         *   A `try-catch (IllegalStateException e)` block wraps the call to `pickupNextTicket` to catch the error if an agent is already active.
 *         *   A broad `try-catch (Exception e)` block wraps the entire main `while` loop. This serves as the "class-wide" handler, catching any unexpected exceptions that might occur during the program's execution and printing an error to `System.err` along with a stack trace for debugging.
 *         *   A `finally` block ensures the `Scanner` resource is closed regardless of whether an exception occurred.
 *     *   `System.out` is used for printing the menu, success messages, and the contents of the queue and history lists.
 *     *   `System.err` is strictly used for printing error messages related to invalid input or failed operations.
 *     *   The `printMenu()` method is a helper to display the available options clearly.
 * 
 * This solution effectively combines the required data structures (`Queue`, `ArrayList`, `List`), control flow (`switch`), input/output (`Scanner`, `System.out`, `System.err`), object-oriented principles (encapsulation, classes), and robust error handling (`try-catch`) to create a functional and well-structured application simulating a real-world scenario.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a support ticket
enum TicketStatus {
    PENDING, ACTIVE, RESOLVED
}

// Represents a single support ticket
class Ticket {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private TicketStatus status;
    private String resolutionDetails; // Details added when ticket is resolved

    /**
     * Constructs a new Ticket with a description.
     * ID is automatically assigned.
     *
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = TicketStatus.PENDING;
        this.resolutionDetails = null;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    public String getResolutionDetails() {
        return resolutionDetails;
    }

    // --- Status Update Methods ---

    /**
     * Changes the ticket status from PENDING to ACTIVE.
     */
    public void activate() {
        if (this.status == TicketStatus.PENDING) {
            this.status = TicketStatus.ACTIVE;
        }
    }

    /**
     * Changes the ticket status from ACTIVE to RESOLVED and sets resolution details.
     *
     * @param resolutionDetails The details of how the ticket was resolved.
     */
    public void resolve(String resolutionDetails) {
        if (this.status == TicketStatus.ACTIVE) {
            this.status = TicketStatus.RESOLVED;
            this.resolutionDetails = resolutionDetails;
        }
    }

    /**
     * Provides a string representation of the ticket.
     *
     * @return String representation including ID, description, status, and resolution (if resolved).
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ID: ").append(id)
          .append(", Desc: '").append(description).append("'")
          .append(", Status: ").append(status);
        if (status == TicketStatus.RESOLVED && resolutionDetails != null) {
            sb.append(", Resolution: '").append(resolutionDetails).append("'");
        }
        return sb.toString();
    }
}

// Manages the queue of pending tickets, active ticket, and resolved history.
class SupportSystem {
    private Queue<Ticket> pendingTickets; // Queue for tickets awaiting processing
    private List<Ticket> resolvedTickets; // List for tickets that have been resolved
    private Ticket activeTicket;          // The single ticket currently being worked on

    /**
     * Constructs a new SupportSystem, initializing the data structures.
     */
    public SupportSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.resolvedTickets = new ArrayList<>(); // ArrayList for dynamic history list
        this.activeTicket = null; // No ticket is active initially
    }

    /**
     * Creates a new ticket and adds it to the pending queue.
     *
     * @param description The description for the new ticket.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(description.trim());
        pendingTickets.offer(newTicket); // offer is the preferred way to add to a Queue
        System.out.println("System: Ticket #" + newTicket.getId() + " added to the queue.");
    }

    /**
     * Retrieves the next ticket from the pending queue, sets it as active.
     *
     * @return The ticket that was picked up, or null if the queue was empty.
     * @throws IllegalStateException if there is already an active ticket.
     */
    public Ticket pickupNextTicket() {
        if (activeTicket != null) {
            // This state should ideally be managed by the caller (SupportSystemApp),
            // but throwing here enforces the rule that only one ticket can be active.
             throw new IllegalStateException("An agent is already working on a ticket.");
        }

        Ticket nextTicket = pendingTickets.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTicket != null) {
            nextTicket.activate();
            activeTicket = nextTicket;
            System.out.println("System: Agent picked up ticket #" + activeTicket.getId() + ".");
        }
        return activeTicket; // Returns null if queue was empty
    }

    /**
     * Resolves the current active ticket and moves it to the resolved history.
     *
     * @param resolutionDetails The details of the resolution.
     * @return The ticket that was resolved, or null if there was no active ticket.
     * @throws IllegalArgumentException if resolution details are null or empty.
     */
    public Ticket resolveActiveTicket(String resolutionDetails) {
        if (activeTicket == null) {
            return null; // No active ticket to resolve
        }
         if (resolutionDetails == null || resolutionDetails.trim().isEmpty()) {
             throw new IllegalArgumentException("Resolution details cannot be empty.");
        }

        activeTicket.resolve(resolutionDetails.trim());
        resolvedTickets.add(activeTicket); // Add to the history list
        System.out.println("System: Ticket #" + activeTicket.getId() + " resolved.");
        Ticket resolved = activeTicket; // Store the resolved ticket before clearing
        activeTicket = null; // Clear the active ticket slot
        return resolved;
    }

    /**
     * Returns a list of tickets currently in the pending queue without removing them.
     *
     * @return A List containing the pending tickets.
     */
    public List<Ticket> viewPendingQueue() {
        // Return a new ArrayList containing elements from the Queue
        // This avoids exposing the internal Queue implementation directly and prevents modification
        return new ArrayList<>(pendingTickets);
    }

    /**
     * Returns the list of tickets that have been resolved.
     *
     * @return A List containing the resolved tickets history.
     */
    public List<Ticket> viewResolvedHistory() {
        // Returning the direct list reference is acceptable for this problem,
        // assuming history modifications only happen via resolveActiveTicket.
        // For higher robustness, a copy could be returned.
        return resolvedTickets;
    }

    /**
     * Returns the ticket currently being worked on.
     *
     * @return The active ticket, or null if none.
     */
    public Ticket getActiveTicket() {
        return activeTicket;
    }
}

// Main application class with the command-line interface
public class SupportSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem();
        boolean running = true;

        System.out.println("--- Technical Support Queue Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                // Inner try-catch for handling non-integer input specifically
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Using a switch statement for command handling
                    switch (choice) {
                        case 1: // Add Ticket
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            try {
                                system.addTicket(description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding ticket: " + e.getMessage());
                            }
                            break;

                        case 2: // Pick up next ticket
                            try {
                                Ticket pickedUp = system.pickupNextTicket();
                                if (pickedUp == null) {
                                    System.err.println("Error: The pending queue is empty. No ticket to pick up.");
                                }
                                // Success message is printed inside SupportSystem method
                            } catch (IllegalStateException e) {
                                System.err.println("Error picking up ticket: " + e.getMessage());
                            }
                            break;

                        case 3: // Resolve active ticket
                            Ticket activeForResolve = system.getActiveTicket();
                            if (activeForResolve == null) {
                                System.err.println("Error: No active ticket to resolve.");
                            } else {
                                System.out.print("Enter resolution details for ticket #" + activeForResolve.getId() + ": ");
                                String resolutionDetails = scanner.nextLine();
                                try {
                                    system.resolveActiveTicket(resolutionDetails);
                                } catch (IllegalArgumentException e) {
                                     System.err.println("Error resolving ticket: " + e.getMessage());
                                }
                                // Success message is printed inside SupportSystem method
                            }
                            break;

                        case 4: // View pending queue
                            List<Ticket> pending = system.viewPendingQueue();
                            System.out.println("\n--- Pending Tickets ---");
                            if (pending.isEmpty()) {
                                System.out.println("The pending queue is empty.");
                            } else {
                                // Iterate through the List returned from viewPendingQueue
                                for (Ticket ticket : pending) {
                                    System.out.println(ticket);
                                }
                            }
                            System.out.println("-----------------------");
                            break;

                        case 5: // View resolved history
                            List<Ticket> resolved = system.viewResolvedHistory();
                            System.out.println("\n--- Resolved Tickets History ---");
                            if (resolved.isEmpty()) {
                                System.out.println("The resolved history is empty.");
                            } else {
                                // Iterate through the List returned from viewResolvedHistory
                                for (Ticket ticket : resolved) {
                                    System.out.println(ticket);
                                }
                            }
                            System.out.println("------------------------------");
                            break;

                         case 6: // View active ticket
                            Ticket active = system.getActiveTicket();
                            System.out.println("\n--- Active Ticket ---");
                            if (active == null) {
                                System.out.println("No active ticket.");
                            } else {
                                System.out.println(active);
                            }
                             System.out.println("---------------------");
                            break;

                        case 0: // Exit
                            running = false;
                            System.out.println("Exiting system. Goodbye!");
                            break;

                        default:
                            System.err.println("Invalid choice. Please enter a number between 0 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // Catching non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                }
                System.out.println(); // Add a blank line for readability after each command
            }
        } catch (Exception e) {
            // General catch block for any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner is closed when the application finishes or crashes
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Select an action:");
        System.out.println("1. Add new ticket");
        System.out.println("2. Pick up next ticket");
        System.out.println("3. Resolve active ticket");
        System.out.println("4. View pending queue");
        System.out.println("5. View resolved history");
        System.out.println("6. View active ticket");
        System.out.println("0. Exit");
    }
}
