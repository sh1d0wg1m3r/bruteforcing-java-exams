/*
 * Exam Question #567
 * Generated on: 2025-05-11 23:30:26
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple, yet robust, Task Processing System. This system will manage a queue of tasks waiting to be processed and maintain a list of tasks that have been completed. The system should interact with the user via the console, allowing them to add new tasks, process the next available task, view the status of all tasks, and exit the application.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer `id`, a `String` `description`, and a boolean `isCompleted` flag. Include a constructor, getter methods for all fields, and a method `markCompleted()` that sets the `isCompleted` flag to `true`. Override the `toString()` method to provide a user-friendly representation of the task (e.g., "Task [ID]: [Description] - [Status]").
 * 2.  **System Management:** Create a `TaskProcessingSystem` class that manages the tasks.
 *     *   It must internally use a `java.util.Queue<Task>` to hold tasks that are pending processing.
 *     *   It must internally use a `java.util.ArrayList<Task>` to hold tasks that have been completed. Declare the variable using the `java.util.List` interface type (`List<Task> completedTasks`).
 *     *   Include a method `addTask(String description)` that creates a new `Task` object with a unique ID (starting from 1) and adds it to the pending queue.
 *     *   Include a method `processNextTask()` that retrieves the task from the front of the pending queue, marks it as completed, and moves it to the completed list. If the pending queue is empty, it should handle this gracefully and inform the user using `System.err`.
 *     *   Include a method `listAllTasks()` that prints all tasks currently in the pending queue and all tasks in the completed list. Clearly label each section.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in a `main` method or a separate `run` method within the `TaskProcessingSystem` class. The interface should present the following options to the user:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. List All Tasks
 *     *   4. Exit
 * 4.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 5.  **Input Validation & Error Handling:**
 *     *   Handle cases where the user enters non-integer input for the menu choice using a `try-catch` block. Print an error message to `System.err`.
 *     *   Handle cases where the pending queue is empty when the user attempts to process a task (as specified in requirement 2), printing an error message to `System.err`.
 *     *   Ensure that the task description is not empty when adding a task. Print an error to `System.err` if it is.
 *     *   Implement a `try-catch` block around the main interaction loop to catch potential exceptions during input or processing, printing a general error message to `System.err`.
 *     *   Use `System.out` for all normal output (menu, task listings, success messages). Use `System.err` for all error messages.
 * 6.  **Best Practices:**
 *     *   Use appropriate access modifiers (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments or Javadoc where necessary to explain complex parts.
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. Exit
 * Enter your choice: [User Input]
 * 
 * // Depending on choice:
 * // If Add Task:
 * Enter task description: [User Input]
 * Task added: Task [ID]: [Description] - Pending
 * 
 * // If Process Task:
 * Task processed: Task [ID]: [Description] - Completed
 * // OR (if queue empty):
 * Error: No pending tasks to process.
 * 
 * // If List Tasks:
 * --- Pending Tasks ---
 * Task [ID]: [Description] - Pending
 * ...
 * --- Completed Tasks ---
 * Task [ID]: [Description] - Completed
 * ...
 * // OR (if lists are empty):
 * --- Pending Tasks ---
 * No pending tasks.
 * --- Completed Tasks ---
 * No completed tasks.
 * 
 * // If Invalid Choice:
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * // If Non-integer Input:
 * Error: Invalid input. Please enter a number.
 * 
 * // If Empty Description:
 * Error: Task description cannot be empty.
 * 
 * // If Exit:
 * Exiting Task Processing System.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Correct implementation of the `Task` and `TaskProcessingSystem` classes.
 * *   Effective use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Robust exception handling and input validation using `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Overall code clarity and correctness.
 * 
 * This task requires you to integrate multiple core Java concepts into a single, functional application. Good luck!
 *
 * EXPLANATION:
 * This solution implements a `TaskProcessingSystem` that manages tasks using a queue for pending items and a list for completed ones, fulfilling all the requirements of the exam question.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents individual tasks with `id`, `description`, and `isCompleted` status.
 *     *   Uses private fields and public getters for encapsulation.
 *     *   The constructor validates the description, throwing an `IllegalArgumentException` if it's empty or null, demonstrating input validation at the object level.
 *     *   `markCompleted()` is a simple state-changing method.
 *     *   `toString()` provides a clear representation for output.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for a processing queue.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This demonstrates programming to the interface (`List`) while using a concrete implementation (`ArrayList`) to store the completed tasks.
 *     *   **`addTask(String description)`:**
 *         *   Generates a unique ID using `nextTaskId++`.
 *         *   Creates a new `Task` object. The `Task` constructor handles the description validation.
 *         *   Uses `pendingTasks.offer(newTask)` to add the task to the end of the queue. `offer` is generally safer than `add` for capacity-constrained queues, although `LinkedList` is not capacity-constrained.
 *         *   Prints a success message using `System.out`.
 *     *   **`processNextTask()`:**
 *         *   Checks if the `pendingTasks` queue is empty. If so, it prints an error to `System.err` and returns, handling the empty queue scenario gracefully.
 *         *   Uses `pendingTasks.poll()` to retrieve and remove the task at the head of the queue (the next one to be processed).
 *         *   If a task is successfully retrieved, it calls `markCompleted()` on the task and adds it to the `completedTasks` list using `completedTasks.add()`.
 *         *   Prints a success message using `System.out`.
 *     *   **`listAllTasks()`:**
 *         *   Iterates through both the `pendingTasks` queue and the `completedTasks` list.
 *         *   Prints clear headers for each section.
 *         *   Uses `System.out` for all output.
 *         *   Handles cases where either collection is empty.
 * 
 * 3.  **User Interface and Control Flow (`run()` method):**
 *     *   **`Scanner`:** A `Scanner` object is used to read user input from `System.in`. The `try-with-resources` block ensures the `Scanner` is automatically closed when the block is exited, preventing resource leaks.
 *     *   **Main Loop & `try-catch`:** The core logic runs inside a `while` loop that continues until the user chooses option 4 (Exit). This loop is wrapped in a `try-catch` block (`catch (Exception e)`) which serves as the "class-wide" or top-level exception handler for the interactive session, catching any unexpected runtime errors.
 *     *   **Input Handling `try-catch`:** Inside the loop, another `try-catch` block specifically handles `InputMismatchException` which occurs if the user enters non-integer input when an integer is expected (`scanner.nextInt()`). This block catches the error, prints an informative message to `System.err`, consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop, and resets the choice variable.
 *     *   **`switch` Statement:** A `switch` statement is used to direct the program flow based on the valid integer input (`choice`). Each `case` corresponds to a menu option, calling the appropriate method (`addTask`, `processNextTask`, `listAllTasks`) or handling the exit condition. The `default` case handles valid integer inputs that are not between 1 and 4, printing an error to `System.err`.
 *     *   **Input Validation (Description):** When adding a task (case 1), the description is read, and the `addTask` method is called. The `addTask` method itself calls the `Task` constructor, which contains the validation logic for the description. If the description is empty, the `IllegalArgumentException` thrown by the `Task` constructor is caught in the `run` method's inner `try-catch`, and an error message is printed to `System.err`.
 *     *   **`System.out` vs. `System.err`:** `System.out.println` is used for all successful operations, menu display, and task listings. `System.err.println` is used exclusively for printing error messages (invalid choice, empty queue, invalid input type, empty description, unexpected errors).
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskProcessingSystem` are `private`, and access is provided via public methods.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `listAllTasks`).
 *     *   **Comments/Documentation:** Javadoc comments are included for classes and key methods explaining their purpose and parameters/return values. Inline comments clarify specific points (like using `LinkedList` for `Queue`).
 *     *   **Input Validation & Error Handling:** Implemented as described above, covering various error scenarios.
 *     *   **Clean Code:** The code is structured into logical classes and methods, follows standard Java formatting, and uses features like `try-with-resources` for resource management.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, application, demonstrating advanced understanding of how these components work together with proper error handling and best practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.isCompleted = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string showing task details and status.
     */
    @Override
    public String toString() {
        return "Task " + id + ": " + description + " - " + (isCompleted ? "Completed" : "Pending");
    }
}

// Manages the collection and processing of tasks
public class TaskProcessingSystem {
    // Using LinkedList as a Queue implementation
    private Queue<Task> pendingTasks;
    // Using ArrayList as a List implementation
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queues and lists.
     */
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Task IDs start from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description for the new task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues (returns false instead of throwing exception)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list upon successful processing.
     * Prints an error if the queue is empty.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        if (taskToProcess != null) {
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task processed: " + taskToProcess);
        }
    }

    /**
     * Lists all tasks, separating pending and completed tasks.
     */
    public void listAllTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating over the queue
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }

        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterating over the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println(); // Add a newline for better formatting
    }

    /**
     * Runs the main interactive loop for the Task Processing System.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;

            // Class-wide exception handling for the main loop
            try {
                while (choice != 4) {
                    printMenu();

                    System.out.print("Enter your choice: ");
                    try {
                        choice = scanner.nextInt();
                        scanner.nextLine(); // Consume newline character

                        switch (choice) {
                            case 1:
                                System.out.print("Enter task description: ");
                                String description = scanner.nextLine();
                                try {
                                    addTask(description);
                                } catch (IllegalArgumentException e) {
                                    System.err.println("Error: " + e.getMessage());
                                }
                                break;
                            case 2:
                                processNextTask();
                                break;
                            case 3:
                                listAllTasks();
                                break;
                            case 4:
                                System.out.println("Exiting Task Processing System.");
                                break;
                            default:
                                System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        }
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        choice = -1; // Reset choice to continue loop
                    }
                    System.out.println(); // Add a newline after each operation
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the main loop execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }

        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
