/*
 * Exam Question #1126
 * Generated on: 2025-05-12 17:28:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Priority Task Dispatcher System
 * 
 * **Scenario:** You are tasked with developing a simplified task dispatcher system for a small service. The system should allow users to add new tasks with a description and priority, process the next available task, and view lists of pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a task. Each task should have:
 *     *   A unique integer ID (automatically generated).
 *     *   A String description.
 *     *   An integer priority (lower number indicates higher priority, e.g., 1 is highest).
 *     *   A status (e.g., PENDING, COMPLETED). Use an `enum` for status.
 *     *   Appropriate private fields and public getter methods.
 *     *   A meaningful `toString()` method for displaying task details.
 * 
 * 2.  **Task Dispatcher Logic:** Create a class `TaskDispatcher` to manage the tasks. This class should:
 *     *   Maintain a collection of tasks that are waiting to be processed. This collection **must** be a `java.util.Queue`.
 *     *   Maintain a collection of tasks that have been completed. This collection **must** be a `java.util.ArrayList`.
 *     *   Provide a method `addTask(String description, int priority)`: Adds a new task to the pending queue. Validate input: description cannot be empty, priority must be a positive integer. Use `System.err` for invalid input messages.
 *     *   Provide a method `processNextTask()`: Retrieves and processes the next task from the pending queue. If the queue is empty, print an error message to `System.err`. If a task is processed, move it to the completed tasks list and print a success message to `System.out`.
 *     *   Provide a method `getPendingTasks()`: Returns a `java.util.List` of currently pending tasks.
 *     *   Provide a method `getCompletedTasks()`: Returns a `java.util.List` of currently completed tasks.
 *     *   Implement proper encapsulation (private fields, public methods).
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `TaskManagementApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`. The interface should present a menu with options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 
 * 4.  **Control Flow & Output:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and successful operations.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation as described in Requirement 2.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch potential unexpected errors during user interaction or processing, printing the error details to `System.err`.
 * 
 * 6.  **Required Components:** Your solution **must** explicitly use *all* of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   Class-wide `try-catch` blocks
 * 
 * 7.  **Best Practices:** Adhere to best practices including meaningful names, comments, and clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting integer choices, and performing actions based on the choice. Output should clearly distinguish between normal information (`System.out`) and errors (`System.err`). Task lists should display relevant details (ID, Description, Priority, Status).
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter task priority (1=high): 5
 * Task added: Task ID 1 - Write report (Priority: 5) - PENDING
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix bug
 * Enter task priority (1=high): 1
 * Task added: Task ID 2 - Fix bug (Priority: 1) - PENDING
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID 1 - Write report (Priority: 5) - PENDING
 * Task ID 2 - Fix bug (Priority: 1) - PENDING
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID 1 - Write report (Priority: 5) - PENDING
 * Task ID 1 completed.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID 2 - Fix bug (Priority: 1) - PENDING
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task ID 1 - Write report (Priority: 5) - COMPLETED
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID 2 - Fix bug (Priority: 1) - PENDING
 * Task ID 2 completed.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks currently pending.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: exit  <-- Assuming user enters non-integer
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Dispatcher.
 * ```
 * 
 * *(Note: The standard `Queue` implementation like `LinkedList` processes tasks in FIFO order based on insertion, not priority. The priority is stored but not used for queue ordering in this basic setup, fulfilling the `Queue` requirement directly. A `PriorityQueue` would order by priority but is not the explicit requirement here).*
 *
 * EXPLANATION:
 * This solution implements a simple task dispatcher system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   Represents a single task with an auto-generated ID, description, priority, and status.
 *     *   Uses an `enum` (`TaskStatus`) for clear status representation.
 *     *   Uses a `static` variable (`nextTaskId`) to ensure unique IDs are generated for each new `Task` instance.
 *     *   Includes a `toString()` method for easy printing of task details.
 *     *   Fields are `private` and accessed via `public` getters and a setter for status, adhering to encapsulation.
 * 
 * 2.  **TaskDispatcher Class:**
 *     *   Manages the collections of tasks.
 *     *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior needed here. The `offer()` method is used for adding tasks, which is standard for `Queue`. The `poll()` method is used for retrieving and removing the head of the queue, handling the empty case gracefully by returning `null`.
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is a concrete implementation of the `List` interface used here to store completed tasks.
 *     *   `addTask()`: Validates the description and priority before creating and adding the task to the `pendingTasks` queue. Uses `System.err` for validation errors and `System.out` for successful additions.
 *     *   `processNextTask()`: Retrieves the next task using `pendingTasks.poll()`. Checks if the result is `null` (queue was empty) and prints an error to `System.err`. If a task is retrieved, it simulates processing (with a small `Thread.sleep` for realism), sets the status to `COMPLETED`, and adds it to the `completedTasks` `ArrayList`. Prints success messages to `System.out`.
 *     *   `getPendingTasks()`: Returns a `List<Task>`. It returns a *new* `ArrayList` containing the elements from the `pendingTasks` queue. This prevents external code from directly modifying the internal `Queue` structure, maintaining encapsulation.
 *     *   `getCompletedTasks()`: Returns the internal `completedTasks` `ArrayList`, cast implicitly to a `List<Task>`.
 * 
 * 3.  **TaskManagementApp Class:**
 *     *   Contains the `main` method and orchestrates the application flow.
 *     *   Initializes `TaskDispatcher` and `Scanner`.
 *     *   `run()` method contains the main application loop (`while(running)`).
 *     *   **Scanner:** Used to read user input from `System.in`. `scanner.nextInt()` is used for reading the menu choice, and `scanner.nextLine()` is used for reading the task description and consuming the newline character after reading an integer.
 *     *   **Switch Statement:** The user's menu choice is handled by a `switch` statement, directing the program flow to the appropriate action method (`addTaskAction`, `dispatcher.processNextTask`, etc.).
 *     *   **System.out and System.err:** Used throughout as required. `System.out` for menus, prompts, success messages, and task lists. `System.err` for invalid input, queue empty errors, and other error conditions.
 *     *   **Class-wide Exception Handling (`try-catch`):** The main `run()` method wraps the core application loop (`while(running)`) in a `try-catch(Exception e)`. This provides a fallback mechanism to catch any unexpected exceptions that might occur during the program's execution, printing the error details to `System.err`. Additionally, specific `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls within the loop and `addTaskAction` to handle cases where the user enters non-integer input, printing a specific error message to `System.err` and recovering.
 *     *   The `Scanner` is closed in a `finally` block within the main `try-catch` to ensure resources are released upon application exit.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating state management, user interaction, input validation, and robust error handling using standard Java practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED,
    FAILED // Added for potential future use or error handling
}

// Class representing a single Task
class Task {
    private int taskId;
    private String description;
    private int priority; // Lower number = higher priority
    private TaskStatus status;

    // Static counter for generating unique task IDs
    private static int nextTaskId = 1;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (lower is higher).
     */
    public Task(String description, int priority) {
        this.taskId = nextTaskId++;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setters ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        return String.format("Task ID %d - %s (Priority: %d) - %s",
                             taskId, description, priority, status);
    }
}

// Class managing the task queues and processing logic
class TaskDispatcher {
    // Queue for tasks waiting to be processed (FIFO based on addition)
    private Queue<Task> pendingTasks;

    // List for tasks that have been completed
    private List<Task> completedTasks; // Implemented using ArrayList

    /**
     * Constructs a TaskDispatcher.
     */
    public TaskDispatcher() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List for completed tasks
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Performs input validation.
     * @param description The description of the task.
     * @param priority The priority of the task.
     * @return true if task was added successfully, false otherwise.
     */
    public boolean addTask(String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        if (priority <= 0) {
            System.err.println("Error: Task priority must be a positive integer.");
            return false;
        }

        Task newTask = new Task(description.trim(), priority);
        // offer() is preferred over add() for queues as it returns false if element cannot be added (e.g., capacity restricted queue)
        boolean added = pendingTasks.offer(newTask);
        if (added) {
            System.out.println("Task added: " + newTask);
        } else {
            // This case is unlikely with LinkedList, but good practice
            System.err.println("Error: Failed to add task to the queue.");
        }
        return added;
    }

    /**
     * Processes the next task from the pending queue.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            System.err.println("Error: No tasks currently pending.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);
        // Simulate processing...
        try {
             // In a real scenario, this would involve actual work
             Thread.sleep(100); // Simulate work
        } catch (InterruptedException e) {
             // Restore interrupt status
             Thread.currentThread().interrupt();
             System.err.println("Task processing interrupted: " + taskToProcess.getTaskId());
             taskToProcess.setStatus(TaskStatus.FAILED); // Example of setting FAILED status
             completedTasks.add(taskToProcess);
             return; // Stop processing this task
        }


        taskToProcess.setStatus(TaskStatus.COMPLETED);
        completedTasks.add(taskToProcess); // Add to the list of completed tasks
        System.out.println("Task ID " + taskToProcess.getTaskId() + " completed.");
    }

    /**
     * Returns a list of pending tasks.
     * Returns a new ArrayList to prevent external modification of the internal queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to maintain encapsulation of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // ArrayList is already a List, returning the reference is fine if external modification is acceptable (which it is for viewing)
    }
}

// Main application class for user interaction
public class TaskManagementApp {

    private TaskDispatcher dispatcher;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs the TaskManagementApp.
     */
    public TaskManagementApp() {
        dispatcher = new TaskDispatcher();
        scanner = new Scanner(System.in);
        running = true;
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Dispatcher Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Use a nested try-catch for reading the integer choice specifically
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTaskAction();
                        break;
                    case 2:
                        dispatcher.processNextTask();
                        break;
                    case 3:
                        viewPendingTasksAction();
                        break;
                    case 4:
                        viewCompletedTasksAction();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Dispatcher.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Handles the 'Add New Task' menu option.
     */
    private void addTaskAction() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        int priority = -1;
        System.out.print("Enter task priority (1=high): ");
        try {
            priority = scanner.nextInt();
            // Consume the newline
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid priority input. Please enter an integer.");
            scanner.nextLine(); // Consume the invalid input
            return; // Exit this action method
        }

        dispatcher.addTask(description, priority);
    }

    /**
     * Handles the 'View Pending Tasks' menu option.
     */
    private void viewPendingTasksAction() {
        List<Task> pending = dispatcher.getPendingTasks(); // Use List interface
        System.out.println("\nPending Tasks:");
        if (pending.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            for (Task task : pending) {
                System.out.println(task);
            }
        }
    }

    /**
     * Handles the 'View Completed Tasks' menu option.
     */
    private void viewCompletedTasksAction() {
        List<Task> completed = dispatcher.getCompletedTasks(); // Use List interface
        System.out.println("\nCompleted Tasks:");
        if (completed.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completed) {
                System.out.println(task);
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementApp app = new TaskManagementApp();
        app.run();
    }
}
