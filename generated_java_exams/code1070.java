/*
 * Exam Question #1070
 * Generated on: 2025-05-12 17:20:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Customer Service Request Processing System
 * 
 * **Objective:** Design and implement a simple command-line application for managing customer service requests. The system should allow adding new requests, processing the next request in the queue, viewing the current queue, viewing processed requests, and viewing a specific request by its ID.
 * 
 * **Scenario:** Imagine a small customer service team where requests arrive and are placed in a queue to be handled one by one. Once a request is processed, it is moved to a separate list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Request Representation:** Create a class `ServiceRequest` to represent a customer request. It should have the following private fields:
 *     *   `id` (int): A unique identifier for the request.
 *     *   `description` (String): A brief description of the request.
 *     *   `status` (enum `RequestStatus`): The current status of the request.
 *     *   The `RequestStatus` enum should have values: `PENDING`, `PROCESSING`, `COMPLETED`.
 *     *   Include a constructor, appropriate getters, and a method to update the status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the request (ID, Description, Status).
 * 
 * 2.  **Request Management:** Create a class `RequestProcessor` that manages the requests. It should have:
 *     *   A private `Queue<ServiceRequest>` to hold requests that are waiting to be processed. Use a suitable implementation like `LinkedList`.
 *     *   A private `ArrayList<ServiceRequest>` to hold requests that have been completed.
 *     *   A private counter for generating unique request IDs.
 *     *   Public methods for:
 *         *   `addRequest(String description)`: Creates a new `ServiceRequest` with a unique ID, sets its status to `PENDING`, and adds it to the queue. Returns the ID of the added request.
 *         *   `processNextRequest()`: Takes the next request from the front of the queue. If the queue is not empty, it updates the request's status to `PROCESSING`, simulates processing (no actual work needed, just the status change), updates the status to `COMPLETED`, and moves it from the queue to the list of processed requests. Returns the completed request or `null` if the queue was empty.
 *         *   `getPendingRequests()`: Returns a `List<ServiceRequest>` containing all requests currently in the queue.
 *         *   `getCompletedRequests()`: Returns a `List<ServiceRequest>` containing all requests that have been processed.
 *         *   `findRequestById(int id)`: Searches both the pending queue and the completed list for a request with the given ID. Returns the `ServiceRequest` object if found, otherwise returns `null`.
 * 
 * 3.  **User Interface:** Implement a main application class (`ServiceSystem`) with a `main` method that provides a command-line interface using `Scanner`. The interface should present a menu with options:
 *     *   1. Add New Request
 *     *   2. Process Next Request
 *     *   3. View Pending Requests
 *     *   4. View Completed Requests
 *     *   5. Find Request by ID
 *     *   6. Exit
 * 
 * 4.  **Input and Output:**
 *     *   Use `Scanner` to read user input (menu choice, request description, request ID).
 *     *   Use `System.out` for the menu, prompts, and displaying request information.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, queue empty, request not found, invalid ID input).
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method's loop to catch potential runtime errors (e.g., `InputMismatchException` when reading an integer, or custom exceptions if you choose to implement them, though not strictly required by the prompt's exception handling clause which focuses on `try-catch`). All caught exceptions should print an informative message to `System.err`.
 *     *   Validate user input where necessary (e.g., ensuring menu choice is a valid number within the range, ensuring request ID is a valid integer).
 * 
 * 6.  **Code Structure and Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments explaining complex logic.
 *     *   Ensure clean code structure.
 *     *   Properly close the `Scanner` resource.
 * 
 * **Required Java Components Checklist:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling (`try-catch`)
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and perform actions based on the input. Output should be clear, showing request details when viewing lists or finding by ID, confirmation messages for adding/processing, and error messages for invalid operations or input.
 * 
 * ---
 * **Example Interaction Flow:**
 * 
 * ```
 * Customer Service Request System
 * Menu:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Find Request by ID
 * 6. Exit
 * Enter your choice: 1
 * Enter request description: Fix printer issue
 * Request ID 1 added.
 * Enter your choice: 1
 * Enter request description: Reset password
 * Request ID 2 added.
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 1, Description: Fix printer issue, Status: PENDING
 * ID: 2, Description: Reset password, Status: PENDING
 * ------------------------
 * Enter your choice: 2
 * Processing request ID 1...
 * Request ID 1 processed.
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 2, Description: Reset password, Status: PENDING
 * ------------------------
 * Enter your choice: 4
 * --- Completed Requests ---
 * ID: 1, Description: Fix printer issue, Status: COMPLETED
 * ------------------------
 * Enter your choice: 5
 * Enter Request ID to find: 2
 * Request Found: ID: 2, Description: Reset password, Status: PENDING
 * Enter your choice: 5
 * Enter Request ID to find: 99
 * Request with ID 99 not found.
 * Enter your choice: 2
 * Processing request ID 2...
 * Request ID 2 processed.
 * Enter your choice: 2
 * Queue is empty. No requests to process.
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * ---
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a Customer Service Request Processing System demonstrating the required Java concepts.
 * 
 * **Structure:**
 * 1.  **`RequestStatus` Enum:** Defines the possible states a service request can be in, providing type safety and readability over using raw strings.
 * 2.  **`ServiceRequest` Class:** Encapsulates the data for a single request (ID, description, status). It includes a constructor, getters, a status setter, and overrides `toString()` for easy printing. Input validation for the description is included in the constructor.
 * 3.  **`RequestProcessor` Class:** Manages the collection of requests.
 *     *   It uses a `Queue<ServiceRequest>` (`LinkedList` implementation) for pending requests, correctly modeling the FIFO (First-In, First-Out) nature of a processing queue. The `offer()` method is used for adding to the queue, and `poll()` for retrieving and removing the head.
 *     *   It uses an `ArrayList<ServiceRequest>` for completed requests, which is suitable for storing a dynamic list of processed items where order isn't strictly FIFO after processing.
 *     *   It maintains `nextRequestId` to ensure unique IDs for new requests.
 *     *   Methods like `addRequest`, `processNextRequest`, `getPendingRequests`, `getCompletedRequests`, and `findRequestById` handle the core logic. `getPendingRequests` and `getCompletedRequests` return `List<ServiceRequest>`, adhering to the requirement of using the `List` interface and promoting good practice by returning a copy to protect the internal collections.
 * 4.  **`ServiceSystem` Class:** Contains the `main` method and serves as the application's entry point and user interface handler.
 *     *   It uses `Scanner` to interact with the user via the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to control the flow based on the user's menu choice, fulfilling that requirement.
 *     *   `System.out` is used for printing the menu, prompts, and successful output (request details, confirmations).
 *     *   `System.err` is specifically used for printing error messages, such as invalid input or operations that fail (e.g., trying to process from an empty queue, invalid ID format).
 *     *   **Class-wide Exception Handling:** A `try-catch` block is wrapped around the core loop logic within `main`. This catches potential `InputMismatchException` when reading the menu choice or request ID, as well as other unexpected `Exception` types, preventing the program from crashing and providing an error message to `System.err`. A separate `try-catch` is used specifically for the "Find Request by ID" input to handle its specific `InputMismatchException` and consume the invalid input correctly. The `IllegalArgumentException` thrown by the `ServiceRequest` constructor is caught when adding a request.
 *     *   Resource Management: The `Scanner` object is explicitly closed before the program exits.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`ServiceRequest`, `RequestProcessor`, `ServiceSystem`) and an enum (`RequestStatus`) to model the problem domain.
 * *   **Encapsulation:** Private fields and public methods/getters in `ServiceRequest` and `RequestProcessor`.
 * *   **Data Structures:** Effective use of `Queue` (specifically `LinkedList`) for managing ordered pending tasks and `ArrayList` for storing completed tasks.
 * *   **Interfaces:** Using `List` as the return type for methods that provide views of the collections (`getPendingRequests`, `getCompletedRequests`).
 * *   **Input/Output:** Using `Scanner` for input, `System.out` for standard output, and `System.err` for error output.
 * *   **Control Flow:** Using `switch` for menu navigation and a `while` loop for the main application cycle.
 * *   **Exception Handling:** Implementing `try-catch` blocks for robust error management, including handling specific input errors (`InputMismatchException`) and general exceptions, printing errors to `System.err`. Input validation is also performed (e.g., checking for empty description, checking if queue is empty before processing).
 * *   **Code Readability:** Meaningful variable/method names and comments are used throughout the code.
 * 
 * The solution successfully integrates all the required components into a cohesive, practical application while adhering to best practices for Java development.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Request Status
enum RequestStatus {
    PENDING,
    PROCESSING,
    COMPLETED
}

// Class to represent a customer service request
class ServiceRequest {
    private int id;
    private String description;
    private RequestStatus status;

    // Constructor
    public ServiceRequest(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = RequestStatus.PENDING; // New requests are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public RequestStatus getStatus() {
        return status;
    }

    // Method to update status (controlled state transitions could be added here)
    public void setStatus(RequestStatus status) {
        // Basic status update, could add logic like "cannot go from COMPLETED to PENDING"
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Status: %s",
                             id, description, status);
    }
}

// Class to manage the request queue and processed list
class RequestProcessor {
    private Queue<ServiceRequest> requestQueue;
    private ArrayList<ServiceRequest> completedRequests; // Use ArrayList for completed
    private int nextRequestId; // Counter for unique IDs

    // Constructor
    public RequestProcessor() {
        this.requestQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Adds a new request to the pending queue.
     * @param description The description of the request.
     * @return The ID of the newly added request.
     */
    public int addRequest(String description) {
        // ServiceRequest constructor already handles empty description validation
        ServiceRequest newRequest = new ServiceRequest(nextRequestId++, description);
        requestQueue.offer(newRequest); // offer is preferred over add for queues
        return newRequest.getId();
    }

    /**
     * Processes the next request in the queue.
     * Moves the request from pending to completed state.
     * @return The completed ServiceRequest, or null if the queue was empty.
     */
    public ServiceRequest processNextRequest() {
        ServiceRequest requestToProcess = requestQueue.poll(); // poll retrieves and removes the head

        if (requestToProcess != null) {
            requestToProcess.setStatus(RequestStatus.PROCESSING);
            // Simulate processing delay if needed, but not required by prompt
            // try { Thread.sleep(500); } catch (InterruptedException e) {}
            requestToProcess.setStatus(RequestStatus.COMPLETED);
            completedRequests.add(requestToProcess);
            return requestToProcess;
        } else {
            return null; // Queue is empty
        }
    }

    /**
     * Returns a List of requests currently in the pending queue.
     * Note: Returns a copy to prevent external modification of the internal queue.
     * @return A List of pending ServiceRequests.
     */
    public List<ServiceRequest> getPendingRequests() {
        return new ArrayList<>(requestQueue); // Return as List interface
    }

    /**
     * Returns a List of requests that have been completed.
     * @return A List of completed ServiceRequests.
     */
    public List<ServiceRequest> getCompletedRequests() {
        return new ArrayList<>(completedRequests); // ArrayList already implements List
    }

    /**
     * Finds a request by its ID in either the pending queue or completed list.
     * @param id The ID of the request to find.
     * @return The ServiceRequest object if found, otherwise null.
     */
    public ServiceRequest findRequestById(int id) {
        // Search in pending queue
        for (ServiceRequest request : requestQueue) {
            if (request.getId() == id) {
                return request;
            }
        }
        // Search in completed list
        for (ServiceRequest request : completedRequests) {
            if (request.getId() == id) {
                return request;
            }
        }
        return null; // Not found
    }
}

// Main application class
public class ServiceSystem {

    private static void displayMenu() {
        System.out.println("\nCustomer Service Request System");
        System.out.println("Menu:");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Find Request by ID");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RequestProcessor processor = new RequestProcessor();
        boolean running = true;

        // Class-wide exception handling loop
        while (running) {
            try {
                displayMenu();
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character

                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        try {
                            int requestId = processor.addRequest(description);
                            System.out.println("Request ID " + requestId + " added.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding request: " + e.getMessage());
                        }
                        break;

                    case 2:
                        ServiceRequest processedRequest = processor.processNextRequest();
                        if (processedRequest != null) {
                            System.out.println("Processing request ID " + processedRequest.getId() + "...");
                            System.out.println("Request ID " + processedRequest.getId() + " processed.");
                        } else {
                            System.out.println("Queue is empty. No requests to process.");
                        }
                        break;

                    case 3:
                        List<ServiceRequest> pending = processor.getPendingRequests();
                        System.out.println("--- Pending Requests ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending requests.");
                        } else {
                            for (ServiceRequest req : pending) {
                                System.out.println(req);
                            }
                        }
                        System.out.println("------------------------");
                        break;

                    case 4:
                        List<ServiceRequest> completed = processor.getCompletedRequests();
                        System.out.println("--- Completed Requests ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed requests.");
                        } else {
                            for (ServiceRequest req : completed) {
                                System.out.println(req);
                            }
                        }
                        System.out.println("------------------------");
                        break;

                    case 5:
                        System.out.print("Enter Request ID to find: ");
                        try {
                            int findId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            ServiceRequest foundRequest = processor.findRequestById(findId);
                            if (foundRequest != null) {
                                System.out.println("Request Found: " + foundRequest);
                            } else {
                                System.out.println("Request with ID " + findId + " not found.");
                            }
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid integer ID.");
                            scanner.nextLine(); // Consume the invalid input
                        }
                        break;

                    case 6:
                        running = false;
                        System.out.println("Exiting system.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for the main menu choice
                System.err.println("Invalid input. Please enter a valid integer for the menu choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to stderr for debugging
            }
        }

        scanner.close(); // Close the scanner resource
    }
}
