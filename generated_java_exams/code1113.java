/*
 * Exam Question #1113
 * Generated on: 2025-05-12 17:26:45
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Manager System
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application for a print shop to manage incoming print jobs. The system should allow users to submit new jobs, process the next job in line, view the list of waiting jobs, and view the list of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Components:** Your solution must utilize ALL of the following Java components from the specified packages:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu navigation/flow control
 *     *   `System.err` for displaying error messages
 *     *   `System.out` for displaying normal output (menu, prompts, status, job details)
 *     *   Class-wide exception handling using `try-catch` blocks within the main application loop.
 * 
 * 2.  **Data Structures:**
 *     *   Maintain a queue of `PrintJob` objects that are waiting to be processed. Jobs should be processed in the order they were submitted (First-In, First-Out - FIFO).
 *     *   Maintain a list of `PrintJob` objects that have been completed.
 * 
 * 3.  **`PrintJob` Class:**
 *     *   Create a class named `PrintJob` with the following private fields:
 *         *   `jobId` (int): A unique identifier for the job.
 *         *   `pages` (int): The number of pages in the job.
 *         *   `priority` (enum `Priority`): The priority level (e.g., HIGH, MEDIUM, LOW).
 *         *   `status` (enum `JobStatus`): The current status (e.g., WAITING, PROCESSING, COMPLETED).
 *     *   Include a constructor to initialize job properties.
 *     *   Provide public getter methods for the fields.
 *     *   Provide a public setter method for the `status` field, as the status will change during processing.
 *     *   Override the `toString()` method to provide a descriptive string representation of the job.
 * 
 * 4.  **`PrintManager` Class:**
 *     *   Create a class named `PrintManager` that manages the print jobs.
 *     *   Include private fields for the job queue (`Queue<PrintJob>`), the completed jobs list (`List<PrintJob>`), and a counter for generating unique `jobId`s.
 *     *   Include a `private Scanner` field for handling user input.
 *     *   Implement the following public methods:
 *         *   `submitJob(int pages, Priority priority)`: Creates a new `PrintJob` with a unique ID, adds it to the waiting queue, and prints a success message to `System.out`. Include input validation for pages (> 0).
 *         *   `processNextJob()`: Removes the next job from the queue, updates its status to `COMPLETED`, and adds it to the completed jobs list. Print messages to `System.out` indicating which job is being processed and which is completed. If the queue is empty, print an error message to `System.err`.
 *         *   `viewQueue()`: Prints the details of all jobs currently in the waiting queue to `System.out`. Indicate if the queue is empty.
 *         *   `viewCompletedJobs()`: Prints the details of all jobs in the completed list to `System.out`. Indicate if the list is empty.
 *         *   `run()`: This method should contain the main application loop. It displays a menu, reads user input using the `Scanner`, and uses a `switch` statement to call the appropriate manager methods based on the user's choice. This method must include `try-catch` blocks to handle potential exceptions, such as `InputMismatchException` during input reading or other unexpected runtime errors, printing error details to `System.err`. The loop should continue until the user chooses to exit.
 *     *   Include a `private displayMenu()` helper method.
 * 
 * 5.  **Enums:** Create `Priority` and `JobStatus` enums as described above.
 * 
 * 6.  **Main Method:** Create a `main` method (can be in `PrintManager` or a separate class) that instantiates `PrintManager` and calls its `run()` method to start the application.
 * 
 * 7.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public/private methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation where necessary (e.g., pages, valid priority).
 *     *   Provide clear error messages using `System.err`.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu of options. Based on user input, it should perform the requested action, printing success or status messages to `System.out` and any error messages to `System.err`. Examples:
 * 
 * ```
 * Welcome to the Print Job Manager!
 * --- Menu ---
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed Jobs
 * 5. Exit
 * ------------
 * Enter your choice: 1
 * Enter number of pages: 100
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Job submitted successfully: Job ID: 1, Pages: 100, Priority: HIGH, Status: WAITING
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Processing job: 1...
 * Job 1 completed.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Error: No jobs in the queue to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number for your choice.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter number of pages: -50
 * Error: Number of pages must be positive.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter number of pages: 20
 * Enter priority (HIGH, MEDIUM, LOW): URGENT
 * Error: Invalid priority entered. Please use HIGH, MEDIUM, or LOW.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Print Job Manager. Goodbye!
 * ```
 *
 * EXPLANATION:
 * The solution implements a Print Job Manager system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Structure:** The system is organized into three main parts:
 *     *   `Priority` and `JobStatus` enums define the possible states and attributes of a print job.
 *     *   `PrintJob` class encapsulates the data for a single job (ID, pages, priority, status) and provides methods to access/modify its status and a `toString` for display.
 *     *   `PrintManager` class orchestrates the entire process. It holds the data structures (`jobQueue` and `completedJobs`) and contains the methods for submitting, processing, viewing jobs, and the main application loop (`run`).
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `Queue<PrintJob>` named `jobQueue` is used to store jobs waiting to be processed. `LinkedList` is chosen as a common implementation of the `Queue` interface, providing efficient FIFO operations. `offer()` is used to add jobs to the end, and `poll()` is used to remove jobs from the front.
 *     *   A `List<PrintJob>` named `completedJobs` is used to store jobs that have finished processing. `ArrayList` is chosen as a common implementation of the `List` interface, providing dynamic resizing and easy storage/retrieval of completed jobs. `add()` is used to append completed jobs.
 *     *   When viewing the queue (`viewQueue()`), a temporary `ArrayList` is created from the `jobQueue` (`new ArrayList<>(jobQueue)`) to allow iteration and display of queue elements without removing them from the queue.
 * 
 * 3.  **User Input (`Scanner`) and Flow Control (`switch`):**
 *     *   A `Scanner` object reads input from `System.in` in the `run()` method.
 *     *   The main loop in `run()` repeatedly displays a menu and reads the user's choice.
 *     *   A `switch` statement efficiently directs the program flow to the appropriate method (`submitJob`, `processNextJob`, `viewQueue`, `viewCompletedJobs`) based on the integer choice entered by the user.
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for all normal output, including the menu, prompts, success messages (e.g., job submitted, job completed), and the formatted lists of jobs.
 *     *   `System.err.println()` is strictly used for displaying error messages, such as invalid user input, attempting to process a job when the queue is empty, or invalid priority strings. This separates error streams from standard output, which is a good practice.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   The `run()` method demonstrates class-wide exception handling. A `try-catch` block wraps the core logic within the main loop.
 *     *   It specifically catches `InputMismatchException`, which `scanner.nextInt()` can throw if the user enters non-integer input when an integer is expected (for the menu choice or number of pages). Catching this prevents the program from crashing and allows it to prompt the user again after displaying an error message to `System.err` and consuming the invalid input (`scanner.nextLine()`).
 *     *   A general `catch (Exception e)` block is included to catch any other unexpected runtime errors that might occur during the execution of the chosen action, printing a generic error message along with the exception's message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `PrintJob` and `PrintManager` are `private`, accessed or modified only through public methods.
 *     *   **Meaningful Names:** Variable names (`jobQueue`, `completedJobs`, `nextJobId`), method names (`submitJob`, `processNextJob`, `viewQueue`, `run`), and enum values are descriptive and reflect their purpose.
 *     *   **Comments and Documentation:** Javadoc comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific code sections.
 *     *   **Input Validation:** The `submitJob` method checks if the number of pages is positive. The priority input string is validated by attempting to convert it to the `Priority` enum using `Priority.valueOf()`, catching the `IllegalArgumentException` if the string doesn't match any enum constant.
 *     *   **Error Handling:** Specific error conditions like an empty queue during processing are explicitly checked, and informative error messages are printed to `System.err`. The `try-catch` blocks provide a safety net for input errors and other unexpected issues.
 *     *   **Clean Code Structure:** The code is divided into logical units (enums, classes, methods), making it readable and maintainable. The `main` method is minimal, simply starting the manager's execution.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating core programming concepts, data structure usage, user interaction handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // Not strictly needed for this solution, but good to be aware for Queue iteration

// Enum for job priority levels
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for print job status
enum JobStatus {
    WAITING, PROCESSING, COMPLETED
}

/**
 * Represents a single print job with its properties and status.
 */
class PrintJob {
    private int jobId;
    private int pages;
    private Priority priority;
    private JobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param pages The number of pages in the job.
     * @param priority The priority level of the job.
     */
    public PrintJob(int jobId, int pages, Priority priority) {
        this.jobId = jobId;
        this.pages = pages;
        this.priority = priority;
        this.status = JobStatus.WAITING; // New jobs start as WAITING
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public int getPages() {
        return pages;
    }

    public Priority getPriority() {
        return priority;
    }

    public JobStatus getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the print job.
     * @param status The new status for the job.
     */
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string detailing the job's properties.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, Pages: %d, Priority: %s, Status: %s",
                             jobId, pages, priority, status);
    }
}

/**
 * Manages the print job queue and completed jobs list.
 * Handles user interaction via a command-line interface.
 */
public class PrintManager {
    private Queue<PrintJob> jobQueue;
    private List<PrintJob> completedJobs;
    private int nextJobId;
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing data structures and scanner.
     */
    public PrintManager() {
        // Using LinkedList as a Queue implementation for FIFO
        this.jobQueue = new LinkedList<>();
        // Using ArrayList to store completed jobs
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Submits a new print job to the queue.
     * Validates input pages.
     * @param pages The number of pages in the job. Must be positive.
     * @param priority The priority of the job.
     */
    public void submitJob(int pages, Priority priority) {
        // Input validation: pages must be positive
        if (pages <= 0) {
            // Using System.err for validation errors as per requirement
            System.err.println("Error: Number of pages must be positive.");
            return; // Exit the method if validation fails
        }

        PrintJob newJob = new PrintJob(nextJobId++, pages, priority);
        jobQueue.offer(newJob); // offer() is preferred over add() in Queue as it doesn't throw exception if failed
        System.out.println("Job submitted successfully: " + newJob); // Normal output
    }

    /**
     * Processes the next job at the front of the queue.
     * Moves the job to the completed list after processing.
     * Handles case where queue is empty.
     */
    public void processNextJob() {
        // Check if queue is empty before attempting to process
        if (jobQueue.isEmpty()) {
            System.err.println("Error: No jobs in the queue to process."); // Error output
            return; // Exit if queue is empty
        }

        PrintJob jobToProcess = jobQueue.poll(); // poll() retrieves and removes the head of the queue (FIFO)
        if (jobToProcess != null) { // Defensive check, poll() returns null if queue is empty, though checked above
            System.out.println("Processing job: " + jobToProcess.getJobId() + "..."); // Normal output

            // Simulate processing - in a real system, this would involve actual work
            // For this task, we just update the status and move it.
            jobToProcess.setStatus(JobStatus.COMPLETED); // Update job status

            completedJobs.add(jobToProcess); // Add the completed job to the list
            System.out.println("Job " + jobToProcess.getJobId() + " completed."); // Normal output
        } else {
             // This branch should ideally not be reached due to the isEmpty() check,
             // but included for robustness.
             System.err.println("Error: Failed to retrieve job from queue unexpectedly.");
        }
    }

    /**
     * Displays the list of jobs currently waiting in the queue.
     * Iterates over a copy to avoid modifying the queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Print Queue ---"); // Normal output
        if (jobQueue.isEmpty()) {
            System.out.println("The queue is empty."); // Normal output
        } else {
            // To iterate over the queue without removing elements, we can copy it to a List
            List<PrintJob> queueList = new ArrayList<>(jobQueue);
            for (int i = 0; i < queueList.size(); i++) {
                System.out.println((i + 1) + ". " + queueList.get(i)); // Normal output
            }
        }
        System.out.println("---------------------------"); // Normal output
    }

    /**
     * Displays the list of jobs that have been completed.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---"); // Normal output
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet."); // Normal output
        } else {
            // Iterate over the completed jobs list
            for (int i = 0; i < completedJobs.size(); i++) {
                System.out.println((i + 1) + ". " + completedJobs.get(i)); // Normal output
            }
        }
        System.out.println("----------------------"); // Normal output
    }

    /**
     * Runs the main application loop, handling user interaction and menu navigation.
     * Includes class-wide exception handling for robust operation.
     */
    public void run() {
        boolean running = true;
        System.out.println("Welcome to the Print Job Manager!"); // Normal output

        // Main application loop
        while (running) {
            displayMenu();

            try {
                System.out.print("Enter your choice: "); // Normal output
                // Read the user's choice. This is the primary point for InputMismatchException
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Submit New Job
                        System.out.print("Enter number of pages: "); // Normal output
                        int pages = scanner.nextInt(); // May throw InputMismatchException
                        scanner.nextLine(); // Consume newline

                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): "); // Normal output
                        String priorityStr = scanner.nextLine().trim().toUpperCase();
                        Priority priority = null;
                        try {
                            // Convert string input to Priority enum. May throw IllegalArgumentException
                            priority = Priority.valueOf(priorityStr);
                            submitJob(pages, priority); // Call submitJob method
                        } catch (IllegalArgumentException e) {
                            // Handle invalid priority string input
                            System.err.println("Error: Invalid priority entered. Please use HIGH, MEDIUM, or LOW."); // Error output
                        }
                        break;

                    case 2: // Process Next Job
                        processNextJob(); // Call processNextJob method
                        break;

                    case 3: // View Print Queue
                        viewQueue(); // Call viewQueue method
                        break;

                    case 4: // View Completed Jobs
                        viewCompletedJobs(); // Call viewCompletedJobs method
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Job Manager. Goodbye!"); // Normal output
                        running = false; // Set running flag to false to exit the loop
                        break;

                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Error output
                        break;
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling for non-integer input for menu choice or pages
                System.err.println("Error: Invalid input. Please enter a number for your choice or requested value."); // Error output
                scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
            } catch (Exception e) {
                // General catch block for any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Error output
                // e.printStackTrace(); // Uncomment for debugging purposes if needed
            }
            System.out.println(); // Add a newline for better readability between menu cycles
        }

        scanner.close(); // Close the scanner resource when the application exits
    }

    /**
     * Displays the main menu options to the user on System.out.
     */
    private void displayMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Submit New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Main method to start the Print Job Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run(); // Start the main application loop
    }
}
