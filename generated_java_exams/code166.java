/*
 * Exam Question #166
 * Generated on: 2025-05-11 22:24:44
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Event Registration System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Event Management System for events with limited capacity. Attendees can register for an event. If the event is not full, they are directly registered. If the event is full, they are added to a waiting list. If a registered attendee cancels, the first person on the waiting list automatically takes their spot.
 * 
 * Your system should allow users to interact via a command-line interface to perform actions such as registering a new participant, cancelling a registration, viewing the list of registered participants, viewing the waiting list, and viewing a summary of the event status.
 * 
 * **Requirements:**
 * 
 * 1.  **Participant Class:** Create a class `Participant` with private fields for `name` (String) and `id` (String). Include a constructor and public getter methods. Implement `equals()` and `hashCode()` based on the participant's `id` to ensure unique participants are handled correctly.
 * 2.  **Event Class:** Create a class `Event` with private fields for `name` (String), `capacity` (int), a `List` to store registered participants, and a `Queue` to store participants on the waiting list.
 *     *   The registered participants list must be declared using the `java.util.List` interface and implemented using `java.util.ArrayList`.
 *     *   The waiting list must be declared using the `java.util.Queue` interface (a `LinkedList` is a suitable implementation).
 *     *   Implement a constructor for the `Event` class.
 *     *   Implement methods:
 *         *   `registerParticipant(Participant participant)`: Adds a participant. If `registeredParticipants.size() < capacity`, add to registered list and print a success message to `System.out`. Otherwise, add to `waitingList` and print a message indicating they are on the waiting list to `System.out`. Handle the case where a participant with the same ID is already registered or on the waiting list by printing an error message to `System.err`.
 *         *   `cancelRegistration(String participantId)`: Finds and removes a participant by ID from either the `registeredParticipants` list or the `waitingList`. If found and removed from `registeredParticipants`, check if the `waitingList` is not empty. If so, remove the first participant from the `waitingList` and add them to the `registeredParticipants` list, printing messages to `System.out` about the cancellation and the waiting list move. If found and removed from `waitingList`, print a cancellation message to `System.out`. If the participant ID is not found in either list, print an error message to `System.err`.
 *         *   `viewRegisteredParticipants()`: Prints the list of registered participants to `System.out`. Indicate if the list is empty.
 *         *   `viewWaitingList()`: Prints the participants on the waiting list to `System.out`. Indicate if the list is empty.
 *         *   `viewEventSummary()`: Prints the event name, capacity, current number of registered participants, current number on the waiting list, and available slots to `System.out`.
 * 3.  **EventManagementSystem Class (Main Application):**
 *     *   Create a class `EventManagementSystem` with a `main` method.
 *     *   Instantiate an `Event` object with a name and a small capacity (e.g., 3 or 5) for testing the waiting list functionality.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven loop that presents options to the user:
 *         1.  Register Participant
 *         2.  Cancel Registration
 *         3.  View Registered Participants
 *         4.  View Waiting List
 *         5.  View Event Summary
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation messages from the `Event` class methods.
 *     *   Use `System.err` for displaying error messages, including invalid menu choices and input validation errors (e.g., empty name/ID).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the `main` method to gracefully handle potential runtime errors, such as `InputMismatchException` when reading the menu choice or other unexpected issues during command processing. Print an informative error message to `System.err` in the catch block.
 *     *   Implement basic input validation for participant name and ID (e.g., check if not empty) before attempting to register or cancel. Use `System.err` for validation errors.
 * 4.  **Best Practices:** Ensure your code follows good practices including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate use of comments where necessary.
 *     *   Clear and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Users enter numbers corresponding to menu options. The output should clearly show the results of operations (success/failure), lists of participants, and the event summary, using `System.out` for normal output and `System.err` for errors.
 * 
 * Example interaction flow:
 * - Display menu.
 * - User chooses 1 (Register), enters name/ID. System confirms registration or waiting list addition.
 * - Repeat registration until capacity is reached, then participants go to waiting list.
 * - User chooses 3 (View Registered) and 4 (View Waiting) to see the lists.
 * - User chooses 5 (Summary) to see counts.
 * - User chooses 2 (Cancel), enters ID. System confirms cancellation and potentially waiting list move.
 * - User chooses 3 and 4 again to see updated lists.
 * - User enters invalid input (non-number for choice, empty name/ID). System prints error to `System.err`.
 * - User chooses 6 (Exit). System quits.
 * 
 * ```java
 * // Your code for Participant.java, Event.java, and EventManagementSystem.java goes here
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Event Registration System demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming (OOP):** The problem is broken down into three classes: `Participant` (representing an attendee), `Event` (managing the event's state and logic), and `EventManagementSystem` (handling user interaction and the main application flow). This demonstrates encapsulation (private fields with public getters/methods) and modular design.
 * 2.  **Collections Framework:**
 *     *   `java.util.List` and `java.util.ArrayList`: The `registeredParticipants` list is declared using the `List` interface and instantiated as an `ArrayList`. This is suitable for storing a dynamic collection where elements might need to be accessed by index (`get(i)`), iterated over, or removed.
 *     *   `java.util.Queue` and `java.util.LinkedList`: The `waitingList` is declared using the `Queue` interface and instantiated as a `LinkedList`. A `Queue` follows a First-In, First-Out (FIFO) principle, which is perfect for a waiting list where the person waiting the longest (first in) is the first to get a spot when available (`poll()`). `LinkedList` is a common `Queue` implementation.
 * 3.  **Input Handling:**
 *     *   `java.util.Scanner`: Used in `EventManagementSystem.main` to read user input from the console for menu choices, participant names, and IDs.
 * 4.  **Control Flow:**
 *     *   `switch` Statement: Used effectively in `EventManagementSystem.main` to direct the program flow based on the user's menu selection, making the code readable and organized.
 *     *   Loops (`while`): The main application runs within a `while(true)` loop, allowing the user to perform multiple operations until they choose to exit.
 * 5.  **Error Handling:**
 *     *   `System.err`: Used consistently throughout the code (in `Event` methods and `EventManagementSystem`) to print error messages, distinguishing them from normal program output (`System.out`). This is crucial for user feedback when operations fail (e.g., duplicate ID, participant not found, invalid input).
 *     *   `try-catch` Blocks:
 *         *   A large `try-catch(Exception e)` block wraps the main `while` loop in `EventManagementSystem.main`. This serves as **class-wide exception handling**, catching any unhandled exceptions that might occur during the execution of the command processing loop and preventing the program from crashing abruptly.
 *         *   A specific `try-catch(InputMismatchException e)` is nested within the loop to specifically handle cases where the user enters non-integer input when prompted for the menu choice, allowing the program to recover and re-prompt the user.
 * 6.  **Input Validation:** Basic validation is performed in `EventManagementSystem.main` to check if participant name or ID are empty strings before attempting to process them. Validation for duplicate IDs is handled within the `Event` class's `registerParticipant` method using the `participantExists` helper.
 * 7.  **Best Practices Implementation:**
 *     *   Private fields and public methods enforce encapsulation.
 *     *   Variable and method names are descriptive (e.g., `registeredParticipants`, `cancelRegistration`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections (like the cancellation process).
 *     *   The use of `Iterator` for safe removal during iteration in the `cancelRegistration` method is a good practice when modifying a collection while iterating.
 *     *   Overriding `equals()` and `hashCode()` in `Participant` ensures that collection methods (like those used implicitly in the `participantExists` helper or explicit iteration checks) correctly identify unique participants based on their ID.
 * 
 * The solution provides a practical example of how these core Java components and practices are integrated to build a functional, albeit simple, application that manages state using different collection types and handles user interaction with basic error management. The cancellation logic, involving the interplay between the `List` and the `Queue`, is a specific point of challenge that requires careful implementation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;
import java.util.Objects;

// 1. Participant Class
class Participant {
    private String name;
    private String id;

    public Participant(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public String getId() {
        return id;
    }

    // Override equals and hashCode based on ID for uniqueness checks
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Participant that = (Participant) o;
        return Objects.equals(id, that.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

// 2. Event Class
class Event {
    private String name;
    private int capacity;
    private List<Participant> registeredParticipants; // Using List interface, implemented by ArrayList
    private Queue<Participant> waitingList; // Using Queue interface, implemented by LinkedList

    public Event(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.registeredParticipants = new ArrayList<>();
        this.waitingList = new LinkedList<>();
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    // Helper method to check if a participant ID already exists in either list
    private boolean participantExists(String id) {
        for (Participant p : registeredParticipants) {
            if (p.getId().equals(id)) {
                return true;
            }
        }
        for (Participant p : waitingList) {
            if (p.getId().equals(id)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Registers a participant for the event. Adds to registered list if space,
     * otherwise adds to waiting list.
     * Prints success messages to System.out or error to System.err.
     * @param participant The participant to register.
     */
    public void registerParticipant(Participant participant) {
        if (participant == null || participant.getId() == null || participant.getId().trim().isEmpty()) {
             System.err.println("Error: Invalid participant data provided.");
             return;
        }

        if (participantExists(participant.getId())) {
            System.err.println("Error: Participant with ID " + participant.getId() + " is already registered or on waiting list.");
            return;
        }

        if (registeredParticipants.size() < capacity) {
            registeredParticipants.add(participant);
            System.out.println("Success: Participant '" + participant.getName() + "' (ID: " + participant.getId() + ") registered successfully.");
        } else {
            waitingList.offer(participant); // Add to the end of the waiting queue
            System.out.println("Info: Event full. Participant '" + participant.getName() + "' (ID: " + participant.getId() + ") added to waiting list.");
        }
    }

    /**
     * Cancels registration for a participant by ID.
     * If cancelled from registered list and waiting list is not empty, moves the first waiting participant.
     * Prints success messages to System.out or error to System.err.
     * @param participantId The ID of the participant to cancel.
     */
    public void cancelRegistration(String participantId) {
        if (participantId == null || participantId.trim().isEmpty()) {
            System.err.println("Error: Participant ID for cancellation cannot be empty.");
            return;
        }

        boolean foundAndRemoved = false;

        // 1. Try to remove from registered participants
        Iterator<Participant> registeredIterator = registeredParticipants.iterator();
        while (registeredIterator.hasNext()) {
            Participant p = registeredIterator.next();
            if (p.getId().equals(participantId)) {
                registeredIterator.remove(); // Safe removal using iterator
                System.out.println("Success: Participant with ID " + participantId + " cancelled registration.");
                foundAndRemoved = true;

                // If removed from registered, move the next person from the waiting list
                if (!waitingList.isEmpty()) {
                    Participant nextInLine = waitingList.poll(); // Get and remove head of the queue
                    registeredParticipants.add(nextInLine);
                    System.out.println("Info: Participant '" + nextInLine.getName() + "' (ID: " + nextInLine.getId() + ") moved from waiting list to registered.");
                }
                break; // Participant found and processed, exit loop
            }
        }

        // 2. If not found in registered, try to remove from waiting list
        if (!foundAndRemoved) {
             Iterator<Participant> waitingIterator = waitingList.iterator();
             while(waitingIterator.hasNext()){
                 Participant p = waitingIterator.next();
                 if(p.getId().equals(participantId)){
                     waitingIterator.remove(); // Safe removal using iterator
                     System.out.println("Success: Participant with ID " + participantId + " removed from waiting list.");
                     foundAndRemoved = true;
                     break; // Participant found and processed, exit loop
                 }
             }
        }

        if (!foundAndRemoved) {
            System.err.println("Error: Participant with ID " + participantId + " not found in registered list or waiting list.");
        }
    }

    /**
     * Prints the list of registered participants to System.out.
     */
    public void viewRegisteredParticipants() {
        System.out.println("\n--- Registered Participants (" + registeredParticipants.size() + "/" + capacity + ") ---");
        if (registeredParticipants.isEmpty()) {
            System.out.println("No participants registered yet.");
        } else {
            for (int i = 0; i < registeredParticipants.size(); i++) {
                // Using get(i) is fine for ArrayList
                System.out.println((i + 1) + ". " + registeredParticipants.get(i));
            }
        }
        System.out.println("----------------------------------------------");
    }

    /**
     * Prints the list of participants on the waiting list to System.out.
     */
    public void viewWaitingList() {
        System.out.println("\n--- Waiting List (" + waitingList.size() + " participants) ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate without removing elements from the queue
            int i = 1;
            for (Participant p : waitingList) {
                 System.out.println((i++) + ". " + p);
            }
        }
         System.out.println("-------------------------------------------");
    }

    /**
     * Prints a summary of the event status to System.out.
     */
    public void viewEventSummary() {
        System.out.println("\n--- Event Summary: " + name + " ---");
        System.out.println("Capacity: " + capacity);
        System.out.println("Registered: " + registeredParticipants.size());
        System.out.println("On Waiting List: " + waitingList.size());
        System.out.println("Available Slots: " + (capacity - registeredParticipants.size()));
        System.out.println("-------------------------------------");
    }
}

// 3. EventManagementSystem Class (Main Application)
public class EventManagementSystem {

    // Private helper method to print the menu
    private static void printMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Register Participant");
        System.out.println("2. Cancel Registration");
        System.out.println("3. View Registered Participants");
        System.out.println("4. View Waiting List");
        System.out.println("5. View Event Summary");
        System.out.println("6. Exit");
        System.out.println("-----------------------------");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Instantiate an Event with a small capacity for demonstration
        Event event = new Event("Java Advanced Concepts Workshop", 3);

        System.out.println("Welcome to the Event Management System for: " + event.getName());
        System.out.println("Event Capacity: " + event.getCapacity());

        // Class-wide exception handling block wrapping the main operational loop
        try {
            while (true) {
                printMenu();
                System.out.print("Enter your choice: ");
                int choice = -1; // Initialize choice

                // Inner try-catch for reading the integer choice specifically
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }


                switch (choice) {
                    case 1: // Register Participant
                        System.out.print("Enter participant name: ");
                        String name = scanner.nextLine();
                        System.out.print("Enter participant ID: ");
                        String id = scanner.nextLine();

                        // Basic input validation for non-empty fields
                        if (name.trim().isEmpty() || id.trim().isEmpty()) {
                            System.err.println("Error: Participant name and ID cannot be empty.");
                        } else {
                            Participant newParticipant = new Participant(name.trim(), id.trim());
                            event.registerParticipant(newParticipant); // Delegate logic to Event class
                        }
                        break;

                    case 2: // Cancel Registration
                        System.out.print("Enter participant ID to cancel: ");
                        String cancelId = scanner.nextLine();

                         // Basic input validation
                        if (cancelId.trim().isEmpty()) {
                            System.err.println("Error: Participant ID for cancellation cannot be empty.");
                        } else {
                            event.cancelRegistration(cancelId.trim()); // Delegate logic to Event class
                        }
                        break;

                    case 3: // View Registered Participants
                        event.viewRegisteredParticipants();
                        break;

                    case 4: // View Waiting List
                        event.viewWaitingList();
                        break;

                    case 5: // View Event Summary
                        event.viewEventSummary();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Event Management System. Goodbye!");
                        return; // Exit the main method, terminating the program

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a blank line for better separation between operations

            } // End while loop
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        } finally {
             // Ensure the scanner is closed when the application exits the try block
             if (scanner != null) {
                scanner.close();
             }
        }
    }
}
