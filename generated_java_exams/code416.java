/*
 * Exam Question #416
 * Generated on: 2025-05-11 23:07:57
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application that simulates a system administrator's task processing queue. The application should allow the user to add new tasks to a queue, process the next task in the queue, view pending tasks, and view completed tasks.
 * 
 * Each task should have a unique ID, a description, and a priority level (an integer). Tasks are processed in a First-In, First-Out (FIFO) manner regardless of their priority. Completed tasks are moved to a separate list for historical tracking.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, input/output, flow control, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `priority` (int). Provide public getter methods for these fields.
 * 2.  **Task Management:** Create a `TaskProcessor` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold pending tasks.
 *     *   It must use a `java.util.List<Task>` (implemented by `java.util.ArrayList<Task>`) to store completed tasks.
 *     *   Include methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` with a unique ID and adds it to the pending task queue.
 *         *   `processNextTask()`: Removes the next task from the queue and adds it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` view of the pending tasks in the queue (without removing them).
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 3.  **User Interface:** Implement a console-based menu using `java.util.Scanner` to interact with the user. The menu options should include:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 4.  **Flow Control:** Use a `switch` statement to handle the user's menu choice.
 * 5.  **Input Validation:** Validate user input for task details (e.g., description not empty, priority is a positive integer). Validate menu choices.
 * 6.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly around user input (e.g., `InputMismatchException`).
 *     *   Implement "class-wide" exception handling within the main application loop to catch unexpected errors gracefully.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue).
 *     *   Use `System.out` for normal output (menu, prompts, task details, success messages).
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Structure the code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and provide appropriate feedback or display lists of tasks. Error conditions (like invalid input or processing an empty queue) should be reported to `System.err`.
 * 
 * Example interaction:
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Fix database connection
 * Enter task priority (integer): 1
 * Task added: Task{id=1, description='Fix database connection', priority=1}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Update server software
 * Enter task priority (integer): 2
 * Task added: Task{id=2, description='Update server software', priority=2}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=1, description='Fix database connection', priority=1}
 * Task{id=2, description='Update server software', priority=2}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Task{id=1, description='Fix database connection', priority=1}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=2, description='Update server software', priority=2}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=1, description='Fix database connection', priority=1}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Task{id=2, description='Update server software', priority=2}
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Error: No pending tasks to process.
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processor.
 * ```
 *
 * EXPLANATION:
 * This solution implements the `Task Processor` application as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and `priority`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods (`getId`, `getDescription`, `getPriority`) provide controlled access to the data.
 *     *   `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the state of the application: pending tasks and completed tasks.
 *     *   `taskQueue`: Declared as `Queue<Task>` and initialized with `LinkedList<Task>`. `LinkedList` is a common implementation of `Queue` and provides the required FIFO behavior. `offer()` and `poll()` methods are used for adding and removing elements from the queue's head.
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `ArrayList<Task>`. `ArrayList` provides a dynamic, index-based list to store completed tasks. `add()` is used to append completed tasks.
 *     *   `nextTaskId`: A simple counter to ensure each task gets a unique ID.
 *     *   `addTask()`: Creates a new `Task` object, performs basic validation on the input description and priority (checking for null/empty description and positive priority), and adds the valid task to the `taskQueue` using `offer()`. It returns the added task or `null` on validation failure.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to get and remove the head of the queue. It checks if the result is `null` (meaning the queue was empty) and prints an error to `System.err` if so. Otherwise, it adds the processed task to the `completedTasks` list and returns the task.
 *     *   `getPendingTasks()`: Returns a *new* `ArrayList` populated with the elements from the `taskQueue`. This is a good practice to prevent external code from directly modifying the internal queue structure.
 *     *   `getCompletedTasks()`: Returns the `completedTasks` `ArrayList`. While returning the actual list allows external modification, it fulfills the requirement of using `List` and `ArrayList` for storage and retrieval in this context.
 * 
 * 3.  **`TaskProcessorApp` (Main Class):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   `Scanner`: An instance is created to read user input from `System.in`.
 *     *   `TaskProcessor`: An instance is created to handle task logic.
 *     *   Main Loop (`while(running)`): Keeps the application running until the user chooses to exit.
 *     *   `printMenu()`: A helper method to display the menu options.
 *     *   **Input Handling and `try-catch`:**
 *         *   A `try-catch` block specifically surrounds `scanner.nextInt()` when reading the menu choice to catch `InputMismatchException` if the user enters non-integer input. If caught, an error is printed to `System.err`, the invalid input is consumed using `scanner.nextLine()`, and `continue` restarts the loop, showing the menu again.
 *         *   Similar `try-catch` is used when reading the task priority to handle non-integer input specifically for that field.
 *     *   **`switch` Statement:** Processes the validated integer `choice` from the user, calling the appropriate methods on the `TaskProcessor` instance.
 *     *   **`System.out` vs. `System.err`:** `System.out.println()` is used for printing the menu, prompts, successful task operations, and listing tasks. `System.err.println()` is used exclusively for printing error messages (invalid input, empty queue processing, validation errors).
 *     *   **Class-wide Exception Handling:** The main `while` loop is enclosed within a larger `try-catch(Exception e)` block. This block serves as a safety net to catch any unexpected or unhandled exceptions that might occur within the main application flow, preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 *     *   `finally` Block: Ensures that the `scanner` resource is closed properly when the application loop finishes or an unhandled exception occurs.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simplified, task management system, demonstrating key programming concepts like object-oriented design, data structures, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task (integer).
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The task priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               '}';
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class TaskProcessor {
    // Using LinkedList as a Queue implementation for FIFO behavior
    private Queue<Task> taskQueue;
    // Using ArrayList as a List implementation for storing completed tasks
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        taskQueue = new LinkedList<>();
        completedTasks = new ArrayList<>();
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Validates description and priority.
     * @param description The task description.
     * @param priority The task priority.
     * @return The newly added Task object, or null if validation fails.
     */
    public Task addTask(String description, int priority) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return null;
        }
        if (priority <= 0) {
            System.err.println("Error: Task priority must be a positive integer.");
            return null;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        taskQueue.offer(newTask); // offer() is generally preferred over add() for queues as it doesn't throw exceptions on capacity limits (though LinkedList doesn't have capacity limits)
        return newTask;
    }

    /**
     * Processes the next task in the queue (FIFO).
     * Removes the task from the queue and adds it to the completed list.
     * Handles the case where the queue is empty.
     * @return The processed Task object, or null if the queue was empty.
     */
    public Task processNextTask() {
        System.out.println("Processing next task...");
        Task taskToProcess = taskQueue.poll(); // Retrieves and removes the head of this queue, or returns null if this queue is empty.

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
            return null;
        } else {
            completedTasks.add(taskToProcess);
            return taskToProcess;
        }
    }

    /**
     * Returns a list view of the pending tasks.
     * Note: This returns a new ArrayList containing elements from the queue
     * to avoid exposing the internal queue structure directly and prevent
     * external modification of the queue itself.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        return new ArrayList<>(taskQueue); // Return a copy
    }

    /**
     * Returns the list of completed tasks.
     * Note: This returns the actual list, which could be modified externally.
     * For a more robust system, a copy should be returned.
     * However, for this exam, returning the list directly is acceptable
     * to demonstrate List usage.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Return the actual list
    }
}

/**
 * Main class to run the Task Processor application.
 * Handles user interaction and the main application loop.
 */
public class TaskProcessorApp {

    private static final int ADD_TASK = 1;
    private static final int PROCESS_TASK = 2;
    private static final int VIEW_PENDING = 3;
    private static final int VIEW_COMPLETED = 4;
    private static final int EXIT = 5;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor processor = new TaskProcessor();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = -1;

                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during input reading
                    System.err.println("An unexpected error occurred during input: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to error stream
                    running = false; // Consider stopping on unexpected errors
                    break; // Exit loop
                }

                // Process menu choice using switch
                switch (choice) {
                    case ADD_TASK:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        int priority = -1;
                        try {
                            System.out.print("Enter task priority (integer): ");
                            priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid priority input. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            continue; // Skip adding task and show menu again
                        }

                        Task addedTask = processor.addTask(description, priority);
                        if (addedTask != null) {
                            System.out.println("Task added: " + addedTask);
                        }
                        break;

                    case PROCESS_TASK:
                        Task processedTask = processor.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Task processed: " + processedTask);
                        }
                        break;

                    case VIEW_PENDING:
                        List<Task> pending = processor.getPendingTasks(); // Using List interface
                        System.out.println("Pending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("  No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println("  " + task);
                            }
                        }
                        break;

                    case VIEW_COMPLETED:
                        List<Task> completed = processor.getCompletedTasks(); // Using List interface
                        System.out.println("Completed Tasks:");
                        if (completed.isEmpty()) {
                            System.out.println("  No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println("  " + task);
                            }
                        }
                        break;

                    case EXIT:
                        running = false;
                        System.out.println("Exiting Task Processor.");
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between "
                                           + ADD_TASK + " and " + EXIT + ".");
                }
                System.out.println(); // Add a newline for better formatting between iterations
            }
        } catch (Exception e) {
            // This catch block handles any unexpected exceptions not caught elsewhere
            // It acts as a "class-wide" handler for the main loop
            System.err.println("An unrecoverable error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Processor Menu ---");
        System.out.println(ADD_TASK + ". Add New Task");
        System.out.println(PROCESS_TASK + ". Process Next Task");
        System.out.println(VIEW_PENDING + ". View Pending Tasks");
        System.out.println(VIEW_COMPLETED + ". View Completed Tasks");
        System.out.println(EXIT + ". Exit");
    }
}
