/*
 * Exam Question #396
 * Generated on: 2025-05-11 23:04:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Objective:** Design and implement a simplified Restaurant Order Management System in Java. This task requires you to demonstrate your understanding of core Java data structures, control flow, user input handling, and exception management within a practical, object-oriented context.
 * 
 * **Scenario:**
 * 
 * Imagine you are building the backend logic for a small restaurant. The system needs to handle incoming customer orders, manage them in a queue for the kitchen, track completed orders, and allow staff to view the menu and order statuses.
 * 
 * **Requirements:**
 * 
 * Your solution must implement a console-based application with the following features:
 * 
 * 1.  **Menu Management:**
 *     *   Maintain a list of available food items, each with a name and a price.
 *     *   Allow the user to display the current menu.
 * 2.  **Order Placement:**
 *     *   Allow the user to place a new order.
 *     *   An order should have a unique ID.
 *     *   Users should be able to add multiple items (selected from the menu by number) with specified quantities to a single order.
 *     *   Once the user finishes adding items, the complete order should be added to a waiting list for the kitchen.
 *     *   Handle cases where the user enters invalid menu item numbers or non-positive quantities.
 * 3.  **Kitchen Operations:**
 *     *   Allow the user (simulating kitchen staff) to process the "next" order. The system should take the order that has been waiting the longest from the queue.
 *     *   Move the processed order from the waiting queue to a list of completed orders.
 *     *   Handle the case where there are no orders waiting to be processed.
 * 4.  **Order Viewing:**
 *     *   Allow the user to view all orders currently waiting in the queue.
 *     *   Allow the user to view all orders that have been completed.
 * 5.  **User Interface:**
 *     *   Provide a main menu loop that presents options for the above actions (Display Menu, Place Order, Prepare Next Order, View Waiting Orders, View Completed Orders, Exit).
 *     *   Read user choices and input using a `Scanner`.
 * 
 * **Technical Constraints:**
 * 
 * Your solution MUST use ALL of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the orders waiting for preparation (First-In, First-Out behavior is essential here).
 * *   `java.util.ArrayList`: Used as the concrete implementation for at least two distinct collections within your system (e.g., the menu list, the completed orders list, or the list of items within an order).
 * *   `java.util.List` interface: Declare variables using the `List` interface type where appropriate (e.g., for collections that represent lists).
 * *   `java.util.Scanner`: For reading all user input from `System.in`.
 * *   `switch` statement: To control the flow based on the user's main menu choice.
 * *   `System.err`: To output all error messages (e.g., invalid input, operational errors like trying to prepare from an empty queue).
 * *   `System.out`: To output all normal information, prompts, menu displays, and successful operation messages.
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust exception handling, particularly around user input operations and potential runtime issues, covering the main application execution flow.
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation by declaring fields as `private` and providing public methods (getters, setters where appropriate, and operational methods).
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include comments to explain the purpose of classes, methods, and any non-obvious logic.
 * *   Perform input validation to ensure user input is in the correct format and within acceptable ranges (e.g., numbers for choices, positive quantities).
 * *   Handle edge cases gracefully (e.g., attempting to process an order when the queue is empty).
 * *   Structure your code into logical classes (e.g., separate classes for `MenuItem`, `Order`, and the main `RestaurantSystem`).
 * 
 * **Expected Output:**
 * 
 * The program should be interactive via the console. It should display clear prompts and output based on the user's selections. Error conditions should be reported using `System.err`. Successful operations and information displays should use `System.out`.
 * 
 * **Time Allotment:** This task is designed to be completed within 45-60 minutes. Focus on correctness, adherence to requirements, and demonstrating the required Java concepts.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Restaurant Order Management System, fulfilling all the requirements of the exam task.
 * 
 * **Core Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Design:** The problem is broken down into logical classes: `MenuItem`, `OrderItem`, `Order`, and `RestaurantSystem`. This demonstrates encapsulation (private fields with public getters/setters/methods) and modularity.
 * 2.  **Data Structures:**
 *     *   `java.util.Queue`: The `waitingOrders` field is declared as a `Queue<Order>` and instantiated as a `LinkedList`. This correctly uses the `Queue` interface and a common implementation (`LinkedList` provides efficient `offer` and `poll` operations needed for a queue). It ensures orders are processed in a FIFO (First-In, First-Out) manner.
 *     *   `java.util.ArrayList`: The `menu` and `completedOrders` fields are declared as `List` interfaces and instantiated as `ArrayList`. The `items` list within the `Order` class is also an `ArrayList`. This demonstrates the use of `ArrayList` for dynamic, index-based or simple list storage.
 *     *   `java.util.List` interface: Variables like `menu`, `completedOrders`, and `Order.items` are typed as `List`, adhering to the principle of programming to interfaces rather than concrete implementations where appropriate.
 * 3.  **User Input (`Scanner`):** A `Scanner` object is used to read integer choices and string inputs from the console (`System.in`). It is properly closed when the application exits.
 * 4.  **Control Flow (`switch`):** A `switch` statement in the `run()` method is used to direct the program flow based on the user's main menu selection, providing a clear structure for handling different commands.
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for all standard output, including displaying the menu, prompts, successful action messages, and details of orders.
 *     *   `System.err.println()` is specifically used for error messages, such as invalid menu choices, invalid quantities, or incorrect input types, clearly separating error output from normal program messages.
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the main application loop within the `run()` method. This serves as the "class-wide" exception handling, catching potential `InputMismatchException` specifically for the main menu choice input and a general `Exception` for any other unexpected errors that might propagate up.
 *     *   Additional `try-catch` blocks are used within the `placeOrder()` method to handle potential `InputMismatchException` when reading item choices or quantities, preventing the program from crashing on invalid input during order placement.
 *     *   The `scanner.nextLine()` calls after `nextInt()` are crucial for consuming the leftover newline character, preventing input issues in subsequent reads.
 * 7.  **Input Validation:** Checks are performed to ensure menu item numbers are within the valid range and quantities are positive before adding items to an order. `InputMismatchException` handling specifically validates that the input format is correct (i.e., a number is entered when expected).
 * 8.  **Edge Case Handling:** The code explicitly checks if the `waitingOrders` queue or `completedOrders` list are empty before attempting to view or process orders, providing user-friendly messages instead of errors. It also handles the case where a user starts placing an order but adds no items.
 * 9.  **Code Structure and Readability:**
 *     *   The code is divided into logical classes, each responsible for a specific part of the system.
 *     *   Methods have clear names reflecting their purpose (`displayMenu`, `placeOrder`, `prepareNextOrder`, etc.).
 *     *   Comments are included to explain the role of classes, methods, and important logic sections.
 *     *   String formatting (`String.format("%.2f", price)`) is used for currency display.
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a real-world scenario, demonstrating proficiency in fundamental and intermediate Java programming concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

/**
 * Represents a single menu item with a name and price.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The price.
     */
    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the menu item.
     * @return The formatted string (e.g., "Burger - $8.99").
     */
    @Override
    public String toString() {
        return name + " - $" + String.format("%.2f", price);
    }
}

/**
 * Represents an item and its quantity within a specific order.
 */
class OrderItem {
    private MenuItem item;
    private int quantity;

    /**
     * Constructs a new OrderItem.
     * @param item The menu item ordered.
     * @param quantity The quantity of the item.
     */
    public OrderItem(MenuItem item, int quantity) {
        this.item = item;
        this.quantity = quantity;
    }

    /**
     * Gets the menu item.
     * @return The MenuItem.
     */
    public MenuItem getItem() {
        return item;
    }

    /**
     * Gets the quantity of the item.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Calculates the subtotal for this order item (price * quantity).
     * @return The subtotal.
     */
    public double getSubtotal() {
        return item.getPrice() * quantity;
    }

    /**
     * Returns a string representation of the order item.
     * @return The formatted string (e.g., "2 x Burger ($17.98)").
     */
    @Override
    public String toString() {
        return quantity + " x " + item.getName() + " ($" + String.format("%.2f", getSubtotal()) + ")";
    }
}

/**
 * Represents a customer order containing multiple OrderItems.
 */
class Order {
    private int orderId;
    private List<OrderItem> items; // Use List interface, implemented by ArrayList
    private String status; // e.g., "Waiting", "Completed"

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for the order.
     */
    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // ArrayList is used for the list of items
        this.status = "Waiting";
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The List of OrderItem objects.
     */
    public List<OrderItem> getItems() {
        return items;
    }

    /**
     * Gets the current status of the order.
     * @return The status string.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the order.
     * @param status The new status string.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Adds a MenuItem with a specified quantity to the order.
     * @param item The MenuItem to add.
     * @param quantity The quantity to add. Must be positive.
     */
    public void addItem(MenuItem item, int quantity) {
        if (item != null && quantity > 0) {
            items.add(new OrderItem(item, quantity));
        } else if (quantity <= 0) {
             // While input validation is done in placeOrder(),
             // this provides a safeguard if called directly.
             System.err.println("Error adding item: Quantity must be positive.");
        } else {
             System.err.println("Error adding item: MenuItem cannot be null.");
        }
    }

    /**
     * Calculates the total price for the entire order.
     * @return The total price.
     */
    public double getTotal() {
        double total = 0;
        for (OrderItem item : items) {
            total += item.getSubtotal();
        }
        return total;
    }

    /**
     * Returns a detailed string representation of the order.
     * @return The formatted order details.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" [").append(status).append("]\n");
        if (items.isEmpty()) {
            sb.append("  (No items)");
        } else {
            for (OrderItem item : items) {
                sb.append("  ").append(item).append("\n");
            }
        }
        sb.append("  Total: $").append(String.format("%.2f", getTotal()));
        return sb.toString();
    }
}

/**
 * The main class managing the restaurant system operations.
 */
public class RestaurantSystem {
    private List<MenuItem> menu; // Use List interface, implemented by ArrayList
    private Queue<Order> waitingOrders; // Use Queue interface, implemented by LinkedList
    private List<Order> completedOrders; // Use List interface, implemented by ArrayList
    private Scanner scanner;
    private int nextOrderId;

    /**
     * Constructs a new RestaurantSystem, initializing collections and sample menu.
     */
    public RestaurantSystem() {
        // Initialize collections using concrete implementations
        menu = new ArrayList<>(); // ArrayList for menu
        waitingOrders = new LinkedList<>(); // LinkedList for queue
        completedOrders = new ArrayList<>(); // ArrayList for completed orders
        scanner = new Scanner(System.in);
        nextOrderId = 1;

        // Populate sample menu
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Salad", 7.25));
        menu.add(new MenuItem("Fries", 3.50));
        menu.add(new MenuItem("Drink", 2.00));
    }

    /**
     * Displays the current menu to the console.
     * Uses System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
        System.out.println("------------");
    }

    /**
     * Guides the user through placing a new order.
     * Interacts with Scanner, uses System.out and System.err, adds to Queue.
     */
    private void placeOrder() {
        System.out.println("\n--- Place New Order ---");
        Order currentOrder = new Order(nextOrderId); // Use nextId, but don't increment until order is validly placed
        boolean addingItems = true;
        boolean orderPlaced = false; // Flag to check if any items were added

        while (addingItems) {
            displayMenu();
            System.out.print("Enter menu item number to add (or 0 to finish order): ");
            try {
                int itemChoice = scanner.nextInt();
                scanner.nextLine(); // Consume newline character left by nextInt()

                if (itemChoice == 0) {
                    addingItems = false; // Exit the item selection loop
                    continue; // Skip to the check after the loop
                }

                // Validate menu item choice
                if (itemChoice < 1 || itemChoice > menu.size()) {
                    System.err.println("Invalid menu item number. Please try again.");
                    continue; // Ask for item again
                }

                MenuItem selectedItem = menu.get(itemChoice - 1);

                System.out.print("Enter quantity for " + selectedItem.getName() + ": ");
                int quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                // Validate quantity
                if (quantity <= 0) {
                    System.err.println("Quantity must be a positive number. Please try again.");
                    continue; // Ask for quantity again
                }

                currentOrder.addItem(selectedItem, quantity);
                System.out.println(quantity + " x " + selectedItem.getName() + " added to order #" + currentOrder.getOrderId() + ".");
                orderPlaced = true; // Mark that at least one item was added

            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected errors during item selection
                 System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                 // For this exam, we'll report and allow the user to try adding another item.
            }
        } // End of while(addingItems) loop

        // Check if the order has items before adding to queue
        if (orderPlaced && !currentOrder.getItems().isEmpty()) {
            waitingOrders.offer(currentOrder); // Add order to the waiting queue (offer is safe)
            System.out.println("Order #" + currentOrder.getOrderId() + " placed and added to waiting queue.");
            nextOrderId++; // Only increment ID if order was successfully placed with items
        } else {
            System.out.println("No items were added to the order. Order cancelled.");
            // nextOrderId is not incremented, so this ID can be reused
        }
    }

    /**
     * Processes the next order from the waiting queue.
     * Uses Queue poll(), adds to List, uses System.out.
     */
    private void prepareNextOrder() {
        System.out.println("\n--- Prepare Next Order ---");
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Order nextOrder = waitingOrders.poll();

        if (nextOrder == null) {
            System.out.println("No orders currently waiting in the queue."); // Status message, not an error
        } else {
            nextOrder.setStatus("Completed"); // Update order status
            completedOrders.add(nextOrder); // Add the completed order to the list
            System.out.println("Order #" + nextOrder.getOrderId() + " has been prepared and moved to completed orders.");
            System.out.println(nextOrder); // Print details of the completed order
        }
    }

    /**
     * Displays all orders currently in the waiting queue.
     * Iterates over Queue, uses System.out.
     */
    private void viewWaitingOrders() {
        System.out.println("\n--- Waiting Orders ---");
        if (waitingOrders.isEmpty()) {
            System.out.println("No orders currently waiting."); // Status message
        } else {
            // Iterate over the queue without removing elements
            int position = 1;
            for (Order order : waitingOrders) {
                System.out.println("Position " + position + ":");
                System.out.println(order);
                position++;
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all orders that have been completed.
     * Iterates over List, uses System.out.
     */
    private void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No orders have been completed yet."); // Status message
        } else {
            // Iterate over the completed orders list
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * The main application loop that handles user interaction.
     * Uses Scanner, switch, System.out, System.err, and try-catch for class-wide handling.
     */
    public void run() {
        int choice = -1;
        // Class-wide exception handling block around the main application loop
        try {
            while (choice != 0) {
                System.out.println("\n--- Restaurant System Menu ---");
                System.out.println("1. Display Menu");
                System.out.println("2. Place New Order");
                System.out.println("3. Prepare Next Order");
                System.out.println("4. View Waiting Orders");
                System.out.println("5. View Completed Orders");
                System.out.println("0. Exit");
                System.out.print("Enter your choice: ");

                // Handle potential InputMismatchException when reading choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline after reading integer

                    // Use switch statement for main menu navigation
                    switch (choice) {
                        case 1:
                            displayMenu();
                            break;
                        case 2:
                            placeOrder();
                            break;
                        case 3:
                            prepareNextOrder();
                            break;
                        case 4:
                            viewWaitingOrders();
                            break;
                        case 5:
                            viewCompletedOrders();
                            break;
                        case 0:
                            System.out.println("Exiting Restaurant System. Goodbye!");
                            break;
                        default:
                            // Invalid choice is an error
                            System.err.println("Invalid choice. Please enter a number between 0 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catching specific input type errors
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input to clear the scanner buffer
                    choice = -1; // Reset choice to ensure the loop continues and invalid input doesn't act as '0'
                }
                // Note: Other exceptions within the specific action methods (like placeOrder)
                // are caught locally within those methods. This outer catch is for
                // errors in the main loop itself or unhandled exceptions from methods.

            } // End of while loop
        } catch (Exception e) {
            // This block catches any other unexpected exceptions that might occur
            // outside the specific catches within the loop or methods.
            System.err.println("An unexpected critical error occurred:");
            e.printStackTrace(); // Print stack trace for debugging
            System.err.println("System is shutting down due to critical error.");
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * The main method to start the Restaurant System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run(); // Start the main application loop
    }
}
