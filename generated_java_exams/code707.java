/*
 * Exam Question #707
 * Generated on: 2025-05-12 16:28:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:** You are tasked with developing a simple command-line application to manage print jobs submitted by users. The system should allow users to add new print jobs to a queue, process the next job in the queue, view the list of pending jobs, and view the list of completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Print Job Representation:** Create a class or record `PrintJob` to represent a print job. Each job should have a unique integer ID, a file name (String), and the number of pages (int).
 * 2.  **Job Management Class:** Create a class `PrintJobManager` that will manage the print jobs.
 * 3.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store the pending print jobs. Jobs should be processed in the order they are submitted (FIFO - First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store the completed print jobs.
 *     *   Ensure that the list of completed jobs is declared using the `java.util.List` interface type.
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Present a menu of options to the user: Add New Job, Process Next Job, View Print Queue, View Completed Jobs, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 5.  **Functionality:**
 *     *   **Add New Job:** Prompt the user for the file name and number of pages. Create a new `PrintJob` object with a unique ID and add it to the pending job queue. Job IDs should be sequentially generated starting from 1.
 *     *   **Process Next Job:** Remove the job at the front of the queue and move it to the list of completed jobs. If the queue is empty, inform the user.
 *     *   **View Print Queue:** Display the details of all jobs currently in the pending queue, in their current order. Do not remove jobs from the queue when viewing.
 *     *   **View Completed Jobs:** Display the details of all jobs that have been processed and moved to the completed list.
 *     *   **Exit:** Terminate the application.
 * 6.  **Error Handling & Input Validation:**
 *     *   Implement input validation for adding a job: file name should not be empty, and page count must be a positive integer (> 0). Use `System.err` to report validation errors.
 *     *   Handle cases where the user tries to process a job when the queue is empty, reporting this using `System.err`.
 *     *   Handle invalid menu choices using `System.err`.
 *     *   Implement robust handling for non-integer input when a number is expected (e.g., menu choice, page count) using `try-catch` blocks and `Scanner`'s methods.
 *     *   Include a **class-wide exception handling** mechanism using a `try-catch` block within the `PrintJobManager`'s main execution method (`runManager`) to catch any unexpected runtime errors during the application's execution loop.
 * 7.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and job listings.
 *     *   Use `System.err` for all error messages and warnings.
 * 8.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadocs for methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should interact with the user via the console, presenting a menu, accepting input, and printing status messages, job lists, or error messages as described above. The output format for job listings should be clear, showing job ID, file name, and page count. Error messages must go to `System.err`.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * Print Job Manager Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter file name: document.txt
 * Enter number of pages: 5
 * Job #1 'document.txt' (5 pages) added to queue.
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 3
 * 
 * --- Print Queue ---
 * 1. Job #1 'document.txt' (5 pages)
 * -------------------
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 2
 * Processed job #1 'document.txt'.
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 3
 * 
 * --- Print Queue ---
 * Queue is empty.
 * -------------------
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 4
 * 
 * --- Completed Jobs ---
 * 1. Job #1 'document.txt' (5 pages)
 * ----------------------
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: invalid
 * Invalid input. Please enter a number. (This message goes to System.err)
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 2
 * Info: Print queue is empty. No jobs to process. (This message goes to System.err)
 * 
 * Print Job Manager Menu:
 * ...
 * Enter choice: 5
 * Exiting Print Job Manager.
 * Scanner closed.
 * ```
 * 
 * Your task is to write the complete Java code for the `PrintJob` (or record) and `PrintJobManager` classes, including a `main` method to start the application.
 *
 * EXPLANATION:
 * This solution implements a simple Print Job Management System using the required Java components and best practices.
 * 
 * 1.  **`PrintJob` Record:** A simple `PrintJob` record is defined to hold the data for each print job: `id`, `fileName`, and `pageCount`. Using a record is a modern, concise way to represent immutable data carriers.
 * 
 * 2.  **`PrintJobManager` Class:** This is the core class managing the application logic.
 *     *   **Encapsulation:** It has private fields (`jobQueue`, `completedJobs`, `nextJobId`) to protect its internal state. Public methods provide controlled access and functionality.
 *     *   **Data Structures:**
 *         *   `private Queue<PrintJob> jobQueue = new LinkedList<>();`: A `LinkedList` is used here because it efficiently implements the `Queue` interface, providing FIFO behavior suitable for a print queue. `offer()` is used to add jobs to the tail, and `poll()` is used to remove jobs from the head.
 *         *   `private List<PrintJob> completedJobs = new ArrayList<>();`: An `ArrayList` is used to store completed jobs. It's declared using the `List` interface type, demonstrating polymorphism and good practice. `add()` is used to append completed jobs.
 *     *   **`nextJobId`:** A private instance variable `nextJobId` is used to generate unique, sequential IDs for each new job, managed by the `PrintJobManager`.
 *     *   **Methods:**
 *         *   `addJob(String fileName, int pageCount)`: Creates a new `PrintJob` with the next available ID and adds it to the `jobQueue`. Includes validation for `fileName` and `pageCount` using `System.err` for error messages.
 *         *   `processNextJob()`: Removes the first job from `jobQueue` using `poll()`. If `poll()` returns `null` (queue is empty), it prints an info message to `System.err`. Otherwise, it adds the processed job to `completedJobs`.
 *         *   `viewQueue()`: Iterates through the `jobQueue` (using a standard for-each loop, which is safe for reading `LinkedList` elements without removing them) and prints job details to `System.out`. Checks if the queue is empty.
 *         *   `viewCompletedJobs()`: Iterates through the `completedJobs` list and prints job details to `System.out`. Checks if the list is empty.
 *         *   `displayMenu()`: A private helper method to print the menu options to `System.out`.
 *         *   `runManager()`: This is the main method containing the application's interactive loop.
 *             *   It uses `Scanner` to read user input.
 *             *   A `while` loop keeps the application running until the user chooses to exit.
 *             *   A `try-catch (InputMismatchException e)` block is used specifically to handle cases where the user enters non-integer input when a number (like the menu choice or page count) is expected. It prints an error to `System.err` and consumes the invalid input from the `Scanner` to prevent an infinite loop.
 *             *   A `switch` statement handles the different menu options, calling the appropriate methods based on the user's valid numerical input.
 *             *   The `default` case in the `switch` handles invalid numerical choices, printing an error to `System.err`.
 *             *   **Class-wide Exception Handling:** A larger `try { ... } catch (Exception e) { ... }` block wraps the entire `while` loop inside `runManager`. This serves as a catch-all for any unexpected `RuntimeException` or other `Exception` that might occur during the execution of the main application logic, providing a basic level of robustness and preventing the program from crashing silently. It prints a generic error message to `System.err`.
 *             *   A `finally` block ensures that the `Scanner` resource is closed properly when the `runManager` method exits, regardless of whether it exits normally or due to an exception.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates an instance of `PrintJobManager` and calls its `runManager()` method to start the interactive loop.
 * 
 * 3.  **System.out vs. System.err:** `System.out.println` is used for standard output like the menu, prompts, and successful operation confirmations. `System.err.println` is strictly used for error messages, warnings, and informational messages about error conditions (like an empty queue when trying to process).
 * 
 * 4.  **Best Practices:**
 *     *   **Meaningful Names:** Variable names (`jobQueue`, `completedJobs`, `fileName`, `pageCount`, `nextJobId`, `choice`) and method names (`addJob`, `processNextJob`, `viewQueue`, `runManager`, `displayMenu`) clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are provided for the class and key public methods, explaining their purpose and parameters. Inline comments clarify specific logic.
 *     *   **Input Validation & Error Handling:** Specific checks are made for valid file names and positive page counts. `InputMismatchException` is explicitly caught for numerical inputs. Empty queue condition is handled. The general `try-catch` in `runManager` provides a safety net.
 *     *   **Clean Code Structure:** The code is organized into logical methods, separating concerns like adding, processing, viewing, and running the main loop. The `PrintJob` record keeps data representation separate.
 * 
 * This solution effectively integrates the required Java components to build a functional, interactive system with basic error handling and adherence to good programming practices, making it a suitable challenge for an advanced Java exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with an ID, file name, and page count.
 * Using a Java Record for conciseness.
 */
record PrintJob(int id, String fileName, int pageCount) {
    // Record automatically provides constructor, getters, toString, equals, hashCode.
    // Validation for pageCount can be done before creating the record instance.
}

/**
 * Manages a queue of print jobs and a list of completed jobs.
 * Provides an interactive command-line interface.
 */
public class PrintJobManager {

    private Queue<PrintJob> jobQueue; // Queue for pending jobs (FIFO)
    private List<PrintJob> completedJobs; // List for completed jobs
    private int nextJobId; // Counter for generating unique job IDs

    /**
     * Constructs a new PrintJobManager.
     * Initializes the job queue and completed jobs list.
     */
    public PrintJobManager() {
        this.jobQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue after validating input.
     *
     * @param fileName  The name of the file to print.
     * @param pageCount The number of pages in the job.
     */
    public void addJob(String fileName, int pageCount) {
        // Input validation
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }
        if (pageCount <= 0) {
            System.err.println("Error: Page count must be a positive integer.");
            return;
        }

        // Create and add the new job
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim(), pageCount);
        jobQueue.offer(newJob); // Use offer for adding to queue
        System.out.println("Job #" + newJob.id() + " '" + newJob.fileName() + "' (" + newJob.pageCount() + " pages) added to queue.");
    }

    /**
     * Processes the next job at the front of the queue by moving it
     * from the pending queue to the completed jobs list.
     */
    public void processNextJob() {
        PrintJob jobToProcess = jobQueue.poll(); // Retrieve and remove head of queue
        if (jobToProcess != null) {
            completedJobs.add(jobToProcess);
            System.out.println("Processed job #" + jobToProcess.id() + " '" + jobToProcess.fileName() + "'.");
        } else {
            System.err.println("Info: Print queue is empty. No jobs to process.");
        }
    }

    /**
     * Displays the details of all jobs currently in the pending print queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Print Queue ---");
        if (jobQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            int position = 1;
            // Iterating over a LinkedList (used as Queue) is safe for reading elements
            for (PrintJob job : jobQueue) {
                System.out.println(position + ". Job #" + job.id() + " '" + job.fileName() + "' (" + job.pageCount() + " pages)");
                position++;
            }
        }
        System.out.println("-------------------");
    }

    /**
     * Displays the details of all jobs that have been processed and completed.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs completed yet.");
        } else {
            int position = 1;
            // Iterating over an ArrayList is straightforward
            for (PrintJob job : completedJobs) {
                System.out.println(position + ". Job #" + job.id() + " '" + job.fileName() + "' (" + job.pageCount() + " pages)");
                position++;
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Runs the main interactive loop for the Print Job Manager application.
     * Handles user input, menu navigation, and general exception handling.
     */
    public void runManager() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling wrapping the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;

                // Handle potential InputMismatchException for menu choice
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of this loop iteration and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add New Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        int pageCount = 0;
                        boolean validPageInput = false;
                        // Loop until valid page count is entered
                        while (!validPageInput) {
                            System.out.print("Enter number of pages: ");
                            try {
                                pageCount = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                // Validation handled in addJob, but basic type/range check here
                                if (pageCount > 0) {
                                    validPageInput = true;
                                } else {
                                    System.err.println("Page count must be positive.");
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid input. Please enter a whole number for pages.");
                                scanner.nextLine(); // Consume invalid input
                            }
                        }
                        addJob(fileName, pageCount); // Add job with validated inputs
                        break;
                    case 2: // Process Next Job
                        processNextJob();
                        break;
                    case 3: // View Print Queue
                        viewQueue();
                        break;
                    case 4: // View Completed Jobs
                        viewCompletedJobs();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Print Job Manager.");
                        break;
                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the loop
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner resource is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation message
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Job Manager Menu ---");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("------------------------------");
    }

    /**
     * The main method to start the Print Job Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.runManager(); // Start the main application loop
    }
}
