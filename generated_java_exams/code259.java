/*
 * Exam Question #259
 * Generated on: 2025-05-11 22:45:53
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** Hospital Walk-in Patient Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage walk-in patients at a hospital clinic. The system should keep track of patients waiting to be seen and those who have already been seen.
 * 
 * The application must present a menu-driven interface to the user, allowing them to perform the following actions:
 * 1.  Add a new walk-in patient to the waiting list.
 * 2.  Call the next patient from the waiting list to be seen.
 * 3.  View the current waiting list.
 * 4.  View the list of patients who have been seen.
 * 5.  Exit the application.
 * 
 * The system should use appropriate data structures to model the waiting line (first-in, first-out) and the list of seen patients. It must handle user input correctly, display informative messages, and manage errors gracefully.
 * 
 * **Specific Requirements:**
 * 
 * 1.  Create a `Patient` class with private fields for `id` (integer) and `name` (String). Include a constructor and public getter methods. Assign unique sequential IDs to patients as they are created.
 * 2.  Create a `HospitalManager` class that contains the main application logic.
 * 3.  Inside `HospitalManager`, use a `java.util.Queue<Patient>` to represent the waiting list.
 * 4.  Inside `HospitalManager`, use a `java.util.List<Patient>` (specifically, an `ArrayList`) to represent the list of seen patients.
 * 5.  Use `java.util.Scanner` to read user input from the console.
 * 6.  Implement the menu logic using a `switch` statement.
 * 7.  Display normal application output (menu, prompts, confirmations, lists) using `System.out`.
 * 8.  Display error messages (e.g., invalid input, trying to call a patient when the queue is empty) using `System.err`.
 * 9.  Implement class-wide exception handling within the `HospitalManager` class's main execution method (`run` or similar) using `try-catch` blocks to catch unexpected runtime errors. Also, handle specific expected exceptions like `InputMismatchException` during input reading.
 * 10. Ensure best practices are followed:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments.
 *     *   Input validation (e.g., non-empty patient name, valid menu choice).
 *     *   Proper error handling (using `System.err`, handling specific error conditions).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should start, display the menu, and respond to user input.
 * - Adding a patient should prompt for a name and confirm the addition with patient details.
 * - Calling the next patient should remove the head of the queue, add it to the seen list, and confirm which patient was called. If the queue is empty, an error message should be printed to `System.err`.
 * - Viewing lists should print the current contents of the respective data structure, indicating if they are empty.
 * - Invalid menu choices or non-integer input should result in an error message on `System.err`, and the menu should reappear.
 * - The program should exit cleanly when option 5 is chosen.
 * - Unexpected exceptions should be caught and reported to `System.err`.
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Hospital Walk-in Patient Management system as described in the problem. It demonstrates the required Java concepts and follows best practices.
 * 
 * 1.  **`Patient` Class:** This class encapsulates patient data (`id` and `name`). A static counter `nextId` ensures each patient gets a unique sequential ID upon creation. Private fields and public getters adhere to encapsulation principles.
 * 
 * 2.  **`HospitalManager` Class:** This is the main class containing the application logic.
 *     *   **Data Structures:**
 *         *   `walkInQueue`: Declared as a `Queue<Patient>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of `Queue` and provides efficient add/remove operations at its ends, suitable for simulating a waiting line (FIFO - First-In, First-Out). The `add()` method adds patients to the tail, and `poll()` removes from the head.
 *         *   `seenPatients`: Declared as a `List<Patient>` and initialized with an `ArrayList`. `ArrayList` is suitable for storing the seen patients as order matters (order seen), and we might need to iterate or access them by index (though not strictly required by the problem, it's a capability of `List`/`ArrayList`).
 *     *   **`Scanner`:** An instance of `Scanner` is used to read user input from `System.in`. It's closed in the `finally` block to release system resources.
 *     *   **`displayMenu()`:** A private helper method to print the menu options to `System.out`.
 *     *   **`addWalkInPatient()`:** Reads the patient's name, performs basic validation (checks if empty), creates a `Patient` object, and adds it to the `walkInQueue` using `queue.add()`. Confirms the action on `System.out`. Includes `scanner.nextLine()` after `scanner.nextInt()` in the main loop to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   **`callNextWalkIn()`:** Checks if the `walkInQueue` is empty. If not, it removes the next patient using `queue.poll()`, adds them to the `seenPatients` list using `list.add()`, and confirms the action on `System.out`. If the queue is empty, it prints an error message to `System.err`. `poll()` is used over `remove()` because it returns `null` if the queue is empty, which is checked explicitly, avoiding a `NoSuchElementException`.
 *     *   **`viewWaitingList()`:** Iterates through the `walkInQueue` using an enhanced for loop (which does not remove elements) and prints each patient to `System.out`. Indicates if the list is empty.
 *     *   **`viewSeenPatients()`:** Iterates through the `seenPatients` `ArrayList` using an index-based for loop (demonstrating list access) and prints each patient to `System.out`. Indicates if the list is empty.
 *     *   **`run()`:** This is the main execution method. It contains the application loop (`while (!exit)`).
 *         *   **`switch` Statement:** The user's menu choice is read and a `switch` statement is used to direct execution to the appropriate method (`addWalkInPatient`, `callNextWalkIn`, etc.). The `default` case handles invalid integer choices.
 *         *   **Input Validation:** The `InputMismatchException` is caught specifically inside the loop's `try` block. This is crucial for handling non-integer input from `scanner.nextInt()` and preventing an infinite loop by consuming the invalid input (`scanner.nextLine()`). An error message is printed to `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while` loop within `run()` is wrapped in an outer `try-catch(Exception e)`. This demonstrates catching any other unexpected runtime exceptions that might occur during the application's execution at a high level within the `HospitalManager` class, printing an error message and stack trace to `System.err`.
 *         *   **`finally` Block:** Ensures the `scanner` resource is closed regardless of whether an exception occurred or the loop exited normally.
 * 
 * 3.  **`main()` Method:** The entry point of the application. It creates an instance of `HospitalManager` and calls its `run()` method to start the system.
 * 
 * This solution effectively uses all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrates good object-oriented principles, handles input validation and errors, and provides a clean structure suitable for an exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // For handling Queue.remove/element if used, though poll is safer

/**
 * Represents a patient with an ID and name.
 */
class Patient {
    private static int nextId = 1; // Static counter for unique patient IDs
    private int id;
    private String name;

    /**
     * Constructs a new Patient with a unique ID.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.name = name;
    }

    /**
     * Gets the patient's ID.
     * @return The patient ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the patient's name.
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a string representation of the Patient.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

/**
 * Manages the hospital walk-in patient queue and seen patients list.
 */
class HospitalManager {
    // Queue for patients waiting to be seen (FIFO)
    private Queue<Patient> walkInQueue;
    // List for patients who have been seen
    private List<Patient> seenPatients; // Using List interface, implemented by ArrayList
    private Scanner scanner;

    /**
     * Constructs a new HospitalManager, initializing data structures and scanner.
     */
    public HospitalManager() {
        // LinkedList is a common implementation of Queue
        this.walkInQueue = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.seenPatients = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Walk-in Manager ---");
        System.out.println("1. Add Walk-in Patient");
        System.out.println("2. Call Next Walk-in Patient");
        System.out.println("3. View Waiting List");
        System.out.println("4. View Seen Patients");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new walk-in patient to the waiting queue based on user input.
     */
    private void addWalkInPatient() {
        System.out.print("Enter patient name: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String name = scanner.nextLine();

        // Input validation for name
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return; // Exit method if name is invalid
        }

        Patient patient = new Patient(name.trim());
        walkInQueue.add(patient); // Add patient to the end of the queue
        System.out.println("Added walk-in patient to queue: " + patient);
    }

    /**
     * Calls the next patient from the waiting queue.
     * Removes the patient from the queue and adds them to the seen list.
     * Handles the case where the queue is empty.
     */
    private void callNextWalkIn() {
        if (walkInQueue.isEmpty()) {
            System.err.println("Error: No walk-in patients currently waiting.");
            return; // Exit method if queue is empty
        }

        // poll() retrieves and removes the head of the queue, returns null if empty (handled above)
        Patient nextPatient = walkInQueue.poll();
        seenPatients.add(nextPatient); // Add the patient to the seen list
        System.out.println("Calling next patient from queue: " + nextPatient);
    }

    /**
     * Displays the current list of patients in the waiting queue.
     */
    private void viewWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (walkInQueue.isEmpty()) {
            System.out.println("The waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements using enhanced for loop
            int position = 1;
            for (Patient p : walkInQueue) {
                System.out.println(position++ + ". " + p);
            }
        }
    }

    /**
     * Displays the list of patients who have been seen.
     */
    private void viewSeenPatients() {
        System.out.println("\n--- Seen Patients ---");
        if (seenPatients.isEmpty()) {
            System.out.println("No patients have been seen yet.");
        } else {
            // Iterate through the List using index-based loop
            for (int i = 0; i < seenPatients.size(); i++) {
                System.out.println((i + 1) + ". " + seenPatients.get(i));
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction and exceptions.
     * Demonstrates class-wide exception handling by wrapping the main loop.
     */
    public void run() {
        int choice = 0;
        boolean exit = false;

        // Class-wide exception handling for the main operational loop
        try {
            while (!exit) {
                displayMenu();

                try {
                    // Read user choice (expecting an integer)
                    choice = scanner.nextInt();

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addWalkInPatient();
                            break;
                        case 2:
                            callNextWalkIn();
                            break;
                        case 3:
                            viewWaitingList();
                            break;
                        case 4:
                            viewSeenPatients();
                            break;
                        case 5:
                            System.out.println("Exiting Hospital Walk-in Manager. Goodbye!");
                            exit = true; // Set exit flag to true to end the loop
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                }
                // Note: Specific operation errors (like NoSuchElementException from Queue.remove() if used)
                // could be caught here or allowed to propagate to the outer catch depending on desired granularity.
                // Using poll() for queue removal avoids NoSuchElementException on empty queue,
                // making the specific empty check sufficient.
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions that might occur
            System.err.println("An unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure resources like Scanner are closed properly
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner resource closed."); // Optional confirmation
            }
        }
    }

    /**
     * The main method to start the Hospital Management application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalManager manager = new HospitalManager();
        manager.run(); // Start the application loop
    }
}
