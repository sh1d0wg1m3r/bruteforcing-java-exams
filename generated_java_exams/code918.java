/*
 * Exam Question #918
 * Generated on: 2025-05-12 16:59:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam: Conference Session Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Conference Session Management System. The system should allow managing different sessions, registering attendees for these sessions, and handling waiting lists if sessions become full. The system will interact with the user via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Entities:**
 *     *   A `Session` class representing a single conference session. It must include:
 *         *   Session name (String).
 *         *   Maximum capacity (int).
 *         *   A list of registered attendee names (List<String>).
 *         *   A queue of attendee names on the waiting list if the session is full (Queue<String>).
 *         *   Methods to add an attendee (registering or adding to waiting list), check if the session is full, get current registered count, and potentially move attendees from the waiting list if space becomes available (though for simplicity in this exam, focus on adding and listing).
 *         *   Proper encapsulation (private fields, public getters).
 *     *   An `EventManager` class that manages a collection of `Session` objects. It must include:
 *         *   A list of all sessions (List<Session>).
 *         *   Methods to add a new session, find a session by name, register an attendee to a specific session, list all sessions, and list details of a specific session.
 *         *   Proper encapsulation.
 * 
 * 2.  **Functionality:**
 *     *   **Add Session:** Allow the user to add a new session by providing a name and capacity. Ensure session names are unique.
 *     *   **Register Attendee:** Allow the user to register an attendee by providing the attendee's name and the session name.
 *         *   If the session is not full, the attendee is added to the registered list.
 *         *   If the session is full, the attendee is added to the waiting list queue.
 *         *   Handle cases where the session does not exist or the attendee is already registered/on the waiting list.
 *     *   **List All Sessions:** Display a summary of all sessions, including the name, capacity, current registered count, and waiting list size.
 *     *   **List Session Details:** Display detailed information for a specific session, including the name, capacity, all registered attendees, and all attendees on the waiting list.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **Technical Constraints:**
 *     *   You **must** use `java.util.Queue` for the waiting list.
 *     *   You **must** use `java.util.ArrayList` for the list of registered attendees within a session.
 *     *   You **must** use `java.util.List` interface for the collection of sessions within the `EventManager`.
 *     *   You **must** use `java.util.Scanner` to read user input from the console.
 *     *   You **must** use a `switch` statement to handle the main menu options.
 *     *   You **must** use `System.err` to output error messages (e.g., session not found, invalid input, session full, duplicate session).
 *     *   You **must** use `System.out` to output normal messages (menu, prompts, successful operations, lists).
 *     *   You **must** implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid user input (`InputMismatchException`) or custom application-specific errors (e.g., `SessionNotFoundException`, `DuplicateSessionException`).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement input validation (e.g., non-negative capacity, non-empty names).
 *     *   Handle errors gracefully using exceptions and `System.err`.
 *     *   Organize code into logical classes.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu to the user. Based on the user's choice, it should perform the requested action and print results or error messages to the console using `System.out` or `System.err` as required.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 1
 * Enter session name: Java Basics
 * Enter session capacity: 5
 * Session 'Java Basics' with capacity 5 added successfully.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 1
 * Enter session name: Advanced Java
 * Enter session capacity: 3
 * Session 'Advanced Java' with capacity 3 added successfully.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Alice
 * Enter session name: Java Basics
 * Attendee Alice registered for 'Java Basics'.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Bob
 * Enter session name: Java Basics
 * Attendee Bob registered for 'Java Basics'.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 3
 * --- All Sessions ---
 * Session: Java Basics [Capacity: 5, Registered: 2, Waiting: 0]
 * Session: Advanced Java [Capacity: 3, Registered: 0, Waiting: 0]
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 4
 * Enter session name: Java Basics
 * --- Session Details: Java Basics ---
 * Capacity: 5
 * Registered Attendees: [Alice, Bob]
 * Waiting List: []
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Charlie
 * Enter session name: Java Basics
 * Attendee Charlie registered for 'Java Basics'.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: David
 * Enter session name: Java Basics
 * Attendee David registered for 'Java Basics'.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Eve
 * Enter session name: Java Basics
 * Attendee Eve registered for 'Java Basics'.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Frank
 * Enter session name: Java Basics
 * Session 'Java Basics' is full. Attendee Frank added to waiting list.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 3
 * --- All Sessions ---
 * Session: Java Basics [Capacity: 5, Registered: 5, Waiting: 1]
 * Session: Advanced Java [Capacity: 3, Registered: 0, Waiting: 0]
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 4
 * Enter session name: Java Basics
 * --- Session Details: Java Basics ---
 * Capacity: 5
 * Registered Attendees: [Alice, Bob, Charlie, David, Eve]
 * Waiting List: [Frank]
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 2
 * Enter attendee name: Grace
 * Enter session name: NonExistentSession
 * Error: Session 'NonExistentSession' not found.
 * 
 * --- Conference Session Management ---
 * 1. Add Session
 * 2. Register Attendee
 * 3. List All Sessions
 * 4. List Session Details
 * 5. Exit
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Correct implementation of `Session` and `EventManager` classes with proper encapsulation.
 * *   Accurate implementation of the required functionality (adding sessions, registering attendees, listing).
 * *   Effective handling of full sessions and waiting lists.
 * *   Robust input validation and error handling using exceptions and `System.err`.
 * *   Adherence to best practices (naming, comments, code structure).
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for this system. Organize your code into appropriate classes. Compile and run your code to ensure it meets all requirements and handles various scenarios, including errors.
 *
 * EXPLANATION:
 * The solution implements a Conference Session Management System as requested, demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Session`: Encapsulates the data and logic for a single session. It holds the session name, capacity, a `List<String>` (`ArrayList`) for registered attendees, and a `Queue<String>` (`LinkedList`) for the waiting list. Methods are provided for getting information (`getName`, `getCapacity`, `getRegisteredAttendees`, `getWaitingList`, `getCurrentAttendeesCount`, `isFull`) and for adding attendees (`addAttendee`), which handles the core logic of checking capacity and adding to the registered list or waiting list.
 *     *   `EventManager`: Manages a collection of `Session` objects using a `List<Session>` (`ArrayList`). It provides methods to add sessions, find sessions, register attendees (delegating to the `Session` object), list all sessions, and list details of a specific session.
 *     *   `ConferenceApp`: Contains the `main` method and the main application loop (`runMenu`). It interacts with the user via `Scanner`, calls methods on the `EventManager`, and handles displaying output and errors.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: Used in the `Session` class (`waitingList`) to maintain the order of attendees waiting for a spot. `LinkedList` is used as the concrete implementation of `Queue`.
 *     *   `ArrayList`: Used in the `Session` class (`registeredAttendees`) to store the list of attendees currently registered. It's also used in `EventManager` to store the collection of `Session` objects.
 *     *   `List interface`: Used in `EventManager` (`List<Session> sessions`) to declare the type of the collection holding sessions, adhering to the principle of programming to interfaces. It's also used in the `Session` class methods `getRegisteredAttendees` and `getWaitingList` to return a `List` view (a copy) of the internal collections.
 *     *   `Scanner`: Used in `ConferenceApp` to read user input from `System.in`.
 *     *   `Switch statement`: Used in the `runMenu` method of `ConferenceApp` to process the user's menu selection.
 *     *   `System.err`: Used throughout `ConferenceApp` to print error messages, such as invalid input, sessions not found, or attendees already registered/on the waiting list.
 *     *   `System.out`: Used throughout `ConferenceApp` to print normal output, such as the menu, prompts, success messages, and session lists/details.
 *     *   `Class-wide exception handling with try-catch blocks`: The `main` method in `ConferenceApp` has a `try-catch` block that wraps the call to `runMenu`. This provides a top-level handler for exceptions like `InputMismatchException` (which can occur if the user enters non-integer input when an integer is expected) or any other uncaught exceptions bubbling up. Additionally, `try-catch` blocks are used within the menu methods (`addSession`, `registerAttendee`, `listSessionDetails`) to handle specific exceptions thrown by the `EventManager` or `Session` classes, printing informative error messages using `System.err`.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Session` and `EventManager` are `private`. Access is provided through public getter methods where appropriate.
 *     *   **Meaningful Names:** Classes (`Session`, `EventManager`, `ConferenceApp`), fields (`name`, `capacity`, `registeredAttendees`, `waitingList`, `sessions`), and methods (`addAttendee`, `registerAttendeeToSession`, `listAllSessions`) have descriptive names.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and key methods explaining their purpose, parameters, and potential exceptions. Inline comments are used for specific logic points.
 *     *   **Input Validation:** Input validation is performed, for example, checking for non-positive capacity or null/empty names in the `Session` and `EventManager` classes, throwing `IllegalArgumentException`. The `Scanner` input for the menu choice is handled using `try-catch` for `InputMismatchException`.
 *     *   **Error Handling:** Custom exceptions (`SessionNotFoundException`, `AttendeeAlreadyRegisteredException`, `AttendeeAlreadyOnWaitingListException`) are defined to represent specific application-level errors. These are thrown by the `Session` and `EventManager` classes and caught in `ConferenceApp` to display user-friendly error messages using `System.err`.
 *     *   **Clean Code Structure:** The code is divided into logical classes, and methods perform single, well-defined tasks. The main application logic is separated from the data structure logic.
 * 
 * The solution successfully integrates the required Java components into a practical scenario, demonstrating an understanding of data structures, object-oriented design, exception handling, and user interaction via the console.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Custom exception for when a session is not found.
 */
class SessionNotFoundException extends Exception {
    public SessionNotFoundException(String message) {
        super(message);
    }
}

/**
 * Custom exception for when an attendee is already registered for a session.
 */
class AttendeeAlreadyRegisteredException extends Exception {
    public AttendeeAlreadyRegisteredException(String message) {
        super(message);
    }
}

/**
 * Custom exception for when an attendee is already on the waiting list for a session.
 */
class AttendeeAlreadyOnWaitingListException extends Exception {
    public AttendeeAlreadyOnWaitingListException(String message) {
        super(message);
    }
}

/**
 * Represents a single conference session with attendees and a waiting list.
 */
class Session {
    private String name;
    private int capacity;
    private List<String> registeredAttendees; // Using ArrayList as required
    private Queue<String> waitingList;       // Using Queue (LinkedList implementation) as required

    /**
     * Constructs a new Session.
     *
     * @param name     The name of the session.
     * @param capacity The maximum number of attendees for the session.
     * @throws IllegalArgumentException if capacity is non-positive.
     */
    public Session(String name, int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Session capacity must be positive.");
        }
        if (name == null || name.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name cannot be null or empty.");
        }
        this.name = name.trim();
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Initialize ArrayList
        this.waitingList = new LinkedList<>();      // Initialize Queue using LinkedList
    }

    // --- Getters ---
    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    /**
     * Returns an immutable view of the registered attendees list.
     * This prevents external modification of the internal list.
     * @return A list of registered attendee names.
     */
    public List<String> getRegisteredAttendees() {
        return new ArrayList<>(registeredAttendees); // Return a copy
    }

     /**
     * Returns an immutable view of the waiting list.
     * Note: Getting a view of a Queue is less standard than a List.
     * We'll return a copy of the current elements.
     * @return A list representation of the waiting list queue.
     */
    public List<String> getWaitingList() {
        return new ArrayList<>(waitingList); // Return a copy of elements
    }

    /**
     * Checks if the session is currently at maximum capacity.
     * @return true if the number of registered attendees equals the capacity, false otherwise.
     */
    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    /**
     * Gets the current number of registered attendees.
     * @return The count of registered attendees.
     */
    public int getCurrentAttendeesCount() {
        return registeredAttendees.size();
    }

    /**
     * Attempts to add an attendee to the session.
     * If the session is full, the attendee is added to the waiting list.
     *
     * @param attendeeName The name of the attendee to add.
     * @return true if the attendee was registered, false if added to the waiting list.
     * @throws AttendeeAlreadyRegisteredException If the attendee is already registered.
     * @throws AttendeeAlreadyOnWaitingListException If the attendee is already on the waiting list.
     * @throws IllegalArgumentException if attendeeName is null or empty.
     */
    public boolean addAttendee(String attendeeName) throws AttendeeAlreadyRegisteredException, AttendeeAlreadyOnWaitingListException {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
             throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        String nameToRegister = attendeeName.trim();

        if (registeredAttendees.contains(nameToRegister)) {
            throw new AttendeeAlreadyRegisteredException("Attendee '" + nameToRegister + "' is already registered for session '" + this.name + "'.");
        }
        if (waitingList.contains(nameToRegister)) {
            throw new AttendeeAlreadyOnWaitingListException("Attendee '" + nameToRegister + "' is already on the waiting list for session '" + this.name + "'.");
        }

        if (!isFull()) {
            registeredAttendees.add(nameToRegister);
            return true; // Registered successfully
        } else {
            waitingList.add(nameToRegister);
            return false; // Added to waiting list
        }
    }

    // Optional: Method to move from waiting list if space opens up
    // For this exam, the problem description doesn't explicitly require this
    // but a real system would need it. Leaving it out to meet exam scope.
    // public void processWaitingList() { ... }

    @Override
    public String toString() {
        return "Session: " + name + " [Capacity: " + capacity +
               ", Registered: " + registeredAttendees.size() +
               ", Waiting: " + waitingList.size() + "]";
    }
}

/**
 * Manages a collection of conference sessions.
 */
class EventManager {
    private List<Session> sessions; // Using List interface as required

    /**
     * Constructs a new EventManager.
     */
    public EventManager() {
        this.sessions = new ArrayList<>(); // Using ArrayList implementation
    }

    /**
     * Adds a new session to the manager.
     *
     * @param name     The name of the session.
     * @param capacity The capacity of the session.
     * @throws IllegalArgumentException If name is null/empty or capacity is non-positive.
     * @throws Exception If a session with the same name already exists.
     */
    public void addSession(String name, int capacity) throws Exception {
         if (name == null || name.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name cannot be null or empty.");
         }
         if (capacity <= 0) {
             throw new IllegalArgumentException("Session capacity must be positive.");
         }
        if (findSession(name) != null) {
            throw new Exception("Session with name '" + name + "' already exists."); // Using a generic Exception for duplicate
        }
        sessions.add(new Session(name, capacity));
    }

    /**
     * Finds a session by its name.
     *
     * @param name The name of the session to find.
     * @return The Session object if found, otherwise null.
     * @throws IllegalArgumentException if name is null or empty.
     */
    public Session findSession(String name) {
         if (name == null || name.trim().isEmpty()) {
             // While technically an error, returning null is also a valid "not found" indicator
             // depending on how the caller handles it. Let's let the caller handle null.
             return null;
         }
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(name.trim())) {
                return session;
            }
        }
        return null;
    }

    /**
     * Registers an attendee to a specific session.
     *
     * @param sessionName  The name of the session.
     * @param attendeeName The name of the attendee.
     * @return true if attendee was registered, false if added to waiting list.
     * @throws SessionNotFoundException If the session does not exist.
     * @throws AttendeeAlreadyRegisteredException If the attendee is already registered.
     * @throws AttendeeAlreadyOnWaitingListException If the attendee is already on the waiting list.
      * @throws IllegalArgumentException if names are null or empty.
     */
    public boolean registerAttendeeToSession(String sessionName, String attendeeName)
            throws SessionNotFoundException, AttendeeAlreadyRegisteredException, AttendeeAlreadyOnWaitingListException {

        if (sessionName == null || sessionName.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name cannot be null or empty.");
        }
         if (attendeeName == null || attendeeName.trim().isEmpty()) {
             throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }

        Session session = findSession(sessionName);
        if (session == null) {
            throw new SessionNotFoundException("Session '" + sessionName + "' not found.");
        }

        // Session's addAttendee method handles the full/waiting logic and attendee uniqueness
        return session.addAttendee(attendeeName);
    }

    /**
     * Lists summary details for all sessions.
     */
    public void listAllSessions() {
        if (sessions.isEmpty()) {
            System.out.println("No sessions available.");
            return;
        }
        System.out.println("--- All Sessions ---");
        for (Session session : sessions) {
            System.out.println(session); // Uses Session's toString()
        }
    }

    /**
     * Lists detailed information for a specific session.
     *
     * @param sessionName The name of the session.
     * @throws SessionNotFoundException If the session does not exist.
     * @throws IllegalArgumentException if sessionName is null or empty.
     */
    public void listSessionDetails(String sessionName) throws SessionNotFoundException {
         if (sessionName == null || sessionName.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name cannot be null or empty.");
        }

        Session session = findSession(sessionName);
        if (session == null) {
            throw new SessionNotFoundException("Session '" + sessionName + "' not found.");
        }

        System.out.println("--- Session Details: " + session.getName() + " ---");
        System.out.println("Capacity: " + session.getCapacity());
        System.out.println("Registered Attendees: " + session.getRegisteredAttendees());
        System.out.println("Waiting List: " + session.getWaitingList());
    }
}

/**
 * Main application class for the Conference Session Management System.
 */
public class ConferenceApp {

    private static EventManager eventManager = new EventManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Conference Session Management ---");

        // Class-wide exception handling for the main loop
        try {
            runMenu();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input type. Please enter a number for the menu choice.");
            // Consume the invalid input to prevent infinite loop
            scanner.next();
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
             // Ensure scanner is closed
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * Runs the main application menu loop.
     */
    private static void runMenu() {
        int choice = -1;
        while (choice != 5) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // May throw InputMismatchException
                scanner.nextLine(); // Consume newline left-over

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addSession();
                        break;
                    case 2:
                        registerAttendee();
                        break;
                    case 3:
                        listAllSessions();
                        break;
                    case 4:
                        listSessionDetails();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Caught by the main try-catch in main(), re-thrown or handled there
                throw e; // Re-throw to be caught by the outer try-catch in main
            } catch (IllegalArgumentException e) {
                 System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                 // Catch other specific exceptions like DuplicateSessionException etc.
                 System.err.println("Error: " + e.getMessage());
            }
            System.out.println(); // Add a newline for better readability between actions
        }
    }

    /**
     * Prints the main menu options.
     */
    private static void printMenu() {
        System.out.println("--- Conference Session Management ---");
        System.out.println("1. Add Session");
        System.out.println("2. Register Attendee");
        System.out.println("3. List All Sessions");
        System.out.println("4. List Session Details");
        System.out.println("5. Exit");
    }

    /**
     * Handles adding a new session based on user input.
     */
    private static void addSession() {
        System.out.print("Enter session name: ");
        String name = scanner.nextLine();

        int capacity = -1;
        System.out.print("Enter session capacity: ");
        try {
             capacity = scanner.nextInt();
             scanner.nextLine(); // Consume newline
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for capacity. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input line
            return; // Exit method
        }


        try {
            eventManager.addSession(name, capacity);
            System.out.println("Session '" + name + "' with capacity " + capacity + " added successfully.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error: " + e.getMessage());
        }
        catch (Exception e) { // Catches DuplicateSessionException specifically if using Exception
            System.err.println("Error: " + e.getMessage());
        }
    }

    /**
     * Handles registering an attendee to a session based on user input.
     */
    private static void registerAttendee() {
        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine();

        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();

        try {
            boolean registered = eventManager.registerAttendeeToSession(sessionName, attendeeName);
            if (registered) {
                System.out.println("Attendee " + attendeeName + " registered for '" + sessionName + "'.");
            } else {
                System.out.println("Session '" + sessionName + "' is full. Attendee " + attendeeName + " added to waiting list.");
            }
        } catch (IllegalArgumentException e) {
             System.err.println("Error: " + e.getMessage());
        } catch (SessionNotFoundException e) {
            System.err.println("Error: " + e.getMessage());
        } catch (AttendeeAlreadyRegisteredException | AttendeeAlreadyOnWaitingListException e) {
             System.err.println("Error: " + e.getMessage());
        }
    }

    /**
     * Handles listing all sessions.
     */
    private static void listAllSessions() {
        eventManager.listAllSessions();
    }

    /**
     * Handles listing details for a specific session based on user input.
     */
    private static void listSessionDetails() {
        System.out.print("Enter session name: ");
        String sessionName = scanner.nextLine();

        try {
            eventManager.listSessionDetails(sessionName);
        } catch (IllegalArgumentException e) {
             System.err.println("Error: " + e.getMessage());
        } catch (SessionNotFoundException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}
