/*
 * Exam Question #101
 * Generated on: 2025-05-11 22:14:24
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Technical Support Ticket System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based technical support ticket management system. The system should allow users (acting as system administrators) to:
 * 
 * 1.  **Add New Support Tickets:** Users can submit new tickets by providing a description and assigning a priority level (HIGH, MEDIUM, or LOW). New tickets are placed into a queue for processing.
 * 2.  **Process Next Ticket:** Support agents process tickets from the front of the pending queue. Once processed, the ticket is marked as complete.
 * 3.  **View All Tickets:** Users can view a list of all tickets ever submitted, including their ID, description, priority, and current status (pending or processed).
 * 4.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must strictly adhere to the following technical requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage tickets that are pending processing.
 *     *   Use `java.util.ArrayList` to store a historical record of *all* tickets ever created.
 *     *   Declare the variable holding the historical record using the `java.util.List` interface type.
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands and ticket details from standard input (`System.in`).
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and ticket information.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu selection.
 * 4.  **Error Handling:**
 *     *   Implement input validation for user commands and ticket details (e.g., valid priority string).
 *     *   Implement exception handling using `try-catch` blocks. A broad exception handler should be present at a high level (e.g., around the main operational loop) to demonstrate "class-wide" handling of unexpected issues.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `Ticket` class to represent a support ticket with appropriate fields (ID, description, priority, processed status) and methods (constructor, getters, `toString()`). Use proper encapsulation (private fields, public methods).
 *     *   Create a main class (`SupportSystem`) to manage the ticket queue and list, handle user interaction, and implement the system logic. Use private fields and public methods where appropriate.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are encouraged but not strictly required for all methods in an exam setting; inline comments for complex logic are sufficient).
 *     *   Ensure clean code structure.
 *     *   Handle the case of processing a ticket when the queue is empty gracefully.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's valid input, it should perform the requested action and provide feedback via `System.out` or `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working
 * Enter ticket priority (HIGH, MEDIUM, LOW): HIGH
 * Ticket #1 (HIGH) added successfully.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: Software installation failed
 * Enter ticket priority (HIGH, MEDIUM, LOW): MEDIUM
 * Ticket #2 (MEDIUM) added successfully.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Processing Ticket #1 (HIGH): My printer is not working
 * Ticket #1 processed.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 3
 * --- All Tickets ---
 * Ticket #1 [HIGH, Processed]: My printer is not working
 * Ticket #2 [MEDIUM, Pending]: Software installation failed
 * --- End of List ---
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid menu choice. Please enter a number between 1 and 4.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Processing Ticket #2 (MEDIUM): Software installation failed
 * Ticket #2 processed.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 2
 * Error: No tickets in the pending queue to process.
 * 
 * Technical Support Ticket System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View All Tickets
 * 4. Exit
 * Enter your choice: 4
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing the `Ticket` class and the `SupportSystem` class with the `main` method.
 *
 * EXPLANATION:
 * This solution implements a `SupportSystem` class that manages a queue of pending support tickets and a list of all tickets ever submitted.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with `ticketId`, `description`, `priority`, and `isProcessed` status.
 *     *   Uses private fields for encapsulation.
 *     *   Provides public getters and a setter for `isProcessed`.
 *     *   The constructor includes input validation for `description` and `priority`, throwing `IllegalArgumentException` if invalid.
 *     *   Includes a `toString()` method for easy printing of ticket details.
 *     *   The `isValidPriority` helper method demonstrates input validation logic.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTickets`: Declared as `Queue<Ticket>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for a waiting line.
 *         *   `allTickets`: Declared as `List<Ticket>` and initialized with `new ArrayList<>()`. `ArrayList` provides a dynamic array implementation suitable for storing a growing list of all historical tickets and allows easy iteration.
 *         *   `nextTicketId`: An integer counter to assign unique IDs to new tickets.
 *     *   **Constructor:** Initializes the queue, list, ticket ID counter, and the `Scanner` for user input.
 *     *   **`addTicket(String description, String priority)`:**
 *         *   Creates a new `Ticket` object. It wraps the ticket creation in a `try-catch` block to handle potential `IllegalArgumentException` thrown by the `Ticket` constructor if the input is invalid, printing the error to `System.err`.
 *         *   If the ticket is created successfully, it's added to the `pendingTickets` queue using `offer()` (which is generally preferred over `add()` in queues as it doesn't throw an exception if the queue is capacity-constrained, although `LinkedList` is not bounded).
 *         *   It's also added to the `allTickets` `List` using `add()`.
 *         *   The `nextTicketId` is incremented.
 *     *   **`processNextTicket()`:**
 *         *   Checks if the `pendingTickets` queue is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns.
 *         *   If not empty, it retrieves and removes the head of the queue using `poll()`. `poll()` returns `null` if the queue is empty, but the `isEmpty()` check prevents this in this logic path.
 *         *   Sets the `isProcessed` status of the retrieved ticket to `true`.
 *         *   Prints processing details to `System.out`.
 *     *   **`viewAllTickets()`:**
 *         *   Iterates through the `allTickets` `List` (declared as `List`, instantiated as `ArrayList`).
 *         *   Prints the `toString()` representation of each ticket to `System.out`.
 *     *   **`displayMenu()`:** A helper method to print the user menu to `System.out`.
 *     *   **`run()`:**
 *         *   Contains the main application loop (`while(true)`).
 *         *   **Class-wide Exception Handling:** The entire `while` loop (the core operational part of the system) is wrapped in a `try-catch(Exception e)` block. This demonstrates catching potentially unexpected exceptions that might occur during the system's runtime, printing a generic error message to `System.err`.
 *         *   Inside the loop, it displays the menu and reads user input using `scanner.nextLine()`.
 *         *   **Input Validation & Handling:** A nested `try-catch(NumberFormatException)` is used to ensure the user's menu input is a valid integer. If not, an error is printed to `System.err`, and the loop continues.
 *         *   **Control Flow:** A `switch` statement is used based on the valid integer choice to call the appropriate methods (`addTicket`, `processNextTicket`, `viewAllTickets`) or exit (`case 4` uses `return` to break out of the `run` method).
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *         *   **Resource Management:** A `finally` block ensures the `scanner` is closed when the `run` method exits (either by returning from case 4 or by an unexpected exception).
 *     *   **`main(String[] args)`:** The entry point of the application. It creates a `SupportSystem` instance and calls its `run()` method.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design, encapsulation, input validation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single support ticket
class Ticket {
    private int ticketId;
    private String description;
    private String priority; // HIGH, MEDIUM, LOW
    private boolean isProcessed;

    /**
     * Constructs a new Ticket.
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the issue.
     * @param priority The priority level (HIGH, MEDIUM, LOW).
     */
    public Ticket(int ticketId, String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        if (!isValidPriority(priority)) {
            throw new IllegalArgumentException("Invalid priority: " + priority + ". Must be HIGH, MEDIUM, or LOW.");
        }
        this.ticketId = ticketId;
        this.description = description.trim();
        this.priority = priority.toUpperCase();
        this.isProcessed = false;
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isProcessed() {
        return isProcessed;
    }

    // Setter for processed status
    public void setProcessed(boolean processed) {
        isProcessed = processed;
    }

    /**
     * Validates if the given priority string is one of the allowed values.
     * @param priority The priority string to validate.
     * @return true if valid, false otherwise.
     */
    private boolean isValidPriority(String priority) {
        if (priority == null) {
            return false;
        }
        String upperPriority = priority.toUpperCase();
        return upperPriority.equals("HIGH") || upperPriority.equals("MEDIUM") || upperPriority.equals("LOW");
    }

    @Override
    public String toString() {
        String status = isProcessed ? "Processed" : "Pending";
        return String.format("Ticket #%d [%s, %s]: %s",
                             ticketId, priority, status, description);
    }
}

// Manages the support ticket system
public class SupportSystem {
    private Queue<Ticket> pendingTickets;
    private List<Ticket> allTickets; // Declared using List interface
    private int nextTicketId;
    private Scanner scanner;

    /**
     * Constructs a new SupportSystem.
     */
    public SupportSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.allTickets = new ArrayList<>();
        this.nextTicketId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new ticket to the system.
     * @param description The ticket description.
     * @param priority The ticket priority (HIGH, MEDIUM, LOW).
     */
    public void addTicket(String description, String priority) {
        try {
            Ticket newTicket = new Ticket(nextTicketId, description, priority);
            pendingTickets.offer(newTicket); // Add to the end of the queue
            allTickets.add(newTicket);      // Add to the history list
            System.out.println("Ticket #" + nextTicketId + " (" + newTicket.getPriority() + ") added successfully.");
            nextTicketId++; // Increment for the next ticket
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding ticket: " + e.getMessage());
        }
    }

    /**
     * Processes the next ticket from the pending queue.
     */
    public void processNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("Error: No tickets in the pending queue to process.");
            return;
        }

        // Retrieve and remove the head of the queue
        Ticket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess != null) {
            ticketToProcess.setProcessed(true); // Mark as processed
            System.out.println("Processing " + ticketToProcess.toString());
            System.out.println("Ticket #" + ticketToProcess.getTicketId() + " processed.");
        }
        // Note: If poll returns null, it means the queue was empty, which is
        // already handled by the isEmpty check above.
    }

    /**
     * Displays all tickets ever created.
     */
    public void viewAllTickets() {
        System.out.println("--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets have been submitted yet.");
        } else {
            // Iterate through the List of all tickets
            for (Ticket ticket : allTickets) {
                System.out.println(ticket.toString());
            }
        }
        System.out.println("--- End of List ---");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTechnical Support Ticket System Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View All Tickets");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        // Class-wide exception handling around the main operational loop
        try {
            while (true) {
                displayMenu();
                String input = scanner.nextLine(); // Read the whole line

                int choice = -1; // Default to an invalid choice
                try {
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip to the next loop iteration
                }

                // Use a switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter ticket priority (HIGH, MEDIUM, LOW): ");
                        String priority = scanner.nextLine();
                        addTicket(description, priority);
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewAllTickets();
                        break;
                    case 4:
                        System.out.println("Exiting system.");
                        return; // Exit the run method, ending the program
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during system operation
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging purposes
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated.");
        }
    }

    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
