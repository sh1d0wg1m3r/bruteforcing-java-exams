/*
 * Exam Question #362
 * Generated on: 2025-05-11 23:00:23
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Network Packet Processing Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a network device that receives, queues, and processes data packets. Packets arrive in a stream and are placed in an incoming buffer (queue). The device processes packets one by one from the front of the queue based on their type. Some packets might be successfully processed, while others might indicate errors or require special handling. The system needs to track processed packets and log any processing errors.
 * 
 * **Task Requirements:**
 * 
 * Implement a Java program that simulates this network packet processing. Your program should:
 * 
 * 1.  Define a `Packet` class to represent a network packet. Each packet should have:
 *     *   An integer ID.
 *     *   A String type (e.g., "DATA", "CONTROL", "ERROR", "UNKNOWN").
 *     *   A String payload (representing the data).
 *     *   Appropriate constructor, getters, and a `toString()` method. Ensure packet IDs are positive.
 * 
 * 2.  Define a `PacketProcessor` class that manages the packet processing. This class should:
 *     *   Maintain a `Queue` of incoming `Packet` objects.
 *     *   Maintain a `List` of successfully processed `Packet` objects.
 *     *   Maintain a `List` of `String` messages representing processing errors.
 *     *   Provide a method to add a `Packet` to the incoming queue.
 *     *   Provide a method to process the next packet from the queue. This method should:
 *         *   Dequeue the packet.
 *         *   Use a `switch` statement based on the packet's type:
 *             *   If type is "DATA": Simulate processing data (e.g., print a message) and add the packet to the processed list.
 *             *   If type is "CONTROL": Simulate processing control (e.g., print a message) and add the packet to the processed list.
 *             *   If type is "ERROR": Simulate an error condition (e.g., print a message), log an error message (e.g., "Processing error for packet ID: [ID]") to the error log list, and *do not* add the packet to the processed list.
 *             *   For any other type: Log an error message (e.g., "Unknown packet type for packet ID: [ID]") to the error log list, and *do not* add the packet to the processed list.
 *         *   Handle the case where the queue is empty before attempting to process.
 *     *   Provide methods to display the current status (queue size, processed count, error count).
 *     *   Provide methods to display the contents of the processed packets list and the error log list.
 *     *   Implement input validation for added packets (e.g., non-null type, positive ID).
 * 
 * 3.  Implement a main class (e.g., `NetworkSimulator`) with a `main` method that:
 *     *   Creates a `PacketProcessor` instance.
 *     *   Uses a `Scanner` to interact with the user via a command-line menu.
 *     *   The menu should offer options like:
 *         *   Add a new packet.
 *         *   Process the next packet.
 *         *   Show status.
 *         *   View processed packets.
 *         *   View error log.
 *         *   Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Prompt the user for necessary information (ID, type, payload) when adding a packet. Implement basic input validation for user commands (e.g., ensuring integer input for choice).
 *     *   Use `System.out` for menu display, prompts, status updates, and successful processing messages.
 *     *   Use `System.err` to report invalid user input or errors detected during packet processing or validation.
 *     *   Implement class-wide exception handling (using `try-catch` blocks) in the `main` method to gracefully handle potential runtime errors (e.g., `InputMismatchException` from `Scanner`).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue` (use a concrete implementation like `LinkedList`)
 * *   `java.util.ArrayList`
 * *   `java.util.List` (use as interface type for declarations)
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (Javadoc).
 * *   Input validation and error handling.
 * *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user commands, and printing output to `System.out` or `System.err` based on the operation and its outcome. Examples:
 * 
 * ```
 * --- Packet Processor Menu ---
 * 1. Add Packet
 * 2. Process Next Packet
 * 3. Show Status
 * 4. View Processed Packets
 * 5. View Error Log
 * 6. Exit
 * Enter choice: 1
 * Enter Packet ID: 101
 * Enter Packet Type (DATA, CONTROL, ERROR, UNKNOWN): DATA
 * Enter Packet Payload: Hello World
 * Packet 101 added to queue.
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 2
 * Processing packet: [Packet ID=101, Type=DATA, Payload=Hello World]
 * Packet 101 processed successfully.
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 3
 * --- Processor Status ---
 * Incoming Queue Size: 0
 * Processed Packets: 1
 * Processing Errors: 0
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 1
 * Enter Packet ID: -5
 * Enter Packet Type (DATA, CONTROL, ERROR, UNKNOWN): CONTROL
 * Enter Packet Payload: Reset
 * Error: Invalid Packet ID. ID must be positive. Packet not added. (Output to System.err)
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 2
 * Attempting to process from empty queue. (Output to System.out or System.err indicating empty)
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 1
 * Enter Packet ID: 102
 * Enter Packet Type (DATA, CONTROL, ERROR, UNKNOWN): ERROR
 * Enter Packet Payload: Corrupt Data
 * Packet 102 added to queue.
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 2
 * Processing packet: [Packet ID=102, Type=ERROR, Payload=Corrupt Data]
 * Simulating error processing for packet ID: 102
 * Error logged for packet ID: 102. (Output to System.err)
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: 5
 * --- Error Log ---
 * Processing error for packet ID: 102
 * Unknown packet type for packet ID: [if any were added]
 * 
 * --- Packet Processor Menu ---
 * ...
 * Enter choice: abc
 * Error: Invalid input. Please enter a number between 1 and 6. (Output to System.err)
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a `NetworkSimulator` that processes `Packet` objects using a `PacketProcessor`. It demonstrates the required Java concepts and follows best practices.
 * 
 * 1.  **`Packet` Class:**
 *     *   Represents a data packet with `id`, `type`, and `payload`.
 *     *   Uses private fields and public getters for encapsulation.
 *     *   The constructor includes input validation for `id` (must be positive) and `type` (cannot be null or empty), throwing `IllegalArgumentException` for invalid input.
 *     *   Includes a `toString()` method for easy printing.
 * 
 * 2.  **`PacketProcessor` Class:**
 *     *   Manages the packet processing workflow.
 *     *   Uses a `Queue<Packet>` (`incomingQueue`) implemented by `LinkedList` to store packets awaiting processing. `offer()` and `poll()` methods are used for adding and removing elements, respectively, which are standard `Queue` operations.
 *     *   Uses a `List<Packet>` (`processedPackets`) implemented by `ArrayList` to store packets that were successfully processed (DATA or CONTROL types).
 *     *   Uses a `List<String>` (`errorLog`) implemented by `ArrayList` to store messages related to processing errors (ERROR types or unknown types).
 *     *   `addPacket()` method adds a valid `Packet` to the queue. It relies on the `Packet` constructor for initial validation.
 *     *   `processNextPacket()` method:
 *         *   Retrieves the next packet using `incomingQueue.poll()`. It checks if the result is `null` to handle an empty queue gracefully.
 *         *   Uses a `switch` statement on `packet.getType()` to determine the processing logic based on the packet type ("DATA", "CONTROL", "ERROR", or `default` for unknown types).
 *         *   Successfully processed packets ("DATA", "CONTROL") are added to `processedPackets`.
 *         *   Error conditions ("ERROR", default) result in a message being added to the `errorLog` using `errorLog.add()`.
 *         *   `System.err.println()` is used specifically for printing error messages within the processor.
 *         *   A `try-catch` block is included around the processing logic within `processNextPacket` to catch any unexpected runtime exceptions during the type-specific processing simulation, logging them to the `errorLog` and using `System.err`.
 *     *   `showStatus()`, `viewProcessed()`, and `viewErrors()` methods provide visibility into the processor's state, using `System.out` for status and processed packets, and `System.err` for the error log contents as requested.
 * 
 * 3.  **`NetworkSimulator` Class (Main):**
 *     *   Contains the `main` method, which serves as the entry point and user interface.
 *     *   Creates instances of `PacketProcessor` and `Scanner`.
 *     *   Runs a main loop controlled by a `boolean running` flag.
 *     *   A `try-catch` block surrounds the main loop to provide class-wide exception handling, catching potential unexpected errors during the program's execution (though more specific handling is done within the loop).
 *     *   Inside the loop, it prints a menu and reads user input using `scanner.nextInt()` for the choice.
 *     *   A `try-catch` block specifically for `InputMismatchException` is used when reading the integer choice, providing robust input validation for the menu selection and preventing crashes if the user enters non-numeric input. `scanner.next()` is used to consume the invalid input.
 *     *   A `finally` block after reading the integer choice ensures `scanner.nextLine()` is called to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   A `switch` statement is used to direct the program flow based on the valid user choice, calling the appropriate methods of the `PacketProcessor`.
 *     *   When adding a packet (case 1), it prompts for ID, type, and payload. It includes a `try-catch` block around the `Packet` constructor call and `processor.addPacket()` to catch `IllegalArgumentException` thrown by the `Packet` constructor during validation, printing the error message to `System.err`. It also handles `InputMismatchException` for the ID input.
 *     *   `System.out.println()` is used for menu prompts, successful actions, and status/processed packet display.
 *     *   `System.err.println()` is used for invalid user input messages and when displaying the error log contents (as per `PacketProcessor::viewErrors`).
 *     *   The `scanner` is closed in a `finally` block outside the main loop to release system resources when the program exits.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), simulates a practical scenario, and adheres to best practices like encapsulation, meaningful names, documentation, and comprehensive error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single network packet.
 */
class Packet {
    private int id;
    private String type;
    private String payload;

    /**
     * Constructs a Packet object.
     *
     * @param id      The unique identifier for the packet. Must be positive.
     * @param type    The type of the packet (e.g., DATA, CONTROL, ERROR).
     * @param payload The data payload of the packet.
     * @throws IllegalArgumentException if id is not positive or type is null/empty.
     */
    public Packet(int id, String type, String payload) {
        if (id <= 0) {
            throw new IllegalArgumentException("Packet ID must be positive.");
        }
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Packet type cannot be null or empty.");
        }
        this.id = id;
        this.type = type.trim().toUpperCase(); // Store type in uppercase for consistent comparison
        this.payload = payload;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getPayload() {
        return payload;
    }

    /**
     * Returns a string representation of the Packet.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Packet [ID=" + id + ", Type=" + type + ", Payload=" + payload + "]";
    }
}

/**
 * Manages the processing of network packets.
 */
class PacketProcessor {
    private Queue<Packet> incomingQueue;
    private List<Packet> processedPackets;
    private List<String> errorLog;

    /**
     * Constructs a PacketProcessor.
     */
    public PacketProcessor() {
        this.incomingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedPackets = new ArrayList<>();
        this.errorLog = new ArrayList<>();
    }

    /**
     * Adds a packet to the incoming queue.
     *
     * @param packet The packet to add.
     * @throws IllegalArgumentException if the packet is null or invalid.
     */
    public void addPacket(Packet packet) {
        if (packet == null) {
            throw new IllegalArgumentException("Cannot add a null packet.");
        }
        // Packet constructor already validates ID and Type
        incomingQueue.offer(packet); // offer is preferred over add for capacity-constrained queues, though LinkedList is not
        System.out.println("Packet " + packet.getId() + " added to queue.");
    }

    /**
     * Processes the next packet from the incoming queue.
     *
     * @return true if a packet was processed, false if the queue was empty.
     */
    public boolean processNextPacket() {
        Packet packet = incomingQueue.poll(); // poll returns null if queue is empty

        if (packet == null) {
            System.out.println("Attempting to process from empty queue.");
            return false;
        }

        System.out.println("Processing packet: " + packet);

        try {
            // Use switch statement based on packet type
            switch (packet.getType()) {
                case "DATA":
                    System.out.println("Simulating data processing for packet ID: " + packet.getId());
                    processedPackets.add(packet);
                    System.out.println("Packet " + packet.getId() + " processed successfully.");
                    break;
                case "CONTROL":
                    System.out.println("Simulating control processing for packet ID: " + packet.getId());
                    processedPackets.add(packet);
                    System.out.println("Packet " + packet.getId() + " processed successfully.");
                    break;
                case "ERROR":
                    System.out.println("Simulating error condition for packet ID: " + packet.getId());
                    String errorMsg = "Processing error for packet ID: " + packet.getId() + " (Type: " + packet.getType() + ")";
                    errorLog.add(errorMsg);
                    System.err.println("Error logged: " + errorMsg); // Use System.err for errors
                    break;
                default:
                    // Handle unknown types
                    String unknownTypeMsg = "Unknown packet type '" + packet.getType() + "' for packet ID: " + packet.getId();
                    errorLog.add(unknownTypeMsg);
                    System.err.println("Error logged: " + unknownTypeMsg); // Use System.err for errors
                    break;
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during processing
            String processingError = "Unexpected error processing packet ID: " + packet.getId() + " - " + e.getMessage();
            errorLog.add(processingError);
            System.err.println("Critical Error during processing: " + processingError); // Use System.err for critical errors
        }
        return true;
    }

    /**
     * Displays the current status of the processor.
     */
    public void showStatus() {
        System.out.println("--- Processor Status ---");
        System.out.println("Incoming Queue Size: " + incomingQueue.size());
        System.out.println("Processed Packets: " + processedPackets.size());
        System.out.println("Processing Errors: " + errorLog.size());
        System.out.println("------------------------");
    }

    /**
     * Displays the list of successfully processed packets.
     */
    public void viewProcessed() {
        System.out.println("--- Processed Packets ---");
        if (processedPackets.isEmpty()) {
            System.out.println("No packets have been processed yet.");
        } else {
            for (Packet p : processedPackets) {
                System.out.println(p);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the error log.
     */
    public void viewErrors() {
        System.out.println("--- Error Log ---");
        if (errorLog.isEmpty()) {
            System.out.println("No errors logged.");
        } else {
            for (String error : errorLog) {
                System.err.println(error); // Errors are logged to System.err
            }
        }
        System.out.println("-----------------");
    }
}

/**
 * Main class to simulate the network packet processing system.
 */
public class NetworkSimulator {

    /**
     * Displays the main menu options.
     */
    private static void printMenu() {
        System.out.println("\n--- Packet Processor Menu ---");
        System.out.println("1. Add Packet");
        System.out.println("2. Process Next Packet");
        System.out.println("3. Show Status");
        System.out.println("4. View Processed Packets");
        System.out.println("5. View Error Log");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    public static void main(String[] args) {
        PacketProcessor processor = new PacketProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main simulation loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 6.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                // Use switch statement for menu handling
                switch (choice) {
                    case 1:
                        System.out.print("Enter Packet ID: ");
                        int id = -1;
                        try {
                            id = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for Packet ID. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit case 1
                        }

                        System.out.print("Enter Packet Type (DATA, CONTROL, ERROR, UNKNOWN): ");
                        String type = scanner.nextLine();

                        System.out.print("Enter Packet Payload: ");
                        String payload = scanner.nextLine();

                        try {
                            Packet newPacket = new Packet(id, type, payload);
                            processor.addPacket(newPacket);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage() + " Packet not added."); // Use System.err for validation errors
                        }
                        break;

                    case 2:
                        processor.processNextPacket();
                        break;

                    case 3:
                        processor.showStatus();
                        break;

                    case 4:
                        processor.viewProcessed();
                        break;

                    case 5:
                        processor.viewErrors();
                        break;

                    case 6:
                        System.out.println("Exiting Packet Processor Simulator. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions in the main loop
            System.err.println("An unexpected error occurred in the simulator: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
