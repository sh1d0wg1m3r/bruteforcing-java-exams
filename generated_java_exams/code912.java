/*
 * Exam Question #912
 * Generated on: 2025-05-12 16:58:29
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Process Resource Allocation Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Resource Allocation Simulator. This simulator manages processes that require a certain amount of "resource units" to complete. Processes are added to a waiting queue. The simulator processes one process at a time from the queue in a step-by-step fashion. Each simulation step attempts to allocate resources to the current process. Processes either complete successfully after receiving enough resources or might fail unexpectedly during allocation. The simulator needs to keep track of waiting, completed, and failed processes.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Process Representation:** Create a class `Process` with the following features:
 *     *   Private fields: `processId` (String), `requiredResourceUnits` (int), `currentResourceUnits` (int), `status` (enum or String: "WAITING", "RUNNING", "COMPLETED", "FAILED").
 *     *   Constructor to initialize `processId` and `requiredResourceUnits`. `currentResourceUnits` should start at 0, and `status` at "WAITING".
 *     *   Public getter methods for all fields.
 *     *   A public method `allocateResources(int units)` that adds `units` to `currentResourceUnits`. Ensure `currentResourceUnits` does not exceed `requiredResourceUnits`. Update status if required units are met.
 *     *   A public method `failProcess(String reason)` that sets the status to "FAILED" and potentially stores the reason (optional, but good practice).
 *     *   Override `toString()` to provide a useful representation of the process state.
 * 
 * 2.  **Simulator Logic:** Create a class `ResourceSimulator` with the following features:
 *     *   Private fields: A `Queue<Process>` for processes waiting for allocation, an `ArrayList<Process>` for completed processes, and an `ArrayList<Process>` for failed processes.
 *     *   Constructor to initialize the collections.
 *     *   A public method `addProcess(Process process)` that adds a process to the waiting queue.
 *     *   A public method `simulateStep()` that performs one simulation step:
 *         *   If the waiting queue is empty, print a message and do nothing.
 *         *   Dequeue the next process from the waiting queue.
 *         *   Simulate resource allocation: Allocate a fixed amount of resources (e.g., 10 units) to the process using its `allocateResources` method.
 *         *   Introduce a random chance of failure (e.g., 10% chance). If failure occurs, call the process's `failProcess` method and move it to the failed processes list. Print an error message using `System.err`.
 *         *   If the process successfully receives resources and its status becomes "COMPLETED", move it to the completed processes list. Print a success message using `System.out`.
 *         *   If the process is still "WAITING" or "RUNNING" after allocation (didn't fail and didn't complete), re-queue it at the *end* of the waiting queue.
 *         *   Handle potential exceptions during simulation (e.g., a custom exception if allocation fails unexpectedly, although random failure is sufficient here).
 *     *   Public methods `getCompletedProcesses()` and `getFailedProcesses()` that return the respective lists (preferably returning `List<Process>` interface type).
 * 
 * 3.  **User Interface (Main Class):** Create a main class (e.g., `ResourceSimulatorApp`) with a `main` method that provides a command-line interface:
 *     *   Use `Scanner` to read user input.
 *     *   Implement a menu using a `switch` statement for the following options:
 *         *   `1`: Add New Process (Prompt for Process ID and Required Resource Units). Validate input (ID not empty, units > 0). Use `System.err` for validation errors.
 *         *   `2`: Simulate One Step.
 *         *   `3`: View Completed Processes.
 *         *   `4`: View Failed Processes.
 *         *   `5`: View Waiting Processes.
 *         *   `6`: Exit.
 *     *   Use a loop to keep the menu running until the user chooses to exit.
 *     *   Include comprehensive `try-catch` blocks in the `main` method to handle potential exceptions during input reading or simulator operations, printing error messages to `System.err`.
 * 
 * 4.  **General Requirements:**
 *     *   Use `java.util.Queue`, `java.util.ArrayList`, and `java.util.List` interface as specified.
 *     *   Use `java.util.Scanner` for input.
 *     *   Use a `switch` statement for menu control.
 *     *   Use `System.err` for all error messages (input validation, simulation failures, exceptions).
 *     *   Use `System.out` for menu display, prompts, success messages, and process lists.
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Add comments where necessary to explain complex logic.
 *     *   Ensure robust input validation and error handling.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user commands, perform the corresponding actions, and print results or errors clearly. When viewing lists, print the `toString()` representation of each process.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Resource Simulator Menu ---
 * 1. Add New Process
 * 2. Simulate One Step
 * 3. View Completed Processes
 * 4. View Failed Processes
 * 5. View Waiting Processes
 * 6. Exit
 * Enter choice: 1
 * Enter Process ID: P1
 * Enter Required Resource Units: 30
 * Process P1 added to the waiting queue.
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 1
 * Enter Process ID: P2
 * Enter Required Resource Units: 25
 * Process P2 added to the waiting queue.
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P1 allocated 10 units. Status: RUNNING (10/30)
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P2 allocated 10 units. Status: RUNNING (10/25)
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P1 allocated 10 units. Status: RUNNING (20/30)
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P2 allocated 10 units. Status: RUNNING (20/25)
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P1 allocated 10 units. Status: COMPLETED (30/30)
 * Process P1 completed successfully!
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P2 allocated 10 units. Status: RUNNING (30/25) - Note: This shouldn't happen due to allocation logic capping at required. Let's assume allocation is capped.
 * Simulating one step...
 * Process P2 allocated 5 units. Status: COMPLETED (25/25)
 * Process P2 completed successfully!
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 3
 * --- Completed Processes ---
 * Process [ID=P1, Status=COMPLETED, Units=30/30]
 * Process [ID=P2, Status=COMPLETED, Units=25/25]
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Waiting queue is empty. No processes to simulate.
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 1
 * Enter Process ID: P3
 * Enter Required Resource Units: 20
 * Process P3 added to the waiting queue.
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * Process P3 allocated 10 units. Status: RUNNING (10/20)
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 2
 * Simulating one step...
 * **[Assuming random failure occurs]**
 * Error: Process P3 failed during resource allocation!
 * Process P3 failed unexpectedly.
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 4
 * --- Failed Processes ---
 * Process [ID=P3, Status=FAILED, Units=10/20]
 * 
 * --- Resource Simulator Menu ---
 * ...
 * Enter choice: 6
 * Exiting simulator.
 * ```
 * 
 * Implement the solution adhering to all requirements.
 *
 * EXPLANATION:
 * This solution implements the `Resource Allocation Simulator` as required, demonstrating the use of the specified Java components and adhering to best practices.
 * 
 * 1.  **`Process` Class:**
 *     *   Represents an individual process with private fields for encapsulation (`processId`, `requiredResourceUnits`, `currentResourceUnits`, `status`).
 *     *   Uses constants (`STATUS_WAITING`, etc.) for status strings to avoid typos.
 *     *   The constructor includes input validation for ID and required units, throwing `IllegalArgumentException`.
 *     *   `allocateResources` method updates the `currentResourceUnits` and changes the status to `RUNNING` or `COMPLETED` based on whether the required units are met. It caps the `currentResourceUnits` at `requiredResourceUnits`.
 *     *   `failProcess` method sets the status to `FAILED`.
 *     *   Getter methods provide controlled access to the process state.
 *     *   `toString()` provides a clear summary for printing.
 * 
 * 2.  **`ResourceSimulator` Class:**
 *     *   Manages the state of the simulation using three core collections:
 *         *   `Queue<Process> waitingQueue`: Implemented using `LinkedList`, which is a common choice for queues in Java. Processes wait here before being processed. `offer()` adds to the end, `poll()` removes from the front.
 *         *   `List<Process> completedProcesses`: Implemented using `ArrayList`. Stores processes that successfully finished. Declared using the `List` interface type, demonstrating polymorphism.
 *         *   `List<Process> failedProcesses`: Implemented using `ArrayList`. Stores processes that failed during simulation. Declared using the `List` interface type.
 *     *   `addProcess`: Adds a process to the `waitingQueue`.
 *     *   `simulateStep`: This is the core logic.
 *         *   It checks if the queue is empty.
 *         *   It uses `poll()` to take the next process from the `waitingQueue`.
 *         *   It simulates a random chance of failure using `Random`. If failure occurs, the process is moved directly to the `failedProcesses` list, and an error is printed to `System.err`.
 *         *   If no failure, it calls the process's `allocateResources` method.
 *         *   It checks the process's status after allocation. If `COMPLETED`, it's moved to `completedProcesses`. If still `RUNNING` (or `WAITING`, though `allocateResources` should change it to `RUNNING`), it's added back to the *end* of the `waitingQueue` using `offer()` to await further allocation in subsequent steps.
 *         *   Includes a `try-catch` block within `simulateStep` to handle potential unexpected errors during the simulation of a single process, printing to `System.err`.
 *     *   `getCompletedProcesses` and `getFailedProcesses` return copies of the internal lists as `List<Process>`, preventing external code from modifying the simulator's internal state directly. `getWaitingProcesses` also provides a list view of the queue.
 *     *   Helper methods `printProcessList`, `displayCompletedProcesses`, etc., are used for organized output.
 * 
 * 3.  **`ResourceSimulatorApp` (Main Class):**
 *     *   Contains the `main` method, which serves as the user interface.
 *     *   Uses a `Scanner` to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement handles the user's menu choice, calling appropriate methods of the `ResourceSimulator` or input handling functions.
 *     *   Input validation is performed in `addNewProcess` for process ID and required units, using `System.err` for invalid input messages. It also handles `NumberFormatException` if the user enters non-numeric input for units.
 *     *   A large `try-catch` block wraps the main `while` loop in `main`. This demonstrates class-wide exception handling, catching any unexpected exceptions that might propagate up from the simulator or input handling, preventing the program from crashing abruptly and printing the error to `System.err`.
 *     *   The `finally` block ensures the `Scanner` is closed when the application terminates.
 *     *   Helper methods like `printMenu` and `getUserChoice` improve code structure and readability. `getUserChoice` includes basic input validation to ensure an integer is entered.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Process`, `ResourceSimulator`, `ResourceSimulatorApp`) with encapsulation (private fields, public methods).
 * *   **Data Structures:** Effective use of `Queue` (specifically `LinkedList`) for managing waiting processes in FIFO order (with re-queueing) and `List` (specifically `ArrayList`) for storing completed and failed processes. Demonstrating the use of the `List` interface type.
 * *   **Control Flow:** Using `switch` for menu navigation and `while` for the main application loop.
 * *   **Input/Output:** Using `Scanner` for user input, `System.out` for normal output, and `System.err` for error messages.
 * *   **Exception Handling:** Using `try-catch` blocks at different levels (in `simulateStep` for potential simulation issues, in `addNewProcess` for input validation/creation errors, and a broad one in `main` for unexpected application errors) and throwing specific exceptions (`IllegalArgumentException`).
 * *   **Input Validation:** Checking user input for correctness before creating objects or performing actions.
 * *   **Code Structure and Readability:** Using meaningful names, comments, and separating concerns into different classes and methods.
 * *   **Polymorphism:** Using the `List` interface type for variables and method return types where the specific implementation (`ArrayList`) is less relevant to the caller.
 * *   **Randomness:** Introducing non-deterministic behavior (process failure) using `java.util.Random`.
 * 
 * This task requires students to integrate multiple core Java concepts into a functional, well-structured application, addressing practical concerns like user interaction, data management, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Random; // For simulating random failure

// Custom exception for simulator errors (optional, but good practice)
class SimulatorException extends Exception {
    public SimulatorException(String message) {
        super(message);
    }
}

// Represents a process requiring resources
class Process {
    private String processId;
    private int requiredResourceUnits;
    private int currentResourceUnits;
    private String status; // WAITING, RUNNING, COMPLETED, FAILED

    private static final String STATUS_WAITING = "WAITING";
    private static final String STATUS_RUNNING = "RUNNING";
    private static final String STATUS_COMPLETED = "COMPLETED";
    private static final String STATUS_FAILED = "FAILED";

    /**
     * Constructs a new Process.
     * @param processId The unique identifier for the process.
     * @param requiredResourceUnits The total resource units needed for completion.
     */
    public Process(String processId, int requiredResourceUnits) {
        if (processId == null || processId.trim().isEmpty()) {
            throw new IllegalArgumentException("Process ID cannot be null or empty.");
        }
        if (requiredResourceUnits <= 0) {
            throw new IllegalArgumentException("Required resource units must be positive.");
        }
        this.processId = processId.trim();
        this.requiredResourceUnits = requiredResourceUnits;
        this.currentResourceUnits = 0;
        this.status = STATUS_WAITING;
    }

    // Getters
    public String getProcessId() {
        return processId;
    }

    public int getRequiredResourceUnits() {
        return requiredResourceUnits;
    }

    public int getCurrentResourceUnits() {
        return currentResourceUnits;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Allocates resources to the process. Updates status if completion is reached.
     * @param units The number of units to allocate.
     */
    public void allocateResources(int units) {
        if (this.status.equals(STATUS_COMPLETED) || this.status.equals(STATUS_FAILED)) {
            // Cannot allocate to completed or failed processes
            return;
        }

        this.currentResourceUnits += units;
        if (this.currentResourceUnits >= this.requiredResourceUnits) {
            this.currentResourceUnits = this.requiredResourceUnits; // Cap at required
            this.status = STATUS_COMPLETED;
        } else {
            this.status = STATUS_RUNNING;
        }
    }

    /**
     * Marks the process as failed.
     * @param reason The reason for failure (optional).
     */
    public void failProcess(String reason) {
        if (this.status.equals(STATUS_COMPLETED) || this.status.equals(STATUS_FAILED)) {
            // Cannot fail a completed or already failed process
            return;
        }
        this.status = STATUS_FAILED;
        // Could potentially store the reason in a field if needed
    }

    // Check status methods for clarity
    public boolean isWaiting() { return this.status.equals(STATUS_WAITING); }
    public boolean isRunning() { return this.status.equals(STATUS_RUNNING); }
    public boolean isCompleted() { return this.status.equals(STATUS_COMPLETED); }
    public boolean isFailed() { return this.status.equals(STATUS_FAILED); }

    @Override
    public String toString() {
        return "Process [ID=" + processId + ", Status=" + status + ", Units=" + currentResourceUnits + "/" + requiredResourceUnits + "]";
    }
}

// Manages the simulation flow and process queues/lists
class ResourceSimulator {
    private Queue<Process> waitingQueue;
    private List<Process> completedProcesses; // Using List interface
    private List<Process> failedProcesses;   // Using List interface
    private Random random; // For simulating failure chance

    private static final int RESOURCE_ALLOCATION_PER_STEP = 10; // Fixed units per step
    private static final double FAILURE_CHANCE = 0.1; // 10% chance of failure

    /**
     * Constructs a new ResourceSimulator.
     */
    public ResourceSimulator() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedProcesses = new ArrayList<>();
        this.failedProcesses = new ArrayList<>();
        this.random = new Random();
    }

    /**
     * Adds a process to the waiting queue.
     * @param process The process to add.
     */
    public void addProcess(Process process) {
        if (process != null && process.isWaiting()) {
            waitingQueue.offer(process); // offer is preferred over add for queues
        } else {
            System.err.println("Error: Cannot add null or non-waiting process to queue.");
        }
    }

    /**
     * Simulates one step of resource allocation.
     * @throws SimulatorException If a critical simulation error occurs (not used for random failure).
     */
    public void simulateStep() {
        System.out.println("Simulating one step...");

        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting queue is empty. No processes to simulate.");
            return;
        }

        // Dequeue the next process
        Process currentProcess = waitingQueue.poll();
        if (currentProcess == null) {
             // This should ideally not happen if queue is not empty, but good check
             System.err.println("Error: Failed to retrieve process from queue.");
             return;
        }

        try {
            // Simulate random failure
            if (random.nextDouble() < FAILURE_CHANCE) {
                currentProcess.failProcess("Random allocation failure");
                failedProcesses.add(currentProcess);
                System.err.println("Error: Process " + currentProcess.getProcessId() + " failed during resource allocation!");
                System.out.println(currentProcess.toString()); // Show failed state
            } else {
                // Allocate resources
                currentProcess.allocateResources(RESOURCE_ALLOCATION_PER_STEP);
                System.out.println("Process " + currentProcess.getProcessId() + " allocated " + RESOURCE_ALLOCATION_PER_STEP + " units. Status: " + currentProcess.getStatus() + " (" + currentProcess.getCurrentResourceUnits() + "/" + currentProcess.getRequiredResourceUnits() + ")");

                // Check status after allocation
                if (currentProcess.isCompleted()) {
                    completedProcesses.add(currentProcess);
                    System.out.println("Process " + currentProcess.getProcessId() + " completed successfully!");
                } else if (currentProcess.isRunning()) {
                    // Re-queue if still running
                    waitingQueue.offer(currentProcess);
                } else {
                     // Should not happen if logic is correct, but handle defensively
                     System.err.println("Warning: Process " + currentProcess.getProcessId() + " in unexpected state after allocation: " + currentProcess.getStatus());
                     // Depending on policy, might add to failed or requeue; here, let's re-queue defensively
                     waitingQueue.offer(currentProcess);
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during simulation
            System.err.println("Critical Simulation Error for Process " + currentProcess.getProcessId() + ": " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
            // Optionally move to failed processes if a critical error occurred
            currentProcess.failProcess("Critical internal error");
            failedProcesses.add(currentProcess);
        }
    }

    /**
     * Returns a list of processes that have completed.
     * @return A List of completed Processes.
     */
    public List<Process> getCompletedProcesses() {
        // Return a copy to prevent external modification of internal list
        return new ArrayList<>(completedProcesses);
    }

    /**
     * Returns a list of processes that have failed.
     * @return A List of failed Processes.
     */
    public List<Process> getFailedProcesses() {
        // Return a copy
        return new ArrayList<>(failedProcesses);
    }

    /**
     * Returns a list of processes currently in the waiting queue.
     * @return A List of waiting Processes.
     */
    public List<Process> getWaitingProcesses() {
         // Convert queue to list for viewing. Does not remove from queue.
         return new ArrayList<>(waitingQueue);
    }

    /**
     * Prints the current state of processes in a given list.
     * @param processes The list of processes to print.
     * @param title The title for the list output.
     */
    private void printProcessList(List<Process> processes, String title) {
        System.out.println("--- " + title + " ---");
        if (processes.isEmpty()) {
            System.out.println("No processes found.");
        } else {
            for (Process p : processes) {
                System.out.println(p);
            }
        }
    }

    // Public methods to trigger printing lists
    public void displayCompletedProcesses() {
        printProcessList(getCompletedProcesses(), "Completed Processes");
    }

     public void displayFailedProcesses() {
        printProcessList(getFailedProcesses(), "Failed Processes");
    }

     public void displayWaitingProcesses() {
        printProcessList(getWaitingProcesses(), "Waiting Processes");
    }
}

// Main application class for user interaction
public class ResourceSimulatorApp {

    private static final Scanner scanner = new Scanner(System.in);
    private static final ResourceSimulator simulator = new ResourceSimulator();

    public static void main(String[] args) {
        System.out.println("Resource Allocation Simulator started.");
        boolean running = true;

        // Class-wide try-catch block covering the main application loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                switch (choice) {
                    case 1:
                        addNewProcess();
                        break;
                    case 2:
                        simulator.simulateStep();
                        break;
                    case 3:
                        simulator.displayCompletedProcesses();
                        break;
                    case 4:
                        simulator.displayFailedProcesses();
                        break;
                    case 5:
                         simulator.displayWaitingProcesses();
                         break;
                    case 6:
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any uncaught exceptions from the main loop or called methods
            System.err.println("A critical error occurred in the application: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the application exits
            scanner.close();
            System.out.println("Simulator application terminated.");
        }
    }

    private static void printMenu() {
        System.out.println("--- Resource Simulator Menu ---");
        System.out.println("1. Add New Process");
        System.out.println("2. Simulate One Step");
        System.out.println("3. View Completed Processes");
        System.out.println("4. View Failed Processes");
        System.out.println("5. View Waiting Processes");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * @return The valid choice number.
     */
    private static int getUserChoice() {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            System.out.print("Enter choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return choice;
    }

    /**
     * Prompts user for process details and adds a new process to the simulator.
     */
    private static void addNewProcess() {
        try {
            System.out.print("Enter Process ID: ");
            String id = scanner.nextLine().trim();

            System.out.print("Enter Required Resource Units: ");
            // Use nextLine() and parse to handle potential non-integer input gracefully
            String unitsStr = scanner.nextLine().trim();
            int units;

            // Input validation
            if (id.isEmpty()) {
                System.err.println("Error: Process ID cannot be empty.");
                return;
            }

            try {
                units = Integer.parseInt(unitsStr);
            } catch (NumberFormatException e) {
                System.err.println("Error: Required resource units must be a valid integer.");
                return;
            }

            if (units <= 0) {
                System.err.println("Error: Required resource units must be positive.");
                return;
            }

            // Create and add the process
            Process newProcess = new Process(id, units);
            simulator.addProcess(newProcess);
            System.out.println("Process " + id + " added to the waiting queue.");

        } catch (IllegalArgumentException e) {
            // Catch exceptions from Process constructor validation
            System.err.println("Error adding process: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during process creation/adding
             System.err.println("An unexpected error occurred while adding process: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }
}
