/*
 * Exam Question #294
 * Generated on: 2025-05-11 22:50:59
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Automated Report Generation System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Automated Report Generation System. This system manages requests for generating reports, processes them in order, and tracks their status.
 * 
 * The system should allow users to:
 * 1.  **Add** a new report generation request to a queue. Each request has a unique ID and a description.
 * 2.  **Process** the next report request from the queue. Processing should simulate work and handle potential failures.
 * 3.  **View** all pending report requests currently in the queue.
 * 4.  **View** all reports that have been successfully processed.
 * 5.  **View** all reports that failed during processing.
 * 6.  **Exit** the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate proficiency in core Java concepts and utilize the following components:
 * 
 * *   `java.util.Queue`: To manage pending report generation requests.
 * *   `java.util.ArrayList`: To store processed (both successful and failed) reports.
 * *   `java.util.List`: Use the `List` interface type when referring to collections of processed reports.
 * *   `java.util.Scanner`: To read user commands and report descriptions from the console.
 * *   `switch` statement: To handle the different user commands.
 * *   `System.err`: To output error messages (e.g., processing failures, invalid input).
 * *   `System.out`: To output normal information (e.g., prompts, task details, lists of reports).
 * *   Class-wide exception handling: Use `try-catch` blocks effectively to handle potential issues, including simulated processing errors and invalid user input.
 * 
 * **Implementation Details:**
 * 
 * 1.  Create a `ReportRequest` class to represent a single report request. It should have:
 *     *   A unique integer `id`.
 *     *   A `String description`.
 *     *   Appropriate constructor, getters, and a `toString()` method for easy printing.
 * 2.  Create a `ReportGenerator` class that manages the queue of pending requests and lists of processed/failed requests.
 *     *   It should contain a `Queue<ReportRequest>` for pending tasks.
 *     *   It should contain a `List<ReportRequest>` for successfully processed tasks.
 *     *   It should contain a `List<ReportRequest>` for failed tasks.
 *     *   It should manage a counter for generating unique request IDs.
 *     *   Implement methods for adding requests, processing the next request, and retrieving the lists of pending, successful, and failed requests.
 *     *   Simulate processing: When processing a request, if the request's description contains the case-insensitive word "FAIL", simulate a processing failure. Otherwise, simulate success.
 * 3.  The main application logic should reside in a class with a `main` method.
 *     *   It should instantiate `Scanner` and `ReportGenerator`.
 *     *   It should run a loop that continuously prompts the user for commands.
 *     *   Use a `switch` statement to dispatch actions based on user input ('a' for add, 'p' for process, 'v' for view, 'e' for exit).
 *     *   Implement input validation for user commands.
 *     *   Wrap the main command processing loop within a `try-catch` block to handle unexpected exceptions gracefully.
 *     *   Ensure proper resource management (closing the `Scanner`).
 * 
 * **Input Format:**
 * 
 * User input will be single characters for commands, followed by relevant data (like report description for 'a').
 * Commands:
 * *   `a`: Add a new report request. The system should then prompt for the report description.
 * *   `p`: Process the next report request.
 * *   `v`: View reports. The system should then prompt which list to view ('p' for pending, 's' for successful, 'f' for failed).
 * *   `e`: Exit the application.
 * 
 * **Error Handling:**
 * 
 * *   If the user enters an invalid command, print an error message to `System.err`.
 * *   If the user requests to view a list using 'v' and provides an invalid list type, print an error message to `System.err`.
 * *   If processing a task fails (due to "FAIL" in description), catch the simulated error (you can throw a custom exception or a standard one like `RuntimeException`), print an error message to `System.err`, and move the task to the failed list.
 * *   If trying to process a task when the queue is empty, print a message to `System.out` indicating no pending tasks.
 * *   Use `try-catch` around input operations that might fail (e.g., reading description after 'a').
 * *   Include a general `try-catch` in `main` to catch any uncaught exceptions during the application lifecycle and print an error message to `System.err` before exiting.
 * 
 * **Expected Output:**
 * 
 * *   Prompts for user input should be clear (e.g., "Enter command (a, p, v, e): ").
 * *   Output for viewing lists should clearly label which list is being displayed and list the reports with their IDs and descriptions.
 * *   Success messages (e.g., "Report request added.", "Report processed successfully.") should go to `System.out`.
 * *   Error messages should go to `System.err`.
 * 
 * **Assessment Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch`.
 * *   Proper object-oriented design (encapsulation, meaningful names).
 * *   Effective implementation of the report generation logic, including simulated failure.
 * *   Robust error handling and input validation.
 * *   Clean code structure and comments.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Automated Report Generation System demonstrating the required Java concepts.
 * 
 * 1.  **`ReportRequest` Class:**
 *     *   This class is a simple Plain Old Java Object (POJO) representing a report request.
 *     *   It uses `private` fields (`id`, `description`) and `public` getters (`getId`, `getDescription`) to enforce encapsulation.
 *     *   The constructor includes basic input validation for the description, throwing an `IllegalArgumentException` if it's null or empty.
 *     *   `toString()` is overridden for convenient printing.
 * 
 * 2.  **`ReportGenerator` Class:**
 *     *   This class encapsulates the core logic of the system.
 *     *   **`Queue`:** `pendingRequests` is declared as a `Queue<ReportRequest>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of `Queue` and is suitable here because we need FIFO (First-In, First-Out) behavior for processing tasks. `offer()` is used to add to the queue, and `poll()` is used to remove from the head.
 *     *   **`List` and `ArrayList`:** `successfulRequests` and `failedRequests` are declared as `List<ReportRequest>` and initialized with `ArrayList`. `ArrayList` is used for its dynamic array capabilities, suitable for storing items where order matters (addition order) and random access isn't strictly necessary but viewing the list is required. Using the `List` interface type promotes good practice, allowing flexibility to switch implementation later if needed (though `ArrayList` is fine here).
 *     *   **`nextRequestId`:** A simple counter to ensure unique IDs for each request.
 *     *   **`addRequest(String description)`:** Creates a new `ReportRequest` and adds it to the `pendingRequests` queue using `offer()`.
 *     *   **`processNextRequest()`:**
 *         *   Uses `poll()` to retrieve and remove the head of the `pendingRequests` queue. If the queue is empty, `poll()` returns `null`, which is handled gracefully.
 *         *   It includes a `try-catch` block specifically for the processing logic.
 *         *   Inside the `try` block, it simulates processing. The failure condition is checked by examining if the description contains "FAIL" (case-insensitive using `toUpperCase(Locale.US)`). If it does, a `ReportProcessingException` is thrown.
 *         *   If no exception is thrown, the request is considered successful and added to the `successfulRequests` list.
 *         *   The `catch (ReportProcessingException e)` block catches the simulated failure, prints an error to `System.err`, and adds the request to the `failedRequests` list.
 *         *   A general `catch (Exception e)` is included to catch any other unexpected runtime issues during the simulation.
 *     *   **`getPendingRequests()`, `getSuccessfulRequests()`, `getFailedRequests()`:** These methods return *new* `ArrayList` instances containing the elements from the internal collections. This is a good practice to provide callers with a snapshot of the data without exposing the internal collection references, preventing external code from modifying the internal state directly (e.g., clearing the pending queue unexpectedly).
 * 
 * 3.  **`ReportSystem` (Main Class):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read user input from `System.in`.
 *     *   **Main Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   **`switch` Statement:** Handles the different user commands ('a', 'p', 'v', 'e').
 *     *   **Input Handling & Validation:**
 *         *   Reads the command character.
 *         *   For 'a', it prompts for the description and calls `generator.addRequest()`. A `try-catch` is used here to specifically catch the `IllegalArgumentException` thrown by the `ReportRequest` constructor if the description is invalid.
 *         *   For 'v', it reads a second input to determine which list to view and uses another nested `switch` statement. Invalid view types result in an error to `System.err`.
 *     *   **`System.out` and `System.err`:** Used appropriately for normal messages (`System.out`) and error messages (`System.err`).
 *     *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This serves as a safety net to catch any unexpected exceptions that might occur anywhere within the main command processing flow, printing a general error message and the stack trace to `System.err` before the program potentially terminates.
 *     *   **`finally` Block:** Ensures that the `scanner.close()` method is called regardless of whether an exception occurred or the loop finished normally, releasing the system resource.
 * 
 * This solution effectively integrates all required components, demonstrates good object-oriented principles, handles different scenarios including simulated errors, and uses `System.out` and `System.err` as specified. The exception handling is layered, with specific catches for known issues (like invalid description or processing failure) and a general catch for unexpected errors in the main loop.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive comparison

// Custom exception for simulated processing failure
class ReportProcessingException extends Exception {
    public ReportProcessingException(String message) {
        super(message);
    }
}

// Represents a single report request
class ReportRequest {
    private int id;
    private String description;

    public ReportRequest(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Report description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "ReportRequest [ID=" + id + ", Description='" + description + "']";
    }
}

// Manages the report generation process
class ReportGenerator {
    private Queue<ReportRequest> pendingRequests;
    private List<ReportRequest> successfulRequests;
    private List<ReportRequest> failedRequests;
    private int nextRequestId;

    public ReportGenerator() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.successfulRequests = new ArrayList<>();
        this.failedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start IDs from 1
    }

    /**
     * Adds a new report request to the pending queue.
     * @param description The description of the report.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addRequest(String description) {
        ReportRequest newRequest = new ReportRequest(nextRequestId++, description);
        pendingRequests.offer(newRequest); // offer is preferred over add for queues
        System.out.println("Report request added: " + newRequest);
    }

    /**
     * Processes the next report request from the queue.
     * Simulates failure if description contains "FAIL".
     * @throws ReportProcessingException if processing fails.
     * @return true if a task was processed (successfully or failed), false if queue was empty.
     */
    public boolean processNextRequest() {
        ReportRequest requestToProcess = pendingRequests.poll(); // poll returns null if empty

        if (requestToProcess == null) {
            System.out.println("No pending report requests to process.");
            return false;
        }

        System.out.println("Processing request: " + requestToProcess);

        try {
            // Simulate processing time (optional)
            // Thread.sleep(100);

            // Simulate failure condition
            if (requestToProcess.getDescription().toUpperCase(Locale.US).contains("FAIL")) {
                throw new ReportProcessingException("Simulated processing failure due to 'FAIL' in description.");
            }

            // Simulate successful processing
            successfulRequests.add(requestToProcess);
            System.out.println("Report processed successfully: " + requestToProcess.getId());

        } catch (ReportProcessingException e) {
            // Handle simulated processing failure
            System.err.println("Processing failed for request ID " + requestToProcess.getId() + ": " + e.getMessage());
            failedRequests.add(requestToProcess);
        } catch (Exception e) {
            // Catch any other unexpected errors during processing simulation
            System.err.println("An unexpected error occurred while processing request ID " + requestToProcess.getId() + ": " + e.getMessage());
            failedRequests.add(requestToProcess);
        }
        return true;
    }

    /**
     * Returns an unmodifiable list of pending report requests.
     */
    public List<ReportRequest> getPendingRequests() {
        // Return a new ArrayList to prevent external modification of the internal queue state
        // Note: Converting Queue to List loses the Queue's order guarantee if processed externally,
        // but for viewing, this is acceptable. Alternatively, iterate and add.
        return new ArrayList<>(pendingRequests); // Simple way to get a snapshot
    }

    /**
     * Returns an unmodifiable list of successfully processed requests.
     */
    public List<ReportRequest> getSuccessfulRequests() {
        // Return a copy to prevent external modification
        return new ArrayList<>(successfulRequests);
    }

    /**
     * Returns an unmodifiable list of failed requests.
     */
    public List<ReportRequest> getFailedRequests() {
        // Return a copy to prevent external modification
        return new ArrayList<>(failedRequests);
    }
}

public class ReportSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ReportGenerator generator = new ReportGenerator();
        boolean running = true;

        System.out.println("Automated Report Generation System");
        System.out.println("Commands: a - add, p - process, v - view, e - exit");

        // Main application loop with class-wide exception handling
        try {
            while (running) {
                System.out.print("\nEnter command (a, p, v, e): ");
                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "a":
                        System.out.print("Enter report description: ");
                        String description = scanner.nextLine().trim();
                        try {
                            generator.addRequest(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding request: " + e.getMessage());
                        }
                        break;

                    case "p":
                        generator.processNextRequest();
                        break;

                    case "v":
                        System.out.print("View list (p - pending, s - successful, f - failed): ");
                        String viewType = scanner.nextLine().trim().toLowerCase();
                        List<ReportRequest> reportsToView = null;
                        String listName = "";

                        switch (viewType) {
                            case "p":
                                reportsToView = generator.getPendingRequests();
                                listName = "Pending Reports";
                                break;
                            case "s":
                                reportsToView = generator.getSuccessfulRequests();
                                listName = "Successful Reports";
                                break;
                            case "f":
                                reportsToView = generator.getFailedRequests();
                                listName = "Failed Reports";
                                break;
                            default:
                                System.err.println("Invalid view type. Use 'p', 's', or 'f'.");
                                continue; // Skip the rest of the 'v' case and go back to main loop
                        }

                        System.out.println("\n--- " + listName + " ---");
                        if (reportsToView.isEmpty()) {
                            System.out.println("No reports in this list.");
                        } else {
                            for (ReportRequest report : reportsToView) {
                                System.out.println(report);
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case "e":
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid command. Please use 'a', 'p', 'v', or 'e'.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions in the main loop
            System.err.println("\nAn unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
