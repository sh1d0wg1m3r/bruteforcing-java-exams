/*
 * Exam Question #332
 * Generated on: 2025-05-11 22:56:23
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line based customer support ticket system. The system should allow users (support staff) to manage incoming support requests.
 * 
 * The system needs to handle tickets in a first-in, first-out manner for processing, while maintaining an archive of tickets once they are resolved.
 * 
 * **System Functionality:**
 * 
 * 1.  **Submit New Ticket:** Allows a user to enter a description for a new support ticket. The system should assign a unique ID to each ticket and add it to the queue of open tickets.
 * 2.  **Process Next Ticket:** Takes the oldest ticket from the queue of open tickets, marks it as resolved, and moves it to an archive list. If there are no open tickets, it should report an error.
 * 3.  **View Open Tickets:** Displays all tickets currently in the open queue, in the order they will be processed.
 * 4.  **View Resolved Tickets:** Displays all tickets that have been processed and moved to the archive.
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * 
 * *   Use a `Queue` to manage the open support tickets (FIFO).
 * *   Use an `ArrayList` to store the resolved tickets archive. Declare the variable using the `List` interface type.
 * *   Use `Scanner` to read user input for menu choices and ticket details.
 * *   Implement the main menu logic using a `switch` statement.
 * *   Use `System.out` for displaying the menu, ticket information, and success messages.
 * *   Use `System.err` for displaying error messages (e.g., trying to process an empty queue, invalid input).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially related to user input.
 * *   Create a separate class `SupportTicket` to represent a single ticket. This class should have private fields for ticket ID, description, and status, and public getter methods.
 * *   Implement best practices: meaningful variable/method names, encapsulation, basic input validation, and comments.
 * 
 * **Implementation Details:**
 * 
 * *   Ticket IDs can be simple integers starting from 1, incrementing for each new ticket.
 * *   The `SupportTicket` class should likely have a constructor to initialize its fields.
 * *   The main application logic should reside in a class (e.g., `SupportSystem`) with a `main` method.
 * *   The main application loop should continue until the user explicitly chooses to exit.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's valid input, it should perform the requested action and display relevant information or error messages using `System.out` or `System.err` accordingly. Invalid menu choices or attempts to perform actions on an empty queue should result in informative error messages on `System.err`.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * 2. Process Next Ticket
 * 3. View Open Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My internet is slow
 * Ticket #1 submitted.
 * 
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * ...
 * Enter your choice: 1
 * Enter ticket description: Cannot access email
 * Ticket #2 submitted.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Open Tickets ---
 * [#1] My internet is slow (Open)
 * [#2] Cannot access email (Open)
 * --- End Open Tickets ---
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket #1: My internet is slow
 * Ticket #1 resolved.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Open Tickets ---
 * [#2] Cannot access email (Open)
 * --- End Open Tickets ---
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * --- Resolved Tickets ---
 * [#1] My internet is slow (Resolved)
 * --- End Resolved Tickets ---
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket #2: Cannot access email
 * Ticket #2 resolved.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No open tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: five
 * Error: Invalid input. Please enter a valid number.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Support Ticket System.
 * ```
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple command-line customer support ticket system, fulfilling all the requirements.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Models a single ticket with `id`, `description`, and `status`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides `public` getter methods.
 *     *   Includes a `resolve()` method to change the status, demonstrating object state change.
 *     *   Overrides `toString()` for easy printing of ticket details.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   Contains the main application logic and state (`openTickets`, `resolvedTickets`, `scanner`, `nextTicketId`).
 *     *   **`Queue<SupportTicket> openTickets`:** A `LinkedList` instance is used here because `LinkedList` implements the `Queue` interface, providing the necessary FIFO behavior (`add` for enqueueing, `poll` for dequeueing). This demonstrates using the `Queue` interface type for the variable while using a concrete implementation.
 *     *   **`List<SupportTicket> resolvedTickets`:** An `ArrayList` instance is used to store resolved tickets. The variable is declared using the `List` interface type, showcasing polymorphism and programming to interfaces. `ArrayList` provides efficient storage and iteration for the archive.
 *     *   **`Scanner scanner`:** Used to read input from `System.in`.
 *     *   **`try-catch` (Class-wide handling):** The main `run()` method contains a `try-catch` block wrapping the primary `while` loop. This demonstrates class-wide or method-level exception handling, catching potential unexpected errors during the application's execution. A `finally` block ensures the `Scanner` is closed.
 *     *   **`Scanner` and `InputMismatchException` Handling:** The `getUserChoice()` method specifically handles `InputMismatchException` which occurs if the user enters non-integer input when an integer is expected. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   **`switch` Statement:** The `run()` method uses a `switch` statement based on the user's choice (`getUserChoice()`) to direct the program flow to the appropriate method (submit, process, view, exit).
 *     *   **`System.out` and `System.err`:** `System.out.println` is used for normal output (menu, ticket details, success messages), while `System.err.println` is used specifically for displaying error conditions (invalid choice, empty queue, invalid input).
 *     *   **Input Validation:** `getUserChoice()` validates the integer input range (1-5). `submitNewTicket()` checks if the description is empty.
 *     *   **Methods for Functionality:** Separate methods (`submitNewTicket`, `processNextTicket`, `viewOpenTickets`, `viewResolvedTickets`) encapsulate the logic for each menu option, improving code organization and readability.
 *     *   **Queue Operations:** `openTickets.add()` is used to add new tickets to the queue. `openTickets.poll()` is used to remove and retrieve the next ticket for processing. The `isEmpty()` method is used to check if the queue is empty before attempting to process.
 *     *   **List Operations:** `resolvedTickets.add()` is used to add processed tickets to the archive list. Iteration using a for-each loop is used for viewing both open and resolved tickets.
 * 
 * This solution effectively combines various core Java features to build a functional system, demonstrating practical application of data structures, input/output, control flow, object-oriented principles, and exception handling. The structure and naming conventions adhere to best practices, making the code understandable and maintainable.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class SupportTicket {
    private int id;
    private String description;
    private String status; // e.g., "Open", "Resolved"

    // Constructor
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Open"; // New tickets are always open
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to change status (used when processing)
    public void resolve() {
        this.status = "Resolved";
    }

    @Override
    public String toString() {
        return "[" + (status.equals("Open") ? "#" : "") + id + "] " + description + " (" + status + ")";
    }
}

// Main class for the Support Ticket System
public class SupportSystem {

    // Queue for open tickets (FIFO)
    private Queue<SupportTicket> openTickets;
    // List for resolved tickets (archive)
    private List<SupportTicket> resolvedTickets;
    // Scanner for user input
    private Scanner scanner;
    // Counter for unique ticket IDs
    private int nextTicketId;

    // Constructor
    public SupportSystem() {
        this.openTickets = new LinkedList<>(); // LinkedList implements Queue
        this.resolvedTickets = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    // Main method to run the system
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }

    // Runs the main application loop
    public void run() {
        System.out.println("--- Welcome to the Support Ticket System ---");
        boolean running = true;

        // Class-wide try-catch block for the main loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        submitNewTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewOpenTickets();
                        break;
                    case 4:
                        viewResolvedTickets();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Support Ticket System.");
                        break;
                    default:
                        // Handled by getUserChoice, but defensive check
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }

    // Prints the main menu
    private void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Open Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Gets and validates user's menu choice
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();
            if (choice < 1 || choice > 5) {
                 System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                 return -1; // Return an invalid value to indicate error
            }
        } catch (InputMismatchException e) {
            // Handle non-integer input
            System.err.println("Error: Invalid input. Please enter a valid number.");
            // Consume the invalid input to prevent infinite loop
            scanner.next();
            // Consume the newline character
            scanner.nextLine();
            return -1; // Return an invalid value to indicate error
        }
        return choice;
    }

    // Handles the submission of a new ticket
    private void submitNewTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine(); // Read the whole line for description

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }

        SupportTicket newTicket = new SupportTicket(nextTicketId, description);
        openTickets.add(newTicket); // Add to the queue
        System.out.println("Ticket #" + nextTicketId + " submitted.");
        nextTicketId++; // Increment for the next ticket
    }

    // Handles the processing of the next ticket in the queue
    private void processNextTicket() {
        if (openTickets.isEmpty()) {
            System.err.println("Error: No open tickets to process.");
            return;
        }

        SupportTicket ticketToProcess = openTickets.poll(); // Remove and get the head of the queue
        System.out.println("Processing ticket #" + ticketToProcess.getId() + ": " + ticketToProcess.getDescription());

        ticketToProcess.resolve(); // Change status to resolved
        resolvedTickets.add(ticketToProcess); // Add to the resolved list
        System.out.println("Ticket #" + ticketToProcess.getId() + " resolved.");
    }

    // Displays all tickets currently in the open queue
    private void viewOpenTickets() {
        if (openTickets.isEmpty()) {
            System.out.println("No open tickets.");
            return;
        }

        System.out.println("--- Open Tickets ---");
        // Iterate through the queue without removing elements
        for (SupportTicket ticket : openTickets) {
            System.out.println(ticket); // Uses SupportTicket's toString()
        }
        System.out.println("--- End Open Tickets ---");
    }

    // Displays all tickets in the resolved archive
    private void viewResolvedTickets() {
        if (resolvedTickets.isEmpty()) {
            System.out.println("No resolved tickets.");
            return;
        }

        System.out.println("--- Resolved Tickets ---");
        // Iterate through the list
        for (SupportTicket ticket : resolvedTickets) {
            System.out.println(ticket); // Uses SupportTicket's toString()
        }
        System.out.println("--- End Resolved Tickets ---");
    }
}
