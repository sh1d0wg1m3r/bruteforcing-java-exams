/*
 * Exam Question #933
 * Generated on: 2025-05-12 17:01:51
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified appointment scheduling system for a small clinic. The system needs to manage patient records and handle a queue of appointments waiting to be seen.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following functionalities:
 * 
 * 1.  **Add New Patient:** Allows adding a new patient record. Each patient should have a unique ID (String), name (String), and age (int).
 * 2.  **Schedule Appointment:** Allows scheduling an appointment for an *existing* patient. Each appointment should have a unique ID (String), the ID of the patient it's for, and a brief description. Appointments are added to a waiting queue.
 * 3.  **Process Next Appointment:** Removes and displays the next appointment from the waiting queue, simulating a patient being seen.
 * 4.  **List All Patients:** Displays details of all registered patients.
 * 5.  **List Pending Appointments:** Displays details of all appointments currently in the waiting queue.
 * 6.  **Exit:** Terminates the program.
 * 
 * Your implementation must adhere to the following technical requirements:
 * 
 * *   Use a `java.util.ArrayList` to store the list of patients.
 * *   Use a `java.util.Queue` (specifically, implement it using `java.util.LinkedList`) to manage the pending appointments.
 * *   Use the `java.util.List` interface type when declaring the patient list variable.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.out.println()` for all normal output (menu, prompts, list items, processed appointment details).
 * *   Use `System.err.println()` for all error messages (e.g., patient not found, queue is empty, invalid input).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during program execution (e.g., incorrect input format for numbers). Specific validation errors (like patient not found) should also print to `System.err` but might be handled with specific checks rather than just generic exceptions.
 * *   Implement proper encapsulation for your data classes (`Patient`, `Appointment`).
 * *   Use meaningful variable and method names.
 * *   Include basic comments or documentation where necessary.
 * *   Implement input validation (e.g., check if a patient exists before scheduling an appointment, validate age > 0).
 * 
 * **Data Structures:**
 * 
 * *   You will need a `Patient` class with `patientId`, `name`, and `age`.
 * *   You will need an `Appointment` class with `appointmentId`, `patientId`, and `description`.
 * *   Your main class (`AppointmentScheduler`) will hold the `List` of patients and the `Queue` of appointments.
 * 
 * **User Interface (Console):**
 * 
 * The program should present a menu to the user:
 * 
 * ```
 * --- Appointment Scheduler Menu ---
 * 1. Add New Patient
 * 2. Schedule Appointment
 * 3. Process Next Appointment
 * 4. List All Patients
 * 5. List Pending Appointments
 * 6. Exit
 * Enter your choice:
 * ```
 * 
 * After the user enters a choice, the program should perform the corresponding action, prompt for necessary details, display results, and then show the menu again until the user chooses to exit.
 * 
 * **Error Handling Scenarios:**
 * 
 * *   If the user tries to schedule an appointment for a patient ID that does not exist, print an error message to `System.err`.
 * *   If the user tries to process an appointment when the queue is empty, print an error message to `System.err`.
 * *   If the user enters non-integer input for the menu choice or patient age, the general `try-catch` should ideally handle this, printing a generic error message to `System.err` and perhaps restarting the menu loop or asking for input again (a simple catch and error message is sufficient for this exam).
 * 
 * **Expected Output Format:**
 * 
 * *   Listings should clearly display patient/appointment details.
 * *   Error messages should be distinct using `System.err`.
 * *   Normal prompts and output should use `System.out`.
 * 
 * This task requires you to integrate various core Java concepts to build a functional, albeit simple, system. Pay close attention to data structure usage, object-oriented principles, and robust error handling.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Scheduler system, demonstrating the required Java concepts.
 * 
 * **1. System Structure:**
 * The system is structured into three classes:
 * *   `Patient`: An object representing a patient with encapsulated data (`patientId`, `name`, `age`).
 * *   `Appointment`: An object representing an appointment, linked to a patient via `patientId`, also with encapsulated data (`appointmentId`, `patientId`, `description`).
 * *   `AppointmentScheduler`: The main class that orchestrates the system. It holds the collections of patients and appointments and contains the main logic for handling user interactions and operations.
 * 
 * **2. Data Structures (`List`, `ArrayList`, `Queue`, `LinkedList`):**
 * *   `private List<Patient> patientList = new ArrayList<>();`: A `java.util.List` interface variable is declared, and it's initialized with a `java.util.ArrayList`. This fulfills the requirement to use both `List` and `ArrayList`. The `ArrayList` is suitable for storing patients as we need to add, list, and potentially search (though a simple linear search `findPatientById` is used here for simplicity), and random access by index isn't the primary need, but iteration is frequent.
 * *   `private Queue<Appointment> appointmentQueue = new LinkedList<>();`: A `java.util.Queue` interface variable is declared, initialized with a `java.util.LinkedList`. This meets the requirement to use `Queue` and `LinkedList`. The `Queue` is perfect for managing appointments that need to be processed in a First-In, First-Out (FIFO) manner (`offer` to add, `poll` to remove from the front).
 * 
 * **3. User Input (`Scanner`):**
 * *   `Scanner scanner = new Scanner(System.in)`: A `Scanner` is used to read input from the standard input stream (`System.in`).
 * *   The `Scanner` is managed using a `try-with-resources` block in the `run()` method. This ensures that the `scanner` resource is automatically closed when the block is exited, preventing resource leaks.
 * *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 * 
 * **4. Flow Control (`switch`):**
 * *   A `switch` statement in the `run()` method is used to direct the program flow based on the user's integer input for the menu choice. Each case corresponds to a specific action (add patient, schedule appointment, etc.).
 * 
 * **5. Output Streams (`System.out`, `System.err`):**
 * *   `System.out.println()` is used for displaying the menu, prompts for input, confirmation messages for successful operations, and listing patient/appointment details.
 * *   `System.err.println()` is used specifically for printing error messages, such as when a patient is not found during scheduling, when trying to process an empty queue, or when invalid input is detected (like non-numeric input).
 * 
 * **6. Exception Handling (`try-catch`):**
 * *   A main `try-catch` block wraps the core menu loop within the `run()` method. This block catches general `Exception` or `InputMismatchException` (specifically for non-integer menu input) to provide a degree of robustness against unexpected runtime errors or incorrect input formats, printing an error message to `System.err`.
 * *   Specific error conditions, like a patient not being found (`findPatientById` returning null) or the queue being empty (`appointmentQueue.poll()` returning null), are checked explicitly within the relevant methods (`scheduleAppointment`, `processNextAppointment`). When these conditions occur, an informative error message is printed to `System.err`, and the method returns or handles the situation appropriately without relying on a generic exception.
 * 
 * **7. Best Practices:**
 * *   **Encapsulation:** `Patient` and `Appointment` classes have private fields and public getter methods, controlling access to their internal state.
 * *   **Meaningful Names:** Class names (`Patient`, `Appointment`, `AppointmentScheduler`), variable names (`patientList`, `appointmentQueue`, `patientId`, `description`), and method names (`addPatient`, `scheduleAppointment`, `processNextAppointment`, `findPatientById`) are descriptive.
 * *   **Comments:** Basic comments explain the purpose of classes, methods, and key sections.
 * *   **Input Validation:** The `addPatient` method validates that age is positive. The `scheduleAppointment` method validates that the entered patient ID exists before creating the appointment. The main loop handles non-integer input for the menu.
 * *   **Error Handling:** As described above, both explicit checks with `System.err` and a general `try-catch` are used.
 * *   **Clean Code Structure:** The code is divided into logical methods, making the `run()` method clean and easy to understand as it primarily calls other helper methods.
 * 
 * **How Required Components are Used:**
 * 
 * *   `Queue`: Used as `appointmentQueue` to manage appointments in FIFO order. `offer()` adds, `poll()` removes from the front. Iteration is done using a simple enhanced for loop (which uses the queue's iterator).
 * *   `ArrayList`: Used as the concrete implementation for the `patientList`. `add()` is used to add patients, iteration is done using a for loop or enhanced for loop.
 * *   `List`: The `patientList` variable is declared using the `List` interface type, demonstrating polymorphism.
 * *   `Scanner`: Used in `run()`, `addPatient()`, and `scheduleAppointment()` to get user input.
 * *   `switch`: Used in `run()` to navigate the main menu options.
 * *   `System.err`: Used for all error messages.
 * *   `System.out`: Used for all normal output, prompts, and menu display.
 * *   `try-catch`: Used in `run()` for general exception handling and specifically for `InputMismatchException` during input reading. Specific validation checks also act as a form of error handling, directing output to `System.err`.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating understanding of fundamental and intermediate Java concepts, object-oriented design, and basic error handling practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a Patient
class Patient {
    private String patientId;
    private String name;
    private int age;

    // Constructor
    public Patient(String patientId, String name, int age) {
        this.patientId = patientId;
        this.name = name;
        this.age = age;
    }

    // Getters
    public String getPatientId() {
        return patientId;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // String representation for printing
    @Override
    public String toString() {
        return "Patient [ID=" + patientId + ", Name=" + name + ", Age=" + age + "]";
    }
}

// Represents an Appointment
class Appointment {
    private String appointmentId;
    private String patientId; // ID of the patient this appointment is for
    private String description;

    // Constructor
    public Appointment(String appointmentId, String patientId, String description) {
        this.appointmentId = appointmentId;
        this.patientId = patientId;
        this.description = description;
    }

    // Getters
    public String getAppointmentId() {
        return appointmentId;
    }

    public String getPatientId() {
        return patientId;
    }

    public String getDescription() {
        return description;
    }

    // String representation for printing
    @Override
    public String toString() {
        return "Appointment [ID=" + appointmentId + ", PatientID=" + patientId + ", Description=" + description + "]";
    }
}

// Main class for the Appointment Scheduler system
public class AppointmentScheduler {

    // Using List interface with ArrayList implementation for patients
    private List<Patient> patientList;
    // Using Queue interface with LinkedList implementation for appointments
    private Queue<Appointment> appointmentQueue;

    // Constructor
    public AppointmentScheduler() {
        patientList = new ArrayList<>();
        appointmentQueue = new LinkedList<>();
    }

    // Main method to run the scheduler
    public static void main(String[] args) {
        AppointmentScheduler scheduler = new AppointmentScheduler();
        scheduler.run();
    }

    // Runs the main menu loop
    public void run() {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;
            while (choice != 6) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addPatient(scanner);
                            break;
                        case 2:
                            scheduleAppointment(scanner);
                            break;
                        case 3:
                            processNextAppointment();
                            break;
                        case 4:
                            listPatients();
                            break;
                        case 5:
                            listPendingAppointments();
                            break;
                        case 6:
                            System.out.println("Exiting Appointment Scheduler. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to prevent accidental exit if 6 was partially entered
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging details
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
             // Catch any exception during scanner initialization or closure (less likely)
             System.err.println("A critical error occurred during setup: " + e.getMessage());
        }
    }

    // Prints the main menu
    private void printMenu() {
        System.out.println("--- Appointment Scheduler Menu ---");
        System.out.println("1. Add New Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. Process Next Appointment");
        System.out.println("4. List All Patients");
        System.out.println("5. List Pending Appointments");
        System.out.println("6. Exit");
    }

    // Adds a new patient based on user input
    private void addPatient(Scanner scanner) {
        System.out.println("--- Add New Patient ---");
        System.out.print("Enter Patient ID: ");
        String id = scanner.nextLine();

        // Basic check for empty ID (can be expanded for uniqueness check)
        if (id.trim().isEmpty()) {
             System.err.println("Patient ID cannot be empty.");
             return;
        }

        System.out.print("Enter Patient Name: ");
        String name = scanner.nextLine();

        int age = -1;
        while (age <= 0) {
            System.out.print("Enter Patient Age: ");
            try {
                age = scanner.nextInt();
                scanner.nextLine(); // Consume newline
                if (age <= 0) {
                    System.err.println("Age must be a positive number.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input for age. Please enter a number.");
                scanner.nextLine(); // Consume invalid input
            }
        }

        Patient newPatient = new Patient(id, name, age);
        patientList.add(newPatient);
        System.out.println("Patient added successfully: " + newPatient);
    }

    // Schedules a new appointment based on user input
    private void scheduleAppointment(Scanner scanner) {
        System.out.println("--- Schedule Appointment ---");
        System.out.print("Enter Appointment ID: ");
        String appId = scanner.nextLine();

        // Basic check for empty ID
         if (appId.trim().isEmpty()) {
             System.err.println("Appointment ID cannot be empty.");
             return;
        }

        System.out.print("Enter Patient ID for Appointment: ");
        String patientId = scanner.nextLine();

        // Validate if patient exists using the List
        Patient patient = findPatientById(patientId);
        if (patient == null) {
            System.err.println("Error: Patient with ID '" + patientId + "' not found.");
            return; // Stop scheduling if patient doesn't exist
        }

        System.out.print("Enter Appointment Description: ");
        String description = scanner.nextLine();

        Appointment newAppointment = new Appointment(appId, patientId, description);
        appointmentQueue.offer(newAppointment); // Add to the end of the queue
        System.out.println("Appointment scheduled successfully for " + patient.getName() + ": " + newAppointment);
    }

    // Processes the next appointment from the queue
    private void processNextAppointment() {
        System.out.println("--- Processing Next Appointment ---");
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        Appointment nextAppointment = appointmentQueue.poll();

        if (nextAppointment == null) {
            System.err.println("No pending appointments in the queue.");
        } else {
            System.out.println("Processing: " + nextAppointment);
            // In a real system, you'd do more here (e.g., update patient status, log)
            System.out.println("Appointment processed.");
        }
    }

    // Lists all registered patients
    private void listPatients() {
        System.out.println("--- All Patients ---");
        if (patientList.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            // Iterate through the List
            for (int i = 0; i < patientList.size(); i++) {
                 System.out.println((i + 1) + ". " + patientList.get(i));
            }
            // Or using enhanced for loop:
            // for (Patient patient : patientList) {
            //     System.out.println(patient);
            // }
        }
    }

    // Lists all pending appointments in the queue
    private void listPendingAppointments() {
        System.out.println("--- Pending Appointments ---");
        if (appointmentQueue.isEmpty()) {
            System.out.println("No pending appointments.");
        } else {
            // Iterate through the Queue without removing elements
            int count = 1;
            for (Appointment appointment : appointmentQueue) {
                System.out.println(count++ + ". " + appointment);
            }
        }
    }

    // Helper method to find a patient by ID in the list
    private Patient findPatientById(String patientId) {
        // Iterate through the List to find the patient
        for (Patient patient : patientList) {
            if (patient.getPatientId().equals(patientId)) {
                return patient;
            }
        }
        return null; // Return null if patient is not found
    }
}
