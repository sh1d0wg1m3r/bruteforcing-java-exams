/*
 * Exam Question #980
 * Generated on: 2025-05-12 17:08:12
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Event Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for managing attendees and tasks for a small event. The system needs to keep track of registered attendees and a list of tasks that need to be completed, processed in the order they were added.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a class `Attendee` with private fields for `name` (String) and `email` (String). Include a constructor and public getter methods for both fields.
 *     *   Create a class `EventTask` with private fields for `description` (String) and `priority` (int). Include a constructor and public getter methods for both fields. Override the `toString()` method in `EventTask` to provide a user-friendly representation (e.g., "Task: [description] (Priority: [priority])").
 * 
 * 2.  **Event Manager Logic:**
 *     *   Create a class `EventManager` that will manage the attendees and tasks.
 *     *   Inside `EventManager`, use a private `java.util.List` (specifically initialized as a `java.util.ArrayList`) to store `Attendee` objects.
 *     *   Inside `EventManager`, use a private `java.util.Queue` (specifically initialized as a `java.util.LinkedList` or `java.util.ArrayDeque` to act as a Queue) to store `EventTask` objects.
 *     *   Implement the following public methods in `EventManager`:
 *         *   `addAttendee(String name, String email)`: Adds a new `Attendee` to the list. Perform basic validation: name and email should not be empty. Return `true` on success, `false` otherwise.
 *         *   `addTask(String description, int priority)`: Adds a new `EventTask` to the queue. Perform basic validation: description should not be empty, priority should be a positive integer. Return `true` on success, `false` otherwise.
 *         *   `processNextTask()`: Removes and returns the next `EventTask` from the queue (FIFO). If the queue is empty, return `null`.
 *         *   `getAttendees()`: Returns the `List` of attendees.
 *         *   `getPendingTasks()`: Returns the `Queue` of pending tasks. (Note: Returning the actual queue/list might be considered less ideal encapsulation in some scenarios, but for this exam, it's acceptable to allow iteration in the main app).
 * 
 * 3.  **Main Application (`EventApp`):**
 *     *   Create a class `EventApp` with a `main` method.
 *     *   Inside `main`, instantiate `EventManager` and `java.util.Scanner`.
 *     *   Implement a command-line interface loop that presents the following options to the user:
 *         *   `1. Add Attendee`
 *         *   `2. Add Task`
 *         *   `3. Process Next Task`
 *         *   `4. View Attendees`
 *         *   `5. View Pending Tasks`
 *         *   `6. Exit`
 *     *   Use a `switch` statement to handle the user's chosen option.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation results (e.g., "Attendee added successfully.", "Processed task: ...").
 *     *   Use `System.err` for displaying error messages (e.g., "Invalid input.", "Task queue is empty.").
 *     *   Implement **class-wide exception handling** using a `try-catch` block that surrounds the main command-processing loop to catch unexpected runtime exceptions. Print an error message to `System.err` if an exception occurs within the loop.
 *     *   Ensure proper input validation when reading user input for attendee and task details (e.g., check for empty strings, handle non-integer input for priority). If input is invalid, print an error to `System.err` and do not proceed with adding the item.
 *     *   Close the `Scanner` resource when the program exits.
 * 
 * **Required Java Components to Use:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` block
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments.
 * *   Input validation and error handling as described.
 * *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, performing the requested operations, and providing feedback via `System.out` or `System.err`. Listing operations should print the current state of attendees or tasks.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * Event Management Menu:
 * 1. Add Attendee
 * 2. Add Task
 * 3. Process Next Task
 * 4. View Attendees
 * 5. View Pending Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Enter attendee email: alice@example.com
 * Attendee added successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 2
 * Enter task description: Set up chairs
 * Enter task priority (positive integer): 5
 * Task added successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 2
 * Enter task description: Arrange flowers
 * Enter task priority (positive integer): 3
 * Task added successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 5
 * Pending Tasks:
 * Task: Set up chairs (Priority: 5)
 * Task: Arrange flowers (Priority: 3)
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 3
 * Processed task: Task: Set up chairs (Priority: 5)
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 5
 * Pending Tasks:
 * Task: Arrange flowers (Priority: 3)
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 3
 * Processed task: Task: Arrange flowers (Priority: 3)
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 3
 * System.err: Task queue is empty.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 4
 * Registered Attendees:
 * Name: Alice, Email: alice@example.com
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 7
 * System.err: Invalid choice. Please enter a number between 1 and 6.
 * 
 * Event Management Menu:
 * ...
 * Enter your choice: 6
 * Exiting Event Management System.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on its correctness, adherence to all specified requirements (including the use of all listed Java components), code quality, error handling, and overall design.
 *
 * EXPLANATION:
 * This solution implements a simple Event Management System as requested, demonstrating the required Java concepts and following best practices.
 * 
 * 1.  **Classes (`Attendee`, `EventTask`):**
 *     *   These classes are simple Plain Old Java Objects (POJOs) representing the core data entities.
 *     *   They use `private` fields for encapsulation and `public` getter methods to access the data.
 *     *   `EventTask` overrides `toString()` for convenient printing.
 * 
 * 2.  **`EventManager` Class:**
 *     *   This class acts as the central manager holding the application's state (attendees and tasks).
 *     *   It uses a `List<Attendee>` (specifically initialized as `ArrayList<Attendee>`) to store attendees, allowing dynamic resizing and easy iteration/access.
 *     *   It uses a `Queue<EventTask>` (specifically initialized as `LinkedList<EventTask>`) to store tasks. `LinkedList` is a common implementation of `Queue` that provides FIFO behavior suitable for processing tasks in order.
 *     *   Methods like `addAttendee`, `addTask`, and `processNextTask` encapsulate the logic for manipulating these data structures.
 *     *   Basic input validation (checking for empty strings or non-positive priority) is included in the `add` methods.
 * 
 * 3.  **`EventApp` (Main Application):**
 *     *   The `main` method in `EventApp` drives the application.
 *     *   It initializes the `EventManager` and `Scanner`.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   The `printMenu()` method displays the available options.
 *     *   User input is read using `scanner.nextInt()` for the choice and `scanner.nextLine()` for strings.
 *     *   **`try-catch` for Input:** A nested `try-catch` is used specifically around `scanner.nextInt()` to gracefully handle cases where the user enters non-integer input for the menu choice or task priority (`InputMismatchException`). `scanner.nextLine()` is called in the `catch` block to consume the invalid input and prevent an infinite loop.
 *     *   **`switch` Statement:** A `switch` statement is used to direct the program flow based on the user's valid menu choice, calling the appropriate `EventManager` methods.
 *     *   **`System.out` and `System.err`:** `System.out` is used for normal output like menus, prompts, success messages, and listing data. `System.err` is used specifically for printing error messages (e.g., validation errors, empty queue).
 *     *   **Class-wide `try-catch`:** The *entire* main `while` loop is wrapped in a `try-catch(Exception e)` block. This provides a safety net to catch any unexpected runtime exceptions that might occur anywhere within the command processing logic (other than the specific `InputMismatchException` handled locally). If such an exception occurs, an error message and the stack trace are printed to `System.err`, and the `finally` block ensures the `Scanner` is closed.
 *     *   **`List` and `Queue` Usage:** The `View Attendees` case iterates through the `List` of attendees. The `View Pending Tasks` case iterates through the `Queue` of tasks. Iterating a `Queue` using a for-each loop or iterator allows viewing elements without removing them, which is suitable for listing. `processNextTask` correctly uses `queue.poll()` to remove the head element.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to ensure it's released regardless of whether the loop finishes normally or an exception occurs.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, albeit simple, application structure, demonstrating understanding of object-oriented design, data structures, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList can implement Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Needed for handling non-integer input

// Represents an attendee for the event
class Attendee {
    private String name;
    private String email;

    // Constructor
    public Attendee(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Public getter for name
    public String getName() {
        return name;
    }

    // Public getter for email
    public String getEmail() {
        return email;
    }

    // User-friendly string representation
    @Override
    public String toString() {
        return "Name: " + name + ", Email: " + email;
    }
}

// Represents a task for the event
class EventTask {
    private String description;
    private int priority;

    // Constructor
    public EventTask(String description, int priority) {
        this.description = description;
        this.priority = priority;
    }

    // Public getter for description
    public String getDescription() {
        return description;
    }

    // Public getter for priority
    public int getPriority() {
        return priority;
    }

    // User-friendly string representation
    @Override
    public String toString() {
        return "Task: " + description + " (Priority: " + priority + ")";
    }
}

// Manages attendees and tasks for the event
class EventManager {
    private List<Attendee> attendees;
    private Queue<EventTask> pendingTasks;

    // Constructor
    public EventManager() {
        // Use ArrayList for attendees list
        this.attendees = new ArrayList<>();
        // Use LinkedList as a Queue for tasks
        this.pendingTasks = new LinkedList<>();
    }

    /**
     * Adds a new attendee to the list.
     *
     * @param name The name of the attendee.
     * @param email The email of the attendee.
     * @return true if attendee was added successfully, false otherwise (due to validation).
     */
    public boolean addAttendee(String name, String email) {
        // Basic validation
        if (name == null || name.trim().isEmpty() || email == null || email.trim().isEmpty()) {
            System.err.println("Error: Attendee name and email cannot be empty.");
            return false;
        }
        attendees.add(new Attendee(name.trim(), email.trim()));
        return true;
    }

    /**
     * Adds a new task to the queue.
     *
     * @param description The description of the task.
     * @param priority The priority of the task (positive integer).
     * @return true if task was added successfully, false otherwise (due to validation).
     */
    public boolean addTask(String description, int priority) {
        // Basic validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        if (priority <= 0) {
            System.err.println("Error: Task priority must be a positive integer.");
            return false;
        }
        pendingTasks.offer(new EventTask(description.trim(), priority)); // offer is preferred for capacity-constrained queues, but works fine here
        return true;
    }

    /**
     * Processes (removes) the next task from the queue.
     *
     * @return The processed EventTask, or null if the queue is empty.
     */
    public EventTask processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        return pendingTasks.poll();
    }

    /**
     * Returns the list of registered attendees.
     *
     * @return The List of Attendee objects.
     */
    public List<Attendee> getAttendees() {
        return attendees;
    }

    /**
     * Returns the queue of pending tasks.
     *
     * @return The Queue of EventTask objects.
     */
    public Queue<EventTask> getPendingTasks() {
        return pendingTasks;
    }
}

// Main application class
public class EventApp {

    public static void main(String[] args) {
        EventManager manager = new EventManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip to the next iteration
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1: // Add Attendee
                        System.out.print("Enter attendee name: ");
                        String attendeeName = scanner.nextLine();
                        System.out.print("Enter attendee email: ");
                        String attendeeEmail = scanner.nextLine();
                        if (manager.addAttendee(attendeeName, attendeeEmail)) {
                            System.out.println("Attendee added successfully.");
                        }
                        break;

                    case 2: // Add Task
                        System.out.print("Enter task description: ");
                        String taskDescription = scanner.nextLine();
                        int taskPriority = -1;
                        System.out.print("Enter task priority (positive integer): ");
                        try {
                            taskPriority = scanner.nextInt();
                            // Consume the newline
                            scanner.nextLine();
                            if (manager.addTask(taskDescription, taskPriority)) {
                                System.out.println("Task added successfully.");
                            }
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for priority. Please enter an integer.");
                            // Consume the invalid input
                            scanner.nextLine();
                        }
                        break;

                    case 3: // Process Next Task
                        EventTask processedTask = manager.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processed task: " + processedTask);
                        } else {
                            System.err.println("Task queue is empty.");
                        }
                        break;

                    case 4: // View Attendees
                        List<Attendee> attendees = manager.getAttendees();
                        if (attendees.isEmpty()) {
                            System.out.println("No attendees registered yet.");
                        } else {
                            System.out.println("Registered Attendees:");
                            // Using List interface reference
                            for (Attendee attendee : attendees) {
                                System.out.println(attendee);
                            }
                        }
                        break;

                    case 5: // View Pending Tasks
                        Queue<EventTask> pendingTasks = manager.getPendingTasks();
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            System.out.println("Pending Tasks:");
                            // Iterate through the Queue (order is preserved)
                            // Note: Iterating a Queue doesn't remove elements
                            for (EventTask task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Event Management System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred during system operation:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Event Management Menu:");
        System.out.println("1. Add Attendee");
        System.out.println("2. Add Task");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Attendees");
        System.out.println("5. View Pending Tasks");
        System.out.println("6. Exit");
    }
}
