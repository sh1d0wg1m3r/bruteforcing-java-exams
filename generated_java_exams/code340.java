/*
 * Exam Question #340
 * Generated on: 2025-05-11 22:57:20
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam: Hospital Appointment Scheduler
 * 
 * **Objective:** Design and implement a simplified hospital appointment scheduling system using core Java collections, input handling, control flow, and exception management.
 * 
 * **Scenario:** You are building a basic system for a small clinic. Patients arrive and are added to a waiting list (a queue). The receptionist can then schedule the next patient from the waiting list for an appointment with a specific doctor at a given time. The system should allow viewing the waiting list and the list of scheduled appointments.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the waiting list of patients.
 *     *   Use a `java.util.ArrayList` to store scheduled appointments.
 *     *   Declare the variable holding scheduled appointments using the `java.util.List` interface.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input for menu selections and patient/appointment details.
 *     *   Present a menu of options to the user:
 *         1.  Add Patient to Waiting List
 *         2.  Schedule Next Patient from Waiting List
 *         3.  View Waiting List
 *         4.  View Scheduled Appointments
 *         5.  Exit
 *     *   Continuously loop the menu until the user chooses to exit.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and list contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu input, trying to schedule from an empty queue, invalid patient/appointment data).
 * 5.  **Error Handling:**
 *     *   Implement input validation for menu choices (ensure it's a valid integer within the range) and potentially for patient/appointment details (e.g., non-empty names).
 *     *   Use `try-catch` blocks for exception handling. Specifically, handle potential `java.util.InputMismatchException` when reading integer input and any other relevant exceptions during operations. Implement class-wide or method-level exception handling to manage potential issues during the program's execution loop.
 *     *   Handle the case where the user tries to schedule an appointment when the waiting queue is empty, printing an error message to `System.err`.
 * 6.  **Class Design:**
 *     *   Create a `Patient` class (with fields like `id` and `name`, appropriate getters/setters).
 *     *   Create an `Appointment` class (with fields like `patient`, `time`, `doctor`, appropriate getters/setters).
 *     *   Create a main class (e.g., `HospitalScheduler`) containing the `main` method and the logic for managing the queue and list, and the user interaction loop.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc to explain code sections.
 *     *   Ensure the `Scanner` resource is closed properly (e.g., using `try-with-resources`).
 * 
 * **Expected Output:**
 * The program should display a menu, accept user input, perform the requested action (adding to queue, scheduling, viewing lists), handle errors gracefully by printing to `System.err`, and continue until the user chooses to exit. Displayed lists should clearly show the contents of the queue and the scheduled appointments.
 * 
 * **Evaluation Criteria:**
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Effective use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Robust exception handling with `try-catch` blocks.
 * *   Proper implementation of input validation and error conditions (e.g., empty queue).
 * *   Good class design with encapsulation.
 * *   Clean, readable code following best practices (naming, comments, resource management).
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Scheduler system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` class: Simple POJO (Plain Old Java Object) with `id` and `name`. Uses private fields and public getters for encapsulation. `toString()` is overridden for easy printing.
 *     *   `Appointment` class: Simple POJO linking a `Patient` object with `time` and `doctor` information. Uses private fields and public getters. `toString()` is overridden.
 *     *   `HospitalScheduler` class: Contains the main logic. It holds the `waitingQueue` (a `Queue` of `Patient` objects) and `scheduledAppointments` (a `List` of `Appointment` objects). It also contains the methods for the menu operations and the `main` method to run the application.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `waitingQueue`: Declared as `Queue<Patient>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing methods like `offer()` (add to end) and `poll()` (remove from front) which are fundamental to queue behavior.
 *     *   `scheduledAppointments`: Declared as `List<Appointment>` and initialized with `new ArrayList<>()`. `ArrayList` is chosen as it's a common and efficient implementation of `List` for storing and accessing elements by index, suitable for a list of scheduled items. The variable is declared using the `List` interface, adhering to the principle of programming to interfaces.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   The `Scanner` is managed using a `try-with-resources` block in the `main` method. This ensures the `Scanner` is automatically closed when the `try` block finishes, preventing resource leaks.
 *     *   `scanner.nextInt()` is used for the menu choice, and `scanner.nextLine()` is used for reading strings (patient name, time, doctor). A common pitfall with `nextInt()` is that it consumes only the integer, leaving the newline character in the buffer. A `scanner.nextLine()` call immediately after `nextInt()` is used to consume this leftover newline, preventing issues with subsequent `nextLine()` calls.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The main loop in the `main` method reads the user's menu choice.
 *     *   A `switch` statement is used to direct execution to the appropriate method (`addPatientToQueue`, `scheduleNextPatient`, `viewWaitingList`, `viewScheduledAppointments`) based on the user's integer input.
 *     *   A `default` case in the `switch` handles invalid integer inputs.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for all normal output: displaying the menu, prompts, success messages, and the contents of the lists.
 *     *   `System.err.println()` is specifically used for error messages: invalid menu input, trying to schedule from an empty queue, empty patient/appointment details, and unexpected runtime errors. This differentiates error output from normal program flow output.
 * 
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch(InputMismatchException)` block is wrapped around the `scanner.nextInt()` call for reading the menu choice. If the user enters non-integer input, this block catches the exception, prints an error to `System.err`, consumes the invalid input using `scanner.next()`, and the `continue` statement restarts the loop, showing the menu again.
 *     *   A broader `try-catch(Exception e)` block is placed around the main `while(running)` loop within the `try-with-resources` block. This serves as a class-wide (or rather, main execution block) exception handler, catching any other unexpected runtime exceptions that might occur during the program's operation and printing an error message and stack trace to `System.err`.
 *     *   Specific logic within `scheduleNextPatient` checks if the `waitingQueue` is empty *before* attempting to `poll()`. If empty, it prints an error to `System.err` and returns, fulfilling the requirement to handle this specific error condition.
 *     *   Basic validation for empty strings is added when adding a patient or scheduling, printing errors to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters are used in `Patient` and `Appointment`.
 *     *   **Naming:** Variables (`waitingQueue`, `scheduledAppointments`, `patientCounter`), methods (`addPatientToQueue`, `scheduleNextPatient`, `viewWaitingList`), and classes have clear, descriptive names.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods. Inline comments explain specific logic points (like consuming the newline after `nextInt`).
 *     *   **Input Validation:** Checks for empty names/details and handles non-integer menu input.
 *     *   **Error Handling:** Explicitly handles `InputMismatchException` and the empty queue condition, using `System.err`. A general catch block provides robustness against unforeseen errors.
 *     *   **Clean Structure:** The code is organized into logical methods within the `HospitalScheduler` class, making the `main` method clean and easy to follow. `try-with-resources` ensures resource management.
 * 
 * This solution effectively integrates all required Java components within a practical scenario, demonstrating understanding of collections, I/O, control flow, and robust error handling.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient waiting for an appointment
class Patient {
    private int id;
    private String name;

    // Constructor
    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private String time;
    private String doctor;

    // Constructor
    public Appointment(Patient patient, String time, String doctor) {
        this.patient = patient;
        this.time = time;
        this.doctor = doctor;
    }

    // Getters
    public Patient getPatient() {
        return patient;
    }

    public String getTime() {
        return time;
    }

    public String getDoctor() {
        return doctor;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Appointment [Patient=" + patient.getName() + ", Time=" + time + ", Doctor=" + doctor + "]";
    }
}

// Main class for the Hospital Scheduler system
public class HospitalScheduler {

    // Queue for patients waiting to be scheduled
    private Queue<Patient> waitingQueue;
    // List for scheduled appointments
    private List<Appointment> scheduledAppointments;
    private int patientCounter = 1; // Simple counter for unique patient IDs

    // Constructor
    public HospitalScheduler() {
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        scheduledAppointments = new ArrayList<>(); // ArrayList implements List
    }

    // Method to display the main menu
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment Scheduler ---");
        System.out.println("1. Add Patient to Waiting List");
        System.out.println("2. Schedule Next Patient from Waiting List");
        System.out.println("3. View Waiting List");
        System.out.println("4. View Scheduled Appointments");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Method to add a new patient to the waiting queue
    public void addPatientToQueue(Scanner scanner) {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        Patient newPatient = new Patient(patientCounter++, name);
        waitingQueue.offer(newPatient); // Add patient to the end of the queue
        System.out.println("Patient '" + name + "' added to the waiting list. ID: " + newPatient.getId());
    }

    // Method to schedule the next patient from the queue
    public void scheduleNextPatient(Scanner scanner) {
        // Check if the queue is empty
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting list is empty. Cannot schedule an appointment.");
            return;
        }

        // Poll the next patient from the front of the queue
        Patient nextPatient = waitingQueue.poll();
        System.out.println("Scheduling appointment for: " + nextPatient.getName() + " (ID: " + nextPatient.getId() + ")");

        System.out.print("Enter appointment time (e.g., 10:00 AM): ");
        String time = scanner.nextLine().trim();

        System.out.print("Enter doctor's name: ");
        String doctor = scanner.nextLine().trim();

        if (time.isEmpty() || doctor.isEmpty()) {
             System.err.println("Error: Appointment time and doctor's name cannot be empty. Patient returned to queue.");
             waitingQueue.offer(nextPatient); // Optionally return patient to queue if details are invalid
             return;
        }


        // Create a new appointment and add it to the scheduled list
        Appointment newAppointment = new Appointment(nextPatient, time, doctor);
        scheduledAppointments.add(newAppointment); // Add appointment to the list

        System.out.println("Appointment scheduled successfully for " + nextPatient.getName() +
                           " at " + time + " with Dr. " + doctor + ".");
    }

    // Method to view the current waiting list
    public void viewWaitingList() {
        System.out.println("\n--- Current Waiting List ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate and print elements without removing them
            int index = 1;
            for (Patient patient : waitingQueue) {
                System.out.println(index++ + ". " + patient);
            }
        }
    }

    // Method to view the list of scheduled appointments
    public void viewScheduledAppointments() {
        System.out.println("\n--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            // Iterate and print elements
            int index = 1;
            for (Appointment appointment : scheduledAppointments) {
                System.out.println(index++ + ". " + appointment);
            }
        }
    }

    // Main method to run the scheduler
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    scheduler.displayMenu();
                    int choice = -1; // Default invalid choice

                    // Handle potential InputMismatchException for menu choice
                    try {
                        choice = scanner.nextInt();
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip the rest of the loop and show menu again
                    } finally {
                         // Consume the newline character left by nextInt()
                         // This is crucial before calling nextLine() in subsequent reads
                         scanner.nextLine();
                    }


                    // Use switch statement for menu actions
                    switch (choice) {
                        case 1:
                            scheduler.addPatientToQueue(scanner);
                            break;
                        case 2:
                            scheduler.scheduleNextPatient(scanner);
                            break;
                        case 3:
                            scheduler.viewWaitingList();
                            break;
                        case 4:
                            scheduler.viewScheduledAppointments();
                            break;
                        case 5:
                            System.out.println("Exiting Hospital Scheduler. Goodbye!");
                            running = false;
                            break;
                        default:
                            // Handle invalid menu options
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }

        } // Scanner is automatically closed here by try-with-resources
        System.out.println("Application terminated.");
    }
}
