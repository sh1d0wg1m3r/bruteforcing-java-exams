/*
 * Exam Question #197
 * Generated on: 2025-05-11 22:30:32
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Restaurant Order Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based Restaurant Order Management System. The system should allow staff to manage customer orders, from placing an order based on a menu to preparing the next order in the queue.
 * 
 * The system must adhere to the following functional requirements:
 * 
 * 1.  **View Menu:** Display the available menu items with their IDs, names, and prices.
 * 2.  **Place New Order:** Allow the user to select multiple menu items by entering a comma-separated list of item IDs. The system should validate the input IDs against the menu. If valid, create an `Order` object containing the selected items and add it to a queue of pending orders. Each order should have a unique, automatically generated ID.
 * 3.  **Prepare Next Order:** Remove the oldest pending order from the queue and display its details, simulating the preparation and completion of the order. If the queue is empty, display an appropriate message.
 * 4.  **View Pending Orders:** Display the details of all orders currently waiting in the queue, without removing them.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must utilize ALL of the following Java components:
 * 
 * *   `java.util.Queue` (use an implementation like `LinkedList` or `ArrayDeque`)
 * *   `java.util.ArrayList`
 * *   `java.util.List` (as an interface type)
 * *   `java.util.Scanner` for handling user input from the console.
 * *   `switch` statement for controlling the main application flow based on user choices.
 * *   `System.err` for displaying all error messages (e.g., invalid input, item not found, empty queue).
 * *   `System.out` for displaying all normal output (e.g., menu, prompts, order details, success messages).
 * *   Class-wide exception handling using `try-catch` blocks to manage potential runtime errors, including specific handling for expected issues (like invalid input format or business logic errors) and a general catch for unexpected exceptions.
 * 
 * **Design and Best Practices:**
 * 
 * *   Implement proper encapsulation (private fields, public methods) for your classes.
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include basic comments or documentation where necessary to explain complex parts.
 * *   Implement robust input validation for user entries (e.g., ensuring menu choices are numbers within range, item IDs are valid integers).
 * *   Implement proper error handling for business logic errors (e.g., attempting to prepare an order when none exist) and input errors, directing error output to `System.err`.
 * *   Structure your code into appropriate classes (e.g., `MenuItem`, `Order`, `RestaurantManagement`, and a main application class).
 * 
 * **Expected Output:**
 * 
 * *   The application should start with a welcome message.
 * *   The main menu with options (1-5) should be displayed repeatedly until the user chooses to exit.
 * *   Choosing option 4 should display the menu.
 * *   Choosing option 1 should prompt for item IDs, validate them, and confirm the order placement or report an error.
 * *   Choosing option 2 should display the prepared order or report that the queue is empty.
 * *   Choosing option 3 should list pending orders or report that none exist.
 * *   Choosing option 5 should display an exit message and terminate.
 * *   Any invalid input or operational error should result in an informative message printed to `System.err`. Unexpected errors should be caught and reported.
 * 
 * Your solution should be a single, cohesive Java program.
 *
 * EXPLANATION:
 * This solution implements a basic Restaurant Order Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Overall Structure:** The code is organized into four classes:
 *     *   `MenuItem`: Represents a single item on the menu with ID, name, and price.
 *     *   `Order`: Represents a customer order, containing a list of `MenuItem`s and a unique order ID.
 *     *   `RestaurantManagement`: Manages the core logic, holding the list of menu items and the queue of pending orders. It provides methods for viewing the menu, placing orders, preparing orders, and viewing pending orders.
 *     *   `RestaurantApp`: Contains the `main` method, handles user interaction via the console (`Scanner`), controls the main application loop, and delegates tasks to the `RestaurantManagement` object.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `pendingOrders` field in `RestaurantManagement` is declared as a `Queue<Order>` and initialized with a `LinkedList<Order>`. `LinkedList` is a common implementation of `Queue` suitable for adding to the end and removing from the front. Methods like `offer()` (to add) and `poll()` (to remove) are used.
 *     *   `java.util.ArrayList`: Used to store the `menu` items (`List<MenuItem> menu = new ArrayList<>();`) and also used internally within the `Order` class to store the list of items for that specific order (`List<MenuItem> items = new ArrayList<>(items);`).
 *     *   `java.util.List`: Used as the interface type for the `menu` field in `RestaurantManagement` and the `items` field in the `Order` class. This promotes flexibility as other `List` implementations could potentially be used.
 *     *   `java.util.Scanner`: An instance is created in the `main` method (`Scanner scanner = new Scanner(System.in);`) to read user input from the console. Methods like `nextInt()` and `nextLine()` are used.
 *     *   `switch`: A `switch` statement in the `main` method controls the application flow based on the user's numerical choice from the main menu.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid menu choices, incorrect input formats, non-existent menu items, or attempts to prepare orders when the queue is empty.
 *     *   `System.out`: Used for all standard output, including the welcome message, menu display, prompts for input, confirmation messages, and details of placed or prepared orders.
 *     *   Class-wide `try-catch`: The main `while(true)` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This serves as a top-level handler for any unexpected runtime exceptions that might occur and weren't caught by more specific handlers, preventing the program from crashing and printing a general error message to `System.err`. Additionally, specific `try-catch` blocks are used around input reading (`scanner.nextInt()`) and method calls that might throw custom exceptions (`restaurant.placeOrder()`, `restaurant.prepareNextOrder()`).
 * 
 * 3.  **Input Handling and Validation:**
 *     *   The main menu choice uses a `try-catch` block around `scanner.nextInt()` to catch `InputMismatchException` if the user enters non-integer input. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to avoid an infinite loop.
 *     *   After reading an integer with `nextInt()`, `scanner.nextLine()` is called in a `finally` block to consume the remaining newline character, which is crucial to prevent issues with subsequent `nextLine()` calls.
 *     *   Placing an order involves reading a comma-separated string of IDs using `scanner.nextLine()`. This string is split, and each part is parsed into an integer using `Integer.parseInt()`. A `try-catch(NumberFormatException)` is used to handle cases where a part is not a valid integer.
 *     *   The `RestaurantManagement.placeOrder()` method validates if the list of item IDs is empty and calls `getMenuItemById()` for each ID. `getMenuItemById()` throws a custom `InvalidMenuItemException` if an ID doesn't correspond to a menu item, which is caught and reported to `System.err` in the `main` method.
 * 
 * 4.  **Error Handling:**
 *     *   Specific custom exceptions (`InvalidMenuItemException`, `EmptyQueueException`) are used to signal business logic errors from the `RestaurantManagement` class.
 *     *   These custom exceptions, along with standard exceptions like `InputMismatchException` and `NumberFormatException`, are caught using `try-catch` blocks.
 *     *   All error messages are explicitly printed to `System.err`.
 *     *   The top-level `try-catch` in `main` provides a fallback for unexpected errors, printing the stack trace to `System.err` for debugging.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `MenuItem`, `Order`, and `RestaurantManagement` are `private`. Access and modification are controlled through public methods (getters, `placeOrder`, `prepareNextOrder`, etc.). Defensive copies (`new ArrayList<>(items)`) and unmodifiable views (`Collections.unmodifiableList()`) are used where appropriate to prevent external code from modifying internal lists.
 *     *   **Naming:** Class names (`MenuItem`, `Order`, `RestaurantManagement`, `RestaurantApp`), variable names (`pendingOrders`, `itemIds`, `preparedOrder`), and method names (`placeOrder`, `prepareNextOrder`, `viewPendingOrders`) are descriptive.
 *     *   **Code Structure:** Logic is separated into classes based on responsibility. The `main` method focuses on the application loop and user interaction, delegating core business logic to `RestaurantManagement`.
 *     *   **Resource Management:** The `Scanner` object is closed using `scanner.close()` when the application exits, either normally or via the `finally` block in case of an unexpected error.
 *     *   **Unique IDs:** `AtomicInteger` is used in the `Order` class to generate unique, sequential order IDs in a thread-safe manner (although only a single thread is used here, it's good practice).
 * 
 * This solution effectively integrates the required Java components to build a functional and well-structured application that handles user input, manages data using appropriate collections, controls flow, and implements robust error handling, fulfilling the requirements of a challenging exam task.
 */

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger; // For unique order IDs

// Custom Exceptions (optional but good practice for specific error types)
class InvalidMenuItemException extends Exception {
    public InvalidMenuItemException(String message) {
        super(message);
    }
}

class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single menu item in the restaurant.
 */
class MenuItem {
    private int id;
    private String name;
    private double price;

    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return id + ". " + name + " - $" + String.format("%.2f", price);
    }
}

/**
 * Represents a customer order, containing multiple menu items.
 */
class Order {
    // AtomicInteger for thread-safe unique order ID generation (good practice)
    private static final AtomicInteger orderCounter = new AtomicInteger(0);
    private int orderId;
    private List<MenuItem> items; // Using List interface
    private double total;

    public Order(List<MenuItem> items) {
        this.orderId = orderCounter.incrementAndGet();
        // Create a new ArrayList to store items, preventing external modification of the order's item list
        this.items = new ArrayList<>(items);
        calculateTotal();
    }

    // Calculate the total price of the order
    private void calculateTotal() {
        this.total = items.stream().mapToDouble(MenuItem::getPrice).sum();
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    // Return an unmodifiable list to prevent external modification
    public List<MenuItem> getItems() {
        return Collections.unmodifiableList(items);
    }

    public double getTotal() {
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" (Total: $").append(String.format("%.2f", total)).append("):\n");
        // Using List iteration
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append("\n");
        }
        return sb.toString();
    }
}

/**
 * Manages the restaurant's menu and pending orders.
 */
class RestaurantManagement {
    // Using ArrayList for the menu, implementing List interface
    private List<MenuItem> menu;
    // Using LinkedList for the pending orders queue, implementing Queue interface
    private Queue<Order> pendingOrders;

    public RestaurantManagement() {
        menu = new ArrayList<>();
        pendingOrders = new LinkedList<>();
        initializeMenu();
    }

    // Populate the menu with some initial items
    private void initializeMenu() {
        menu.add(new MenuItem(101, "Classic Burger", 8.99));
        menu.add(new MenuItem(102, "French Fries", 3.49));
        menu.add(new MenuItem(103, "Pepperoni Pizza", 12.99));
        menu.add(new MenuItem(104, "Garden Salad", 7.50));
        menu.add(new MenuItem(105, "Cola", 1.99));
        menu.add(new MenuItem(106, "Orange Juice", 2.49));
    }

    // Return an unmodifiable view of the menu
    public List<MenuItem> getMenu() {
        return Collections.unmodifiableList(menu);
    }

    /**
     * Finds a menu item by its ID.
     * @param id The ID of the menu item.
     * @return The MenuItem object.
     * @throws InvalidMenuItemException if the item ID does not exist.
     */
    public MenuItem getMenuItemById(int id) throws InvalidMenuItemException {
        // Iterate through the ArrayList menu
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        // Item not found
        throw new InvalidMenuItemException("Menu item with ID " + id + " not found.");
    }

    /**
     * Creates a new order from a list of item IDs and adds it to the pending queue.
     * @param itemIds A list of IDs of the items to include in the order.
     * @throws InvalidMenuItemException if any of the item IDs are invalid or the list is empty.
     */
    public void placeOrder(List<Integer> itemIds) throws InvalidMenuItemException {
        if (itemIds == null || itemIds.isEmpty()) {
            throw new InvalidMenuItemException("Cannot place an empty order. Please select items.");
        }

        List<MenuItem> orderedItems = new ArrayList<>(); // Use ArrayList for items in the order
        for (Integer itemId : itemIds) {
            // getMenuItemById throws InvalidMenuItemException if ID is not found
            orderedItems.add(getMenuItemById(itemId));
        }

        Order newOrder = new Order(orderedItems);
        // Add the new order to the pending orders queue
        pendingOrders.offer(newOrder); // offer() is a standard Queue method to add
        System.out.println("Order #" + newOrder.getOrderId() + " placed successfully.");
    }

    /**
     * Removes and returns the next order from the pending queue.
     * @return The next Order to be prepared.
     * @throws EmptyQueueException if there are no pending orders.
     */
    public Order prepareNextOrder() throws EmptyQueueException {
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        Order nextOrder = pendingOrders.poll();
        if (nextOrder == null) {
            throw new EmptyQueueException("No pending orders to prepare.");
        }
        return nextOrder;
    }

    /**
     * Displays all orders currently in the pending queue without removing them.
     */
    public void viewPendingOrders() {
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
            return;
        }
        System.out.println("\n--- Pending Orders ---");
        // Iterate through the Queue using its iterator (does not remove elements)
        Iterator<Order> iterator = pendingOrders.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        System.out.println("----------------------\n");
    }

    /**
     * Displays the restaurant menu.
     */
    public void viewMenu() {
        System.out.println("\n--- Menu ---");
        // Iterate through the ArrayList menu
        for (MenuItem item : menu) {
            System.out.println(item); // MenuItem's toString() is used here
        }
        System.out.println("------------\n");
    }
}

/**
 * Main class to run the Restaurant Order Management application.
 * Handles user interaction and delegates tasks to RestaurantManagement.
 */
public class RestaurantApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RestaurantManagement restaurant = new RestaurantManagement();

        System.out.println("Welcome to the Restaurant Order Management System!");

        // --- Class-wide Exception Handling ---
        // This try-catch block wraps the main application loop to catch any
        // unhandled exceptions that might occur during execution, preventing
        // the program from crashing abruptly and providing a general error message.
        try {
            // --- Main Application Loop ---
            while (true) {
                System.out.println("\nChoose an action:");
                System.out.println("1. Place New Order");
                System.out.println("2. Prepare Next Order");
                System.out.println("3. View Pending Orders");
                System.out.println("4. View Menu");
                System.out.println("5. Exit");
                System.out.print("Enter choice: ");

                int choice = -1;
                // --- Input Handling and Validation with try-catch ---
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input format. Please enter a number for your choice.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    // Consume the newline character left by nextInt() to avoid issues with nextLine()
                    scanner.nextLine();
                }

                // --- Flow Control using switch statement ---
                switch (choice) {
                    case 1: // Place New Order
                        restaurant.viewMenu(); // Show menu first to help user choose
                        System.out.print("Enter comma-separated menu item IDs to order (e.g., 101,102): ");
                        String itemIdsString = scanner.nextLine();
                        String[] idStrings = itemIdsString.split(",");
                        List<Integer> itemIds = new ArrayList<>(); // Use ArrayList for collecting input IDs
                        boolean inputError = false;

                        if (itemIdsString.trim().isEmpty()) {
                             System.err.println("No item IDs entered. Order not placed.");
                             break; // Exit this case
                        }

                        // Parse and validate item IDs
                        for (String idStr : idStrings) {
                            try {
                                int id = Integer.parseInt(idStr.trim());
                                itemIds.add(id);
                            } catch (NumberFormatException e) {
                                System.err.println("Invalid item ID format: '" + idStr.trim() + "'. Please enter numbers only.");
                                inputError = true;
                                break; // Stop processing this order request on first error
                            }
                        }

                        // If parsing was successful, attempt to place the order
                        if (!inputError) {
                            try {
                                restaurant.placeOrder(itemIds);
                            } catch (InvalidMenuItemException e) {
                                // Catch specific business logic error (e.g., item ID not on menu)
                                System.err.println("Error placing order: " + e.getMessage());
                            }
                        }
                        break;

                    case 2: // Prepare Next Order
                        try {
                            Order preparedOrder = restaurant.prepareNextOrder();
                            System.out.println("--- Prepared Order ---");
                            System.out.println(preparedOrder); // Order's toString() is used here
                            System.out.println("----------------------");
                        } catch (EmptyQueueException e) {
                            // Catch specific business logic error (e.g., queue is empty)
                            System.err.println("Error preparing order: " + e.getMessage());
                        }
                        break;

                    case 3: // View Pending Orders
                        restaurant.viewPendingOrders();
                        break;

                    case 4: // View Menu
                        restaurant.viewMenu();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Restaurant Order Management System. Goodbye!");
                        scanner.close(); // Close the scanner resource
                        System.exit(0); // Terminate the application
                        break; // break is technically redundant after System.exit(0) but good practice

                    default:
                        // Handle choices outside the expected range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // --- General Catch for Unexpected Errors ---
            // This catches any Exception that wasn't specifically handled elsewhere
            System.err.println("\nAn unexpected system error occurred:");
            // Print the stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed even if an exception occurred
             if (scanner != null) {
                 scanner.close();
             }
        }
    }
}
