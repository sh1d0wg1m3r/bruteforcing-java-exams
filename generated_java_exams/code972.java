/*
 * Exam Question #972
 * Generated on: 2025-05-12 17:06:59
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Waiting List Management**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for a hospital clinic to manage patient waiting lists for consultations. Patients arrive and are added to a waiting list. When a doctor becomes available, the next patient in line is called in. The system needs to handle basic operations like adding patients, viewing the current waiting list, and processing the next patient.
 * 
 * **Requirements:**
 * Develop a Java program that implements this system. Your solution must adhere to the following:
 * 
 * 1.  **Core Functionality:**
 *     *   Present a menu to the user with options:
 *         1.  Add Patient to Waiting List
 *         2.  View Waiting List
 *         3.  Process Next Patient
 *         4.  Exit
 *     *   Implement each menu option.
 *     *   Adding a patient should prompt for the patient's name and a brief description of their issue.
 *     *   Viewing the waiting list should display the patients in the order they will be processed.
 *     *   Processing the next patient should remove the patient at the front of the waiting list and indicate which patient is being processed. Keep track of processed patients in a separate list.
 * 
 * 2.  **Required Java Components:** Your solution MUST use ALL of the following:
 *     *   `java.util.Queue` (for the waiting list)
 *     *   `java.util.ArrayList` (for storing processed patients)
 *     *   `java.util.List` interface (use this as the type declaration for the processed patients list)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling the menu options)
 *     *   `System.err` (for displaying error messages, e.g., invalid input, trying to process from an empty list)
 *     *   `System.out` (for displaying the menu, prompts, successful actions, and waiting list contents)
 *     *   Class-wide exception handling with `try-catch` blocks (wrap the main operational loop or critical sections to handle potential runtime errors gracefully, including input errors).
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Use private fields and public methods where appropriate (e.g., for the `Patient` class and the main management class).
 *     *   **Naming:** Use meaningful names for variables, methods, and classes.
 *     *   **Documentation:** Include basic comments or Javadoc for classes and methods explaining their purpose.
 *     *   **Input Validation:** Validate user input (e.g., menu choice is an integer, patient name is not empty).
 *     *   **Error Handling:** Handle cases like trying to process a patient when the waiting list is empty.
 *     *   **Clean Code:** Organize your code logically.
 * 
 * **Expected Output:**
 * The program should interact with the user via the console. Examples:
 * *   Displaying the menu.
 * *   Prompting for patient details.
 * *   Confirming successful addition of a patient.
 * *   Printing the waiting list contents clearly (e.g., "Waiting List: Patient1, Patient2, ...").
 * *   Indicating which patient is being processed ("Processing: [Patient Name]").
 * *   Displaying an error message to `System.err` if an operation fails (e.g., "Error: Waiting list is empty.").
 * *   Handling invalid menu input gracefully with an error message on `System.err`.
 * 
 * Your solution should consist of one or more Java files containing the necessary classes.
 *
 * EXPLANATION:
 * The solution implements a simple Hospital Waiting List Management system as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Patient` Class:** This class is a simple Plain Old Java Object (POJO) representing a patient. It has private fields (`name`, `issue`) and a public constructor and `toString()` method, adhering to encapsulation principles.
 * 
 * 2.  **`HospitalScheduler` Class:** This is the main class that manages the system's logic.
 *     *   **Fields:**
 *         *   `waitingList`: Declared as `Queue<Patient>` and initialized with `new LinkedList<>()`. This uses the `Queue` interface and the `LinkedList` implementation, fulfilling the requirement for `Queue`. `LinkedList` is suitable as it efficiently supports adding to the end (`offer`) and removing from the beginning (`poll`), which are standard Queue operations.
 *         *   `processedPatients`: Declared as `List<Patient>` and initialized with `new ArrayList<>()`. This fulfills the requirements for both the `List` interface and the `ArrayList` class. It's used here to simply store patients after they are processed, although the prompt didn't require viewing this list, its inclusion demonstrates the use of `ArrayList` and `List`.
 *         *   `scanner`: Declared as `Scanner` and initialized with `new Scanner(System.in)`. This is used to read input from the console, fulfilling the `Scanner` requirement.
 *     *   **Constructor:** Initializes the `waitingList`, `processedPatients`, and `scanner`.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addPatient()`:**
 *         *   Prompts the user for input using `System.out`.
 *         *   Reads input using `scanner.nextLine()`. Using `nextLine()` after `nextInt()` (in the `run` method) is crucial to consume the leftover newline character.
 *         *   Includes basic validation to ensure name and issue are not empty. If invalid, it prints an error message to `System.err`.
 *         *   Creates a `Patient` object.
 *         *   Adds the patient to the `waitingList` using `waitingList.offer()`. `offer()` is the standard `Queue` method for adding elements.
 *     *   **`viewWaitingList()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the `waitingList` is empty and prints a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `waitingList` using a for-each loop. This allows viewing the elements in order without removing them, which is appropriate for a view operation. The patient's `toString()` method is used for display. Output is to `System.out`.
 *     *   **`processNextPatient()`:**
 *         *   Uses `waitingList.poll()` to retrieve and remove the patient at the head of the queue. `poll()` returns `null` if the queue is empty.
 *         *   Checks if the result of `poll()` is `null`. If it is, it prints an error message to `System.err`, fulfilling the `System.err` requirement for error conditions.
 *         *   If a patient is retrieved, it prints a success message to `System.out` indicating which patient is being processed and adds the patient to the `processedPatients` list using `processedPatients.add()`, fulfilling the `ArrayList`/`List` requirement.
 *     *   **`run()`:**
 *         *   This method contains the main application loop.
 *         *   It's wrapped in a `try-catch (Exception e)` block, providing class-wide exception handling as required. This catches any unexpected runtime errors.
 *         *   A specific `catch (InputMismatchException e)` is included within the main `try` block, or could be outside, to handle cases where the user enters non-integer input for the menu choice. This demonstrates handling specific exception types.
 *         *   Inside the loop, it displays the menu using `displayMenu()`.
 *         *   It uses `scanner.hasNextInt()` for input validation *before* attempting to read an integer. If the input is not an integer, an error is printed to `System.err`, the invalid input is consumed with `scanner.nextLine()`, and the loop continues.
 *         *   If the input is an integer, it's read using `scanner.nextInt()`, and `scanner.nextLine()` is called immediately after to consume the remaining newline character.
 *         *   A `switch` statement is used to direct execution based on the user's `choice`, calling the appropriate private methods (`addPatient`, `viewWaitingList`, `processNextPatient`) or handling the exit case. This fulfills the `switch` requirement.
 *         *   A `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *         *   A `finally` block ensures that the `closeScanner()` method is always called before the program terminates, releasing the scanner resource.
 *     *   **`closeScanner()`:** A private helper method to close the `Scanner` resource, preventing resource leaks.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `HospitalScheduler` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating proper object-oriented design, input handling, error management, and flow control using standard Java libraries. The use of `System.err` for errors and `System.out` for normal interaction is correctly applied.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient waiting for a consultation.
 */
class Patient {
    private String name;
    private String issue;

    /**
     * Constructs a new Patient object.
     * @param name The name of the patient.
     * @param issue A brief description of the patient's issue.
     */
    public Patient(String name, String issue) {
        this.name = name;
        this.issue = issue;
    }

    // --- Getters (Example - not strictly required by prompt but good practice) ---
    public String getName() {
        return name;
    }

    public String getIssue() {
        return issue;
    }

    /**
     * Returns a string representation of the Patient.
     * @return String representation including name and issue.
     */
    @Override
    public String toString() {
        return name + " (" + issue + ")";
    }
}

/**
 * Manages the hospital waiting list and processed patients.
 */
public class HospitalScheduler {
    // Use Queue for FIFO waiting list
    private Queue<Patient> waitingList;
    // Use List/ArrayList to store processed patients
    private List<Patient> processedPatients;
    private Scanner scanner;

    /**
     * Constructs a new HospitalScheduler.
     * Initializes the waiting list, processed list, and scanner.
     */
    public HospitalScheduler() {
        // LinkedList is a common implementation for Queue
        this.waitingList = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.processedPatients = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Scheduler Menu ---");
        System.out.println("1. Add Patient to Waiting List");
        System.out.println("2. View Waiting List");
        System.out.println("3. Process Next Patient");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the waiting list based on user input.
     * Includes basic input validation.
     */
    private void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine().trim(); // Use nextLine after nextInt
        if (name.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        System.out.print("Enter patient issue: ");
        String issue = scanner.nextLine().trim();
         if (issue.isEmpty()) {
            System.err.println("Error: Patient issue cannot be empty.");
            return;
        }

        Patient newPatient = new Patient(name, issue);
        // offer() is preferred over add() for capacity-constrained queues,
        // but for LinkedList it's effectively the same and standard Queue method.
        waitingList.offer(newPatient);
        System.out.println("Patient '" + name + "' added to the waiting list.");
    }

    /**
     * Displays the current waiting list without removing patients.
     */
    private void viewWaitingList() {
        System.out.println("\n--- Current Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("The waiting list is empty.");
        } else {
            // Iterate through the queue elements
            int index = 1;
            for (Patient patient : waitingList) {
                System.out.println(index++ + ". " + patient);
            }
        }
    }

    /**
     * Processes the next patient from the waiting list (removes them)
     * and adds them to the processed list. Handles an empty list.
     */
    private void processNextPatient() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Patient nextPatient = waitingList.poll();

        if (nextPatient == null) {
            System.err.println("Error: The waiting list is currently empty. No patient to process.");
        } else {
            processedPatients.add(nextPatient); // Add to the list of processed patients
            System.out.println("Processing: " + nextPatient);
        }
    }

    /**
     * Runs the main scheduler loop, displaying the menu and handling user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        // Use try-catch block for class-wide exception handling around the main loop
        try {
            while (choice != 4) {
                displayMenu();

                // Validate input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int
                } else {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the switch and display menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addPatient();
                        break;
                    case 2:
                        viewWaitingList();
                        break;
                    case 3:
                        processNextPatient();
                        break;
                    case 4:
                        System.out.println("Exiting Hospital Scheduler. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (InputMismatchException e) {
             // This catch block specifically handles cases where nextInt() fails
             // but the hasNextInt() check might have been bypassed or an issue occurs later.
             // In this specific structure, the hasNextInt check handles most cases,
             // but a general catch is still good practice.
             System.err.println("A serious input error occurred: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
             // Ensure the scanner is closed regardless of exceptions or exiting
             closeScanner();
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the Hospital Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
