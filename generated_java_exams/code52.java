/*
 * Exam Question #52
 * Generated on: 2025-05-11 22:05:58
 * Generated by: Account 3
 * 
 * QUESTION:
 * Subject: Advanced Java Programming
 * Time Allotment: 60 Minutes
 * 
 * **Task Management System**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small project team. The system should allow users to add new tasks, process the next pending task, and view all tasks.
 * 
 * Each task should have a unique ID, a description, a priority level (an integer, where a lower number indicates higher priority), and a status (Pending, Processing, or Completed). New tasks are initially "Pending". When a task is processed, its status changes to "Processing".
 * 
 * The system must manage tasks using the following structures and concepts:
 * 
 * 1.  **Pending Tasks:** New tasks that are ready to be worked on should be placed in a queue. The system should process tasks from this queue in a First-In, First-Out (FIFO) manner.
 * 2.  **All Tasks Record:** The system must maintain a complete record of *all* tasks created during its execution, regardless of their current status. This record should be stored in a list.
 * 3.  **User Interaction:** The system should present a menu to the user and accept commands via standard input.
 * 4.  **Error Handling:** The system must handle invalid user input gracefully and manage situations like trying to process a task when none are pending.
 * 
 * **Implementation Requirements:**
 * 
 * Your Java program must adhere to the following:
 * 
 * *   Use `java.util.Queue` (you can use `java.util.LinkedList` as the concrete implementation).
 * *   Use `java.util.ArrayList` as the concrete implementation for the list of all tasks.
 * *   Declare the list of all tasks using the `java.util.List` interface type.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the different menu options.
 * *   Print error messages to `System.err`.
 * *   Print normal output (menu, prompts, task details, success messages) to `System.out`.
 * *   Implement class-wide exception handling using `try-catch` blocks where necessary (e.g., for input validation, processing empty queue).
 * *   Create a `Task` class with appropriate private fields (ID, description, priority, status) and public methods (getters, status setter). Use an enum for task status.
 * *   Create a main class (`TaskManagementSystem`) containing the main application logic and the `main` method.
 * *   Follow best practices: meaningful variable/method names, appropriate comments, input validation (e.g., non-empty description, positive priority number), and proper encapsulation.
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Task: Prompts for description and priority. Creates a task, adds it to the main list, and enqueues it.
 * 2.  Process Next Pending Task: Dequeues the next task from the pending queue, changes its status to "Processing", and prints its details. If the queue is empty, print a message to `System.out`.
 * 3.  View All Tasks: Lists all tasks ever created, showing their ID, description, priority, and status.
 * 4.  Exit: Terminates the program.
 * 
 * **Expected Output:**
 * 
 * *   Menu should be displayed clearly.
 * *   Prompts for input should be clear.
 * *   Task details in "View All Tasks" should be formatted nicely (e.g., showing all fields).
 * *   Success messages (e.g., "Task added successfully") should be printed to `System.out`.
 * *   Error messages (e.g., "Invalid choice", "Error: Task description cannot be empty", "Error: Invalid priority input") should be printed to `System.err`.
 * *   The "No pending tasks" message should go to `System.out`.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * **Architecture:**
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in (`PENDING`, `PROCESSING`, `COMPLETED`), providing type safety and readability over using simple strings.
 * 2.  **`Task` Class:** Represents an individual task with private fields (`taskId`, `description`, `priority`, `status`) and public getters. It includes a `setStatus` method to allow state changes and overrides `toString` for easy printing of task details. This adheres to encapsulation principles.
 * 3.  **`TaskManagementSystem` Class:** This is the core class containing the application logic.
 *     *   It holds two main data structures:
 *         *   `pendingTasksQueue` (declared as `Queue<Task>`, implemented with `LinkedList`): Manages tasks that are ready to be processed using FIFO order.
 *         *   `allTasks` (declared as `List<Task>`, implemented with `ArrayList`): Maintains a comprehensive record of every task created during the program's execution.
 *     *   `nextTaskId`: A simple counter to assign unique IDs to tasks.
 *     *   `scanner`: An instance of `Scanner` for reading user input.
 * 
 * **Component Usage:**
 * *   **`Queue` (`java.util.Queue`)**: Used for `pendingTasksQueue`. The `offer()` method is used to add tasks to the queue, and `poll()` is used to retrieve and remove the head of the queue (the next task to be processed).
 * *   **`ArrayList` (`java.util.ArrayList`)**: Used as the concrete implementation for the `allTasks` list. It provides dynamic resizing and efficient element access by index (though we primarily iterate through it here).
 * *   **`List` Interface (`java.util.List`)**: `allTasks` is declared using the `List` interface (`List<Task> allTasks = new ArrayList<>();`). This is a best practice, promoting flexibility as the underlying implementation could be changed (e.g., to `LinkedList`) without affecting code that interacts with the list via the interface.
 * *   **`Scanner` (`java.util.Scanner`)**: Used in the `run()` method to read the user's menu choice and in the `addTask()` method to read the task description and priority from `System.in`. Careful handling of the newline character left by `nextInt()` using `scanner.nextLine()` is implemented to prevent input issues.
 * *   **`Switch Statement`**: Used in the `run()` method to direct program flow based on the user's integer input, calling the appropriate method for adding, processing, viewing, or exiting.
 * *   **`System.err`**: Used specifically for printing error messages, such as invalid menu choices, empty task descriptions, invalid priority input, or unexpected exceptions. This differentiates error output from standard program messages.
 * *   **`System.out`**: Used for all standard output, including displaying the menu, prompts for input, success messages (e.g., "Task added successfully"), the list of all tasks, and the exit message.
 * *   **`Try-Catch Blocks`**: Implemented for exception handling:
 *     *   In `addTask()`: A `try-catch(InputMismatchException)` block is used to catch errors if the user enters non-integer input for the priority. A general `finally` block ensures the newline is consumed.
 *     *   In `processNextTask()`: A general `try-catch(Exception)` is included to catch any potential unexpected errors during the processing logic (though the primary "error" of an empty queue is handled explicitly with an `if` check after `poll()`).
 *     *   In `run()`: A `try-catch(InputMismatchException)` handles non-integer input for the main menu choice, preventing the program from crashing and informing the user. A broader `catch(Exception)` is also included as a fallback for any other unexpected runtime errors in the main loop.
 * 
 * **Flow and Functionality:**
 * *   The `run()` method contains the main application loop, which continues until the user chooses to exit (option 4).
 * *   Inside the loop, the menu is displayed, user input is read, and a `switch` statement dispatches the call to the relevant method (`addTask`, `processNextTask`, `viewAllTasks`).
 * *   `addTask()` prompts for details, validates the input (non-empty description, positive priority), creates a `Task` object, adds it to the `allTasks` list, and adds it to the `pendingTasksQueue`.
 * *   `processNextTask()` attempts to remove the next task from `pendingTasksQueue` using `poll()`. If `poll()` returns `null` (queue is empty), it prints a message. Otherwise, it updates the status of the retrieved task to `PROCESSING`.
 * *   `viewAllTasks()` iterates through the `allTasks` list and prints the details of each task using its `toString()` method.
 * 
 * **Best Practices:**
 * *   **Encapsulation:** Fields in `Task` and `TaskManagementSystem` are private, accessed via public methods where appropriate.
 * *   **Meaningful Names:** Variables (`pendingTasksQueue`, `allTasks`, `nextTaskId`), methods (`addTask`, `processNextTask`, `viewAllTasks`, `displayMenu`), and the enum (`TaskStatus`) have clear, descriptive names.
 * *   **Comments:** Basic Javadoc-style comments explain the purpose of classes, enums, and methods. Inline comments explain specific logic points.
 * *   **Input Validation:** Checks are performed for empty strings and non-positive numbers where required, alongside handling format errors (`InputMismatchException`).
 * *   **Error Handling:** Specific exceptions are caught where possible (`InputMismatchException`), general exceptions are caught as a fallback, and informative messages are printed to `System.err` (for errors) or `System.out` (for non-error conditions like empty queue).
 * *   **Clean Code Structure:** The code is divided into logical units (enum, `Task` class, `TaskManagementSystem` class) with well-defined methods, making it readable and maintainable. Resource management (closing the `Scanner`) is also included.
 * 
 * This solution effectively integrates the required Java components to build a functional, albeit simple, system while demonstrating key programming concepts and best practices suitable for evaluating advanced understanding.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.ArrayList; // Concrete implementation for List
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner input

/**
 * Enum to represent the status of a task.
 */
enum TaskStatus {
    PENDING, PROCESSING, COMPLETED
}

/**
 * Represents a single task in the Task Management System.
 * Encapsulates task details and status.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // Lower number = higher priority
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param taskId      The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority    The priority level (lower is higher priority).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING; // New tasks are initially PENDING
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task object.
     *
     * @return Formatted string with task details.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: \"%s\", Priority: %d, Status: %s",
                             taskId, description, priority, status);
    }
}

/**
 * The main class for the Task Management System.
 * Manages a queue of pending tasks and a list of all tasks.
 */
public class TaskManagementSystem {
    // Queue for tasks that are pending and ready to be processed (FIFO)
    private Queue<Task> pendingTasksQueue;
    // List to keep a record of all tasks created
    private List<Task> allTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes the data structures and the task ID counter.
     */
    public TaskManagementSystem() {
        this.pendingTasksQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();       // ArrayList implements List
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. Exit");
        System.out.println("--------------------------");
    }

    /**
     * Handles the process of adding a new task based on user input.
     * Includes input validation and adds the task to both the allTasks list and the pendingTasksQueue.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        // Consume the newline character left by previous nextInt() or similar calls
        scanner.nextLine();

        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        // Input validation for description
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        int priority = -1;
        System.out.print("Enter task priority (e.g., 1 for high): ");
        try {
            priority = scanner.nextInt();
            // Input validation for priority
            if (priority <= 0) {
                 System.err.println("Error: Priority must be a positive integer.");
                 // Consume the invalid input line
                 scanner.nextLine();
                 return;
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid priority input. Please enter a number.");
            // Consume the invalid input line
            scanner.nextLine();
            return;
        } finally {
             // Consume the rest of the line after reading the integer,
             // regardless of whether an exception occurred or not,
             // to prevent issues with the next nextLine() call.
             if (scanner.hasNextLine()) {
                 scanner.nextLine();
             }
        }


        // Create the new task
        Task newTask = new Task(nextTaskId++, description, priority);

        // Add the task to the list of all tasks
        allTasks.add(newTask);

        // Add the task to the pending queue
        pendingTasksQueue.offer(newTask); // offer() is preferred over add() for queues as it doesn't throw an exception if the queue is full (though LinkedList doesn't have a fixed size)

        System.out.println("Task added successfully: " + newTask.getDescription());
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and updates its status.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");
        try {
            // Retrieve and remove the head of the queue
            Task taskToProcess = pendingTasksQueue.poll();

            if (taskToProcess == null) {
                System.out.println("No pending tasks in the queue.");
                return;
            }

            // Simulate processing: update status
            taskToProcess.setStatus(TaskStatus.PROCESSING);

            // Note: In a more complex system, you might move this task
            // to a 'processing' list or similar. Here, it remains in 'allTasks'
            // with updated status and is removed from the 'pendingTasksQueue'.

            System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getTaskId() + ")");

            // Optional: Simulate completion immediately after processing for this example
            // taskToProcess.setStatus(TaskStatus.COMPLETED);
            // System.out.println("Task ID " + taskToProcess.getTaskId() + " marked as completed.");

        } catch (Exception e) {
            // Catch any unexpected errors during processing
            System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
            // In a real application, you would log the exception details
            // e.printStackTrace(); // Uncomment for debugging
        }
    }

    /**
     * Displays all tasks that have been created, regardless of their status.
     */
    public void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
            return;
        }
        // Iterate through the list of all tasks and print their details
        for (Task task : allTasks) {
            System.out.println(task); // Uses the Task class's toString() method
        }
    }

    /**
     * The main application loop that displays the menu and handles user input.
     * Contains the switch statement and general exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 4) {
            displayMenu();
            System.out.print("Enter your choice: ");

            try {
                choice = scanner.nextInt();

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewAllTasks();
                        break;
                    case 4:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
                choice = -1; // Reset choice to ensure the loop continues and menu is shown again
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the main loop execution
                 System.err.println("An unexpected system error occurred: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for debugging
                 // Optionally, decide if this error should terminate the program
            }
        }
        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * The entry point of the application.
     * Creates an instance of TaskManagementSystem and starts the main loop.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
