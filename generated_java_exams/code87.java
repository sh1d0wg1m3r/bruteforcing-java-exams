/*
 * Exam Question #87
 * Generated on: 2025-05-11 22:11:44
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Print Job Management System
 * 
 * **Objective:** Design and implement a simplified Print Job Management System that simulates adding print jobs to a queue, managing a pool of printers, assigning jobs to available printers, and marking jobs as completed. Your solution must demonstrate a strong understanding of core Java collections, control flow, user interaction, and robust error handling.
 * 
 * **System Description:**
 * 
 * The system should manage two main entities: `PrintJob` and `Printer`.
 * - A `PrintJob` has an ID, a user name, a file name, and a status (WAITING, PRINTING, COMPLETED). Jobs are added to a waiting queue.
 * - A `Printer` has an ID, a status (AVAILABLE, BUSY), and can hold a reference to the `PrintJob` it is currently printing.
 * 
 * The system should support the following operations via a command-line interface:
 * 1.  **Add Printer:** Configure a new printer with a unique ID.
 * 2.  **Add Print Job:** Create a new print job with a user and file name, and add it to the waiting queue.
 * 3.  **List Waiting Jobs:** Display all jobs currently in the waiting queue.
 * 4.  **List Printers:** Display the status of all configured printers.
 * 5.  **Assign Job to Printer:** Take the next job from the waiting queue and assign it to the first available printer. If no printers are available or the queue is empty, report an error.
 * 6.  **Mark Job as Completed:** Given a printer ID, mark the job currently assigned to that printer as completed and make the printer available again. Report an error if the printer is not found or not busy.
 * 7.  **List Completed Jobs:** Display all jobs that have been marked as completed.
 * 8.  **Exit:** Terminate the application.
 * 
 * **Requirements:**
 * 
 * Your Java solution must adhere to the following:
 * 
 * 1.  **Component Usage:** You *must* use ALL of the following Java components:
 *     *   `java.util.Queue` (for the waiting print jobs)
 *     *   `java.util.ArrayList` (as an implementation for storing printers and completed jobs)
 *     *   `java.util.List` (as the declared type for collections where appropriate)
 *     *   `java.util.Scanner` (for all user input)
 *     *   `switch` statement (for the main menu navigation)
 *     *   `System.err` (for displaying all error messages)
 *     *   `System.out` (for displaying all normal output, prompts, menus, lists, etc.)
 *     *   Class-wide exception handling with `try-catch` blocks (at least in the main application class's execution loop to handle potential runtime issues like invalid input or operational errors).
 * 
 * 2.  **Object-Oriented Design:**
 *     *   Create separate classes for `PrintJob`, `Printer`, and a manager class (e.g., `PrintQueueManager`) to encapsulate the system logic.
 *     *   Use proper encapsulation (private fields, public getters/setters where necessary).
 *     *   Use meaningful variable and method names.
 * 
 * 3.  **Robustness:**
 *     *   Implement input validation (e.g., handle non-integer input for choices/IDs, ensure user/file names are not empty).
 *     *   Implement proper error handling for operational failures (e.g., trying to assign a job with no available printers, trying to mark a job complete on a non-existent or idle printer). Use `System.err` for all error reporting.
 * 
 * 4.  **Code Quality:**
 *     *   Include appropriate comments explaining complex logic or design choices.
 *     *   Ensure a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept input, perform the requested operation, and display relevant output or error messages. The output should be clear, indicating the success or failure of operations and displaying lists of jobs/printers in a readable format. Error messages should be distinct using `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Simple Print Job Management System ---
 * Select an option:
 * 1. Add Printer
 * 2. Add Print Job
 * ...
 * Enter your choice: 1
 * Enter printer ID: 101
 * Printer 101 added.
 * 
 * Select an option:
 * ...
 * Enter your choice: 1
 * Enter printer ID: 102
 * Printer 102 added.
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Enter user name: alice
 * Enter file name: documentA.pdf
 * Print job added: Job [ID=1, User=alice, File=documentA.pdf, Status=WAITING]
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Enter user name: bob
 * Enter file name: report.xlsx
 * Print job added: Job [ID=2, User=bob, File=report.xlsx, Status=WAITING]
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Waiting Print Jobs ---
 * Job [ID=1, User=alice, File=documentA.pdf, Status=WAITING]
 * Job [ID=2, User=bob, File=report.xlsx, Status=WAITING]
 * Total waiting jobs: 2
 * 
 * Select an option:
 * ...
 * Enter your choice: 5
 * Assigned job 1 to printer 101
 * 
 * Select an option:
 * ...
 * Enter your choice: 4
 * --- Printers ---
 * Printer [ID=101, Status=BUSY, Current Job=1]
 * Printer [ID=102, Status=AVAILABLE]
 * 
 * Select an option:
 * ...
 * Enter your choice: 6
 * Enter ID of printer that finished the job: 101
 * Job 1 on printer 101 marked as completed.
 * 
 * Select an option:
 * ...
 * Enter your choice: 7
 * --- Completed Print Jobs ---
 * Job [ID=1, User=alice, File=documentA.pdf, Status=COMPLETED]
 * 
 * Select an option:
 * ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * ```
 * 
 * This task requires you to integrate multiple Java concepts into a functional and robust application. Good luck!
 *
 * EXPLANATION:
 * This solution implements a simplified Print Job Management System demonstrating the required Java concepts.
 * 
 * **Mapping Requirements to Code:**
 * 
 * 1.  **`java.util.Queue`**: The `jobQueue` field in `PrintQueueManager` is declared as a `Queue<PrintJob>` and instantiated using `LinkedList`. This structure correctly models the waiting line for print jobs, where jobs are added to the end (`offer()`) and removed from the front (`poll()`) in a First-In, First-Out (FIFO) manner. The `listWaitingJobs()` method iterates through the queue without removing elements to display its contents.
 * 
 * 2.  **`java.util.ArrayList`**: The `printerList` and `completedJobs` fields in `PrintQueueManager` are instantiated as `ArrayList`. `printerList` stores the collection of `Printer` objects, allowing efficient iteration and access. `completedJobs` stores `PrintJob` objects after they are finished printing, providing a history.
 * 
 * 3.  **`java.util.List`**: Both `printerList` and `completedJobs` are declared using the `List` interface type (`List<Printer>`, `List<PrintJob>`). This is a best practice demonstrating programming to interfaces rather than concrete implementations, making the code more flexible if a different `List` implementation were needed later.
 * 
 * 4.  **`java.util.Scanner`**: A single `Scanner` instance (`scanner`) is created in the `Main` class and used to read all user input from `System.in`, including menu choices, printer IDs, user names, and file names. `scanner.nextLine()` is used appropriately after `nextInt()` to consume the remaining newline character.
 * 
 * 5.  **`switch` statement**: The `main` method in the `Main` class uses a `switch` statement based on the user's menu choice (`choice`) to direct the program flow to the corresponding operation handler method (e.g., `addPrinter()`, `manager.assignJobToPrinter()`).
 * 
 * 6.  **`System.err`**: `System.err.println()` is used exclusively for outputting error messages. This includes messages for invalid input (non-integer choices, empty strings), operational errors (no available printers, queue empty, printer not found, printer not busy), and unexpected exceptions caught by the `try-catch` blocks. This distinguishes error output from normal program output.
 * 
 * 7.  **`System.out`**: `System.out.println()` is used for all standard program output: displaying the menu, prompts for input, confirmation messages for successful operations, and listing the contents of the waiting job queue, printer list, and completed job list.
 * 
 * 8.  **Class-wide exception handling with `try-catch` blocks**: In the `Main` class's `main` method, a `try-catch` block wraps the input reading (`scanner.nextInt()`) specifically to catch `InputMismatchException` if the user enters non-integer input for the menu choice. An *inner* `try-catch` block then wraps the *entire `switch` statement*. This structure ensures that any unexpected `Exception` that might occur during the execution of the selected menu option (e.g., errors within the manager methods not explicitly handled there) is caught at the top level of the `Main` class's operational loop, preventing the program from crashing and providing a generic error message via `System.err`. Specific input validation methods like `addPrinter()` and `markJobCompleted()` also use `try-catch` for `InputMismatchException` during their specific integer input steps.
 * 
 * **Object-Oriented Design and Best Practices:**
 * 
 * *   **Encapsulation:** The `PrintJob` and `Printer` classes have private fields (`id`, `user`, `fileName`, `status`, `currentJob`) and expose data and functionality through public methods (getters and setters where appropriate). The `PrintQueueManager` also encapsulates its data structures (`jobQueue`, `printerList`, `completedJobs`) and provides public methods for system operations.
 * *   **Meaningful Names:** Class names (`PrintJob`, `Printer`, `PrintQueueManager`, `Main`), variable names (`jobQueue`, `printerList`, `availablePrinter`, `nextJob`), and method names (`addJob`, `assignJobToPrinter`, `listWaitingJobs`) are descriptive and indicate their purpose. Enum types (`JobStatus`, `PrinterStatus`) improve readability.
 * *   **Input Validation:** Methods like `addJob` check for empty strings, and the input handling in `Main` and helper methods (`addPrinter`, `markJobCompleted`) uses `try-catch` to validate integer input.
 * *   **Error Handling:** Specific operational errors are checked within the `PrintQueueManager` methods (e.g., checking if printers exist, checking printer status, checking if queue is empty) and reported using `System.err`.
 * *   **Code Structure:** The code is organized into separate classes, each with a single responsibility. The `Main` class handles the user interface and delegates business logic to the `PrintQueueManager`. Comments are included to explain the purpose of classes, methods, and key code sections.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating good object-oriented design, input validation, and error handling techniques suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents the status of a print job
enum JobStatus {
    WAITING, PRINTING, COMPLETED
}

// Represents a print job
class PrintJob {
    private int id;
    private String user;
    private String fileName;
    private JobStatus status;
    private static int nextId = 1; // Auto-generate unique job IDs

    public PrintJob(String user, String fileName) {
        this.id = nextId++;
        this.user = user;
        this.fileName = fileName;
        this.status = JobStatus.WAITING;
    }

    // Getters
    public int getId() { return id; }
    public String getUser() { return user; }
    public String getFileName() { return fileName; }
    public JobStatus getStatus() { return status; }

    // Setter for status
    public void setStatus(JobStatus status) { this.status = status; }

    @Override
    public String toString() {
        return "Job [ID=" + id + ", User=" + user + ", File=" + fileName + ", Status=" + status + "]";
    }
}

// Represents the status of a printer
enum PrinterStatus {
    AVAILABLE, BUSY
}

// Represents a printer
class Printer {
    private int id;
    private PrinterStatus status;
    private PrintJob currentJob; // Job currently being printed

    public Printer(int id) {
        this.id = id;
        this.status = PrinterStatus.AVAILABLE;
        this.currentJob = null;
    }

    // Getters
    public int getId() { return id; }
    public PrinterStatus getStatus() { return status; }
    public PrintJob getCurrentJob() { return currentJob; }

    // Setters
    public void setStatus(PrinterStatus status) { this.status = status; }
    public void setCurrentJob(PrintJob currentJob) { this.currentJob = currentJob; }

    @Override
    public String toString() {
        return "Printer [ID=" + id + ", Status=" + status + (currentJob != null ? ", Current Job=" + currentJob.getId() : "") + "]";
    }
}

// Manages the print queue and printers
class PrintQueueManager {
    // Queue for jobs waiting to be printed (FIFO)
    private Queue<PrintJob> jobQueue;
    // List to hold all configured printers
    private List<Printer> printerList;
    // List to hold completed jobs
    private List<PrintJob> completedJobs;

    public PrintQueueManager() {
        // Use LinkedList as a Queue implementation
        jobQueue = new LinkedList<>();
        // Use ArrayList for dynamic lists of printers and completed jobs
        printerList = new ArrayList<>();
        completedJobs = new ArrayList<>();
    }

    /**
     * Adds a new printer to the system.
     * @param printerId The unique ID for the printer.
     */
    public void addPrinter(int printerId) {
        // Input validation: Check for non-positive ID (optional but good practice)
        if (printerId <= 0) {
            System.err.println("Error: Printer ID must be a positive integer.");
            return;
        }
        // Validation: Check if printer ID already exists
        for (Printer printer : printerList) {
            if (printer.getId() == printerId) {
                System.err.println("Error: Printer with ID " + printerId + " already exists.");
                return;
            }
        }
        printerList.add(new Printer(printerId));
        System.out.println("Printer " + printerId + " added successfully.");
    }

    /**
     * Adds a new print job to the waiting queue.
     * @param user The user who submitted the job.
     * @param fileName The name of the file to print.
     */
    public void addJob(String user, String fileName) {
        // Input validation: Check if user or file name are empty
        if (user == null || user.trim().isEmpty() || fileName == null || fileName.trim().isEmpty()) {
             System.err.println("Error: User and file name cannot be empty.");
             return;
        }
        PrintJob newJob = new PrintJob(user.trim(), fileName.trim());
        // Add the job to the end of the queue
        jobQueue.offer(newJob);
        System.out.println("Print job added: " + newJob);
    }

    /**
     * Lists all jobs currently in the waiting queue.
     */
    public void listWaitingJobs() {
        if (jobQueue.isEmpty()) {
            System.out.println("No jobs in the waiting queue.");
            return;
        }
        System.out.println("--- Waiting Print Jobs ---");
        // Iterate through the queue elements without removing them
        int count = 0;
        for (PrintJob job : jobQueue) {
             System.out.println(job);
             count++;
        }
        System.out.println("Total waiting jobs: " + count);
    }

    /**
     * Lists all configured printers and their status.
     */
     public void listPrinters() {
        if (printerList.isEmpty()) {
            System.out.println("No printers configured in the system.");
            return;
        }
        System.out.println("--- Printers ---");
        // Iterate through the list of printers
        for (Printer printer : printerList) {
            System.out.println(printer);
        }
    }

    /**
     * Assigns the next job from the queue to the first available printer.
     */
    public void assignJobToPrinter() {
        // 1. Find the first available printer
        Printer availablePrinter = null;
        // Iterate through the list of printers
        for (Printer printer : printerList) {
            if (printer.getStatus() == PrinterStatus.AVAILABLE) {
                availablePrinter = printer;
                break; // Found one, exit loop
            }
        }

        // Operational Error: No available printers
        if (availablePrinter == null) {
            System.err.println("Error: No printers are currently available to take a job.");
            return;
        }

        // 2. Get the next job from the queue
        // poll() removes the head of the queue
        PrintJob nextJob = jobQueue.poll();

        // Operational Error: Job queue is empty
        if (nextJob == null) {
            System.err.println("Error: Print job queue is empty. No jobs to assign.");
            return;
        }

        // 3. Assign the job to the printer and update statuses
        availablePrinter.setStatus(PrinterStatus.BUSY);
        availablePrinter.setCurrentJob(nextJob);
        nextJob.setStatus(JobStatus.PRINTING);

        System.out.println("Successfully assigned job " + nextJob.getId() + " to printer " + availablePrinter.getId());
    }

    /**
     * Marks the job on a specific printer as completed and makes the printer available.
     * @param printerId The ID of the printer that finished the job.
     */
    public void markJobAsCompleted(int printerId) {
        // 1. Find the printer by ID
        Printer targetPrinter = null;
        // Iterate through the list of printers
        for (Printer printer : printerList) {
            if (printer.getId() == printerId) {
                targetPrinter = printer;
                break; // Found the printer
            }
        }

        // Operational Error: Printer not found
        if (targetPrinter == null) {
            System.err.println("Error: Printer with ID " + printerId + " not found in the system.");
            return;
        }

        // Operational Error: Printer is not busy
        if (targetPrinter.getStatus() == PrinterStatus.AVAILABLE) {
            System.err.println("Error: Printer " + printerId + " is currently AVAILABLE and not printing a job.");
            return;
        }

        // 3. Mark the job as completed and free the printer
        PrintJob completedJob = targetPrinter.getCurrentJob();
        if (completedJob != null) {
            completedJob.setStatus(JobStatus.COMPLETED);
            // Add the completed job to the list of completed jobs
            completedJobs.add(completedJob);
            System.out.println("Job " + completedJob.getId() + " on printer " + printerId + " marked as completed.");
        } else {
             // This is an unexpected state if status is BUSY but currentJob is null
             System.err.println("Internal Error: Printer " + printerId + " is busy but has no current job assigned.");
        }

        targetPrinter.setCurrentJob(null);
        targetPrinter.setStatus(PrinterStatus.AVAILABLE);
    }

    /**
     * Lists all jobs that have been marked as completed.
     */
    public void listCompletedJobs() {
         if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
            return;
        }
        System.out.println("--- Completed Print Jobs ---");
        // Iterate through the list of completed jobs
        for (PrintJob job : completedJobs) {
             System.out.println(job);
        }
    }
}

// Main class for user interaction and system execution
public class Main {

    // Instantiate the manager and scanner
    private static PrintQueueManager manager = new PrintQueueManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Simple Print Job Management System ---");

        boolean running = true;
        while (running) {
            printMenu();
            int choice = -1;

            // Outer try-catch block for handling input reading errors
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Inner try-catch block for class-wide exception handling
                // This catches potential exceptions thrown during the execution
                // of the chosen operation via the switch statement.
                try {
                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addPrinter();
                            break;
                        case 2:
                            addPrintJob();
                            break;
                        case 3:
                            manager.listWaitingJobs();
                            break;
                        case 4:
                            manager.listPrinters();
                            break;
                        case 5:
                            manager.assignJobToPrinter();
                            break;
                        case 6:
                            markJobCompleted();
                            break;
                        case 7:
                            manager.listCompletedJobs();
                            break;
                        case 0: // Exit option
                            System.out.println("Exiting system. Goodbye!");
                            running = false;
                            break;
                        default:
                            // Handle invalid menu choices
                            System.err.println("Invalid choice. Please enter a number from the menu (0-7).");
                    }
                } catch (Exception e) {
                    // Catch any unexpected runtime exceptions from the operations
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // Optional: e.printStackTrace(); for detailed debugging
                }

            } catch (InputMismatchException e) {
                // Handle non-integer input specifically for the menu choice
                System.err.println("Invalid input. Please enter a valid integer for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other exceptions during the input phase
                 System.err.println("An unexpected error occurred during input processing: " + e.getMessage());
                 // Optional: e.printStackTrace();
            }
            System.out.println(); // Add a newline for better readability between menu cycles
        }

        // Close the scanner when the program exits
        scanner.close();
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add Printer");
        System.out.println("2. Add Print Job");
        System.out.println("3. List Waiting Jobs");
        System.out.println("4. List Printers");
        System.out.println("5. Assign Job to Printer");
        System.out.println("6. Mark Job as Completed");
        System.out.println("7. List Completed Jobs");
        System.out.println("0. Exit");
    }

    /**
     * Handles user input for adding a printer.
     */
    private static void addPrinter() {
        try {
            System.out.print("Enter printer ID: ");
            int printerId = scanner.nextInt();
            scanner.nextLine(); // Consume newline
            manager.addPrinter(printerId);
        } catch (InputMismatchException e) {
            // Handle non-integer input for printer ID
            System.err.println("Invalid input. Please enter a valid integer for printer ID.");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    /**
     * Handles user input for adding a print job.
     */
    private static void addPrintJob() {
        System.out.print("Enter user name: ");
        String user = scanner.nextLine();
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine();
        manager.addJob(user, fileName);
    }

    /**
     * Handles user input for marking a job as completed on a specific printer.
     */
    private static void markJobCompleted() {
        try {
            System.out.print("Enter ID of printer that finished the job: ");
            int printerId = scanner.nextInt();
            scanner.nextLine(); // Consume newline
            manager.markJobAsCompleted(printerId);
        } catch (InputMismatchException e) {
            // Handle non-integer input for printer ID
            System.err.println("Invalid input. Please enter a valid integer for printer ID.");
            scanner.nextLine(); // Consume the invalid input
        }
    }
}
