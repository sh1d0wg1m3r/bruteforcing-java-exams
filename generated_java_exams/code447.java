/*
 * Exam Question #447
 * Generated on: 2025-05-11 23:12:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Batch Processing Simulator**
 * 
 * You are tasked with creating a simple command-line application that simulates a batch processing system. The system manages tasks that are added to a queue and processed one by one in First-In, First-Out (FIFO) order. Completed tasks are moved to an archive.
 * 
 * Your application must meet the following requirements:
 * 
 * 1.  **Task Representation:** A task is simply represented by a `String` description.
 * 2.  **Data Structures:**
 *     *   Maintain a queue of pending tasks. Use `java.util.Queue`.
 *     *   Maintain a list of completed tasks. Use `java.util.List` and implement it with `java.util.ArrayList`.
 * 3.  **User Interface:** Provide a text-based menu allowing the user to perform the following actions:
 *     *   **1. Add New Task:** Prompt the user for a task description and add it to the end of the pending tasks queue.
 *     *   **2. Process Next Task:** Take the task from the front of the pending tasks queue, simulate processing (just print a message), and move it to the completed tasks list.
 *     *   **3. View Completed Tasks:** Display all tasks currently in the completed tasks list.
 *     *   **4. View Pending Tasks:** Display all tasks currently in the pending tasks queue.
 *     *   **5. Exit:** Terminate the program.
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input (menu choices and task descriptions).
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task information, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process when no tasks are pending).
 * 7.  **Error Handling:** Implement robust error handling using `try-catch` blocks.
 *     *   Handle potential `NumberFormatException` or `InputMismatchException` if the user enters non-numeric input for the menu choice.
 *     *   Handle the case where the user attempts to process a task when the pending queue is empty.
 *     *   Validate that the task description is not empty when adding a new task.
 * 8.  **Best Practices:**
 *     *   Encapsulate the system logic within a class (e.g., `BatchProcessor`) with private fields and public methods.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for the class and methods).
 *     *   Ensure proper input validation and error message clarity.
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying the menu. Based on user input, it should perform the requested action, print appropriate messages on `System.out` (or errors on `System.err`), and loop back to the menu until the user chooses to exit.
 * 
 * Example interaction:
 * 
 * ```
 * --- Batch Processing Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Clean the server room
 * Task added: Clean the server room
 * 
 * --- Batch Processing Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter task description: Update software licenses
 * Task added: Update software licenses
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 4
 * Pending Tasks:
 * 1. Clean the server room
 * 2. Update software licenses
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Clean the server room
 * Task completed: Clean the server room
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 4
 * Pending Tasks:
 * 1. Update software licenses
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 3
 * Completed Tasks:
 * 1. Clean the server room
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Update software licenses
 * Task completed: Update software licenses
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process. (on System.err)
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number between 1 and 5. (on System.err)
 * (and the loop continues)
 * 
 * --- Batch Processing Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Batch Processor.
 * ```
 * 
 * Your solution should provide the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution provides a complete implementation of the `BatchProcessor` class, fulfilling all requirements of the exam task.
 * 
 * 1.  **Class Structure and Encapsulation:** The logic is encapsulated within the `BatchProcessor` class. The data structures (`pendingTasks`, `completedTasks`) and the `Scanner` are private fields, accessible only through the class's public methods (`addTask`, `processNextTask`, `viewCompletedTasks`, `viewPendingTasks`, `run`).
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `private Queue<String> pendingTasks = new LinkedList<>();`: A `Queue` is used to store tasks waiting to be processed. `LinkedList` is a common implementation of `Queue` that supports the necessary FIFO operations (`offer` for adding, `poll` for removing from the head).
 *     *   `private List<String> completedTasks = new ArrayList<>();`: A `List` interface variable is used to hold the completed tasks, implemented by `ArrayList`. This allows easy storage and retrieval of completed tasks in the order they finished.
 * 3.  **User Input (`Scanner`):** A `Scanner` object reads input from `System.in` for both the menu choice (`nextInt()`) and the task description (`nextLine()`). Note the necessary `scanner.nextLine()` call after `nextInt()` to consume the leftover newline character.
 * 4.  **Control Flow (`switch`):** The `run()` method contains the main application loop. Inside the loop, a `switch` statement handles the user's menu choice, directing execution to the appropriate method (`addTask`, `processNextTask`, `viewCompletedTasks`, `viewPendingTasks`) or exiting the loop.
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, confirmation messages when tasks are added or completed, and listing the contents of the completed and pending task lists.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, empty task descriptions, or attempting to process from an empty queue. This follows the best practice of separating normal output from error output.
 * 6.  **Error Handling (`try-catch`):**
 *     *   A `try-catch(InputMismatchException e)` block surrounds the reading of the menu choice (`scanner.nextInt()`). This handles cases where the user enters non-integer input, preventing the program from crashing. The `scanner.next()` call inside the catch block is crucial to consume the invalid token and avoid an infinite loop.
 *     *   A general `catch(Exception e)` is included as a class-wide handler for any other unexpected errors that might occur within the main loop's try block.
 *     *   Specific error conditions are checked within the methods:
 *         *   `addTask` checks for empty or null task descriptions.
 *         *   `processNextTask` checks if `pendingTasks.poll()` returns `null`, indicating an empty queue, and prints an error on `System.err`.
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Achieved as described in point 1.
 *     *   **Naming:** Variable names (`pendingTasks`, `completedTasks`, `scanner`, `choice`, `description`) and method names (`addTask`, `processNextTask`, `viewCompletedTasks`, `viewPendingTasks`, `displayMenu`, `run`, `closeScanner`) are descriptive and follow Java conventions.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of the class and its methods. Inline comments clarify specific logic points (like consuming the newline after `nextInt`).
 *     *   **Input Validation:** Task descriptions are validated to be non-empty. Menu input is validated by the `switch` statement and the `try-catch` block.
 *     *   **Error Handling:** Implemented with `try-catch` and specific checks, using `System.err` for output.
 *     *   **Clean Structure:** The code is organized into logical methods, and the `run()` method provides a clear control flow loop. A `main` method instantiates the class and starts the process. Resource management for the `Scanner` is handled by the `closeScanner` method.
 * 
 * This solution effectively demonstrates the required Java components and programming concepts in a practical, interactive application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Simulates a simple batch processing system using a Queue for pending tasks
 * and a List for completed tasks.
 */
public class BatchProcessor {

    private Queue<String> pendingTasks; // Queue for tasks awaiting processing
    private List<String> completedTasks; // List for tasks that have been processed
    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new BatchProcessor. Initializes the task queues and scanner.
     */
    public BatchProcessor() {
        // Using LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     *
     * @param taskDescription The description of the task to add.
     */
    public void addTask(String taskDescription) {
        if (taskDescription == null || taskDescription.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        pendingTasks.offer(taskDescription.trim()); // offer() is generally preferred for capacity-constrained queues, but works fine here too.
        System.out.println("Task added: " + taskDescription.trim());
    }

    /**
     * Processes the next task in the pending tasks queue.
     * Moves the task from pending to completed list.
     */
    public void processNextTask() {
        String nextTask = pendingTasks.poll(); // poll() retrieves and removes the head of the queue, returns null if empty.
        if (nextTask == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + nextTask);
            completedTasks.add(nextTask);
            System.out.println("Task completed: " + nextTask);
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("Completed Tasks:");
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            System.out.println("Pending Tasks:");
            // Iterate through the queue without removing elements
            int i = 0;
            for (String task : pendingTasks) {
                System.out.println((i + 1) + ". " + task);
                i++;
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Batch Processing Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide exception handling for input errors.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewCompletedTasks();
                        break;
                    case 4:
                        viewPendingTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Batch Processor.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
    }

    /**
     * Closes the scanner resource. Should be called when the application exits.
     */
    public void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the Batch Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BatchProcessor processor = new BatchProcessor();
        processor.run();
        processor.closeScanner();
    }
}
