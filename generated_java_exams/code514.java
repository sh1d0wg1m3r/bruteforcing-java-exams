/*
 * Exam Question #514
 * Generated on: 2025-05-11 23:22:37
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based system to manage and process tasks. The system should allow users to add new tasks, process the next available task, and view the lists of pending and completed/failed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java application named `TaskProcessorSystem` that meets the following criteria:
 * 
 * 1.  **Task Representation:**
 *     *   Create a class named `Task`.
 *     *   The `Task` class must have private fields for `description` (String) and `status` (an enum you define, e.g., `TaskStatus`).
 *     *   Define an enum `TaskStatus` with at least three states: `PENDING`, `PROCESSING`, and `COMPLETED` (or `FAILED`).
 *     *   The `Task` class should have a constructor that takes a description and initializes the status to `PENDING`.
 *     *   Include public getter methods for description and status, and a public setter method for status.
 *     *   Override the `toString()` method in `Task` to provide a clear string representation (e.g., "Description: [description], Status: [status]").
 * 
 * 2.  **System Management:**
 *     *   Create a class named `TaskProcessorSystem`.
 *     *   This class must manage two collections:
 *         *   A `Queue<Task>` to hold tasks that are waiting to be processed (`pendingTasks`).
 *         *   A `List<Task>` (specifically using `ArrayList` for instantiation) to hold tasks that have been processed (either completed or marked as failed) (`processedTasks`).
 *     *   Use the `java.util.Queue` interface type for the `pendingTasks` variable and the `java.util.List` interface type for the `processedTasks` variable. Instantiate `pendingTasks` using a suitable `Queue` implementation (e.g., `LinkedList`) and `processedTasks` using `ArrayList`.
 *     *   Include a `Scanner` object as a class-level field to handle user input throughout the system's execution.
 *     *   Implement the following public methods in `TaskProcessorSystem`:
 *         *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue. Validate that the description is not null or empty. If invalid, print an error using `System.err` and do not add the task.
 *         *   `processNextTask()`:
 *             *   Attempts to retrieve the next task from the front of the `pendingTasks` queue.
 *             *   If the queue is empty, print an error message using `System.err`.
 *             *   If a task is retrieved, change its status to `PROCESSING`.
 *             *   Simulate processing (you don't need complex logic, just change the status). After processing, you can choose to mark it as `COMPLETED` or `FAILED` (e.g., always mark as `COMPLETED` for simplicity, or add a random chance).
 *             *   Move the processed task from the pending state (implicitly, as it's removed from the queue) to the `processedTasks` list.
 *             *   Print a confirmation message using `System.out`.
 *         *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue and prints the details of each task using its `toString()` method. If the queue is empty, print a message using `System.out`.
 *         *   `viewProcessedTasks()`: Iterates through the `processedTasks` list and prints the details of each task using its `toString()` method. If the list is empty, print a message using `System.out`.
 *         *   `run()`: This method should contain the main application loop. It should:
 *             *   Display a menu of options to the user (e.g., Add Task, Process Next, View Pending, View Processed, Exit).
 *             *   Read the user's choice using the `Scanner`.
 *             *   Use a `switch` statement to handle the user's selection, calling the appropriate methods.
 *             *   Handle invalid menu choices using the `default` case of the `switch` and print an error using `System.err`.
 *             *   The loop should continue until the user chooses the 'Exit' option.
 *             *   Implement class-wide exception handling using a `try-catch` block around the main loop in the `run()` method to catch any unexpected `Exception` and print an error message to `System.err` before the program potentially terminates or continues.
 * 
 * 3.  **Input/Output and Error Handling:**
 *     *   Use `Scanner` for all user input.
 *     *   Use `System.out` for displaying menus, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, empty queue/list operations).
 *     *   Implement input validation for adding tasks (non-empty description).
 *     *   Implement error handling for operations on empty collections (`processNextTask`, `viewPendingTasks`, `viewProcessedTasks`).
 *     *   Implement general exception handling for the main application loop using `try-catch`.
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc is a plus).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user via the console. Examples of interactions:
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: Description: Write exam question, Status: PENDING
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Grade papers
 * Task added: Description: Grade papers, Status: PENDING
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Description: Write exam question, Status: PENDING
 * Description: Grade papers, Status: PENDING
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Description: Write exam question, Status: PROCESSING
 * Task completed: Description: Write exam question, Status: COMPLETED
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Description: Grade papers, Status: PENDING
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * Processed Tasks:
 * Description: Write exam question, Status: COMPLETED
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Description: Grade papers, Status: PROCESSING
 * Task completed: Description: Grade papers, Status: COMPLETED
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks pending.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * This task requires integrating several core Java concepts and standard library components in a practical application, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 *
 * EXPLANATION:
 * This solution implements a `TaskProcessingSystem` that manages tasks using a queue for pending items and a list for processed items, fulfilling all the requirements of the exam question.
 * 
 * 1.  **`Task` Class and `TaskStatus` Enum:**
 *     *   The `Task` class encapsulates the data for a single task: its `description` and `status`.
 *     *   The `TaskStatus` enum defines the possible states a task can be in (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`). Using an enum provides type safety and makes the code more readable than using simple strings or integers for status.
 *     *   Private fields and public getters/setters demonstrate proper encapsulation.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskProcessorSystem` Class:**
 *     *   This is the main class that orchestrates the system.
 *     *   It holds the two required collections: `pendingTasks` (declared as `Queue<Task>`, instantiated as `LinkedList`) and `processedTasks` (declared as `List<Task>`, instantiated as `ArrayList`). This demonstrates using interface types for variables, which is a good practice for flexibility.
 *     *   A single `Scanner` instance is used throughout the application for reading user input, preventing resource leaks from creating multiple scanners.
 *     *   **`addTask(String description)`:** This method adds a new task. It includes input validation to ensure the description is not empty. It uses `pendingTasks.offer()` to add the task to the end of the queue. `System.out` is used for success messages, and `System.err` for validation errors.
 *     *   **`processNextTask()`:** This method processes the task at the front of the `pendingTasks` queue using `pendingTasks.poll()`. `poll()` is suitable because it returns `null` if the queue is empty, allowing for easy error handling using `System.err`. The task's status is updated, and it's moved to the `processedTasks` list using `processedTasks.add()`. `System.out` is used for progress and completion messages.
 *     *   **`viewPendingTasks()` and `viewProcessedTasks()`:** These methods iterate through their respective collections (`pendingTasks` and `processedTasks`) and print the tasks. They check if the collections are empty first, printing informative messages using `System.out` if they are. Iterating over the `Queue` is done using a standard enhanced for loop, which doesn't remove elements.
 *     *   **`displayMenu()`:** A private helper method to keep the `run()` method cleaner by separating the menu printing logic.
 *     *   **`run()`:** This is the heart of the application loop.
 *         *   It uses a `boolean` flag (`running`) to control the loop.
 *         *   A `try-catch` block wraps the entire `while` loop. This provides class-wide exception handling, ensuring that if any unexpected runtime error occurs within the main execution flow, it is caught, an error message is printed to `System.err` (including a stack trace for debugging), and the program can potentially exit gracefully (or the loop might continue if the exception is non-fatal to the loop structure itself, though here it's set up to catch broad `Exception`).
 *         *   Inside the loop, the menu is displayed, and user input is read.
 *         *   Input validation for integer choice is included using `scanner.hasNextInt()` and consuming invalid input to prevent an infinite loop.
 *         *   A `switch` statement is used to direct the flow based on the user's valid integer choice.
 *         *   The `default` case of the `switch` handles invalid integer inputs, printing an error to `System.err`.
 *         *   Choosing option `5` sets `running` to `false`, terminating the loop.
 *         *   The `finally` block ensures the `Scanner` resource is closed when the `run` method finishes (either by exiting the loop or catching an exception), preventing resource leaks.
 * 
 * 3.  **Input/Output and Error Handling:**
 *     *   `Scanner` is correctly used for reading different input types (`nextInt`, `nextLine`).
 *     *   `System.out` is used for standard output (menus, successful operations, list contents).
 *     *   `System.err` is correctly used for error conditions (invalid input, attempting operations on empty collections, unexpected exceptions).
 *     *   Specific input validation (non-empty description) and error handling for empty collections are implemented within the respective methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewProcessedTasks`).
 *     *   General exception handling is provided by the `try-catch` block in the `run` method.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Method and variable names are descriptive (e.g., `pendingTasks`, `processNextTask`, `viewProcessedTasks`).
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   The code is structured logically with separate methods for different functionalities.
 * 
 * This solution effectively demonstrates the required Java components and best practices in a cohesive, practical application.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED // Added FAILED for more flexibility, though COMPLETED is sufficient per requirements
}

// Represents a single task in the system
class Task {
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a description and initial status PENDING.
     *
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     *
     * @return The task status.
     */
    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return A formatted string showing task description and status.
     */
    @Override
    public String toString() {
        return "Description: " + description + ", Status: " + status;
    }
}

// Main class for the Task Processing System
public class TaskProcessorSystem {

    // Queue to hold tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been processed (completed or failed)
    private List<Task> processedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessorSystem, initializing collections and scanner.
     */
    public TaskProcessorSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.processedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the description is not null or empty.
     *
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is generally preferred over add for capacity-constrained queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the processed list after changing its status.
     */
    public void processNextTask() {
        // poll retrieves and removes the head of the queue, returns null if empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            System.err.println("Error: No tasks pending.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);
        taskToProcess.setStatus(TaskStatus.PROCESSING);

        // Simulate processing time or logic (optional, not required by prompt)
        // try { Thread.sleep(100); } catch (InterruptedException e) {}

        // For this example, always mark as COMPLETED
        taskToProcess.setStatus(TaskStatus.COMPLETED);
        processedTasks.add(taskToProcess);
        System.out.println("Task completed: " + taskToProcess);
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
            return;
        }
        System.out.println("--- Pending Tasks ---");
        // Iterate through the queue without removing elements
        for (Task task : pendingTasks) {
            System.out.println(task);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the processed list.
     */
    public void viewProcessedTasks() {
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks processed yet.");
            return;
        }
        System.out.println("--- Processed Tasks ---");
        // Iterate through the list
        for (Task task : processedTasks) {
            System.out.println(task);
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default value for invalid input

                // Read user choice, handling potential non-integer input
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input to prevent infinite loop
                    String invalidInput = scanner.next();
                    System.err.println("Error: Invalid input '" + invalidInput + "'. Please enter a number.");
                    continue; // Skip the switch and show menu again
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewProcessedTasks();
                        break;
                    case 5:
                        running = false; // Exit the loop
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorSystem system = new TaskProcessorSystem();
        system.run();
    }
}
