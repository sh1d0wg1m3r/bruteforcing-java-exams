/*
 * Exam Question #646
 * Generated on: 2025-05-12 16:19:33
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simple console-based application to manage tasks for a small team. The system should allow users to add new tasks to a processing queue, process the next task in the queue, view tasks currently in the queue, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with a private field `description` (String). It should have a constructor to initialize the description and a public getter method `getDescription()`.
 * 2.  **Task Management Logic:** Create a class named `TaskManager`.
 *     *   It must have a private `Queue<Task>` to hold tasks waiting to be processed. Use an appropriate `java.util` implementation (e.g., `LinkedList`).
 *     *   It must have a private `List<Task>` (implemented using `java.util.ArrayList`) to store completed tasks.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object with the given description and adds it to the end of the task queue.
 *         *   `processNextTask()`: Removes the task from the front of the queue and adds it to the list of completed tasks. If the queue is empty, it should indicate an error.
 *         *   `viewTaskQueue()`: Displays all tasks currently in the queue without removing them.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed list.
 * 3.  **User Interface:** Implement a main class (e.g., `TeamTaskSystem`) with a `main` method to provide a console interface.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Display a menu with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Task Queue
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The program should loop, displaying the menu and processing user input until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `java.util.InputMismatchException` when reading integer input from the scanner. If invalid input is detected, display an error message and clear the invalid input from the scanner.
 *     *   If the user attempts to process a task when the queue is empty, print an error message.
 *     *   Use `System.err` to print all error messages.
 *     *   Use `System.out` for all normal output (menu, task lists, success messages).
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes/methods).
 *     *   Validate user input where necessary (e.g., menu choice range).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept integer input for choices, prompt for task descriptions when adding, and display lists of tasks or error messages based on the user's actions.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added to queue.
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task added to queue.
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Task Queue ---
 * - Write report
 * - Prepare presentation
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Write report
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Task Queue ---
 * - Prepare presentation
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * - Write report
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Prepare presentation
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Error: Task queue is empty. No tasks to process.
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Team Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should consist of the complete Java code for all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple console-based task management system using the required Java components.
 * 
 * 1.  **Task Class:** A basic POJO (`Task`) is created to represent a task with a `description`. It follows encapsulation by keeping the `description` field private and providing a public getter. An overridden `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskManager Class:** This class encapsulates the core logic of the system.
 *     *   It uses a `Queue<Task>` (`taskQueue`) implemented by `LinkedList` to manage tasks waiting to be processed. The `Queue` interface naturally fits the "first-in, first-out" processing requirement.
 *     *   It uses a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store tasks after they are processed. `ArrayList` is suitable here as we primarily add to and view the list.
 *     *   `addTask()`: Takes a description, creates a `Task`, and adds it to the queue using `offer()`. Basic validation for empty description is included.
 *     *   `processNextTask()`: Removes the task from the front of the queue using `poll()`. `poll()` is safe for empty queues (returns `null`), allowing us to check if a task was actually retrieved before adding it to the completed list. An error message is printed via `System.err` if the queue was empty.
 *     *   `viewTaskQueue()` and `viewCompletedTasks()`: Iterate through the respective collections and print the tasks. These methods demonstrate iterating over a `Queue` and a `List`.
 * 
 * 3.  **TeamTaskSystem Class (Main):** This class provides the command-line interface.
 *     *   It contains the `main` method, which is the entry point.
 *     *   A `Scanner` is used to read user input from the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   `displayMenu()` is a helper method using `System.out` to show the options.
 *     *   A `try-catch` block wraps the code that reads the user's menu choice (`scanner.nextInt()`). This specifically catches `InputMismatchException` if the user enters non-integer input. If caught, an error is printed to `System.err`, and `scanner.next()` is called to consume the invalid input, preventing an infinite loop caused by the scanner not advancing past the bad token. A general `catch (Exception e)` is also included for robustness against other unexpected issues.
 *     *   A `switch` statement handles the valid integer input, calling the appropriate methods in the `TaskManager` instance.
 *     *   Input validation is performed within the `switch`'s `default` case for choices outside the valid range (1-5).
 *     *   `System.out` is used for all standard messages and output lists.
 *     *   `System.err` is exclusively used for error messages (invalid input, invalid choice, empty queue).
 *     *   The `Scanner` is closed when the loop terminates.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating proper object-oriented principles like encapsulation and incorporating essential error handling and input validation techniques.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task object.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "- " + description;
    }
}

/**
 * Manages a queue of tasks waiting for processing and a list of completed tasks.
 */
class TaskManager {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager.
     * Initializes the task queue and completed tasks list.
     */
    public TaskManager() {
        this.taskQueue = new LinkedList<>(); // Implementing Queue with LinkedList
        this.completedTasks = new ArrayList<>(); // Implementing List with ArrayList
    }

    /**
     * Adds a new task to the queue.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // offer is preferred over add in queues as it returns false if capacity restricted
        System.out.println("Task added to queue.");
    }

    /**
     * Processes the next task in the queue by moving it to the completed list.
     * If the queue is empty, prints an error message.
     */
    public void processNextTask() {
        System.out.println("Processing next task...");
        Task nextTask = taskQueue.poll(); // poll retrieves and removes the head of the queue, returns null if empty

        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask.getDescription());
        } else {
            System.err.println("Error: Task queue is empty. No tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the queue.
     */
    public void viewTaskQueue() {
        System.out.println("--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterating through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }
}

/**
 * Main class for the Team Task Management System console application.
 * Handles user interaction, menu display, and delegates tasks to TaskManager.
 */
public class TeamTaskSystem {

    private static void displayMenu() {
        System.out.println("\n--- Team Task Management ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        taskManager.viewTaskQueue();
                        break;
                    case 4:
                        taskManager.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                // Consume the invalid input to prevent an infinite loop
                scanner.next();
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when the application exits
    }
}
