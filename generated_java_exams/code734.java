/*
 * Exam Question #734
 * Generated on: 2025-05-12 16:32:53
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Clinic Appointment Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified appointment management system for a small clinic. The system needs to handle patient registration and appointment scheduling. Patients must be registered before they can schedule an appointment. Appointments are processed in the order they are scheduled (First-In, First-Out).
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow users to register new patients.
 *     *   Allow users to schedule appointments for *registered* patients. Each appointment should include the patient's name and a requested time slot (a simple string like "10:00 AM" is sufficient).
 *     *   Allow users to process the next appointment in the queue, simulating a patient being seen by a doctor.
 *     *   Allow users to view a list of all registered patients.
 *     *   Allow users to view the list of pending appointments.
 *     *   Provide a menu-driven interface for user interaction.
 *     *   Allow the user to exit the application.
 * 
 * 2.  **Data Structures & Components:** Your solution **MUST** use the following Java components:
 *     *   `java.util.Queue`: To manage the pending appointments (FIFO order).
 *     *   `java.util.ArrayList`: To store the list of registered patients.
 *     *   `java.util.List`: Use `List<Patient>` when referring to the collection of registered patients (demonstrates interface usage).
 *     *   `java.util.Scanner`: To read user input from the console.
 *     *   `switch` statement: To handle the different menu options.
 *     *   `System.err`: To print error messages (e.g., patient not found, queue empty, invalid input).
 *     *   `System.out`: To print menu options, successful operations, lists, etc.
 *     *   Class-wide `try-catch` block: Wrap the main application loop or a significant portion of the core logic in a `try-catch` block to handle potential runtime exceptions gracefully.
 * 
 * 3.  **Object-Oriented Design:**
 *     *   Create a `Patient` class (with at least a name).
 *     *   Create an `Appointment` class (with patient details and time slot).
 *     *   Create a `ClinicScheduler` class that encapsulates the `List` of patients and the `Queue` of appointments and provides methods for the required operations (register, schedule, process, view).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Implement input validation (at least for menu choices).
 *     *   Implement proper error handling as described above.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Menu Options:**
 * 
 * 1.  Register New Patient
 * 2.  Schedule Appointment
 * 3.  Process Next Appointment
 * 4.  View Registered Patients
 * 5.  View Pending Appointments
 * 6.  Exit
 * 
 * **Expected Output:**
 * 
 * *   The application should start by displaying the menu.
 * *   Based on the user's input, it should perform the corresponding action.
 * *   Successful actions should be confirmed via `System.out`.
 * *   Errors (like trying to schedule for a non-existent patient, or processing an empty queue, or invalid menu input) should be reported via `System.err`.
 * *   Viewing lists should print the contents to `System.out`.
 * *   The application should continue until the user chooses to exit.
 * 
 * **Constraint:** Focus on demonstrating the required Java components and concepts. Complex time slot management or persistence are not required.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the required functionality.
 * *   Proper object-oriented design (classes, encapsulation).
 * *   Effective error handling and input validation.
 * *   Adherence to best practices (naming, comments, code structure).
 *
 * EXPLANATION:
 * This solution implements a simple Clinic Appointment Management System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Object-Oriented Design:**
 *     *   `Patient` class: A simple class to hold patient data (`name`). It follows encapsulation with a private field and a public getter.
 *     *   `Appointment` class: Holds an `Appointment` object and a `timeSlot` string. It also follows encapsulation.
 *     *   `ClinicScheduler` class: This is the core class managing the system's state and logic. It contains the collections (`registeredPatients` and `pendingAppointments`) and methods for all operations.
 * 
 * 2.  **Data Structures:**
 *     *   `List<Patient> registeredPatients = new ArrayList<>();`: An `ArrayList` is used to store registered patients. It's accessed via the `List` interface, demonstrating polymorphism and good practice. `ArrayList` is suitable here as we need to store a dynamic list and occasionally search by name.
 *     *   `Queue<Appointment> pendingAppointments = new LinkedList<>();`: A `LinkedList` is used as the implementation of the `Queue` interface to manage appointments. `Queue` is the correct choice because appointments are processed in a First-In, First-Out (FIFO) manner. `LinkedList` efficiently supports queue operations (`offer` to add, `poll` to remove from the head).
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `pendingAppointments`. `offer()` adds to the tail, `poll()` removes from the head, `isEmpty()` checks if the queue is empty.
 *     *   `ArrayList`: Used as the concrete implementation for `registeredPatients`.
 *     *   `List`: The `registeredPatients` variable is declared as `List<Patient>`, demonstrating the use of the interface.
 *     *   `Scanner`: An instance is created in `main` to read user input from `System.in`. `nextInt()` reads the menu choice, and `nextLine()` reads string inputs (patient name, time slot) and consumes the leftover newline after `nextInt()`.
 *     *   `switch` statement: Used in the `main` loop to direct execution based on the user's menu choice.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input, patient not found, or trying to process an empty queue.
 *     *   `System.out`: Used for all other output, including the menu, successful operation confirmations, and listing patients/appointments.
 *     *   `try-catch` blocks:
 *         *   A large `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This provides class-wide exception handling, catching any unhandled exceptions that might occur during the program's execution and preventing the program from crashing abruptly.
 *         *   A specific `try-catch(InputMismatchException e)` block is used when reading the menu choice. This handles cases where the user enters non-integer input for the menu, prints an error to `System.err`, consumes the invalid input, and allows the loop to continue.
 * 
 * 4.  **Functionality Implementation:**
 *     *   Registering a patient adds a new `Patient` object to the `registeredPatients` list after basic validation (not empty name, not already registered).
 *     *   Scheduling an appointment first checks if the patient exists in the `registeredPatients` list using the private `findPatientByName` helper method. If found, an `Appointment` object is created and added to the `pendingAppointments` queue using `offer()`. If not found, an error is printed to `System.err`.
 *     *   Processing the next appointment checks if the `pendingAppointments` queue is empty. If not, it removes the head of the queue using `poll()` and prints a confirmation. If empty, an error is printed to `System.err`.
 *     *   Viewing patients/appointments iterates through the respective collections and prints their details using their `toString()` methods. Copies of the collections are returned by the getter methods to protect the internal state.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is applied in `Patient`, `Appointment`, and `ClinicScheduler` classes.
 *     *   Variable names (`registeredPatients`, `pendingAppointments`, `timeSlot`, `patientName`, etc.) and method names (`registerPatient`, `scheduleAppointment`, `processNextAppointment`, `findPatientByName`, `printMenu`) are descriptive.
 *     *   Basic comments explain the purpose of classes and key methods.
 *     *   Input validation is present for menu choices (`InputMismatchException` and range check) and basic checks for empty strings for names and time slots.
 *     *   Error messages are directed to `System.err`.
 *     *   The code is structured into separate classes with clear responsibilities.
 * 
 * This solution effectively demonstrates the required Java concepts and data structures within a practical, albeit simplified, application context, while adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the clinic system.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient object.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [Name: " + name + "]";
    }
}

/**
 * Represents an appointment in the clinic system.
 */
class Appointment {
    private Patient patient;
    private String timeSlot;

    /**
     * Constructs a new Appointment object.
     * @param patient The patient for the appointment.
     * @param timeSlot The requested time slot (e.g., "10:00 AM").
     */
    public Appointment(Patient patient, String timeSlot) {
        this.patient = patient;
        this.timeSlot = timeSlot;
    }

    /**
     * Gets the patient associated with the appointment.
     * @return The Patient object.
     */
    public Patient getPatient() {
        return patient;
    }

    /**
     * Gets the time slot for the appointment.
     * @return The time slot string.
     */
    public String getTimeSlot() {
        return timeSlot;
    }

    @Override
    public String toString() {
        return "Appointment [Patient: " + patient.getName() + ", Time: " + timeSlot + "]";
    }
}

/**
 * Manages patients and appointments for the clinic.
 */
class ClinicScheduler {
    // Using List interface with ArrayList implementation for registered patients
    private List<Patient> registeredPatients;
    // Using Queue interface with LinkedList implementation for pending appointments
    private Queue<Appointment> pendingAppointments;

    /**
     * Constructs a new ClinicScheduler.
     * Initializes the patient list and appointment queue.
     */
    public ClinicScheduler() {
        this.registeredPatients = new ArrayList<>();
        this.pendingAppointments = new LinkedList<>();
    }

    /**
     * Registers a new patient.
     * @param name The name of the patient to register.
     */
    public void registerPatient(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }
        // Simple check to prevent duplicate names (case-insensitive)
        for (Patient p : registeredPatients) {
            if (p.getName().equalsIgnoreCase(name.trim())) {
                System.err.println("Error: Patient '" + name.trim() + "' is already registered.");
                return;
            }
        }
        Patient newPatient = new Patient(name.trim());
        registeredPatients.add(newPatient);
        System.out.println("Patient '" + newPatient.getName() + "' registered successfully.");
    }

    /**
     * Schedules an appointment for a registered patient.
     * Adds the appointment to the pending queue.
     * @param patientName The name of the registered patient.
     * @param timeSlot The requested time slot.
     */
    public void scheduleAppointment(String patientName, String timeSlot) {
        if (patientName == null || patientName.trim().isEmpty() || timeSlot == null || timeSlot.trim().isEmpty()) {
             System.err.println("Error: Patient name and time slot cannot be empty.");
             return;
        }

        Patient patient = findPatientByName(patientName.trim());

        if (patient == null) {
            System.err.println("Error: Patient '" + patientName.trim() + "' not found. Please register the patient first.");
            return;
        }

        Appointment newAppointment = new Appointment(patient, timeSlot.trim());
        pendingAppointments.offer(newAppointment); // offer is preferred over add for queues
        System.out.println("Appointment scheduled for '" + patient.getName() + "' at " + timeSlot.trim() + ".");
    }

    /**
     * Processes the next appointment in the queue (FIFO).
     * Removes the appointment from the queue.
     */
    public void processNextAppointment() {
        if (pendingAppointments.isEmpty()) {
            System.err.println("Error: No pending appointments in the queue.");
            return;
        }

        Appointment nextAppointment = pendingAppointments.poll(); // poll removes the head of the queue
        System.out.println("Processing appointment: " + nextAppointment);
        // In a real system, this would involve more logic, like marking as complete.
    }

    /**
     * Gets the list of all registered patients.
     * @return A List of Patient objects.
     */
    public List<Patient> getRegisteredPatients() {
        return new ArrayList<>(registeredPatients); // Return a copy to prevent external modification
    }

    /**
     * Gets the list of all pending appointments.
     * @return A List of Appointment objects (copy of queue elements).
     */
    public List<Appointment> getPendingAppointments() {
         // Convert queue elements to a List for easy viewing
        return new ArrayList<>(pendingAppointments);
    }

    /**
     * Finds a registered patient by name (case-insensitive search).
     * @param name The name to search for.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientByName(String name) {
        for (Patient patient : registeredPatients) {
            if (patient.getName().equalsIgnoreCase(name)) {
                return patient;
            }
        }
        return null;
    }
}

/**
 * Main class to run the Clinic Appointment Management System.
 * Provides the user interface and handles input.
 */
public class ClinicApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ClinicScheduler scheduler = new ClinicScheduler();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                // Using switch statement for menu control flow
                switch (choice) {
                    case 1:
                        System.out.print("Enter patient name: ");
                        String patientNameRegister = scanner.nextLine();
                        scheduler.registerPatient(patientNameRegister);
                        break;
                    case 2:
                        System.out.print("Enter patient name for appointment: ");
                        String patientNameSchedule = scanner.nextLine();
                        System.out.print("Enter desired time slot (e.g., 10:30 AM): ");
                        String timeSlot = scanner.nextLine();
                        scheduler.scheduleAppointment(patientNameSchedule, timeSlot);
                        break;
                    case 3:
                        scheduler.processNextAppointment();
                        break;
                    case 4:
                        System.out.println("\n--- Registered Patients ---");
                        List<Patient> patients = scheduler.getRegisteredPatients();
                        if (patients.isEmpty()) {
                            System.out.println("No patients registered yet.");
                        } else {
                            for (int i = 0; i < patients.size(); i++) {
                                System.out.println((i + 1) + ". " + patients.get(i));
                            }
                        }
                        System.out.println("---------------------------");
                        break;
                    case 5:
                        System.out.println("\n--- Pending Appointments ---");
                        List<Appointment> appointments = scheduler.getPendingAppointments();
                        if (appointments.isEmpty()) {
                            System.out.println("No pending appointments.");
                        } else {
                            for (int i = 0; i < appointments.size(); i++) {
                                System.out.println((i + 1) + ". " + appointments.get(i));
                            }
                        }
                        System.out.println("----------------------------");
                        break;
                    case 6:
                        System.out.println("Exiting Clinic Appointment System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Clinic Appointment System Menu ---");
        System.out.println("1. Register New Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. Process Next Appointment");
        System.out.println("4. View Registered Patients");
        System.out.println("5. View Pending Appointments");
        System.out.println("6. Exit");
        System.out.println("--------------------------------------");
    }
}
