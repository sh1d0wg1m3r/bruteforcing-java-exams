/*
 * Exam Question #823
 * Generated on: 2025-05-12 16:46:30
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line Task Management System for a small team. The system should allow users to add new tasks, view pending tasks, mark pending tasks as complete, and view completed tasks.
 * 
 * Each task should have a unique ID, a description, and a status (either PENDING or COMPLETED).
 * 
 * The system will maintain two collections of tasks:
 * 1.  A collection of tasks that are currently pending. New tasks are added here. When a task is marked complete, it is removed from this collection.
 * 2.  A collection of tasks that have been completed. When a task is marked complete, it is added to this collection.
 * 
 * The system should interact with the user through a simple menu interface in the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a `Task` class with private fields for `id` (int), `description` (String), and `status` (an enum `TaskStatus` with values `PENDING` and `COMPLETED`). Implement a constructor, public getter methods for all fields, a public method to set the status (`setStatus`), and override `toString()` to provide a readable representation of a task. Crucially, override `equals()` and `hashCode()` based *only* on the `id` field to facilitate searching/removal.
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue<Task>` to store the *pending* tasks.
 *     *   Use `java.util.List<Task>` (implemented by `java.util.ArrayList`) to store the *completed* tasks.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` to read user input.
 * 4.  **Menu:** Present the user with the following options in a loop until the user chooses to exit:
 *     1.  Add New Task
 *     2.  View Pending Tasks
 *     3.  Mark Task as Complete
 *     4.  View Completed Tasks
 *     5.  Exit
 * 5.  **Flow Control:** Use a `switch` statement to handle the user's menu choice.
 * 6.  **Output:** Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 * 7.  **Error Handling:**
 *     *   Use `System.err` to print error messages for invalid user input (e.g., non-numeric input for menu choice or task ID) or invalid operations (e.g., attempting to complete a task ID that doesn't exist in the pending list).
 *     *   Implement **class-wide exception handling** using a `try-catch` block around the main application loop (the loop handling the menu choices) to catch general exceptions and print an error message to `System.err`.
 * 8.  **Input Validation:** Validate user input where necessary (e.g., ensure menu choice is within range, ensure task ID input is numeric).
 * 9.  **Best Practices:** Adhere to Java best practices including proper encapsulation, meaningful variable and method names, appropriate comments, and clean code structure.
 * 
 * **Functionality Details:**
 * 
 * *   **Add New Task:** Prompt the user for a task description. Generate a unique ID for the task (a simple counter starting from 1 is sufficient). Create a new `Task` object with status `PENDING` and add it to the pending tasks queue.
 * *   **View Pending Tasks:** Iterate through the pending tasks queue and print each task's details. If the queue is empty, print a message indicating no pending tasks.
 * *   **Mark Task as Complete:** Prompt the user for the ID of the task to mark as complete. Search the pending tasks queue for a task with the given ID. If found, remove it from the queue, change its status to `COMPLETED`, and add it to the completed tasks list. If no task with the given ID is found in the pending list, print an error message to `System.err`. *Hint: Removing an element by value/ID from a Queue implementation like LinkedList might require iterating.*
 * *   **View Completed Tasks:** Iterate through the completed tasks list and print each task's details. If the list is empty, print a message indicating no completed tasks.
 * *   **Exit:** Terminate the application.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Task Management System
 * Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Mark Task as Complete
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: <user input>
 * 
 * <Output based on choice - prompts, lists, messages>
 * 
 * <Error messages go to System.err>
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method to run the application.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingTasks` field is declared as a `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface. Tasks are added to the end of the queue using `offer()` in the `addNewTask()` method. Viewing pending tasks involves iterating through the queue using a for-each loop, which doesn't remove elements.
 * 2.  **`java.util.ArrayList` & `java.util.List`:** The `completedTasks` field is declared as a `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is a dynamic array implementation of the `List` interface. Completed tasks are added to this list using `add()` in the `markTaskAsComplete()` method. Viewing completed tasks involves iterating through the list using a for-each loop.
 * 3.  **`java.util.Scanner`:** A `Scanner` object is used to read user input from `System.in` in the `run()` method and within `addNewTask()` and `markTaskAsComplete()`. `scanner.nextLine()` is used consistently to read entire lines, avoiding common pitfalls with mixed `nextInt()` and `nextLine()` calls.
 * 4.  **`switch` statement:** A `switch` statement in the `run()` method is used to control the application flow based on the user's integer choice from the menu.
 * 5.  **`System.err`:** `System.err.println()` is used specifically for printing error messages, such as invalid menu choices, non-numeric input, or when a task ID is not found in the pending list during the completion process. This separates error output from standard application output.
 * 6.  **`System.out`:** `System.out.println()` and `System.out.print()` are used for all standard application output, including displaying the menu, prompts, task details, and success messages.
 * 7.  **Class-wide `try-catch`:** The `run()` method, which contains the main application loop, is wrapped in a `try-catch(Exception e)` block. This demonstrates handling potential unexpected exceptions that might occur during the application's execution, printing a generic error message and the stack trace to `System.err`. A more specific `catch (NumberFormatException e)` is also used inside the loop for handling invalid numeric input errors from the menu choice specifically.
 * 8.  **`Task` Class:** Encapsulation is used with private fields and public getter methods. The `setStatus` method allows controlled modification of the task status. `toString()` provides a useful string representation. The `equals()` and `hashCode()` methods are overridden based *only* on the `id`, which is crucial for correctly identifying and removing a specific `Task` object from a collection based on its ID, particularly when using methods like `remove(Object)` (although the iterator approach was used here for robustness with `Queue`).
 * 
 * **Functionality Implementation:**
 * 
 * *   **`addNewTask`:** Reads a description, creates a new `Task` with a unique ID generated by incrementing `nextTaskId`, and adds it to the `pendingTasks` queue using `offer()`.
 * *   **`viewPendingTasks` & `viewCompletedTasks`:** Simple iteration over the respective collections using enhanced for loops.
 * *   **`markTaskAsComplete`:** This is the most complex part involving the `Queue`. It prompts for an ID, reads it, and handles potential `NumberFormatException`. It then uses an `Iterator` to traverse the `pendingTasks` queue. When the task with the matching ID is found, `iterator.remove()` is called to safely remove the element during iteration. The found `Task` object's status is updated, and it's added to the `completedTasks` list. If the loop finishes without finding the ID, an error is printed to `System.err`. Using the iterator's `remove()` is the recommended way to remove elements while iterating over collections like `LinkedList`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` are private, accessed via public methods.
 * *   **Meaningful Names:** Class names (`TaskManagerApp`, `Task`, `TaskStatus`), variable names (`pendingTasks`, `completedTasks`, `nextTaskId`), and method names (`addNewTask`, `markTaskAsComplete`, `displayMenu`) are descriptive.
 * *   **Comments:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic.
 * *   **Input Validation:** `NumberFormatException` is caught for user input, and the task description is checked for emptiness.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for different error conditions. A general `try-catch` is present.
 * *   **Clean Structure:** The code is organized into separate classes (`TaskStatus`, `Task`, `TaskManagerApp`) with distinct responsibilities. The `run()` method orchestrates the main application logic.
 * 
 * This solution effectively utilizes all required components in a practical scenario, demonstrating understanding of collection interfaces and implementations, input/output, control flow, exception handling, and object-oriented design principles suitable for an advanced Java programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: \"%s\", Status: %s",
                id, description, status);
    }

    /**
     * Checks if two Task objects are equal based on their ID.
     * @param o The object to compare with.
     * @return true if the objects are equal (same ID), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    /**
     * Generates a hash code for the Task based on its ID.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

// Main application class for managing tasks
public class TaskManagerApp {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs
    private Scanner scanner;

    /**
     * Constructs the TaskManagerApp.
     * Initializes collections and task ID counter.
     */
    public TaskManagerApp() {
        // Use LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Mark Task as Complete");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input description.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Displays all pending tasks.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Marks a task as complete based on its ID.
     * Prompts user for the task ID.
     */
    private void markTaskAsComplete() {
        System.out.print("Enter the ID of the task to mark as complete: ");
        int taskIdToComplete;
        try {
            taskIdToComplete = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid task ID format. Please enter a number.");
            return;
        }

        Task taskToMove = null;
        Iterator<Task> iterator = pendingTasks.iterator();

        // Iterate through the pending tasks to find the task by ID
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskIdToComplete) {
                taskToMove = task;
                iterator.remove(); // Safely remove the task using the iterator
                break; // Found and removed, exit loop
            }
        }

        if (taskToMove != null) {
            taskToMove.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToMove); // Add to the completed list
            System.out.println("Task marked as complete: " + taskToMove);
        } else {
            System.err.println("Error: Task with ID " + taskIdToComplete + " not found in pending tasks.");
        }
    }

    /**
     * Displays all completed tasks.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1; // Initialize with a non-menu value

        // Class-wide try-catch block for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    // Read user choice, expecting an integer
                    choice = Integer.parseInt(scanner.nextLine());

                    // Use switch for menu navigation
                    switch (choice) {
                        case 1:
                            addNewTask();
                            break;
                        case 2:
                            viewPendingTasks();
                            break;
                        case 3:
                            markTaskAsComplete();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Catch specific error for non-integer input
                    System.err.println("Error: Invalid input. Please enter a number.");
                    choice = -1; // Reset choice to stay in loop and re-display menu
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the application run
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run();
    }
}
