/*
 * Exam Question #698
 * Generated on: 2025-05-12 16:27:25
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Registration and Check-in System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified console-based system to manage attendee registration and check-in for a single event. The system needs to handle registration requests placed in a queue, process these requests to officially register attendees, and then allow attendees to check in.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Representation:** Create an `Attendee` class with private fields for `attendeeId` (String), `name` (String), and `status` (an enum like `RegistrationStatus: PENDING, REGISTERED, CHECKED_IN`). Include a constructor and appropriate public getter methods.
 * 2.  **Event Management:** Create an `EventManager` class to manage the event.
 *     *   It must have a private field `registrationQueue` of type `java.util.Queue<Attendee>` to hold attendees requesting registration.
 *     *   It must have a private field `registeredAttendees` of type `java.util.List<Attendee>` (implemented using `java.util.ArrayList`) to hold attendees who have been officially registered or checked in.
 *     *   Include methods for the following operations:
 *         *   `addRegistrationRequest(String attendeeId, String name)`: Adds a new `Attendee` with status `PENDING` to the `registrationQueue`. Basic validation (ID/name not empty) should be performed.
 *         *   `processRegistrationQueue()`: Moves all attendees from the `registrationQueue` to the `registeredAttendees` list, changing their status from `PENDING` to `REGISTERED`. Handles the case where the queue is empty.
 *         *   `checkInAttendee(String attendeeId)`: Searches the `registeredAttendees` list for an attendee with the given ID. If found and their status is `REGISTERED`, changes their status to `CHECKED_IN`. Handles cases where the attendee is not found or is already checked in.
 *         *   `getEventStatus()`: Returns a formatted string showing the number of attendees in the `registrationQueue`, the number `REGISTERED` in the `registeredAttendees` list, and the number `CHECKED_IN` in the `registeredAttendees` list.
 * 3.  **Main Application (`ExamSystem` class):**
 *     *   Create the `main` method to run the application.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with options for:
 *         1.  Add Registration Request
 *         2.  Process All Registration Requests
 *         3.  Check In Attendee
 *         4.  View Event Status
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices (ensure it's an integer within the valid range).
 *     *   Use `System.out` for menu prompts, successful operation messages, and displaying the event status.
 *     *   Use `System.err` to print error messages for invalid input, failed operations (e.g., attendee not found for check-in, processing an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks. At a minimum, the main application loop should be wrapped in a `try-catch` block to catch unexpected errors, and specific `try-catch` blocks should handle expected issues like invalid number format for menu input.
 * 4.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus, but clear inline comments are sufficient for an exam).
 *     *   Implement input validation and error handling as described above.
 *     *   Structure the code cleanly into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide feedback using `System.out` for success/status and `System.err` for errors. Examples:
 * 
 * *   Adding registration: `System.out.println("Registration request added for " + name);`
 * *   Processing queue: `System.out.println("Processed " + count + " registration requests.");` or `System.err.println("Registration queue is empty.");`
 * *   Check-in: `System.out.println("Attendee " + attendeeId + " checked in successfully.");` or `System.err.println("Attendee with ID " + attendeeId + " not found or not registered.");`
 * *   Status: `System.out.println("--- Event Status ---"); System.out.println("Pending in Queue: X"); System.out.println("Registered: Y"); System.out.println("Checked In: Z"); System.out.println("--------------------");`
 * *   Invalid input: `System.err.println("Invalid menu choice. Please enter a number between 1 and 5.");` or `System.err.println("Invalid input. Please enter a number.");`
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, and `try-catch`.
 * *   The system manages only one event.
 *
 * EXPLANATION:
 * This solution implements a simple event management system demonstrating the required Java concepts.
 * 
 * 1.  **`Attendee` Class:**
 *     *   Represents an attendee with `attendeeId`, `name`, and `status`.
 *     *   Uses an `enum` (`RegistrationStatus`) for clear status representation (`PENDING`, `REGISTERED`, `CHECKED_IN`).
 *     *   Fields are `private` for encapsulation.
 *     *   Provides public getter methods.
 *     *   The `setStatus` method is package-private (default access) or could be private with setter logic controlled only within `EventManager`, ensuring status changes are managed correctly by the system logic, not arbitrarily from outside.
 *     *   Includes basic validation in the constructor and a `toString` method for easy printing.
 * 
 * 2.  **`EventManager` Class:**
 *     *   Manages the core logic for a single event.
 *     *   `registrationQueue`: A `Queue<Attendee>` (implemented by `LinkedList`) holds attendees requesting to register. `offer()` is used for adding, `poll()` for retrieving and removing the head element. This simulates a waiting list for processing.
 *     *   `registeredAttendees`: A `List<Attendee>` (implemented by `ArrayList`) stores attendees who have been processed from the queue and officially registered or subsequently checked in. `ArrayList` is suitable for storing and searching through the list of registered individuals.
 *     *   `addRegistrationRequest()`: Adds a new `Attendee` (initially `PENDING`) to the `registrationQueue`. Includes basic input validation and a check for duplicate IDs (though a robust system would need more sophisticated ID management). Uses `System.err` for validation errors.
 *     *   `processRegistrationQueue()`: Iterates through the `registrationQueue` using a `while` loop and `poll()`. Each dequeued `Attendee` has their status updated to `REGISTERED` and is added to the `registeredAttendees` `List`. Handles the empty queue case with a `System.err` message.
 *     *   `checkInAttendee()`: Searches the `registeredAttendees` `List` for an attendee by ID. A simple loop is used, but for larger lists, a `HashMap<String, Attendee>` keyed by ID within `EventManager` could provide faster lookups (though `HashMap` wasn't a required component). It validates the attendee's current status before changing it to `CHECKED_IN` and uses `System.err` for errors (not found, already checked in).
 *     *   `getEventStatus()`: Iterates through both the `registrationQueue` and `registeredAttendees` `List` to count attendees in each status and returns a formatted string using `System.out` for the final output.
 * 
 * 3.  **`ExamSystem` Class (`main` method):**
 *     *   This is the entry point of the application.
 *     *   A `Scanner` is used for all console input.
 *     *   An `EventManager` instance is created for the single event.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop:
 *         *   The `printMenu()` method displays the options using `System.out`.
 *         *   A `try-catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *         *   The user's valid integer choice is processed by a `switch` statement.
 *         *   Each `case` calls the appropriate method on the `eventManager` instance.
 *         *   Additional specific `try-catch` blocks are included around operations within the `switch` cases (like in `addRegistrationRequest`) to handle potential errors during those operations (e.g., `IllegalArgumentException`).
 *         *   A broader `catch (Exception e)` is placed *inside* the `while` loop's `try` block. This provides "class-wide" handling for any unexpected exceptions that might occur *during* the execution of a menu option but weren't caught by more specific handlers. It prints an error to `System.err`.
 *     *   A final `try-catch (Exception e)` block wraps the entire `while` loop. This is the outermost "class-wide" handler, catching any critical exceptions that might cause the loop itself to terminate unexpectedly. It also prints to `System.err`.
 *     *   A `finally` block ensures the `Scanner` resource is closed properly when the application exits (either normally or due to a critical error).
 * 
 * **Usage of Required Components:**
 * 
 * *   `java.util.Queue`: Used in `EventManager` (`registrationQueue`) to manage pending registration requests using `offer()` and `poll()`.
 * *   `java.util.ArrayList`: Used in `EventManager` to implement the `registeredAttendees` `List`.
 * *   `java.util.List`: The `registeredAttendees` field is declared as the `List` interface type, demonstrating programming to interfaces.
 * *   `java.util.Scanner`: Used in `ExamSystem.main` to read all user input from `System.in`.
 * *   `switch` statement: Used in `ExamSystem.main` to control the flow based on the user's menu selection.
 * *   `System.err`: Used throughout the code (`EventManager`, `ExamSystem.main`) to display error messages and warnings (invalid input, operation failures, exceptions).
 * *   `System.out`: Used in `ExamSystem.main` and `EventManager` to display menus, prompts, success messages, and the event status report.
 * *   `try-catch` blocks: Used extensively in `ExamSystem.main` (for input validation, general operation errors, and a final loop safety net) and in `EventManager` methods (for input validation, specific operation errors like queue empty or attendee not found). This fulfills the "class-wide exception handling" requirement by wrapping the main operational logic.
 * 
 * This solution provides a practical simulation of an event process, effectively utilizes all specified Java components, incorporates best practices like encapsulation and error handling, and is structured to be challenging yet solvable within a reasonable timeframe.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for attendee registration status
enum RegistrationStatus {
    PENDING,
    REGISTERED,
    CHECKED_IN
}

// Represents an attendee
class Attendee {
    private String attendeeId;
    private String name;
    private RegistrationStatus status;

    public Attendee(String attendeeId, String name) {
        if (attendeeId == null || attendeeId.trim().isEmpty() || name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee ID and Name cannot be empty.");
        }
        this.attendeeId = attendeeId.trim();
        this.name = name.trim();
        this.status = RegistrationStatus.PENDING; // Initially PENDING when created
    }

    public String getAttendeeId() {
        return attendeeId;
    }

    public String getName() {
        return name;
    }

    public RegistrationStatus getStatus() {
        return status;
    }

    // Method to update status - controlled internally by EventManager
    void setStatus(RegistrationStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + attendeeId + ", Name: " + name + ", Status: " + status;
    }
}

// Manages attendees for a single event
class EventManager {
    private Queue<Attendee> registrationQueue;
    private List<Attendee> registeredAttendees; // Implemented using ArrayList
    private String eventName;

    public EventManager(String eventName) {
        if (eventName == null || eventName.trim().isEmpty()) {
             throw new IllegalArgumentException("Event name cannot be empty.");
        }
        this.eventName = eventName.trim();
        this.registrationQueue = new LinkedList<>(); // LinkedList implements Queue
        this.registeredAttendees = new ArrayList<>(); // ArrayList implements List
        System.out.println("Event Manager initialized for: " + this.eventName);
    }

    /**
     * Adds a new attendee registration request to the queue.
     * @param attendeeId The unique ID for the attendee.
     * @param name The name of the attendee.
     */
    public void addRegistrationRequest(String attendeeId, String name) {
        try {
            Attendee newAttendee = new Attendee(attendeeId, name);
            // Basic check if ID already exists in queue or registered list (optional but good)
            boolean existsInQueue = registrationQueue.stream()
                                     .anyMatch(a -> a.getAttendeeId().equals(attendeeId));
            boolean existsInRegistered = registeredAttendees.stream()
                                         .anyMatch(a -> a.getAttendeeId().equals(attendeeId));

            if (existsInQueue || existsInRegistered) {
                System.err.println("Error: Attendee with ID " + attendeeId + " already exists.");
                return;
            }

            registrationQueue.offer(newAttendee); // offer is safer than add, returns false if failed
            System.out.println("Registration request added for " + name + " (ID: " + attendeeId + ").");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding registration: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding registration: " + e.getMessage());
        }
    }

    /**
     * Processes all pending registration requests in the queue, moving them
     * to the registered list and updating their status.
     */
    public void processRegistrationQueue() {
        if (registrationQueue.isEmpty()) {
            System.err.println("Registration queue is empty. Nothing to process.");
            return;
        }

        int processedCount = 0;
        // Process all items currently in the queue
        while (!registrationQueue.isEmpty()) {
            Attendee attendee = registrationQueue.poll(); // Retrieve and remove the head of the queue
            if (attendee != null) {
                attendee.setStatus(RegistrationStatus.REGISTERED);
                registeredAttendees.add(attendee); // Add to the registered list
                processedCount++;
            }
        }
        System.out.println("Processed " + processedCount + " registration requests.");
    }

    /**
     * Finds an attendee by ID in the registered list and checks them in.
     * @param attendeeId The ID of the attendee to check in.
     */
    public void checkInAttendee(String attendeeId) {
        if (attendeeId == null || attendeeId.trim().isEmpty()) {
            System.err.println("Attendee ID cannot be empty for check-in.");
            return;
        }
        String idToFind = attendeeId.trim();

        // Search the registeredAttendees List
        Attendee foundAttendee = null;
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getAttendeeId().equals(idToFind)) {
                foundAttendee = attendee;
                break;
            }
        }

        if (foundAttendee == null) {
            System.err.println("Error: Attendee with ID " + idToFind + " not found in registered list.");
        } else {
            if (foundAttendee.getStatus() == RegistrationStatus.REGISTERED) {
                foundAttendee.setStatus(RegistrationStatus.CHECKED_IN);
                System.out.println("Attendee " + idToFind + " checked in successfully.");
            } else if (foundAttendee.getStatus() == RegistrationStatus.CHECKED_IN) {
                System.err.println("Error: Attendee with ID " + idToFind + " is already checked in.");
            } else {
                 // This case should ideally not happen if processRegistrationQueue works correctly
                 System.err.println("Error: Attendee with ID " + idToFind + " has unexpected status: " + foundAttendee.getStatus());
            }
        }
    }

    /**
     * Provides a summary of the current event status.
     * @return A string detailing the counts of attendees in different statuses.
     */
    public String getEventStatus() {
        int pendingCount = registrationQueue.size();
        int registeredCount = 0;
        int checkedInCount = 0;

        for (Attendee attendee : registeredAttendees) {
            if (attendee.getStatus() == RegistrationStatus.REGISTERED) {
                registeredCount++;
            } else if (attendee.getStatus() == RegistrationStatus.CHECKED_IN) {
                checkedInCount++;
            }
        }

        StringBuilder statusReport = new StringBuilder();
        statusReport.append("--- Event Status for '").append(eventName).append("' ---\n");
        statusReport.append("Pending in Queue: ").append(pendingCount).append("\n");
        statusReport.append("Registered: ").append(registeredCount).append("\n");
        statusReport.append("Checked In: ").append(checkedInCount).append("\n");
        statusReport.append("--------------------");

        return statusReport.toString();
    }
}

// Main application class
public class ExamSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager("Annual Tech Conference");
        boolean running = true;

        // Class-wide try-catch for unexpected errors in the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Initialize choice outside the try block

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for menu navigation
                    switch (choice) {
                        case 1: // Add Registration Request
                            System.out.print("Enter Attendee ID: ");
                            String id = scanner.nextLine();
                            System.out.print("Enter Attendee Name: ");
                            String name = scanner.nextLine();
                            eventManager.addRegistrationRequest(id, name);
                            break;

                        case 2: // Process All Registration Requests
                            eventManager.processRegistrationQueue();
                            break;

                        case 3: // Check In Attendee
                            System.out.print("Enter Attendee ID to Check In: ");
                            String checkInId = scanner.nextLine();
                            eventManager.checkInAttendee(checkInId);
                            break;

                        case 4: // View Event Status
                            System.out.println(eventManager.getEventStatus());
                            break;

                        case 5: // Exit
                            System.out.println("Exiting system. Goodbye!");
                            running = false;
                            break;

                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid menu choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                     // Catch any other unexpected exceptions during operation handling
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     e.printStackTrace(); // Optional: print stack trace for debugging in exam context
                }
            }
        } catch (Exception e) {
            // This catches any exceptions that escape the inner try-catch,
            // providing a final safety net for the application loop.
            System.err.println("A critical error occurred in the main application loop: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Indicate resource cleanup
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Add Registration Request");
        System.out.println("2. Process All Registration Requests");
        System.out.println("3. Check In Attendee");
        System.out.println("4. View Event Status");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }
}
