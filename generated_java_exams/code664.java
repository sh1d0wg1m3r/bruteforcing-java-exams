/*
 * Exam Question #664
 * Generated on: 2025-05-12 16:22:12
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Exam Task: Print Job Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based application to simulate a print server. The system should manage a queue of print jobs waiting to be processed and maintain a history of jobs that have been completed. Users should be able to submit new jobs, process the next job in the queue, view the current queue, and view a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java program named `PrintManager` that fulfills the following requirements:
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class `PrintJob` with private fields: `jobId` (int), `fileName` (String), `pages` (int), and `status` (String, initially "Queued").
 *     *   Implement a constructor to initialize these fields. Assign a unique `jobId` automatically using a static counter starting from 1.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for the `status` field.
 *     *   Override the `toString()` method to provide a user-friendly representation of the job (including ID, file name, pages, and status).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Create a class `PrintManager` which will contain the main application logic.
 *     *   Declare a private field `jobQueue` of type `java.util.Queue<PrintJob>` to hold jobs waiting to be processed. Use a suitable implementation (e.g., `java.util.LinkedList`).
 *     *   Declare a private field `jobHistory` of type `java.util.List<PrintJob>` to store completed jobs. Use `java.util.ArrayList` as the implementation.
 *     *   Declare a private field `scanner` of type `java.util.Scanner` to read user input from the console.
 *     *   Implement a constructor to initialize the `jobQueue`, `jobHistory`, and `scanner`.
 *     *   Implement a `main` method that creates a `PrintManager` instance and starts the application loop.
 *     *   Implement a method (e.g., `run()`) that contains the main application loop. This loop should repeatedly:
 *         *   Display a menu of options to the user:
 *             1.  Submit New Print Job
 *             2.  Process Next Print Job
 *             3.  View Current Queue
 *             4.  View Job History
 *             5.  Exit
 *         *   Read the user's choice using the `Scanner`.
 *         *   Use a `switch` statement to handle the user's choice.
 * 
 * 3.  **Menu Options Implementation:**
 *     *   **Option 1 (Submit Job):**
 *         *   Prompt the user for the file name and number of pages.
 *         *   Validate input: File name must not be empty. Number of pages must be a positive integer (> 0).
 *         *   If validation fails, print an error message to `System.err` and do not create/add the job.
 *         *   If input is valid, create a new `PrintJob` object and add it to the `jobQueue`.
 *         *   Print a success message to `System.out`.
 *     *   **Option 2 (Process Job):**
 *         *   Check if the `jobQueue` is empty. If so, print an informational message to `System.out`.
 *         *   If not empty, remove the next job from the front of the `jobQueue` using a `Queue` method.
 *         *   Change the status of the processed job to "Completed" using the setter.
 *         *   Add the completed job to the `jobHistory` list.
 *         *   Print a success message to `System.out` indicating which job was processed.
 *     *   **Option 3 (View Queue):**
 *         *   Check if the `jobQueue` is empty. If so, print an informational message to `System.out`.
 *         *   If not empty, iterate through the `jobQueue` (without removing elements) and print the details of each job using its `toString()` method to `System.out`.
 *     *   **Option 4 (View History):**
 *         *   Check if the `jobHistory` is empty. If so, print an informational message to `System.out`.
 *         *   If not empty, iterate through the `jobHistory` list and print the details of each completed job using its `toString()` method to `System.out`.
 *     *   **Option 5 (Exit):**
 *         *   Print an exit message to `System.out` and terminate the program.
 *     *   **Invalid Choice:** If the user enters a number outside the range 1-5, print an error message to `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.err` for all error messages (input validation failures, invalid menu choices, unexpected issues).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, list displays, exit message).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., non-integer input for menu choice or pages). Ensure the application doesn't crash on invalid input and prompts the user again. The `try-catch` should ideally cover the main operational loop.
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to Java coding conventions (meaningful variable/method names, indentation).
 *     *   Include comments to explain key parts of the code.
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting user input, and displaying results or errors as described above. The output should clearly distinguish between normal messages (`System.out`) and error messages (`System.err`).
 *
 * EXPLANATION:
 * This solution implements a simple Print Job Management System using core Java collections and control structures as required.
 * 
 * **Key Components Used and Demonstrated:**
 * 
 * 1.  **`java.util.Queue`**: The `jobQueue` field is declared as a `Queue<PrintJob>` and initialized with `java.util.LinkedList`. This demonstrates the use of a Queue to manage elements in a First-In, First-Out (FIFO) manner. `offer()` is used to add jobs to the tail, and `poll()` is used to remove jobs from the head during processing.
 * 2.  **`java.util.ArrayList`**: The `jobHistory` field is initialized with `new ArrayList<>()`. This demonstrates the use of an `ArrayList`, a resizable array implementation of the `List` interface, to store completed jobs.
 * 3.  **`java.util.List` interface**: The `jobHistory` field is declared using the `List<PrintJob>` interface type (`private List<PrintJob> jobHistory;`). This demonstrates the principle of programming to interfaces rather than concrete implementations, promoting flexibility.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used to read user input from `System.in` for menu choices, file names, and page counts.
 * 5.  **`switch` statement**: A `switch` statement in the `run()` method is used to direct program flow based on the user's integer input from the menu.
 * 6.  **`System.err`**: `System.err.println()` is used specifically for displaying error messages, such as invalid input during job submission, invalid menu choices, and unexpected exceptions. This distinguishes error output from normal program output.
 * 7.  **`System.out`**: `System.out.println()` is used for all standard output, including the menu, prompts, success messages, confirmation of actions, and displaying the contents of the queue and history.
 * 8.  **Class-wide exception handling with `try-catch`**: A `try-catch` block is wrapped around the main `while` loop in the `run()` method. This demonstrates catching potential exceptions that might occur during the program's execution, preventing the program from crashing. A more specific `try-catch` for `InputMismatchException` is also included inside the loop to handle non-integer input gracefully for the menu choice, consuming the invalid input and prompting the user again. The outer `catch (Exception e)` serves as a general fallback for other unexpected runtime issues. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields in both `PrintJob` and `PrintManager` classes are declared as `private`, and access is provided through public getter and setter methods where appropriate (`PrintJob` status setter).
 * *   **Meaningful Variable and Method Names:** Names like `jobQueue`, `jobHistory`, `submitJob`, `processNextJob`, `viewQueue`, `viewHistory`, `fileName`, `pages` are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic points.
 * *   **Input Validation:** The `submitJob` method explicitly checks for empty file names and non-positive page counts, providing specific error messages via `System.err`.
 * *   **Proper Error Handling:** Different types of errors (validation, invalid choice, runtime exception) are handled differently, using `System.err` for error output and preventing program termination where possible. Specific exceptions like `InputMismatchException` are caught and handled gracefully.
 * *   **Clean Code Structure:** The code is divided into two classes (`PrintJob` and `PrintManager`) with distinct responsibilities. `PrintManager` methods are kept relatively focused on single tasks (displaying menu, submitting, processing, viewing).
 * 
 * **Workflow:**
 * 
 * The `main` method in `PrintManager` creates an instance and calls its `run()` method. The `run()` method enters a loop that displays the menu, reads user input, and uses a `switch` statement to dispatch the request to the appropriate private method (`submitJob`, `processNextJob`, etc.). Input validation and collection manipulation (`offer`, `poll`, `add`, iteration) are performed within these methods. Error conditions are reported using `System.err`, and unexpected exceptions are caught by the outer `try-catch` block. The loop continues until the user selects the 'Exit' option (5). The `finally` block ensures resources are cleaned up.
 * 
 * This solution effectively demonstrates the required Java concepts and best practices within a practical, interactive command-line application.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Good specific exception to catch

/**
 * Represents a single print job with ID, file name, pages, and status.
 */
class PrintJob {
    private int jobId;
    private String fileName;
    private int pages;
    private String status; // e.g., "Queued", "Processing", "Completed", "Failed"

    // Static counter for unique job IDs, shared among all PrintJob instances
    private static int jobCounter = 0;

    /**
     * Constructs a new PrintJob.
     * Automatically assigns a unique ID and sets the initial status to "Queued".
     *
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the file.
     */
    public PrintJob(String fileName, int pages) {
        this.jobId = ++jobCounter; // Assign unique ID and increment counter
        this.fileName = fileName;
        this.pages = pages;
        this.status = "Queued"; // Initial status
    }

    // --- Getters ---

    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---

    /**
     * Sets the status of the print job.
     *
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages + ", Status: " + status;
    }
}

/**
 * Manages the print job queue and history.
 * Handles user interaction via console menu.
 */
public class PrintManager {

    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<PrintJob> jobQueue;
    // List to hold completed jobs (maintains order of completion)
    private List<PrintJob> jobHistory; // Using List interface, implemented by ArrayList
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing the queue, history, and scanner.
     */
    public PrintManager() {
        // Using LinkedList as an implementation of Queue
        this.jobQueue = new LinkedList<>();
        // Using ArrayList as an implementation of List for history
        this.jobHistory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Job Manager ---");
        System.out.println("1. Submit New Print Job");
        System.out.println("2. Process Next Print Job");
        System.out.println("3. View Current Queue");
        System.out.println("4. View Job History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the submission of a new print job based on user input.
     * Includes input validation.
     */
    private void submitJob() {
        System.out.print("Enter file name: ");
        // Use nextLine() to capture the entire line, then trim whitespace
        String fileName = scanner.nextLine().trim();

        // Validate file name
        if (fileName.isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return; // Exit the method if validation fails
        }

        int pages = 0;
        System.out.print("Enter number of pages: ");
        try {
            // Attempt to read integer input for pages
            pages = scanner.nextInt();
            // Consume the leftover newline character after nextInt()
            scanner.nextLine();
        } catch (InputMismatchException e) {
            // Handle non-integer input
            System.err.println("Error: Invalid input for pages. Please enter a valid number.");
            // Consume the invalid input to prevent an infinite loop caused by nextInt()
            scanner.nextLine();
            return; // Exit the method if input is invalid
        }

        // Validate number of pages
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive.");
            return; // Exit the method if validation fails
        }

        // Create the new job and add it to the queue
        PrintJob newJob = new PrintJob(fileName, pages);
        jobQueue.offer(newJob); // offer() is recommended for queues; returns false on failure (rare for LinkedList)
        System.out.println("Job submitted successfully: " + newJob.getFileName() + " (ID: " + newJob.getJobId() + ")");
    }

    /**
     * Processes the next job at the head of the queue.
     * Removes the job from the queue, updates its status, and adds it to history.
     */
    private void processNextJob() {
        // Check if the queue is empty before attempting to process
        if (jobQueue.isEmpty()) {
            System.out.println("Print queue is empty. No jobs to process."); // Informational message
            return;
        }

        // Use poll() to remove and retrieve the head of the queue
        PrintJob jobToProcess = jobQueue.poll();

        // poll() returns null if the queue is empty, though we checked already.
        // This check adds robustness.
        if (jobToProcess != null) {
            // Simulate processing the job
            System.out.println("Processing job: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getJobId() + ")");

            // Update the job's status
            jobToProcess.setStatus("Completed");

            // Add the processed job to the history list
            jobHistory.add(jobToProcess);
            System.out.println("Job " + jobToProcess.getJobId() + " processed and added to history.");
        } else {
             // This block should ideally not be reached due to the isEmpty check,
             // but included for defensive programming.
             System.err.println("Internal Error: Failed to retrieve job from queue despite it not being empty.");
        }
    }

    /**
     * Displays the details of all jobs currently waiting in the queue.
     * Does not remove jobs from the queue.
     */
    private void viewQueue() {
        // Check if the queue is empty
        if (jobQueue.isEmpty()) {
            System.out.println("Print queue is empty."); // Informational message
            return;
        }

        System.out.println("\n--- Current Print Queue ---");
        // Iterate through the queue using a for-each loop (uses iterator internally)
        // This does NOT remove elements from the queue.
        int count = 0;
        for (PrintJob job : jobQueue) {
             System.out.println(job);
             count++;
        }
        System.out.println("Total jobs in queue: " + count);
    }

    /**
     * Displays the details of all jobs in the history list.
     */
    private void viewHistory() {
        // Check if the history list is empty
        if (jobHistory.isEmpty()) {
            System.out.println("Job history is empty."); // Informational message
            return;
        }

        System.out.println("\n--- Print Job History ---");
        // Iterate through the history list (ArrayList)
        for (PrintJob job : jobHistory) {
            System.out.println(job);
        }
        System.out.println("Total jobs in history: " + jobHistory.size());
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     * Includes class-wide exception handling for the main loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling block covering the main interactive loop.
        // Catches unexpected runtime errors.
        try {
            // Loop until the user chooses to exit (choice 5)
            while (choice != 5) {
                displayMenu();

                // Inner try-catch to specifically handle non-integer input for the menu choice
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt() to prepare for nextLine() calls
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input from the scanner buffer to prevent an infinite loop
                    scanner.nextLine();
                    choice = -1; // Reset choice to an invalid value to loop again
                    continue; // Skip the switch statement and continue to the next loop iteration
                }

                // Use a switch statement to perform actions based on the user's valid choice
                switch (choice) {
                    case 1:
                        submitJob(); // Call method to submit a new job
                        break;
                    case 2:
                        processNextJob(); // Call method to process the next job in the queue
                        break;
                    case 3:
                        viewQueue(); // Call method to view the current queue
                        break;
                    case 4:
                        viewHistory(); // Call method to view the job history
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Manager. Goodbye!"); // Exit message
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that occur during the program execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Print the stack trace to standard error for debugging
            e.printStackTrace(System.err);
        } finally {
             // Ensure the scanner resource is closed when the program finishes or encounters an error
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * The main entry point of the application.
     * Creates a PrintManager instance and starts the application loop.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.run(); // Start the main application loop
    }
}
