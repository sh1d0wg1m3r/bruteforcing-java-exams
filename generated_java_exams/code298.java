/*
 * Exam Question #298
 * Generated on: 2025-05-11 22:51:21
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Software Build Queue and Artifact Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system to manage software build jobs and their resulting artifacts. The system should allow users to submit new build requests, process the next pending build, and view both the waiting jobs and the completed artifacts.
 * 
 * Your solution must adhere to the following requirements and demonstrate proficiency in using various core Java components and best practices.
 * 
 * **System Functionality:**
 * 
 * 1.  **Submit Build Job:** Allows the user to enter details for a new build job (Project Name, Version). The system should assign a unique ID to each job and add it to a queue of pending jobs.
 * 2.  **Process Next Build:** Takes the next job from the front of the pending queue. It simulates a build process (no actual compilation needed, just simulate creating an output). Upon successful "build", it creates an "artifact" record linked to the job and adds it to a list of completed artifacts. If the queue is empty, it should report an error.
 * 3.  **View Pending Jobs:** Displays the details of all jobs currently waiting in the queue.
 * 4.  **View Completed Artifacts:** Displays the details of all artifacts generated from completed builds.
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Requirements:**
 * 
 * *   Use `java.util.Queue` (specifically, an implementation like `java.util.LinkedList`) to manage the pending build jobs (FIFO - First-In, First-Out).
 * *   Use `java.util.ArrayList` to store the completed artifacts.
 * *   Declare the collection for completed artifacts using the `java.util.List` interface type.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Implement the main menu and user command handling using a `switch` statement.
 * *   Use `System.err` to print error messages (e.g., invalid input, trying to process an empty queue).
 * *   Use `System.out` for all normal output (menu, prompts, job/artifact details).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid numerical input from the user.
 * *   Design the system using object-oriented principles:
 *     *   Create classes for `BuildJob` and `Artifact`.
 *     *   Create a main class (e.g., `BuildSystemApp`) to contain the `main` method and application logic.
 *     *   Consider a class (e.g., `BuildQueueManager`) to encapsulate the queue, list, and core operations.
 * *   Follow best practices:
 *     *   Use private fields and public methods (encapsulation).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Perform basic input validation (e.g., check for empty project name/version).
 * 
 * **Input Format:**
 * 
 * The system should present a menu and prompt the user for a choice (an integer). Depending on the choice, it may prompt for additional input (strings).
 * 
 * **Output Format:**
 * 
 * *   Menu options should be printed to `System.out`.
 * *   Prompts for input should be printed to `System.out`.
 * *   Details of pending jobs and completed artifacts should be printed to `System.out`.
 * *   Error messages should be printed to `System.err`.
 * *   Confirmation messages (e.g., "Job submitted successfully") should be printed to `System.out`.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Build Management Menu ---
 * 1. Submit New Build Job
 * 2. Process Next Build
 * 3. View Pending Jobs
 * 4. View Completed Artifacts
 * 5. Exit
 * Enter choice: 1
 * Enter Project Name: MyProject
 * Enter Version: 1.0.0
 * Job 1 (MyProject v1.0.0) submitted successfully.
 * 
 * --- Build Management Menu ---
 * ...
 * Enter choice: 2
 * Processing Job 1 (MyProject v1.0.0)...
 * Artifact for Job 1 created: MyProject-1.0.0.jar (Size: 500 KB).
 * 
 * --- Build Management Menu ---
 * ...
 * Enter choice: 2
 * Error: No pending jobs to process.
 * 
 * --- Build Management Menu ---
 * ...
 * Enter choice: 4
 * --- Completed Artifacts ---
 * Job ID: 1, File: MyProject-1.0.0.jar, Size: 500 KB
 * ---------------------------
 * 
 * --- Build Management Menu ---
 * ...
 * Enter choice: 5
 * Exiting Build Management System.
 * ```
 * 
 * Your task is to implement the complete Java code for this system.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper use of `System.err` and `System.out`.
 * *   Effective implementation of `try-catch` for exception handling, including handling potential input errors.
 * *   Adherence to object-oriented design principles (encapsulation, classes).
 * *   Meaningful naming and comments.
 * *   Basic input validation.
 * *   Correct implementation of system functionality (add to queue, process from queue, add to list, view).
 * 
 * **Note:** You do not need to implement actual file creation or complex build logic. Simulating the artifact creation with dummy data (like generating a file name and random size) is sufficient.
 *
 * EXPLANATION:
 * The solution implements a simple software build management system adhering to all specified requirements.
 * 
 * 1.  **Object-Oriented Design:**
 *     *   `BuildJob` class: Encapsulates the data for a build request (ID, project name, version) with private fields and public getters. Includes input validation in the constructor.
 *     *   `Artifact` class: Encapsulates the data for a completed build output (job ID, file name, size) with private fields and public getters. Includes input validation in the constructor.
 *     *   `BuildQueueManager` class: Encapsulates the core logic and data structures (`Queue` for pending jobs, `List` for completed artifacts). It manages the state of the system and provides methods (`submitJob`, `processNextJob`) to interact with it. This promotes modularity and encapsulation.
 *     *   `BuildSystemApp` class: Contains the `main` method, handles user interaction (menu, input), and orchestrates calls to the `BuildQueueManager`.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `Queue<BuildJob> pendingJobs = new LinkedList<>();`: A `LinkedList` is used as an implementation of the `Queue` interface. This correctly models the FIFO nature of a build queue, where jobs are processed in the order they are submitted. `offer()` is used for adding to the queue and `poll()` for removing from the front.
 *     *   `List<Artifact> completedArtifacts = new ArrayList<>();`: An `ArrayList` is used to store the completed `Artifact` objects. It is declared using the `List` interface type, demonstrating programming to the interface. `ArrayList` is suitable here as we primarily need to add items and iterate through them.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is used to read user input from `System.in`. It's initialized once and closed in the `finally` block to release system resources.
 *     *   The `getUserChoice()` method specifically handles reading integer input and consumes the leftover newline character using `scanner.nextLine()` to prevent issues in subsequent `nextLine()` calls.
 * 
 * 4.  **Flow Control (`switch`):**
 *     *   A `switch` statement in the `main` method is used to direct the program flow based on the integer choice entered by the user, providing a clear and structured menu system.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, confirmation messages, and the details of jobs and artifacts.
 *     *   `System.err.println()` is used specifically for printing error messages, such as invalid menu choices, input validation failures, or operational errors (like trying to process an empty queue). This is good practice for distinguishing normal output from errors.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A large `try-catch (Exception e)` block wraps the main application loop in the `main` method. This provides a form of "class-wide" handling, catching any unexpected exceptions that might propagate up from the called methods and preventing the application from crashing abruptly.
 *     *   Specific `try-catch (InputMismatchException e)` is used within `getUserChoice()` to handle cases where the user enters non-integer input when an integer is expected.
 *     *   `IllegalArgumentException` is caught in `submitBuildJob` to handle validation errors originating from the `BuildJob` constructor.
 *     *   Operational errors, like attempting to process an empty queue, are handled by checking the return value of `manager.processNextJob()` and printing an error message to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used in `BuildJob`, `Artifact`, and `BuildQueueManager`.
 *     *   **Meaningful Names:** Class names (`BuildJob`, `Artifact`, `BuildQueueManager`, `BuildSystemApp`), variable names (`pendingJobs`, `completedArtifacts`, `nextJobId`), and method names (`submitJob`, `processNextJob`, `viewPendingJobs`) are descriptive.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** Basic checks for null or empty strings are performed before creating `BuildJob` objects. `getUserChoice` handles non-integer input.
 *     *   **Error Handling:** As detailed above, various `try-catch` blocks and conditional checks handle different error scenarios.
 *     *   **Clean Code:** The code is organized into separate classes with clear responsibilities. Methods are relatively short and focused.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, albeit simplified, system scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random; // For simulating artifact size

/**
 * Represents a software build job request.
 */
class BuildJob {
    private int id;
    private String projectName;
    private String version;

    /**
     * Constructs a new BuildJob.
     * @param id The unique ID for the job.
     * @param projectName The name of the project to build.
     * @param version The version of the project to build.
     */
    public BuildJob(int id, String projectName, String version) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be null or empty.");
        }
        if (version == null || version.trim().isEmpty()) {
            throw new IllegalArgumentException("Version cannot be null or empty.");
        }
        this.id = id;
        this.projectName = projectName.trim();
        this.version = version.trim();
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getProjectName() {
        return projectName;
    }

    public String getVersion() {
        return version;
    }

    @Override
    public String toString() {
        return "Job " + id + " (" + projectName + " v" + version + ")";
    }
}

/**
 * Represents a software artifact produced by a build job.
 */
class Artifact {
    private int jobId;
    private String fileName;
    private int sizeKB; // Size in Kilobytes

    /**
     * Constructs a new Artifact.
     * @param jobId The ID of the build job that produced this artifact.
     * @param fileName The name of the artifact file.
     * @param sizeKB The size of the artifact in KB.
     */
    public Artifact(int jobId, String fileName, int sizeKB) {
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be null or empty.");
        }
        if (sizeKB < 0) {
             throw new IllegalArgumentException("Size cannot be negative.");
        }
        this.jobId = jobId;
        this.fileName = fileName.trim();
        this.sizeKB = sizeKB;
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getSizeKB() {
        return sizeKB;
    }

    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Size: " + sizeKB + " KB";
    }
}

/**
 * Manages the queue of pending build jobs and the list of completed artifacts.
 */
class BuildQueueManager {
    private Queue<BuildJob> pendingJobs;
    private List<Artifact> completedArtifacts;
    private int nextJobId;
    private Random random; // For simulating artifact size

    /**
     * Constructs a new BuildQueueManager.
     */
    public BuildQueueManager() {
        this.pendingJobs = new LinkedList<>(); // LinkedList implements Queue
        this.completedArtifacts = new ArrayList<>(); // ArrayList implements List
        this.nextJobId = 1;
        this.random = new Random();
    }

    /**
     * Submits a new build job to the queue.
     * @param projectName The name of the project.
     * @param version The version of the project.
     * @return The submitted BuildJob object.
     * @throws IllegalArgumentException if input is invalid.
     */
    public BuildJob submitJob(String projectName, String version) {
        BuildJob newJob = new BuildJob(nextJobId++, projectName, version);
        pendingJobs.offer(newJob); // offer is preferred over add for queues
        return newJob;
    }

    /**
     * Processes the next job in the queue, simulating a build and creating an artifact.
     * @return The created Artifact object, or null if the queue was empty.
     */
    public Artifact processNextJob() {
        BuildJob jobToProcess = pendingJobs.poll(); // poll retrieves and removes the head of the queue
        if (jobToProcess == null) {
            return null; // Queue is empty
        }

        // Simulate build process and artifact creation
        String artifactFileName = jobToProcess.getProjectName() + "-" + jobToProcess.getVersion() + ".jar";
        int artifactSize = 200 + random.nextInt(1000); // Simulate size between 200 and 1199 KB

        Artifact completedArtifact = new Artifact(jobToProcess.getId(), artifactFileName, artifactSize);
        completedArtifacts.add(completedArtifact);

        System.out.println("Processing " + jobToProcess + "...");
        System.out.println("Artifact for Job " + jobToProcess.getId() + " created: " + completedArtifact.getFileName() + " (Size: " + completedArtifact.getSizeKB() + " KB).");

        return completedArtifact;
    }

    /**
     * Gets the list of pending jobs.
     * Note: Returns the internal queue for easy iteration in the main app.
     * In a more complex system, might return a copy or unmodifiable view.
     * @return The Queue of pending BuildJob objects.
     */
    public Queue<BuildJob> getPendingJobs() {
        return pendingJobs;
    }

    /**
     * Gets the list of completed artifacts.
     * Note: Returns the internal list for easy iteration in the main app.
     * In a more complex system, might return a copy or unmodifiable view.
     * @return The List of completed Artifact objects.
     */
    public List<Artifact> getCompletedArtifacts() {
        return completedArtifacts;
    }
}

/**
 * Main application class for the Build Management System.
 */
public class BuildSystemApp {

    private static BuildQueueManager manager = new BuildQueueManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        submitBuildJob();
                        break;
                    case 2:
                        processNextBuild();
                        break;
                    case 3:
                        viewPendingJobs();
                        break;
                    case 4:
                        viewCompletedArtifacts();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Build Management System.");
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Build Management Menu ---");
        System.out.println("1. Submit New Build Job");
        System.out.println("2. Process Next Build");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Artifacts");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Reads and validates user's menu choice. Handles non-integer input.
     * @return The valid integer choice.
     */
    private static int getUserChoice() {
        while (true) {
            try {
                // Use Scanner to read input
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character
                return choice;
            } catch (InputMismatchException e) {
                // Use System.err for input type errors
                System.err.println("Invalid input. Please enter an integer.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                System.out.print("Enter choice: "); // Reprompt
            }
        }
    }

    /**
     * Handles the submission of a new build job.
     */
    private static void submitBuildJob() {
        System.out.print("Enter Project Name: ");
        String projectName = scanner.nextLine();
        System.out.print("Enter Version: ");
        String version = scanner.nextLine();

        // Basic input validation before creating the job
        if (projectName.trim().isEmpty() || version.trim().isEmpty()) {
             System.err.println("Project name and version cannot be empty.");
             return; // Exit the method if input is invalid
        }

        try {
            BuildJob submittedJob = manager.submitJob(projectName, version);
            System.out.println(submittedJob + " submitted successfully.");
        } catch (IllegalArgumentException e) {
            // Catch exceptions from the BuildJob constructor for invalid data
            System.err.println("Error submitting job: " + e.getMessage());
        }
    }

    /**
     * Handles the processing of the next build job in the queue.
     */
    private static void processNextBuild() {
        Artifact artifact = manager.processNextJob();
        if (artifact == null) {
            // Use System.err for operational errors like empty queue
            System.err.println("Error: No pending jobs to process.");
        }
        // Success message is printed inside processNextJob method
    }

    /**
     * Displays the list of pending build jobs.
     */
    private static void viewPendingJobs() {
        Queue<BuildJob> pending = manager.getPendingJobs();
        System.out.println("--- Pending Build Jobs ---");
        if (pending.isEmpty()) {
            System.out.println("No jobs currently pending.");
        } else {
            // Iterate through the Queue (e.g., using a for-each loop or iterator)
            // Note: Iterating directly over the queue does not remove elements
            for (BuildJob job : pending) {
                System.out.println(job);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the list of completed artifacts.
     */
    private static void viewCompletedArtifacts() {
        List<Artifact> completed = manager.getCompletedArtifacts();
        System.out.println("--- Completed Artifacts ---");
        if (completed.isEmpty()) {
            System.out.println("No artifacts completed yet.");
        } else {
            // Iterate through the List
            for (Artifact artifact : completed) {
                System.out.println(artifact);
            }
        }
        System.out.println("---------------------------");
    }
}
