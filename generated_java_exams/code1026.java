/*
 * Exam Question #1026
 * Generated on: 2025-05-12 17:14:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Document Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Document Processing System in Java. This system will manage documents through a processing queue and maintain a history of processed documents. Users should be able to interact with the system via a command-line interface to add new documents, process the next document in the queue, view the current queue, view the processing history, and exit the application.
 * 
 * The system should simulate a processing step where a document is taken from the front of the queue, its status is updated (simulating success or failure), and it is then moved to a historical record.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a `Document` class with private fields for a unique integer `id`, a `String name`, and a `String status` (e.g., "Pending", "Completed", "Failed"). Include a constructor, public getter methods for all fields, a public setter method for the status, and a `toString()` method for easy printing.
 * 2.  **Processing System Logic:** Create a `ProcessingSystem` class to manage the documents.
 *     *   It must use a `java.util.Queue<Document>` to hold documents waiting to be processed. Use `java.util.LinkedList` as the concrete implementation for the queue.
 *     *   It must use a `java.util.List<Document>` to store documents after they have been processed. Declare the field as `List` and use `java.util.ArrayList` as the concrete implementation.
 *     *   Implement methods:
 *         *   `addDocument(String name)`: Creates a new `Document` with a unique ID and "Pending" status and adds it to the processing queue.
 *         *   `processNextDocument()`: Removes the document at the front of the queue. If the queue is empty, print an error message to `System.err` and do nothing further. Otherwise, simulate processing (e.g., randomly determine success or failure), update the document's status, and add it to the processed history list. Print the outcome (success or failure) to `System.out`.
 *         *   `viewQueue()`: Prints the details of all documents currently in the processing queue to `System.out`. Indicate if the queue is empty.
 *         *   `viewHistory()`: Prints the details of all documents in the processed history list to `System.out`. Indicate if the history is empty.
 * 3.  **User Interface:** Create a main application class (e.g., `DocumentProcessorApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user: Add Document, Process Next, View Queue, View History, Exit.
 *     *   Use a `switch` statement to handle the user's choice and call the appropriate methods on the `ProcessingSystem` instance.
 *     *   The application should run in a loop until the user chooses to exit.
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for normal output (menu, prompts, success messages, document details).
 *     *   Use `System.err` for specific error messages (e.g., trying to process when the queue is empty, invalid menu input).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential issues like invalid input type from the user (e.g., entering text when a number is expected).
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement basic input validation (e.g., handling non-integer menu input).
 *     *   Structure the code clearly across classes.
 * 
 * **Expected Output:**
 * 
 * The program should provide a clear command-line interface. Example interactions might look like:
 * 
 * ```
 * --- Document Processing System ---
 * Choose an action:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 0. Exit
 * Enter your choice: 1
 * Enter document name: ReportA
 * Document 'ReportA' added to the queue.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 1
 * Enter document name: DataSheetB
 * Document 'DataSheetB' added to the queue.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 3
 * --- Current Processing Queue ---
 * 1. Document [ID=1, Name='ReportA', Status='Pending']
 * 2. Document [ID=2, Name='DataSheetB', Status='Pending']
 * ------------------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * Attempting to process next document...
 * Processing document ID 1 ('ReportA')...
 * Document ID 1 processing completed successfully.
 * Document ID 1 moved to history.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 3
 * --- Current Processing Queue ---
 * 1. Document [ID=2, Name='DataSheetB', Status='Pending']
 * ------------------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 4
 * --- Processed Documents History ---
 * 1. Document [ID=1, Name='ReportA', Status='Completed']
 * ---------------------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * Attempting to process next document...
 * Processing document ID 2 ('DataSheetB')...
 * Document ID 2 processing failed. // Or completed, depending on simulation
 * Document ID 2 moved to history.
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 4
 * --- Processed Documents History ---
 * 1. Document [ID=1, Name='ReportA', Status='Completed']
 * 2. Document [ID=2, Name='DataSheetB', Status='Failed'] // Or Completed
 * ---------------------------------
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. // Printed to System.err
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 2
 * Attempting to process next document...
 * Processing failed: The processing queue is empty. // Printed to System.err
 * 
 * Choose an action:
 * ... menu ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * ```
 * 
 * **Constraint:** Your solution code must be provided as a single block.
 *
 * EXPLANATION:
 * The provided solution implements the Document Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Document` Class:**
 *     *   This class serves as a simple data structure representing a document.
 *     *   It uses private fields (`id`, `name`, `status`) and public getter methods (`getId`, `getName`, `getStatus`) and a setter (`setStatus`) to enforce encapsulation.
 *     *   The `toString()` method provides a convenient way to print document details.
 * 
 * 2.  **`ProcessingSystem` Class:**
 *     *   This class encapsulates the core logic of the system.
 *     *   It uses `private Queue<Document> processingQueue = new LinkedList<>();` to manage documents waiting for processing. `Queue` is the interface, and `LinkedList` is the concrete implementation, allowing FIFO (First-In, First-Out) behavior. `offer()` is used for adding to the queue, and `poll()` is used for removing from the front, safely returning `null` if the queue is empty.
 *     *   It uses `private List<Document> processedHistory = new ArrayList<>();` to store documents after processing. `List` is the interface, and `ArrayList` is the concrete implementation, providing dynamic array capabilities to store the history.
 *     *   The `addDocument` method creates a new `Document` and adds it to the `processingQueue`. A simple counter (`nextDocumentId`) ensures unique IDs.
 *     *   The `processNextDocument` method demonstrates several requirements:
 *         *   It uses `processingQueue.poll()` to get the next document.
 *         *   It checks if the result of `poll()` is `null` to detect an empty queue and prints an error message to `System.err` in this case.
 *         *   It simulates processing using `java.util.Random`.
 *         *   It updates the document's status using the `setStatus` method.
 *         *   It adds the processed document to the `processedHistory` list.
 *         *   It prints success messages to `System.out` and failure messages to `System.err`.
 *     *   The `viewQueue` and `viewHistory` methods iterate through the respective collections (`processingQueue` and `processedHistory`) and print the details of each document using the `Document`'s `toString()` method. They also check if the collections are empty and print appropriate messages.
 * 
 * 3.  **`DocumentProcessorApp` Class (`main` method):**
 *     *   This is the entry point of the application.
 *     *   It uses `java.util.Scanner` to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `printMenu` helper method displays the available options.
 *     *   A `switch` statement handles the user's integer choice, calling the corresponding methods in the `ProcessingSystem` instance.
 *     *   **Class-wide Exception Handling:** A `try-catch` block surrounds the user input reading and the `switch` statement.
 *         *   It specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when `scanner.nextInt()` is expected. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A general `catch (Exception e)` block is included as a catch-all for any other unexpected runtime errors that might occur within the main loop's execution, printing the error message to `System.err`. This demonstrates robust error handling at the application loop level.
 *     *   `System.out.println()` is used for the menu, prompts, and successful operation feedback.
 *     *   `System.err.println()` is used for error messages (invalid menu choice, input type mismatch, processing an empty queue, processing failure).
 *     *   The `scanner.close()` call ensures that resources are released when the application exits.
 * 
 * **Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Document`, `ProcessingSystem`, `DocumentProcessorApp`), objects, encapsulation (private fields, public methods).
 * *   **Collections Framework:** Practical usage of `Queue` (specifically `LinkedList` for FIFO behavior) and `List` (specifically `ArrayList` for dynamic storage and history). Understanding the difference between interfaces (`Queue`, `List`) and concrete implementations (`LinkedList`, `ArrayList`).
 * *   **Input/Output:** Using `Scanner` for console input, `System.out` for standard output, and `System.err` for error output.
 * *   **Control Flow:** Using `while` loop for the application cycle and `switch` statement for menu navigation.
 * *   **Exception Handling:** Using `try-catch` blocks for anticipated errors (like input type mismatches) and unexpected runtime errors, demonstrating robust application behavior. Specific error conditions within methods (like empty queue processing) are handled with conditional checks and `System.err`.
 * *   **Randomness:** Using `java.util.Random` to simulate real-world variability (processing success/failure).
 * *   **Best Practices:** Adherence to naming conventions, basic commenting, and separating concerns into different classes.
 * 
 * This solution effectively integrates multiple core and advanced Java concepts to solve a practical problem, fulfilling all the requirements of the exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

/**
 * Represents a document in the processing system.
 */
class Document {
    private int id;
    private String name;
    private String status; // e.g., "Pending", "Completed", "Failed"

    /**
     * Constructs a new Document.
     * @param id The unique ID of the document.
     * @param name The name of the document.
     * @param status The initial status of the document.
     */
    public Document(int id, String name, String status) {
        this.id = id;
        this.name = name;
        this.status = status;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Document.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Document [ID=" + id + ", Name='" + name + "', Status='" + status + "']";
    }
}

/**
 * Manages the document processing queue and history.
 */
class ProcessingSystem {
    private Queue<Document> processingQueue;
    private List<Document> processedHistory;
    private int nextDocumentId; // Counter for generating unique IDs
    private Random random; // For simulating processing outcome

    /**
     * Constructs a new ProcessingSystem.
     * Initializes the queue, history list, ID counter, and random generator.
     */
    public ProcessingSystem() {
        this.processingQueue = new LinkedList<>(); // Use LinkedList as concrete Queue
        this.processedHistory = new ArrayList<>(); // Use ArrayList as concrete List
        this.nextDocumentId = 1; // Start IDs from 1
        this.random = new Random();
    }

    /**
     * Adds a new document to the processing queue.
     * @param docName The name of the document to add.
     */
    public void addDocument(String docName) {
        Document newDoc = new Document(nextDocumentId++, docName, "Pending");
        processingQueue.offer(newDoc); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
    }

    /**
     * Processes the next document in the queue.
     * Removes the document, simulates processing, updates status, and moves to history.
     * Prints error to System.err if queue is empty.
     */
    public void processNextDocument() {
        Document docToProcess = processingQueue.poll(); // poll() retrieves and removes the head, returns null if empty

        if (docToProcess == null) {
            System.err.println("Processing failed: The processing queue is empty.");
            return; // Exit the method if queue was empty
        }

        System.out.println("Attempting to process document ID " + docToProcess.getId() + " ('" + docToProcess.getName() + "')...");

        // Simulate processing outcome: 70% chance of success
        boolean success = random.nextDouble() < 0.7;

        if (success) {
            docToProcess.setStatus("Completed");
            System.out.println("Document ID " + docToProcess.getId() + " processing completed successfully.");
        } else {
            docToProcess.setStatus("Failed");
            System.err.println("Document ID " + docToProcess.getId() + " processing failed.");
        }

        processedHistory.add(docToProcess);
        System.out.println("Document ID " + docToProcess.getId() + " moved to history.");
    }

    /**
     * Prints the details of all documents currently in the processing queue.
     * Prints to System.out.
     */
    public void viewQueue() {
        System.out.println("--- Current Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue to print elements without removing them
            int index = 1;
            for (Document doc : processingQueue) {
                System.out.println(index++ + ". " + doc); // Uses Document's toString()
            }
        }
        System.out.println("------------------------------");
    }

    /**
     * Prints the details of all documents in the processed history list.
     * Prints to System.out.
     */
    public void viewHistory() {
        System.out.println("--- Processed Documents History ---");
        if (processedHistory.isEmpty()) {
            System.out.println("The history is empty.");
        } else {
            // Iterate through the list
            for (int i = 0; i < processedHistory.size(); i++) {
                System.out.println((i + 1) + ". " + processedHistory.get(i)); // Uses Document's toString()
            }
        }
        System.out.println("---------------------------------");
    }
}

/**
 * Main application class for the Document Processing System.
 * Handles user interaction and menu navigation.
 */
public class DocumentProcessorApp {

    /**
     * Main method to run the Document Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProcessingSystem system = new ProcessingSystem();
        boolean running = true;

        System.out.println("--- Document Processing System ---");

        // Main application loop
        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            // Class-wide exception handling for user input
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for menu options
                switch (choice) {
                    case 1: // Add Document
                        System.out.print("Enter document name: ");
                        String docName = scanner.nextLine();
                        system.addDocument(docName);
                        System.out.println("Document '" + docName + "' added to the queue.");
                        break;
                    case 2: // Process Next Document
                        system.processNextDocument();
                        break;
                    case 3: // View Queue
                        system.viewQueue();
                        break;
                    case 4: // View History
                        system.viewHistory();
                        break;
                    case 0: // Exit
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number from the menu (0-4).");
                }
            } catch (InputMismatchException e) {
                // Handles non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // General catch-all for any other unexpected errors during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging in development
            }
            System.out.println(); // Add a newline for better readability between menu cycles
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed History");
        System.out.println("0. Exit");
    }
}
