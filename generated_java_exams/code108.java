/*
 * Exam Question #108
 * Generated on: 2025-05-11 22:15:28
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Seating Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system to manage attendees for an event with limited seating. The system needs to handle attendee registration, arrival, and seating based on arrival order.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Representation:** Create a class `Attendee` with a name and a status (e.g., "REGISTERED", "ARRIVED_WAITING", "SEATED", "UNABLE_TO_SEAT").
 * 2.  **Event Management:** Create a class `EventManager` that will manage the event.
 *     *   It must hold a `List` (specifically an `ArrayList`) of all *registered* attendees.
 *     *   It must hold a `Queue` of attendees who have *arrived* and are waiting to be seated.
 *     *   It must have a fixed maximum seat capacity.
 *     *   It must track the number of attendees currently seated.
 * 3.  **Functionality:** Implement the following operations within the `EventManager` or through its methods:
 *     *   **Register Attendee:** Add a new `Attendee` to the registered list. Prevent adding attendees with duplicate names (case-insensitive). Initial status is "REGISTERED".
 *     *   **Attendee Arrives:** An attendee with a given name arrives. Find them in the registered list. If found and not already arrived/seated, change their status to "ARRIVED_WAITING" and add them to the arrival `Queue`. If not found or already processed, report an error.
 *     *   **Seat Next Attendee:** Take the attendee at the front of the arrival `Queue`. If seats are available (current seated count < capacity), change their status to "SEATED", remove them from the queue, and increment the seated count. If no seats are available, change their status to "UNABLE_TO_SEAT" and remove them from the queue. If the queue is empty, report that there is no one waiting.
 *     *   **List All Attendees:** Display all registered attendees with their current status.
 *     *   **Display Event Status:** Show the total registered attendees, attendees waiting in the queue, current seated count, and remaining seats.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:** Use `Scanner` to provide a command-line menu for the user to select actions (Register, Arrive, Seat, List, Status, Exit). Use a `switch` statement to handle user input.
 * 5.  **Error Handling:**
 *     *   Use `System.err.println` for all error messages (e.g., attendee not found, duplicate registration, no seats, queue empty, invalid menu option, invalid input type).
 *     *   Implement class-wide exception handling (a `try-catch` block, likely around the main input loop) to catch general errors like `InputMismatchException` and prevent the program from crashing.
 *     *   Validate user input where necessary (e.g., non-empty names).
 * 6.  **Output:** Use `System.out.println` for all successful actions, menu prompts, and status displays.
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining complex parts.
 *     *   Ensure resources like `Scanner` are closed properly (or handled in a way that prevents resource leaks in a simple console app context).
 * 
 * **Execution:**
 * 
 * The program should start by asking for the maximum seat capacity. Then, it should present the menu of options repeatedly until the user chooses to exit.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Enter maximum seat capacity: 3
 * Event Management Menu:
 * 1. Register Attendee
 * 2. Attendee Arrives
 * 3. Seat Next Attendee
 * 4. List All Attendees
 * 5. Display Event Status
 * 6. Exit
 * Enter choice: 1
 * Enter attendee name: Alice
 * Attendee Alice registered.
 * 
 * Enter choice: 1
 * Enter attendee name: Bob
 * Attendee Bob registered.
 * 
 * Enter choice: 1
 * Enter attendee name: Charlie
 * Attendee Charlie registered.
 * 
 * Enter choice: 1
 * Enter attendee name: Alice
 * Error: Attendee with name 'Alice' is already registered.
 * 
 * Enter choice: 2
 * Enter attendee name: Bob
 * Attendee Bob arrived and is waiting to be seated.
 * 
 * Enter choice: 2
 * Enter attendee name: David
 * Error: Attendee 'David' not found in registered list.
 * 
 * Enter choice: 5
 * --- Event Status ---
 * Registered: 3
 * Waiting in Queue: 1
 * Seated: 0 / 3
 * Remaining Seats: 3
 * --------------------
 * 
 * Enter choice: 3
 * Seating Bob. Status: SEATED.
 * 
 * Enter choice: 5
 * --- Event Status ---
 * Registered: 3
 * Waiting in Queue: 0
 * Seated: 1 / 3
 * Remaining Seats: 2
 * --------------------
 * 
 * Enter choice: 2
 * Enter attendee name: Alice
 * Attendee Alice arrived and is waiting to be seated.
 * 
 * Enter choice: 2
 * Enter attendee name: Charlie
 * Attendee Charlie arrived and is waiting to be seated.
 * 
 * Enter choice: 5
 * --- Event Status ---
 * Registered: 3
 * Waiting in Queue: 2
 * Seated: 1 / 3
 * Remaining Seats: 2
 * --------------------
 * 
 * Enter choice: 3
 * Seating Alice. Status: SEATED.
 * 
 * Enter choice: 3
 * Seating Charlie. Status: SEATED.
 * 
 * Enter choice: 3
 * Error: No seats available. Charlie's status: UNABLE_TO_SEAT.
 * 
 * Enter choice: 5
 * --- Event Status ---
 * Registered: 3
 * Waiting in Queue: 0
 * Seated: 2 / 3
 * Remaining Seats: 1
 * --------------------
 * 
 * Enter choice: 3
 * Error: No attendees waiting in the queue.
 * 
 * Enter choice: 4
 * --- All Attendees ---
 * Name: Alice, Status: SEATED
 * Name: Bob, Status: SEATED
 * Name: Charlie, Status: UNABLE_TO_SEAT
 * ---------------------
 * 
 * Enter choice: 6
 * Exiting Event Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple event management system demonstrating the required Java concepts.
 * 
 * 1.  **`Attendee` Class:** This class encapsulates the data for an attendee (name and status) with appropriate getters and setters. It includes basic validation for the name and overrides `equals` and `hashCode` to allow for case-insensitive name comparison when checking for duplicates in the `ArrayList`.
 * 2.  **`EventManager` Class:**
 *     *   **Data Structures:**
 *         *   `private List<Attendee> registeredAttendees = new ArrayList<>();`: An `ArrayList` is used to store the master list of all attendees who have registered. It's declared using the `List` interface, demonstrating polymorphism.
 *         *   `private Queue<Attendee> arrivalQueue = new LinkedList<>();`: A `LinkedList` is used as the concrete implementation of the `Queue` interface. The `Queue` correctly models the first-in, first-out (FIFO) nature of attendees arriving and waiting to be seated.
 *     *   **State:** `maxSeatCapacity` and `seatedCount` track the seating situation.
 *     *   **Methods:**
 *         *   `registerAttendee(String name)`: Adds an attendee to the `registeredAttendees` list. It performs input validation (non-empty name) and checks for duplicates using the overridden `equals` method, printing errors to `System.err`.
 *         *   `attendeeArrives(String name)`: Finds the attendee in the `registeredAttendees` list. If found and in the correct status ("REGISTERED"), it changes their status to "ARRIVED_WAITING" and adds them to the `arrivalQueue` using `offer()`. Errors (not found, already processed) are printed to `System.err`.
 *         *   `seatNextAttendee()`: Uses `arrivalQueue.poll()` to retrieve and remove the next attendee from the front of the queue. It checks `seatedCount` against `maxSeatCapacity`. Based on seat availability, it updates the attendee's status to "SEATED" or "UNABLE_TO_SEAT" and increments `seatedCount` if seated. Error messages (queue empty, no seats) are printed to `System.err`.
 *         *   `listAllAttendees()`: Iterates through the `registeredAttendees` list and prints each attendee's details using `System.out`.
 *         *   `displayEventStatus()`: Prints summary information about the event state using `System.out`.
 *     *   **Main Method:**
 *         *   Initializes `Scanner` and gets the `maxSeatCapacity` from the user, including `try-catch` for `InputMismatchException` and `IllegalArgumentException` from the `EventManager` constructor.
 *         *   Enters a `while(running)` loop for the main application flow.
 *         *   Presents the menu using `System.out`.
 *         *   Reads the user's choice using `scanner.nextInt()`, handling `InputMismatchException` with a specific `try-catch` block and printing to `System.err`.
 *         *   A `switch` statement dispatches the execution based on the user's valid choice, calling the appropriate `EventManager` methods.
 *         *   The main `while` loop is wrapped in a larger `try-catch(Exception e)` block. This provides a class-wide safety net for any unexpected runtime errors, printing a generic error message to `System.err` and the stack trace.
 *         *   A `finally` block ensures the `Scanner` resource is closed when the program exits the `try` or `catch` blocks.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Effective use of `ArrayList` (`List`) for a dynamic collection of registered items and `Queue` (`LinkedList`) for managing items in a specific processing order (FIFO).
 * *   **Encapsulation:** Fields in `Attendee` and `EventManager` are private, accessed via public methods.
 * *   **Polymorphism:** Using the `List` interface for `registeredAttendees` while implementing with `ArrayList`.
 * *   **Control Flow:** Using `switch` for menu-driven input handling and `while` for the main application loop.
 * *   **Input/Output:** Using `Scanner` for user input, `System.out` for standard output, and `System.err` specifically for error reporting as required.
 * *   **Error Handling:** Implementing specific checks within methods (e.g., duplicate names, attendee not found, queue empty, seats full) and reporting via `System.err`. Using `try-catch` blocks for input validation (`InputMismatchException`) and a broader `try-catch` in the `main` method for unexpected exceptions, demonstrating class-wide handling.
 * *   **Object-Oriented Design:** Separating concerns into `Attendee` and `EventManager` classes.
 * *   **Resource Management:** Closing the `Scanner`.
 * 
 * This solution provides a robust structure for the problem, incorporating all required components and adhering to good programming practices, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an attendee with name and status
class Attendee {
    private String name;
    private String status; // e.g., "REGISTERED", "ARRIVED_WAITING", "SEATED", "UNABLE_TO_SEAT"

    public Attendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be empty.");
        }
        this.name = name.trim();
        this.status = "REGISTERED"; // Initial status
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Name: " + name + ", Status: " + status;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        // Compare names case-insensitively
        return name.equalsIgnoreCase(attendee.name);
    }

    @Override
    public int hashCode() {
        return name.toLowerCase().hashCode();
    }
}

// Manages the event, attendees, queue, and seating
class EventManager {
    private List<Attendee> registeredAttendees;
    private Queue<Attendee> arrivalQueue;
    private int maxSeatCapacity;
    private int seatedCount;

    public EventManager(int maxSeatCapacity) {
        if (maxSeatCapacity <= 0) {
            throw new IllegalArgumentException("Seat capacity must be positive.");
        }
        this.maxSeatCapacity = maxSeatCapacity;
        this.registeredAttendees = new ArrayList<>();
        this.arrivalQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.seatedCount = 0;
    }

    /**
     * Registers a new attendee.
     * @param name The name of the attendee.
     * @return true if registration was successful, false otherwise.
     */
    public boolean registerAttendee(String name) {
        try {
            Attendee newAttendee = new Attendee(name);
            // Check if attendee is already registered (case-insensitive name check)
            if (registeredAttendees.contains(newAttendee)) {
                System.err.println("Error: Attendee with name '" + name + "' is already registered.");
                return false;
            }
            registeredAttendees.add(newAttendee);
            System.out.println("Attendee " + newAttendee.getName() + " registered.");
            return true;
        } catch (IllegalArgumentException e) {
            System.err.println("Error during registration: " + e.getMessage());
            return false;
        }
    }

    /**
     * Handles the arrival of an attendee.
     * @param name The name of the arriving attendee.
     * @return true if arrival was processed successfully, false otherwise.
     */
    public boolean attendeeArrives(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return false;
        }

        // Find the attendee in the registered list
        Attendee arrivingAttendee = null;
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getName().equalsIgnoreCase(name.trim())) {
                arrivingAttendee = attendee;
                break;
            }
        }

        if (arrivingAttendee == null) {
            System.err.println("Error: Attendee '" + name.trim() + "' not found in registered list.");
            return false;
        }

        // Check if attendee has already arrived or been seated
        if (!arrivingAttendee.getStatus().equals("REGISTERED")) {
             System.err.println("Error: Attendee '" + name.trim() + "' has already arrived or been seated.");
             return false;
        }

        // Add to the arrival queue and update status
        arrivalQueue.offer(arrivingAttendee); // offer is safer than add, returns false on failure
        arrivingAttendee.setStatus("ARRIVED_WAITING");
        System.out.println("Attendee " + arrivingAttendee.getName() + " arrived and is waiting to be seated.");
        return true;
    }

    /**
     * Seats the next attendee from the arrival queue if seats are available.
     * @return true if an attendee was seated or processed (even if unable to seat), false if queue was empty.
     */
    public boolean seatNextAttendee() {
        Attendee nextToSeat = arrivalQueue.poll(); // Get and remove the head of the queue

        if (nextToSeat == null) {
            System.err.println("Error: No attendees waiting in the queue.");
            return false;
        }

        if (seatedCount < maxSeatCapacity) {
            nextToSeat.setStatus("SEATED");
            seatedCount++;
            System.out.println("Seating " + nextToSeat.getName() + ". Status: SEATED.");
        } else {
            nextToSeat.setStatus("UNABLE_TO_SEAT");
            System.err.println("Error: No seats available. " + nextToSeat.getName() + "'s status: UNABLE_TO_SEAT.");
        }
        return true;
    }

    /**
     * Displays all registered attendees and their current status.
     */
    public void listAllAttendees() {
        System.out.println("\n--- All Attendees ---");
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            for (Attendee attendee : registeredAttendees) {
                System.out.println(attendee);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays the current status of the event.
     */
    public void displayEventStatus() {
        System.out.println("\n--- Event Status ---");
        System.out.println("Registered: " + registeredAttendees.size());
        System.out.println("Waiting in Queue: " + arrivalQueue.size());
        System.out.println("Seated: " + seatedCount + " / " + maxSeatCapacity);
        System.out.println("Remaining Seats: " + (maxSeatCapacity - seatedCount));
        System.out.println("--------------------\n");
    }

    // Main method to run the simulation
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = null;
        boolean running = true;

        // Get seat capacity first
        while (eventManager == null) {
            System.out.print("Enter maximum seat capacity: ");
            try {
                int capacity = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over
                eventManager = new EventManager(capacity);
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for capacity.");
                scanner.nextLine(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                 System.err.println("Error: " + e.getMessage());
            }
        }

        // Main application loop with class-wide try-catch
        try {
            while (running) {
                System.out.println("Event Management Menu:");
                System.out.println("1. Register Attendee");
                System.out.println("2. Attendee Arrives");
                System.out.println("3. Seat Next Attendee");
                System.out.println("4. List All Attendees");
                System.out.println("5. Display Event Status");
                System.out.println("6. Exit");
                System.out.print("Enter choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter attendee name: ");
                        String regName = scanner.nextLine();
                        eventManager.registerAttendee(regName);
                        break;
                    case 2:
                        System.out.print("Enter attendee name: ");
                        String arriveName = scanner.nextLine();
                        eventManager.attendeeArrives(arriveName);
                        break;
                    case 3:
                        eventManager.seatNextAttendee();
                        break;
                    case 4:
                        eventManager.listAllAttendees();
                        break;
                    case 5:
                        eventManager.displayEventStatus();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Event Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Class-wide catch for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
             scanner.close(); // Ensure scanner is closed
        }
    }
}
