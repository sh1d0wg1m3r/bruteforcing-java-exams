/*
 * Exam Question #752
 * Generated on: 2025-05-12 16:35:46
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Support Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application for a support team. The system needs to manage incoming support tickets, assign them for processing, and keep a record of completed tickets. Tickets arrive and are placed in a queue, waiting to be addressed by available support agents.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold incoming support tickets waiting for processing.
 *     *   Use a `java.util.List` (implemented with `java.util.ArrayList`) to store tickets that have been processed and archived.
 *     *   Use a `java.util.List` (implemented with `java.util.ArrayList`) to maintain a list of available support agents.
 * 
 * 2.  **Classes:**
 *     *   Create a `Ticket` class with private fields for `id` (auto-generated unique integer), `description` (String), and `status` (String, e.g., "Pending", "Resolved"). Include a constructor, getters, and a method to set the status. Implement a meaningful `toString()` method.
 *     *   Create a simple `Agent` class with private fields for `id` (int) and `name` (String). Include a constructor, getters, and a `toString()` method.
 *     *   Create a `SupportSystem` class that encapsulates the data structures (Queue and Lists) and the main logic for managing tickets and agents.
 * 
 * 3.  **Functionality:**
 *     *   Initialize the `SupportSystem` with a few pre-defined `Agent` objects.
 *     *   Implement a command-line interface using `java.util.Scanner` to interact with the system.
 *     *   Present a menu of options to the user:
 *         1.  Add New Ticket
 *         2.  Process Next Ticket
 *         3.  View Ticket Queue
 *         4.  View Archived Tickets
 *         5.  View Available Agents
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   **Add New Ticket:** Prompt the user for a ticket description, create a new `Ticket` object with status "Pending", and add it to the incoming ticket queue.
 *     *   **Process Next Ticket:** If the queue is not empty, retrieve (and remove) the next ticket from the front of the queue. Change its status to "Resolved". Add the resolved ticket to the archived tickets list. Report which ticket was processed. If the queue is empty, report an error. (You can simplify agent assignment by just stating it was processed, no need for complex agent availability logic).
 *     *   **View Ticket Queue:** Display all tickets currently in the incoming queue without removing them.
 *     *   **View Archived Tickets:** Display all tickets in the archived list.
 *     *   **View Available Agents:** Display the list of agents.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling & Best Practices:**
 *     *   Use `System.out` for displaying the menu, successful operations, and viewing lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, queue is empty when trying to process).
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Handle `InputMismatchException` when reading input.
 *     *   Implement a "class-wide" or main application loop `try-catch` block to catch any unexpected runtime exceptions that might occur during program execution.
 *     *   Follow principles of encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex parts of the code.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested operations, printing status messages to `System.out` and errors to `System.err`.
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Ticket Queue
 * 4. View Archived Tickets
 * 5. View Available Agents
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * 
 * Ticket added: 1
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Ticket Queue ---
 * 1. Ticket [ID=1, Description='Printer not working', Status=Pending]
 * ----------------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing Ticket ID 1...
 * Ticket ID 1 resolved. Processed by Agent Alice
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Archived Tickets ---
 * 1. Ticket [ID=1, Description='Printer not working', Status=Resolved]
 * --------------------------
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List` interface.
 * *   Proper implementation of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Effective implementation of `try-catch` for both specific input errors and general runtime exceptions.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Clear and logical code structure.
 * *   Meaningful naming and basic commenting.
 * *   Correct implementation of menu options and core system logic.
 * *   Robustness in handling invalid input and edge cases (e.g., empty queue).
 *
 * EXPLANATION:
 * This solution implements a basic Support Ticket Management System demonstrating the required Java concepts and data structures.
 * 
 * 1.  **Classes (`Ticket`, `Agent`, `SupportSystem`):**
 *     *   `Ticket` and `Agent` are simple model classes following encapsulation principles with private fields and public getters. `Ticket` includes an auto-incrementing ID and a status field.
 *     *   `SupportSystem` is the main class orchestrating the system. It holds the core data structures and the methods for system operations.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `Queue<Ticket> incomingTickets`: A `LinkedList` is used to implement the `Queue` interface. This is appropriate because tickets are processed in a First-In, First-Out (FIFO) manner. `offer()` is used for adding and `poll()` for removing from the head.
 *     *   `List<Ticket> archivedTickets`: An `ArrayList` is used to implement the `List` interface. This stores processed tickets and allows easy iteration and storage of completed items.
 *     *   `List<Agent> availableAgents`: An `ArrayList` is used to implement the `List` interface. This holds the list of agents. While a simple list is sufficient for this problem's agent handling (just displaying them or picking the first one), `ArrayList` is a flexible choice for collections where elements are accessed by index or iterated over.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   `Scanner scanner = new Scanner(System.in);` is used in the `main` method to read user input from the console.
 *     *   A `while` loop keeps the program running until the user chooses to exit.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer menu choice. This is a clean way to handle multiple distinct options.
 *     *   `System.out.println()` is used for printing the menu, prompts, successful action messages, and the contents of the queues/lists.
 *     *   `System.err.println()` is used specifically for printing error messages, such as when the user enters invalid input or attempts an operation on an empty queue. Using `System.err` is a standard practice to distinguish error output from normal program output, which can be useful for redirection.
 * 
 * 4.  **Exception Handling (`try-catch`):**
 *     *   **Specific Input Handling:** A `try-catch(InputMismatchException e)` block is placed around `scanner.nextInt()` inside the main loop. This specifically catches cases where the user enters non-integer input for the menu choice. If caught, an error message is printed to `System.err`, the invalid input is consumed using `scanner.next()` to prevent an infinite loop, and `continue` skips to the next menu display.
 *     *   **Class-wide Handling:** A large `try-catch(Exception e)` block wraps the entire `while` loop in the `main` method. This serves as a general safety net to catch any unexpected runtime exceptions that might occur anywhere within the main program flow. It prints an error message to `System.err` and the stack trace using `e.printStackTrace()` for debugging.
 *     *   **Resource Management:** A `finally` block is used at the end of the main `try-catch` block to ensure that the `Scanner` object is closed, releasing the underlying system resource (`System.in`), regardless of whether the program exited normally or due to an exception.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Private fields in classes are accessed only through public methods (getters, setters).
 *     *   **Meaningful Names:** Variable names (`incomingTickets`, `archivedTickets`, `processNextTicket`) and method names are descriptive, improving code readability.
 *     *   **Input Validation:** Checks are performed for empty ticket descriptions and invalid menu numbers. `InputMismatchException` is handled.
 *     *   **Error Handling:** Specific and general exception handling is implemented, using `System.err` for error output.
 *     *   **Clean Structure:** The code is organized into logical classes, and the `main` method clearly separates the user interface logic from the core system operations delegated to the `SupportSystem` instance.
 * 
 * This solution effectively integrates all required components into a functional program that simulates a practical scenario, demonstrating a solid understanding of core Java data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class representing a support ticket
class Ticket {
    private static int nextId = 1; // Auto-generating ID
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Resolved"

    /**
     * Constructs a new Ticket.
     * @param description The description of the issue.
     */
    public Ticket(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = "Pending"; // New tickets are pending by default
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the ticket.
     * @param status The new status (e.g., "Resolved").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Class representing a support agent
class Agent {
    private int id;
    private String name;

    /**
     * Constructs a new Agent.
     * @param id The agent's unique ID.
     * @param name The agent's name.
     */
    public Agent(int id, String name) {
        this.id = id;
        this.name = name;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the Agent.
     */
    @Override
    public String toString() {
        return "Agent [ID=" + id + ", Name='" + name + "']";
    }
}

// Main class managing the support system
public class SupportSystem { // Renamed to SupportSystem as it holds the main logic

    // Using Queue for incoming tickets (FIFO)
    private Queue<Ticket> incomingTickets;
    // Using List (ArrayList) for archived tickets
    private List<Ticket> archivedTickets;
    // Using List (ArrayList) for available agents
    private List<Agent> availableAgents;

    /**
     * Constructs the SupportSystem, initializing data structures and agents.
     */
    public SupportSystem() {
        // LinkedList is a common implementation for Queue
        this.incomingTickets = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.archivedTickets = new ArrayList<>();
        this.availableAgents = new ArrayList<>();

        // Pre-populate with some agents
        availableAgents.add(new Agent(101, "Alice"));
        availableAgents.add(new Agent(102, "Bob"));
        availableAgents.add(new Agent(103, "Charlie"));
    }

    /**
     * Adds a new ticket to the incoming queue.
     * @param description The description of the new ticket.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }
        Ticket newTicket = new Ticket(description.trim());
        // offer() is preferred for queues as it handles capacity restricted queues (though LinkedList is not)
        incomingTickets.offer(newTicket);
        System.out.println("Ticket added: " + newTicket.getId());
    }

    /**
     * Processes the next ticket in the queue.
     * Removes the ticket from the queue, marks it as resolved, and archives it.
     */
    public void processNextTicket() {
        // Check if the queue is empty before attempting to poll
        if (incomingTickets.isEmpty()) {
            System.err.println("No tickets in the queue to process.");
            return;
        }

        // poll() retrieves and removes the head of the queue, returns null if empty (checked above)
        Ticket ticketToProcess = incomingTickets.poll();
        ticketToProcess.setStatus("Resolved"); // Update status

        // Simulate assigning to an agent (pick the first one for simplicity)
        Agent processingAgent = null;
        if (!availableAgents.isEmpty()) {
             processingAgent = availableAgents.get(0);
        }

        System.out.println("Processing Ticket ID " + ticketToProcess.getId() + "...");

        // Add the resolved ticket to the archived list
        archivedTickets.add(ticketToProcess);

        System.out.println("Ticket ID " + ticketToProcess.getId() + " resolved." +
                           (processingAgent != null ? " Processed by Agent " + processingAgent.getName() : ""));
    }

    /**
     * Displays all tickets currently in the incoming queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Ticket Queue ---");
        if (incomingTickets.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            // Create a temporary list to easily iterate with index
            List<Ticket> queueList = new ArrayList<>(incomingTickets);
            for (int i = 0; i < queueList.size(); i++) {
                 System.out.println((i + 1) + ". " + queueList.get(i));
            }
        }
        System.out.println("----------------------------");
    }

    /**
     * Displays all tickets in the archived list.
     */
    public void viewArchivedTickets() {
        System.out.println("\n--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("No tickets have been archived yet.");
        } else {
            for (int i = 0; i < archivedTickets.size(); i++) {
                 System.out.println((i + 1) + ". " + archivedTickets.get(i));
            }
        }
        System.out.println("--------------------------");
    }

     /**
     * Displays all available agents.
     */
    public void viewAgents() {
        System.out.println("\n--- Available Agents ---");
        if (availableAgents.isEmpty()) {
            System.out.println("No agents available.");
        } else {
            for (int i = 0; i < availableAgents.size(); i++) {
                 System.out.println((i + 1) + ". " + availableAgents.get(i));
            }
        }
        System.out.println("------------------------");
    }


    /**
     * Main method to run the Support Ticket System.
     * Handles user interaction and menu navigation.
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem(); // Instantiate the system
        boolean running = true;

        // Class-wide try-catch block to handle unexpected runtime errors
        try {
            while (running) {
                // Display menu using System.out
                System.out.println("\n--- Support Ticket System Menu ---");
                System.out.println("1. Add New Ticket");
                System.out.println("2. Process Next Ticket");
                System.out.println("3. View Ticket Queue");
                System.out.println("4. View Archived Tickets");
                System.out.println("5. View Available Agents");
                System.out.println("6. Exit");
                System.out.print("Enter your choice: ");

                int choice = -1;
                // Specific try-catch for handling non-integer input
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Use System.err for input validation errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                } finally {
                     // This finally block is not strictly necessary here but shows usage.
                     // Putting scanner.close() here would close it too early.
                }

                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        system.addTicket(description);
                        break;
                    case 2:
                        system.processNextTicket();
                        break;
                    case 3:
                        system.viewQueue();
                        break;
                    case 4:
                        system.viewArchivedTickets();
                        break;
                    case 5:
                        system.viewAgents();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Use System.err for invalid menu options
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the program's main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Print the stack trace for debugging purposes
            e.printStackTrace();
        } finally {
             // Ensure the scanner resource is closed properly when the program finishes
             if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed."); // Indicate scanner was closed
             }
        }
    }
}
