/*
 * Exam Question #382
 * Generated on: 2025-05-11 23:02:53
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Objective:** Design and implement a simplified Hospital Appointment Management System. This system will allow registering patients and scheduling appointments, managing pending appointment requests, and processing them. You must demonstrate proficiency in using core Java collections, input/output, control flow, and exception handling.
 * 
 * **Scenario:** You are developing a basic command-line interface for a hospital's appointment desk. The system needs to maintain a list of registered patients and a queue of appointment requests that are waiting to be assigned to a doctor (for simplicity, we just process them from the queue).
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Management:**
 *     *   Maintain a list of registered patients. Each patient should have a unique ID (simple integer, auto-incrementing) and a name.
 *     *   Allow adding new patients.
 *     *   Allow viewing all registered patients.
 * 2.  **Appointment Request Management:**
 *     *   Maintain a queue of appointment requests.
 *     *   Each appointment request should include the patient's ID and the reason for the appointment.
 *     *   Allow scheduling a new appointment request by providing a patient ID and reason. The system must validate that the patient ID exists.
 *     *   Allow viewing all pending appointment requests in the queue.
 *     *   Allow processing the next appointment request from the queue (dequeue operation).
 * 3.  **User Interface:**
 *     *   Provide a command-line menu interface using `Scanner` for user interaction.
 *     *   The menu should offer options for:
 *         *   Add New Patient
 *         *   Schedule Appointment
 *         *   View All Patients
 *         *   View Pending Appointments
 *         *   Process Next Appointment
 *         *   Exit
 * 4.  **Technical Requirements:**
 *     *   You *must* use `java.util.Queue` to manage pending appointment requests.
 *     *   You *must* use `java.util.ArrayList` to store the list of patients.
 *     *   You *must* declare the patient list using the `java.util.List` interface type (e.g., `List<Patient> patients = new ArrayList<>();`).
 *     *   You *must* use `java.util.Scanner` for all user input.
 *     *   You *must* use a `switch` statement to handle the different menu options.
 *     *   You *must* use `System.err.println()` to output all error messages (e.g., invalid input, patient not found).
 *     *   You *must* use `System.out.println()` for the menu, prompts, and all successful operation outputs.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues (e.g., non-integer input when expecting an integer, or potential errors during operations). The main application loop should have a broad `try-catch` to prevent crashes.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Implement input validation (e.g., checking for valid patient ID when scheduling).
 *     *   Implement proper error handling as specified.
 *     *   Maintain a clean and organized code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user input. Examples:
 * 
 * *   Adding a patient: Prompt for name, confirm addition with ID.
 * *   Viewing patients: List all patients with ID and name.
 * *   Scheduling appointment: Prompt for patient ID and reason. Validate ID. Confirm scheduling. If ID is invalid, print error to `System.err`.
 * *   Viewing queue: List all pending appointment requests (patient ID, reason). Indicate if the queue is empty.
 * *   Processing appointment: Remove and display the next request. Indicate if the queue is empty.
 * *   Invalid menu choice or input: Print error to `System.err`.
 * *   Unexpected errors: Catch in the main loop and print a generic error message to `System.err`.
 * 
 * **Deliverables:**
 * 
 * Submit a single `.java` file containing the complete solution code.
 * 
 * **Time Limit:** 45-60 minutes.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` class: Simple POJO (Plain Old Java Object) with private fields (`id`, `name`) and public getter methods, demonstrating encapsulation. Includes a `toString()` method for easy printing.
 *     *   `AppointmentRequest` class: Similar simple POJO with private fields (`patientId`, `reason`) and public getters, also demonstrating encapsulation. Includes a `toString()` method.
 *     *   `HospitalScheduler` class: The main class containing the application logic. It holds the data structures (`patients` list and `pendingAppointments` queue) and the operational methods (`addNewPatient`, `scheduleAppointment`, etc.).
 * 
 * 2.  **Data Structures:**
 *     *   `List<Patient> patients = new ArrayList<>();`: An `ArrayList` is used to store the `Patient` objects. It's declared using the `List` interface, which is a best practice for flexibility. `ArrayList` is suitable here as we primarily add patients and iterate through them; random access by index isn't heavily used, but iteration is efficient.
 *     *   `Queue<AppointmentRequest> pendingAppointments = new LinkedList<>();`: A `LinkedList` is used, but it's declared using the `Queue` interface. `LinkedList` implements `Queue` and provides efficient `offer()` (add to end) and `poll()` (remove from front) operations, which are characteristic of a queue (FIFO - First-In, First-Out). This perfectly models a waiting list for appointment requests.
 * 
 * 3.  **Input and Output:**
 *     *   `Scanner scanner = new Scanner(System.in);`: A `Scanner` object is used to read user input from the console (`System.in`). It's a class-level field and initialized in the constructor.
 *     *   `System.out.println()`: Used for displaying the menu, prompts, confirmation messages, and lists of patients/appointments.
 *     *   `System.err.println()`: Used specifically for displaying error messages, such as invalid menu choices, non-integer input, or when a patient ID is not found during scheduling. This is a good practice to separate normal output from error streams.
 * 
 * 4.  **Control Flow:**
 *     *   `switch (choice)`: A `switch` statement in the `run()` method is used to direct the program flow based on the user's menu selection. Each case calls the corresponding private method to perform the action.
 *     *   `do...while (choice != 6)`: The main application loop continues until the user chooses option 6 (Exit).
 * 
 * 5.  **Exception Handling:**
 *     *   Specific `try-catch` blocks are used around operations that might throw predictable exceptions, such as parsing integer input (`InputMismatchException` when reading `choice` or `patientId`).
 *     *   A broader `try-catch (Exception e)` block is included inside the `do-while` loop's processing block. This catches any other unexpected runtime exceptions that might occur during the execution of the chosen action (e.g., a `NullPointerException` if logic errors existed, although less likely in this simple implementation). This prevents a single faulty operation from crashing the entire application loop.
 *     *   A final, outermost `try-catch (Exception mainException)` block wraps the entire `do-while` loop within the `run()` method. This serves as a class-wide safety net, ensuring that even if an exception escapes the inner handling, the program can print a critical error message to `System.err` before potentially terminating, rather than crashing silently or with a default stack trace.
 *     *   A `finally` block is used to ensure the `Scanner` resource is closed when the application exits or encounters a critical error.
 * 
 * 6.  **Methods and Encapsulation:**
 *     *   The `HospitalScheduler` class contains private methods (`displayMenu`, `addNewPatient`, `scheduleAppointment`, etc.) that perform specific tasks. This promotes modularity and encapsulation, hiding the internal implementation details from the outside. The `run()` method is public as it's the entry point for starting the scheduler.
 *     *   `isPatientExist(int id)` is a helper method demonstrating a simple search within the `ArrayList`.
 * 
 * 7.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Achieved through private fields and public methods/getters in `Patient` and `AppointmentRequest`, and private helper methods in `HospitalScheduler`.
 *     *   **Naming:** Variable names (`patients`, `pendingAppointments`, `nextPatientId`, `reason`, `patientId`) and method names (`addNewPatient`, `scheduleAppointment`, `processNextAppointment`) are descriptive.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific code sections.
 *     *   **Input Validation:** Checks are performed for empty patient names/reasons and, crucially, validates if a patient ID exists before scheduling an appointment. `InputMismatchException` handling validates integer input.
 *     *   **Error Handling:** As detailed in point 5, multiple layers of `try-catch` and specific `System.err` usage handle various error scenarios.
 *     *   **Clean Code Structure:** The code is divided into logical classes and methods, making it readable and maintainable.
 * 
 * This solution effectively uses all the required components in a cohesive, practical scenario, demonstrating key Java programming concepts like data structures, control flow, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private int id;
    private String name;

    /**
     * Constructs a new Patient.
     * @param id The unique patient ID.
     * @param name The patient's name.
     */
    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * Gets the patient's ID.
     * @return The patient ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the patient's name.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

/**
 * Represents a request for an appointment.
 */
class AppointmentRequest {
    private int patientId;
    private String reason;

    /**
     * Constructs a new AppointmentRequest.
     * @param patientId The ID of the patient requesting the appointment.
     * @param reason The reason for the appointment.
     */
    public AppointmentRequest(int patientId, String reason) {
        this.patientId = patientId;
        this.reason = reason;
    }

    /**
     * Gets the ID of the patient associated with this request.
     * @return The patient ID.
     */
    public int getPatientId() {
        return patientId;
    }

    /**
     * Gets the reason for the appointment.
     * @return The appointment reason.
     */
    public String getReason() {
        return reason;
    }

    @Override
    public String toString() {
        return "Appointment Request [Patient ID=" + patientId + ", Reason=" + reason + "]";
    }
}

/**
 * Main class for the Hospital Appointment Management System.
 * Manages patients and a queue of appointment requests.
 */
public class HospitalScheduler {

    // Use List interface type for ArrayList
    private List<Patient> patients;
    // Use Queue interface type for LinkedList
    private Queue<AppointmentRequest> pendingAppointments;
    private int nextPatientId;
    private Scanner scanner;

    /**
     * Constructs a new HospitalScheduler.
     * Initializes patient list, appointment queue, and scanner.
     */
    public HospitalScheduler() {
        patients = new ArrayList<>(); // ArrayList stores patients
        pendingAppointments = new LinkedList<>(); // LinkedList implements Queue for requests
        nextPatientId = 1; // Start patient IDs from 1
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System ---");
        System.out.println("1. Add New Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. View All Patients");
        System.out.println("4. View Pending Appointments");
        System.out.println("5. Process Next Appointment");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the system.
     */
    private void addNewPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }
        Patient newPatient = new Patient(nextPatientId++, name.trim());
        patients.add(newPatient);
        System.out.println("Patient added: " + newPatient);
    }

    /**
     * Schedules a new appointment request.
     * Validates patient ID before adding to the queue.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient ID: ");
        try {
            int patientId = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over

            // Validate patient ID
            if (!isPatientExist(patientId)) {
                System.err.println("Error: Patient with ID " + patientId + " not found.");
                return;
            }

            System.out.print("Enter reason for appointment: ");
            String reason = scanner.nextLine();
             if (reason == null || reason.trim().isEmpty()) {
                 System.err.println("Error: Appointment reason cannot be empty.");
                 return;
            }

            AppointmentRequest request = new AppointmentRequest(patientId, reason.trim());
            pendingAppointments.offer(request); // offer is preferred over add for queues
            System.out.println("Appointment request scheduled for patient ID " + patientId);

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a valid integer for patient ID.");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    /**
     * Checks if a patient with the given ID exists in the system.
     * @param id The patient ID to check.
     * @return true if the patient exists, false otherwise.
     */
    private boolean isPatientExist(int id) {
        for (Patient patient : patients) {
            if (patient.getId() == id) {
                return true;
            }
        }
        return false;
    }

    /**
     * Views all registered patients.
     */
    private void viewAllPatients() {
        System.out.println("\n--- Registered Patients ---");
        if (patients.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            for (Patient patient : patients) {
                System.out.println(patient);
            }
        }
    }

    /**
     * Views all pending appointment requests in the queue.
     */
    private void viewPendingAppointments() {
        System.out.println("\n--- Pending Appointment Requests ---");
        if (pendingAppointments.isEmpty()) {
            System.out.println("No pending appointment requests.");
        } else {
            // Iterate without removing elements
            pendingAppointments.forEach(System.out::println);
        }
    }

    /**
     * Processes the next appointment request from the queue.
     */
    private void processNextAppointment() {
        System.out.println("\n--- Processing Next Appointment ---");
        AppointmentRequest nextRequest = pendingAppointments.poll(); // Retrieves and removes the head of the queue
        if (nextRequest == null) {
            System.out.println("No pending appointment requests to process.");
        } else {
            System.out.println("Processing: " + nextRequest);
            // In a real system, this would involve assigning a doctor, setting time, etc.
            // For this simulation, we just acknowledge processing.
            System.out.println("Appointment processed for patient ID " + nextRequest.getPatientId());
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice;
        // Class-wide exception handling for the main loop
        try {
            do {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addNewPatient();
                            break;
                        case 2:
                            scheduleAppointment();
                            break;
                        case 3:
                            viewAllPatients();
                            break;
                        case 4:
                            viewPendingAppointments();
                            break;
                        case 5:
                            processNextAppointment();
                            break;
                        case 6:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a valid integer for menu choice.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = 0; // Set choice to 0 to continue loop
                } catch (Exception e) {
                     // Catch any other unexpected exceptions within the loop operations
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     // e.printStackTrace(); // Uncomment for detailed debugging
                     choice = 0; // Set choice to 0 to continue loop
                }

            } while (choice != 6);
        } catch (Exception mainException) {
            // This catches any exceptions that might escape the inner try-catch,
            // providing a final safety net before the program terminates unexpectedly.
             System.err.println("A critical system error occurred: " + mainException.getMessage());
             // mainException.printStackTrace(); // Uncomment for detailed debugging
        } finally {
             // Ensure scanner is closed
             if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
             }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler app = new HospitalScheduler();
        app.run();
    }
}
