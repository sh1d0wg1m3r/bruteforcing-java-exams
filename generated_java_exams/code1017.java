/*
 * Exam Question #1017
 * Generated on: 2025-05-12 17:13:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified task management system for a small team. The system should allow managing tasks that need to be done, assigning them to team members, and marking them as complete. Tasks are initially placed in a queue awaiting assignment.
 * 
 * **Requirements:**
 * 
 * Implement a Java console application that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with fields for a unique ID, description, status (e.g., PENDING, ASSIGNED, COMPLETE), and the ID of the assigned team member (if any). Tasks should be automatically assigned unique IDs upon creation.
 * 2.  **Team Member Representation:** Create a `TeamMember` class with fields for a unique ID and name. Team members should be automatically assigned unique IDs upon creation.
 * 3.  **Data Storage:**
 *     *   Maintain a queue of tasks that are currently awaiting assignment.
 *     *   Maintain a list of all team members.
 *     *   Maintain a list of *all* tasks ever created, regardless of their current status or assignment, to allow lookup by ID for completion.
 * 4.  **Functionality (Console Menu):** The application should present a menu with the following options:
 *     *   `1. Add New Task`: Prompt the user for a task description and add a new `PENDING` task to the queue and the master task list.
 *     *   `2. List All Tasks`: Display details of all tasks in the system (from the master list), including their ID, description, status, and assigned member ID (if applicable). Also, specifically list tasks currently in the assignment queue.
 *     *   `3. List Team Members`: Display details of all team members (ID and name).
 *     *   `4. Assign Task from Queue`: Take the next task from the assignment queue, prompt the user to enter the ID of a team member, and mark the task as `ASSIGNED` to that member. If the queue is empty or the member ID is invalid, report an error.
 *     *   `5. Mark Task Complete`: Prompt the user for a Task ID and the Member ID who completed it. Find the task in the master list. If the task exists, is currently `ASSIGNED` to the specified member, mark its status as `COMPLETE`. Otherwise, report an error.
 *     *   `6. Exit`: Terminate the application.
 * 5.  **Technical Constraints:** Your solution **must** use **ALL** of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu flow control
 *     *   `System.err` for error messages (e.g., invalid input, task/member not found, empty queue)
 *     *   `System.out` for normal output (menu, lists, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks around the main application loop to catch unexpected errors, in addition to specific input validation catches.
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments explaining key logic.
 *     *   Implement robust input validation (e.g., handling non-integer input for IDs, empty task descriptions).
 *     *   Provide clear error messages using `System.err`.
 *     *   Structure the code cleanly with separate classes and methods for different functionalities.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and interact with the user via the console. Successful operations should print informative messages to `System.out`. Errors (like invalid menu choices, non-existent IDs, trying to assign from an empty queue) should print clear messages to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. List All Tasks
 * 3. List Team Members
 * 4. Assign Task from Queue
 * 5. Mark Task Complete
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Task added to queue: 1
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Team Members ---
 * Member ID: 1, Name: Alice
 * Member ID: 2, Name: Bob
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Next task in queue: Task ID: 1, Description: "Implement login feature", Status: PENDING
 * --- Team Members ---
 * Member ID: 1, Name: Alice
 * Member ID: 2, Name: Bob
 * Enter Member ID to assign this task: 1
 * Task ID 1 assigned to Alice (Member ID: 1).
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: "Implement login feature", Status: ASSIGNED (Assigned to Member ID: 1)
 * --- Tasks in Queue (Pending Assignment) ---
 * Task queue is empty.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Enter Task ID to mark as complete: 1
 * Enter Member ID who completed the task: 1
 * Task ID 1 marked as complete by Alice.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Management System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements the `Task Management System` as requested, demonstrating the use of all required Java components and adhering to best practices.
 * 
 * 1.  **Overall Structure:**
 *     *   The system is organized into three classes: `Task`, `TeamMember`, and `TaskManagementSystem`.
 *     *   `Task` and `TeamMember` are simple data classes with unique ID generation and basic fields.
 *     *   `TaskManagementSystem` is the main class orchestrating the application logic, holding the data structures and implementing the menu-driven interface.
 *     *   The `main` method in `TaskManagementSystem` creates an instance of the system and calls its `run` method.
 *     *   The `run` method contains the main application loop, displaying the menu and processing user input.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   **`java.util.Queue`:** The `taskQueue` is declared as `Queue<Task>` and instantiated using `new LinkedList<>()`. It is used to store tasks that are waiting to be assigned (`offer` to add, `peek` to view the next, `poll` to remove).
 *     *   **`java.util.ArrayList`:** The `teamMembers` and `allTasks` are instantiated using `new ArrayList<>()`. `ArrayList` is chosen for its dynamic resizing and efficient element access by index or iteration, suitable for storing lists of members and a master list of tasks where elements are often iterated or searched.
 *     *   **`java.util.List` interface:** The variables `teamMembers` and `allTasks` are declared using the `List` interface type (`List<TeamMember>`, `List<Task>`). This is a best practice, programming to the interface rather than the concrete implementation (`ArrayList`), allowing for easier switching of list implementations later if needed.
 *     *   **`java.util.Scanner`:** A `Scanner` object is created (`scanner`) to read user input from `System.in`. `scanner.nextLine()` is used to read entire lines, which is then parsed (if needed) to avoid issues with leftover newline characters from methods like `nextInt()`.
 *     *   **`switch` statement:** The `switch` statement in the `run` method is used to control the flow of the application based on the user's integer menu choice, directing execution to the appropriate method (`addTask`, `listAllTasks`, etc.).
 *     *   **`System.err`:** Used throughout the code to print error messages to the standard error stream. This includes messages for invalid menu choices, `NumberFormatException` during input parsing, tasks or members not found, empty queue errors, and validation failures (e.g., trying to complete a task not assigned to the member).
 *     *   **`System.out`:** Used for all normal output, such as displaying the menu, success messages after actions, and listing tasks and team members.
 *     *   **Class-wide `try-catch` blocks:** The main `while` loop in the `run` method is wrapped in a `try-catch(Exception e)`. This serves as a class-wide handler for any unexpected runtime exceptions that might occur within the loop, preventing the program from crashing abruptly. Specific input parsing errors (`NumberFormatException`) are caught within the main `try` block, closer to where they occur. Error conditions related to data state (empty queue, non-existent IDs) are handled with `if` checks and `System.err` messages within the respective methods.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TeamMember` are `private`. Public getter methods are provided to access data. State-changing operations (like `assignTo`, `complete` in `Task`) are handled by public methods rather than exposing fields directly. Data structures in `TaskManagementSystem` are also private.
 *     *   **Meaningful Names:** Class names (`Task`, `TeamMember`, `TaskManagementSystem`), variable names (`taskQueue`, `teamMembers`, `description`, `assignedMemberId`), method names (`addTask`, `findMemberById`, `markTaskComplete`), and enum values (`PENDING`, `ASSIGNED`, `COMPLETE`) are descriptive and clearly indicate their purpose.
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, fields, and key logic sections. Javadoc comments are used for class and method summaries.
 *     *   **Input Validation:** Checks are performed for empty task descriptions. `NumberFormatException` is caught when parsing user input for menu choices or IDs. Checks are made to ensure entered Task IDs and Member IDs correspond to existing objects before proceeding with operations like assignment or completion.
 *     *   **Error Handling:** Specific error conditions are identified (e.g., queue empty, ID not found, invalid task status for completion) and reported using `System.err` with informative messages. The `try-catch` blocks handle parsing errors and unexpected exceptions.
 *     *   **Clean Code Structure:** Functionality is divided into logical methods (`addTask`, `assignTask`, etc.). Helper methods (`findMemberById`, `findTaskById`) encapsulate searching logic. The `Task` and `TeamMember` classes manage their own data and state.
 * 
 * 4.  **Logic Flow:**
 *     *   Tasks are added to *both* the `taskQueue` (for pending assignment) and the `allTasks` list (for general lookup).
 *     *   Assigning a task involves taking it *from* the `taskQueue` using `poll()` and updating its status and assigned member ID.
 *     *   Listing tasks iterates through the `allTasks` list to show everything, and separately iterates through the `taskQueue` (without removing elements) to show what's pending.
 *     *   Marking a task complete requires finding the task in the `allTasks` list by ID and verifying its current status and assigned member before changing its status.
 * 
 * 5.  **Error Handling Implementation:**
 *     *   Input reading uses `scanner.nextLine()` followed by `Integer.parseInt()`. This pattern is safer than `scanner.nextInt()` as it consumes the entire line, preventing newline characters from interfering with subsequent `nextLine()` calls. The `NumberFormatException` catch handles non-integer input gracefully.
 *     *   Specific business logic errors (e.g., attempting to assign from an empty queue, providing a non-existent member ID, trying to complete a task not assigned to the given member) are checked using `if` statements, and error messages are printed to `System.err`.
 *     *   The top-level `try-catch(Exception e)` in `run()` provides a safety net for any unforeseen runtime errors, printing a general error message and the stack trace for debugging. The `finally` block ensures resources like the `Scanner` are closed.
 * 
 * This solution effectively utilizes the required Java components within a practical scenario, demonstrating key programming concepts like object-oriented design, data structures, input/output, control flow, and exception handling as requested.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly needed with nextLine() + parseInt, good to know

// Class to represent a Task
class Task {
    private static int nextTaskId = 1;
    private int id;
    private String description;
    private TaskStatus status;
    private int assignedMemberId; // 0 indicates not assigned

    // Enum for task status
    public enum TaskStatus {
        PENDING, ASSIGNED, COMPLETE
    }

    /**
     * Constructor for creating a new task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextTaskId++;
        this.description = description;
        this.status = TaskStatus.PENDING;
        this.assignedMemberId = 0; // Default to 0 (not assigned)
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public int getAssignedMemberId() {
        return assignedMemberId;
    }

    // --- State Change Methods ---
    /**
     * Marks the task as assigned to a specific member.
     * @param memberId The ID of the member the task is assigned to.
     */
    public void assignTo(int memberId) {
        this.assignedMemberId = memberId;
        this.status = TaskStatus.ASSIGNED;
    }

    /**
     * Marks the task as complete.
     */
    public void complete() {
        this.status = TaskStatus.COMPLETE;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string showing task details.
     */
    @Override
    public String toString() {
        String memberInfo = (status == TaskStatus.ASSIGNED || status == TaskStatus.COMPLETE)
                ? " (Assigned to Member ID: " + assignedMemberId + ")" : "";
        return "Task ID: " + id + ", Description: \"" + description + "\", Status: " + status + memberInfo;
    }
}

// Class to represent a Team Member
class TeamMember {
    private static int nextMemberId = 1;
    private int id;
    private String name;

    /**
     * Constructor for creating a new team member.
     * @param name The name of the team member.
     */
    public TeamMember(String name) {
        this.id = nextMemberId++;
        this.name = name;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the team member.
     * @return A formatted string showing member details.
     */
    @Override
    public String toString() {
        return "Member ID: " + id + ", Name: " + name;
    }
}

// Main class for the Task Management System
public class TaskManagementSystem {

    // Data structures
    private Queue<Task> taskQueue = new LinkedList<>(); // Queue for tasks awaiting assignment
    private List<TeamMember> teamMembers = new ArrayList<>(); // List of all team members
    private List<Task> allTasks = new ArrayList<>(); // Master list of all tasks created

    private Scanner scanner = new Scanner(System.in); // Scanner for user input

    /**
     * Constructor to initialize the system with some dummy data.
     */
    public TaskManagementSystem() {
        // Add some initial team members
        teamMembers.add(new TeamMember("Alice"));
        teamMembers.add(new TeamMember("Bob"));
        teamMembers.add(new TeamMember("Charlie"));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. List All Tasks");
        System.out.println("3. List Team Members");
        System.out.println("4. Assign Task from Queue");
        System.out.println("5. Mark Task Complete");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the process of adding a new task.
     * Prompts for description, creates task, adds to queue and master list.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if input is invalid
        }

        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // Add to the end of the queue
        allTasks.add(newTask); // Add to the master list
        System.out.println("Task added to queue with ID: " + newTask.getId());
    }

    /**
     * Lists all tasks in the system and highlights tasks currently in the queue.
     */
    private void listAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks available in the system.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }

        System.out.println("\n--- Tasks in Queue (Pending Assignment) ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty.");
        } else {
            // Iterate over the queue without removing elements (using for-each or iterator)
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Lists all team members registered in the system.
     */
    private void listTeamMembers() {
        System.out.println("\n--- Team Members ---");
        if (teamMembers.isEmpty()) {
            System.out.println("No team members available.");
        } else {
            for (TeamMember member : teamMembers) {
                System.out.println(member);
            }
        }
    }

    /**
     * Assigns the next task from the queue to a selected team member.
     */
    private void assignTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. Cannot assign tasks.");
            return;
        }

        // Peek at the next task to inform the user, but don't remove yet
        Task taskToAssign = taskQueue.peek();
        System.out.println("Next task in queue: " + taskToAssign);

        listTeamMembers(); // Show members for selection

        System.out.print("Enter Member ID to assign this task: ");
        try {
            // Read input as line and parse to handle potential non-integer input safely
            int memberId = Integer.parseInt(scanner.nextLine());

            TeamMember member = findMemberById(memberId);

            if (member == null) {
                System.err.println("Error: Member with ID " + memberId + " not found.");
                return;
            }

            // If member is found, proceed with assignment
            taskQueue.poll(); // Remove the task from the queue
            taskToAssign.assignTo(memberId); // Update task status and assigned member ID
            System.out.println("Task ID " + taskToAssign.getId() + " assigned to " + member.getName() + " (Member ID: " + member.getId() + ").");

        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a valid integer for Member ID.");
        }
    }

    /**
     * Marks a specific task as complete by a specific member.
     */
    private void markTaskComplete() {
        System.out.print("Enter Task ID to mark as complete: ");
        try {
            int taskId = Integer.parseInt(scanner.nextLine());

            System.out.print("Enter Member ID who completed the task: ");
            int memberId = Integer.parseInt(scanner.nextLine());

            Task task = findTaskById(taskId);
            TeamMember member = findMemberById(memberId);

            if (task == null) {
                System.err.println("Error: Task with ID " + taskId + " not found.");
                return;
            }
            if (member == null) {
                 System.err.println("Error: Member with ID " + memberId + " not found.");
                 return;
            }

            // Validate if the task is assigned to this member and is not already complete
            if (task.getStatus() != Task.TaskStatus.ASSIGNED || task.getAssignedMemberId() != memberId) {
                System.err.println("Error: Task ID " + taskId + " is not currently assigned to Member ID " + memberId + ", or it's already completed/pending.");
                return;
            }

            task.complete(); // Mark the task as complete
            System.out.println("Task ID " + taskId + " marked as complete by " + member.getName() + ".");

        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter valid integers for Task ID and Member ID.");
        }
    }

    /**
     * Helper method to find a team member by their ID.
     * @param memberId The ID to search for.
     * @return The TeamMember object if found, null otherwise.
     */
    private TeamMember findMemberById(int memberId) {
        for (TeamMember member : teamMembers) {
            if (member.getId() == memberId) {
                return member;
            }
        }
        return null; // Member not found
    }

    /**
     * Helper method to find a task by its ID from the master list.
     * @param taskId The ID to search for.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        // Search the master list of all tasks
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * The main method to run the task management system application.
     * Contains the main menu loop and class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        // Use a class-wide try-catch around the main operational loop
        try {
            while (choice != 6) {
                displayMenu();
                String input = scanner.nextLine(); // Read the entire line of input

                try {
                    choice = Integer.parseInt(input); // Attempt to parse the input as an integer

                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            listAllTasks();
                            break;
                        case 3:
                            listTeamMembers();
                            break;
                        case 4:
                            assignTask();
                            break;
                        case 5:
                            markTaskComplete();
                            break;
                        case 6:
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (NumberFormatException e) {
                    // Handle cases where input is not a valid integer
                    System.err.println("Invalid input. Please enter a number.");
                    choice = 0; // Reset choice to prevent exiting or executing unintended options
                }
                // No catch for specific errors here, as they are handled within methods
                // The outer catch will handle any other unexpected runtime exceptions
            }
        } catch (Exception e) {
            // Class-wide catch block for any unexpected exceptions during execution
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
