/*
 * Exam Question #577
 * Generated on: 2025-05-12 16:09:48
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Industrial Robot Task Scheduler**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a single industrial robot. The robot processes tasks in the order they are received (First-In, First-Out). The system needs to allow users to add new tasks, command the robot to process the next task in the queue, view the list of pending tasks, and view the list of tasks that have been completed.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts, including data structures, object-oriented programming, input/output, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single robot task. It should have:
 *     *   A unique integer `taskId`.
 *     *   A `String` `description` of the task (e.g., "Move arm to position A", "Weld part X").
 *     *   A boolean flag `isCompleted`.
 *     *   Proper encapsulation (private fields, public getters).
 *     *   A constructor to initialize a task with a description. Task IDs should be automatically generated and unique for each new task.
 *     *   A method `markAsCompleted()` to set the `isCompleted` flag.
 *     *   An appropriate `toString()` method for easy printing of task details.
 * 
 * 2.  **Scheduler Logic:** Create a `RobotScheduler` class to manage the task flow. It should contain:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed (the task queue).
 *     *   A `List<Task>` to hold tasks that have been completed.
 *     *   Use `java.util.LinkedList` for the `Queue` implementation.
 *     *   Use `java.util.ArrayList` for the `List` implementation, but declare the variable using the `List` interface type.
 *     *   Proper encapsulation for its data structures.
 *     *   A public method `addTask(String description)` that creates a new `Task` object and adds it to the task queue.
 *     *   A public method `processNextTask()` that:
 *         *   Removes the next task from the front of the queue.
 *         *   Marks the task as completed using its `markAsCompleted()` method.
 *         *   Adds the completed task to the list of completed tasks.
 *         *   If the task queue is empty when `processNextTask` is called, it should *not* crash but instead report an error. You should define and throw a custom exception (e.g., `EmptyQueueException`) in this case.
 *     *   Public methods `printTaskQueue()` and `printCompletedTasks()` that iterate through the respective data structures and print the details of each task using its `toString()` method to `System.out`.
 * 
 * 3.  **User Interface:** Create a `Main` class with a `main` method to run the application.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Task Queue
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu choice. If the user enters non-integer input or a number outside the valid range, print an error message using `System.err` and allow the application to continue.
 *     *   Use `try-catch` blocks to handle potential exceptions, including the custom `EmptyQueueException` thrown by `processNextTask` and `InputMismatchException` from `Scanner`.
 *     *   All error messages (invalid input, empty queue, unexpected errors) must be printed to `System.err`.
 *     *   Normal output (menu, prompts, task lists, success messages) must be printed to `System.out`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure proper encapsulation.
 *     *   Structure the code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu. Based on user input, it should perform the requested action, print results or status messages to `System.out`, and print error messages to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Robot Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Weld frame component
 * Task added: Task{id=1, description='Weld frame component', completed=false}
 * 
 * Robot Task Scheduler Menu:
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter task description: Inspect paint finish
 * Task added: Task{id=2, description='Inspect paint finish', completed=false}
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * --- Task Queue ---
 * Task{id=1, description='Weld frame component', completed=false}
 * Task{id=2, description='Inspect paint finish', completed=false}
 * ------------------
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Task{id=1, description='Weld frame component', completed=true}
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * --- Task Queue ---
 * Task{id=2, description='Inspect paint finish', completed=false}
 * ------------------
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Weld frame component', completed=true}
 * -----------------------
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task processed: Task{id=2, description='Inspect paint finish', completed=true}
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Error: Task queue is empty. No tasks to process.
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Robot Task Scheduler Menu:
 * ...
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * Your code should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation and usage of `Queue`, `ArrayList`, `List`, `Scanner`, `Switch`.
 * *   Correct usage of `System.out` and `System.err`.
 * *   Effective use of `try-catch` for robust error handling, including the custom exception.
 * *   Proper object-oriented design (encapsulation, meaningful names, comments).
 * *   Adherence to all specified requirements.
 *
 * EXPLANATION:
 * This solution implements the Robot Task Scheduler as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, and `isCompleted`.
 *     *   `taskId` is generated using a `static` counter (`nextId`) to ensure uniqueness across all `Task` instances.
 *     *   Fields are `private` adhering to encapsulation.
 *     *   Public getters provide controlled access to the data.
 *     *   `markAsCompleted()` is a public method to change the task's state.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`RobotScheduler` Class:**
 *     *   Manages the task workflow using two key data structures:
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This demonstrates using the `Queue` interface and choosing a suitable implementation (`LinkedList` works well as a queue). Tasks are added (`offer`) and removed from the front (`poll`) following FIFO.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This demonstrates using the `List` interface while using the concrete `ArrayList` implementation, showcasing polymorphism and the flexibility of using interfaces. Completed tasks are simply added to the end (`add`).
 *     *   `addTask(String description)`: Creates a new `Task` object and adds it to the `taskQueue` using `offer()`.
 *     *   `processNextTask()`:
 *         *   Checks if the `taskQueue` is empty using `isEmpty()`.
 *         *   If empty, it throws the custom `EmptyQueueException`. This is a key requirement for error handling business logic.
 *         *   If not empty, it removes the head of the queue using `poll()`, marks the task as completed, and adds it to the `completedTasks` list.
 *     *   `printTaskQueue()` and `printCompletedTasks()`: Iterate through the respective data structures and print task details using the `Task` class's `toString()` method. Iterating directly over the `Queue` using a for-each loop is possible and doesn't remove elements.
 * 
 * 3.  **`EmptyQueueException`:**
 *     *   A simple custom exception class that extends `Exception`. This is used to signal a specific error condition (trying to process a task when none are available) in a structured way. It provides clear information about the error.
 * 
 * 4.  **`Main` Class:**
 *     *   Contains the `main` method, the application's entry point.
 *     *   A `Scanner` is used for reading console input.
 *     *   A `RobotScheduler` instance is created.
 *     *   The core logic runs in a `while(true)` loop that continues until explicitly exited.
 *     *   `displayMenu()` is a helper method to print the options.
 *     *   A `try-catch` block wraps the input reading and processing logic within the loop.
 *         *   `scanner.nextInt()` reads the integer choice. `scanner.nextLine()` is crucial after `nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls when reading the task description.
 *         *   A `switch` statement dispatches control based on the integer choice.
 *         *   Case 1: Reads the description using `scanner.nextLine()` and calls `scheduler.addTask()`.
 *         *   Case 2: Calls `scheduler.processNextTask()`. This call is wrapped in *another* `try-catch` block specifically to catch the `EmptyQueueException` thrown by `processNextTask`. The error message is printed to `System.err`.
 *         *   Cases 3 & 4: Call the respective printing methods on the scheduler.
 *         *   Case 5: Prints an exit message, closes the scanner to release system resources, and uses `return` to terminate the `main` method and thus the program.
 *         *   `default`: Handles invalid integer choices within the switch.
 *     *   The outer `try-catch` block specifically catches `InputMismatchException`. This occurs if the user enters non-integer input when an integer is expected (`scanner.nextInt()`). The error is reported to `System.err`, and `scanner.nextLine()` is called within the catch block to consume the invalid input from the buffer, preventing an infinite error loop.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors, printing a generic error message to `System.err`.
 * 
 * 5.  **System.out vs. System.err:**
 *     *   `System.out.println()` is used for all normal interactions: displaying the menu, prompts, successful operation messages, and task lists.
 *     *   `System.err.println()` is used exclusively for error messages: invalid input, invalid menu choice, and the message from the caught `EmptyQueueException`. This correctly separates standard output from error output, which is a common practice in command-line applications.
 * 
 * This solution effectively uses the required components, follows best practices, and provides robust handling for user input and potential operational errors, fulfilling the requirements of a challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Custom exception for indicating an empty task queue.
 */
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with a default message.
     */
    public EmptyQueueException() {
        super("Task queue is empty. No tasks to process.");
    }

    /**
     * Constructs an EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single task for the industrial robot.
 */
class Task {
    private int taskId;
    private String description;
    private boolean isCompleted;
    private static int nextId = 1; // Static counter for unique task IDs

    /**
     * Constructs a new Task with a given description.
     * Automatically assigns a unique task ID.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.taskId = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.isCompleted = false;
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markAsCompleted() {
        this.isCompleted = true;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string containing task details.
     */
    @Override
    public String toString() {
        return "Task{id=" + taskId +
               ", description='" + description + '\'' +
               ", completed=" + isCompleted +
               '}';
    }
}

/**
 * Manages the queue of tasks for the robot and keeps track of completed tasks.
 */
class RobotScheduler {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;

    /**
     * Constructs a new RobotScheduler, initializing task queues and lists.
     */
    public RobotScheduler() {
        this.taskQueue = new LinkedList<>(); // Use LinkedList for Queue implementation
        this.completedTasks = new ArrayList<>(); // Use ArrayList for List implementation
    }

    /**
     * Adds a new task to the end of the task queue.
     * @param description The description for the new task.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        Task newTask = new Task(description);
        taskQueue.offer(newTask); // offer() is generally preferred over add() for queues as it handles capacity issues (though LinkedList is unbounded)
        return newTask;
    }

    /**
     * Processes the next task from the front of the queue.
     * Removes the task, marks it as completed, and adds it to the completed list.
     * @throws EmptyQueueException if the task queue is empty.
     */
    public void processNextTask() throws EmptyQueueException {
        if (taskQueue.isEmpty()) {
            throw new EmptyQueueException();
        }

        Task nextTask = taskQueue.poll(); // Retrieve and remove the head of the queue
        if (nextTask != null) { // poll() returns null if queue is empty, but we already checked
            nextTask.markAsCompleted();
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask);
        }
    }

    /**
     * Prints the details of all tasks currently in the task queue.
     */
    public void printTaskQueue() {
        System.out.println("--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("------------------");
    }

    /**
     * Prints the details of all tasks that have been completed.
     */
    public void printCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the list of completed tasks
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main class to run the Robot Task Scheduler application.
 * Handles user interaction and manages the RobotScheduler.
 */
public class Main {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\nRobot Task Scheduler Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RobotScheduler scheduler = new RobotScheduler();

        // Main application loop
        while (true) {
            displayMenu();

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for handling user choices
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        Task addedTask = scheduler.addTask(description);
                        System.out.println("Task added: " + addedTask);
                        break;

                    case 2: // Process Next Task
                        System.out.println("Processing next task...");
                        try {
                            scheduler.processNextTask();
                        } catch (EmptyQueueException e) {
                            // Catch the custom exception for empty queue and print to stderr
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 3: // View Task Queue
                        scheduler.printTaskQueue();
                        break;

                    case 4: // View Completed Tasks
                        scheduler.printCompletedTasks();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting scheduler.");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the main method, ending the program

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(System.err); // Uncomment for detailed debugging
            }
            // Add a small delay or prompt if needed, or just loop
        }
    }
}
