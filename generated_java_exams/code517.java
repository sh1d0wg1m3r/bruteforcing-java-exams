/*
 * Exam Question #517
 * Generated on: 2025-05-11 23:23:10
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Request Processor
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Customer Service Request Processing System. The system should allow users to add new service requests, process the next request in line, view the current queue of pending requests, and view a history of processed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Request Management:**
 *     *   Each request should have a unique ID (a simple counter starting from 1 is sufficient), a description of the issue, and the customer's name.
 *     *   New requests are added to a queue for processing.
 *     *   Requests are processed in a First-In, First-Out (FIFO) manner.
 *     *   Processed requests are moved to a separate list for historical viewing.
 * 
 * 2.  **User Interface:**
 *     *   The system should provide a command-line interface.
 *     *   Use `Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Request
 *         2.  Process Next Request
 *         3.  View Pending Requests Queue
 *         4.  View Processed Requests History
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 3.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the pending requests.
 *     *   Use `java.util.List` (implemented by `java.util.ArrayList`) to store the history of processed requests.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Validate user input for adding requests (e.g., description and customer name should not be empty).
 *     *   Handle cases where the user tries to process a request when the queue is empty.
 *     *   Handle invalid menu choices.
 *     *   Use `System.err` to print all error messages.
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, list contents).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues, particularly input errors or system state problems. A general `try-catch` around the main application loop is required.
 * 
 * 5.  **Code Structure and Best Practices:**
 *     *   Create classes to encapsulate the system's logic (e.g., a `Request` class and a `RequestProcessingSystem` class).
 *     *   Use private fields and public methods for proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (brief Javadoc is sufficient for key classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   The program should display a menu upon startup and after each successful operation or handled error.
 * *   Adding a request should prompt for description and customer name, then confirm successful addition.
 * *   Processing a request should indicate which request (by ID) was processed or report that the queue is empty.
 * *   Viewing the queue should list all pending requests in order, or indicate if the queue is empty.
 * *   Viewing history should list all processed requests, or indicate if the history is empty.
 * *   Error messages (invalid input, empty queue processing, invalid menu choice) should be printed to `System.err`.
 * *   Any unhandled exceptions caught by the main `try-catch` should be reported to `System.err`.
 * 
 * **Constraints:**
 * 
 * *   You MUST use `java.util.Queue`.
 * *   You MUST use `java.util.ArrayList` and declare the variable using the `java.util.List` interface.
 * *   You MUST use `java.util.Scanner`.
 * *   You MUST use a `switch` statement.
 * *   You MUST use `System.err` for error output.
 * *   You MUST use `System.out` for normal output.
 * *   You MUST use `try-catch` for exception handling, including a general catch block around the main application loop.
 * 
 * **Note:** Focus on demonstrating the correct usage and integration of the required Java components and best practices.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Service Request Processing System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Request` Class:**
 *     *   This is a simple Plain Old Java Object (POJO) representing a request.
 *     *   It has private fields (`id`, `description`, `customerName`) to enforce encapsulation.
 *     *   A constructor initializes these fields.
 *     *   Public getter methods are provided to access the data.
 *     *   The `toString()` method is overridden for easy printing of request details.
 * 
 * 2.  **`RequestProcessingSystem` Class:**
 *     *   This class contains the core logic for managing requests.
 *     *   It uses a `Queue<Request>` (`requestQueue`) implemented by `LinkedList` to store pending requests, ensuring FIFO order.
 *     *   It uses a `List<Request>` (`processedRequests`) implemented by `ArrayList` to store requests after they are processed.
 *     *   `nextRequestId` is a simple counter to generate unique IDs.
 *     *   **`addRequest(String description, String customerName)`:**
 *         *   Takes description and customer name as input.
 *         *   Includes input validation (`IllegalArgumentException`) to check for empty strings, printing the error to `System.err` via the calling code's `catch` block.
 *         *   Creates a new `Request` object with a unique ID.
 *         *   Uses `requestQueue.offer()` to add the request to the end of the queue. `offer()` is generally preferred over `add()` in Queue as it returns `false` on failure in capacity-constrained queues (though `LinkedList` is not capacity-constrained).
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextRequest()`:**
 *         *   Uses `requestQueue.poll()` to retrieve and remove the element at the front of the queue. `poll()` is used because it returns `null` if the queue is empty, which is handled gracefully.
 *         *   If a request is retrieved, it's added to the `processedRequests` list using `processedRequests.add()`.
 *         *   Prints a success message to `System.out`.
 *         *   If the queue was empty, it prints an error message to `System.err`.
 *     *   **`viewPendingRequests()`:**
 *         *   Checks if `requestQueue` is empty and prints an appropriate message to `System.out`.
 *         *   If not empty, it iterates through the queue (using `forEach` and method reference `System.out::println`) and prints each request to `System.out` without removing them from the queue.
 *     *   **`viewProcessedRequests()`:**
 *         *   Checks if `processedRequests` is empty and prints an appropriate message to `System.out`.
 *         *   If not empty, it iterates through the list (using `forEach`) and prints each processed request to `System.out`.
 * 
 * 3.  **`ServiceSystemApp` Class:**
 *     *   Contains the `main` method, which is the application entry point.
 *     *   A `Scanner` object is created to read user input from `System.in`.
 *     *   An instance of `RequestProcessingSystem` is created.
 *     *   A `boolean running` flag controls the main application loop.
 *     *   **Class-wide `try-catch`:** The main `while(running)` loop is wrapped in a `try` block. A general `catch(Exception e)` block follows, which catches any unexpected runtime exception that might occur within the loop's execution, printing an error and stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   Inside the loop:
 *         *   The menu is printed to `System.out`.
 *         *   User input is read using `scanner.nextInt()`.
 *         *   A specific `try-catch (InputMismatchException e)` is used *within* the loop to handle non-integer input for the menu choice. This provides more specific error handling for this common input issue, preventing the program from crashing and allowing the loop to continue after printing an error to `System.err`. `scanner.nextLine()` is called after `nextInt()` and in the catch block to consume the remaining newline character or invalid input.
 *         *   A `switch` statement handles the valid integer choices (1-5).
 *         *   Each case calls the appropriate method on the `RequestProcessingSystem` instance.
 *         *   Case 1 (Add Request) prompts for description and customer name using `scanner.nextLine()` and wraps the `system.addRequest` call in a `try-catch` to specifically handle the `IllegalArgumentException` thrown by `addRequest` for validation errors, printing the error message to `System.err`.
 *         *   Case 2 (Process Next) calls `system.processNextRequest()`, which handles the empty queue condition internally using `System.err`.
 *         *   Cases 3 and 4 (View) call the respective view methods, which handle empty collections internally using `System.out`.
 *         *   Case 5 sets `running` to `false` to exit the loop.
 *         *   The `default` case in the `switch` handles invalid number choices, printing an error to `System.err`.
 * 
 * This structure effectively utilizes all required components, adheres to best practices like encapsulation and meaningful names, implements robust input validation and error handling using both specific and general `try-catch` blocks with appropriate output streams (`System.out` and `System.err`), and simulates a practical system flow using `Queue` for ordered processing and `List` for history.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single customer service request.
 */
class Request {
    private int id;
    private String description;
    private String customerName;

    /**
     * Constructs a new Request.
     * @param id The unique ID for the request.
     * @param description The description of the issue.
     * @param customerName The name of the customer.
     */
    public Request(int id, String description, String customerName) {
        this.id = id;
        this.description = description;
        this.customerName = customerName;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getCustomerName() {
        return customerName;
    }

    /**
     * Provides a string representation of the Request.
     * @return Formatted string including ID, description, and customer name.
     */
    @Override
    public String toString() {
        return String.format("Request ID: %d, Description: \"%s\", Customer: %s",
                             id, description, customerName);
    }
}

/**
 * Manages the queue of pending service requests and the history of processed requests.
 */
class RequestProcessingSystem {
    private Queue<Request> requestQueue;
    private List<Request> processedRequests;
    private int nextRequestId;

    /**
     * Constructs a new RequestProcessingSystem.
     * Initializes the queue, processed list, and request ID counter.
     */
    public RequestProcessingSystem() {
        // Use LinkedList as an implementation of Queue
        this.requestQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.processedRequests = new ArrayList<>();
        this.nextRequestId = 1;
    }

    /**
     * Adds a new request to the processing queue.
     * @param description The description of the issue.
     * @param customerName The name of the customer.
     * @throws IllegalArgumentException if description or customerName is null or empty.
     */
    public void addRequest(String description, String customerName) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        if (customerName == null || customerName.trim().isEmpty()) {
            throw new IllegalArgumentException("Customer name cannot be empty.");
        }

        Request newRequest = new Request(nextRequestId++, description.trim(), customerName.trim());
        requestQueue.offer(newRequest); // offer is generally preferred over add for queues
        System.out.println("Request added: " + newRequest.toString());
    }

    /**
     * Processes the next request from the queue (FIFO).
     * Moves the processed request to the history list.
     * @return The processed Request object, or null if the queue was empty.
     */
    public Request processNextRequest() {
        Request next = requestQueue.poll(); // poll returns null if queue is empty
        if (next != null) {
            processedRequests.add(next);
            System.out.println("Processed request: " + next.toString());
        } else {
            System.err.println("No pending requests to process.");
        }
        return next;
    }

    /**
     * Displays the current queue of pending requests.
     */
    public void viewPendingRequests() {
        if (requestQueue.isEmpty()) {
            System.out.println("The pending requests queue is empty.");
        } else {
            System.out.println("--- Pending Requests Queue ---");
            // Iterate through the queue without removing elements
            requestQueue.forEach(System.out::println);
            System.out.println("------------------------------");
        }
    }

    /**
     * Displays the history of processed requests.
     */
    public void viewProcessedRequests() {
        if (processedRequests.isEmpty()) {
            System.out.println("The processed requests history is empty.");
        } else {
            System.out.println("--- Processed Requests History ---");
            // Iterate through the list
            processedRequests.forEach(System.out::println);
            System.out.println("----------------------------------");
        }
    }

    /**
     * Checks if the processing system is active (has pending requests).
     * Not strictly required by prompt but useful.
     * @return true if the queue is not empty, false otherwise.
     */
    public boolean hasPendingRequests() {
        return !requestQueue.isEmpty();
    }
}

/**
 * Main application class for the Customer Service Request Processor.
 * Handles user interaction and orchestrates the system.
 */
public class ServiceSystemApp {

    private static final String MENU =
            "\n--- Service Request System Menu ---\n" +
            "1. Add New Request\n" +
            "2. Process Next Request\n" +
            "3. View Pending Requests Queue\n" +
            "4. View Processed Requests History\n" +
            "5. Exit\n" +
            "Enter your choice: ";

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RequestProcessingSystem system = new RequestProcessingSystem();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                System.out.print(MENU);

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter customer name: ");
                        String customerName = scanner.nextLine();
                        try {
                            system.addRequest(description, customerName);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding request: " + e.getMessage());
                        }
                        break;
                    case 2:
                        system.processNextRequest();
                        break;
                    case 3:
                        system.viewPendingRequests();
                        break;
                    case 4:
                        system.viewProcessedRequests();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // General catch block for unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("System shut down.");
        }
    }
}
