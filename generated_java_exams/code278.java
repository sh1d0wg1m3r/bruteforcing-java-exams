/*
 * Exam Question #278
 * Generated on: 2025-05-11 22:48:42
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple simulation for a manufacturing production line. The system needs to manage tasks that arrive, queue them up for processing, simulate the processing of the next task, and keep track of tasks that have been completed. The system should be interactive, allowing a user to add new tasks, process the next task in the queue, view the list of pending tasks, view the list of completed tasks, and exit.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this production line using the following structure and adhering to best practices:
 * 
 * 1.  **Task Class:** Create a `Task` class to represent a production task.
 *     *   It should have private fields for `taskId` (an integer, unique), `taskType` (String, e.g., "Assembly", "Testing", "Packaging"), and `duration` (integer, representing processing time units).
 *     *   Provide a constructor to initialize these fields.
 *     *   Include public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., "Task ID: 101, Type: Assembly, Duration: 5").
 * 
 * 2.  **ProductionLineSimulator Class:** Create a class (e.g., `ProductionLineSimulator`) containing the `main` method.
 *     *   This class should manage the state of the production line.
 *     *   Use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (the "pending tasks queue").
 *     *   Use a `java.util.List<Task>` (specifically, a `java.util.ArrayList<Task>`) to store tasks that have been completed.
 *     *   Maintain a counter for generating unique task IDs.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Read the user's choice.
 * 
 * 4.  **Flow Control:**
 *     *   Use a `switch` statement based on the user's choice to execute the corresponding action.
 *     *   The program should loop, presenting the menu and processing choices until the user selects the "Exit" option.
 * 
 * 5.  **Adding a Task:**
 *     *   Prompt the user for the task type (String) and duration (integer).
 *     *   Validate that the duration is a positive integer.
 *     *   If input is valid, create a new `Task` object with a unique ID, and add it to the pending tasks queue.
 *     *   Use `System.out` for success messages.
 *     *   Use `System.err` for validation errors (e.g., non-positive duration, invalid input format).
 * 
 * 6.  **Processing a Task:**
 *     *   Check if the pending tasks queue is empty.
 *     *   If not empty, remove the task at the front of the queue (simulate processing).
 *     *   Add the processed task to the completed tasks list.
 *     *   Use `System.out` to report which task was processed.
 *     *   If the queue is empty, use `System.out` to inform the user there are no tasks to process.
 * 
 * 7.  **Viewing Tasks:**
 *     *   For viewing pending tasks, iterate through the `Queue` and print each task's details using its `toString()` method. Do *not* remove tasks from the queue.
 *     *   For viewing completed tasks, iterate through the `List` and print each task's details.
 *     *   Use `System.out` for listing tasks and headers.
 * 
 * 8.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Handle potential `java.util.InputMismatchException` when reading integer input (like duration or menu choice).
 *     *   Handle the validation error for non-positive duration.
 *     *   Implement class-wide exception handling by wrapping the main interaction loop in a `try-catch(Exception e)` block to catch any unexpected runtime errors and report them using `System.err`.
 * 
 * 9.  **Best Practices:**
 *     *   Use appropriate data types and access modifiers (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input based on the choice, and print status or task details. Error messages should go to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Production Line Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type: Assembly
 * Enter task duration: 5
 * Task added: Task ID: 1, Type: Assembly, Duration: 5
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 1
 * Enter task type: Testing
 * Enter task duration: 3
 * Task added: Task ID: 2, Type: Testing, Duration: 3
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 1, Type: Assembly, Duration: 5
 * Task ID: 2, Type: Testing, Duration: 3
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 1, Type: Assembly, Duration: 5
 * Task ID: 1 completed.
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 2, Type: Testing, Duration: 3
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 1, Type: Assembly, Duration: 5
 * 
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Production Line Simulator.
 * ```
 * 
 * Handle invalid duration input:
 * 
 * ```
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 1
 * Enter task type: Packaging
 * Enter task duration: -2
 * Error: Task duration must be a positive integer.
 * ```
 * 
 * Handle invalid menu choice:
 * 
 * ```
 * --- Production Line Menu ---
 * ...
 * Enter your choice: 9
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * ```
 * 
 * Handle invalid input format for menu choice:
 * 
 * ```
 * --- Production Line Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements the `ProductionLineSimulator` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) representing a task.
 *     *   It uses `private` fields (`taskId`, `taskType`, `duration`) to enforce encapsulation.
 *     *   Public getter methods provide controlled access to the task's properties.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`ProductionLineSimulator` Class:**
 *     *   This is the main class where the simulation logic resides.
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used to implement the `Queue` interface. This is suitable because a queue requires efficient insertion at the rear (`offer()`) and removal from the front (`poll()`), which `LinkedList` provides. It models the waiting line of tasks.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used to implement the `List` interface. This is suitable for storing completed tasks because we primarily add to the end (`add()`) and iterate through the list (`for-each loop`) to view completed tasks. `ArrayList` offers efficient random access (though not used extensively here) and good overall performance for these operations.
 *     *   **`nextTaskId`**: An integer counter ensures each task gets a unique ID.
 *     *   **`scanner`**: A `Scanner` object is used for reading console input.
 *     *   **Encapsulation**: The data structures (`pendingTasks`, `completedTasks`, `nextTaskId`) and the `scanner` are private fields within the simulator class.
 *     *   **Methods**: Private helper methods (`displayMenu`, `addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) encapsulate specific functionalities, making the code modular and readable. The public `startSimulation` method orchestrates the main loop.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   The `startSimulation` method contains the main `while` loop that keeps the program running until the user chooses to exit.
 *     *   Inside the loop, `displayMenu` shows the options.
 *     *   `scanner.nextInt()` reads the user's numerical choice. `scanner.nextLine()` is called immediately after `nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   A `switch` statement directs execution to the appropriate method based on the user's `choice`.
 *     *   A `default` case in the `switch` handles invalid numerical choices.
 * 
 * 4.  **Adding and Processing Tasks:**
 *     *   `addTask()`: Prompts for type and duration. It includes a loop with a `try-catch` specifically for the duration input to handle `InputMismatchException` (non-integer input) and a check for positive duration. Valid tasks are added to the `pendingTasks` `Queue` using `offer()`.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to get and remove the task at the head of the queue. If `poll()` returns `null` (queue is empty), it prints a message. Otherwise, the task is added to the `completedTasks` `List` using `add()`.
 * 
 * 5.  **Viewing Tasks:**
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` `Queue` using an enhanced `for` loop. This iterates over the elements without removing them, fulfilling the requirement to view without processing.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` `List` using an enhanced `for` loop, printing each completed task.
 * 
 * 6.  **Error Handling:**
 *     *   **Input Validation (`addTask`)**: Explicitly checks if `duration <= 0` and uses `System.err` for the error message.
 *     *   **Input Format Handling (`addTask`, `startSimulation`)**: `try-catch (InputMismatchException e)` blocks are used around `scanner.nextInt()` calls. If invalid input is detected, an error message is printed to `System.err`, and `scanner.nextLine()` is called inside the catch block to clear the invalid input from the scanner buffer, preventing an infinite loop. `continue` is used in the main loop's catch block to restart the loop iteration and display the menu again.
 *     *   **Class-wide Exception Handling (`startSimulation`)**: The entire `while` loop that drives the simulation is wrapped in a `try-catch (Exception e)`. This demonstrates handling any *unexpected* runtime exceptions that might occur within the simulation logic, printing an error message and stack trace to `System.err` before the program potentially terminates or enters a stable state in a more complex scenario.
 *     *   **Resource Management**: The `finally` block in `startSimulation` ensures that the `scanner.close()` method is called regardless of whether the `while` loop finishes normally or an unexpected `Exception` is caught, preventing resource leaks.
 * 
 * 7.  **Best Practices:**
 *     *   Private fields and public methods (`getters`, `toString`) ensure proper encapsulation.
 *     *   Variable names (`pendingTasks`, `completedTasks`, `nextTaskId`, `taskType`, `duration`, `choice`) and method names (`displayMenu`, `addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `startSimulation`) are descriptive.
 *     *   Basic Javadoc comments are included for classes and methods, explaining their purpose. Inline comments clarify specific logic points (like consuming newline after `nextInt`).
 *     *   `System.out` is used for normal program output (menu, success messages, task lists), while `System.err` is reserved for error messages (validation errors, invalid input, unexpected exceptions), adhering to standard practice.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical simulation, demonstrating understanding of data structures, control flow, error handling, and object-oriented principles.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single production task.
 */
class Task {
    private int taskId;
    private String taskType;
    private int duration;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param taskType The type of the task (e.g., Assembly, Testing).
     * @param duration The duration of the task in time units.
     */
    public Task(int taskId, String taskType, int duration) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.duration = duration;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getTaskType() {
        return taskType;
    }

    public int getDuration() {
        return duration;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Type: " + taskType + ", Duration: " + duration;
    }
}

/**
 * Simulates a production line managing pending and completed tasks.
 */
public class ProductionLineSimulator {

    // Use LinkedList to implement Queue for efficient additions/removals from front/back
    private Queue<Task> pendingTasks;
    // Use ArrayList for completed tasks as we primarily add and iterate
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for unique task IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new ProductionLineSimulator.
     */
    public ProductionLineSimulator() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Production Line Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the pending queue based on user input.
     */
    private void addTask() {
        System.out.print("Enter task type: ");
        String type = scanner.nextLine();

        int duration = -1;
        boolean validDuration = false;
        while (!validDuration) {
            System.out.print("Enter task duration: ");
            try {
                duration = scanner.nextInt();
                // Consume the rest of the line after reading the integer
                scanner.nextLine();
                if (duration <= 0) {
                    System.err.println("Error: Task duration must be a positive integer.");
                } else {
                    validDuration = true;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for duration.");
                // Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
            }
        }

        Task newTask = new Task(nextTaskId++, type, duration);
        pendingTasks.offer(newTask); // Use offer() for adding to queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue and moves it to completed.
     */
    private void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Use poll() to retrieve and remove

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            // Simulate processing time if needed, but for this problem, just move it
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task ID: " + taskToProcess.getTaskId() + " completed.");
        } else {
            System.out.println("No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Starts the production line simulation loop.
     */
    public void startSimulation() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop and show menu again
                }

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Production Line Simulator.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the simulation
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed even if an exception occurs or loop exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.startSimulation();
    }
}
