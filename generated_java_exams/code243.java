/*
 * Exam Question #243
 * Generated on: 2025-05-11 22:38:13
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Call Center Simulation**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple console-based application that simulates a technical support call center. The system should manage incoming customer support calls by placing them in a waiting queue. Support agents can then process calls from the queue in a First-In, First-Out (FIFO) manner. The system should also maintain a history of all calls that have been completed.
 * 
 * Your task is to create a Java program that fulfills the following requirements:
 * 
 * 1.  **Call Representation:** Create a `Call` class to represent a customer support call. Each `Call` object must have:
 *     *   A unique integer `callId` (automatically generated, starting from 1).
 *     *   A `String` description of the issue.
 *     *   A `String` issue type (e.g., "Technical", "Billing", "General").
 *     *   A `String` status (e.g., "Waiting", "Completed").
 *     *   Appropriate private fields, a constructor, and public getter methods.
 *     *   A method to update the status (e.g., to "Completed").
 *     *   An overridden `toString()` method for easy printing of call details.
 * 
 * 2.  **Call Center Management:** Create a `CallCenter` class responsible for managing the calls. This class must:
 *     *   Use a `java.util.Queue` to store calls that are waiting to be processed. Use a concrete implementation like `LinkedList`.
 *     *   Use a `java.util.List` (declared as `List`, implemented as `ArrayList`) to store calls that have been completed.
 *     *   Include methods for:
 *         *   `addCall(String description, String issueType)`: Creates a new `Call` object and adds it to the waiting queue.
 *         *   `processNextCall()`: Removes the next call from the queue (the one that has been waiting the longest), updates its status to "Completed", and adds it to the list of completed calls. If the queue is empty, it should indicate that.
 *         *   `viewQueue()`: Displays the details of all calls currently in the waiting queue without removing them.
 *         *   `viewHistory()`: Displays the details of all calls in the completed history list.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `CallCenterApp`) with a `main` method that provides a command-line interface using `java.util.Scanner`. The interface should present a menu with options corresponding to the `CallCenter` operations (Add Call, Process Call, View Queue, View History) and an option to Exit.
 * 
 * 4.  **Flow Control:** Use a `switch` statement in the main application loop to handle the user's menu choice.
 * 
 * 5.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and call details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu input, attempting to process a call when the queue is empty, invalid call details like empty description).
 * 
 * 6.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks in the main application class to gracefully handle potential runtime errors, especially issues related to user input (like entering non-numeric text for a menu choice). Ensure the program doesn't crash on invalid input and provides informative error messages via `System.err`. Handle specific exceptions like `InputMismatchException` and include a general `Exception` catch.
 * 
 * 7.  **Best Practices:**
 *     *   Adhere to encapsulation principles (private fields, public methods/getters).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement basic input validation (e.g., check if description/type are empty strings before adding a call).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu. User input should trigger corresponding actions. Output should clearly indicate the result of each action (e.g., "New call added...", "Processed call...", listing calls in queue/history). Error messages should be printed to `System.err` when invalid actions or inputs occur.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Call Center Menu ---
 * 1. Add New Call
 * 2. Process Next Call
 * 3. View Call Queue
 * 4. View Completed History
 * 0. Exit
 * ------------------------
 * Enter your choice: 1
 * Enter call description: Internet not working
 * Enter issue type (e.g., Technical, Billing, General): Technical
 * New call added to queue: 1
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Call Queue ---
 * 1. Call ID: 1, Type: Technical, Status: Waiting, Description: "Internet not working"
 * --------------------------
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 2
 * Processed call: 1
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 3
 * The call queue is empty.
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Call History ---
 * 1. Call ID: 1, Type: Technical, Status: Completed, Description: "Internet not working"
 * ----------------------------
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 0 and 4.
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Call Center Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Call Center application. Goodbye!
 * ```
 * 
 * Your solution should be provided as a single block of Java code containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple call center simulation using the required Java components and best practices.
 * 
 * 1.  **`Call` Class:** Represents a single call with a unique ID, description, type, and status. It uses a `static int` (`nextCallId`) to automatically generate unique IDs for each new call instance. Encapsulation is achieved by making fields `private` and providing public getter methods. The `setStatus` method allows updating the call's state. `toString()` provides a convenient way to print call details.
 * 
 * 2.  **`CallCenter` Class:** This is the core management class.
 *     *   It uses a `java.util.Queue<Call>` (`callQueue`) implemented with `LinkedList` to store waiting calls, correctly modeling the FIFO nature of a call queue. `offer()` is used for adding calls, and `poll()` for removing and retrieving the next call.
 *     *   It uses a `java.util.List<Call>` (`completedCalls`) declared with the `List` interface and implemented with `ArrayList` to store processed calls. `add()` is used to append completed calls to this history list.
 *     *   Methods like `addCall`, `processNextCall`, `viewQueue`, and `viewHistory` encapsulate the operations on these data structures.
 *     *   `viewQueue()` demonstrates how to iterate or view the contents of a `Queue` without removing elements by copying the queue's elements into a temporary `ArrayList` and then iterating through the list. This is a common technique when you need to inspect the queue's state.
 *     *   Basic input validation is included in `addCall` to prevent adding calls with empty descriptions or types, using `System.err` for feedback. Error handling for an empty queue is implemented in `processNextCall` and `viewQueue`, also using `System.err`.
 * 
 * 3.  **`CallCenterApp` Class (Main):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes a `Scanner` for reading user input and a `CallCenter` object.
 *     *   The main application logic runs inside a `while` loop that continues until the user chooses to exit (option 0).
 *     *   A `printMenu()` method displays the available options using `System.out`.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer input, calling the appropriate `CallCenter` methods or exiting. `System.out` is used for normal prompts and confirmations.
 * 
 * 4.  **Exception Handling (`try-catch`):**
 *     *   The core application loop within `main` is wrapped in a `try` block. This fulfills the requirement for "class-wide" handling by containing the primary execution flow.
 *     *   An inner `try-catch` block specifically targets the user input reading (`scanner.nextInt()`) and the `switch` block.
 *     *   It explicitly catches `InputMismatchException` which occurs if the user enters non-integer text when a number is expected. The catch block prints an error message to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A general `catch (Exception e)` is included to catch any other unexpected exceptions that might occur during the operations within the loop, printing an error message to `System.err`.
 *     *   The outer `catch (Exception mainException)` handles any exceptions that occur during the initial setup phase (like creating the `Scanner` or `CallCenter` instance).
 * 
 * 5.  **Required Components Usage:**
 *     *   `Queue`: Used for `callQueue`.
 *     *   `ArrayList`: Used for `completedCalls` and temporarily in `viewQueue`.
 *     *   `List` interface: Used in the declaration `private List<Call> completedCalls;`.
 *     *   `Scanner`: Used in `main` to read user input.
 *     *   `switch`: Used in `main` for menu navigation.
 *     *   `System.err`: Used for error messages (invalid input, empty queue, validation errors).
 *     *   `System.out`: Used for menu, prompts, and normal output.
 *     *   `try-catch`: Used for robust exception handling around user input and general operations in `main`.
 * 
 * This solution effectively integrates multiple Java concepts and data structures to solve a practical problem, demonstrating understanding of object-oriented design, data management, user interaction, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class to represent a customer support call
class Call {
    // Static counter to generate unique call IDs
    private static int nextCallId = 1;

    private int callId;
    private String description;
    private String issueType;
    private String status; // e.g., "Waiting", "Completed"

    /**
     * Constructs a new Call object with initial status "Waiting".
     * @param description The description of the customer's issue.
     * @param issueType The type of issue (e.g., "Technical", "Billing").
     */
    public Call(String description, String issueType) {
        this.callId = nextCallId++; // Assign unique ID and increment counter
        this.description = description;
        this.issueType = issueType;
        this.status = "Waiting"; // New calls start as Waiting
    }

    // --- Getters ---
    public int getCallId() {
        return callId;
    }

    public String getDescription() {
        return description;
    }

    public String getIssueType() {
        return issueType;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the call.
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Call object.
     * @return A formatted string describing the call.
     */
    @Override
    public String toString() {
        return String.format("Call ID: %d, Type: %s, Status: %s, Description: \"%s\"",
                             callId, issueType, status, description);
    }
}

// Class to manage the call center operations
class CallCenter {
    // Queue to hold calls waiting for processing (FIFO)
    private Queue<Call> callQueue;
    // List to hold calls that have been completed
    private List<Call> completedCalls;

    /**
     * Constructs a new CallCenter, initializing the call queue and completed calls list.
     */
    public CallCenter() {
        // Use LinkedList as an implementation of Queue
        callQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        completedCalls = new ArrayList<>();
    }

    /**
     * Adds a new call to the waiting queue. Performs basic validation on input.
     * @param description The description of the issue.
     * @param issueType The type of issue (e.g., "Technical", "Billing").
     */
    public void addCall(String description, String issueType) {
        // Basic input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Call description cannot be empty.");
            return;
        }
        if (issueType == null || issueType.trim().isEmpty()) {
            System.err.println("Error: Call issue type cannot be empty.");
            return;
        }

        Call newCall = new Call(description, issueType);
        // Add the new call to the end of the queue
        callQueue.offer(newCall); // offer() is generally preferred over add() for queues

        System.out.println("New call added to queue: " + newCall.getCallId());
    }

    /**
     * Processes the next call in the queue (the one at the head).
     * Removes it from the queue, updates its status, and adds it to the history.
     */
    public void processNextCall() {
        // Check if the queue is empty before attempting to process
        if (callQueue.isEmpty()) {
            System.err.println("No calls in the queue to process.");
            return;
        }

        // Get and remove the head of the queue
        Call callToProcess = callQueue.poll();

        // poll() returns null if the queue is empty, though we checked isEmpty() above.
        // This null check adds robustness.
        if (callToProcess != null) {
            callToProcess.setStatus("Completed"); // Update status
            completedCalls.add(callToProcess); // Add to completed history
            System.out.println("Processed call: " + callToProcess.getCallId());
        } else {
             // Should not happen if isEmpty() check is correct, but good defensive programming.
             System.err.println("Internal error: Failed to retrieve call from queue.");
        }
    }

    /**
     * Displays the details of all calls currently in the waiting queue.
     * Calls are displayed in the order they would be processed (FIFO).
     */
    public void viewQueue() {
        if (callQueue.isEmpty()) {
            System.out.println("The call queue is empty.");
            return;
        }

        System.out.println("\n--- Current Call Queue ---");
        // To display queue contents without removing elements,
        // we can iterate over the queue or copy to a list/array.
        // Copying to a list ensures we iterate over a snapshot and can use indexing if needed.
        List<Call> queueList = new ArrayList<>(callQueue); // Copies elements from queue to list
        for (int i = 0; i < queueList.size(); i++) {
             System.out.println((i + 1) + ". " + queueList.get(i));
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the history of all completed calls.
     */
    public void viewHistory() {
        if (completedCalls.isEmpty()) {
            System.out.println("No calls have been completed yet.");
            return;
        }

        System.out.println("\n--- Completed Call History ---");
        // Iterate through the completed calls list
        for (int i = 0; i < completedCalls.size(); i++) {
             System.out.println((i + 1) + ". " + completedCalls.get(i));
        }
        System.out.println("----------------------------");
    }
}

// Main application class with user interface and exception handling
public class CallCenterApp {

    public static void main(String[] args) {
        // Implement class-wide exception handling by wrapping the main logic
        try {
            Scanner scanner = new Scanner(System.in);
            CallCenter callCenter = new CallCenter();

            int choice = -1; // Initialize choice to enter the loop

            // Main application loop
            while (choice != 0) {
                printMenu(); // Display the menu options

                try {
                    System.out.print("Enter your choice: ");
                    // Read the integer choice from the user
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1: // Add New Call
                            System.out.print("Enter call description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter issue type (e.g., Technical, Billing, General): ");
                            String issueType = scanner.nextLine();
                            callCenter.addCall(description, issueType);
                            break;
                        case 2: // Process Next Call
                            callCenter.processNextCall();
                            break;
                        case 3: // View Call Queue
                            callCenter.viewQueue();
                            break;
                        case 4: // View Completed History
                            callCenter.viewHistory();
                            break;
                        case 0: // Exit
                            System.out.println("Exiting Call Center application. Goodbye!");
                            break;
                        default:
                            // Handle cases where the integer input is not a valid menu option
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.nextLine();
                    // Reset choice to a value that keeps the loop running
                    choice = -1;
                } catch (Exception e) {
                    // Catch any other unexpected exceptions that might occur within the loop
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging: e.printStackTrace();
                }
                System.out.println(); // Add a newline for better separation between menu interactions
            }

            // Close the scanner resource when the application exits the loop
            scanner.close();

        } catch (Exception mainException) {
            // This catch block handles exceptions that might occur outside the main loop,
            // such as issues during the initialization of the Scanner or CallCenter.
            System.err.println("A critical error occurred during application startup or execution: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
        }
    }

    /**
     * Prints the main menu options to the console for the user.
     */
    private static void printMenu() {
        System.out.println("--- Call Center Menu ---");
        System.out.println("1. Add New Call");
        System.out.println("2. Process Next Call");
        System.out.println("3. View Call Queue");
        System.out.println("4. View Completed History");
        System.out.println("0. Exit");
        System.out.println("------------------------");
    }
}
