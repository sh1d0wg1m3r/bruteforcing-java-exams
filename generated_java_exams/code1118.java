/*
 * Exam Question #1118
 * Generated on: 2025-05-12 17:27:29
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Print Job Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application to simulate a print job management system. The system should manage a queue of print jobs waiting to be processed and maintain a history of completed jobs. Users will interact with the system via a text-based menu.
 * 
 * **Functional Requirements:**
 * 
 * 1.  **Add New Print Job:** Allow the user to submit a new print job by providing a document name and the number of pages. New jobs are added to the end of the print queue.
 * 2.  **Process Next Job:** Process the job at the front of the queue. Once processed, the job should be removed from the queue and added to a list of completed jobs.
 * 3.  **View Pending Jobs:** Display all jobs currently waiting in the print queue, in the order they will be processed.
 * 4.  **View Completed Jobs:** Display all jobs that have been processed.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution MUST adhere to the following technical specifications:
 * 
 * 1.  **Collections:**
 *     *   Use `java.util.Queue` to represent the queue of pending print jobs.
 *     *   Use `java.util.ArrayList` to store the history of completed jobs.
 *     *   Use the `java.util.List` interface as a type declaration where appropriate (e.g., for method return types when viewing jobs).
 * 2.  **User Input:** Use `java.util.Scanner` to read user input from the console.
 * 3.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, job details, and success messages.
 *     *   Use `System.err` to output error messages (e.g., invalid menu choice, invalid job details, attempting to process an empty queue).
 * 5.  **Exception Handling:** Implement robust exception handling using `try-catch` blocks. This should include handling potential errors like invalid number formats for input, and logical errors such as attempting to create a job with invalid details or process a job when the queue is empty. The main application loop should use try-catch to handle exceptions arising from user input or operations.
 * 
 * **Design Requirements (Best Practices):**
 * 
 * 1.  **Object-Oriented Design:** Design appropriate classes to model the system (e.g., a `PrintJob` class and a `PrintManager` class).
 * 2.  **Encapsulation:** Ensure class fields are private and accessed via public methods (getters).
 * 3.  **Naming Conventions:** Use meaningful names for classes, variables, and methods.
 * 4.  **Comments:** Include comments to explain the purpose of classes, complex methods, or non-obvious logic.
 * 5.  **Input Validation:** Validate user input for adding jobs (e.g., document name is not empty, page count is a positive integer).
 * 6.  **Error Handling:** Handle operational errors gracefully (e.g., attempting to process an empty queue).
 * 
 * **Expected Output (Examples):**
 * 
 * ```
 * --- Print Job Management System ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * -----------------------------------
 * Enter your choice: 1
 * Enter document name: Report.pdf
 * Enter number of pages: 15
 * Job added to queue: Report.pdf
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 1
 * Enter document name: Image.jpg
 * Enter number of pages: 3
 * Job added to queue: Image.jpg
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Print Jobs ---
 * 1. Job ID: 1, Document: "Report.pdf", Pages: 15
 * 2. Job ID: 2, Document: "Image.jpg", Pages: 3
 * --------------------------
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 2
 * Processed job: Job ID: 1, Document: "Report.pdf", Pages: 15
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Print Jobs ---
 * 1. Job ID: 2, Document: "Image.jpg", Pages: 3
 * --------------------------
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 4
 * --- Completed Print Jobs ---
 * 1. Job ID: 1, Document: "Report.pdf", Pages: 15
 * ----------------------------
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 2
 * Processed job: Job ID: 2, Document: "Image.jpg", Pages: 3
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 2
 * Error: Print queue is empty. No jobs to process.
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 1
 * Enter document name:
 * Enter number of pages: 10
 * Job creation failed: Document name cannot be empty.
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 1
 * Enter document name: Test
 * Enter number of pages: -5
 * Job creation failed: Page count must be positive.
 * 
 * --- Print Job Management System ---
 * ...
 * Enter your choice: 5
 * Exiting Print Job Management System. Goodbye!
 * ```
 * 
 * Your solution should provide a robust implementation that meets all the specified requirements.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Print Job Management System using the required Java components and following best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print job.
 *     *   Contains `private` fields for `id`, `documentName`, and `pageCount`, demonstrating encapsulation.
 *     *   Uses a `static` field `nextId` to ensure each job gets a unique ID upon creation.
 *     *   The constructor includes input validation, throwing `IllegalArgumentException` if the document name is empty or the page count is not positive. This demonstrates proactive error checking at the object creation level.
 *     *   Includes public getter methods (`getId`, `getDocumentName`, `getPageCount`).
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Manages the collections holding the jobs.
 *     *   Contains a `private Queue<PrintJob> printQueue` to hold jobs waiting to be processed. `java.util.LinkedList` is used as a concrete implementation of the `Queue` interface.
 *     *   Contains a `private List<PrintJob> completedJobs` to hold jobs that have finished processing. `java.util.ArrayList` is used as a concrete implementation of the `List` interface.
 *     *   `addJob(PrintJob job)`: Uses the `offer()` method of the Queue to add a job. Includes a null check.
 *     *   `processNextJob()`: Uses the `poll()` method of the Queue to retrieve and remove the head job. It checks if the result is null (indicating an empty queue) and prints an error to `System.err`. If a job is retrieved, it's added to the `completedJobs` list.
 *     *   `getPendingJobs()`: Returns a `List<PrintJob>` representation of the current queue elements. A new `ArrayList` is created from the queue's elements to return a snapshot, preventing external code from modifying the live queue directly and demonstrating returning the `List` interface type.
 *     *   `getCompletedJobs()`: Returns the `List<PrintJob>` containing completed jobs.
 * 
 * 3.  **`PrintSystemApp` Class:**
 *     *   Contains the `main` method and serves as the application's entry point and user interface handler.
 *     *   Instantiates `PrintManager` and `Scanner`.
 *     *   The `run()` method contains the main application loop.
 *     *   It repeatedly calls `printMenu()`, reads user input using `scanner.nextLine()`, and attempts to parse it into an integer.
 *     *   A `try-catch` block surrounds the input reading and the `switch` statement to handle potential `NumberFormatException` (if the user enters non-numeric input) and `IllegalArgumentException` (which can be thrown by the `PrintJob` constructor during job creation or potentially other operations). A general `Exception` catch is included for robustness. Error messages are printed to `System.err`.
 *     *   A `switch` statement is used to direct control flow based on the user's valid integer choice, calling corresponding private helper methods (`addPrintJob`, `processNextJob`, `viewPendingJobs`, `viewCompletedJobs`).
 *     *   The helper methods interact with the `PrintManager` instance to perform the requested actions.
 *     *   `addPrintJob` specifically handles reading document name and page count, parsing the page count, and creating a `PrintJob` within its own `try-catch` to handle `NumberFormatException` or `IllegalArgumentException` from the `PrintJob` constructor.
 *     *   `viewPendingJobs` and `viewCompletedJobs` retrieve the job lists (as `List<PrintJob>`) from the `PrintManager` and iterate through them to display the job details using `System.out`.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`PrintJob`, `PrintManager`, `PrintSystemApp`) with encapsulation, methods, and state.
 * *   **Collections Framework:** Effective use of `Queue` (`LinkedList`) for a waiting line and `List` (`ArrayList`) for a history, demonstrating appropriate collection types for different scenarios. Usage of the `List` interface for method return types and variable declarations.
 * *   **User Input:** Reading console input using `Scanner`.
 * *   **Control Flow:** Using `switch` for menu selection and a `while` loop for the application lifecycle.
 * *   **Exception Handling:** Implementing `try-catch` blocks to handle specific exceptions (`NumberFormatException`, `IllegalArgumentException`) and a general `Exception`, directing error output to `System.err`. This shows how to handle anticipated runtime errors and potential unexpected issues gracefully.
 * *   **Input Validation:** Checking user-provided data (document name, page count) before creating objects or performing operations.
 * *   **Modular Design:** Breaking down the problem into smaller, manageable methods (`addPrintJob`, `processNextJob`, etc.) and classes (`PrintJob`, `PrintManager`).
 * *   **Standard Output:** Differentiating between normal output (`System.out`) and error output (`System.err`).
 * 
 * This solution successfully integrates all required components into a cohesive, practical application that demonstrates advanced understanding of core Java concepts and best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly needed with nextLine then parse

/**
 * Represents a single print job with a unique ID, document name, and page count.
 */
class PrintJob {
    private int id;
    private String documentName;
    private int pageCount;
    private static int nextId = 1; // Static counter for unique job IDs

    /**
     * Constructs a new PrintJob.
     * Performs basic validation on input parameters.
     * @param documentName The name of the document.
     * @param pageCount The number of pages in the document.
     * @throws IllegalArgumentException if documentName is empty or pageCount is not positive.
     */
    public PrintJob(String documentName, int pageCount) {
        // Input validation
        if (documentName == null || documentName.trim().isEmpty()) {
            throw new IllegalArgumentException("Document name cannot be empty.");
        }
        if (pageCount <= 0) {
            throw new IllegalArgumentException("Page count must be positive.");
        }

        this.id = nextId++; // Assign unique ID and increment counter
        this.documentName = documentName.trim();
        this.pageCount = pageCount;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDocumentName() {
        return documentName;
    }

    public int getPageCount() {
        return pageCount;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string detailing the job ID, document name, and page count.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, Document: \"%s\", Pages: %d", id, documentName, pageCount);
    }
}

/**
 * Manages the print queue and the list of completed jobs.
 */
class PrintManager {
    private Queue<PrintJob> printQueue;      // Queue for pending jobs
    private List<PrintJob> completedJobs;   // List for completed jobs

    /**
     * Constructs a new PrintManager, initializing the queue and completed list.
     */
    public PrintManager() {
        this.printQueue = new LinkedList<>(); // LinkedList is a common implementation for Queue
        this.completedJobs = new ArrayList<>(); // ArrayList is used for the completed list
    }

    /**
     * Adds a new print job to the end of the queue.
     * @param job The PrintJob to add. Must not be null.
     */
    public void addJob(PrintJob job) {
        if (job != null) {
            printQueue.offer(job); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It returns false on failure.
            System.out.println("Job added to queue: " + job.getDocumentName());
        } else {
             System.err.println("Error: Attempted to add a null job.");
        }
    }

    /**
     * Processes the next job at the front of the queue.
     * Removes the job from the queue and adds it to the completed jobs list.
     * Reports an error to System.err if the queue is empty.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob job = printQueue.poll(); // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        if (job != null) {
            completedJobs.add(job); // Add the processed job to the list of completed jobs
            System.out.println("Processed job: " + job);
            return job;
        } else {
            System.err.println("Error: Print queue is empty. No jobs to process.");
            return null;
        }
    }

    /**
     * Retrieves a list of all pending print jobs currently in the queue.
     * Returns a new ArrayList containing the elements from the queue to avoid external modification
     * of the internal queue structure while iterating or displaying.
     * @return A List of pending PrintJob objects. Returns an empty list if the queue is empty.
     */
    public List<PrintJob> getPendingJobs() {
        // Return a new ArrayList containing all elements from the queue.
        // This allows iterating over pending jobs without directly exposing the queue's internal structure or state changes.
        return new ArrayList<>(printQueue); // Demonstrates returning a List interface type
    }

    /**
     * Retrieves the list of all completed print jobs.
     * @return A List of completed PrintJob objects. Returns an empty list if no jobs are completed.
     */
    public List<PrintJob> getCompletedJobs() {
        return completedJobs; // Returns the internal List of completed jobs
    }
}

/**
 * Main application class for the Print Job Management System.
 * Handles user interaction and coordinates operations via the PrintManager.
 */
public class PrintSystemApp {

    private static PrintManager printManager = new PrintManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        run();
    }

    /**
     * Runs the main application loop, displaying the menu and handling user choices.
     * Includes class-wide exception handling for user input and operations.
     */
    public static void run() {
        int choice = -1;
        // Loop until the user chooses to exit (choice 5)
        while (choice != 5) {
            printMenu(); // Display the main menu
            try {
                System.out.print("Enter your choice: ");
                String input = scanner.nextLine(); // Read the entire line of input

                // Attempt to parse the input string into an integer.
                // This is where NumberFormatException can occur if input is not a valid integer.
                choice = Integer.parseInt(input);

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addPrintJob(); // Call method to add a new job
                        break;
                    case 2:
                        processNextJob(); // Call method to process the next job
                        break;
                    case 3:
                        viewPendingJobs(); // Call method to view pending jobs
                        break;
                    case 4:
                        viewCompletedJobs(); // Call method to view completed jobs
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        break;
                    default:
                        // Handle cases where the integer input is outside the valid range [1, 5]
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch exception if Integer.parseInt fails (input was not a number)
                System.err.println("Invalid input. Please enter a number for the menu choice.");
            } catch (IllegalArgumentException e) {
                 // Catch exceptions that might bubble up from PrintJob constructor or other methods
                 // (e.g., validation errors during job creation)
                 System.err.println("Operation Error: " + e.getMessage());
            } catch (Exception e) {
                // A general catch block for any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging purposes
            }
            System.out.println(); // Print a newline for better separation between menu interactions
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void printMenu() {
        System.out.println("--- Print Job Management System ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Handles the process of getting input from the user to create and add a new print job.
     * Includes input reading and initial validation before attempting job creation.
     */
    private static void addPrintJob() {
        System.out.print("Enter document name: ");
        String docName = scanner.nextLine(); // Read document name

        System.out.print("Enter number of pages: ");
        String pagesInput = scanner.nextLine(); // Read page count as a string first

        try {
            // Attempt to parse page count input string into an integer
            int pageCount = Integer.parseInt(pagesInput);

            // Create a new PrintJob object. The constructor handles validation
            // (non-empty name, positive pages) and throws IllegalArgumentException if invalid.
            PrintJob newJob = new PrintJob(docName, pageCount);

            // If job creation was successful (no exception thrown), add it to the manager
            printManager.addJob(newJob);

        } catch (NumberFormatException e) {
            // Catch exception if Integer.parseInt fails for page count
            System.err.println("Invalid input for page count. Please enter a valid number.");
        } catch (IllegalArgumentException e) {
            // Catch validation errors thrown by the PrintJob constructor
            System.err.println("Job creation failed: " + e.getMessage());
        }
        // Note: Other exceptions are allowed to bubble up to the main run() loop's catch block.
    }

    /**
     * Calls the PrintManager to process the next job in the queue.
     * The PrintManager handles the logic and prints status/error messages.
     */
    private static void processNextJob() {
        System.out.println("Attempting to process next job...");
        printManager.processNextJob(); // This method prints its own success or error message
    }

    /**
     * Retrieves and displays the list of pending print jobs from the PrintManager.
     */
    private static void viewPendingJobs() {
        // Get the list of pending jobs from the manager. The manager returns a List<PrintJob>.
        List<PrintJob> pending = printManager.getPendingJobs();

        System.out.println("--- Pending Print Jobs ---");
        if (pending.isEmpty()) {
            System.out.println("No jobs currently in the queue.");
        } else {
            // Iterate through the list of pending jobs and print each one.
            for (int i = 0; i < pending.size(); i++) {
                System.out.println((i + 1) + ". " + pending.get(i)); // Use List's get(index) method
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Retrieves and displays the list of completed print jobs from the PrintManager.
     */
    private static void viewCompletedJobs() {
        // Get the list of completed jobs from the manager. The manager returns a List<PrintJob>.
        List<PrintJob> completed = printManager.getCompletedJobs();

        System.out.println("--- Completed Print Jobs ---");
        if (completed.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list of completed jobs and print each one.
            for (int i = 0; i < completed.size(); i++) {
                 System.out.println((i + 1) + ". " + completed.get(i)); // Use List's get(index) method
            }
        }
        System.out.println("----------------------------");
    }
}
