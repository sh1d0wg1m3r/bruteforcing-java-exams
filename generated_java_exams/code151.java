/*
 * Exam Question #151
 * Generated on: 2025-05-11 22:22:06
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Sorting Facility Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation for a package sorting facility. Packages arrive and are placed in an incoming queue. Workers process packages one by one from the queue, sort them, and place them into a list of sorted packages ready for further handling (e.g., delivery). The system needs to manage these packages, allow adding new incoming packages, processing the next available package, and viewing the current state of both the incoming and sorted package areas.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this facility. Your program must adhere to the following specifications:
 * 
 * 1.  **Package Representation:** Create a `Package` class with the following private fields:
 *     *   `packageId` (String): A unique identifier for the package.
 *     *   `description` (String): A brief description of the package contents.
 *     *   `status` (String): Represents the current status (e.g., "PENDING", "SORTED").
 * 
 *     Include a constructor, public getter methods for all fields, and a `toString()` method that provides a user-friendly representation of the package. Ensure proper encapsulation.
 * 
 * 2.  **Facility Management:** Create a `SortingFacility` class responsible for managing the packages. This class must contain:
 *     *   A `Queue<Package>` to hold incoming packages waiting to be processed.
 *     *   A `List<Package>` (implemented using `ArrayList`) to hold packages that have been processed/sorted.
 * 
 *     Provide public methods in `SortingFacility` for the following operations:
 *     *   `addIncomingPackage(Package pkg)`: Adds a package to the incoming queue. Include validation (e.g., packageId and description cannot be empty/null).
 *     *   `processNextPackage()`: Takes the next package from the incoming queue, changes its status to "SORTED", and adds it to the sorted packages list. Handle the case where the incoming queue is empty.
 *     *   `getIncomingPackages()`: Returns the `Queue` of incoming packages.
 *     *   `getSortedPackages()`: Returns the `List` of sorted packages.
 *     *   `getIncomingCount()`: Returns the number of packages in the incoming queue.
 *     *   `getSortedCount()`: Returns the number of packages in the sorted list.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `FacilityApp`) with a `main` method that provides a command-line interface using `Scanner`. The program should present a menu with the following options:
 *     *   Add New Incoming Package
 *     *   Process Next Pending Package
 *     *   View Incoming Packages
 *     *   View Sorted Packages
 *     *   Exit
 * 
 * 4.  **Flow Control:** Use a `switch` statement in the main loop to handle user menu selections.
 * 
 * 5.  **Input/Output:**
 *     *   Use `Scanner` to read user input for menu choices and package details.
 *     *   Use `System.out` for displaying the menu, success messages, and package lists.
 *     *   Use `System.err` to display error messages (e.g., invalid input, operation failed).
 * 
 * 6.  **Exception Handling:** Implement class-wide exception handling using `try-catch` blocks in the `main` method's loop to catch potential issues like `InputMismatchException` (if the user enters non-numeric input for the menu) or other unexpected errors during operations. Gracefully handle these errors and inform the user via `System.err`.
 * 
 * 7.  **Error Handling and Validation:** Implement input validation for package details when adding a new package. Handle the scenario where the user tries to process a package when the incoming queue is empty. Report these issues using `System.err`.
 * 
 * 8.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc style for classes/methods is encouraged but not strictly required for all getters/setters).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, displaying the menu, accepting user input, performing the requested operation, and displaying results or error messages.
 * 
 * *   Adding a package should prompt for ID and description, then confirm success or report validation errors.
 * *   Processing a package should confirm which package was processed or report that the queue is empty.
 * *   Viewing packages should list the packages currently in the respective collections.
 * *   Invalid menu input or operational errors should result in an error message printed to `System.err`.
 * 
 * ---
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Sorting Facility Menu:
 * 1. Add New Incoming Package
 * 2. Process Next Pending Package
 * 3. View Incoming Packages
 * 4. View Sorted Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P001
 * Enter Package Description: Electronics
 * Package P001 added to incoming queue.
 * 
 * Sorting Facility Menu:
 * 1. Add New Incoming Package
 * 2. Process Next Pending Package
 * 3. View Incoming Packages
 * 4. View Sorted Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P002
 * Enter Package Description: Books
 * Package P002 added to incoming queue.
 * 
 * Sorting Facility Menu:
 * 1. Add New Incoming Package
 * 2. Process Next Pending Package
 * 3. View Incoming Packages
 * 4. View Sorted Packages
 * 5. Exit
 * Enter your choice: 3
 * Incoming Packages (2):
 * Package ID: P001, Description: Electronics, Status: PENDING
 * Package ID: P002, Description: Books, Status: PENDING
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 2
 * Processed package: Package ID: P001, Description: Electronics, Status: PENDING -> SORTED
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 4
 * Sorted Packages (1):
 * Package ID: P001, Description: Electronics, Status: SORTED
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 2
 * Processed package: Package ID: P002, Description: Books, Status: PENDING -> SORTED
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 3
 * Incoming Packages (0):
 * (Empty)
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 4
 * Sorted Packages (2):
 * Package ID: P001, Description: Electronics, Status: SORTED
 * Package ID: P002, Description: Books, Status: SORTED
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 2
 * System.err: No packages in the incoming queue to process.
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: abc
 * System.err: Invalid input. Please enter a number.
 * 
 * Sorting Facility Menu:
 * ...
 * Enter your choice: 5
 * Exiting Sorting Facility.
 * ```
 * 
 * Your solution should implement the classes and logic described above, using all the required Java components and following best practices.
 * 
 * ---
 * **Note:** You are allowed to use `java.util.LinkedList` as the concrete implementation for the `Queue` interface.
 *
 * EXPLANATION:
 * This solution implements the package sorting facility simulation according to the requirements, demonstrating the use of the specified Java components and adhering to best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   Encapsulates package data (`packageId`, `description`, `status`) using private fields.
 *     *   The constructor validates input (`packageId`, `description`) ensuring they are not null or empty, throwing `IllegalArgumentException` if validation fails.
 *     *   Provides public getter methods to access package information.
 *     *   Includes a `setStatus` method, which is used by the `SortingFacility` to change the package state.
 *     *   The `toString()` method provides a clear string representation of a package.
 * 
 * 2.  **`SortingFacility` Class:**
 *     *   Manages the two distinct states of packages using a `Queue<Package>` (`incomingPackages`) and a `List<Package>` (`sortedPackages`).
 *     *   `incomingPackages` is implemented using `LinkedList`, which is a common choice for `Queue` as it provides efficient insertion/removal from both ends.
 *     *   `sortedPackages` is implemented using `ArrayList`, suitable for storing processed items where access by index or iteration is common.
 *     *   `addIncomingPackage(Package pkg)`: Adds a package to the `incomingPackages` queue using `offer()`. It relies on the `Package` constructor for initial validation.
 *     *   `processNextPackage()`: Uses `poll()` to retrieve and remove the head of the `incomingPackages` queue. If the queue is empty, `poll()` returns `null`, which is handled gracefully. If a package is retrieved, its status is updated, and it's added to the `sortedPackages` list.
 *     *   `getIncomingPackages()` and `getSortedPackages()`: Provide access to the underlying collections. Note that returning the collection directly allows external modification, which might be acceptable in this simple simulation context but in a more complex system, returning unmodifiable views might be preferred.
 *     *   `getIncomingCount()` and `getSortedCount()`: Provide the current size of the collections.
 * 
 * 3.  **`FacilityApp` Class (Main Application):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   Creates instances of `SortingFacility` and `Scanner`.
 *     *   Implements a `while` loop (`running`) to keep the application active until the user chooses to exit.
 *     *   `displayMenu()`: A helper method to print the user options to `System.out`.
 *     *   **Scanner for User Input:** Reads the user's menu choice using `scanner.nextInt()`. It's crucial to call `scanner.nextLine()` immediately after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls used for reading package details.
 *     *   **Switch Statement:** The core control flow uses a `switch` statement on the user's `choice`. Each case corresponds to a menu option, calling the appropriate methods on the `SortingFacility` object.
 *     *   **System.out and System.err:** `System.out.println()` is used for displaying the menu, successful operation messages, and package lists. `System.err.println()` is used specifically for displaying error messages, such as invalid input, validation failures, or attempting to process an empty queue. This distinguishes normal output from error output.
 *     *   **Exception Handling (`try-catch`):**
 *         *   An inner `try-catch (InputMismatchException e)` block handles cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop caused by the `Scanner` not advancing past the invalid token.
 *         *   An outer `try-catch (Exception e)` block wraps the entire `while` loop. This acts as a top-level catch-all for any unexpected exceptions that might occur during the program's execution, printing an error message and the stack trace to `System.err`. This demonstrates class-wide exception handling.
 *         *   A specific `try-catch (IllegalArgumentException e)` is used when creating a new `Package` instance within case 1 to catch validation errors from the `Package` constructor and report them via `System.err`.
 *     *   **Error Handling and Validation:**
 *         *   Input validation for package ID and description is performed within the `Package` constructor, leveraging Java's exception mechanism (`IllegalArgumentException`).
 *         *   The `processNextPackage` logic checks if `poll()` returned `null` (meaning the queue was empty) and prints an error message to `System.err` if so.
 *         *   The `default` case in the `switch` handles invalid menu numbers, printing an error to `System.err`.
 *     *   **Best Practices:**
 *         *   Private fields and public methods demonstrate encapsulation.
 *         *   Variable names (`packageId`, `incomingPackages`, `processNextPackage`, `scanner`, `choice`) are descriptive.
 *         *   Comments explain the purpose of classes, methods, and key logic sections.
 *         *   The code is structured into logical classes (`Package`, `SortingFacility`, `FacilityApp`).
 *         *   Input validation and error handling are implemented where necessary.
 *         *   The `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred.
 * 
 * This solution effectively combines the required Java components to create a functional simulation, demonstrating understanding of data structures (`Queue`, `List`, `ArrayList`), object-oriented principles (encapsulation), user interaction (`Scanner`, `System.out`, `System.err`), control flow (`switch`, `while`), and robust error handling (`try-catch`).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package in the sorting facility.
 */
class Package {
    private String packageId;
    private String description;
    private String status; // e.g., "PENDING", "SORTED"

    /**
     * Constructs a new Package.
     * @param packageId The unique identifier for the package.
     * @param description The description of the package contents.
     */
    public Package(String packageId, String description) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Package description cannot be null or empty.");
        }
        this.packageId = packageId.trim();
        this.description = description.trim();
        this.status = "PENDING"; // Default status for new packages
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (used by SortingFacility) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Package.
     * @return A formatted string detailing the package.
     */
    @Override
    public String toString() {
        return String.format("Package ID: %s, Description: %s, Status: %s",
                             packageId, description, status);
    }
}

/**
 * Manages the flow of packages through the sorting facility.
 */
class SortingFacility {
    private Queue<Package> incomingPackages; // Packages waiting to be processed
    private List<Package> sortedPackages;    // Packages that have been processed

    /**
     * Constructs a new SortingFacility.
     */
    public SortingFacility() {
        // Using LinkedList as a concrete implementation for Queue
        this.incomingPackages = new LinkedList<>();
        // Using ArrayList as a concrete implementation for List
        this.sortedPackages = new ArrayList<>();
    }

    /**
     * Adds a new package to the incoming queue.
     * @param pkg The package to add.
     * @throws IllegalArgumentException if the package is null or invalid.
     */
    public void addIncomingPackage(Package pkg) {
        if (pkg == null) {
            throw new IllegalArgumentException("Cannot add a null package.");
        }
        // Package constructor already validates ID and description
        if (pkg.getStatus() != null && !pkg.getStatus().equals("PENDING")) {
             System.err.println("Warning: Adding a package with initial status not PENDING.");
        }
        this.incomingPackages.offer(pkg); // offer is generally preferred over add for queues
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves the package to the sorted list after changing its status.
     * @return The package that was processed, or null if the queue was empty.
     */
    public Package processNextPackage() {
        Package pkgToProcess = this.incomingPackages.poll(); // poll returns null if queue is empty
        if (pkgToProcess != null) {
            pkgToProcess.setStatus("SORTED");
            this.sortedPackages.add(pkgToProcess);
            return pkgToProcess;
        }
        return null; // No package was available
    }

    /**
     * Gets the queue of incoming packages.
     * @return The Queue of incoming packages.
     */
    public Queue<Package> getIncomingPackages() {
        return incomingPackages;
    }

    /**
     * Gets the list of sorted packages.
     * @return The List of sorted packages.
     */
    public List<Package> getSortedPackages() {
        return sortedPackages;
    }

    /**
     * Gets the number of packages in the incoming queue.
     * @return The count of incoming packages.
     */
    public int getIncomingCount() {
        return incomingPackages.size();
    }

    /**
     * Gets the number of packages in the sorted list.
     * @return The count of sorted packages.
     */
    public int getSortedCount() {
        return sortedPackages.size();
    }
}

/**
 * Main application class for the Sorting Facility simulation.
 * Handles user interaction and orchestrates the facility operations.
 */
public class FacilityApp {

    private static void displayMenu() {
        System.out.println("\nSorting Facility Menu:");
        System.out.println("1. Add New Incoming Package");
        System.out.println("2. Process Next Pending Package");
        System.out.println("3. View Incoming Packages");
        System.out.println("4. View Sorted Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        SortingFacility facility = new SortingFacility();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter Package ID: ");
                        String id = scanner.nextLine();
                        System.out.print("Enter Package Description: ");
                        String description = scanner.nextLine();
                        try {
                            Package newPackage = new Package(id, description);
                            facility.addIncomingPackage(newPackage);
                            System.out.println("Package " + newPackage.getPackageId() + " added to incoming queue.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding package: " + e.getMessage());
                        }
                        break;

                    case 2:
                        Package processedPackage = facility.processNextPackage();
                        if (processedPackage != null) {
                            System.out.println("Processed package: " + processedPackage.toString().replace("PENDING", "PENDING -> SORTED"));
                        } else {
                            System.err.println("No packages in the incoming queue to process.");
                        }
                        break;

                    case 3:
                        System.out.println("Incoming Packages (" + facility.getIncomingCount() + "):");
                        if (facility.getIncomingCount() == 0) {
                            System.out.println("(Empty)");
                        } else {
                            // Iterate and print packages from the queue (without removing)
                            facility.getIncomingPackages().forEach(System.out::println);
                        }
                        break;

                    case 4:
                        System.out.println("Sorted Packages (" + facility.getSortedCount() + "):");
                        if (facility.getSortedCount() == 0) {
                            System.out.println("(Empty)");
                        } else {
                            // Iterate and print packages from the list
                            facility.getSortedPackages().forEach(System.out::println);
                        }
                        break;

                    case 5:
                        running = false;
                        System.out.println("Exiting Sorting Facility.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions at the top level
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }
}
