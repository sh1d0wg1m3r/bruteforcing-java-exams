/*
 * Exam Question #900
 * Generated on: 2025-05-12 16:56:55
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple console-based Task Management System. This system should allow users to add new tasks to a queue for processing, process the next task in the queue, view the list of pending tasks, view the list of completed tasks, and exit the application.
 * 
 * The system must simulate a sequential processing flow where tasks are handled in the order they are added.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private attributes:
 *     *   `taskId` (String): A unique identifier for the task (can be generated sequentially or randomly, but must be unique).
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "PENDING", "COMPLETED").
 *     *   Include a constructor and appropriate public getter methods. An overridden `toString()` method is recommended for easy printing.
 * 
 * 2.  **Task Management System Class:** Create a `TaskProcessingSystem` class that encapsulates the core logic.
 *     *   It must have a private `Queue<Task>` to store tasks that are waiting to be processed. Use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *     *   It must have a private `List<Task>` to store tasks that have been completed. Use `java.util.ArrayList` as the concrete implementation, but declare the field using the `List` interface type.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with status "PENDING", assigns a unique ID, and adds it to the pending queue. Validate that the description is not null or empty.
 *         *   `processNextTask()`: Removes the task at the front of the pending queue, updates its status to "COMPLETED", and adds it to the completed tasks list. If the queue is empty, handle this gracefully.
 *         *   `viewPendingTasks()`: Prints the details of all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Prints the details of all tasks currently in the completed tasks list.
 *     *   Ensure proper encapsulation for all internal data structures.
 * 
 * 3.  **User Interface (Main Method):**
 *     *   The `main` method should be in a separate class (e.g., `TaskApp`).
 *     *   It should instantiate the `TaskProcessingSystem`.
 *     *   It must use a `Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (e.g., Add Task, Process Task, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu selection and call the appropriate methods of the `TaskProcessingSystem`.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Use `System.err.println()` to display error messages (e.g., invalid menu choice, empty task description, trying to process task when queue is empty).
 *     *   Use `System.out.println()` for all normal output (menu, prompts, task lists).
 *     *   Implement input validation where necessary (e.g., ensuring task description is not empty).
 *     *   Include class-wide exception handling using `try-catch` blocks within the `main` loop or specific operations to catch potential issues (e.g., issues with Scanner input, unexpected errors during processing).
 * 
 * 5.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Follow standard Java coding conventions.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and respond based on the chosen option.
 * *   Adding a task should confirm the task was added.
 * *   Processing a task should indicate which task was processed or if the queue was empty.
 * *   Viewing tasks should list tasks with their ID, description, and status.
 * *   Invalid input should result in an error message on `System.err`.
 * *   Exiting should terminate the program.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task 'Write report' added with ID: task-1
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task 'Prepare presentation' added with ID: task-2
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: task-1, Description: Write report, Status: PENDING
 * Task ID: task-2, Description: Prepare presentation, Status: PENDING
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task ID: task-1, Description: Write report, Status: PENDING
 * Task task-1 completed.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: task-2, Description: Prepare presentation, Status: PENDING
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: task-1, Description: Write report, Status: COMPLETED
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Implement the Java code for the `Task` class, `TaskProcessingSystem` class, and the `main` method demonstrating the required functionality and use of all specified Java components.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** Represents a single task with a unique ID, description, and status. It follows encapsulation principles with private fields and public getters. The constructor includes basic validation for the description. The `toString()` method provides a convenient way to print task details. An `AtomicInteger` is used in `TaskProcessingSystem` to generate simple, unique task IDs safely.
 * 
 * 2.  **TaskProcessingSystem Class:** This is the core class managing the tasks.
 *     *   It uses a `private Queue<Task> pendingTasks` implemented by `java.util.LinkedList`. The `Queue` interface is ideal here because tasks are processed in FIFO (First-In, First-Out) order â€“ the first task added is the first one processed. `LinkedList` is a common choice for implementing `Queue` due to efficient additions/removals from ends.
 *     *   It uses a `private List<Task> completedTasks` declared as the `List` interface type but implemented by `java.util.ArrayList`. This demonstrates programming to the interface. `ArrayList` is suitable for storing completed tasks as we primarily need to add to it and iterate through it, and random access (though not heavily used here) is efficient.
 *     *   `addTask()`: Creates a new `Task`, generates a unique ID, and adds it to the `pendingTasks` queue using `queue.add()`. It wraps the task creation in a `try-catch` to handle potential `IllegalArgumentException` from the `Task` constructor.
 *     *   `processNextTask()`: Checks if the queue is empty. If not, it uses `queue.poll()` to retrieve and remove the head of the queue. It updates the task's status and adds it to the `completedTasks` list using `list.add()`. It includes a `try-catch` block to handle potential errors during the processing step itself.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections and print task details. Iterating the `Queue` is done using a for-each loop, which traverses the elements without removing them.
 * 
 * 3.  **TaskApp Class (Main Method):**
 *     *   This class contains the `main` method, which serves as the application's entry point and user interface handler.
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `printMenu()` helper method displays the available options.
 *     *   A `switch` statement is used to direct the program flow based on the integer input received from the user. This is a clear and efficient way to handle multiple menu options.
 *     *   **Input Handling and Validation:** Inside the loop, there's a nested `try-catch` block specifically for handling the `Scanner` input. It checks if the input is an integer (`scanner.hasNextInt()`) before reading it. If not, it prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop. A `finally` block ensures the newline character after `nextInt()` is consumed by `scanner.nextLine()`.
 *     *   **Error Handling (`System.err`):** `System.err.println()` is used for displaying error messages, such as invalid menu choices, attempting to process an empty queue, or invalid task descriptions caught from the `addTask` method.
 *     *   **Normal Output (`System.out`):** All menu prompts, task details, and success messages are printed using `System.out.println()`.
 *     *   **Class-wide Exception Handling:** The entire `while` loop in `main` is wrapped in a `try-catch` block. This acts as a top-level handler for any unexpected exceptions that might occur anywhere within the loop, preventing the program from crashing abruptly and providing a final error message to `System.err`.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block outside the `while` loop to ensure the resource is released when the application exits, regardless of whether it exits normally or due to an exception.
 * 
 * This solution effectively integrates all the required components into a functional, well-structured, and robust application that simulates a practical task processing workflow.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // To generate unique IDs

// Represents a single task in the system
class Task {
    private String taskId;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    public Task(String taskId, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.status = "PENDING"; // New tasks start as PENDING
    }

    // Getters
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status (used internally by the system)
    void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the collection of tasks using a queue and a list
class TaskProcessingSystem {
    private Queue<Task> pendingTasks; // Queue for tasks waiting to be processed
    private List<Task> completedTasks; // List for tasks that are finished
    private AtomicInteger taskIdCounter; // Helper for generating unique task IDs

    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // Use LinkedList as Queue implementation
        this.completedTasks = new ArrayList<>(); // Use ArrayList as List implementation
        this.taskIdCounter = new AtomicInteger(0); // Initialize counter for IDs
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        try {
            // Task constructor validates description
            String newTaskId = "task-" + taskIdCounter.incrementAndGet();
            Task newTask = new Task(newTaskId, description);
            pendingTasks.add(newTask);
            System.out.println("Task '" + newTask.getDescription() + "' added with ID: " + newTask.getTaskId());
        } catch (IllegalArgumentException e) {
            // Re-throw or handle as needed, here we let the calling method handle it
            throw e;
        } catch (Exception e) {
            // Catch any other unexpected errors during task creation/addition
            System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list upon successful processing.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to process. The queue is empty.");
            return;
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess != null) {
            try {
                System.out.println("Processing task: " + taskToProcess);
                // Simulate processing time or complex logic if needed
                taskToProcess.setStatus("COMPLETED"); // Update status
                completedTasks.add(taskToProcess); // Add to completed list
                System.out.println("Task " + taskToProcess.getTaskId() + " completed.");
            } catch (Exception e) {
                // Handle errors that might occur during processing or status update
                System.err.println("An error occurred while processing task " + taskToProcess.getTaskId() + ": " + e.getMessage());
                // Optional: decide whether to re-add the task to the queue or log it as failed
            }
        }
    }

    /**
     * Prints all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Prints all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }
}

// Main application class to run the system
public class TaskApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessingSystem taskSystem = new TaskProcessingSystem();
        boolean running = true;

        // Class-wide exception handling using try-catch for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Default invalid choice
                try {
                    // Handle non-integer input
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                    } else {
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input
                        continue; // Skip to the next loop iteration
                    }
                } catch (Exception e) {
                    System.err.println("Error reading input: " + e.getMessage());
                    scanner.next(); // Attempt to clear the bad input
                    continue; // Skip to the next loop iteration
                } finally {
                    // Consume the newline character left by nextInt()
                    if (scanner.hasNextLine()) {
                         scanner.nextLine();
                    }
                }


                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            taskSystem.addTask(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;
                    case 2:
                        taskSystem.processNextTask();
                        break;
                    case 3:
                        taskSystem.viewPendingTasks();
                        break;
                    case 4:
                        taskSystem.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception mainException) {
            // Catch any unexpected exceptions that bubble up to the main loop
            System.err.println("An unrecoverable error occurred: " + mainException.getMessage());
            mainException.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
