/*
 * Exam Question #349
 * Generated on: 2025-05-11 22:58:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Management System. The system needs to manage a list of doctors, a waiting list of patients seeking appointments, and scheduled appointments.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Add new doctors to the system.
 *     *   Add new patients to a waiting list.
 *     *   Schedule appointments: Take the next patient from the waiting list and assign them to the doctor with the *fewest* currently scheduled appointments (appointments that are not yet marked as completed). If no doctors are available or no patients are waiting, handle this gracefully.
 *     *   Complete an appointment: Mark a scheduled appointment as completed based on user selection.
 *     *   List System State: Display the list of doctors, their scheduled appointments (distinguishing between scheduled and completed), and the current patient waiting list.
 *     *   Exit the application.
 * 
 * 2.  **Required Java Components:** Your solution *must* use ALL of the following:
 *     *   `java.util.Queue` (specifically `java.util.LinkedList` or `java.util.ArrayDeque` implementing `Queue`) for the patient waiting list.
 *     *   `java.util.ArrayList` for storing doctors and potentially appointments.
 *     *   `java.util.List` interface (declare variables using `List`, instantiate with `ArrayList`).
 *     *   `java.util.Scanner` for all user input.
 *     *   `switch` statement for handling the main menu options.
 *     *   `System.err` for displaying error messages (e.g., invalid input, system state errors like no doctors).
 *     *   `System.out` for displaying normal output (menu, lists, confirmations).
 *     *   Class-wide exception handling using `try-catch` blocks to manage potential runtime issues, especially related to user input and system operations.
 * 
 * 3.  **Best Practices:**
 *     *   Implement proper encapsulation using `private` fields and `public` methods where necessary.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and Javadoc documentation.
 *     *   Perform input validation to handle incorrect data types or out-of-range selections.
 *     *   Implement robust error handling using `try-catch` and conditional checks.
 *     *   Structure your code logically into appropriate classes (`Patient`, `Doctor`, `Appointment`, `HospitalSystem`).
 * 
 * **Classes to Create:**
 * 
 * *   `Patient`: Should have a name.
 * *   `Doctor`: Should have a name and specialty. It should also internally manage a list of appointments assigned to this doctor.
 * *   `Appointment`: Should link a `Patient` and a `Doctor`. It should have a status (e.g., `SCHEDULED`, `COMPLETED`).
 * *   `HospitalSystem`: The main class containing the `main` method and managing the lists of doctors, the patient waiting queue, and performing the core operations.
 * 
 * **Execution:**
 * 
 * The program should present a menu to the user upon startup and repeatedly prompt for input until the user chooses to exit.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * --- Hospital Management System ---
 * 1. Add Doctor
 * 2. Add Patient to Waiting List
 * 3. Schedule Appointment
 * 4. Complete Appointment
 * 5. List System State
 * 6. Exit
 * Enter choice: 1
 * Enter doctor name: Dr. Smith
 * Enter doctor specialty: Cardiology
 * Doctor Dr. Smith (Cardiology) added.
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 2
 * Enter patient name: Alice
 * Patient Alice added to waiting list.
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 2
 * Enter patient name: Bob
 * Patient Bob added to waiting list.
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 3
 * Attempting to schedule appointment...
 * Patient Alice scheduled with Dr. Smith.
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 5
 * --- System State ---
 * Doctors:
 * - Dr. Smith (Cardiology)
 *   Appointments:
 *   - [SCHEDULED] Alice with Dr. Smith
 * 
 * Waiting List:
 * - Bob
 * --------------------
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 4
 * --- Scheduled Appointments ---
 * 0: [SCHEDULED] Alice with Dr. Smith
 * Enter appointment number to complete: 0
 * Appointment 0 (Alice with Dr. Smith) marked as COMPLETED.
 * 
 * --- Hospital Management System ---
 * ... (menu repeats)
 * Enter choice: 5
 * --- System State ---
 * Doctors:
 * - Dr. Smith (Cardiology)
 *   Appointments:
 *   - [COMPLETED] Alice with Dr. Smith
 * 
 * Waiting List:
 * - Bob
 * --------------------
 * ...
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correctness and completeness of functionality.
 * *   Proper use of all required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, etc.).
 * *   Robustness of input validation and error handling.
 * *   Code structure and readability.
 * 
 * **Deliverable:**
 * 
 * Provide the complete Java source code for all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a basic Hospital Appointment Management System demonstrating the required Java concepts.
 * 
 * **Core Classes:**
 * 
 * *   `Patient`: A simple class holding the patient's `name`.
 * *   `Doctor`: Holds the doctor's `name` and `specialty`. Crucially, it maintains a `List<Appointment>` (`ArrayList`) to track appointments specifically assigned to this doctor. It also has a helper method `getActiveAppointmentCount()` to find doctors with fewer active appointments.
 * *   `Appointment`: Represents the link between a `Patient` and a `Doctor`. It includes an `AppointmentStatus` enum (`SCHEDULED`, `COMPLETED`) to track its state.
 * *   `HospitalSystem`: The main class orchestrating the system.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `waitingList` is declared as `Queue<Patient>` and instantiated using `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface. Patients are added using `offer()` and removed (when scheduled) using `poll()`. `peek()` is used to look at the next patient without removing them.
 * 2.  **`java.util.ArrayList`**: Used to store the `doctors` (`List<Doctor> doctors = new ArrayList<>();`) and the list of appointments within each `Doctor` object (`List<Appointment> scheduledAppointments = new ArrayList<>();`). A central `allAppointments` list (also `ArrayList`) is kept in `HospitalSystem` to easily list all appointments system-wide when completing one.
 * 3.  **`java.util.List` interface**: The `doctors` list and the `scheduledAppointments` lists within `Doctor` are declared using the `List` interface, adhering to the principle of programming to interfaces.
 * 4.  **`java.util.Scanner`**: A single `Scanner` instance is created in the `HospitalSystem` constructor and used across various methods (`addDoctor`, `addPatient`, `completeAppointment`, `run`) to read user input from `System.in`.
 * 5.  **`switch` statement**: The `run()` method uses a `while` loop and a `switch` statement based on the user's menu choice to direct execution to the appropriate method (`addDoctor`, `addPatient`, etc.).
 * 6.  **`System.err`**: Used to print error messages, such as invalid menu choices, input type mismatches, or system state errors (e.g., trying to schedule without doctors or patients). This distinguishes error output from normal program information.
 * 7.  **`System.out`**: Used for all standard output, including the menu, prompts, confirmation messages, and listing the system state.
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   The main `while` loop in the `run()` method is wrapped in a `try-catch` block (`catch (Exception e)`). This provides a top-level handler for any unexpected runtime exceptions that might occur within the main application loop or the methods it calls.
 *     *   More specific exception handling is implemented within methods where input is read. For example, `completeAppointment()` uses a `try-catch (InputMismatchException e)` specifically to handle cases where the user enters non-integer input when an appointment number is expected. This demonstrates handling anticipated errors gracefully at the point where they are likely to occur. The `scanner.nextLine()` call within the catch block is crucial to consume the invalid input and prevent an infinite loop.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Patient`, `Doctor`, and `Appointment` are `private`, with `public` getter methods provided only where necessary. The `HospitalSystem` manages its internal state (`doctors`, `waitingList`, `allAppointments`) through its public methods.
 * *   **Meaningful Names:** Class names (`Patient`, `Doctor`, `Appointment`, `HospitalSystem`), variable names (`waitingList`, `scheduledAppointments`, `nextPatient`, `bestDoctor`), and method names (`addDoctor`, `scheduleAppointment`, `listSystemState`) are descriptive.
 * *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes and key methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** Checks are performed to ensure input strings are not empty (`addDoctor`, `addPatient`). `completeAppointment` validates the user-entered index against the size of the scheduled appointments list. `InputMismatchException` handling validates that numeric input is actually a number.
 * *   **Error Handling:** Error conditions like empty waiting lists or no doctors are checked before attempting operations, and informative messages are printed to `System.err`. `try-catch` blocks handle input errors and potential runtime exceptions.
 * *   **Clean Code Structure:** The code is divided into logical classes, and the `HospitalSystem` class separates different functionalities into distinct methods, making the code modular and easier to understand. The `run()` method provides a clear entry point and control flow.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating advanced Java concepts like collection usage, object-oriented design, error handling, and input processing.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Appointment Status
enum AppointmentStatus {
    SCHEDULED,
    COMPLETED
}

// Represents a Patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a Doctor
class Doctor {
    private String name;
    private String specialty;
    private List<Appointment> scheduledAppointments; // Appointments assigned to this doctor

    public Doctor(String name, String specialty) {
        this.name = name;
        this.specialty = specialty;
        this.scheduledAppointments = new ArrayList<>();
    }

    public String getName() {
        return name;
    }

    public String getSpecialty() {
        return specialty;
    }

    public List<Appointment> getScheduledAppointments() {
        return scheduledAppointments;
    }

    /**
     * Gets the number of currently scheduled (not completed) appointments.
     * @return The count of active appointments.
     */
    public int getActiveAppointmentCount() {
        int count = 0;
        for (Appointment appt : scheduledAppointments) {
            if (appt.getStatus() == AppointmentStatus.SCHEDULED) {
                count++;
            }
        }
        return count;
    }

    public void addAppointment(Appointment appointment) {
        this.scheduledAppointments.add(appointment);
    }

    @Override
    public String toString() {
        return name + " (" + specialty + ")";
    }
}

// Represents an Appointment between a Patient and a Doctor
class Appointment {
    private Patient patient;
    private Doctor doctor;
    private AppointmentStatus status;

    public Appointment(Patient patient, Doctor doctor) {
        this.patient = patient;
        this.doctor = doctor;
        this.status = AppointmentStatus.SCHEDULED; // Default status
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public AppointmentStatus getStatus() {
        return status;
    }

    public void setStatus(AppointmentStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[" + status + "] " + patient.getName() + " with " + doctor.getName();
    }
}

// Main class managing the hospital system
public class HospitalSystem {

    private List<Doctor> doctors;
    private Queue<Patient> waitingList;
    private List<Appointment> allAppointments; // Keep a central list of all appointments
    private Scanner scanner;

    public HospitalSystem() {
        doctors = new ArrayList<>();
        waitingList = new LinkedList<>(); // LinkedList implements Queue
        allAppointments = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Management System ---");
        System.out.println("1. Add Doctor");
        System.out.println("2. Add Patient to Waiting List");
        System.out.println("3. Schedule Appointment");
        System.out.println("4. Complete Appointment");
        System.out.println("5. List System State");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a new doctor to the system.
     */
    private void addDoctor() {
        System.out.print("Enter doctor name: ");
        String name = scanner.nextLine();
        System.out.print("Enter doctor specialty: ");
        String specialty = scanner.nextLine();

        if (name.trim().isEmpty() || specialty.trim().isEmpty()) {
             System.err.println("Error: Doctor name and specialty cannot be empty.");
             return;
        }

        Doctor newDoctor = new Doctor(name, specialty);
        doctors.add(newDoctor);
        System.out.println("Doctor " + newDoctor + " added.");
    }

    /**
     * Adds a new patient to the waiting list queue.
     */
    private void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

         if (name.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }

        Patient newPatient = new Patient(name);
        waitingList.offer(newPatient); // offer is preferred over add for queues (returns false if fails, doesn't throw exception)
        System.out.println("Patient " + newPatient + " added to waiting list.");
    }

    /**
     * Schedules an appointment by taking the next patient from the queue
     * and assigning them to the doctor with the fewest active appointments.
     */
    private void scheduleAppointment() {
        System.out.println("Attempting to schedule appointment...");

        if (waitingList.isEmpty()) {
            System.err.println("Error: No patients in the waiting list.");
            return;
        }

        if (doctors.isEmpty()) {
            System.err.println("Error: No doctors available in the system.");
            return;
        }

        Patient nextPatient = waitingList.peek(); // Just peek for now, poll later if successful

        // Find doctor with the fewest active appointments
        Doctor bestDoctor = null;
        int minAppointments = Integer.MAX_VALUE;

        for (Doctor doctor : doctors) {
            int activeCount = doctor.getActiveAppointmentCount();
            if (activeCount < minAppointments) {
                minAppointments = activeCount;
                bestDoctor = doctor;
            }
        }

        if (bestDoctor != null) {
            // Now poll the patient from the queue as we have a doctor
            nextPatient = waitingList.poll();
            Appointment newAppointment = new Appointment(nextPatient, bestDoctor);
            bestDoctor.addAppointment(newAppointment);
            allAppointments.add(newAppointment);
            System.out.println("Patient " + nextPatient.getName() + " scheduled with " + bestDoctor.getName() + ".");
        } else {
             // This case should technically not be reached if doctors list is not empty,
             // but good for robustness if logic changes.
            System.err.println("Error: Could not find a suitable doctor.");
        }
    }

    /**
     * Lists scheduled appointments and allows the user to mark one as completed.
     */
    private void completeAppointment() {
        List<Appointment> scheduled = new ArrayList<>();
        for(Appointment appt : allAppointments) {
            if (appt.getStatus() == AppointmentStatus.SCHEDULED) {
                scheduled.add(appt);
            }
        }

        if (scheduled.isEmpty()) {
            System.out.println("No scheduled appointments to complete.");
            return;
        }

        System.out.println("--- Scheduled Appointments ---");
        for (int i = 0; i < scheduled.size(); i++) {
            System.out.println(i + ": " + scheduled.get(i));
        }

        System.out.print("Enter appointment number to complete: ");
        try {
            int choice = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            if (choice >= 0 && choice < scheduled.size()) {
                Appointment appointmentToComplete = scheduled.get(choice);
                appointmentToComplete.setStatus(AppointmentStatus.COMPLETED);
                System.out.println("Appointment " + choice + " (" + appointmentToComplete.getPatient().getName() + " with " + appointmentToComplete.getDoctor().getName() + ") marked as COMPLETED.");
            } else {
                System.err.println("Error: Invalid appointment number.");
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    /**
     * Displays the current state of the system: doctors, their appointments,
     * and the waiting list.
     */
    private void listSystemState() {
        System.out.println("--- System State ---");

        System.out.println("Doctors:");
        if (doctors.isEmpty()) {
            System.out.println("- No doctors in the system.");
        } else {
            for (Doctor doctor : doctors) {
                System.out.println("- " + doctor);
                if (doctor.getScheduledAppointments().isEmpty()) {
                    System.out.println("  Appointments: None");
                } else {
                    System.out.println("  Appointments:");
                    for (Appointment appt : doctor.getScheduledAppointments()) {
                         System.out.println("  - " + appt); // Appointment.toString() includes status
                    }
                }
            }
        }

        System.out.println("\nWaiting List:");
        if (waitingList.isEmpty()) {
            System.out.println("- Waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements
            waitingList.forEach(patient -> System.out.println("- " + patient));
        }
        System.out.println("--------------------");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character

                // Class-wide exception handling example:
                // The switch block and method calls within it are covered by this try-catch
                // for potential unexpected errors, although specific input errors are handled
                // within methods like completeAppointment().
                switch (choice) {
                    case 1:
                        addDoctor();
                        break;
                    case 2:
                        addPatient();
                        break;
                    case 3:
                        scheduleAppointment();
                        break;
                    case 4:
                        completeAppointment();
                        break;
                    case 5:
                        listSystemState();
                        break;
                    case 6:
                        System.out.println("Exiting Hospital Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during operation
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to standard error
            }
        }
        scanner.close();
    }

    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.run();
    }
}
