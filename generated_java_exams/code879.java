/*
 * Exam Question #879
 * Generated on: 2025-05-12 16:54:08
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Ticket Management System with Waiting List
 * 
 * **Objective:** Design and implement a command-line application in Java to manage ticket sales and a waiting list for a single event with a fixed capacity. This task requires demonstrating proficiency in using fundamental Java data structures and control flow mechanisms, alongside proper error handling and input validation.
 * 
 * **Scenario:** You are building a simplified system for managing tickets for a popular event. The event has a maximum number of attendees (capacity). Customers can buy tickets if available. If tickets are sold out, they can join a waiting list. If a ticket becomes available (due to cancellation), the first person on the waiting list should be offered the ticket automatically.
 * 
 * **Requirements:**
 * 
 * 1.  **Event Capacity:** The system must be initialized with a total capacity for the event.
 * 2.  **Data Structures:**
 *     *   Use a `List` (specifically `java.util.ArrayList`) to store the names (as `String`) of customers who have successfully purchased tickets.
 *     *   Use a `Queue` (specifically an implementation like `java.util.LinkedList` or `java.util.ArrayDeque`) to store the names (as `String`) of customers on the waiting list. The waiting list must operate in a First-In, First-Out (FIFO) manner.
 * 3.  **User Interface:** Provide a command-line interface using `java.util.Scanner` for user input. The program should present a menu of options to the user.
 * 4.  **Menu Options (using a `switch` statement):**
 *     *   `1: Buy Ticket`: Prompt for customer name. If `availableTickets > 0`, add the customer name to the ticket holders list and decrement `availableTickets`. If sold out, inform the user and ask if they want to join the waiting list. If the response is "yes" (case-insensitive), add them to the waiting list queue.
 *     *   `2: Join Waiting List`: Prompt for customer name and add them directly to the waiting list queue.
 *     *   `3: Cancel Ticket`: Prompt for customer name. If the customer name is found in the ticket holders list, remove it and increment `availableTickets`. If the waiting list is not empty after cancellation, automatically move the first person from the waiting list queue to the ticket holders list and decrement `availableTickets`. If the customer name is not found in the ticket holders list, display an error message.
 *     *   `4: Process Waiting List`: Explicitly attempt to move customers from the waiting list queue to the ticket holders list as long as tickets are available and the waiting list is not empty. Process customers from the queue in FIFO order.
 *     *   `5: View Status`: Display the total capacity, number of available tickets, number of ticket holders, the list of ticket holders, the size of the waiting list, and the list of people currently on the waiting list (in order).
 *     *   `6: Exit`: Terminate the program gracefully.
 * 5.  **Error Handling:**
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential `InputMismatchException` when the user enters non-numeric input where a number is expected (e.g., for the menu choice or initial capacity).
 *     *   Handle cases where a customer tries to cancel a ticket they don't hold.
 *     *   Use `System.err` to display all error messages (e.g., invalid input, customer not found, cannot perform action).
 *     *   Use `System.out` for all normal program output (menu, prompts, confirmations, status updates).
 * 6.  **Input Validation:** Validate user input where appropriate (e.g., ensure customer names are not empty).
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields).
 *     *   Include comments explaining the purpose of key methods or complex logic.
 *     *   Structure the code logically within a class.
 * 
 * **Expected Output:** The program should run interactively, presenting the menu, taking user input, performing the requested operations, and displaying relevant output or error messages until the user chooses to exit. The output for status updates should clearly list ticket holders and waiting list members.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Welcome to the Event Ticket Management System!
 * Please enter the total event capacity: 3
 * Event system initialized with capacity: 3
 * 
 * Choose an option:
 * 1: Buy Ticket
 * 2: Join Waiting List
 * 3: Cancel Ticket
 * 4: Process Waiting List
 * 5: View Status
 * 6: Exit
 * Enter choice: 1
 * Enter customer name to buy ticket: Alice
 * Ticket purchased successfully for Alice.
 * 
 * Choose an option:
 * ...
 * Enter choice: 1
 * Enter customer name to buy ticket: Bob
 * Ticket purchased successfully for Bob.
 * 
 * Choose an option:
 * ...
 * Enter choice: 1
 * Enter customer name to buy ticket: Charlie
 * Ticket purchased successfully for Charlie.
 * 
 * Choose an option:
 * ...
 * Enter choice: 1
 * Enter customer name to buy ticket: David
 * Event is sold out. David, would you like to join the waiting list? (yes/no)
 * yes
 * David added to the waiting list. Position: 1
 * 
 * Choose an option:
 * ...
 * Enter choice: 5
 * 
 * --- Event Status ---
 * Total Capacity: 3
 * Available Tickets: 0
 * Ticket Holders (3):
 *   - Alice
 *   - Bob
 *   - Charlie
 * Waiting List Size: 1
 * Waiting List:
 *   1. David
 * --------------------
 * 
 * Choose an option:
 * ...
 * Enter choice: 3
 * Enter customer name to cancel ticket: Bob
 * Ticket for Bob cancelled.
 * Attempting to process waiting list...
 * Ticket issued to David from waiting list.
 * 
 * Choose an option:
 * ...
 * Enter choice: 5
 * 
 * --- Event Status ---
 * Total Capacity: 3
 * Available Tickets: 0
 * Ticket Holders (3):
 *   - Alice
 *   - Charlie
 *   - David
 * Waiting List Size: 0
 * Waiting List:
 *   None
 * --------------------
 * 
 * Choose an option:
 * ...
 * Enter choice: 6
 * Exiting Event System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements the `EventSystem` class to manage event tickets and a waiting list according to the requirements.
 * 
 * 1.  **Data Structures:**
 *     *   `ticketHolders`: A `java.util.ArrayList<String>` is used to store the names of customers who have tickets. `ArrayList` is suitable because we need to easily add, remove, and iterate through the list of holders, and order doesn't strictly matter beyond display.
 *     *   `waitingList`: A `java.util.Queue<String>` is used, specifically implemented with `java.util.LinkedList`. `Queue` is the perfect structure for a waiting list because it enforces a First-In, First-Out (FIFO) order, ensuring that the person who has been waiting the longest is the first to get an available ticket. Methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used, which are standard `Queue` operations.
 * 
 * 2.  **Encapsulation:** The event's state (`totalCapacity`, `availableTickets`, `ticketHolders`, `waitingList`) is kept private within the `EventSystem` class, accessible only through public methods (`buyTicket`, `cancelTicket`, `viewStatus`, etc.).
 * 
 * 3.  **User Interface (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   A `java.util.Scanner` reads input from `System.in`.
 *     *   A `while` loop keeps the program running until the user chooses to exit.
 *     *   A `switch` statement is used to handle the different menu options provided to the user.
 *     *   `System.out.println` is used for displaying the menu, prompts, confirmations, and status reports.
 *     *   `System.err.println` is used exclusively for displaying error messages, such as invalid user input or business logic errors (e.g., trying to cancel a ticket not held).
 * 
 * 4.  **Functionality:**
 *     *   **`buyTicket`:** Checks availability. If available, adds to `ticketHolders` and decrements count. If sold out, it interacts with the user via the passed `Scanner` to offer joining the waiting list and calls `joinWaitingList` if confirmed. Includes checks for duplicate names.
 *     *   **`joinWaitingList`:** Adds a customer name to the `waitingList` queue using `offer()`. Includes checks for duplicate names.
 *     *   **`cancelTicket`:** Attempts to remove the customer name from `ticketHolders`. If successful, increments available tickets. Crucially, it then calls `processWaitingList` to automatically fill the cancelled spot from the queue if possible. Reports an error if the customer is not found.
 *     *   **`processWaitingList`:** Iterates while tickets are available and the waiting list is not empty. It uses `poll()` to get the next customer from the queue (removing them) and adds them to the `ticketHolders` list, decrementing available tickets.
 *     *   **`viewStatus`:** Prints a formatted summary of the event's state, including iterating through the `ticketHolders` list and the `waitingList` queue (using an enhanced for loop, which iterates without removing elements from the queue).
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block in the `main` method handles the initial capacity input, specifically catching `InputMismatchException` if the user enters non-numeric text. It also catches `IllegalArgumentException` thrown by the constructor for invalid capacity.
 *     *   The main program loop in `main` is wrapped in a `try-catch` block that catches `InputMismatchException` for invalid menu choices. This prevents the program from crashing on bad input and allows the loop to continue after reporting the error to `System.err`.
 *     *   A general `catch (Exception e)` is included in the main loop to catch any other unexpected runtime errors during operation, printing the error message and stack trace to `System.err`.
 *     *   Specific business logic errors (like cancelling a non-existent ticket or invalid customer name) are handled within the respective methods by printing error messages to `System.err` and returning, rather than throwing exceptions, which is a simpler approach suitable for an exam context.
 * 
 * 6.  **Input Validation:** Basic validation is performed to check if customer names are null or empty strings before processing them.
 * 
 * 7.  **Best Practices:** The code uses clear variable and method names (`availableTickets`, `buyTicket`, `waitingList.offer`), follows standard Java conventions, and includes comments explaining the purpose of the class and key methods. Fields are private, adhering to encapsulation principles.
 * 
 * This solution effectively integrates all the required Java components to build a functional and interactive system that demonstrates an understanding of data structures, control flow, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // Implementation of Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // For handling non-integer input

/**
 * Manages ticket sales and a waiting list for an event.
 */
public class EventSystem {

    private int totalCapacity;
    private int availableTickets;
    private List<String> ticketHolders; // List of customers with tickets
    private Queue<String> waitingList; // Queue of customers on the waiting list (FIFO)

    /**
     * Constructs an EventSystem with a specified capacity.
     *
     * @param capacity The total number of tickets available for the event.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public EventSystem(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.totalCapacity = capacity;
        this.availableTickets = capacity;
        this.ticketHolders = new ArrayList<>(); // Use ArrayList for dynamic resizing and easy iteration/removal
        this.waitingList = new LinkedList<>(); // Use LinkedList as a Queue implementation
    }

    /**
     * Attempts to buy a ticket for a customer. If sold out, offers to join waiting list.
     *
     * @param customerName The name of the customer.
     * @param scanner      The Scanner object for potential waiting list confirmation input.
     */
    public void buyTicket(String customerName, Scanner scanner) {
        // Input validation
        if (customerName == null || customerName.trim().isEmpty()) {
            System.err.println("Error: Customer name cannot be empty.");
            return;
        }
        String trimmedName = customerName.trim();

        // Prevent duplicates if they already hold a ticket or are on the list
        if (ticketHolders.contains(trimmedName)) {
            System.out.println(trimmedName + " already has a ticket.");
            return;
        }
        if (waitingList.contains(trimmedName)) {
            System.out.println(trimmedName + " is already on the waiting list.");
            return;
        }

        if (availableTickets > 0) {
            ticketHolders.add(trimmedName);
            availableTickets--;
            System.out.println("Ticket purchased successfully for " + trimmedName + ".");
        } else {
            System.out.println("Event is sold out. " + trimmedName + ", would you like to join the waiting list? (yes/no)");
            // Use scanner passed from main for this specific user interaction point
            String response = scanner.nextLine().trim().toLowerCase();
            if (response.equals("yes")) {
                joinWaitingList(trimmedName); // Reuse the joinWaitingList method
            } else {
                System.out.println(trimmedName + " did not join the waiting list.");
            }
        }
    }

    /**
     * Adds a customer directly to the waiting list.
     *
     * @param customerName The name of the customer.
     */
    public void joinWaitingList(String customerName) {
         // Input validation
        if (customerName == null || customerName.trim().isEmpty()) {
            System.err.println("Error: Customer name cannot be empty.");
            return;
        }
        String trimmedName = customerName.trim();

         // Prevent duplicates if they already hold a ticket or are on the list
        if (ticketHolders.contains(trimmedName)) {
            System.out.println(trimmedName + " already has a ticket. Cannot join waiting list.");
            return;
        }
        if (waitingList.contains(trimmedName)) {
            System.out.println(trimmedName + " is already on the waiting list.");
            return;
        }

        waitingList.offer(trimmedName); // offer() is generally preferred over add() for queues as it handles capacity constraints gracefully (though LinkedList is unbounded)
        System.out.println(trimmedName + " added to the waiting list. Position: " + waitingList.size());
    }

    /**
     * Cancels a ticket for a customer and potentially processes the waiting list.
     *
     * @param customerName The name of the customer whose ticket to cancel.
     */
    public void cancelTicket(String customerName) {
        // Input validation
        if (customerName == null || customerName.trim().isEmpty()) {
            System.err.println("Error: Customer name cannot be empty.");
            return;
        }
        String trimmedName = customerName.trim();

        if (ticketHolders.remove(trimmedName)) {
            availableTickets++;
            System.out.println("Ticket for " + trimmedName + " cancelled.");

            // Automatically offer the newly available ticket to the next person on the waiting list
            processWaitingList(); // Call the method to check and process waiting list
        } else {
            System.err.println("Error: " + trimmedName + " not found in ticket holders list. Cannot cancel ticket.");
        }
    }

    /**
     * Attempts to move customers from the waiting list to ticket holders if tickets are available.
     */
    public void processWaitingList() {
        System.out.println("Attempting to process waiting list...");
        // Process waiting list as long as there are tickets and people waiting
        while (availableTickets > 0 && !waitingList.isEmpty()) {
            String nextCustomer = waitingList.poll(); // Get and remove the head of the queue

            // Should not be null due to isEmpty() check, but good practice
            if (nextCustomer != null) {
                 // Add the customer to ticket holders list
                ticketHolders.add(nextCustomer);
                availableTickets--;
                System.out.println("Ticket issued to " + nextCustomer + " from waiting list.");
            }
        }

        // Report status after processing
        if (waitingList.isEmpty()) {
             System.out.println("Waiting list is now empty.");
        } else if (availableTickets == 0) {
             System.out.println("No tickets available to process waiting list further.");
        } else {
             // This case shouldn't be reached if the loop condition is correct
             System.out.println("Processing finished.");
        }
    }

    /**
     * Displays the current status of the event tickets and waiting list.
     */
    public void viewStatus() {
        System.out.println("\n--- Event Status ---");
        System.out.println("Total Capacity: " + totalCapacity);
        System.out.println("Available Tickets: " + availableTickets);
        System.out.println("Ticket Holders (" + ticketHolders.size() + "):");
        if (ticketHolders.isEmpty()) {
            System.out.println("  None");
        } else {
            // Iterate through the list to display holders
            for (String holder : ticketHolders) {
                System.out.println("  - " + holder);
            }
        }

        System.out.println("Waiting List Size: " + waitingList.size());
        System.out.println("Waiting List (FIFO Order):");
        if (waitingList.isEmpty()) {
             System.out.println("  None");
        } else {
             // Iterate through the queue without removing elements to display order
             int position = 1;
             for (String waitingCustomer : waitingList) {
                 System.out.println("  " + position++ + ". " + waitingCustomer);
             }
        }
        System.out.println("--------------------\n");
    }

    /**
     * Main method to run the Event Ticket Management System.
     * Handles user interaction loop and top-level exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventSystem eventSystem = null; // System instance

        // --- System Setup Phase ---
        try {
            System.out.println("Welcome to the Event Ticket Management System!");
            System.out.print("Please enter the total event capacity: ");
            int capacity = scanner.nextInt();
            scanner.nextLine(); // Consume the leftover newline character after reading int

            eventSystem = new EventSystem(capacity);
            System.out.println("Event system initialized with capacity: " + capacity);

        } catch (InputMismatchException e) {
            // Handles non-integer input for capacity
            System.err.println("Invalid input for capacity. Please enter a whole number.");
            // Consume the invalid input to prevent infinite loop
            scanner.nextLine();
            System.err.println("System setup failed. Exiting.");
            scanner.close(); // Close scanner before exiting
            return; // Exit the program
        } catch (IllegalArgumentException e) {
             // Handles non-positive capacity from constructor
             System.err.println("Error during setup: " + e.getMessage());
             System.err.println("System setup failed. Exiting.");
             scanner.close(); // Close scanner before exiting
             return; // Exit the program
        } catch (Exception e) {
             // Catch any other unexpected error during setup
             System.err.println("An unexpected error occurred during setup: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream
             scanner.close(); // Close scanner before exiting
             return; // Exit the program
        }

        // --- Main Program Loop ---
        boolean running = true;
        while (running) {
            System.out.println("\n--- Menu ---");
            System.out.println("1: Buy Ticket");
            System.out.println("2: Join Waiting List");
            System.out.println("3: Cancel Ticket");
            System.out.println("4: Process Waiting List");
            System.out.println("5: View Status");
            System.out.println("6: Exit");
            System.out.print("Enter choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                // Use switch for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter customer name to buy ticket: ");
                        String buyName = scanner.nextLine();
                        // Pass scanner to buyTicket for potential waiting list prompt
                        eventSystem.buyTicket(buyName, scanner);
                        break;
                    case 2:
                        System.out.print("Enter customer name to join waiting list: ");
                        String waitName = scanner.nextLine();
                        eventSystem.joinWaitingList(waitName);
                        break;
                    case 3:
                        System.out.print("Enter customer name to cancel ticket: ");
                        String cancelName = scanner.nextLine();
                        eventSystem.cancelTicket(cancelName);
                        break;
                    case 4:
                        eventSystem.processWaitingList();
                        break;
                    case 5:
                        eventSystem.viewStatus();
                        break;
                    case 6:
                        System.out.println("Exiting Event System. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handles integer input that is not a valid menu option
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Handles non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number for your choice.");
                // Consume the invalid input to prevent infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the main loop operations
                System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream for debugging
            }
        }

        scanner.close(); // Close the scanner when the program exits
    }
}
