/*
 * Exam Question #745
 * Generated on: 2025-05-12 16:34:36
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Resource Allocation and Task Processing System
 * 
 * **Objective:** Design and implement a simple command-line application in Java that simulates a system managing a queue of tasks requiring specific resources from a pool. This task assesses your ability to use fundamental Java collections, control flow statements, exception handling, and adhere to good programming practices.
 * 
 * **Problem Description:**
 * 
 * You are required to build a **Resource Allocation and Task Processing System**. This system will manage incoming tasks in a queue and allocate resources from a predefined pool to process these tasks.
 * 
 * The system should offer the following functionalities via a command-line interface:
 * 
 * 1.  **Add New Task:** Allow the user to add a new task to the processing queue. Each task needs a description and specifies the ID of a required resource from the pool.
 * 2.  **Process Next Task:** Attempt to process the task at the front of the queue. To process a task, the system checks if the resource required by that task is available in the resource pool.
 *     *   If the required resource is **available**: The resource is conceptually allocated (marked as busy), the task is removed from the queue, and the system reports successful processing. For simplicity in this exercise, the resource is immediately made available again after processing is reported.
 *     *   If the required resource is **not available**: The task remains at the front of the queue, and the system reports that the resource is busy and processing failed for this task.
 * 3.  **View Task Queue:** Display all tasks currently waiting in the processing queue in the order they will be processed.
 * 4.  **View Resource Pool:** Display the status (ID, name, and availability) of all resources in the pool.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your Java solution must strictly use **ALL** of the following components:
 * 
 * *   `java.util.Queue`: To manage the task queue (First-In, First-Out). Use a concrete implementation like `java.util.LinkedList`.
 * *   `java.util.ArrayList`: As the underlying data structure to store the resources in the resource pool.
 * *   `java.util.List` interface: Declare the variable holding the resource pool using the `List` interface type.
 * *   `java.util.Scanner`: To read user input (menu choices, task details) from `System.in`.
 * *   `switch` statement: To handle the different menu options selected by the user.
 * *   `System.err`: To print all error messages (e.g., invalid input, resource unavailability during processing).
 * *   `System.out`: To print all normal output (menus, prompts, success messages, lists).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust handling for potential issues, particularly around user input (e.g., `InputMismatchException`) and potentially during task processing.
 * 
 * **Initial State:**
 * 
 * The system should be initialized with a few predefined resources in the resource pool. For example:
 * *   Resource ID: 101, Name: "Server A", Available: true
 * *   Resource ID: 102, Name: "Server B", Available: true
 * *   Resource ID: 103, Name: "Database C", Available: true
 * 
 * **Best Practices:**
 * 
 * Your code should demonstrate good programming practices, including:
 * *   **Encapsulation:** Use private fields and provide public methods (getters, setters where necessary, or action methods) for classes like `Task` and `Resource`.
 * *   **Meaningful Names:** Use descriptive names for variables, methods, and classes.
 * *   **Comments & Documentation:** Include comments to explain complex logic and Javadoc-style comments for classes and methods.
 * *   **Input Validation:** Validate user input where appropriate (e.g., ensure a valid resource ID is entered when adding a task).
 * *   **Clean Code Structure:** Organize your code into logical classes and methods.
 * 
 * **Expected User Interaction and Output:**
 * 
 * The system should continuously display the menu after each operation until the user chooses to exit.
 * 
 * *   **Menu:** Display options 1-5 and 0 for Exit.
 * *   **Adding Task:** Prompt user for description and resource ID. Confirm task added. If resource ID is invalid, print error to `System.err`.
 * *   **Processing Task (Success):** Print messages indicating the task being processed, the resource used, success confirmation, and resource availability being restored.
 * *   **Processing Task (Failure):** Print messages indicating the task being processed, the required resource, and an error message to `System.err` stating the resource is busy and the task remains in the queue.
 * *   **Viewing Queue/Resources:** Print the list of items or indicate if the list is empty to `System.out`.
 * *   **Invalid Menu Choice or Input:** Print an error message to `System.err` and handle the error gracefully (e.g., consume invalid input, re-prompt).
 * 
 * Your submission should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of ALL specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the task processing logic (queue management, resource checking/allocation).
 * *   Robust error handling and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Clear and correct output as described.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Resource Allocation and Task Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Task`: A simple class encapsulating task details (ID, description, required resource ID). It follows encapsulation with private fields and public getters.
 *     *   `Resource`: A class representing a resource with an ID, name, and availability status. It also uses encapsulation with private fields and public getters/setters.
 *     *   `TaskProcessingSystem`: The main class containing the core logic. It holds the `taskQueue` and `resourcePool` and manages user interaction.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: The `taskQueue` field is declared as `java.util.Queue<Task>` and initialized with `java.util.LinkedList`, correctly implementing the FIFO behavior required for a queue. Tasks are added using `add()` and processed using `peek()` (to check before removing) and `remove()`. Iteration for viewing the queue is done using an enhanced for loop, which is safe as it doesn't remove elements.
 *     *   `ArrayList`: The `resourcePool` field is initialized using `new ArrayList<>()`, providing a dynamic list to store `Resource` objects. Resources are added during initialization and accessed/searched within the list.
 *     *   `List interface`: The `resourcePool` field is declared as `java.util.List<Resource>`, demonstrating the use of the interface type for the variable, which is a good practice for flexibility.
 *     *   `Scanner`: A `java.util.Scanner` object is used to read user input for menu choices, task descriptions, and required resource IDs from `System.in`. Care is taken to handle newline characters after reading integers (`scanner.nextLine()`).
 *     *   `switch` statement: The `run()` method uses a `switch` statement to direct the program flow based on the user's menu choice, calling the appropriate methods (`addTask`, `processNextTask`, etc.).
 *     *   `System.err`: Error messages, such as invalid input formats, invalid resource IDs, or resource unavailability during processing, are printed to `System.err`.
 *     *   `System.out`: All normal output, including the menu, prompts, success messages, and the contents of the queue and resource pool, is printed to `System.out`.
 *     *   `try-catch` blocks:
 *         *   The `run()` method contains a `try-catch` block to handle potential `InputMismatchException` when reading the menu choice, preventing the program from crashing on non-integer input and consuming the invalid token. It also includes a general `catch (Exception e)` for any other unexpected runtime errors in the main loop.
 *         *   The `addTask()` method includes a `try-catch(InputMismatchException e)` specifically for reading the required resource ID, handling non-integer input during task creation. It also validates if the entered resource ID corresponds to an existing resource.
 *         *   The `processNextTask()` method includes a general `catch (Exception e)` to handle potential issues that might arise during the processing logic (e.g., if `getResourceById` returned null unexpectedly, though input validation minimizes this risk).
 * 
 * 3.  **Task Processing Logic:**
 *     *   `addTask()`: Prompts for user input, creates a `Task` object with a simple auto-generated ID, validates the resource ID, and adds the task to the `taskQueue` using `add()`.
 *     *   `processNextTask()`: Checks if the queue is empty. If not, it uses `peek()` to look at the next task. It finds the required resource in the `resourcePool` using the helper method `getResourceById`. It checks the resource's availability. If available, it marks the resource busy, removes the task from the queue using `remove()`, reports success, and immediately marks the resource available again (as per the simplified requirement). If the resource is not available, it reports the failure to `System.err`, and the task remains in the queue because `remove()` was not called.
 * 
 * 4.  **Resource Management:**
 *     *   Resources are stored in an `ArrayList` and managed via the `Resource` class's `isAvailable()` and `setAvailable()` methods.
 *     *   The `getResourceById()` helper method demonstrates searching within the `ArrayList`.
 * 
 * 5.  **Best Practices Implementation:**
 *     *   Encapsulation is used in `Task` and `Resource`.
 *     *   Method and variable names are descriptive (e.g., `taskQueue`, `processNextTask`, `requiredResourceId`).
 *     *   Comments explain the purpose of classes, methods, and significant code blocks.
 *     *   Input validation is present for resource IDs and menu choices.
 *     *   The code is organized into logical units (`Task`, `Resource`, `TaskProcessingSystem`).
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating an understanding of data structures, control flow, error handling, and object-oriented principles suitable for an advanced exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation for List
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task that needs processing, requiring a specific resource.
 */
class Task {
    private int id;
    private String description;
    private int requiredResourceId;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param requiredResourceId The ID of the resource needed to process this task.
     */
    public Task(int id, String description, int requiredResourceId) {
        this.id = id;
        this.description = description;
        this.requiredResourceId = requiredResourceId;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getRequiredResourceId() {
        return requiredResourceId;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', RequiredResourceID=" + requiredResourceId + "]";
    }
}

/**
 * Represents a resource available in the pool, required by tasks.
 */
class Resource {
    private int id;
    private String name;
    private boolean available;

    /**
     * Constructs a new Resource.
     * @param id The unique ID of the resource.
     * @param name The name of the resource.
     */
    public Resource(int id, String name) {
        this.id = id;
        this.name = name;
        this.available = true; // Resources are initially available
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isAvailable() {
        return available;
    }

    // --- Setter ---
    public void setAvailable(boolean available) {
        this.available = available;
    }

    /**
     * Provides a string representation of the Resource.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Resource [ID=" + id + ", Name='" + name + "', Available=" + available + "]";
    }
}

/**
 * The main system managing the task queue and resource pool.
 */
public class TaskProcessingSystem {
    // Use Queue interface, implemented by LinkedList for FIFO behavior
    private Queue<Task> taskQueue;
    // Use List interface, implemented by ArrayList for dynamic resizing and element access
    private List<Resource> resourcePool;
    private Scanner scanner;
    private int nextTaskId = 1; // Simple counter for generating unique task IDs

    /**
     * Constructs the TaskProcessingSystem, initializing the queue, pool, and scanner.
     * Adds initial resources to the pool.
     */
    public TaskProcessingSystem() {
        taskQueue = new LinkedList<>(); // Initialize the task queue
        resourcePool = new ArrayList<>(); // Initialize the resource pool

        // Add some initial resources to the pool
        resourcePool.add(new Resource(101, "Server A"));
        resourcePool.add(new Resource(102, "Server B"));
        resourcePool.add(new Resource(103, "Database C"));

        scanner = new Scanner(System.in); // Initialize the scanner

        System.out.println("--- Task Processing System Initialized ---");
        System.out.println("Initial Resources Loaded: " + resourcePool.size());
        viewResourcePool(); // Show initial resources
        System.out.println("------------------------------------------");
    }

    /**
     * Adds a new task based on user input to the task queue.
     * Includes input validation for the required resource ID.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");

        // Consume any leftover newline character from previous input
        scanner.nextLine();

        System.out.print("Enter Task Description: ");
        String description = scanner.nextLine();

        int requiredResourceId = -1;
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter Required Resource ID (e.g., 101, 102, 103): ");
            try {
                requiredResourceId = scanner.nextInt();
                // Validate if the entered resource ID exists in the pool
                if (getResourceById(requiredResourceId) != null) {
                    validInput = true;
                } else {
                    // Print error to System.err if resource ID is invalid
                    System.err.println("Error: Invalid Resource ID. Please enter a valid ID from the resource pool.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for resource ID
                System.err.println("Error: Invalid input. Please enter a number for the Resource ID.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            }
        }
        // Consume the leftover newline after reading the integer ID
        scanner.nextLine();

        Task newTask = new Task(nextTaskId++, description, requiredResourceId);
        taskQueue.add(newTask); // Add the new task to the queue
        System.out.println("Task added to queue: " + newTask);
    }

    /**
     * Attempts to process the next task from the queue.
     * Requires the task's needed resource to be available.
     */
    public void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");

        // Check if the queue is empty
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty. Nothing to process.");
            return;
        }

        // Peek at the first task without removing it yet
        Task taskToProcess = taskQueue.peek();
        System.out.println("Attempting to process: " + taskToProcess);

        try {
            // Find the required resource in the pool
            Resource requiredResource = getResourceById(taskToProcess.getRequiredResourceId());

            // This case should ideally not happen if addTask validates resource ID,
            // but included for robustness against unexpected task data.
            if (requiredResource == null) {
                 System.err.println("Error: Task ID " + taskToProcess.getId() + " requires unknown resource ID " + taskToProcess.getRequiredResourceId() + ". Skipping task.");
                 taskQueue.remove(); // Remove the problematic task from the queue
                 return;
            }

            // Check if the required resource is available
            if (requiredResource.isAvailable()) {
                // Simulate resource allocation (mark busy)
                requiredResource.setAvailable(false);

                // Dequeue the task as it's being processed
                Task processedTask = taskQueue.remove();

                System.out.println("Successfully processed Task ID " + processedTask.getId() + " using Resource ID " + requiredResource.getId());

                // Simulate resource deallocation immediately after processing (simplification)
                requiredResource.setAvailable(true);
                System.out.println("Resource ID " + requiredResource.getId() + " is now available again.");

            } else {
                // Resource is not available
                // Print error to System.err
                System.err.println("Error: Resource ID " + requiredResource.getId() + " required by Task ID " + taskToProcess.getId() + " is currently busy. Task remains in queue.");
                // Task remains in the queue because we used peek() and didn't remove it.
            }
        } catch (Exception e) {
             // Catch any unexpected errors during the processing logic
             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
             // e.printStackTrace(); // Uncomment for detailed debugging in case of unexpected exceptions
        }
    }

    /**
     * Displays all tasks currently waiting in the queue.
     */
    public void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
            return;
        }

        // Iterate through the queue elements without removing them
        int index = 1;
        for (Task task : taskQueue) {
            System.out.println(index++ + ". " + task);
        }
    }

    /**
     * Displays the status of all resources in the pool.
     */
    public void viewResourcePool() {
        System.out.println("\n--- Resource Pool Status ---");
        if (resourcePool.isEmpty()) {
            System.out.println("No resources available in the pool.");
            return;
        }
        // Iterate through the resource list
        for (Resource resource : resourcePool) {
            System.out.println(resource);
        }
    }

    /**
     * Helper method to find a resource by its ID in the resource pool.
     * @param resourceId The ID of the resource to find.
     * @return The Resource object if found, otherwise null.
     */
    private Resource getResourceById(int resourceId) {
        // Iterate through the resource list to find the resource by ID
        for (Resource resource : resourcePool) {
            if (resource.getId() == resourceId) {
                return resource;
            }
        }
        return null; // Resource not found
    }

    /**
     * Runs the main application loop, displaying the menu and handling user input.
     * Includes class-wide exception handling for the main loop.
     */
    public void run() {
        int choice = -1; // Initialize choice to a non-exit value

        // Main loop continues until the user chooses to exit (choice 0)
        while (choice != 0) {
            displayMenu(); // Show the menu
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read user's menu choice

                // Use switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        processNextTask(); // Call method to process the next task
                        break;
                    case 3:
                        viewTaskQueue(); // Call method to view the queue
                        break;
                    case 4:
                        viewResourcePool(); // Call method to view resources
                        break;
                    case 0:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break; // Exit the loop
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling for non-integer input in the main menu
                System.err.println("Error: Invalid input. Please enter a number for the menu choice.");
                scanner.next(); // Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to ensure the loop continues
            } catch (Exception e) {
                 // Catch any other unexpected exceptions that might occur in the loop
                 System.err.println("An unexpected error occurred in the main loop: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Resource Pool");
        System.out.println("0. Exit");
        System.out.println("---------------------------------");
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem(); // Create an instance of the system
        system.run(); // Start the system's main loop
    }
}
