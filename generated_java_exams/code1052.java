/*
 * Exam Question #1052
 * Generated on: 2025-05-12 17:18:23
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Support Ticket Management System Implementation
 * 
 * **Problem Description:**
 * 
 * You are required to develop a command-line application for a simplified Support Ticket Management System. This system will help a small support team manage incoming technical support requests. The system should allow users to add new tickets, view tickets waiting for processing, process the next ticket in the queue, and view tickets that have already been resolved.
 * 
 * Your implementation must demonstrate a strong understanding of core Java concepts, including collections, user input handling, control flow, encapsulation, and exception handling.
 * 
 * **Specific Requirements:**
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Create a public class named `SupportTicket`.
 *     *   It must have the following **private** fields:
 *         *   `ticketId` (int): A unique identifier for the ticket.
 *         *   `description` (String): A brief description of the issue.
 *         *   `status` (String): Represents the current state of the ticket (e.g., "PENDING", "PROCESSED").
 *     *   Provide a public constructor that accepts the `ticketId` and `description`. The initial `status` should always be "PENDING".
 *     *   Include public getter methods for `ticketId`, `description`, and `status`.
 *     *   Include a public method `markAsProcessed()` that changes the ticket's status to "PROCESSED".
 *     *   Override the `toString()` method to provide a user-friendly string representation of the ticket (e.g., "Ticket #ID (STATUS): Description").
 * 
 * 2.  **`TicketManager` Class:**
 *     *   Create a public class named `TicketManager`.
 *     *   It must contain a **private** `java.util.Queue<SupportTicket>` to manage tickets that are waiting to be processed (pending tickets). Use a concrete implementation of `Queue` (e.g., `LinkedList`).
 *     *   It must contain a **private** `java.util.List<SupportTicket>` to store tickets that have been processed (archived tickets). This list must be implemented using `java.util.ArrayList`.
 *     *   Include a private counter (`int nextTicketId`) to generate sequential, unique ticket IDs starting from 1.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `SupportTicket` using the next available ID and the provided description, then adds it to the pending queue. Increment the ID counter.
 *         *   `viewPendingTickets()`: Prints the details of all tickets currently in the pending queue, ordered by their position in the queue, without removing them. If the queue is empty, print a "No pending tickets." message.
 *         *   `processNextTicket()`: Removes the ticket at the front of the pending queue, updates its status to "PROCESSED" using the `markAsProcessed()` method, and adds it to the archived tickets list. If the pending queue is empty when this method is called, print an error message to `System.err`.
 *         *   `viewArchivedTickets()`: Prints the details of all tickets in the archived list. If the list is empty, print a "No archived tickets." message.
 * 
 * 3.  **`SupportSystemApp` Class (Main Application):**
 *     *   Create a public class named `SupportSystemApp` containing the standard `public static void main(String[] args)` method.
 *     *   Inside the `main` method:
 *         *   Instantiate a `TicketManager` object.
 *         *   Use a `java.util.Scanner` object to read user input from the console (`System.in`).
 *         *   Present a menu to the user with the following options:
 *             1. Add New Ticket
 *             2. View Pending Tickets
 *             3. Process Next Ticket
 *             4. View Archived Tickets
 *             5. Exit
 *         *   Implement a loop that continuously displays the menu and processes user input until the user selects the "Exit" option.
 *         *   Use a `switch` statement to handle the user's menu choice, calling the appropriate methods on the `TicketManager`.
 *         *   **Input Validation:** When adding a new ticket (Option 1), prompt the user for a description. Validate that the entered description is not null, empty, or contains only whitespace. If the description is invalid, print an error message to `System.err` and do *not* add the ticket.
 *         *   **Output:** Use `System.out` for displaying the menu, prompts, successful operation messages (e.g., "Ticket #X added..."), and the lists of tickets.
 *         *   **Error Handling:**
 *             *   Use `System.err` to print all error messages (e.g., invalid menu choice, invalid ticket description, attempting to process an empty queue).
 *             *   Implement **class-wide exception handling** in the `main` method using a `try-catch` block (or blocks) that can catch potential runtime errors, such as a user entering non-numeric input when a number is expected for the menu choice (`InputMismatchException`). The application should not crash due to such errors but should report them gracefully via `System.err` and continue running.
 *         *   Ensure the `Scanner` resource is properly closed when the application exits.
 * 
 * 4.  **General Requirements:**
 *     *   Adhere to Java coding best practices: proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments to explain logic, and clean code structure.
 *     *   Ensure all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used correctly and effectively within the solution.
 * 
 * **Expected Output:**
 * 
 * Your program's interaction should resemble the examples provided in the problem description, including handling valid inputs, displaying ticket lists, processing tickets, handling the empty queue case, and managing invalid user inputs for both menu choices and ticket descriptions, directing error messages to `System.err`.
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View Archived Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Email server is down
 * Ticket #1 added to the queue.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket #1 (PENDING): Email server is down
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * Processing ticket #1...
 * Ticket #1 processed and archived.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 4
 * --- Archived Tickets ---
 * Ticket #1 (PROCESSED): Email server is down
 * ------------------------
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * ERROR: No pending tickets to process.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: abc
 * ERROR: Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter ticket description:
 * ERROR: Ticket description cannot be empty.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 6
 * ERROR: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Exiting Support Ticket System.
 * Scanner closed.
 * ```
 * 
 * Implement the Java code for the `SupportTicket`, `TicketManager`, and `SupportSystemApp` classes to fulfill all the requirements.
 *
 * EXPLANATION:
 * The provided solution implements a simple Support Ticket Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`SupportTicket` Class:** This class models a single ticket with an ID, description, and status. It uses private fields for encapsulation and provides public getters and a method (`markAsProcessed`) to control access and state changes. The `toString()` method is overridden for convenient printing of ticket details.
 * 
 * 2.  **`TicketManager` Class:** This class acts as the core logic handler for managing ticket collections.
 *     *   It uses a `java.util.Queue<SupportTicket>` (`pendingTickets`) implemented by `java.util.LinkedList`. The `Queue` is appropriate here because support tickets are typically processed in the order they are received (First-In, First-Out).
 *     *   It uses a `java.util.List<SupportTicket>` (`archivedTickets`) implemented by `java.util.ArrayList`. The `List` interface is used for the declaration, fulfilling that requirement, and `ArrayList` is a suitable concrete implementation for storing processed items where indexed access or simple iteration is needed.
 *     *   The `addTicket` method adds new tickets to the queue using `offer()`.
 *     *   The `viewPendingTickets` method iterates through the queue using an enhanced for loop, which does not remove elements, allowing viewing without affecting the queue's state.
 *     *   The `processNextTicket` method uses `poll()` to retrieve and remove the head of the queue. `poll()` is preferred over `remove()` as it returns `null` if the queue is empty, which is handled by printing an error to `System.err`. If a ticket is retrieved, its status is updated, and it's added to the archived list.
 *     *   The `viewArchivedTickets` method iterates through the `ArrayList` to display processed tickets.
 * 
 * 3.  **`SupportSystemApp` Class:** This class contains the `main` method and handles user interaction.
 *     *   A `java.util.Scanner` is used to read input from the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to direct program flow based on the user's menu selection.
 *     *   **Input Validation:** When adding a ticket, the code checks if the description is null or empty/whitespace using `trim().isEmpty()`. An error message is printed to `System.err` if validation fails.
 *     *   **Output:** `System.out` is used for all standard output, including the menu, prompts, and ticket information.
 *     *   **Error Handling:**
 *         *   A nested `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-numeric input for the menu choice, printing an error to `System.err` and consuming the invalid input using `scanner.next()` before continuing the loop.
 *         *   A `try-catch(Exception e)` block wraps the main `while` loop. This provides **class-wide exception handling** by catching any other unexpected runtime exceptions that might occur during the application's execution, preventing a crash and reporting a general error to `System.err`.
 *         *   The `finally` block ensures that the `Scanner` resource is closed properly when the program exits, whether normally or due to an unexpected exception.
 *     *   The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues when reading the ticket description later.
 * 
 * This solution effectively integrates all the required Java components, follows best practices like encapsulation and meaningful naming, and implements robust error handling and input validation, making it a challenging yet solvable task for an advanced Java exam.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation for List
import java.util.Scanner; // For user input
import java.util.InputMismatchException; // For handling non-integer input

/**
 * Represents a single support ticket in the system.
 * Demonstrates encapsulation.
 */
class SupportTicket {
    private int ticketId;
    private String description;
    private String status; // "PENDING" or "PROCESSED"

    /**
     * Constructor for creating a new SupportTicket.
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the support issue.
     */
    public SupportTicket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = "PENDING"; // Initial status for new tickets
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket's status as PROCESSED.
     */
    public void markAsProcessed() {
        this.status = "PROCESSED";
    }

    /**
     * Provides a string representation of the ticket for printing.
     * @return Formatted string of ticket details.
     */
    @Override
    public String toString() {
        return "Ticket #" + ticketId + " (" + status + "): " + description;
    }
}

/**
 * Manages the collection of support tickets, separating pending and archived.
 * Uses Queue and List (ArrayList) as required.
 */
class TicketManager {
    // Queue for pending tickets (FIFO processing)
    private Queue<SupportTicket> pendingTickets;
    // List for archived tickets (storage of processed items)
    private List<SupportTicket> archivedTickets;

    private int nextTicketId; // Counter for generating unique ticket IDs

    /**
     * Constructor initializes the ticket collections and ID counter.
     */
    public TicketManager() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.archivedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue with a unique ID.
     * @param description The description of the ticket.
     */
    public void addTicket(String description) {
        // Note: Basic validation is done here, but primary validation is in the App class.
        if (description == null || description.trim().isEmpty()) {
             // This case should ideally not happen if validation in App is correct,
             // but defensive programming is good.
             System.err.println("Internal Error: Attempted to add ticket with empty description.");
             return;
        }
        SupportTicket newTicket = new SupportTicket(nextTicketId++, description.trim());
        // offer() is generally preferred over add() for queues as it handles capacity constraints (though LinkedList is unbounded)
        pendingTickets.offer(newTicket);
        System.out.println("Ticket #" + newTicket.getTicketId() + " added to the queue.");
    }

    /**
     * Displays all tickets currently waiting in the pending queue.
     * Prints to System.out.
     */
    public void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            // The order reflects the queue's FIFO nature for viewing
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Processes the next ticket from the front of the pending queue.
     * Removes the ticket, marks it as processed, and adds it to the archived list.
     * Reports errors to System.err if the queue is empty.
     */
    public void processNextTicket() {
        // poll() retrieves and removes the head of the queue, returning null if empty.
        SupportTicket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess == null) {
            // Error case: Queue is empty
            System.err.println("ERROR: No pending tickets to process.");
        } else {
            // Success case: Ticket found and removed
            System.out.println("Processing ticket #" + ticketToProcess.getTicketId() + "...");
            ticketToProcess.markAsProcessed(); // Update status
            archivedTickets.add(ticketToProcess); // Add to archive list
            System.out.println("Ticket #" + ticketToProcess.getTicketId() + " processed and archived.");
        }
    }

    /**
     * Displays all tickets that have been processed and moved to the archive.
     * Prints to System.out.
     */
    public void viewArchivedTickets() {
        System.out.println("--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("No archived tickets.");
        } else {
            // Iterate through the list
            for (SupportTicket ticket : archivedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("------------------------");
    }
}

/**
 * Main application class for the Support Ticket Management System.
 * Handles user interaction, displays the menu, and delegates operations
 * to the TicketManager. Implements Scanner, switch, System.out, System.err,
 * and class-wide try-catch exception handling as required.
 */
public class SupportSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TicketManager manager = new TicketManager();
        boolean running = true;

        // Class-wide exception handling for the main application loop.
        // Catches unexpected errors that might occur during execution.
        try {
            while (running) {
                printMenu(); // Display the main menu

                int choice = -1;
                // Use a nested try-catch specifically for reading the integer menu choice
                // to handle InputMismatchException gracefully.
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read the integer choice
                } catch (InputMismatchException e) {
                    // Handle case where user enters non-integer input
                    System.err.println("ERROR: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid token from the scanner buffer
                    continue; // Skip the rest of this loop iteration and show menu again
                } finally {
                     // Important: Consume the rest of the line after reading the integer.
                     // This prevents issues with subsequent nextLine() calls reading the leftover newline.
                    scanner.nextLine();
                }

                // Use a switch statement to process the valid integer choice
                switch (choice) {
                    case 1: // Add New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        // Input validation for the ticket description
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("ERROR: Ticket description cannot be empty.");
                        } else {
                            manager.addTicket(description); // Delegate to TicketManager
                        }
                        break;

                    case 2: // View Pending Tickets
                        manager.viewPendingTickets(); // Delegate to TicketManager
                        break;

                    case 3: // Process Next Ticket
                        manager.processNextTicket(); // Delegate to TicketManager (handles empty queue error internally)
                        break;

                    case 4: // View Archived Tickets
                        manager.viewArchivedTickets(); // Delegate to TicketManager
                        break;

                    case 5: // Exit
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Support Ticket System.");
                        break;

                    default: // Handle choices outside the 1-5 range
                        System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Print a blank line for better separation between menu cycles
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur during execution.
            // This acts as a fallback for unhandled runtime errors.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging output in case of unexpected errors
        } finally {
            // Ensure the scanner resource is closed properly regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation message
            }
        }
    }

    /**
     * Helper method to print the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Process Next Ticket");
        System.out.println("4. View Archived Tickets");
        System.out.println("5. Exit");
    }
}
