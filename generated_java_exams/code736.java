/*
 * Exam Question #736
 * Generated on: 2025-05-12 16:33:19
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: Technical Support Ticket System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line based technical support ticket management system. The system should allow users (acting as support agents) to add new support tickets, process the next available ticket, view pending tickets, and view resolved tickets.
 * 
 * The system should prioritize tickets based on their arrival order. When a ticket is added, it enters a queue. When an agent processes a ticket, the system should take the oldest pending ticket from the queue. Resolved tickets should be moved to a separate list for historical tracking.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, user input handling, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage pending support tickets. A `LinkedList` is a suitable implementation.
 *     *   Use `java.util.ArrayList` to store resolved support tickets.
 *     *   Use the `java.util.List` interface when declaring variables that hold the resolved tickets, promoting good practice.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read commands and ticket details from the user via the console.
 *     *   Present a clear menu of options to the user.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands based on their menu selection.
 *     *   Implement a loop to keep the system running until the user chooses to exit.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Validate user input where necessary (e.g., ensuring ticket descriptions are not empty, validating menu choices).
 *     *   Use `System.err` to display error messages to the user.
 *     *   Use `System.out` for all normal output (menu, prompts, ticket details, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks. The main operational loop of the program should be wrapped in a `try-catch` block to catch potential runtime errors. Handle specific expected issues (like trying to process a ticket when none are pending) with appropriate messages.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Create a `Ticket` class to represent a single support ticket. It should encapsulate ticket details like ID, description, and status.
 *     *   Create a `SupportSystem` class to manage the collection of pending and resolved tickets and implement the core business logic (adding, processing, viewing).
 *     *   Ensure proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 * 
 * **System Operations:**
 * 
 * 1.  **Add New Ticket:** Prompt the user for a ticket description. Generate a unique ticket ID automatically. Add the new ticket to the pending queue.
 * 2.  **Process Next Ticket:** Take the oldest ticket from the pending queue. If the queue is empty, report an error. Otherwise, mark the ticket as resolved and move it to the resolved tickets list. Report which ticket was processed.
 * 3.  **View Pending Tickets:** Display all tickets currently in the pending queue, in order. If the queue is empty, report that.
 * 4.  **View Resolved Tickets:** Display all tickets in the resolved tickets list. If the list is empty, report that.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My computer won't turn on.
 * Ticket #1 added to the queue.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer offline issue.
 * Ticket #2 added to the queue.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: My computer won't turn on., Status: Pending
 * Ticket ID: 2, Description: Printer offline issue., Status: Pending
 * -----------------------
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 2
 * Processing ticket: Ticket ID: 1, Description: My computer won't turn on., Status: Pending
 * Ticket #1 resolved.
 * 
 * Technical Support System Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 4
 * --- Resolved Tickets ---
 * Ticket ID: 1, Description: My computer won't turn on., Status: Resolved
 * ------------------------
 * 
 * Technical Support System Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Technical Support System Menu:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Submission:** Provide the complete Java code for all necessary classes (`Ticket`, `SupportSystem`, and the main class containing `main`).
 *
 * EXPLANATION:
 * This solution implements the technical support ticket system using the required Java components and following best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with `id`, `description`, and `status`.
 *     *   Uses a `static int nextId` to automatically generate unique IDs for each new ticket, demonstrating a simple way to manage unique identifiers across instances.
 *     *   Includes a constructor, getters, a `markAsResolved()` method, and an overridden `toString()` for easy printing.
 *     *   All fields are `private`, enforcing encapsulation.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   Manages the core data structures: a `Queue<Ticket>` named `ticketQueue` (implemented using `LinkedList`) for pending tickets and a `List<Ticket>` named `resolvedTickets` (implemented using `ArrayList`) for resolved tickets. This correctly uses the `List` interface type for the variable.
 *     *   `addTicket()`: Creates a new `Ticket` object and adds it to the `ticketQueue` using `offer()`.
 *     *   `processNextTicket()`: Uses `poll()` to retrieve and remove the head of the `ticketQueue`. If `poll()` returns `null` (queue is empty), it prints a message. Otherwise, it marks the ticket as resolved using the `Ticket` object's method and adds it to the `resolvedTickets` list.
 *     *   `getPendingTickets()` and `getResolvedTickets()`: Provide access to the collections (though iterating directly over the returned queue in `main` is done carefully to avoid modifying it).
 *     *   `isQueueEmpty()` and `isResolvedListEmpty()`: Helper methods for checking collection states.
 *     *   Fields are `private`, ensuring data is accessed only through defined methods.
 * 
 * 3.  **`SupportSystemApp` Class (Main):**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   Initializes `Scanner` for input and `SupportSystem` to manage tickets.
 *     *   The main application logic runs within a `while (running)` loop.
 *     *   **Class-wide Exception Handling:** The *entire* `while` loop and the code before it (except `Scanner` and `System` object creation) are wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling by catching any unexpected runtime errors that might occur during the execution of the main program flow. A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop finished normally.
 *     *   Inside the loop:
 *         *   `printMenu()`: A separate method is used to display the menu, promoting modularity.
 *         *   User input for the choice is read using `scanner.nextLine()`.
 *         *   A nested `try-catch(NumberFormatException)` specifically handles non-integer input for the menu choice, preventing the program from crashing and allowing the loop to continue.
 *         *   A `switch` statement processes the valid integer choice.
 *         *   Case 1: Prompts for description, performs basic input validation (`description.isEmpty()`), and calls `system.addTicket()`. Uses `System.err` for the validation error.
 *         *   Case 2: Calls `system.processNextTicket()`. The `SupportSystem` class handles the empty queue message internally.
 *         *   Case 3: Retrieves the pending queue and iterates through it using a for-each loop to display tickets. Checks if the queue is empty first.
 *         *   Case 4: Retrieves the resolved list and iterates through it to display tickets. Checks if the list is empty first.
 *         *   Case 5: Sets `running` to `false` to exit the loop.
 *         *   `default`: Handles invalid integer choices using `System.err`.
 *     *   `System.out` is used for menus, prompts, success messages, and displaying ticket details.
 *     *   `System.err` is used for validation errors and the generic unexpected error caught by the outer `try-catch`.
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, object-oriented application demonstrating good design principles, input validation, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a single technical support ticket.
 */
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs

    private int id;
    private String description;
    private String status; // e.g., "Pending", "Resolved"

    /**
     * Constructs a new Ticket with a unique ID and initial status "Pending".
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket status as "Resolved".
     */
    public void markAsResolved() {
        this.status = "Resolved";
    }

    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: %s, Status: %s",
                             id, description, status);
    }
}

/**
 * Manages the collection of pending and resolved support tickets.
 */
class SupportSystem {
    // Queue for pending tickets (FIFO - First-In, First-Out)
    private Queue<Ticket> ticketQueue;
    // List for resolved tickets
    private List<Ticket> resolvedTickets;

    /**
     * Constructs a new SupportSystem with empty queues and lists.
     */
    public SupportSystem() {
        this.ticketQueue = new LinkedList<>(); // LinkedList implements Queue
        this.resolvedTickets = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the new ticket.
     */
    public void addTicket(String description) {
        Ticket newTicket = new Ticket(description);
        ticketQueue.offer(newTicket); // offer() is preferred over add() for queues, handles capacity limits (though LinkedList is unbounded)
        System.out.println("Ticket #" + newTicket.getId() + " added to the queue.");
    }

    /**
     * Processes the next available ticket from the queue.
     * Moves the ticket to the resolved list.
     * @return The processed Ticket object, or null if the queue was empty.
     */
    public Ticket processNextTicket() {
        Ticket nextTicket = ticketQueue.poll(); // poll() retrieves and removes the head, returns null if empty
        if (nextTicket != null) {
            System.out.println("Processing ticket: " + nextTicket);
            nextTicket.markAsResolved();
            resolvedTickets.add(nextTicket);
            System.out.println("Ticket #" + nextTicket.getId() + " resolved.");
        } else {
            System.out.println("No pending tickets to process.");
        }
        return nextTicket; // Return the processed ticket or null
    }

    /**
     * Gets the queue of pending tickets.
     * @return The Queue of pending tickets.
     */
    public Queue<Ticket> getPendingTickets() {
        return ticketQueue;
    }

    /**
     * Gets the list of resolved tickets.
     * @return The List of resolved tickets.
     */
    public List<Ticket> getResolvedTickets() {
        return resolvedTickets;
    }

    /**
     * Checks if there are any pending tickets.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return ticketQueue.isEmpty();
    }

    /**
     * Checks if there are any resolved tickets.
     * @return true if the list is empty, false otherwise.
     */
    public boolean isResolvedListEmpty() {
        return resolvedTickets.isEmpty();
    }
}

/**
 * Main class to run the Technical Support Ticket System.
 * Handles user interaction and delegates tasks to SupportSystem.
 */
public class SupportSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportSystem system = new SupportSystem();
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Use a nested try-catch for input specific issues if needed,
                // but the outer one catches broader runtime errors.
                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1: // Add New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine().trim();
                        if (description.isEmpty()) {
                            System.err.println("Error: Ticket description cannot be empty.");
                        } else {
                            system.addTicket(description);
                        }
                        break;

                    case 2: // Process Next Ticket
                        system.processNextTicket(); // Handles empty queue internally with a message
                        break;

                    case 3: // View Pending Tickets
                        System.out.println("\n--- Pending Tickets ---");
                        if (system.isQueueEmpty()) {
                            System.out.println("No pending tickets.");
                        } else {
                            // Iterate over the queue without removing elements
                            for (Ticket ticket : system.getPendingTickets()) {
                                System.out.println(ticket);
                            }
                        }
                        System.out.println("-----------------------");
                        break;

                    case 4: // View Resolved Tickets
                        System.out.println("\n--- Resolved Tickets ---");
                        if (system.isResolvedListEmpty()) {
                            System.out.println("No resolved tickets.");
                        } else {
                            // Iterate over the list
                            for (Ticket ticket : system.getResolvedTickets()) {
                                System.out.println(ticket);
                            }
                        }
                        System.out.println("------------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting system.");
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging purposes
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Technical Support System Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. Exit");
    }
}
