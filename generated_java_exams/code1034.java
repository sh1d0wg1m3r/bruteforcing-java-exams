/*
 * Exam Question #1034
 * Generated on: 2025-05-12 17:15:45
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam: Restaurant Order Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Restaurant Order Management System in Java. The system should allow staff to place new customer orders, send them to a kitchen queue for processing, process orders one by one from the queue, and view the status of orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Display a fixed menu of items.
 *     *   Allow placing a new order by selecting items from the menu. An order must contain at least one item.
 *     *   Add new orders to a kitchen queue for processing.
 *     *   Process the next order available in the kitchen queue. Processing an order removes it from the queue and updates its status.
 *     *   View the current list of orders waiting in the kitchen queue.
 *     *   View a list of *all* orders placed during the system's runtime, showing their current status.
 *     *   Provide a simple command-line interface for user interaction.
 * 
 * 2.  **Required Java Components:** Your solution **must** utilize **ALL** of the following Java components:
 *     *   `java.util.Queue`: To manage the kitchen order queue (First-In, First-Out).
 *     *   `java.util.ArrayList`: As the concrete implementation for lists within your classes (e.g., list of menu items in an order, list of all orders).
 *     *   `java.util.List`: Declare list variables using this interface type where appropriate (`List<MenuItem> menu`, `List<Order> allOrders`).
 *     *   `java.util.Scanner`: To read user input from the console.
 *     *   `switch` statement: For handling the main menu choices.
 *     *   `System.err`: To display error messages (e.g., invalid input, cannot process empty queue).
 *     *   `System.out`: To display all normal output (menu, prompts, order details, queue status, success messages).
 *     *   Class-wide exception handling with `try-catch` blocks: To gracefully handle potential issues like invalid user input (e.g., non-numeric input when expecting a number).
 * 
 * 3.  **Best Practices:**
 *     *   Design using appropriate classes (`MenuItem`, `Order`, `RestaurantSystem` are suggested, but you can design your own).
 *     *   Implement proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts or logic.
 *     *   Add input validation to handle incorrect user entries (e.g., non-existent menu item number, non-numeric input).
 *     *   Implement proper error handling using `try-catch` and `System.err`.
 *     *   Structure your code cleanly.
 * 
 * **Expected Output:**
 * 
 * The system should present a main menu loop. User interactions should lead to clear output via `System.out` and errors via `System.err`.
 * 
 * *   Displaying the menu should show numbered items with names and prices.
 * *   Placing an order should guide the user to select items by number, confirm additions, and announce when the order is placed and added to the queue.
 * *   Processing an order should announce which order is being processed and update its status.
 * *   Viewing the kitchen queue should list orders currently waiting.
 * *   Viewing all orders should list every order placed during the session with its current status.
 * *   Invalid inputs or actions (like processing an empty queue) should result in error messages on `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Restaurant Order Management System ---
 * 
 * Select an action:
 * 1. Place New Order
 * 2. Process Next Order from Queue
 * 3. View Kitchen Queue
 * 4. View All Placed Orders
 * 5. Exit
 * Enter choice: 1
 * 
 * --- Place New Order ---
 * --- Menu ---
 * 1. Burger ($8.99)
 * 2. Fries ($3.49)
 * 3. Soda ($1.99)
 * ...
 * ------------
 * Enter item number to add (0 to finish order): 1
 * Burger added to order #1
 * Enter item number to add (0 to finish order): 2
 * Fries added to order #1
 * Enter item number to add (0 to finish order): 0
 * 
 * Order #1 placed and added to kitchen queue.
 * Order #1 [Pending]
 *   - Burger
 *   - Fries
 *   Total: $12.48
 * 
 * Select an action:
 * ...
 * Enter choice: 3
 * 
 * --- Kitchen Queue ---
 * Position 1: Order #1 [Pending]
 * 
 * Select an action:
 * ...
 * Enter choice: 2
 * 
 * --- Process Next Order ---
 * Processing Order #1...
 * Order #1 [Preparing]
 *   - Burger
 *   - Fries
 *   Total: $12.48
 * 
 * Select an action:
 * ...
 * Enter choice: 3
 * 
 * --- Kitchen Queue ---
 * The kitchen queue is empty.
 * 
 * Select an action:
 * ...
 * Enter choice: 4
 * 
 * --- All Placed Orders ---
 * Order #1 [Preparing]
 *   - Burger
 *   - Fries
 *   Total: $12.48
 * ---
 * 
 * Select an action:
 * ...
 * Enter choice: 6  <-- Invalid Input
 * 
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an action:
 * ...
 * Enter choice: abc <-- Invalid Input
 * 
 * Error: Invalid input. Please enter a number.
 * 
 * Select an action:
 * ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single Java program containing all necessary classes and the `main` method to start the system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Restaurant Order Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Design:**
 *     *   `MenuItem`: A simple class encapsulating the name and price of a menu item. It follows encapsulation principles with private fields and public getters.
 *     *   `Order`: Represents a customer order. It includes an `orderId`, a `List<MenuItem>` to hold the items (`ArrayList` implementation used as required), and a `status`. Methods are provided to add items, update status, and calculate the total. It uses `ArrayList` internally for the `items` list.
 *     *   `RestaurantSystem`: The main class that orchestrates the system. It holds the `menu` (`List<MenuItem>` implemented by `ArrayList`), the `kitchenQueue` (`Queue<Order>` implemented by `LinkedList` to provide FIFO behavior), and `allOrders` (`List<Order>` implemented by `ArrayList`) for tracking all orders placed. It also manages the `nextOrderId`.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: The `kitchenQueue` variable is declared as `Queue<Order>` and initialized with `new LinkedList<>()`. The `offer()` method is used to add orders to the end of the queue (when placing a new order), and the `poll()` method is used to retrieve and remove the order from the front of the queue (when processing the next order). Iteration is used in `viewKitchenQueue()` to peek at elements without removing them.
 *     *   `java.util.ArrayList`: Used as the concrete implementation for the `items` list within the `Order` class, and for the `menu` and `allOrders` lists within the `RestaurantSystem` class, fulfilling the requirement to use `ArrayList`.
 *     *   `java.util.List`: The `menu` and `allOrders` variables in `RestaurantSystem`, and the `items` variable in `Order` are declared using the `List` interface type, demonstrating polymorphism and programming to interfaces.
 *     *   `java.util.Scanner`: A `Scanner` object is created in the `run()` method and passed to `placeOrder()` to handle user input from `System.in`. `nextInt()` and `nextLine()` are used to read different input types.
 *     *   `switch` statement: Used in the `run()` method's main loop to direct execution based on the user's numeric choice from the main menu.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, invalid input types (`InputMismatchException`), attempts to place empty orders, or internal processing errors. This separates error output from normal program output (`System.out`).
 *     *   `System.out`: Used for all regular program output, including the menu display, prompts for user input, success messages for placing/processing orders, and displaying order details and queue contents.
 *     *   `try-catch` blocks: Implemented in the `run()` method (for the main menu choice) and the `placeOrder()` method (for item selection input). This provides class-wide exception handling within the main interaction loops. It specifically catches `InputMismatchException` for non-numeric input and a general `Exception` for other potential runtime issues, printing error details to `System.err` and attempting to recover by consuming the invalid input.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `MenuItem`, `Order`, and `RestaurantSystem` are `private`, accessed only through public getter methods or specific mutator methods (`addItem`, `updateStatus`).
 *     *   **Meaningful Names:** Variables (`kitchenQueue`, `allOrders`, `nextOrderId`, `itemNumber`, `orderToProcess`) and methods (`placeOrder`, `processNextOrder`, `viewKitchenQueue`, `displayMenu`) are named descriptively.
 *     *   **Comments:** Javadoc-style comments are used for classes and methods, explaining their purpose, parameters, and return values. Inline comments explain specific logic points.
 *     *   **Input Validation:** The `placeOrder` method checks if the entered item number corresponds to a valid menu item. The main loop and `placeOrder` use `try-catch` to handle non-numeric input. The `placeOrder` method also prevents placing an order with no items.
 *     *   **Error Handling:** `try-catch` blocks are used for robustness. Error messages are descriptive and printed to `System.err`. Invalid input handling includes consuming the erroneous input to prevent infinite loops.
 *     *   **Clean Code Structure:** The code is divided into logical classes, each responsible for a specific part of the system. Methods are focused on single tasks (e.g., `placeOrder` handles only placing an order).
 * 
 * This solution effectively integrates all required components into a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single menu item with a name and price.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The price.
     */
    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the menu item.
     * @return Formatted string like "ItemName ($Price.00)".
     */
    @Override
    public String toString() {
        return name + " ($" + String.format("%.2f", price) + ")";
    }
}

/**
 * Represents a customer order, containing multiple menu items and a status.
 */
class Order {
    private int orderId;
    private List<MenuItem> items; // Required: Use List interface
    private String status; // e.g., "Pending", "Preparing", "Served"

    /**
     * Constructs a new Order with a unique ID.
     * @param orderId The unique identifier for the order.
     */
    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // Required: Use ArrayList implementation
        this.status = "Pending";
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of MenuItems.
     */
    public List<MenuItem> getItems() {
        return items; // Return the list for viewing
    }

    /**
     * Gets the current status of the order.
     * @return The status string.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Adds a MenuItem to the order.
     * @param item The MenuItem to add.
     */
    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
        }
    }

    /**
     * Updates the status of the order.
     * @param status The new status string.
     */
    public void updateStatus(String status) {
        this.status = status;
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double calculateTotal() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    /**
     * Returns a detailed string representation of the order.
     * @return Formatted string including ID, status, items, and total.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" [").append(status).append("]\n");
        for (MenuItem item : items) {
            sb.append("  - ").append(item.getName()).append("\n");
        }
        sb.append("  Total: $").append(String.format("%.2f", calculateTotal()));
        return sb.toString();
    }
}

/**
 * Manages the restaurant operations: menu, kitchen queue, and all orders.
 */
public class RestaurantSystem {
    private List<MenuItem> menu; // Required: Use List interface
    private Queue<Order> kitchenQueue; // Required: Use Queue interface
    private List<Order> allOrders; // Required: Use List interface
    private int nextOrderId;

    /**
     * Constructs the RestaurantSystem, initializing collections and the menu.
     */
    public RestaurantSystem() {
        menu = new ArrayList<>(); // Required: Use ArrayList implementation
        kitchenQueue = new LinkedList<>(); // LinkedList implements Queue interface
        allOrders = new ArrayList<>(); // Required: Use ArrayList implementation
        nextOrderId = 1;

        // Initialize sample menu
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Fries", 3.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Salad", 7.00));
        menu.add(new MenuItem("Pasta", 10.75));
    }

    /**
     * Displays the restaurant menu to System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (int i = 0; i < menu.size(); i++) {
            System.out.println((i + 1) + ". " + menu.get(i));
        }
        System.out.println("------------");
    }

    /**
     * Gets a MenuItem by its 1-based index from the displayed menu.
     * @param index The 1-based index from the displayed menu.
     * @return The MenuItem object, or null if the index is invalid.
     */
    private MenuItem getMenuItemByIndex(int index) {
        if (index > 0 && index <= menu.size()) {
            return menu.get(index - 1); // Adjust for 0-based index
        }
        return null; // Indicate invalid index
    }

    /**
     * Handles the process of placing a new order based on user input.
     * Reads input using the provided Scanner.
     * @param scanner The Scanner object for reading input.
     */
    public void placeOrder(Scanner scanner) {
        System.out.println("\n--- Place New Order ---");
        Order newOrder = new Order(nextOrderId);
        boolean addingItems = true;

        while (addingItems) {
            displayMenu();
            System.out.print("Enter item number to add (0 to finish order): ");
            try {
                int itemNumber = scanner.nextInt();
                // Consume the rest of the line to prevent issues with next nextLine()
                scanner.nextLine();

                if (itemNumber == 0) {
                    if (newOrder.getItems().isEmpty()) {
                        System.err.println("Error: Cannot place an empty order. Add at least one item.");
                        // Continue the loop to allow adding items
                    } else {
                        addingItems = false; // Finish adding items
                    }
                } else {
                    MenuItem selectedItem = getMenuItemByIndex(itemNumber);
                    if (selectedItem != null) {
                        newOrder.addItem(selectedItem);
                        System.out.println(selectedItem.getName() + " added to order #" + newOrder.getOrderId());
                    } else {
                        System.err.println("Error: Invalid item number. Please try again.");
                    }
                }
            } catch (InputMismatchException e) {
                // Required: Use System.err for error messages
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) { // Required: Class-wide exception handling
                 System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to err for debugging
                 scanner.nextLine(); // Attempt to clear input
            }
        }

        // Only add the order if items were successfully added
        if (!newOrder.getItems().isEmpty()) {
            allOrders.add(newOrder); // Required: Use List/ArrayList
            kitchenQueue.offer(newOrder); // Required: Use Queue
            nextOrderId++; // Increment order ID only if order is placed
            System.out.println("\nOrder #" + newOrder.getOrderId() + " placed and added to kitchen queue.");
            System.out.println(newOrder); // Print order details using Order's toString
        } else {
             System.out.println("Order placement cancelled as no items were added.");
             // nextOrderId is not incremented if order is empty, so no need to decrement
        }
    }

    /**
     * Processes the next order from the kitchen queue.
     * Removes the order from the queue and updates its status in the allOrders list.
     */
    public void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        // Required: Use Queue (poll removes the head)
        Order orderToProcess = kitchenQueue.poll();

        if (orderToProcess != null) {
            // Find the order in the allOrders list to update its status
            // Required: Demonstrate using List to find an element
            Order foundOrder = null;
            for(Order order : allOrders) { // Iterate through the List
                if (order.getOrderId() == orderToProcess.getOrderId()) {
                    foundOrder = order;
                    break; // Found the order
                }
            }

            if (foundOrder != null) {
                 foundOrder.updateStatus("Preparing"); // Update status in the main list
                 System.out.println("Processing Order #" + foundOrder.getOrderId() + "...");
                 System.out.println(foundOrder); // Print updated order details
                 // In a real system, you might move it to another queue or state (e.g., "Served") later.
                 // For this problem, "Preparing" indicates it's out of the initial queue.
            } else {
                 // This case indicates a logic error if an order is in the queue but not in allOrders
                 // Required: Use System.err for error messages
                 System.err.println("Internal Error: Processed order #" + orderToProcess.getOrderId() + " not found in the master order list.");
            }

        } else {
            System.out.println("The kitchen queue is empty. No orders to process.");
        }
    }

    /**
     * Displays the current orders waiting in the kitchen queue.
     * Iterates through the queue without removing elements.
     */
    public void viewKitchenQueue() {
        System.out.println("\n--- Kitchen Queue ---");
        if (kitchenQueue.isEmpty()) {
            System.out.println("The kitchen queue is empty.");
        } else {
            // Required: Use Queue (iteration)
            int position = 1;
            for (Order order : kitchenQueue) { // Iterating over a Queue uses its iterator
                System.out.println("Position " + position++ + ": Order #" + order.getOrderId() + " [" + order.getStatus() + "]");
                // Optionally print items: System.out.println(order); // Too verbose for just queue view
            }
        }
    }

    /**
     * Displays all orders that have been placed during the system's runtime.
     * Iterates through the allOrders list.
     */
    public void viewAllOrders() {
        System.out.println("\n--- All Placed Orders ---");
        if (allOrders.isEmpty()) {
            System.out.println("No orders have been placed yet.");
        } else {
            // Required: Use List/ArrayList (iteration)
            for (Order order : allOrders) {
                System.out.println(order); // Order's toString provides full details
                System.out.println("---"); // Separator for clarity
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        // Required: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Restaurant Order Management System ---");

        while (running) {
            System.out.println("\nSelect an action:");
            System.out.println("1. Place New Order");
            System.out.println("2. Process Next Order from Queue");
            System.out.println("3. View Kitchen Queue");
            System.out.println("4. View All Placed Orders");
            System.out.println("5. Exit");
            System.out.print("Enter choice: ");

            try { // Required: Class-wide exception handling with try-catch
                int choice = scanner.nextInt();
                // Consume the rest of the line after reading the integer choice
                // This is important to prevent issues with subsequent nextLine() calls
                scanner.nextLine();

                // Required: Use switch statement
                switch (choice) {
                    case 1:
                        placeOrder(scanner); // Pass scanner to allow input in method
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewKitchenQueue();
                        break;
                    case 4:
                        viewAllOrders();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Required: Use System.err for error messages
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handles cases where the user enters non-integer input for the main menu choice
                // Required: Use System.err for error messages
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the main loop
                 // Required: Class-wide exception handling
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to err for debugging
                 scanner.nextLine(); // Attempt to clear input
            }
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
