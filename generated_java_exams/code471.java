/*
 * Exam Question #471
 * Generated on: 2025-05-11 23:16:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam - Advanced Task Management System
 * 
 * **Objective:** Design and implement a simple command-line task management system. The system should allow users to add new tasks, process the next pending task, and view lists of tasks. This problem requires demonstrating proficiency with core Java collections, control flow, input/output, and exception handling.
 * 
 * **Scenario:** You are building the backend for a basic task management application. Tasks are added to a queue for processing in the order they are received (FIFO). The system also needs to maintain a record of all tasks ever created, regardless of their current status.
 * 
 * **Requirements:**
 * 
 * 1.  **`Task` Class:**
 *     *   Create a `Task` class with private fields: `id` (int, unique), `description` (String), `priority` (int, e.g., 1-5), and `status` (String, e.g., "Pending", "Completed").
 *     *   Implement a constructor `Task(int id, String description, int priority)`. The status should be initialized to "Pending".
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public method `markCompleted()` that changes the status to "Completed".
 *     *   Override the `toString()` method to provide a concise string representation of the task (e.g., `[ID] Description (Priority: X) - Status`).
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Create a `TaskManager` class to manage the tasks.
 *     *   It must have private fields:
 *         *   A `List<Task>` (use `ArrayList`) to store *all* tasks created in the system.
 *         *   A `Queue<Task>` (use `java.util.Queue`, specifically a `LinkedList` implementation) to store tasks that are currently "Pending" and waiting to be processed.
 *         *   An integer to keep track of the next available task ID.
 *     *   Implement public methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task`, adds it to both the `allTasks` list and the `tasksToProcess` queue. Assigns a unique ID. Validates the priority (must be between 1 and 5 inclusive). If priority is invalid, print an error to `System.err` and do not add the task.
 *         *   `processNextTask()`: Removes the next task from the `tasksToProcess` queue, marks its status as "Completed" (by calling its `markCompleted()` method), and returns the processed task. If the queue is empty, print an error message to `System.err` and return `null`.
 *         *   `listAllTasks()`: Returns the `List` containing all tasks ever created.
 *         *   `listTasksToProcess()`: Returns a `List` containing the tasks currently in the `tasksToProcess` queue. *Important:* This method should *not* remove elements from the queue. Create a new `ArrayList` and add elements from the queue to it for display.
 * 
 * 3.  **Main Application (`Main` class or similar):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a command loop that presents the user with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  List All Tasks
 *         4.  List Pending Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Call the appropriate `TaskManager` methods based on the user's selection.
 *     *   Display output to the console using `System.out`.
 *     *   Display error messages using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block in the `main` method that wraps the core command processing loop. This block should catch `Exception` and print an error message to `System.err`. Handle specific input validation errors (like non-integer input) appropriately before calling `TaskManager` methods or within the switch cases.
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Include comments or Javadoc where necessary to explain complex logic or class/method purpose.
 * *   Ensure proper encapsulation (private fields, public methods).
 * *   Validate user input where appropriate (e.g., menu choice, task priority).
 * *   Handle potential errors gracefully (e.g., processing an empty queue, invalid input).
 * 
 * **Expected Output:**
 * 
 * *   The program should continuously display the menu until the user chooses to exit.
 * *   Adding a task should print a confirmation to `System.out`. Invalid priority should print an error to `System.err`.
 * *   Processing a task should print which task was processed to `System.out`. Processing an empty queue should print an error to `System.err`.
 * *   Listing tasks should print the details of each task in the respective list/queue to `System.out`.
 * *   Any unhandled exceptions within the main loop should be caught and reported to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter choice: 1
 * Enter task description: Write report
 * Enter task priority (1-5): 2
 * Task added: [1] Write report (Priority: 2) - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 1
 * Enter task description: Schedule meeting
 * Enter task priority (1-5): 1
 * Task added: [2] Schedule meeting (Priority: 1) - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 4
 * Pending Tasks:
 * [1] Write report (Priority: 2) - Pending
 * [2] Schedule meeting (Priority: 1) - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 2
 * Processing task: [1] Write report (Priority: 2) - Pending
 * Task [1] processed.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 4
 * Pending Tasks:
 * [2] Schedule meeting (Priority: 1) - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 3
 * All Tasks:
 * [1] Write report (Priority: 2) - Completed
 * [2] Schedule meeting (Priority: 1) - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 2
 * Processing task: [2] Schedule meeting (Priority: 1) - Pending
 * Task [2] processed.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 2
 * Error: No tasks in the processing queue.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Constraints:** Adhere strictly to the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 *
 * EXPLANATION:
 * This solution implements a simple command-line task management system, fulfilling all the requirements of the problem.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses private fields (`id`, `description`, `priority`, `status`) to enforce encapsulation.
 *     *   Provides public getter methods to access the data.
 *     *   The `markCompleted()` method is the controlled way to change the task's status.
 *     *   The overridden `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Acts as the central controller for managing tasks.
 *     *   Uses an `ArrayList`, referenced by the `List` interface (`private List<Task> allTasks;`), to keep a complete history of all tasks ever created. `ArrayList` is suitable here for dynamic resizing and easy iteration/storage.
 *     *   Uses a `LinkedList` implementation, referenced by the `Queue` interface (`private Queue<Task> tasksToProcess;`), to manage tasks waiting for processing in a FIFO (First-In, First-Out) manner. `Queue` methods like `offer()` (add) and `poll()` (retrieve and remove) are used.
 *     *   `nextTaskId` ensures unique IDs for tasks.
 *     *   `addTask()` performs basic input validation for priority before creating and adding the task to *both* the `allTasks` list and the `tasksToProcess` queue. It prints success or error messages using `System.out` or `System.err`.
 *     *   `processNextTask()` checks if the `tasksToProcess` queue is empty using `isEmpty()`. If not empty, it uses `poll()` to get and remove the next task and then calls its `markCompleted()` method. It handles the empty queue case by printing to `System.err` and returning `null`.
 *     *   `listAllTasks()` directly returns the internal `allTasks` list.
 *     *   `listTasksToProcess()` demonstrates how to iterate over a `Queue` (using an enhanced for loop or iterator) and copy its contents into a new `ArrayList` (referenced as `List`) for display *without* altering the queue's state. This fulfills the requirement of using `ArrayList` and `List` for listing queue contents.
 * 
 * 3.  **`Main` Class:**
 *     *   The `main` method is the entry point.
 *     *   It initializes the `TaskManager` and `Scanner`.
 *     *   A `while(running)` loop keeps the program active until the user chooses to exit.
 *     *   `printMenu()` displays the available options to `System.out`.
 *     *   Input is read using `scanner.hasNextInt()` and `scanner.nextInt()` for the choice, followed by `scanner.nextLine()` to consume the leftover newline, preventing issues with subsequent `nextLine()` calls for descriptions. A similar pattern is used for priority input. This is a robust way to handle mixed `nextInt()`/`nextLine()` input and validate if the input is actually an integer. Invalid non-integer input for the menu choice is handled by consuming the invalid token and continuing the loop, printing an error to `System.err`.
 *     *   A `switch` statement directs the program flow based on the validated user choice, calling the appropriate `TaskManager` methods.
 *     *   Output messages are printed to `System.out`.
 *     *   Error messages (invalid choice, empty queue, invalid priority) are printed to `System.err`.
 *     *   **Class-wide exception handling:** A `try-catch(Exception e)` block wraps the entire `while(running)` loop in `main`. This serves as a general safety net to catch any unexpected runtime exceptions that might occur during the execution of the command processing logic. If an exception is caught, it prints a generic error message and the stack trace to `System.err`. A specific `catch(InputMismatchException e)` is included before the general `Exception` catch to handle potential Scanner issues more specifically, although the `hasNextInt()` checks mitigate many of these.
 *     *   A `finally` block ensures that the `scanner.close()` method is called when the `try` block is exited, either normally or due to an exception, releasing system resources.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical simulation, demonstrating good object-oriented design principles like encapsulation, clear method responsibilities, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues

/**
 * Represents a single task with a description, priority, and status.
 */
class Task {
    private int id;
    private String description;
    private int priority;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     *
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (e.g., 1-5).
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Tasks start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the task.
     *
     * @return Formatted string describing the task.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + description + " (Priority: " + priority + ") - " + status;
    }
}

/**
 * Manages a collection of tasks, supporting adding, processing, and listing.
 */
class TaskManager {
    // Use List interface for all tasks, implemented by ArrayList
    private List<Task> allTasks;
    // Use Queue interface for tasks waiting processing, implemented by LinkedList
    private Queue<Task> tasksToProcess;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.tasksToProcess = new LinkedList<>(); // LinkedList implements Queue
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The description of the task.
     * @param priority The priority level (1-5).
     * @return true if the task was added successfully, false otherwise (e.g., invalid priority).
     */
    public boolean addTask(String description, int priority) {
        // Input validation for priority
        if (priority < 1 || priority > 5) {
            System.err.println("Error: Invalid priority. Priority must be between 1 and 5.");
            return false;
        }

        // Create new task
        Task newTask = new Task(nextTaskId++, description, priority);

        // Add to both collections
        allTasks.add(newTask);
        tasksToProcess.offer(newTask); // offer() is preferred over add() for queues as it handles capacity issues (though LinkedList is unbounded)

        System.out.println("Task added: " + newTask);
        return true;
    }

    /**
     * Processes the next task in the processing queue.
     *
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        // Check if queue is empty
        if (tasksToProcess.isEmpty()) {
            System.err.println("Error: No tasks in the processing queue.");
            return null;
        }

        // Get and remove the head of the queue
        Task taskToProcess = tasksToProcess.poll(); // poll() returns null if queue is empty, but we already checked

        // Mark task as completed
        taskToProcess.markCompleted();

        System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");
        System.out.println("Task [" + taskToProcess.getId() + "] processed.");

        return taskToProcess;
    }

    /**
     * Returns a list of all tasks ever created.
     *
     * @return A List of all tasks.
     */
    public List<Task> listAllTasks() {
        return allTasks; // Return the actual list
    }

    /**
     * Returns a list of tasks currently waiting in the processing queue.
     * Does not remove tasks from the queue.
     *
     * @return A new List containing tasks from the processing queue.
     */
    public List<Task> listTasksToProcess() {
        // Create a new list to hold the queue elements for display
        List<Task> pendingList = new ArrayList<>();
        // Iterate over the queue without removing elements and add to the list
        for (Task task : tasksToProcess) {
            pendingList.add(task);
        }
        return pendingList;
    }
}

/**
 * Main class to run the Task Management System.
 */
public class Main { // Renamed from a generic name like 'Solution' to 'Main' for clarity
    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main command loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Initialize choice to an invalid value

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        int priority = -1; // Initialize priority

                        System.out.print("Enter task priority (1-5): ");
                        if (scanner.hasNextInt()) {
                            priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.addTask(description, priority);
                        } else {
                            System.err.println("Error: Invalid priority input. Please enter a number.");
                            scanner.next(); // Consume invalid input
                            scanner.nextLine(); // Consume rest of the line
                        }
                        break;

                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;

                    case 3: // List All Tasks
                        List<Task> allTasks = taskManager.listAllTasks();
                        System.out.println("\n--- All Tasks ---");
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks created yet.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("-----------------");
                        break;

                    case 4: // List Pending Tasks
                        List<Task> pendingTasks = taskManager.listTasksToProcess();
                        System.out.println("\n--- Pending Tasks ---");
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks pending processing.");
                        } else {
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better formatting between commands
            }
        } catch (InputMismatchException e) {
             // This catch block is less likely to be hit with the hasNextInt checks,
             // but remains as a fallback for unexpected scanner state issues.
            System.err.println("A critical input error occurred: " + e.getMessage());
            scanner.nextLine(); // Attempt to clear the bad input
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }
}
