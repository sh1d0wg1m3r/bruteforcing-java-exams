/*
 * Exam Question #480
 * Generated on: 2025-05-11 23:17:33
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Warehouse Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified warehouse management system. The system needs to manage a fixed set of product types, track their inventory levels, accept customer orders, and process these orders sequentially. Orders are processed in a First-In, First-Out (FIFO) manner.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Management:**
 *     *   Maintain a list of product types, each with a unique ID, name, and current stock quantity.
 *     *   Allow adding stock to existing product types.
 *     *   Allow viewing the current inventory levels of all product types.
 * 
 * 2.  **Order Management:**
 *     *   Accept customer orders. An order consists of one or more items, where each item specifies a product ID and a desired quantity.
 *     *   Orders should be placed into a waiting queue upon creation.
 *     *   Process orders one by one from the front of the queue.
 *     *   When processing an order:
 *         *   Attempt to fulfill the order by reducing the stock of each requested product.
 *         *   If *at any point* during the processing of an order, there is insufficient stock for a requested item, the *entire order* fails. Do not partially fulfill orders.
 *         *   If an order fails due to insufficient stock, log an error message to `System.err` detailing the failure and the order ID. The order is discarded (not returned to the queue).
 *         *   If an order is successfully processed, log a success message to `System.out` detailing the order ID and the items fulfilled.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to accept commands from the user via the console.
 *     *   Support the following commands:
 *         *   `addstock <productId> <quantity>`: Add the specified quantity to the stock of the given product ID.
 *         *   `placeorder`: Initiate the process of placing a new order. The system should then prompt the user to enter product IDs and quantities for items in the order, one per line, until the user enters `0` as the product ID.
 *         *   `process`: Attempt to process the next order in the queue.
 *         *   `view`: Display the current inventory levels for all products.
 *         *   `exit`: Terminate the program.
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 4.  **Error Handling and Best Practices:**
 *     *   Implement robust input validation. If the user provides invalid input (e.g., non-numeric values when numbers are expected, invalid product IDs, non-positive quantities), catch the error, print a user-friendly error message to `System.err`, and allow the user to enter the next command without crashing.
 *     *   Use class-wide `try-catch` blocks where necessary to handle potential exceptions, especially around input processing and business logic (like insufficient stock).
 *     *   Use `System.err` for all error messages and `System.out` for all normal output (prompts, success messages, inventory display).
 *     *   Follow object-oriented principles: Use classes (`Product`, `Order`, `WarehouseManager`, `OrderItem`, potentially a custom exception).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs where applicable).
 *     *   Ensure the `Scanner` resource is properly closed upon program exit.
 *     *   Define and use a custom exception for the insufficient stock scenario during order processing.
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Initial State:**
 * 
 * The system should start with a predefined set of products in the inventory. For example:
 * *   ID 1: Laptop, Stock 10
 * *   ID 2: Keyboard, Stock 25
 * *   ID 3: Mouse, Stock 50
 * 
 * **Expected Output:**
 * 
 * *   Prompts for commands should be clear.
 * *   `view` command should list product ID, name, and stock.
 * *   `placeorder` command should prompt for items and confirm order placement.
 * *   `process` command should indicate success or failure (with details) via `System.out` or `System.err`.
 * *   Error messages (invalid input, invalid product ID, insufficient stock) should go to `System.err`.
 * *   Successful operations and information displays should go to `System.out`.
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple warehouse management system that fulfills all the requirements of the problem, demonstrating the use of the specified Java components and best practices.
 * 
 * **Core Classes:**
 * 
 * 1.  `InsufficientStockException`: A custom checked exception (could also be unchecked, but checked forces explicit handling) to signal when an attempt is made to remove more stock than available for a product.
 * 2.  `Product`: Represents a product type with `id`, `name`, and `stock`. Includes methods `addStock` and `removeStock` with basic validation and throwing the custom exception. Uses private fields and public getters for encapsulation.
 * 3.  `OrderItem`: A simple class representing a line item within an order, holding a `productId` and `quantity`.
 * 4.  `Order`: Represents a customer order with a unique `orderId` and a `List` of `OrderItem`s. Uses a static counter for generating sequential order IDs.
 * 5.  `WarehouseManager`: The main class orchestrating the system. It holds the inventory (`List<Product>`) and the order queue (`Queue<Order>`). It contains methods for each command and the main `run` loop.
 * 
 * **Required Component Usage:**
 * 
 * *   `java.util.Queue`: Used for `orderQueue = new LinkedList<>()`. Orders are added using `offer()` in `placeOrder()` and retrieved/removed using `peek()` and `poll()` in `processNextOrder()`, ensuring FIFO processing.
 * *   `java.util.ArrayList`: Used to implement the `List` interface for `inventory = new ArrayList<>()`. It's also used internally within `Order` to store `OrderItem`s (`items = new ArrayList<>(items);`).
 * *   `java.util.List`: The `inventory` field is declared as `List<Product> inventory`, demonstrating programming to the interface. The `Order` class also uses `List<OrderItem>`.
 * *   `java.util.Scanner`: An instance `scanner` is used in the `WarehouseManager` constructor and throughout the `run` and `placeOrder` methods to read user input from `System.in`. It's closed upon program exit.
 * *   `switch` statement: Used in the `run()` method to dispatch control flow based on the user's command string ("addstock", "placeorder", "process", "view", "exit").
 * *   `System.err`: Used for printing all error messages, such as invalid input, product not found, insufficient stock errors during processing, and unexpected exceptions.
 * *   `System.out`: Used for printing normal output, including prompts, success messages (stock added, order placed, order processed), and the inventory list.
 * *   Class-wide `try-catch` blocks:
 *     *   A `try-catch` block surrounds the `switch` statement in the `run()` method to catch general exceptions during command execution.
 *     *   Specific `try-catch(InputMismatchException)` blocks are used within command cases (`addstock`, `placeorder`) to handle non-numeric user input gracefully.
 *     *   A `try-catch(InsufficientStockException)` block is specifically used in `processNextOrder()` to handle the business logic error when stock is too low.
 *     *   Generic `catch(Exception e)` blocks are included in `placeOrder()` and `processNextOrder()` to catch any other unexpected runtime issues.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Product`, `OrderItem`, and `Order` are private with public getter methods. `WarehouseManager`'s internal state (`inventory`, `orderQueue`) is also private.
 * *   **Meaningful Names:** Classes, variables, and methods have descriptive names (e.g., `addStock`, `processNextOrder`, `insufficientStockException`).
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and key methods explaining their purpose, parameters, and potential exceptions. Inline comments clarify specific logic.
 * *   **Input Validation:** Checks are performed for positive quantities, valid product IDs (by looking them up), and numeric input using `try-catch(InputMismatchException)`.
 * *   **Proper Error Handling:** Different types of errors are handled differently: input errors caught by `InputMismatchException`, business logic errors by `InsufficientStockException`, and other runtime errors by generic `Exception` catches. Error messages are informative and directed to `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical classes, and methods are kept reasonably focused on single responsibilities.
 * *   **Resource Management:** The `Scanner` is explicitly closed when the application terminates.
 * 
 * **Logic Flow:**
 * 
 * 1.  The `main` method creates a `WarehouseManager` instance and calls its `run()` method.
 * 2.  `run()` initializes the inventory and queue, then enters a `while` loop that continues until `running` is false.
 * 3.  Inside the loop, it prompts for and reads a command.
 * 4.  A `try-catch` block wraps the `switch` statement to handle potential errors during command processing.
 * 5.  The `switch` directs execution based on the command:
 *     *   `addstock`: Reads product ID and quantity, calls `addStock`. Includes input validation `try-catch`.
 *     *   `placeorder`: Calls `placeOrder()`. This method enters its own loop to read multiple order items, performing input validation (`try-catch`) for each item. It creates an `Order` object and adds it to the `orderQueue`.
 *     *   `process`: Calls `processNextOrder()`. This method first `peek()`s at the next order. It performs a pre-check loop over the order items to ensure stock *can* be fulfilled (checking for missing products or obvious stock shortages). If the pre-check fails, it `poll()`s the order and prints an error to `System.err`. If the pre-check passes, it enters a second loop to actually call `product.removeStock()`. This is where `InsufficientStockException` can be thrown. A `try-catch(InsufficientStockException)` block handles this, `poll()`ing the failed order and printing to `System.err`. A generic `catch(Exception)` is included for other unexpected errors during processing.
 *     *   `view`: Calls `viewInventory()`, which iterates through the `inventory` list and prints product details to `System.out`.
 *     *   `exit`: Sets `running` to `false` to end the loop.
 *     *   `default`: Handles unknown commands, printing an error to `System.err`.
 * 6.  After the `while` loop ends, `scanner.close()` is called.
 * 
 * This structure effectively utilizes the required components to build a functional, albeit simplified, system demonstrating core Java concepts including collections, queues, error handling, and basic object-oriented design.
 */

import java.util.*;

// Custom exception for insufficient stock
class InsufficientStockException extends Exception {
    private int productId;
    private int requestedQuantity;
    private int availableStock;

    public InsufficientStockException(int productId, int requestedQuantity, int availableStock) {
        super("Insufficient stock for Product ID: " + productId + ". Requested: " + requestedQuantity + ", Available: " + availableStock);
        this.productId = productId;
        this.requestedQuantity = requestedQuantity;
        this.availableStock = availableStock;
    }

    public int getProductId() {
        return productId;
    }

    public int getRequestedQuantity() {
        return requestedQuantity;
    }

    public int getAvailableStock() {
        return availableStock;
    }
}

// Represents a product type in the warehouse
class Product {
    private int id;
    private String name;
    private int stock;

    public Product(int id, String name, int initialStock) {
        this.id = id;
        this.name = name;
        this.stock = initialStock;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getStock() {
        return stock;
    }

    /**
     * Adds quantity to the product's stock.
     * @param quantity The quantity to add. Must be positive.
     */
    public void addStock(int quantity) {
        if (quantity > 0) {
            this.stock += quantity;
        } else {
            System.err.println("Warning: Attempted to add non-positive stock for Product ID " + id);
        }
    }

    /**
     * Removes quantity from the product's stock.
     * @param quantity The quantity to remove. Must be positive.
     * @throws InsufficientStockException If the quantity to remove exceeds available stock.
     */
    public void removeStock(int quantity) throws InsufficientStockException {
        if (quantity <= 0) {
             System.err.println("Warning: Attempted to remove non-positive stock for Product ID " + id);
             return; // Or throw an IllegalArgumentException
        }
        if (this.stock < quantity) {
            throw new InsufficientStockException(this.id, quantity, this.stock);
        }
        this.stock -= quantity;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Stock: " + stock;
    }
}

// Represents a single item within an order
class OrderItem {
    private int productId;
    private int quantity;

    public OrderItem(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public int getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Product ID: " + productId + ", Quantity: " + quantity;
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<OrderItem> items;

    public Order(List<OrderItem> items) {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(items); // Defensive copy
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append("\n");
        sb.append("  Items:\n");
        for (OrderItem item : items) {
            sb.append("    - ").append(item).append("\n");
        }
        return sb.toString();
    }
}

// Manages the warehouse inventory and order processing
public class WarehouseManager {
    private List<Product> inventory; // Using List interface, implemented by ArrayList
    private Queue<Order> orderQueue; // Using Queue interface, implemented by LinkedList
    private Scanner scanner;

    public WarehouseManager() {
        // Initialize inventory with some products
        inventory = new ArrayList<>();
        inventory.add(new Product(1, "Laptop", 10));
        inventory.add(new Product(2, "Keyboard", 25));
        inventory.add(new Product(3, "Mouse", 50));

        // Initialize order queue
        orderQueue = new LinkedList<>(); // LinkedList implements Queue

        // Initialize scanner
        scanner = new Scanner(System.in);

        System.out.println("Warehouse Management System initialized.");
        System.out.println("Available commands: addstock, placeorder, process, view, exit");
    }

    /**
     * Finds a product in the inventory by its ID.
     * @param productId The ID of the product to find.
     * @return The Product object if found, null otherwise.
     */
    private Product findProductById(int productId) {
        for (Product product : inventory) {
            if (product.getId() == productId) {
                return product;
            }
        }
        return null;
    }

    /**
     * Adds stock to an existing product.
     * @param productId The ID of the product.
     * @param quantity The quantity to add.
     */
    public void addStock(int productId, int quantity) {
        Product product = findProductById(productId);
        if (product == null) {
            System.err.println("Error: Product with ID " + productId + " not found.");
            return;
        }
        if (quantity <= 0) {
            System.err.println("Error: Quantity to add must be positive.");
            return;
        }
        product.addStock(quantity);
        System.out.println("Successfully added " + quantity + " units to stock for Product ID " + productId + " (" + product.getName() + "). New stock: " + product.getStock());
    }

    /**
     * Guides the user through placing a new order and adds it to the queue.
     */
    public void placeOrder() {
        List<OrderItem> items = new ArrayList<>();
        System.out.println("Enter order items (Product ID and Quantity), one per line. Enter 0 for Product ID to finish.");

        while (true) {
            try {
                System.out.print("Enter Product ID (0 to finish): ");
                int productId = scanner.nextInt();
                if (productId == 0) {
                    break;
                }

                Product product = findProductById(productId);
                if (product == null) {
                    System.err.println("Error: Product with ID " + productId + " not found. Please enter a valid Product ID.");
                    scanner.nextLine(); // Consume the rest of the line
                    continue;
                }

                System.out.print("Enter Quantity for Product ID " + productId + ": ");
                int quantity = scanner.nextInt();

                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive.");
                    scanner.nextLine(); // Consume the rest of the line
                    continue;
                }

                items.add(new OrderItem(productId, quantity));

            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter numbers for Product ID and Quantity.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 System.err.println("An unexpected error occurred during order item input: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace for debugging
                 scanner.nextLine(); // Attempt to clear the line
            }
        }

        if (items.isEmpty()) {
            System.out.println("No items added to the order. Order cancelled.");
        } else {
            Order newOrder = new Order(items);
            orderQueue.offer(newOrder); // Add order to the queue
            System.out.println("Order " + newOrder.getOrderId() + " placed successfully and added to the processing queue.");
            System.out.println(newOrder); // Print order details
        }
         scanner.nextLine(); // Consume the leftover newline after the last nextInt()
    }

    /**
     * Attempts to process the next order in the queue.
     */
    public void processNextOrder() {
        Order orderToProcess = orderQueue.peek(); // Peek to get the order without removing it yet

        if (orderToProcess == null) {
            System.out.println("No orders in the queue to process.");
            return;
        }

        System.out.println("Attempting to process Order ID: " + orderToProcess.getOrderId());

        // Check stock availability for all items first (pre-check)
        // This prevents partial stock reduction before a failure
        boolean sufficientStockForAllItems = true;
        try {
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProductId());
                if (product == null) {
                    System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Product with ID " + item.getProductId() + " not found in inventory.");
                    sufficientStockForAllItems = false; // Treat missing product as insufficient stock for processing
                    break; // Stop checking this order
                }
                // This check is redundant if removeStock throws, but good for a clear pre-check message
                if (product.getStock() < item.getQuantity()) {
                     System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Insufficient stock for Product ID " + item.getProductId() + ". Requested: " + item.getQuantity() + ", Available: " + product.getStock());
                     sufficientStockForAllItems = false;
                     break; // Stop checking this order
                }
            }
        } catch (Exception e) {
             // Catch unexpected errors during pre-check
             System.err.println("An unexpected error occurred during stock pre-check for Order " + orderToProcess.getOrderId() + ": " + e.getMessage());
             e.printStackTrace(System.err);
             sufficientStockForAllItems = false; // Assume failure
        }


        if (!sufficientStockForAllItems) {
             // If pre-check failed, remove order and report error
            orderQueue.poll(); // Remove the order from the queue
            System.err.println("Order " + orderToProcess.getOrderId() + " failed to process due to insufficient stock or missing product. Order discarded.");
            return;
        }

        // If pre-check passed, attempt to reduce stock
        try {
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProductId());
                // We already checked if product exists and has stock in the pre-check,
                // but the removeStock method itself also throws InsufficientStockException,
                // providing a second layer of validation and the required exception usage.
                 if (product != null) { // Should not be null based on pre-check, but defensive
                    product.removeStock(item.getQuantity()); // This can throw InsufficientStockException
                 } else {
                     // This case should ideally not be reached if pre-check is thorough,
                     // but included for robustness.
                     throw new InsufficientStockException(item.getProductId(), item.getQuantity(), 0);
                 }
            }

            // If we reached here, all items were successfully processed
            orderQueue.poll(); // Remove the order from the queue
            System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully.");

        } catch (InsufficientStockException e) {
            // This catch block handles the exception thrown by product.removeStock()
            orderQueue.poll(); // Remove the order from the queue
            System.err.println("Order " + orderToProcess.getOrderId() + " failed during processing: " + e.getMessage());
            System.err.println("Order discarded.");
        } catch (Exception e) {
             // Catch any other unexpected errors during processing
             orderQueue.poll(); // Remove the order from the queue
             System.err.println("An unexpected error occurred during processing Order " + orderToProcess.getOrderId() + ": " + e.getMessage());
             e.printStackTrace(System.err);
             System.err.println("Order discarded.");
        }
    }

    /**
     * Displays the current inventory levels of all products.
     */
    public void viewInventory() {
        System.out.println("\n--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main command loop for the warehouse manager.
     */
    public void run() {
        String command;
        boolean running = true;

        while (running) {
            System.out.print("\nEnter command: ");
            command = scanner.next().toLowerCase(); // Read command

            try { // Class-wide try-catch for general command processing issues
                switch (command) {
                    case "addstock":
                        try {
                            int productId = scanner.nextInt();
                            int quantity = scanner.nextInt();
                            addStock(productId, quantity);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for addstock. Please enter product ID and quantity as numbers.");
                            scanner.next(); // Consume the invalid input
                            scanner.nextLine(); // Consume the rest of the line
                        }
                        break;

                    case "placeorder":
                        scanner.nextLine(); // Consume the newline left by next()
                        placeOrder();
                        break;

                    case "process":
                        processNextOrder();
                        break;

                    case "view":
                        viewInventory();
                        break;

                    case "exit":
                        System.out.println("Exiting Warehouse Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Unknown command. Available commands: addstock, placeorder, process, view, exit");
                        scanner.nextLine(); // Consume the rest of the line
                        break;
                }
            } catch (Exception e) {
                // Generic catch for unexpected errors in the command loop
                System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                e.printStackTrace(System.err);
                // Depending on the error, you might need to consume input or reset state
                // For simplicity here, we just print and continue the loop.
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        manager.run();
    }
}
