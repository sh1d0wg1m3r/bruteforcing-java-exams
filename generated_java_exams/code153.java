/*
 * Exam Question #153
 * Generated on: 2025-05-11 22:22:39
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Service Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based application to simulate a document print service. The service manages incoming print jobs, processes them in the order they are received, and keeps a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Class Design:**
 *     *   Create a class `PrintJob` to represent a single print job. It should have private fields for a unique job ID (an integer), the document name (a String), and the number of pages (an integer). Include a constructor, getter methods for all fields, and a `toString()` method for easy display. Implement basic validation in the constructor (e.g., document name not empty, pages positive).
 *     *   Create a class `PrintService` that manages the print jobs. It should contain the main application logic and the data structures for managing jobs.
 * 
 * 2.  **Data Structures:**
 *     *   Inside the `PrintService` class, use a `java.util.Queue` (specifically, a `LinkedList` implementation) to hold the pending print jobs. Jobs should be processed in First-In, First-Out (FIFO) order.
 *     *   Inside the `PrintService` class, use a `java.util.List` (specifically, an `ArrayList` implementation) to store the history of completed print jobs.
 * 
 * 3.  **User Interface:**
 *     *   Implement a console-based menu using `java.util.Scanner` for user input. The menu should display the following options:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Job Queue
 *         4.  View Completed Jobs
 *         5.  Exit
 * 
 * 4.  **Program Flow:**
 *     *   Use a `switch` statement within a loop to handle the user's menu choice.
 *     *   The program should repeatedly display the menu and process user input until the 'Exit' option is chosen.
 * 
 * 5.  **Core Functionality:**
 *     *   **Add New Print Job:** Prompt the user for the document name and number of pages. Generate a unique job ID (start from 1 and increment). Create a `PrintJob` object and add it to the pending job queue.
 *     *   **Process Next Job:** Remove the oldest job from the queue. Simulate processing (print a message). Add the processed job to the completed jobs list. If the queue is empty, inform the user.
 *     *   **View Job Queue:** Display the details of all jobs currently waiting in the queue, in the order they will be processed.
 *     *   **View Completed Jobs:** Display the details of all jobs that have been processed and are in the history list.
 * 
 * 6.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and listing jobs.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, operation failures).
 *     *   Implement robust exception handling using `try-catch` blocks:
 *         *   Catch `java.util.InputMismatchException` when reading integer input (menu choice, number of pages) if the user enters non-numeric text. Display an error and allow the user to try again.
 *         *   Handle validation errors from the `PrintJob` constructor (e.g., non-positive pages, empty name) by catching the appropriate exception (`IllegalArgumentException`) in the `addJob` logic and reporting the error.
 *         *   Ensure that attempting to process a job from an empty queue is handled gracefully (check if the queue is empty before attempting to remove an element).
 *         *   Implement a **class-wide** `try-catch` block in the main execution loop (`PrintService.run()` method) to catch any other unexpected runtime exceptions that might occur during the program's execution, printing a generic error message to `System.err` before the program potentially terminates (or attempts to continue if possible).
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation by making class fields private and providing public methods where necessary.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., method descriptions).
 *     *   Ensure input validation is performed where necessary (as described in error handling).
 *     *   Structure the code logically with helper methods for different tasks.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting the menu, accepting input, performing actions, and displaying results or errors using `System.out` and `System.err` as specified. Example interactions might look like:
 * 
 * ```
 * --- Print Service Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Job Queue
 * 4. View Completed Jobs
 * 5. Exit
 * --------------------------
 * Enter your choice: 1
 * --- Add New Print Job ---
 * Enter document name: Report.pdf
 * Enter number of pages: 15
 * Successfully added job: Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 1
 * --- Add New Print Job ---
 * Enter document name: Presentation.pptx
 * Enter number of pages: abc
 * Error: Invalid input. Please enter a valid number for pages.
 * Enter number of pages: -5
 * Error: Number of pages must be positive.
 * Enter number of pages: 20
 * Successfully added job: Job ID: 2, Document: 'Presentation.pptx', Pages: 20
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Job Queue ---
 * 1. Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 2. Job ID: 2, Document: 'Presentation.pptx', Pages: 20
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Job ---
 * Processing job: Job ID: 1, Document: 'Report.pdf', Pages: 15
 * Job 1 completed and moved to history.
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Jobs History ---
 * 1. Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Job ---
 * Processing job: Job ID: 2, Document: 'Presentation.pptx', Pages: 20
 * Job 2 completed and moved to history.
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Job ---
 * Job queue is empty. No jobs to process.
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 99
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: exit
 * Invalid input. Please enter a number corresponding to the menu options.
 * 
 * --- Print Service Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Print Service. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the `PrintJob` and `PrintService` classes according to these requirements.
 *
 * EXPLANATION:
 * This solution implements a `PrintService` simulation according to the requirements, demonstrating the use of various Java core concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `PrintJob`: A simple Plain Old Java Object (POJO) class representing a print job. It encapsulates the job's data (`jobId`, `documentName`, `numberOfPages`) with private fields and public getter methods. The constructor includes input validation for the document name and page count, throwing `IllegalArgumentException` if validation fails. The `toString()` method provides a convenient string representation for printing.
 *     *   `PrintService`: This is the main class containing the application logic. It holds instances of the data structures and the `Scanner`, and includes methods for each menu operation and the main execution loop (`run`).
 * 
 * 2.  **Data Structures:**
 *     *   `jobQueue`: Declared as `Queue<PrintJob>` and initialized as `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` and provides the required FIFO behavior for managing pending jobs. Jobs are added using `queue.add()` and removed from the front using `queue.poll()` (or `queue.remove()`).
 *     *   `completedJobs`: Declared as `List<PrintJob>` and initialized as `new ArrayList<>()`. `ArrayList` is a common implementation of `List` and is suitable for storing the history of completed jobs where order matters (order of completion) but access by index or iteration is needed, not necessarily FIFO removal. Jobs are added using `list.add()`.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   A `Scanner` object reads input from `System.in`.
 *     *   `System.out` is used extensively for displaying the menu, prompts, success messages, and the contents of the queue and completed lists, adhering to the requirement for normal output.
 *     *   The `run()` method contains the main loop that repeatedly displays the menu (`displayMenu()`) and reads the user's integer choice using `scanner.nextInt()`.
 *     *   A `switch` statement directs the program flow based on the integer choice, calling the appropriate private helper method (`addJob`, `processNextJob`, `viewQueue`, `viewCompletedJobs`) or exiting the loop.
 *     *   `System.err` is used specifically for displaying error messages, such as invalid menu choices or input validation failures, as required.
 * 
 * 4.  **Core Functionality Implementation:**
 *     *   `addJob()`: Prompts for input, reads document name (`nextLine`) and pages (`nextInt`). It includes a loop and `try-catch` specifically for reading the number of pages to handle `InputMismatchException` and re-prompt until valid integer input is given. It also validates the page count (> 0). After getting valid input, it attempts to create a `PrintJob`. It catches `IllegalArgumentException` from the `PrintJob` constructor if the validation fails there (e.g., empty name), reporting the error using `System.err`. If successful, the job is added to the `jobQueue` using `add()`, and `nextJobId` is incremented.
 *     *   `processNextJob()`: Checks if `jobQueue` is empty using `isEmpty()`. If not empty, it retrieves and removes the next job using `jobQueue.poll()`. `poll()` is used here as it's safer than `remove()` (which throws `NoSuchElementException` if empty), although the `isEmpty()` check already prevents that. The processed job is then added to the `completedJobs` list using `add()`. Success messages are printed to `System.out`. If the queue is empty, a message is printed to `System.out`.
 *     *   `viewQueue()` and `viewCompletedJobs()`: These methods check if their respective collections are empty and print a message if so. Otherwise, they iterate through the collection (using a for-each loop which works for both `Queue` and `List`) and print each job's `toString()` representation to `System.out`.
 * 
 * 5.  **Exception Handling (`try-catch`) and `System.err`:**
 *     *   **Specific Input Handling:** The `addJob()` method has a `try-catch(InputMismatchException)` loop around reading `numberOfPages` to handle non-integer input gracefully, printing an error to `System.err` and re-prompting. The `run()` method has an inner `try-catch(InputMismatchException)` around the main `scanner.nextInt()` call for the menu choice. This catches non-integer menu input, prints an error to `System.err`, and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   **Validation Handling:** `addJob()` catches `IllegalArgumentException` that might be thrown by the `PrintJob` constructor due to invalid data (empty name, non-positive pages), printing the specific validation error message to `System.err`.
 *     *   **Operation Handling:** `processNextJob()` checks `jobQueue.isEmpty()` before calling `poll()`, preventing `NoSuchElementException`. It also includes a general `catch(Exception e)` to catch any other unexpected issues during the processing step.
 *     *   **Class-wide Handling:** The `run()` method includes an outer `try-catch(Exception e)` block that wraps the entire `while` loop. This serves as the required "class-wide" exception handling. Any unhandled exception that occurs within the loop (e.g., in `addJob`, `processNextJob`, etc., if not caught by their specific handlers, or other unexpected runtime errors) will propagate up to this catch block. It prints a generic fatal error message to `System.err`, preventing the program from crashing abruptly and providing some diagnostic information (`e.getMessage()`).
 *     *   **`finally` block:** The `run()` method includes a `finally` block to ensure that the `scanner` object is closed when the `run()` method exits, whether normally (via `return`) or due to an exception.
 * 
 * 6.  **Best Practices:**
 *     *   All data fields in `PrintJob` and `PrintService` are `private`.
 *     *   Methods have descriptive names (e.g., `addJob`, `processNextJob`, `viewQueue`).
 *     *   Comments explain the purpose of classes and methods.
 *     *   Input validation is performed.
 *     *   Error handling is layered, addressing specific expected errors and including a general catch-all.
 *     *   The code is divided into logical methods, making it more readable and maintainable.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured program with robust error handling, meeting the criteria for a challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with ID, document name, and page count.
 */
class PrintJob {
    private int jobId;
    private String documentName;
    private int numberOfPages;

    /**
     * Constructs a new PrintJob.
     *
     * @param jobId The unique identifier for the job.
     * @param documentName The name of the document.
     * @param numberOfPages The number of pages in the document.
     * @throws IllegalArgumentException if documentName is empty or numberOfPages is not positive.
     */
    public PrintJob(int jobId, String documentName, int numberOfPages) {
        // Input validation
        if (documentName == null || documentName.trim().isEmpty()) {
            throw new IllegalArgumentException("Document name cannot be empty.");
        }
        if (numberOfPages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }

        this.jobId = jobId;
        this.documentName = documentName.trim(); // Trim whitespace
        this.numberOfPages = numberOfPages;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getDocumentName() {
        return documentName;
    }

    public int getNumberOfPages() {
        return numberOfPages;
    }

    /**
     * Returns a string representation of the PrintJob.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", Document: '" + documentName + "', Pages: " + numberOfPages;
    }
}

/**
 * Manages the print service, including a queue of pending jobs and a history of completed jobs.
 * Provides a console interface for interaction.
 */
public class PrintService {
    // Private fields for data structures and scanner
    private Queue<PrintJob> jobQueue; // Queue for pending jobs (FIFO)
    private List<PrintJob> completedJobs; // List for completed jobs history
    private Scanner scanner; // Scanner for user input
    private int nextJobId; // Counter for generating unique job IDs

    /**
     * Constructor to initialize the Print Service.
     * Initializes the queue, list, scanner, and job ID counter.
     */
    public PrintService() {
        // Initialize data structures using concrete implementations
        this.jobQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Displays the main menu options to the console.
     * Uses System.out for normal output.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Service Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Job Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("--------------------------");
    }

    /**
     * Handles adding a new print job based on user input.
     * Includes input validation and specific exception handling for input errors.
     * Uses System.out for prompts and success messages, System.err for errors.
     */
    private void addJob() {
        System.out.println("\n--- Add New Print Job ---");
        System.out.print("Enter document name: ");
        String documentName = scanner.nextLine(); // Read document name

        int numberOfPages = 0;
        boolean validInput = false;

        // Loop until valid integer input for pages is received
        while (!validInput) {
            System.out.print("Enter number of pages: ");
            try {
                numberOfPages = scanner.nextInt();
                // Consume the rest of the line after reading the integer
                scanner.nextLine();
                // Validate page count is positive
                if (numberOfPages <= 0) {
                    System.err.println("Error: Number of pages must be positive.");
                } else {
                    validInput = true; // Input is valid, exit loop
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a valid number for pages.");
                // Consume the invalid input from the scanner buffer
                scanner.nextLine();
            }
        }

        // Attempt to create and add the job after getting valid input
        try {
            // Create a new PrintJob object with the next available ID
            PrintJob newJob = new PrintJob(nextJobId, documentName, numberOfPages);
            // Add the job to the end of the queue
            jobQueue.add(newJob);
            System.out.println("Successfully added job: " + newJob);
            nextJobId++; // Increment job ID counter for the next job
        } catch (IllegalArgumentException e) {
            // Catch validation errors thrown by the PrintJob constructor
            System.err.println("Error creating job: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during job creation or adding to queue
            System.err.println("An unexpected error occurred while adding job: " + e.getMessage());
        }
    }

    /**
     * Processes the next print job from the queue.
     * Removes the job from the queue and adds it to the completed list.
     * Uses System.out for processing messages, System.err for errors.
     */
    private void processNextJob() {
        System.out.println("\n--- Process Next Job ---");
        // Check if the queue is empty before attempting to process
        if (jobQueue.isEmpty()) {
            System.out.println("Job queue is empty. No jobs to process.");
        } else {
            try {
                // Retrieve and remove the head of the queue
                // poll() is safer than remove() as it returns null if empty,
                // although we already checked with isEmpty().
                PrintJob processedJob = jobQueue.poll();

                if (processedJob != null) {
                    // Simulate processing
                    System.out.println("Processing job: " + processedJob);
                    // Add the processed job to the completed jobs list
                    completedJobs.add(processedJob);
                    System.out.println("Job " + processedJob.getJobId() + " completed and moved to history.");
                } else {
                    // This case should ideally not happen due to isEmpty() check,
                    // but provides robustness.
                    System.err.println("Error: Failed to retrieve job from queue.");
                }
            } catch (Exception e) {
                // Catch any unexpected runtime errors during processing
                System.err.println("An unexpected error occurred while processing job: " + e.getMessage());
            }
        }
    }

    /**
     * Displays the current list of jobs waiting in the queue.
     * Uses System.out for output.
     */
    private void viewQueue() {
        System.out.println("\n--- Current Job Queue ---");
        if (jobQueue.isEmpty()) {
            System.out.println("The job queue is currently empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            // Using jobQueue directly in a for-each loop iterates through its elements
            for (PrintJob job : jobQueue) {
                System.out.println(index + ". " + job);
                index++;
            }
        }
    }

    /**
     * Displays the history of completed print jobs.
     * Uses System.out for output.
     */
    private void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs History ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the completed jobs list
            int index = 1;
            // Using completedJobs (List) directly in a for-each loop
            for (PrintJob job : completedJobs) {
                System.out.println(index + ". " + job);
                index++;
            }
        }
    }

    /**
     * Runs the main application loop for the Print Service.
     * Contains the main menu interaction, switch statement, and exception handling.
     * Includes specific input handling and a class-wide catch-all.
     */
    public void run() {
        // Outer try-catch block for class-wide exception handling
        try {
            // Main application loop
            while (true) {
                displayMenu(); // Display menu options
                int choice = -1; // Variable to store user choice

                // Inner try-catch block specifically for handling input errors (like non-integer)
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by scanner.nextInt()
                    scanner.nextLine();

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            addJob(); // Call method to add a job
                            break;
                        case 2:
                            processNextJob(); // Call method to process the next job
                            break;
                        case 3:
                            viewQueue(); // Call method to view the job queue
                            break;
                        case 4:
                            viewCompletedJobs(); // Call method to view completed jobs
                            break;
                        case 5:
                            System.out.println("Exiting Print Service. Goodbye!");
                            return; // Exit the run method, terminating the application loop
                        default:
                            // Handle integer choices that are outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break; // Continue the loop
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the input was not an integer
                    System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
                    // Consume the invalid input from the scanner buffer to prevent infinite loop
                    scanner.nextLine();
                }
                // Any other unexpected runtime exception from methods like addJob, processNextJob etc.
                // that were not caught by their internal specific handlers will propagate up
                // and be caught by the outer catch block.

            } // End of while loop
        } catch (Exception e) {
            // This outer catch block serves as the class-wide handler for any
            // unexpected exceptions that occur during the main execution loop.
            System.err.println("An unexpected fatal error occurred in the Print Service: " + e.getMessage());
            // Optionally print stack trace for detailed debugging during development/exam
            // e.printStackTrace(System.err);
        } finally {
            // The finally block ensures the scanner is closed regardless of how
            // the try block exits (normal completion, return, or exception).
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation message
            }
        }
    }

    /**
     * Main method to start the Print Service application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintService service = new PrintService(); // Create an instance of the service
        service.run(); // Start the main application loop
    }
}
