/*
 * Exam Question #596
 * Generated on: 2025-05-12 16:12:25
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Software Development Task Queue Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simple command-line application to manage a queue of software development tasks. The system should allow users to add new tasks to a pending queue, process the next task from the queue, view the tasks currently in the pending queue, and view a history of completed tasks.
 * 
 * Each task should have a unique ID, a description, and a priority level (represented by an integer, where a lower number indicates higher priority - though for simplicity, the processing will be strictly FIFO based on arrival order in the queue).
 * 
 * The system must interact with the user via the console, presenting a menu of options.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `priority` (int). Include a constructor, public getter methods for all fields, and a meaningful `toString()` method.
 * 2.  **Task Management Logic:** Create a `TaskQueueManager` class to handle the core logic.
 *     *   It must contain a `private Queue<Task>` to hold tasks that are pending. Use a `LinkedList` as the concrete implementation.
 *     *   It must contain a `private List<Task>` to hold tasks that have been completed. Use an `ArrayList` as the concrete implementation, but declare the field type as `List`.
 *     *   It must use a `private Scanner` instance to read user input from `System.in`.
 *     *   Implement the following public methods:
 *         *   `addTask()`: Prompts the user for task description and priority. Creates a new `Task` object (assigning a simple incrementing ID starting from 1) and adds it to the pending queue. Must handle potential `InputMismatchException` if the user enters non-integer priority.
 *         *   `processNextTask()`: Removes the next task from the pending queue (FIFO), changes its status conceptually (though we won't add a status field to `Task` for this problem's scope - just move it), and adds it to the completed tasks list. If the queue is empty, it should inform the user.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them. If the queue is empty, it should inform the user.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed tasks list. If the list is empty, it should inform the user.
 *         *   `run()`: This method should contain the main application loop. It should repeatedly display a menu of options (Add Task, Process Next, View Pending, View Completed, Exit), read the user's choice using the `Scanner`, and use a `switch` statement to call the appropriate management method. The loop should continue until the user chooses to exit.
 * 3.  **User Interaction and Output:**
 *     *   Use `System.out` for displaying the menu, task details, and success messages.
 *     *   Use `System.err` for displaying error messages, such as invalid menu choices or input errors during task creation.
 * 4.  **Error Handling:**
 *     *   Implement robust exception handling. The `run()` method should have a `try-catch` block that wraps the main loop's operations (reading input, processing choice) to catch potential unexpected errors and print a generic error message to `System.err`.
 *     *   Specific input validation (like the priority in `addTask`) should also be handled with `try-catch` within the respective methods, using `System.err` for specific error messages.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Add comments where necessary to explain logic.
 *     *   Close the `Scanner` when the application exits.
 * 
 * **Expected Output (Example Interaction):**
 * 
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter task priority (integer): 2
 * Task added: Task{id=1, description='Implement login feature', priority=2}
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write unit tests
 * Enter task priority (integer): 1
 * Task added: Task{id=2, description='Write unit tests', priority=1}
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=1, description='Implement login feature', priority=2}
 * Task{id=2, description='Write unit tests', priority=1}
 * ---------------------
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Implement login feature', priority=2}
 * Task completed and moved to history.
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=2, description='Write unit tests', priority=1}
 * ---------------------
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Implement login feature', priority=2}
 * -----------------------
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * java.util.InputMismatchException
 * ... (stack trace) ...
 * 
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Note:** The provided example interaction includes an `InputMismatchException` example. Your system should handle this gracefully within the loop's `try-catch`.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line task management system using the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple data structure (POJO) to represent a task. It has private fields (`id`, `description`, `priority`) ensuring encapsulation. Public getter methods provide controlled access to the task's data. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`TaskQueueManager` Class:** This is the core class managing the task flow.
 *     *   **`Queue<Task> pendingTasks`:** A `LinkedList` is used here because it implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a task queue. Tasks are added to the end (`add()`) and removed from the front (`poll()`).
 *     *   **`List<Task> completedTasks`:** An `ArrayList` is used to store completed tasks, allowing for dynamic resizing and easy iteration. It is declared using the `List` interface type, promoting programming to interfaces.
 *     *   **`Scanner scanner`:** Used to read user input from the console (`System.in`).
 *     *   **`nextTaskId`:** A simple counter to assign unique IDs to new tasks.
 *     *   **`addTask()`:** Prompts for task details. It uses a `try-catch` block specifically to handle `InputMismatchException` when reading the integer priority, preventing the program from crashing if the user enters non-numeric input. `scanner.nextLine()` is used carefully after `scanner.nextInt()` to consume the leftover newline character.
 *     *   **`processNextTask()`:** Uses the `poll()` method of the `Queue`. `poll()` is safer than `remove()` as it returns `null` if the queue is empty, which is checked before attempting to process. The processed task is then added to the `completedTasks` list.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`:** These methods iterate through the respective collections (`pendingTasks` and `completedTasks`) using enhanced for loops to display the task details without modifying the collections. They check if the collections are empty before iterating.
 *     *   **`displayMenu()`:** A helper method to print the user options.
 *     *   **`run()`:** This method contains the main loop that drives the application.
 *         *   It displays the menu.
 *         *   It reads the user's integer choice using `scanner.nextInt()`. A `scanner.nextLine()` call immediately follows to consume the newline character, which is crucial before the next `scanner.nextLine()` call (e.g., in `addTask`).
 *         *   A **`switch`** statement is used to elegantly handle the different menu options, calling the corresponding methods (`addTask`, `processNextTask`, etc.). A `default` case handles invalid integer inputs.
 *         *   **Class-wide `try-catch`:** The `run()` method is wrapped in a large `try-catch(Exception e)` block. This provides a safety net to catch any unexpected runtime exceptions that might occur within the loop or called methods (beyond the specific `InputMismatchException` handled internally in `addTask` and within the loop's input reading). It prints a generic error message and the stack trace to `System.err`.
 *         *   An inner `try-catch(InputMismatchException e)` is specifically placed around the `scanner.nextInt()` call within the loop. This handles cases where the user enters non-integer input for the menu choice itself, preventing the loop from breaking or entering an infinite loop.
 *         *   The `finally` block ensures that the `Scanner` is closed, releasing system resources, regardless of whether the loop finished normally or an exception occurred.
 *     *   **`main()`:** The entry point of the application, which simply creates an instance of `TaskQueueManager` and calls its `run()` method.
 * 
 * This solution demonstrates the practical use of `Queue`, `List`, `ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` for robust error handling within a structured, object-oriented program following common Java best practices like encapsulation and meaningful naming.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a software development task.
 */
class Task {
    private int id;
    private String description;
    private int priority; // Lower number indicates higher priority

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', priority=" + priority + '}';
    }
}

/**
 * Manages the queue of pending tasks and a list of completed tasks.
 */
public class TaskQueueManager { // Changed to public for main method access

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared as List interface
    private Scanner scanner;
    private int nextTaskId; // To generate unique task IDs

    /**
     * Constructs a new TaskQueueManager.
     * Initializes the pending queue, completed list, scanner, and task ID counter.
     */
    public TaskQueueManager() {
        pendingTasks = new LinkedList<>(); // Concrete implementation for Queue
        completedTasks = new ArrayList<>(); // Concrete implementation for List
        scanner = new Scanner(System.in);
        nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue based on user input.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        int priority = -1;
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter task priority (integer): ");
            try {
                priority = scanner.nextInt();
                validInput = true; // Input was successfully read as an integer
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter an integer for priority.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } finally {
                 // Consume the rest of the line after reading the integer or invalid input
                 // This is important to clear the buffer before the next scanner.nextLine() call
                 // if nextInt() was successful.
                 if (validInput) { // Only consume newline if nextInt was successful
                     scanner.nextLine();
                 }
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.add(newTask);
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue, moving it to the completed list.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process.");
        } else {
            Task processedTask = pendingTasks.poll(); // Retrieves and removes the head of the queue
            if (processedTask != null) { // poll() returns null if queue is empty, but we already checked
                completedTasks.add(processedTask);
                System.out.println("Processing task: " + processedTask);
                System.out.println("Task completed and moved to history.");
            }
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed tasks history list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks in history.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and dispatches commands using a switch statement.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Task Management System.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    System.err.println(e); // Print the exception details to stderr
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                }
                // Note: Other potential exceptions during method calls (e.g., NullPointerException if not careful)
                // would be caught by the outer catch block.
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the application run
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to stderr
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     */
    public static void main(String[] args) {
        TaskQueueManager manager = new TaskQueueManager();
        manager.run();
    }
}
