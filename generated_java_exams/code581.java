/*
 * Exam Question #581
 * Generated on: 2025-05-12 16:10:21
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Objective:** Design and implement a simple command-line task management system that allows users to add tasks, process the next pending task, view a history of completed tasks, and exit. This system must demonstrate a solid understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Scenario:** You are building a basic backend system for managing a queue of tasks that need sequential processing. Once a task is processed, it should be moved to a history log.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class.
 *     *   It should have a private field for the task `description` (String).
 *     *   It should have a private field for the task `status` (use an enum: `PENDING`, `COMPLETED`).
 *     *   Provide a constructor `Task(String description)` that initializes the task with the `PENDING` status.
 *     *   Provide a public method `markAsCompleted()` that changes the status to `COMPLETED`.
 *     *   Provide public getter methods for `description` and `status`.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (e.g., "[PENDING] Buy groceries" or "[COMPLETED] Pay bills").
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   It must use a `java.util.List<Task>` to hold tasks that have been completed, using `java.util.ArrayList` as the concrete implementation. Declare the field using the `List` interface type.
 *     *   Provide a public method `addTask(String description)`:
 *         *   This method should create a new `Task` object with the given description.
 *         *   It must validate that the description is not null or empty (whitespace only is also considered empty). If invalid, print an error message to `System.err` and do not add the task.
 *         *   If valid, add the new task to the pending tasks queue and print a success message to `System.out`.
 *     *   Provide a public method `processNextTask()`:
 *         *   This method should take the next task from the front of the pending tasks queue.
 *         *   If the queue is empty, print an error message to `System.err` indicating no tasks are pending.
 *         *   If a task is retrieved, mark it as `COMPLETED` using its `markAsCompleted()` method.
 *         *   Move the completed task to the completed tasks history list.
 *         *   Print a success message to `System.out` indicating which task was processed.
 *     *   Provide a public method `viewTaskHistory()`:
 *         *   Iterate through the completed tasks history list.
 *         *   Print each completed task (using its `toString()` method) to `System.out`.
 *         *   If the history is empty, print a message indicating that to `System.out`.
 * 
 * 3.  **Main Application Logic:** Create a class with a `main` method (e.g., `TaskApp`).
 *     *   Instantiate the `TaskManager`.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a command loop that continuously:
 *         *   Displays a menu of options: Add Task, Process Next Task, View History, Exit.
 *         *   Reads the user's command (a single integer or string).
 *         *   Uses a `switch` statement to handle the different commands.
 *             *   **Add Task:** Prompt for the task description, read it, and call `manager.addTask()`.
 *             *   **Process Task:** Call `manager.processNextTask()`.
 *             *   **View History:** Call `manager.viewTaskHistory()`.
 *             *   **Exit:** Terminate the program.
 *             *   **Invalid Command:** Print an error message to `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential runtime errors during the program's execution (e.g., unexpected input issues, though `Scanner` exceptions are less common with `nextLine`). A `try-with-resources` for the `Scanner` is recommended.
 *     *   Use `System.out` for menu prompts, successful operations, and history display.
 *     *   Use `System.err` for invalid input errors and operational errors (e.g., trying to process an empty queue).
 * 
 * **Expected Output:**
 * 
 * *   Menu should be displayed clearly.
 * *   Adding a task: Success message like "Task added: [PENDING] ..."
 * *   Adding an invalid task: Error message to `System.err` like "Error: Task description cannot be empty."
 * *   Processing a task: Success message like "Processed task: [COMPLETED] ..."
 * *   Processing when queue is empty: Error message to `System.err` like "Error: No tasks pending to process."
 * *   Viewing history: List of completed tasks or a message if history is empty.
 * *   Invalid command: Error message to `System.err` like "Error: Invalid command. Please try again."
 * *   Program termination upon Exit.
 * 
 * **Constraint Checklist & Important Notes:**
 * 
 * *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Follow best practices: encapsulation, meaningful names, comments, validation, error handling.
 * *   The `try-catch` should ideally wrap the main command loop or the entire `main` method body.
 * *   The `Scanner` should be closed properly, ideally using `try-with-resources`.
 * 
 * This task requires integrating multiple core Java concepts into a functional application. Good luck!
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents individual tasks with a `description` and `status`.
 *     *   Uses an `enum` (`TaskStatus`) for a type-safe representation of status (`PENDING`, `COMPLETED`).
 *     *   Fields are `private` adhering to encapsulation.
 *     *   Provides a constructor, a method to change status (`markAsCompleted`), and getters.
 *     *   Overrides `toString()` for clear output formatting, fulfilling a requirement and best practice.
 *     *   Includes basic validation in the constructor, although the main validation happens in `TaskManager`.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Acts as the core logic handler.
 *     *   Uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to manage tasks waiting for processing in FIFO order.
 *     *   Uses a `List<Task>` (`completedTasksHistory`) implemented by `ArrayList` to store tasks after they are processed. Declaring it as `List` demonstrates programming to the interface.
 *     *   `addTask(String description)`: Validates input (null or empty description) and prints to `System.err` if invalid. Adds valid tasks to the `pendingTasks` queue using `offer()`. Prints success messages to `System.out`.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. If `poll()` returns `null`, it means the queue was empty, and an error is printed to `System.err`. Otherwise, it marks the task as completed and adds it to the `completedTasksHistory` list. Success messages go to `System.out`.
 *     *   `viewTaskHistory()`: Iterates through the `completedTasksHistory` list and prints each task using its `toString()` method to `System.out`. Handles the case where the history is empty.
 * 
 * 3.  **`TaskApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Instantiates `TaskManager` and `Scanner`.
 *     *   Uses a `try-with-resources` block for the `Scanner` to ensure it's automatically closed, preventing resource leaks.
 *     *   The main application logic runs inside a `while` loop controlled by the `running` flag.
 *     *   A nested `try-catch (Exception e)` block is placed around the main `while` loop. This acts as a class-wide exception handler, catching any unexpected runtime exceptions that might occur during the command processing loop and printing an error message to `System.err`.
 *     *   `printMenu()`: A helper method to display the user options to `System.out`.
 *     *   Reads user input using `scanner.nextLine()`.
 *     *   A `switch` statement is used to handle the different user commands (1, 2, 3, 4), directing the flow to the appropriate `TaskManager` methods or program exit.
 *     *   The `default` case in the `switch` handles invalid command input, printing an error to `System.err`.
 *     *   `System.out` is used for all normal output (menu, prompts, success messages, history).
 *     *   `System.err` is used exclusively for error messages (invalid input, empty queue processing, invalid command, unexpected runtime errors).
 * 
 * This structure demonstrates proper object-oriented design (separating concerns into classes), effective use of collections (`Queue`, `List`, `ArrayList`, `LinkedList`), control flow (`switch`, `while`), I/O (`Scanner`, `System.out`, `System.err`), and robust error handling (`try-catch`, input validation).
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Objects; // For Objects.requireNonNullElse

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task with a description and status
class Task {
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with the given description.
     * The status is initialized to PENDING.
     *
     * @param description The description of the task. Must not be null or empty.
     */
    public Task(String description) {
        // Basic validation in constructor, though addTask also validates
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim(); // Trim whitespace
        this.status = TaskStatus.PENDING;
    }

    /**
     * Marks the task as completed.
     */
    public void markAsCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    // Getters
    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Provides a string representation of the task including its status.
     *
     * @return A formatted string like "[STATUS] Description".
     */
    @Override
    public String toString() {
        return "[" + status + "] " + description;
    }

    // Optional: hashCode and equals if tasks need unique identification beyond description
    // @Override
    // public boolean equals(Object o) { ... }
    // @Override
    // public int hashCode() { ... }
}

// Manages the collection of pending and completed tasks
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed (history)
    private List<Task> completedTasksHistory;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation for history
        this.completedTasksHistory = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Validates the description before adding.
     *
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }
        try {
            Task newTask = new Task(description);
            pendingTasks.offer(newTask); // Use offer for adding to queue
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            // This catch is technically redundant due to the initial check,
            // but good practice if Task constructor had more complex validation.
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Marks the task as completed and moves it to history.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove head of queue

        if (taskToProcess == null) {
            System.err.println("Error: No tasks pending to process.");
        } else {
            taskToProcess.markAsCompleted();
            completedTasksHistory.add(taskToProcess); // Add to history list
            System.out.println("Processed task: " + taskToProcess);
        }
    }

    /**
     * Displays the history of all completed tasks.
     */
    public void viewTaskHistory() {
        if (completedTasksHistory.isEmpty()) {
            System.out.println("Task history is empty.");
        } else {
            System.out.println("--- Task History ---");
            // Iterate through the List of completed tasks
            for (int i = 0; i < completedTasksHistory.size(); i++) {
                 Task task = completedTasksHistory.get(i);
                 // Using index for numbered list, or just task.toString() is fine
                 System.out.println((i + 1) + ". " + task);
            }
            System.out.println("--------------------");
        }
    }

    /**
     * Checks if there are any pending tasks.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean hasPendingTasks() {
        return !pendingTasks.isEmpty();
    }
}

// Main application class to run the task management system
public class TaskApp {

    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Class-wide exception handling around the main loop
            try {
                while (running) {
                    printMenu();
                    System.out.print("Enter command: ");
                    String command = scanner.nextLine().trim(); // Read full line and trim

                    // Use switch statement for command processing
                    switch (command) {
                        case "1": // Add Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            manager.addTask(description);
                            break;
                        case "2": // Process Next Task
                            manager.processNextTask();
                            break;
                        case "3": // View History
                            manager.viewTaskHistory();
                            break;
                        case "4": // Exit
                            System.out.println("Exiting Task Management System. Goodbye!");
                            running = false; // Set flag to exit loop
                            break;
                        default: // Invalid Command
                            System.err.println("Error: Invalid command. Please enter 1, 2, 3, or 4.");
                            break;
                    }
                    System.out.println(); // Add a newline for better readability between commands

                    // Optional: Add a small delay or prompt to continue if needed
                    // System.out.println("Press Enter to continue...");
                    // scanner.nextLine();
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
         catch (Exception e) {
            // Catch exceptions related to Scanner or try-with-resources itself
            System.err.println("Error initializing or closing scanner: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task History");
        System.out.println("4. Exit");
        System.out.println("--------------------------");
    }
}
