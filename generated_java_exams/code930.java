/*
 * Exam Question #930
 * Generated on: 2025-05-12 17:01:16
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Restaurant Order Management System
 * 
 * **Objective:** Implement a simplified restaurant order management system that handles incoming orders, processes them sequentially, and allows viewing the menu and order statuses. This task requires demonstrating proficiency with core Java collections, control flow, input/output, and exception handling.
 * 
 * **Scenario:** You are developing the backend system for a small restaurant. Orders are taken and added to a queue. The kitchen processes orders one by one from the front of the queue. Customers or staff can view the menu, add new orders, process the next order in the queue, or view pending and completed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items. Use `java.util.List` as the variable type, initialized with `java.util.ArrayList`.
 *     *   Manage incoming orders using a `java.util.Queue`.
 *     *   Keep a history of completed orders using `java.util.List` as the variable type, initialized with `java.util.ArrayList`.
 * 2.  **Core Functionality:**
 *     *   Display the menu with item numbers, names, and prices.
 *     *   Allow adding a new order:
 *         *   Prompt the user to select items from the menu by number.
 *         *   Allow adding multiple items to a single order.
 *         *   Create an `Order` object (you'll need to define this class).
 *         *   Add the newly created order to the pending orders `Queue`.
 *     *   Process the next order:
 *         *   Take the next order from the front of the pending orders `Queue`.
 *         *   Move the processed order to the completed orders `List`.
 *         *   Report which order was processed.
 *     *   View pending orders: List all orders currently in the `Queue`.
 *     *   View completed orders: List all orders in the completed orders `List`.
 *     *   Provide a simple text-based menu for user interaction (e.g., 1. View Menu, 2. Add Order, 3. Process Next Order, 4. View Pending Orders, 5. View Completed Orders, 6. Exit).
 * 3.  **User Input:** Use `java.util.Scanner` to read user choices and order details from `System.in`.
 * 4.  **Control Flow:** Use a `switch` statement to handle the main menu options.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful actions, and lists of orders.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 6.  **Exception Handling:** Implement `try-catch` blocks for class-wide exception handling, particularly around the main operational loop, to gracefully handle unexpected errors or invalid input formats. Also, handle specific potential issues like trying to process an order when the queue is empty.
 * 7.  **Object-Oriented Design:**
 *     *   Create a `MenuItem` class (at least `name` and `price`).
 *     *   Create an `Order` class (at least a unique ID, a list of `MenuItem`s, and potentially a status).
 *     *   Create a main `RestaurantSystem` class to manage the menu, queues, lists, and user interaction logic.
 *     *   Use private fields and public methods where appropriate (encapsulation).
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include basic input validation (e.g., checking if a menu item number is valid, handling non-numeric input).
 *     *   Add comments to explain complex parts of the code.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. When started, it should display a menu of options. Based on user input, it should perform the requested action, print relevant information to `System.out`, or print error messages to `System.err` if something goes wrong. The system should continue running until the user chooses the "Exit" option.
 * 
 * Example Interaction Flow (Partial):
 * 
 * ```
 * --- Restaurant Management System ---
 * 1. View Menu
 * 2. Add Order
 * 3. Process Next Order
 * 4. View Pending Orders
 * 5. View Completed Orders
 * 6. Exit
 * Enter your choice: 1
 * --- Menu ---
 * 1. Burger - $8.99
 * 2. Fries - $3.49
 * 3. Soda - $1.99
 * ---
 * Enter your choice: 2
 * --- Add New Order ---
 * Select item number (0 to finish): 1
 * Added: Burger
 * Select item number (0 to finish): 2
 * Added: Fries
 * Select item number (0 to finish): 0
 * Order 1 added to queue.
 * --- Restaurant Management System ---
 * ...
 * Enter your choice: 4
 * --- Pending Orders ---
 * Order 1: Burger, Fries
 * ---
 * Enter your choice: 3
 * Processing Order 1...
 * Order 1 processed.
 * --- Restaurant Management System ---
 * ...
 * Enter your choice: 4
 * --- Pending Orders ---
 * No pending orders.
 * ---
 * Enter your choice: 5
 * --- Completed Orders ---
 * Order 1: Burger, Fries
 * ---
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes (`MenuItem`, `Order`, `RestaurantSystem`, and the main class with the `main` method).
 * 
 * **Evaluation Criteria:**
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Implementation of all required functionalities.
 * *   Correct handling of edge cases (e.g., empty queue).
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Code clarity, readability, and adherence to best practices (naming, comments, validation).
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Management System based on the requirements, demonstrating the use of all specified Java components.
 * 
 * 1.  **`MenuItem` Class:** A simple Plain Old Java Object (POJO) representing an item on the menu. It encapsulates the item's `id`, `name`, and `price` with private fields and public getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient formatted string for display.
 * 
 * 2.  **`Order` Class:** Represents a customer's order. It includes a unique `orderId` generated using a static counter, a `List<MenuItem>` to hold the items in the order, and a `status` string (e.g., "PENDING", "COMPLETED"). The constructor initializes the order with items and sets the initial status. The `toString()` method provides a formatted string for displaying order details. It uses an `ArrayList` internally to store the items, fulfilling the `ArrayList` requirement within another class.
 * 
 * 3.  **`RestaurantSystem` Class:** This is the core class managing the system's state and logic.
 *     *   **Collections:**
 *         *   `List<MenuItem> menuItems`: An `ArrayList` is used to store the fixed menu items. Declared as `List` demonstrates using the interface type.
 *         *   `Queue<Order> pendingOrders`: A `LinkedList` is used as the implementation for the `Queue` interface. `Queue` is ideal here because orders are processed in the order they are received (First-In, First-Out - FIFO). `offer()` is used to add to the queue, and `poll()` is used to remove from the front.
 *         *   `List<Order> completedOrders`: An `ArrayList` is used to store orders after they have been processed. Declared as `List` demonstrates using the interface type.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read input from `System.in`.
 *     *   **Methods:**
 *         *   `initializeMenu()`: Populates the `menuItems` list.
 *         *   `displayMenu()`: Iterates through `menuItems` and prints each item.
 *         *   `addOrder()`: Prompts the user to select items by number. It uses a loop and input validation (`try-catch` for `InputMismatchException` and checking item existence) to build a list of items for the current order. A new `Order` object is created with these items and added to the `pendingOrders` queue using `offer()`.
 *         *   `processNextOrder()`: Checks if the `pendingOrders` queue is empty. If not, it uses `poll()` to retrieve and remove the next order. The order's status is updated, and it's added to the `completedOrders` list. An error message is printed to `System.err` if the queue is empty.
 *         *   `viewPendingOrders()`: Iterates through the `pendingOrders` queue (using an enhanced for loop, which doesn't remove elements) and prints each order's details.
 *         *   `viewCompletedOrders()`: Iterates through the `completedOrders` list and prints each completed order.
 *         *   `displayMainMenu()`: Prints the options available to the user.
 *         *   `runSystem()`: This method contains the main application loop. It repeatedly displays the menu, reads the user's choice using `scanner.nextInt()`, and uses a `switch` statement to execute the corresponding action by calling the appropriate methods.
 *     *   **`Switch` Statement:** Used in `runSystem()` to direct program flow based on the user's menu choice.
 *     *   **`System.out` and `System.err`:** Used throughout the class for displaying information (`System.out`) and error messages (`System.err`).
 *     *   **`try-catch`:**
 *         *   A broad `try-catch(Exception e)` block wraps the main `while` loop in `runSystem()`. This provides class-wide handling for unexpected errors that might occur during the execution of the system, ensuring the program doesn't crash immediately.
 *         *   A specific `try-catch(InputMismatchException e)` is used within the `addOrder()` method and the main loop in `runSystem()` to handle cases where the user enters non-numeric input when a number is expected. This prevents the program from crashing due to invalid input format and allows it to prompt the user again. The invalid input is consumed using `scanner.next()`.
 *         *   Checking `pendingOrders.isEmpty()` *before* calling `poll()` in `processNextOrder()` is a form of validation that prevents a potential `NoSuchElementException` (though `poll()` returns `null`, `remove()` would throw it) and allows printing a user-friendly error message to `System.err`.
 * 
 * 4.  **`RestaurantApp` Class:** Contains the `main` method, which serves as the entry point of the application. It simply creates an instance of `RestaurantSystem` and calls its `runSystem()` method to start the interactive loop.
 * 
 * This solution effectively integrates all required components into a practical scenario, demonstrating proper object-oriented design, data structure usage, control flow, input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the restaurant menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return id + ". " + name + " - $" + String.format("%.2f", price);
    }
}

// Represents a customer order
class Order {
    private static int orderCounter = 0; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items;
    private String status; // e.g., PENDING, COMPLETED

    public Order(List<MenuItem> items) {
        this.orderId = ++orderCounter;
        this.items = new ArrayList<>(items); // Create a copy to avoid external modification
        this.status = "PENDING";
    }

    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return items;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ").append(orderId).append(" (").append(status).append("): ");
        if (items.isEmpty()) {
            sb.append("No items");
        } else {
            for (int i = 0; i < items.size(); i++) {
                sb.append(items.get(i).getName());
                if (i < items.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }
}

// Manages the restaurant's orders and menu
class RestaurantSystem {
    private List<MenuItem> menuItems; // Using List interface, implemented by ArrayList
    private Queue<Order> pendingOrders; // Using Queue interface, implemented by LinkedList
    private List<Order> completedOrders; // Using List interface, implemented by ArrayList
    private Scanner scanner;

    public RestaurantSystem() {
        // Initialize collections
        menuItems = new ArrayList<>();
        pendingOrders = new LinkedList<>(); // LinkedList is a common Queue implementation
        completedOrders = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Populate initial menu
        initializeMenu();
    }

    // Initializes the menu items
    private void initializeMenu() {
        menuItems.add(new MenuItem(1, "Burger", 8.99));
        menuItems.add(new MenuItem(2, "Fries", 3.49));
        menuItems.add(new MenuItem(3, "Soda", 1.99));
        menuItems.add(new MenuItem(4, "Pizza Slice", 5.50));
        menuItems.add(new MenuItem(5, "Salad", 7.00));
    }

    // Displays the restaurant menu
    public void displayMenu() {
        System.out.println("\n--- Menu ---");
        for (MenuItem item : menuItems) {
            System.out.println(item);
        }
        System.out.println("---");
    }

    // Allows user to add a new order
    public void addOrder() {
        System.out.println("\n--- Add New Order ---");
        displayMenu();

        List<MenuItem> currentOrderItems = new ArrayList<>();
        int itemNumber;

        while (true) {
            System.out.print("Select item number (0 to finish): ");
            try {
                itemNumber = scanner.nextInt();
                if (itemNumber == 0) {
                    break; // Finish adding items
                }

                boolean found = false;
                for (MenuItem item : menuItems) {
                    if (item.getId() == itemNumber) {
                        currentOrderItems.add(item);
                        System.out.println("Added: " + item.getName());
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    System.err.println("Error: Invalid item number.");
                }

            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
            }
        }

        if (!currentOrderItems.isEmpty()) {
            Order newOrder = new Order(currentOrderItems);
            pendingOrders.offer(newOrder); // Add to the end of the queue
            System.out.println("Order " + newOrder.getOrderId() + " added to queue.");
        } else {
            System.out.println("No items selected. Order not created.");
        }
    }

    // Processes the next order in the queue
    public void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        if (pendingOrders.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
        } else {
            Order orderToProcess = pendingOrders.poll(); // Remove from the front of the queue
            if (orderToProcess != null) { // poll() returns null if queue is empty (already checked, but good practice)
                orderToProcess.setStatus("COMPLETED");
                completedOrders.add(orderToProcess); // Add to completed list
                System.out.println("Processing Order " + orderToProcess.getOrderId() + "...");
                System.out.println("Order " + orderToProcess.getOrderId() + " processed.");
            }
        }
    }

    // Displays all pending orders
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate without removing from the queue
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("---");
    }

    // Displays all completed orders
    public void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("---");
    }

    // Displays the main menu options
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Management System ---");
        System.out.println("1. View Menu");
        System.out.println("2. Add Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. View Completed Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main system loop
    public void runSystem() {
        boolean running = true;
        while (running) {
            try { // Class-wide exception handling for the main loop
                displayMainMenu();
                int choice = scanner.nextInt();

                // Consume the rest of the line after the integer input
                // This is important if the next input is read using scanner.nextLine()
                // However, in this specific case, nextInt() is used repeatedly,
                // so consuming the newline might not be strictly necessary
                // depending on Scanner's behavior, but it's a good practice
                // to prevent issues if you were to mix nextInt/nextDouble with nextLine later.
                // For this problem, we primarily use nextInt, so we can skip scanner.nextLine() here
                // after reading the main menu choice.

                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        addOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        viewCompletedOrders();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }
}

// Main application class
public class RestaurantApp {
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.runSystem();
    }
}
