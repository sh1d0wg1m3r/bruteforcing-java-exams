/*
 * Exam Question #768
 * Generated on: 2025-05-12 16:37:55
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a small team. The system should allow users to add tasks, track their status (Pending, Ready, Completed), manage tasks that are ready for processing using a queue, and view the overall list of tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides the following functionality via a command-line interface:
 * 
 * 1.  **Add Task:** Prompt the user for a task description. Create a new task with a unique ID and initial status `PENDING`. Add this task to the system's task list.
 * 2.  **View All Tasks:** Display all tasks currently in the system, showing their ID, description, and status.
 * 3.  **Mark Task as Ready:** Prompt the user for a task ID. Find the task with the given ID. If it exists and is `PENDING`, change its status to `READY` and add it to a queue of tasks waiting for processing. If the task is not found or is not in the `PENDING` status, display an error message.
 * 4.  **Complete Next Ready Task:** Take the task at the front of the queue of ready tasks. If the queue is not empty, change the status of this task (in the main task list) to `COMPLETED`. If the queue is empty, display an error message.
 * 5.  **View Ready Tasks:** Display all tasks currently in the ready queue.
 * 6.  **Exit:** Terminate the application.
 * 
 * **Technical Constraints:**
 * 
 * *   You **must** use `java.util.Queue` to manage tasks that are ready for processing.
 * *   You **must** use `java.util.ArrayList` to store the master list of all tasks created.
 * *   You **must** declare the master task list using the `java.util.List` interface (e.g., `List<Task> allTasks = new ArrayList<>();`).
 * *   You **must** use `java.util.Scanner` to get user input from the console.
 * *   You **must** use a `switch` statement to handle the main menu options.
 * *   You **must** use `System.err` to print error messages (e.g., invalid input, task not found, queue empty).
 * *   You **must** use `System.out` for normal output (menu, prompts, task listings, success messages).
 * *   You **must** implement exception handling using `try-catch` blocks, particularly for handling non-integer input when an integer is expected and potentially for other runtime errors.
 * *   Create a separate `Task` class with private fields (`id`, `description`, `status`) and appropriate public methods (getters, setters). Use an `enum` for the task status (`PENDING`, `READY`, `COMPLETED`).
 * *   Ensure proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * *   Implement input validation where necessary (e.g., checking if a task ID exists, checking task status before marking ready).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu of options to the user. Based on the user's choice, it should perform the requested action, display relevant information, and handle errors gracefully using `System.err`.
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Mark Task as Ready
 * 4. Complete Next Ready Task
 * 5. View Ready Tasks
 * 6. Exit
 * Enter your choice:
 * ```
 * *(Example interaction for adding a task)*
 * `Enter task description:`
 * `Implement feature X`
 * `Task added with ID: 1`
 * 
 * *(Example interaction for marking ready)*
 * `Enter Task ID to mark as Ready:`
 * `1`
 * `Task 1 marked as READY and added to the queue.`
 * 
 * *(Example interaction for completing)*
 * `Completed task: [ID=1, Description=Implement feature X, Status=COMPLETED]`
 * 
 * *(Example error output)*
 * `Enter Task ID to mark as Ready:`
 * `99`
 * `Error: Task with ID 99 not found.` (Printed to System.err)
 * 
 * `Enter your choice:`
 * `abc`
 * `Error: Invalid input. Please enter a number.` (Printed to System.err)
 * 
 * `Enter your choice:`
 * `4`
 * `Error: The ready task queue is empty.` (Printed to System.err)
 * 
 * ---
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the specified task management logic.
 * *   Proper class design (`Task` class with enum, main class managing collections).
 * *   Effective use of encapsulation and meaningful names.
 * *   Robust input validation and error handling using `try-catch` and `System.err`.
 * *   Clear and user-friendly console interface.
 * *   Adherence to Java coding best practices.
 * 
 * ---
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System as required by the exam question.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming (OOP):**
 *     *   A `Task` class encapsulates the data (id, description, status) and behavior of a single task.
 *     *   An `enum` (`TaskStatus`) is used to represent the fixed set of possible states for a task, improving code readability and preventing invalid status values.
 *     *   The `TaskManager` class manages the collections of tasks and the application logic, demonstrating composition.
 *     *   Encapsulation is applied by making fields `private` and providing public methods (getters, setters, operational methods) to interact with the objects.
 * 
 * 2.  **Collections Framework (`java.util`):**
 *     *   `java.util.List` interface is used to declare `allTasks`, promoting good practice by programming to an interface.
 *     *   `java.util.ArrayList` is used as the concrete implementation for `allTasks`, providing a dynamic array to store all tasks created.
 *     *   `java.util.Queue` interface is used to declare `readyQueue`, representing tasks waiting for processing in a FIFO (First-In, First-Out) manner.
 *     *   `java.util.LinkedList` is used as the concrete implementation for `readyQueue`, as it efficiently implements the `Queue` interface.
 * 
 * 3.  **Input/Output:**
 *     *   `java.util.Scanner` is used to read user input from `System.in`.
 *     *   `System.out.println` and `System.out.print` are used for displaying menus, prompts, and successful output.
 *     *   `System.err.println` is specifically used for printing error messages, directing them to the standard error stream, which is good practice for distinguishing errors from normal output.
 * 
 * 4.  **Control Flow:**
 *     *   A `while` loop maintains the main application loop, keeping the program running until the user chooses to exit.
 *     *   A `switch` statement is used within the loop to handle the user's menu choice, directing execution to the appropriate task management method.
 *     *   `if-else if-else` statements are used within methods (like `markTaskReady`) for conditional logic and validation.
 * 
 * 5.  **Error Handling:**
 *     *   `try-catch` blocks are used to handle potential runtime exceptions.
 *     *   `InputMismatchException` is caught specifically when `scanner.nextInt()` is used, preventing the program from crashing if the user enters non-integer input for menu choices or task IDs.
 *     *   A general `Exception` catch is included as a fallback, though more specific catches could be added for other potential issues.
 *     *   Logical errors (e.g., task not found, task not in the correct status, queue empty) are checked explicitly, and informative error messages are printed to `System.err`.
 *     *   `scanner.nextLine()` is used after reading integers (`nextInt()`) to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls. It's also used within catch blocks to clear invalid input.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names are used for classes (`Task`, `TaskManager`), variables (`allTasks`, `readyQueue`, `nextTaskId`), methods (`addTask`, `viewAllTasks`, `markTaskReady`, etc.), and enum constants (`PENDING`, `READY`, `COMPLETED`).
 *     *   Basic Javadoc comments are provided for classes and key methods to explain their purpose.
 *     *   Input validation is performed (checking menu choice range, checking if task ID exists, checking task status).
 *     *   The code is structured logically with a dedicated class for the task object and a main class to manage the system's state and operations.
 * 
 * The solution effectively integrates all the required Java components into a cohesive application that simulates a practical task management scenario, demonstrating advanced understanding of Java fundamentals and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING, READY, COMPLETED
}

// Task Class
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID=" + id + ", Description=" + description + ", Status=" + status + "]";
    }
}

// Main Task Management Class
public class TaskManager {

    // Use List interface for flexibility, implemented by ArrayList
    private List<Task> allTasks;
    // Use Queue interface for ready tasks, implemented by LinkedList
    private Queue<Task> readyQueue;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.readyQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the system.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Displays all tasks in the system.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system.");
        } else {
            System.out.println("--- All Tasks ---");
            for (Task task : allTasks) {
                System.out.println(task);
            }
            System.out.println("-----------------");
        }
    }

    /**
     * Finds a task by its ID.
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Marks a pending task as ready and adds it to the ready queue.
     * @param taskId The ID of the task to mark as ready.
     */
    public void markTaskReady(int taskId) {
        Task task = findTaskById(taskId);

        if (task == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
        } else if (task.getStatus() != TaskStatus.PENDING) {
            System.err.println("Error: Task " + taskId + " is not PENDING. Current status: " + task.getStatus());
        } else {
            task.setStatus(TaskStatus.READY);
            readyQueue.offer(task); // Add to the end of the queue
            System.out.println("Task " + taskId + " marked as READY and added to the queue.");
        }
    }

    /**
     * Completes the next task from the ready queue.
     */
    public void completeNextReadyTask() {
        Task taskToComplete = readyQueue.poll(); // Get and remove the head of the queue

        if (taskToComplete == null) {
            System.err.println("Error: The ready task queue is empty.");
        } else {
            // Although we have the task object from the queue,
            // we should update its status in the main allTasks list
            // to ensure the status change is persistent across views.
            // findTaskById is not strictly needed IF the object reference
            // in the queue is the same as in allTasks, which it is here.
            // However, explicitly finding and updating reinforces the idea
            // of the main list being the source of truth. Let's directly
            // update the object from the queue since it's the same instance.
            taskToComplete.setStatus(TaskStatus.COMPLETED);
            System.out.println("Completed task: " + taskToComplete);
            // Note: The task remains in allTasks with the new status.
        }
    }

    /**
     * Displays tasks currently in the ready queue.
     */
    public void viewReadyTasks() {
        if (readyQueue.isEmpty()) {
            System.out.println("The ready task queue is empty.");
        } else {
            System.out.println("--- Ready Tasks (in queue order) ---");
            // Iterate without removing elements
            for (Task task : readyQueue) {
                System.out.println(task);
            }
            System.out.println("------------------------------------");
        }
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Mark Task as Ready");
        System.out.println("4. Complete Next Ready Task");
        System.out.println("5. View Ready Tasks");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            // Input validation for menu choice
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the rest of the loop and show menu again
            } catch (Exception e) {
                 System.err.println("An unexpected error occurred during input: " + e.getMessage());
                 scanner.nextLine(); // Attempt to clear input
                 continue;
            }


            // Process user choice using switch
            switch (choice) {
                case 1:
                    System.out.print("Enter task description: ");
                    String description = scanner.nextLine();
                    addTask(description);
                    break;
                case 2:
                    viewAllTasks();
                    break;
                case 3:
                    System.out.print("Enter Task ID to mark as Ready: ");
                    try {
                        int taskIdToMarkReady = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        markTaskReady(taskIdToMarkReady);
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a valid Task ID (number).");
                        scanner.nextLine(); // Consume invalid input
                    } catch (Exception e) {
                         System.err.println("An unexpected error occurred: " + e.getMessage());
                         scanner.nextLine();
                    }
                    break;
                case 4:
                    completeNextReadyTask();
                    break;
                case 5:
                    viewReadyTasks();
                    break;
                case 6:
                    System.out.println("Exiting Task Management System. Goodbye!");
                    running = false;
                    break;
                default:
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
