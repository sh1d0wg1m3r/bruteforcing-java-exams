/*
 * Exam Question #397
 * Generated on: 2025-05-11 23:05:09
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Scheduler**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line based Task Scheduling system. This system should allow users to add tasks to a queue, process the next task in the queue, view the current tasks waiting in the queue, and view tasks that have been completed.
 * 
 * The system must adhere to the following requirements and demonstrate advanced Java concepts:
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. Each task should have:
 *     *   A unique integer ID (automatically assigned).
 *     *   A String description.
 *     *   An integer priority (e.g., 1-5, where 1 is highest priority).
 *     *   Implement a `toString()` method for easy display.
 * 
 * 2.  **Task Scheduler Logic:** Create a class `TaskScheduler` that manages the tasks. It must contain:
 *     *   A `java.util.Queue` to hold tasks waiting to be processed. Use a concrete implementation like `LinkedList`.
 *     *   A `java.util.List` (specifically, use `java.util.ArrayList`) to store tasks once they are completed.
 *     *   Methods for:
 *         *   `addTask(String description, int priority)`: Adds a new task to the waiting queue. Validate that priority is within a valid range (e.g., 1-5). If invalid, print an error to `System.err` and do not add the task.
 *         *   `processNextTask()`: Removes the task at the front of the queue, marks it as completed, and moves it to the completed tasks list. If the queue is empty, print an error message to `System.err`.
 *         *   `viewQueue()`: Prints the details of all tasks currently in the waiting queue to `System.out`. Indicate if the queue is empty.
 *         *   `viewCompletedTasks()`: Prints the details of all tasks in the completed tasks list to `System.out`. Indicate if the list is empty.
 * 
 * 3.  **User Interface:** Implement a command-line interface in a main application class.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user (e.g., Add Task, Process Task, View Queue, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, task details, and successful actions.
 *     *   Use `System.err` for displaying invalid input messages, validation errors, and error conditions (like processing an empty queue).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main application loop to gracefully handle unexpected runtime errors (e.g., non-integer input for menu choice).
 *     *   Handle specific error conditions within methods (like an empty queue during processing) and report them using `System.err`.
 *     *   Validate user input (e.g., priority range).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but not strictly required for this exam, inline comments explaining logic are sufficient).
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Expected Output:**
 * 
 * *   Menu options are displayed clearly using `System.out`.
 * *   Task details (ID, description, priority) are printed when viewing queues/lists using `System.out`.
 * *   Confirmation messages for successful actions (like adding or processing) are printed to `System.out`.
 * *   Error messages for invalid input, validation failures, or operational errors (like empty queue) are printed to `System.err`.
 * *   The program handles non-integer input for menu choices gracefully without crashing, prompting the user to try again and printing an error to `System.err`.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * *   The solution should be contained within a few classes (`Task`, `TaskScheduler`, and a main application class).
 * 
 * **Task:**
 * 
 * Write the complete Java code for this Task Scheduling system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Scheduling system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and `priority`.
 *     *   A `static int nextId` ensures each task gets a unique, automatically assigned ID.
 *     *   Getters provide controlled access to the private fields (encapsulation).
 *     *   `toString()` provides a convenient formatted string for printing task details.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   Manages the core logic using a `Queue<Task>` (`taskQueue`) for waiting tasks and a `List<Task>` (`completedTasks`) for finished tasks.
 *     *   `LinkedList` is chosen as a concrete implementation for `Queue` because it efficiently supports adding to the end and removing from the beginning, which is the standard queue behavior.
 *     *   `ArrayList` is chosen as a concrete implementation for `List` to store completed tasks, as random access or simple iteration is common for viewing completed items.
 *     *   `addTask`: Takes description and priority, validates the priority range (1-5). If valid, a new `Task` object is created and added to the `taskQueue` using `offer()`. If invalid, an error message is printed to `System.err`.
 *     *   `processNextTask`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. If `poll()` returns `null` (queue is empty), an error is printed to `System.err`. Otherwise, the retrieved task is added to the `completedTasks` list.
 *     *   `viewQueue`: Iterates through the `taskQueue` (using an enhanced for loop, which doesn't remove elements) and prints each task. Checks if the queue is empty and prints a message if so. Output goes to `System.out`.
 *     *   `viewCompletedTasks`: Iterates through the `completedTasks` `ArrayList` and prints each task. Checks if the list is empty. Output goes to `System.out`.
 * 
 * 3.  **`TaskSchedulerApp` Class (Main Application):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   Initializes `Scanner` for reading console input and `TaskScheduler` to manage tasks.
 *     *   A `boolean running` controls the main application loop.
 *     *   **Class-wide Exception Handling:** The core `while(running)` loop is wrapped in a `try-catch(Exception e)` block. This provides a safety net for any unexpected runtime errors that might occur within the loop, preventing the program from crashing abruptly and printing a generic error message to `System.err`.
 *     *   Inside the loop:
 *         *   `printMenu()` displays options using `System.out`.
 *         *   A nested `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input when prompted for the menu choice. It prints an error to `System.err` and uses `scanner.next()` to consume the invalid token, preventing an infinite loop.
 *         *   A `switch` statement directs execution based on the valid integer choice.
 *         *   Each case calls the appropriate method on the `scheduler` object.
 *         *   Case 1 (`addTask`): Prompts for description and priority. A nested `try-catch` handles potential `InputMismatchException` when reading the priority. `scanner.nextLine()` is used after reading the description to consume the newline character left by `scanner.nextInt()` in the main loop's input reading.
 *         *   Cases 2, 3, 4 call the respective scheduler methods.
 *         *   Case 5 sets `running` to `false` to exit the loop.
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   **Resource Management:** The `finally` block associated with the outer `try-catch` ensures that `scanner.close()` is called before the program exits, releasing the system resource.
 * 
 * **Summary of Required Components Usage:**
 * 
 * *   `java.util.Queue`: Used in `TaskScheduler` to manage tasks waiting for processing (`taskQueue`).
 * *   `java.util.ArrayList`: Used in `TaskScheduler` to store completed tasks (`completedTasks`).
 * *   `java.util.List`: Used as the interface type for `completedTasks`, demonstrating programming to interfaces.
 * *   `java.util.Scanner`: Used in `TaskSchedulerApp` to read user input from the console.
 * *   `switch`: Used in `TaskSchedulerApp` to control the flow based on the user's menu choice.
 * *   `System.err`: Used in `TaskScheduler` and `TaskSchedulerApp` to print error messages (validation errors, empty queue, invalid input, unexpected exceptions).
 * *   `System.out`: Used in `TaskScheduler` and `TaskSchedulerApp` to print normal output (menu, task details, success messages).
 * *   `try-catch`: Used for class-wide exception handling around the main loop in `TaskSchedulerApp` and for specific input validation error handling within the loop.
 * 
 * The solution demonstrates good practices like encapsulation, clear method names, input validation, and robust error handling, making it a challenging yet practical exam question.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;
    private int priority; // e.g., 1 (high) to 5 (low)

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param priority The task priority (1-5).
     */
    public Task(String description, int priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return String.format("Task [ID=%d, Priority=%d, Description='%s']", id, priority, description);
    }
}

// Manages the queue of tasks and completed tasks
class TaskScheduler {
    private Queue<Task> taskQueue; // Tasks waiting to be processed
    private List<Task> completedTasks; // Tasks that have been processed
    private final int MIN_PRIORITY = 1;
    private final int MAX_PRIORITY = 5;

    /**
     * Constructs a TaskScheduler with empty queues/lists.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // Use LinkedList as concrete Queue implementation
        this.completedTasks = new ArrayList<>(); // Use ArrayList as concrete List implementation
    }

    /**
     * Adds a new task to the waiting queue after validation.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        // Input validation for priority
        if (priority < MIN_PRIORITY || priority > MAX_PRIORITY) {
            System.err.println("Error: Invalid priority. Priority must be between " + MIN_PRIORITY + " and " + MAX_PRIORITY + ".");
            return; // Do not add task if validation fails
        }

        Task newTask = new Task(description, priority);
        taskQueue.offer(newTask); // offer() is preferred over add() as it doesn't throw exception on capacity limits (though LinkedList is unbounded)
        System.out.println("Task added to queue: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Removes the head of the queue and moves it to the completed list.
     */
    public void processNextTask() {
        Task nextTask = taskQueue.poll(); // poll() retrieves and removes the head, returns null if queue is empty

        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask);
        } else {
            System.err.println("Error: Task queue is empty. No tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the completed tasks list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

// Main application class to run the Task Scheduler
public class TaskSchedulerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskScheduler scheduler = new TaskScheduler();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer input
                } catch (InputMismatchException e) {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    // Consume the newline character left by nextInt()
                    // This is important before reading String input later (like description)
                    // Although not strictly needed here because we only read int, it's good practice
                    // if reading mixed types after nextInt(). Let's omit for simplicity in this specific case.
                }


                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        scanner.nextLine(); // Consume the leftover newline from nextInt()
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (1-5): ");
                        int priority = -1;
                        try {
                            priority = scanner.nextInt();
                            scheduler.addTask(description, priority);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid priority input. Please enter a number.");
                            scanner.next(); // Consume invalid input
                        } finally {
                             // Consume the newline character after reading priority
                             // This is needed before the next loop iteration potentially reads a line
                             // scanner.nextLine(); // Removed as nextInt is the last read before loop continues
                        }
                        break;

                    case 2: // Process Next Task
                        scheduler.processNextTask();
                        break;

                    case 3: // View Queue
                        scheduler.viewQueue();
                        break;

                    case 4: // View Completed Tasks
                        scheduler.viewCompletedTasks();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid Choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("---------------------------");
    }
}
