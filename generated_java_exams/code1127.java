/*
 * Exam Question #1127
 * Generated on: 2025-05-12 17:28:39
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulator
 * 
 * **Objective:** Design and implement a Java program that simulates a simple production line. The system should manage items waiting to be processed, process them sequentially, and keep track of completed items. This task requires demonstrating proficiency with core Java collections, I/O, control flow, and exception handling.
 * 
 * **Scenario:** You are building a simplified simulation for a factory production line. Items arrive and are placed in a queue to await processing. A worker processes items one by one from the front of the queue. Once processed, the item is moved to a list of completed items. The user should be able to interact with the system via a command-line interface to add new items, process the next item, view the current status, or exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Class:** Create a class `Product` to represent an item on the production line. It should have private fields for `id` (int), `name` (String), and `type` (String). Include a constructor and public getter methods for these fields.
 * 2.  **ProductionLine Class:** Create a class `ProductionLine` that manages the simulation logic.
 *     *   It must have a private `Queue<Product>` to hold items waiting for processing. Use a suitable implementation (e.g., `LinkedList`).
 *     *   It must have a private `List<Product>` to hold completed items. Use `ArrayList` as the implementation, but declare the field using the `List` interface type.
 *     *   Include a constructor to initialize the collections.
 *     *   Implement a public method `addProduct(Product product)` that adds a product to the waiting queue.
 *     *   Implement a public method `processNextItem()` that:
 *         *   Retrieves the next item from the front of the waiting queue.
 *         *   If the queue is empty, print an appropriate error message to `System.err` and return.
 *         *   Simulates processing (e.g., print a message indicating the item is being processed).
 *         *   Adds the processed item to the completed items list.
 *         *   Prints a success message to `System.out`.
 *     *   Implement a public method `viewStatus()` that prints the current contents of the waiting queue and the completed items list to `System.out`.
 * 3.  **Main Application Class:** Create a class (e.g., `ProductionLineSimulator`) with a `main` method to handle user interaction.
 *     *   Use `java.util.Scanner` to read user commands and product details from the console.
 *     *   Implement a command loop that continuously prompts the user for input until they choose to exit.
 *     *   Use a `switch` statement to handle different user commands:
 *         *   `a`: Add a new product. Prompt the user for product ID, name, and type. Create a `Product` object and add it to the `ProductionLine` using the `addProduct` method. Validate input (e.g., ID must be an integer).
 *         *   `p`: Process the next item. Call the `processNextItem` method on the `ProductionLine`.
 *         *   `v`: View status. Call the `viewStatus` method on the `ProductionLine`.
 *         *   `q`: Quit the application.
 *         *   Any other input: Print an error message to `System.err`.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle potential issues during the program execution, especially around user input parsing (`InputMismatchException`, etc.). Error messages from exceptions should be printed to `System.err`.
 *     *   Ensure `System.out` is used for all normal output (prompts, menu, success messages, status) and `System.err` is used exclusively for error messages.
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Perform basic input validation (e.g., check for non-integer ID, handle empty strings for name/type if desired, though basic `Scanner` readLine handles null reasonably for this level).
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept commands, and display output similar to the following examples:
 * 
 * ```
 * Production Line Simulator Menu:
 * a - Add Product
 * p - Process Next Item
 * v - View Status
 * q - Quit
 * Enter command: a
 * Enter Product ID (integer): 101
 * Enter Product Name: Widget
 * Enter Product Type: Electronics
 * Product added to queue.
 * Enter command: a
 * Enter Product ID (integer): 102
 * Enter Product Name: Gadget
 * Enter Product Type: Mechanical
 * Product added to queue.
 * Enter command: v
 * --- Production Line Status ---
 * Waiting Queue:
 * [ID: 101, Name: Widget, Type: Electronics]
 * [ID: 102, Name: Gadget, Type: Mechanical]
 * Completed Items:
 * (Empty)
 * -----------------------------
 * Enter command: p
 * Processing item: [ID: 101, Name: Widget, Type: Electronics]
 * Item processed and moved to completed.
 * Enter command: v
 * --- Production Line Status ---
 * Waiting Queue:
 * [ID: 102, Name: Gadget, Type: Mechanical]
 * Completed Items:
 * [ID: 101, Name: Widget, Type: Electronics]
 * -----------------------------
 * Enter command: p
 * Processing item: [ID: 102, Name: Gadget, Type: Mechanical]
 * Item processed and moved to completed.
 * Enter command: p
 * Error: No items in the waiting queue to process.
 * Enter command: v
 * --- Production Line Status ---
 * Waiting Queue:
 * (Empty)
 * Completed Items:
 * [ID: 101, Name: Widget, Type: Electronics]
 * [ID: 102, Name: Gadget, Type: Mechanical]
 * -----------------------------
 * Enter command: invalid
 * Error: Invalid command. Please use 'a', 'p', 'v', or 'q'.
 * Enter command: a
 * Enter Product ID (integer): abc
 * Error reading input: For input string: "abc"
 * Enter command: q
 * Exiting Production Line Simulator.
 * ```
 * 
 * **Constraint Checklist:**
 * 
 * *   [x] Queue (from java.util.Queue) used?
 * *   [x] ArrayList (from java.util.ArrayList) used?
 * *   [x] List interface (from java.util.List) used for a variable?
 * *   [x] Scanner for user input used?
 * *   [x] Switch statement for flow control used?
 * *   [x] System.err for error messages used?
 * *   [x] System.out for normal output used?
 * *   [x] Class-wide exception handling with try-catch blocks used?
 * *   [x] Proper encapsulation?
 * *   [x] Meaningful names?
 * *   [x] Comments/Documentation?
 * *   [x] Input validation?
 * *   [x] Proper error handling?
 * *   [x] Clean code structure?
 * *   [x] Creative/Practical scenario?
 * 
 * **Time Estimate:** 45-60 minutes
 * 
 * **Instructions:** Write the complete Java code for the `Product`, `ProductionLine`, and `ProductionLineSimulator` classes in a single file or separate files as appropriate, ensuring it meets all the requirements.
 *
 * EXPLANATION:
 * This solution implements the `Production Line Simulator` as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Product` Class:** A simple POJO (Plain Old Java Object) with private fields (`id`, `name`, `type`), a constructor, and public getters. It also overrides `toString()` for easy printing. This demonstrates basic encapsulation.
 * 
 * 2.  **`ProductionLine` Class:**
 *     *   **`Queue<Product> waitingQueue`**: A `java.util.Queue` is used to model the waiting line, where items are processed in FIFO (First-In, First-Out) order. `LinkedList` is chosen as a common implementation for `Queue`.
 *     *   **`List<Product> completedItems`**: A `java.util.List` is used to store the items after processing. It is declared as the `List` interface type but instantiated as an `ArrayList`. This demonstrates programming to interfaces. `ArrayList` is suitable for storing and iterating over completed items.
 *     *   **`addProduct(Product product)`**: Uses `queue.offer()` to add a product to the end of the waiting queue. `offer()` is generally preferred over `add()` for queues as it returns `false` if the addition fails (though for `LinkedList`, it typically won't fail unless memory is exhausted).
 *     *   **`processNextItem()`**: Checks if the queue is empty using `waitingQueue.isEmpty()`. If empty, it prints an error message to `System.err` and returns, fulfilling the requirement to handle this specific error case using `System.err`. If not empty, it uses `queue.poll()` to retrieve and remove the item at the head of the queue. This item is then added to the `completedItems` list. Success messages are printed to `System.out`.
 *     *   **`viewStatus()`**: Prints the contents of both the waiting queue and the completed items list to `System.out`, providing the current state of the simulation. It checks for empty lists/queues and prints a friendly message.
 * 
 * 3.  **`ProductionLineSimulator` Class (Main Application):**
 *     *   **`Scanner scanner = new Scanner(System.in)`**: Used to read input from the standard input stream (`System.in`).
 *     *   **`try-catch` (Class-wide):** The main `while` loop is wrapped in a `try-catch` block. This fulfills the requirement for "class-wide" exception handling by covering the primary execution flow of the application. It catches any unexpected `Exception` and prints an error to `System.err`. A `finally` block ensures the `Scanner` is closed properly, releasing the system resource.
 *     *   **`while (running)` loop:** Controls the main application flow, continuing until the `running` flag is set to `false`.
 *     *   **`switch (command)`**: This is the core flow control mechanism based on user input, directly addressing the requirement to use a `switch` statement. It handles the different menu options (`a`, `p`, `v`, `q`) and a `default` case for invalid input.
 *     *   **Input Handling (`case "a"`):**
 *         *   Prompts for product details using `System.out`.
 *         *   Uses `scanner.nextLine()` to read each line of input (ID, name, type). Reading the integer ID this way (`Integer.parseInt(scanner.nextLine())`) is safer when mixing `nextLine()` with other `next...()` methods, although in this structure, `nextLine()` is used consistently after the command, avoiding common `Scanner` pitfalls.
 *         *   A nested `try-catch` specifically handles `NumberFormatException` during the parsing of the Product ID, printing a specific error to `System.err`. This demonstrates more granular error handling within a command.
 *         *   Basic validation checks if name or type are empty.
 *         *   Creates a new `Product` object and calls `productionLine.addProduct()`.
 *     *   **Error Output (`System.err`):** Used explicitly for error messages like invalid commands, empty queue processing attempts, input parsing errors, and unexpected exceptions.
 *     *   **Normal Output (`System.out`):** Used for all prompts, menu display, success messages, processing status, and the full status view.
 *     *   **Best Practices:** Variable names (`waitingQueue`, `completedItems`, `productToProcess`, `running`, `command`) are meaningful. Methods (`addProduct`, `processNextItem`, `viewStatus`, `printMenu`) describe their actions. Basic comments and Javadoc are included.
 * 
 * This solution effectively integrates the required Java components into a practical simulation, demonstrating understanding of collections, I/O, control flow, and robust error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product item on the production line.
 */
class Product {
    private int id;
    private String name;
    private String type;

    /**
     * Constructs a new Product.
     * @param id The unique identifier for the product.
     * @param name The name of the product.
     * @param type The type or category of the product.
     */
    public Product(int id, String name, String type) {
        this.id = id;
        this.name = name;
        this.type = type;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the Product.
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", Name: " + name + ", Type: " + type + "]";
    }
}

/**
 * Simulates a production line managing waiting and completed products.
 */
class ProductionLine {
    // Using LinkedList for the Queue implementation as it's suitable for queue operations
    private Queue<Product> waitingQueue;
    // Declaring as List interface, implemented by ArrayList
    private List<Product> completedItems;

    /**
     * Constructs a new ProductionLine, initializing the queues and lists.
     */
    public ProductionLine() {
        this.waitingQueue = new LinkedList<>();
        this.completedItems = new ArrayList<>(); // Implementation is ArrayList
    }

    /**
     * Adds a product to the waiting queue.
     * @param product The product to add.
     */
    public void addProduct(Product product) {
        if (product != null) {
            waitingQueue.offer(product); // offer is preferred over add for queues
            System.out.println("Product added to queue.");
        } else {
            System.err.println("Error: Cannot add null product.");
        }
    }

    /**
     * Processes the next item from the waiting queue and moves it to completed items.
     */
    public void processNextItem() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: No items in the waiting queue to process.");
            return; // Exit the method if queue is empty
        }

        Product productToProcess = waitingQueue.poll(); // Retrieves and removes the head of the queue

        System.out.println("Processing item: " + productToProcess);

        // Simulate processing time or logic here if needed

        completedItems.add(productToProcess); // Add to the list of completed items
        System.out.println("Item processed and moved to completed.");
    }

    /**
     * Prints the current status of the waiting queue and completed items.
     */
    public void viewStatus() {
        System.out.println("\n--- Production Line Status ---");

        System.out.println("Waiting Queue:");
        if (waitingQueue.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate through the queue without removing elements
            waitingQueue.forEach(System.out::println);
        }

        System.out.println("Completed Items:");
        if (completedItems.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            completedItems.forEach(System.out::println);
        }
        System.out.println("-----------------------------\n");
    }
}

/**
 * Main class to run the Production Line Simulator application.
 * Handles user input and interaction with the ProductionLine.
 */
public class ProductionLineSimulator {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLine productionLine = new ProductionLine();
        boolean running = true;

        // Class-wide try-catch block to handle unexpected errors during the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Switch statement for flow control based on user command
                switch (command) {
                    case "a": // Add Product
                        try {
                            System.out.print("Enter Product ID (integer): ");
                            // Use nextLine and parse to handle non-integer input gracefully
                            int id = Integer.parseInt(scanner.nextLine());
                            System.out.print("Enter Product Name: ");
                            String name = scanner.nextLine();
                            System.out.print("Enter Product Type: ");
                            String type = scanner.nextLine();

                            // Basic validation
                            if (name.isEmpty() || type.isEmpty()) {
                                System.err.println("Error: Product name and type cannot be empty.");
                            } else {
                                Product newProduct = new Product(id, name, type);
                                productionLine.addProduct(newProduct);
                            }
                        } catch (NumberFormatException e) {
                            // Catch specific exception for ID parsing errors
                            System.err.println("Error reading input: Invalid Product ID. Please enter an integer.");
                            // Do not consume the rest of the line here, as nextLine was used above
                        } catch (Exception e) {
                             // Catch any other unexpected errors during add
                            System.err.println("An unexpected error occurred while adding product: " + e.getMessage());
                        }
                        break;

                    case "p": // Process Next Item
                        productionLine.processNextItem(); // Error handling for empty queue is inside this method
                        break;

                    case "v": // View Status
                        productionLine.viewStatus();
                        break;

                    case "q": // Quit
                        System.out.println("Exiting Production Line Simulator.");
                        running = false;
                        break;

                    default: // Invalid command
                        System.err.println("Error: Invalid command. Please use 'a', 'p', 'v', or 'q'.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unhandled exceptions from the main loop
            System.err.println("An unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or if an error occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nProduction Line Simulator Menu:");
        System.out.println("a - Add Product");
        System.out.println("p - Process Next Item");
        System.out.println("v - View Status");
        System.out.println("q - Quit");
    }
}
