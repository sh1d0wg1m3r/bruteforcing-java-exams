/*
 * Exam Question #182
 * Generated on: 2025-05-11 22:27:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Package Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for managing packages in a warehouse. Packages arrive and are placed in an incoming queue to await processing. A warehouse worker processes packages one by one from the front of the queue. Once processed, packages are moved to a separate list of completed packages.
 * 
 * Your system must allow the user to perform the following actions via a console menu:
 * 
 * 1.  **Add New Package:** Add a new package to the incoming queue. Each package should have a unique ID (you can generate a simple sequential ID) and a description.
 * 2.  **Process Next Package:** Take the package at the front of the incoming queue, remove it from the queue, and add it to the list of processed packages.
 * 3.  **View Incoming Queue:** Display the list of packages currently waiting in the incoming queue.
 * 4.  **View Processed Packages:** Display the list of packages that have been processed.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to represent the incoming package queue.
 *     *   Use `java.util.ArrayList` to store processed packages.
 *     *   Use `java.util.List` as the return type or parameter type where appropriate (e.g., a method returning the list of processed packages).
 * 2.  **User Input:** Use `java.util.Scanner` to read user input from the console.
 * 3.  **Control Flow:** Use a `switch` statement to handle the main menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation results (e.g., package added, package processed, list contents).
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, queue is empty when trying to process, invalid input for package description).
 * 5.  **Error Handling:** Implement robust exception handling using `try-catch` blocks. Demonstrate class-wide or method-level exception handling to catch potential runtime issues (e.g., errors during input processing, attempting operations on empty data structures where not explicitly checked).
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Package` class with private fields (e.g., `id`, `description`) and public getter methods.
 *     *   Create a main class (e.g., `WarehouseSystem`) that encapsulates the queue, processed list, and the system logic. Use private fields for the data structures and public methods for operations (add, process, view).
 * 7.  **Best Practices:**
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments or Javadoc where necessary to explain complex parts.
 *     *   Implement basic input validation (e.g., ensure package description is not empty).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors. Examples:
 * 
 * *   Upon starting: Display menu.
 * *   Adding a package: Prompt for description, confirm addition to queue.
 * *   Processing: Confirm which package was processed and moved to the list, or display error if queue is empty.
 * *   Viewing Queue: Display contents of the queue or indicate it's empty.
 * *   Viewing Processed: Display contents of the processed list or indicate it's empty.
 * *   Invalid input: Display error message on `System.err`.
 * *   Other errors: Display error message on `System.err` using `try-catch`.
 * 
 * **Constraints:**
 * 
 * *   You must use *all* the specified Java components.
 * *   The solution should be a single, cohesive program.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * 
 * *   Correctness and completeness of the implementation according to the requirements.
 * *   Proper usage of all required Java components.
 * *   Effectiveness of error handling using `try-catch` and `System.err`.
 * *   Adherence to object-oriented principles and best practices (encapsulation, naming, comments).
 * *   Clarity and structure of the code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * The provided solution implements a simple Warehouse Package Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:** This class serves as a simple Plain Old Java Object (POJO) to represent a package. It follows encapsulation principles with private fields (`id`, `description`) and public getter methods. The `toString()` method is overridden for easy printing of package details.
 * 
 * 2.  **`WarehouseSystem` Class:** This is the main class containing the application logic and data structures.
 *     *   **Data Structures:**
 *         *   `incomingQueue`: Declared as `Queue<Package>` and initialized with `new LinkedList<>()`. `LinkedList` is a common and suitable implementation for `Queue` as it efficiently supports FIFO operations (`offer`, `poll`).
 *         *   `processedPackages`: Declared as `List<Package>` and initialized with `new ArrayList<>()`. `ArrayList` is used for storing processed items, allowing dynamic resizing and easy iteration. The use of `List` as the type for the field and in methods like `viewProcessedPackages` demonstrates polymorphism and good practice (programming to an interface).
 *     *   **`nextPackageId`:** A simple counter to generate unique IDs for packages.
 *     *   **`scanner`:** A `Scanner` instance is created once and used throughout the `run` method for reading user input. Declaring it as a class member and closing it in a `finally` block is a good practice for resource management.
 *     *   **`addPackage(String description)`:** This method creates a new `Package` object with the next available ID and the provided description. It includes basic input validation to check if the description is empty. If valid, the package is added to the `incomingQueue` using `offer()`.
 *     *   **`processNextPackage()`:** This method attempts to retrieve and remove the head of the `incomingQueue` using `poll()`. If `poll()` returns `null` (meaning the queue is empty), an error message is printed to `System.err`. Otherwise, the retrieved package is added to the `processedPackages` list.
 *     *   **`viewIncomingQueue()`:** This method iterates through the `incomingQueue` (without removing elements) and prints each package. It checks if the queue is empty and prints a corresponding message.
 *     *   **`viewProcessedPackages()`:** This method iterates through the `processedPackages` `ArrayList` and prints each package. It demonstrates using the `List` interface type. It checks if the list is empty.
 *     *   **`displayMenu()`:** A helper method to print the user menu to `System.out`.
 *     *   **`run()`:** This is the main loop of the application.
 *         *   It uses a `while(running)` loop to keep the system active until the user chooses to exit.
 *         *   Inside the loop, it displays the menu and reads the user's input using `scanner.nextLine()`. Reading the entire line is safer than `nextInt()` followed by `nextLine()`.
 *         *   It attempts to parse the input string into an integer `choice`. A `NumberFormatException` is caught internally, setting `choice` to -1 if parsing fails, which is then handled by the `default` case of the `switch`.
 *         *   A `switch` statement is used to handle the different menu options, calling the appropriate methods based on the user's `choice`.
 *         *   The `default` case of the `switch` handles invalid numerical input (including the -1 from parsing errors) and prints an error message to `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any *unexpected* runtime exceptions that might occur during the program's execution (beyond the specific input validation or empty queue checks). If such an exception occurs, an error message and the stack trace are printed to `System.err`, and the program will likely terminate (or the loop will break depending on the exception).
 *         *   **`finally` Block:** A `finally` block is used to ensure the `scanner` resource is closed, releasing system resources, regardless of whether the loop finishes normally or an unexpected exception occurs.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates an instance of `WarehouseSystem` and calls its `run()` method to start the system.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks within a practical, object-oriented structure, fulfilling all the requirements of the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Class representing a package
class Package {
    private int id;
    private String description;

    public Package(int id, String description) {
        this.id = id;
        this.description = description;
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Package [ID=" + id + ", Description='" + description + "']";
    }
}

// Main system class encapsulating the logic and data structures
public class WarehouseSystem {

    // Use Queue for incoming packages (FIFO)
    private Queue<Package> incomingQueue;
    // Use List/ArrayList for processed packages
    private List<Package> processedPackages;
    // Counter for generating package IDs
    private int nextPackageId;

    // Scanner for user input - declared as a class member for easier management
    private Scanner scanner;

    /**
     * Constructs a new WarehouseSystem.
     * Initializes the queue, list, and package ID counter.
     */
    public WarehouseSystem() {
        this.incomingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedPackages = new ArrayList<>();
        this.nextPackageId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new package to the incoming queue.
     *
     * @param description The description of the package.
     * @return The newly created package, or null if description is invalid.
     */
    public Package addPackage(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Package description cannot be empty.");
            return null;
        }
        Package newPackage = new Package(nextPackageId++, description.trim());
        incomingQueue.offer(newPackage); // offer is generally preferred over add for queues
        System.out.println("Added to queue: " + newPackage);
        return newPackage;
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves the package from the queue to the processed list.
     *
     * @return The processed package, or null if the queue is empty.
     */
    public Package processNextPackage() {
        Package packageToProcess = incomingQueue.poll(); // poll retrieves and removes the head
        if (packageToProcess != null) {
            processedPackages.add(packageToProcess);
            System.out.println("Processed: " + packageToProcess);
            return packageToProcess;
        } else {
            System.err.println("Error: Incoming queue is empty. Nothing to process.");
            return null;
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    public void viewIncomingQueue() {
        System.out.println("\n--- Incoming Queue ---");
        if (incomingQueue.isEmpty()) {
            System.out.println("The incoming queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            incomingQueue.forEach(System.out::println);
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all packages that have been processed.
     */
    public void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Use the List interface reference for iteration
            List<Package> processedList = processedPackages;
            processedList.forEach(System.out::println);
        }
        System.out.println("------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        // Class-wide try-catch block to catch unexpected exceptions during execution
        try {
            while (running) {
                displayMenu();
                String input = scanner.nextLine(); // Read the whole line to avoid issues with nextInt()

                // Try to parse the input as an integer choice
                int choice = -1; // Default to invalid choice
                try {
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // If parsing fails, choice remains -1, handled by the default case
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter package description: ");
                        String description = scanner.nextLine();
                        addPackage(description);
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewIncomingQueue();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions and print to System.err
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed when the application exits or an unhandled exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run();
    }
}
