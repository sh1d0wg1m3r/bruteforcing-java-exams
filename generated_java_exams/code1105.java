/*
 * Exam Question #1105
 * Generated on: 2025-05-12 17:25:33
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Package Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a package processing center. Packages arrive and are placed in an incoming queue. A worker processes packages one by one from the front of the queue. Once processed, packages are added to a list of completed packages. The system needs to handle user commands to add packages, process the next package, view completed packages, and exit.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Package Class:** Create a `Package` class with private fields for `trackingNumber` (String), `weight` (double), and `destination` (String). Provide a constructor to initialize these fields and public getter methods for accessing them. Include a meaningful `toString()` method to represent a package.
 * 2.  **Package Processing System Class:** Create a main class (e.g., `PackageProcessingSystem`) that manages the package flow.
 *     *   It must contain a `Queue<Package>` to hold incoming packages awaiting processing.
 *     *   It must contain a `List<Package>` (implemented using `ArrayList`) to store packages that have been successfully processed.
 *     *   Implement methods for:
 *         *   `addPackage(String trackingNumber, double weight, String destination)`: Adds a new `Package` to the incoming queue after validating the input.
 *         *   `processNextPackage()`: Removes the next package from the incoming queue, simulates processing (e.g., print a message), and adds it to the list of processed packages. Handles the case where the queue is empty.
 *         *   `listCompletedPackages()`: Displays the details of all packages in the processed list.
 *     *   The `main` method should implement a command-line interface using `Scanner` to interact with the user.
 * 3.  **User Interface:** The `main` method should present a menu with options:
 *     *   `add`: Prompt the user for package details (tracking number, weight, destination) and add the package.
 *     *   `process`: Process the next package from the queue.
 *     *   `list`: Display all completed packages.
 *     *   `exit`: Terminate the program.
 * 4.  **Input Handling:**
 *     *   Use `Scanner` to read user commands and package details.
 *     *   Validate user input for package details:
 *         *   Tracking number and destination should not be empty.
 *         *   Weight should be a positive number.
 *     *   Handle potential `Scanner` input issues (e.g., non-numeric input for weight).
 * 5.  **Control Flow:** Use a `switch` statement to handle the different user commands.
 * 6.  **Error Handling:**
 *     *   Use `System.err.println()` to display error messages (e.g., invalid input, trying to process from an empty queue).
 *     *   Use `System.out.println()` for normal output (menu, confirmations, package details).
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around operations that might fail (like processing an empty queue or parsing input). A general `try-catch` in the main loop is acceptable for catching unexpected runtime errors and keeping the program running or exiting gracefully.
 * 7.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc where applicable).
 *     *   Ensure clean code structure.
 *     *   Program to the `List` interface when declaring the collection of processed packages.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept commands, and produce output similar to this (depending on user input):
 * 
 * ```
 * Package Processing System Menu:
 * add    - Add a new package
 * process - Process the next package
 * list   - List completed packages
 * exit   - Exit the system
 * Enter command: add
 * Enter tracking number: TN123
 * Enter weight (kg): 2.5
 * Enter destination: New York
 * Package TN123 added to queue.
 * Enter command: add
 * Enter tracking number: TN456
 * Enter weight (kg): 1.0
 * Enter destination: Los Angeles
 * Package TN456 added to queue.
 * Enter command: process
 * Processing package: Package{trackingNumber='TN123', weight=2.5, destination='New York'}
 * Package TN123 processed and added to completed list.
 * Enter command: process
 * Processing package: Package{trackingNumber='TN456', weight=1.0, destination='Los Angeles'}
 * Package TN456 processed and added to completed list.
 * Enter command: process
 * System.err: No packages in the queue to process.
 * Enter command: list
 * --- Completed Packages ---
 * Package{trackingNumber='TN123', weight=2.5, destination='New York'}
 * Package{trackingNumber='TN456', weight=1.0, destination='Los Angeles'}
 * -------------------------
 * Enter command: exit
 * Exiting Package Processing System.
 * ```
 * 
 * Consider edge cases like entering non-numeric weight or processing an empty queue.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct logic for adding, processing, and listing packages.
 * *   Robust input validation and error handling.
 * *   Adherence to best practices (encapsulation, naming, comments, clean structure).
 * *   Handling of edge cases.
 *
 * EXPLANATION:
 * This solution implements a simple Package Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   Encapsulation is achieved with `private` fields (`trackingNumber`, `weight`, `destination`) and `public` getter methods.
 *     *   The constructor initializes the package state.
 *     *   The `toString()` method provides a convenient way to display package information.
 * 
 * 2.  **`PackageProcessingSystem` Class:**
 *     *   **`Queue`:** A `Queue<Package>` named `incomingQueue` is used (specifically a `LinkedList`, which implements the `Queue` interface). This correctly models the "packages arriving and waiting in line" scenario, where items are added to the end (`offer`) and removed from the front (`poll`). `poll()` is used because it gracefully returns `null` if the queue is empty, which is handled in `processNextPackage()`.
 *     *   **`List` and `ArrayList`:** A `List<Package>` named `processedPackages` is declared, but instantiated as an `ArrayList<Package>`. This demonstrates programming to the `List` interface, which is a best practice allowing flexibility to change the underlying implementation (e.g., to `LinkedList`) later if needed, without changing the code that uses the `List` interface. `ArrayList` provides efficient storage and iteration for the completed packages.
 *     *   **`Scanner`:** A `Scanner` object is used in the `main` method (managed by the `run` method) to read user input from the console. It's initialized to read from `System.in`. The `try-with-resources` block around the scanner in the `run` method ensures it is automatically closed when the method exits.
 *     *   **`addPackage` Method:** Takes package details, performs basic input validation (checking for empty strings and non-positive weight), prints errors using `System.err`, and adds valid packages to the `incomingQueue` using `offer()`.
 *     *   **`processNextPackage` Method:** Uses `poll()` to get the next package from the queue. It checks if `poll()` returned `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it prints a processing message and adds the package to the `processedPackages` `List`.
 *     *   **`listCompletedPackages` Method:** Iterates through the `processedPackages` `List` (using an enhanced for loop) and prints each package's `toString()` representation to `System.out`. Handles the case of an empty list.
 *     *   **`run` Method:** Contains the main application loop. It repeatedly displays the menu and reads user commands.
 *     *   **`switch` Statement:** Inside the `run` method, a `switch` statement is used to determine which action to perform based on the user's command string ("add", "process", "list", "exit", or default for unknown).
 *     *   **`System.out` and `System.err`:** Used appropriately for normal program output (`System.out`) and error messages (`System.err`).
 *     *   **`try-catch` Blocks:**
 *         *   A `try-with-resources` block manages the `Scanner` in the `run` method, ensuring it's closed.
 *         *   An inner `try-catch` block is used specifically around the `Double.parseDouble` call within the "add" command handling to catch `NumberFormatException` if the user enters non-numeric input for weight. This prevents the program from crashing and allows the loop to continue.
 *         *   A general `catch (Exception e)` block wraps the `switch` statement inside the `while` loop. This provides class-wide handling for any *other* unexpected runtime exceptions that might occur during command processing, printing an error message to `System.err` and preventing the program from terminating abruptly. A separate catch outside the loop handles critical errors related to the main loop or Scanner initialization.
 * 
 * 3.  **Best Practices:**
 *     *   Encapsulation in `Package` class.
 *     *   Meaningful names (`incomingQueue`, `processedPackages`, `addPackage`, `processNextPackage`, etc.).
 *     *   Javadoc comments for classes and methods, inline comments for logic.
 *     *   Input validation in `addPackage` and during `Scanner` input processing.
 *     *   Error handling using `try-catch` and `System.err`.
 *     *   Programming to the `List` interface.
 *     *   Clean separation of concerns (Package data vs. System logic).
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a real-world process, while adhering to good programming practices and handling potential errors.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with tracking information.
 */
class Package {
    private String trackingNumber;
    private double weight; // in kilograms
    private String destination;

    /**
     * Constructs a new Package.
     *
     * @param trackingNumber The unique tracking number.
     * @param weight         The weight of the package in kilograms.
     * @param destination    The destination address.
     */
    public Package(String trackingNumber, double weight, String destination) {
        this.trackingNumber = trackingNumber;
        this.weight = weight;
        this.destination = destination;
    }

    // Getters
    public String getTrackingNumber() {
        return trackingNumber;
    }

    public double getWeight() {
        return weight;
    }

    public String getDestination() {
        return destination;
    }

    /**
     * Provides a string representation of the Package.
     *
     * @return A string detailing the package's attributes.
     */
    @Override
    public String toString() {
        return "Package{" +
               "trackingNumber='" + trackingNumber + '\'' +
               ", weight=" + weight +
               ", destination='" + destination + '\'' +
               '}';
    }
}

/**
 * Simulates a package processing center managing incoming and processed packages.
 */
public class PackageProcessingSystem {

    private Queue<Package> incomingQueue;
    private List<Package> processedPackages;
    private Scanner scanner;

    /**
     * Constructs a new PackageProcessingSystem.
     */
    public PackageProcessingSystem() {
        incomingQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        processedPackages = new ArrayList<>(); // Use ArrayList for the list of processed packages
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new package to the incoming queue after validation.
     *
     * @param trackingNumber The tracking number of the package.
     * @param weight         The weight of the package.
     * @param destination    The destination of the package.
     */
    public void addPackage(String trackingNumber, double weight, String destination) {
        // Input validation
        if (trackingNumber == null || trackingNumber.trim().isEmpty()) {
            System.err.println("Error: Tracking number cannot be empty.");
            return;
        }
        if (destination == null || destination.trim().isEmpty()) {
            System.err.println("Error: Destination cannot be empty.");
            return;
        }
        if (weight <= 0) {
            System.err.println("Error: Weight must be a positive number.");
            return;
        }

        Package newPackage = new Package(trackingNumber.trim(), weight, destination.trim());
        incomingQueue.offer(newPackage); // offer is generally preferred over add for queues
        System.out.println("Package " + newPackage.getTrackingNumber() + " added to queue.");
    }

    /**
     * Processes the next package from the incoming queue.
     * Removes it from the queue and adds it to the list of processed packages.
     */
    public void processNextPackage() {
        Package packageToProcess = incomingQueue.poll(); // poll returns null if queue is empty

        if (packageToProcess == null) {
            System.err.println("No packages in the queue to process.");
        } else {
            System.out.println("Processing package: " + packageToProcess);
            // Simulate processing time if needed, but for this task, just move it
            processedPackages.add(packageToProcess);
            System.out.println("Package " + packageToProcess.getTrackingNumber() + " processed and added to completed list.");
        }
    }

    /**
     * Lists all packages that have been processed.
     */
    public void listCompletedPackages() {
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            System.out.println("--- Completed Packages ---");
            for (Package pkg : processedPackages) {
                System.out.println(pkg);
            }
            System.out.println("-------------------------");
        }
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\nPackage Processing System Menu:");
        System.out.println("add    - Add a new package");
        System.out.println("process - Process the next package");
        System.out.println("list   - List completed packages");
        System.out.println("exit   - Exit the system");
        System.out.print("Enter command: ");
    }

    /**
     * Runs the main command loop for the package processing system.
     */
    public void run() {
        String command;
        // Use try-with-resources for Scanner to ensure it's closed properly
        try (scanner) { // Scanner is initialized in the constructor
            while (true) {
                displayMenu();
                command = scanner.nextLine().trim().toLowerCase();

                // Class-wide try-catch block for general error handling
                try {
                    switch (command) {
                        case "add":
                            System.out.print("Enter tracking number: ");
                            String trackingNum = scanner.nextLine();

                            double weight = -1; // Initialize with invalid value
                            System.out.print("Enter weight (kg): ");
                            try {
                                weight = Double.parseDouble(scanner.nextLine());
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid weight format. Please enter a number.");
                                // Do not proceed with adding if weight is invalid
                                continue;
                            }

                            System.out.print("Enter destination: ");
                            String destination = scanner.nextLine();

                            addPackage(trackingNum, weight, destination);
                            break;

                        case "process":
                            processNextPackage();
                            break;

                        case "list":
                            listCompletedPackages();
                            break;

                        case "exit":
                            System.out.println("Exiting Package Processing System.");
                            return; // Exit the run method and thus the program

                        default:
                            System.err.println("Unknown command. Please try again.");
                            break;
                    }
                } catch (Exception e) {
                    // Catch any unexpected exceptions during command processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging during development
                    // e.printStackTrace();
                }
            }
        } catch (Exception e) {
             // Catch exceptions related to the Scanner itself or the main loop structure
             System.err.println("A critical error occurred during system operation: " + e.getMessage());
             e.printStackTrace(); // Print stack trace for critical errors
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PackageProcessingSystem system = new PackageProcessingSystem();
        system.run();
    }
}
