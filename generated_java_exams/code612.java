/*
 * Exam Question #612
 * Generated on: 2025-05-12 16:14:47
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam: Print Job Management System
 * 
 * **Objective:** Design and implement a simple command-line application to manage print jobs using core Java data structures and control flow mechanisms.
 * 
 * **Scenario:** You are developing a basic system for managing print jobs sent to a single printer. Jobs arrive and are added to a queue. The printer processes jobs one by one from the front of the queue. The system should also keep a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Print Job Representation:** Create a class `PrintJob` to represent a print job. It should have private fields for a unique `jobId` (integer, starting from 1), `fileName` (String), and `status` (String, e.g., "Pending", "Completed"). Provide a constructor and public getter methods for these fields.
 * 2.  **Print Manager Class:** Create a class `PrintManager` that encapsulates the print queue and the history of completed jobs.
 *     *   It must have a private field of type `java.util.Queue<PrintJob>` to store pending jobs. Use a suitable implementation like `LinkedList`.
 *     *   It must have a private field of type `java.util.List<PrintJob>` to store completed jobs. Use `java.util.ArrayList` but declare the field using the `List` interface type.
 *     *   Include a private integer field `nextJobId` initialized to 1, used to assign unique IDs to new jobs.
 *     *   Implement the following public methods:
 *         *   `addJob(String fileName)`: Creates a new `PrintJob` with status "Pending", assigns the next available `jobId`, adds it to the queue, and increments `nextJobId`. Input validation: if `fileName` is null or empty, print an error message to `System.err` and do not add the job.
 *         *   `processNextJob()`: Removes the job at the front of the queue, changes its status to "Completed", and adds it to the completed jobs list. If the queue is empty, print an error message to `System.err`.
 *         *   `viewQueue()`: Prints the details (ID, File Name, Status) of all jobs currently in the queue to `System.out`. If the queue is empty, print a message indicating that.
 *         *   `viewHistory()`: Prints the details (ID, File Name, Status) of all completed jobs in the history list to `System.out`. If the history is empty, print a message indicating that.
 * 3.  **Main Application Logic:** In a class with a `main` method (e.g., `PrintSystemApp`), create an instance of `PrintManager`. Use `java.util.Scanner` to read user commands from the console. Implement a command loop that continues until the user chooses to exit.
 * 4.  **User Commands:** The application should support the following commands via integer input:
 *     *   `1`: Add Job (Prompts for file name)
 *     *   `2`: Process Next Job
 *     *   `3`: View Pending Jobs Queue
 *     *   `4`: View Completed Jobs History
 *     *   `5`: Exit
 * 5.  **Control Flow:** Use a `switch` statement in the main loop to handle the different user commands.
 * 6.  **Error Handling:**
 *     *   Use `System.err` for all error messages (e.g., invalid input for adding job, processing empty queue, invalid command).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command processing loop to catch any unexpected runtime errors and print an informative message to `System.err` before exiting or continuing.
 * 7.  **Output:** Use `System.out` for all normal output (prompts, confirmations, list contents).
 * 8.  **Best Practices:** Adhere to Java coding best practices, including proper encapsulation, meaningful names, comments, and clean code structure.
 * 
 * **Expected Output:**
 * 
 * *   When the program starts, it should display a menu of options.
 * *   Adding a job should prompt for a file name and confirm successful addition (or report an error if the file name is invalid).
 * *   Processing a job should confirm which job was processed (or report an error if the queue is empty).
 * *   Viewing the queue or history should list the jobs with their details or state that the list is empty.
 * *   Selecting an invalid command should print an error message to `System.err`.
 * *   Selecting 'Exit' should terminate the program gracefully.
 * *   Any unhandled exception during the main loop should be caught and reported to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Print Job Management System
 * Choose an action:
 * 1. Add Job
 * 2. Process Next Job
 * 3. View Pending Jobs Queue
 * 4. View Completed Jobs History
 * 5. Exit
 * Enter command: 1
 * Enter file name: document.pdf
 * Job 1 (document.pdf) added to queue.
 * Enter command: 1
 * Enter file name: report.txt
 * Job 2 (report.txt) added to queue.
 * Enter command: 3
 * --- Pending Jobs Queue ---
 * Job ID: 1, File: document.pdf, Status: Pending
 * Job ID: 2, File: report.txt, Status: Pending
 * --------------------------
 * Enter command: 2
 * Processing Job: 1 (document.pdf)
 * Enter command: 3
 * --- Pending Jobs Queue ---
 * Job ID: 2, File: report.txt, Status: Pending
 * --------------------------
 * Enter command: 4
 * --- Completed Jobs History ---
 * Job ID: 1, File: document.pdf, Status: Completed
 * --------------------------
 * Enter command: 2
 * Processing Job: 2 (report.txt)
 * Enter command: 2
 * Error: The print queue is empty.
 * Enter command: 4
 * --- Completed Jobs History ---
 * Job ID: 1, File: document.pdf, Status: Completed
 * Job ID: 2, File: report.txt, Status: Completed
 * --------------------------
 * Enter command: 5
 * Exiting Print Job Management System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The solution implements a simple Print Job Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:** This class serves as a simple Plain Old Java Object (POJO) to model a print job. It has private fields (`jobId`, `fileName`, `status`) ensuring data encapsulation. Public getter methods provide controlled access to the data. A `setStatus` method is included, which is intended for use by the `PrintManager` to update the job's state. The `toString()` method provides a convenient way to print job details.
 * 
 * 2.  **`PrintManager` Class:** This is the core class managing the print jobs.
 *     *   `private Queue<PrintJob> printQueue`: Declared using the `Queue` interface and instantiated with `LinkedList`. This correctly models the FIFO (First-In, First-Out) nature of a print queue. Jobs are added to the tail (`offer`) and removed from the head (`poll`).
 *     *   `private List<PrintJob> completedJobs`: Declared using the `List` interface and instantiated with `ArrayList`. This stores the history of jobs once they are processed, allowing easy iteration and storage of completed items.
 *     *   `private int nextJobId`: Manages the assignment of unique IDs to new jobs, incrementing each time a job is added.
 *     *   **`addJob(String fileName)`:** Takes a file name, performs basic validation (checks for null or empty string), creates a new `PrintJob` with the "Pending" status and the next ID, and adds it to the `printQueue` using `offer()`. Uses `System.err` for validation errors and `System.out` for success messages.
 *     *   **`processNextJob()`:** Checks if the `printQueue` is empty. If not, it removes the head of the queue using `poll()`, updates the job's status to "Completed", and adds it to the `completedJobs` list. Uses `System.err` if the queue is empty and `System.out` to confirm processing.
 *     *   **`viewQueue()`:** Iterates through the `printQueue` (using a for-each loop, which doesn't remove elements) and prints each job's details using its `toString()` method. Uses `System.out` for output and checks for an empty queue.
 *     *   **`viewHistory()`:** Iterates through the `completedJobs` list and prints each completed job's details. Uses `System.out` for output and checks for an empty history.
 * 
 * 3.  **`PrintSystemApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses `Scanner` to read user input from `System.in`.
 *     *   Creates an instance of `PrintManager`.
 *     *   The main logic is within a `while(running)` loop.
 *     *   A nested `try-catch (InputMismatchException)` block is used specifically to handle cases where the user enters non-integer input for the command, preventing the `scanner.nextInt()` from crashing the program and causing an infinite loop by consuming the bad input. A `finally` block consumes the newline character left by `nextInt()` or `next()`, which is crucial before calling `scanner.nextLine()` later.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer command input, calling the appropriate methods in the `PrintManager`. Invalid command numbers trigger a `default` case printing an error to `System.err`.
 *     *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch (Exception e)` block. This demonstrates catching any *other* unexpected runtime exceptions that might occur within the loop, printing an error message and potentially the stack trace to `System.err`. This fulfills the requirement for class-wide handling around the main operational part of the application.
 *     *   A `finally` block ensures the `scanner` is closed when the application exits, regardless of whether it exited normally or due to an exception.
 *     *   `System.out` is used for the menu and successful operation messages. `System.err` is used exclusively for error conditions (invalid command, empty queue/history operations, input errors).
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Achieved by making fields private and providing public methods for access/modification where appropriate (`PrintJob`, `PrintManager`).
 *     *   **Meaningful Names:** Class names (`PrintJob`, `PrintManager`, `PrintSystemApp`), variable names (`printQueue`, `completedJobs`, `nextJobId`, `fileName`, `command`), and method names (`addJob`, `processNextJob`, `viewQueue`, `viewHistory`, `printMenu`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Handled in `addJob` for the file name and in the main loop for command input type.
 *     *   **Error Handling:** Specific error messages to `System.err` for expected errors (empty queue, invalid command, invalid input type) and a general `try-catch` for unexpected runtime exceptions.
 *     *   **Clean Code Structure:** The logic is separated into distinct classes with clear responsibilities (`PrintJob` for data, `PrintManager` for business logic/data management, `PrintSystemApp` for user interface/main loop).
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating good object-oriented design and robust handling of user interaction and potential errors, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int jobId;
    private String fileName;
    private String status;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param fileName The name of the file to be printed.
     */
    public PrintJob(int jobId, String fileName) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status (used by PrintManager) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Status: " + status;
    }
}

// Manages the queue of print jobs and completed jobs history
class PrintManager {
    // Use Queue interface, implement with LinkedList for FIFO behavior
    private Queue<PrintJob> printQueue;
    // Use List interface, implement with ArrayList for dynamic history storage
    private List<PrintJob> completedJobs;
    private int nextJobId; // To assign unique IDs to new jobs

    /**
     * Constructs a new PrintManager.
     */
    public PrintManager() {
        this.printQueue = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1;
    }

    /**
     * Adds a new print job to the queue.
     * @param fileName The name of the file for the job.
     */
    public void addJob(String fileName) {
        // Input validation
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }

        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim());
        printQueue.offer(newJob); // offer() is preferred over add() for capacity-constrained queues, though LinkedList isn't capacity-constrained. It returns false on failure, add() throws exception.
        System.out.println("Job " + newJob.getJobId() + " (" + newJob.getFileName() + ") added to queue.");
    }

    /**
     * Processes the next job in the queue.
     * Moves the job from the queue to the completed history.
     */
    public void processNextJob() {
        // Check if queue is empty
        if (printQueue.isEmpty()) {
            System.err.println("Error: The print queue is empty.");
            return;
        }

        PrintJob jobToProcess = printQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty
        if (jobToProcess != null) {
            jobToProcess.setStatus("Completed");
            completedJobs.add(jobToProcess);
            System.out.println("Processing Job: " + jobToProcess.getJobId() + " (" + jobToProcess.getFileName() + ")");
        }
        // Note: poll() returning null case is already handled by the isEmpty check, but good practice.
    }

    /**
     * Displays the current jobs in the pending queue.
     */
    public void viewQueue() {
        System.out.println("--- Pending Jobs Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (PrintJob job : printQueue) {
                System.out.println(job); // PrintJob's toString() is used here
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the history of completed jobs.
     */
    public void viewHistory() {
        System.out.println("--- Completed Jobs History ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the completed jobs list
            for (PrintJob job : completedJobs) {
                System.out.println(job); // PrintJob's toString() is used here
            }
        }
        System.out.println("--------------------------");
    }
}

// Main application class for user interaction
public class PrintSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintManager manager = new PrintManager();
        boolean running = true;

        System.out.println("Print Job Management System");

        // Class-wide exception handling around the main interaction loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: ");

                int command = -1; // Default invalid command
                try {
                    command = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to next iteration
                } finally {
                     // Consume the newline character left by nextInt() or next()
                     // This is important to prevent nextLine() from reading an empty string immediately after.
                     // This approach handles both valid int input and the InputMismatchException case.
                     if (scanner.hasNextLine()) {
                         scanner.nextLine();
                     }
                }


                // Use a switch statement for command handling
                switch (command) {
                    case 1:
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine(); // Read the rest of the line
                        manager.addJob(fileName);
                        break;
                    case 2:
                        manager.processNextJob();
                        break;
                    case 3:
                        manager.viewQueue();
                        break;
                    case 4:
                        manager.viewHistory();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Print Job Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Optional: Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the command menu to the console.
     */
    private static void printMenu() {
        System.out.println("\nChoose an action:");
        System.out.println("1. Add Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs Queue");
        System.out.println("4. View Completed Jobs History");
        System.out.println("5. Exit");
    }
}
