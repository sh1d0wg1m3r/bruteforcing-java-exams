/*
 * Exam Question #1124
 * Generated on: 2025-05-12 17:28:11
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Objective:** Implement a console-based task management system that allows users to add, process, and view tasks. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception management.
 * 
 * **Scenario:** You are to build a simplified system for managing tasks. New tasks are added to a queue representing pending work. When a task is processed, it is removed from the pending queue and added to a list of completed tasks. The user interacts with the system through a menu in the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple class (or inner class) named `Task` with a private field for the task description (`String`). Include a constructor and a public getter method for the description.
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue` to store tasks that are pending (waiting to be processed). Choose an appropriate concrete implementation (e.g., `LinkedList`).
 *     *   Use `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare the collection storing completed tasks using the `java.util.List` interface type.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (System.in).
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, task lists, and the exit message.
 *     *   Use `System.err` to display all error messages (e.g., invalid menu choice, empty task description, invalid input type, unexpected errors).
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during the program's execution. This should include handling specific input errors (like non-integer input for menu choice) and a general catch-all for other unexpected exceptions.
 *     *   Ensure the `Scanner` is properly closed, ideally in a `finally` block or similar mechanism.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation by making fields private and providing public methods for access/modification where necessary.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments (including Javadoc for classes and methods) to explain the code.
 *     *   Implement input validation (e.g., check for empty task description when adding, handle non-numeric menu input).
 *     *   Ensure proper error handling as specified in requirement 6.
 *     *   Structure the code cleanly with separate methods for different functionalities (adding, processing, viewing, displaying menu, running the main loop).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and perform actions based on the choice. Examples:
 * 
 * *   Adding a task: Prompt for description, add to queue, print confirmation.
 * *   Processing a task: Check if queue is empty. If not, remove from queue, add to list, print processed task. If empty, print "No pending tasks." message.
 * *   Viewing pending tasks: List tasks in the queue. Print "No tasks currently pending." if empty.
 * *   Viewing completed tasks: List tasks in the completed list. Print "No tasks have been completed yet." if empty.
 * *   Invalid input: Print error message to `System.err`.
 * *   Unexpected error: Print general error message to `System.err`.
 * 
 * You must provide the complete, runnable Java code in a single file.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based task management system, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Representation:** The `Task` class is defined as a private static inner class within `TaskManager`. It has a private `description` field, a constructor, and a public `getDescription()` getter, demonstrating encapsulation. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **Data Structures:**
 *     *   `pendingTasks` is declared as `Queue<Task>` and initialized with a `LinkedList`, which is a common implementation of the `Queue` interface. Tasks are added using `offer()` and removed using `poll()`, standard `Queue` operations.
 *     *   `completedTasks` is declared as `List<Task>` and initialized with an `ArrayList`. This adheres to the requirement of using `ArrayList` while declaring it with the `List` interface type, promoting good practice by programming to the interface. Completed tasks are added using `add()`.
 * 
 * 3.  **User Interaction & Control Flow:**
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   The `displayMenu()` method prints the options to `System.out`.
 *     *   User input for the menu choice is read, and a `switch` statement directs the program flow to the appropriate method (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) or exits the loop.
 * 
 * 4.  **Output:**
 *     *   All user-facing messages, prompts, menu display, and task lists are printed using `System.out`.
 *     *   Error messages, such as invalid menu input, empty task description attempts, and unexpected system errors, are explicitly printed to `System.err` as required.
 * 
 * 5.  **Exception Handling:**
 *     *   A `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might occur during the execution of the core logic. The error message and stack trace are printed to `System.err`.
 *     *   A specific `try-catch(InputMismatchException e)` is nested inside the loop to handle cases where the user enters non-integer input when prompted for the menu choice. This catch block prints an error to `System.err` and consumes the invalid input from the scanner buffer (`scanner.nextLine()`) to prevent an infinite loop.
 *     *   A `finally` block ensures that the `scanner` object is closed regardless of whether the loop finishes normally or an exception is caught, releasing system resources.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields (`description`, `pendingTasks`, `completedTasks`, `scanner`) are private. Access and modification are done through public methods.
 *     *   **Meaningful Names:** Class, method, and variable names (`TaskManager`, `Task`, `pendingTasks`, `addTask`, `processNextTask`, `run`, `choice`, `description`) are descriptive of their purpose.
 *     *   **Comments:** Javadoc comments are provided for classes and public methods. Inline comments explain specific logic points (like `offer` vs `add`, consuming newline after `nextInt`).
 *     *   **Input Validation:** The `addTask` method checks if the provided description is null or empty. The `InputMismatchException` handling validates that the menu input is an integer.
 *     *   **Error Handling:** Specific error types are handled (`InputMismatchException`), general errors are caught, and error messages are directed to `System.err`.
 *     *   **Clean Code Structure:** The code is organized into a main class with an inner helper class. Functionality is separated into distinct methods (`addTask`, `processNextTask`, etc.), making the `run` method clean and focused on the main loop and control flow.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, menu-driven application, demonstrating a solid understanding of fundamental and intermediate Java concepts suitable for a challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A simple console-based Task Management System.
 * Allows adding tasks to a pending queue, processing the next task,
 * and viewing both pending and completed tasks.
 */
public class TaskManager {

    /**
     * Represents a single task with a description.
     */
    private static class Task {
        private String description;

        /**
         * Constructs a new Task.
         * @param description The description of the task.
         */
        public Task(String description) {
            this.description = description;
        }

        /**
         * Gets the description of the task.
         * @return The task description.
         */
        public String getDescription() {
            return description;
        }

        /**
         * Provides a string representation of the task, which is its description.
         * @return The task description string.
         */
        @Override
        public String toString() {
            return description;
        }
    }

    // Queue to hold tasks that are pending
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // LinkedList is a common implementation for Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the description is not empty.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        // offer is generally preferred over add for bounded queues, but fine here
        pendingTasks.offer(newTask);
        System.out.println("Successfully added task: \"" + description.trim() + "\"");
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from the pending queue to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process.");
            return;
        }
        // poll retrieves and removes the head of the queue, returns null if empty (handled above)
        Task processedTask = pendingTasks.poll();
        completedTasks.add(processedTask);
        System.out.println("Successfully processed task: \"" + processedTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Handles the case where the pending queue is empty.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            int i = 1;
            // Iterating over a Queue typically uses its iterator, which does not remove elements
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task.getDescription());
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been completed.
     * Handles the case where the completed list is empty.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            int i = 1;
            for (Task task : completedTasks) {
                System.out.println(i++ + ". " + task.getDescription());
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop for the Task Management System.
     * Includes input handling, menu navigation, and class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch to handle unexpected exceptions during execution
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default value

                try {
                    choice = scanner.nextInt();
                    // Consume the rest of the line after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    // Consume the invalid input from the scanner buffer
                    scanner.nextLine();
                    // Continue the loop to display the menu again
                    continue;
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // General catch-all for any other unexpected exceptions
            System.err.println("An unexpected error occurred during program execution:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed when the application exits or an error occurs
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner closed."); // Optional: confirm closure
            }
        }
    }

    /**
     * The main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
