/*
 * Exam Question #452
 * Generated on: 2025-05-11 23:13:13
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Scheduler Simulation
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified multi-tasking system simulation. This system will manage a queue of pending tasks, process them one by one, and track their status. The system should allow users to add new tasks, process the next available task, view the status of all tasks, and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. It should have the following properties:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): A numerical priority (e.g., 1-5, lower number means higher priority).
 *     *   `status` (enum `TaskStatus`): The current status of the task (`PENDING`, `IN_PROGRESS`, `COMPLETED`, `FAILED`).
 *     *   Implement appropriate getters and setters (or make fields final and use a constructor).
 *     *   Override `toString()` for easy display.
 * 
 * 2.  **Task Status:** Create an enum `TaskStatus` with the values `PENDING`, `IN_PROGRESS`, `COMPLETED`, `FAILED`.
 * 
 * 3.  **Task Manager:** Create a class `TaskManager` that will manage the tasks. This class should contain the core logic.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks that are waiting to be processed (`PENDING`). A `LinkedList` is a suitable implementation.
 *     *   It must use a `java.util.ArrayList<Task>` to store all tasks created in the system, regardless of their current status.
 *     *   Methods should accept and return `java.util.List` where appropriate (e.g., a method to get all tasks).
 *     *   Implement the following methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task`, assigns a unique ID, sets status to `PENDING`, adds it to the pending queue, and also adds it to the list of all tasks. Should validate priority (e.g., 1-5).
 *         *   `processNextTask()`: Takes the next task from the pending queue (if available), changes its status to `IN_PROGRESS`, simulates processing (you can just change status to `COMPLETED` or `FAILED` based on a condition, like priority > 3 fails). The processed task should remain in the all-tasks list with its updated status. Handle the case where the queue is empty.
 *         *   `viewAllTasks()`: Returns a `List<Task>` containing all tasks currently managed by the system.
 *         *   `viewPendingTasks()`: Returns a `List<Task>` containing only tasks with `PENDING` status (retrieved from the queue or the all-tasks list).
 *     *   The `TaskManager` class should handle user interaction within its `main` method (or a dedicated run method called from main).
 * 
 * 4.  **User Interface (Console):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Display a menu of options: Add Task, Process Task, View All Tasks, View Pending Tasks, Exit.
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement input validation for user choices and task details (e.g., ensure priority is a number within the valid range).
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input processing and task processing logic, to catch potential errors (e.g., `NumberFormatException` for invalid priority input, or a custom exception for task processing failure).
 *     *   Use `System.err.println()` to display error messages to the user.
 *     *   Use `System.out.println()` for normal output (menu, task details, success messages).
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Execution:**
 * 
 * The program should start, display the menu, and repeatedly prompt the user for input until they choose the Exit option.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Enter task priority (1-5): 2
 * Task added: [ID: 1, Description: Implement feature X, Priority: 2, Status: PENDING]
 * 
 * Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: [ID: 1, Description: Implement feature X, Priority: 2, Status: IN_PROGRESS]
 * Task 1 completed successfully.
 * 
 * Task Scheduler Menu:
 * 1. Add New Task
 * ...
 * Enter your choice: 3
 * --- All Tasks ---
 * [ID: 1, Description: Implement feature X, Priority: 2, Status: COMPLETED]
 * --- End All Tasks ---
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter task priority (1-5): invalid
 * Error: Invalid priority. Please enter a number between 1 and 5.
 * ...
 * Enter your choice: 2
 * No tasks currently pending.
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Proper implementation of the `Task` and `TaskManager` classes.
 * *   Functional task management logic (add, process, view).
 * *   Robust input validation and error handling using `try-catch` and `System.err`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clear and correct output format.
 *
 * EXPLANATION:
 * This solution implements the Task Scheduler simulation as requested, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in, providing type safety and readability compared to using simple strings or integers for status.
 * 2.  **`Task` Class:** Represents a single task with `id`, `description`, `priority`, and `status`.
 *     *   Fields are `private` and `final` where appropriate (`id`, `description`, `priority`) or have a controlled setter (`status`), ensuring encapsulation.
 *     *   The constructor includes basic input validation for `description` and `priority`, throwing `IllegalArgumentException` if validation fails.
 *     *   `toString()` is overridden for convenient display of task details.
 * 3.  **`TaskManager` Class:** The core class managing the system.
 *     *   It uses a `Queue<Task>` (`pendingTasksQueue`) implemented by `LinkedList` to maintain the order of tasks waiting to be processed (FIFO - First-In, First-Out).
 *     *   It uses an `ArrayList<Task>` (`allTasksList`) to store a record of *all* tasks ever created, regardless of their current status. This allows viewing historical tasks.
 *     *   `AtomicInteger` is used to safely generate unique task IDs in a thread-safe manner (though threading isn't required by the problem, it's a good practice for ID generation).
 *     *   The `main` method creates a `TaskManager` instance and calls its `run` method to start the simulation loop.
 * 
 * **Required Component Usage:**
 * 
 * *   **`Queue`:** `pendingTasksQueue` is declared as `Queue<Task>` and initialized with `LinkedList`. `offer()` is used to add tasks to the end, and `poll()` is used to retrieve and remove tasks from the front.
 * *   **`ArrayList`:** `allTasksList` is declared and used to store all tasks. Tasks are added to it using `add()`.
 * *   **`List` interface:** Methods like `viewAllTasks()` and `viewPendingTasks()` are declared to return `List<Task>`, adhering to the requirement to use the interface. They return new `ArrayList` instances based on the internal collections to avoid exposing the internal state directly.
 * *   **`Scanner`:** Used in the `run` method to read user input from `System.in`. `scanner.nextInt()` reads integers, and `scanner.nextLine()` reads strings and consumes the newline character.
 * *   **`Switch statement`:** Used in the `run` method to control the flow based on the user's menu choice, directing execution to the appropriate `TaskManager` methods.
 * *   **`System.err`:** Used within the `try-catch` blocks and input validation checks to print error messages (e.g., invalid input, task processing failure).
 * *   **`System.out`:** Used for printing the menu, success messages, task details, and lists of tasks.
 * *   **`try-catch` blocks:**
 *     *   A large `try-catch` block wraps the main loop logic in the `run` method to catch general `Exception`s, including `InputMismatchException` which is common when `Scanner` expects a different type than entered.
 *     *   A nested `try-catch` block exists within the task processing simulation (`processNextTask`) to handle potential exceptions during the simulated work (although in this simple simulation, it primarily serves to catch potential issues and mark the task as `FAILED`).
 *     *   A `try-catch` block is also used when adding a task within the `switch` statement to catch `IllegalArgumentException` thrown by the `Task` constructor if input validation fails.
 * 
 * **Logic and Flow:**
 * 
 * 1.  The `run` method displays a menu.
 * 2.  It reads the user's integer choice using `Scanner`.
 * 3.  A `switch` statement directs execution based on the choice.
 * 4.  **Case 1 (Add Task):** Prompts for description and priority, reads input, calls `addTask`. `addTask` creates a `Task` object (which validates priority), adds it to both the `pendingTasksQueue` and `allTasksList`.
 * 5.  **Case 2 (Process Task):** Calls `processNextTask`. `processNextTask` uses `pendingTasksQueue.poll()` to get the next task. If a task is retrieved, its status is updated. A simple check (`priority > 3`) simulates a potential processing failure. The task's status is updated within the `allTasksList` because the `allTasksList` holds references to the same `Task` objects that were in the queue.
 * 6.  **Case 3 (View All Tasks):** Calls `viewAllTasks`, which returns a copy of the `allTasksList`. The program then iterates through this list and prints each task.
 * 7.  **Case 4 (View Pending Tasks):** Calls `viewPendingTasks`, which returns a copy of the `pendingTasksQueue` contents. The program iterates and prints.
 * 8.  **Case 5 (Exit):** Sets the `running` flag to `false`, ending the loop.
 * 9.  **Default Case:** Handles invalid menu choices.
 * 10. **Error Handling:** `try-catch` blocks catch `InputMismatchException` for non-integer input and `IllegalArgumentException` for invalid task details, printing messages to `System.err`. A general `catch(Exception)` handles other potential runtime errors.
 * 
 * **Best Practices:**
 * 
 * *   Meaningful names (`pendingTasksQueue`, `processNextTask`, `TaskStatus.PENDING`).
 * *   Encapsulation via `private` fields and public methods/getters/setters.
 * *   Basic Javadoc comments explain the purpose of classes and methods.
 * *   Input validation is performed at the point where data is used to create an object (`Task` constructor) and where user input is parsed (`run` method).
 * *   The code is structured logically into classes and methods, enhancing readability and maintainability.
 * 
 * This solution effectively integrates all the required Java components within a practical simulation, demonstrating an understanding of data structures, object-oriented design, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For unique ID generation

// Enum for Task Status
enum TaskStatus {
    PENDING,
    IN_PROGRESS,
    COMPLETED,
    FAILED
}

// Represents a single task
class Task {
    private final int id;
    private final String description;
    private final int priority;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID of the task.
     * @param description The description of the task.
     * @param priority The priority of the task (1-5).
     */
    public Task(int id, String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 1 || priority > 5) {
            throw new IllegalArgumentException("Task priority must be between 1 and 5.");
        }
        this.id = id;
        this.description = description.trim();
        this.priority = priority;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status (only status can change)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + id +
               ", Description: " + description +
               ", Priority: " + priority +
               ", Status: " + status + "]";
    }
}

// Manages the tasks using a Queue and ArrayList
public class TaskManager {

    // Use a Queue for tasks waiting to be processed (PENDING)
    private final Queue<Task> pendingTasksQueue;

    // Use an ArrayList to keep track of ALL tasks ever created
    private final ArrayList<Task> allTasksList;

    // For generating unique task IDs
    private final AtomicInteger taskIdCounter;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasksQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasksList = new ArrayList<>();
        this.taskIdCounter = new AtomicInteger(0); // Start IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The description of the task.
     * @param priority The priority of the task (1-5).
     * @throws IllegalArgumentException if description is invalid or priority is out of range.
     */
    public void addTask(String description, int priority) {
        // Task constructor performs validation
        int newId = taskIdCounter.incrementAndGet();
        Task newTask = new Task(newId, description, priority);

        // Add to both the queue (for processing) and the list (for tracking all)
        pendingTasksQueue.offer(newTask); // offer is preferred over add for queues
        allTasksList.add(newTask);

        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates processing by changing status to COMPLETED or FAILED.
     *
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasksQueue.poll(); // poll retrieves and removes the head

        if (taskToProcess == null) {
            System.out.println("No tasks currently pending.");
            return null;
        }

        System.out.println("Processing task: " + taskToProcess);
        taskToProcess.setStatus(TaskStatus.IN_PROGRESS); // Set status to IN_PROGRESS

        // Simulate processing logic: tasks with priority > 3 fail
        try {
            // Simulate some work
            // Thread.sleep(100); // Optional: add a small delay

            if (taskToProcess.getPriority() > 3) {
                taskToProcess.setStatus(TaskStatus.FAILED);
                System.out.println("Task " + taskToProcess.getId() + " failed due to low priority.");
            } else {
                taskToProcess.setStatus(TaskStatus.COMPLETED);
                System.out.println("Task " + taskToProcess.getId() + " completed successfully.");
            }
        } catch (Exception e) {
            // Catch potential exceptions during simulated processing
            taskToProcess.setStatus(TaskStatus.FAILED);
            System.err.println("Error processing task " + taskToProcess.getId() + ": " + e.getMessage());
        }

        // The task is already in allTasksList, no need to re-add.
        // Its status has been updated directly via the reference.

        return taskToProcess;
    }

    /**
     * Returns a list of all tasks managed by the system.
     *
     * @return A List containing all tasks.
     */
    public List<Task> viewAllTasks() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(allTasksList);
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     *
     * @return A List containing pending tasks.
     */
    public List<Task> viewPendingTasks() {
        // The queue itself is the source of pending tasks
        return new ArrayList<>(pendingTasksQueue); // Return a copy
    }

    /**
     * Runs the main Task Scheduler simulation loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (1-5): ");
                        int priority = scanner.nextInt();
                        scanner.nextLine(); // Consume newline

                        try {
                            addTask(description, priority);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        processNextTask();
                        break;

                    case 3: // View All Tasks
                        List<Task> allTasks = viewAllTasks();
                        System.out.println("--- All Tasks ---");
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks created yet.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("--- End All Tasks ---");
                        break;

                    case 4: // View Pending Tasks
                        List<Task> pendingTasks = viewPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks currently pending.");
                        } else {
                            // Iterate over the list returned by viewPendingTasks()
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("--- End Pending Tasks ---");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Scheduler.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (java.util.InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for the menu choice or priority.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
            System.out.println(); // Add a newline for better readability between cycles
        }

        scanner.close(); // Close the scanner when done
    }

    private void printMenu() {
        System.out.println("Task Scheduler Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
