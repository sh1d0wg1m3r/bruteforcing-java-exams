/*
 * Exam Question #83
 * Generated on: 2025-05-11 22:10:41
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Task Dispatch System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing tasks and dispatching them to available workers in a warehouse. Tasks arrive in a specific order and must be processed first-in, first-out. The system needs to track pending tasks, available workers, and handle the dispatch process based on user commands.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this warehouse task dispatch system. Your solution must strictly adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incoming tasks waiting to be dispatched. Tasks must be processed in the order they are added.
 *     *   Use a `java.util.ArrayList` to store the list of available workers. Declare the variable using the `java.util.List` interface type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   The program should present a menu of options to the user.
 *     *   Use a `switch` statement to process the user's chosen command.
 * 
 * 3.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, task/worker lists, and dispatch results.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, no tasks to dispatch, no workers available).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, such as invalid user input (non-integer where integer is expected) or attempts to perform operations on empty collections (like trying to dispatch a task when the queue is empty).
 * 
 * 5.  **System Functionality:**
 *     *   **Add Task:** Allow the user to add a new task to the system. Each task should have a unique ID (auto-generated) and a description provided by the user.
 *     *   **Add Worker:** Allow the user to add a new worker to the system. Each worker should have a unique ID (auto-generated) and a name provided by the user.
 *     *   **Dispatch Task:** Attempt to dispatch the next pending task from the queue to the first available worker in the list.
 *         *   If there are pending tasks and available workers, remove the task from the queue, assign it to the worker, and print a success message indicating which task was assigned to which worker.
 *         *   If there are no pending tasks, print an error message using `System.err`.
 *         *   If there are no available workers, print an error message using `System.err`.
 *     *   **List Pending Tasks:** Display all tasks currently in the queue.
 *     *   **List Available Workers:** Display all workers currently in the list.
 *     *   **Exit:** Terminate the program.
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) for classes (`Task`, `Worker`, `WarehouseDispatchSystem`).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., ensure description/name is not empty).
 * 
 * **Expected Output Structure:**
 * 
 * The program should run in a loop, presenting the menu and processing commands until the user chooses to exit.
 * 
 * ```
 * --- Warehouse Dispatch System Menu ---
 * 1. Add Task
 * 2. Add Worker
 * 3. Dispatch Task
 * 4. List Pending Tasks
 * 5. List Available Workers
 * 6. Exit
 * Enter your choice:
 * ```
 * 
 * Upon successful operations or listing, output should be informative, like:
 * 
 * ```
 * Task added: Task #1 - Pick items for Order 101
 * Worker added: Worker #1 - Alice
 * Task #1 assigned to Worker #1.
 * Pending Tasks:
 * Task #2 - Pack items for Shipment 505
 * Task #3 - Receive new inventory
 * Available Workers:
 * Worker #1 - Alice
 * Worker #2 - Bob
 * ```
 * 
 * Error messages should go to `System.err`:
 * 
 * ```
 * Error: No pending tasks to dispatch.
 * Error: No available workers to dispatch tasks.
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Focus on the core requirements. Do not implement complex features like worker availability status (all workers in the list are considered available for this problem), task completion, etc.
 * *   The solution should be contained within a single file for simplicity in an exam setting.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the system logic (task queueing, worker listing, dispatching logic).
 * *   Proper error handling and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clean and readable code structure.
 *
 * EXPLANATION:
 * This solution implements a simplified Warehouse Task Dispatch System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Task` class: Represents a single task with an auto-generated ID and a description. Uses a static counter (`nextTaskId`) for unique IDs.
 *     *   `Worker` class: Represents a single worker with an auto-generated ID and a name. Uses a static counter (`nextWorkerId`) for unique IDs.
 *     *   `WarehouseDispatchSystem` class: The main class that orchestrates the system. It holds the data structures (`Queue` and `List`) and the main logic.
 * 
 * 2.  **Data Structures:**
 *     *   `Queue<Task> pendingTasks`: A `LinkedList` is used to implement the `Queue` interface. This ensures tasks are stored and retrieved in a First-In, First-Out (FIFO) manner, crucial for task dispatching order. `offer()` is used for adding (safer than `add`), and `poll()` is used for retrieving and removing the head of the queue (returns `null` if empty, safer than `remove()`).
 *     *   `List<Worker> availableWorkers`: An `ArrayList` is used to store workers. It's declared using the `List` interface type (`List<Worker> availableWorkers = new ArrayList<>();`), which is a best practice for flexibility.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`):**
 *     *   A `Scanner` object reads input from `System.in`.
 *     *   The `run()` method contains the main loop. Inside the loop, `displayMenu()` shows options.
 *     *   `scanner.nextInt()` reads the user's menu choice. A subsequent `scanner.nextLine()` is necessary to consume the leftover newline character after reading the integer, preventing issues with subsequent `nextLine()` calls for reading strings.
 *     *   A `switch` statement branches the execution based on the user's integer choice, calling the appropriate methods (`addTask`, `addWorker`, `dispatchTask`, `listPendingTasks`, `listAvailableWorkers`, or exiting).
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, confirmation messages (task/worker added, task dispatched), and lists of tasks/workers.
 *     *   `System.err.println()` is specifically used for error messages, such as invalid menu choices, empty input for names/descriptions, or conditions preventing dispatch (no tasks/workers).
 * 
 * 5.  **Error Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the code that reads the user's choice and the `switch` statement within the main loop in the `run()` method.
 *     *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A generic `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, demonstrating a broader exception handling strategy, printing the error message and stack trace.
 *     *   Specific checks (`pendingTasks.isEmpty()`, `availableWorkers.isEmpty()`, `description.trim().isEmpty()`, `name.trim().isEmpty()`) are performed within methods (`dispatchTask`, `addTask`, `addWorker`) to validate conditions *before* attempting operations that might fail, printing errors to `System.err` when conditions aren't met.
 * 
 * 6.  **System Functionality Implementation:**
 *     *   `addTask(String description)`: Creates a new `Task` object and uses `pendingTasks.offer()` to add it to the end of the queue. Includes validation for empty description.
 *     *   `addWorker(String name)`: Creates a new `Worker` object and uses `availableWorkers.add()` to add it to the `ArrayList`. Includes validation for empty name.
 *     *   `dispatchTask()`: Checks if both the task queue (`pendingTasks`) and worker list (`availableWorkers`) are non-empty. If both conditions are met, it uses `pendingTasks.poll()` to get and remove the next task from the front of the queue and retrieves the first worker from the `availableWorkers` list (`availableWorkers.get(0)` for simplicity). It then prints the assignment message. If either tasks or workers are missing, it prints an appropriate error to `System.err`.
 *     *   `listPendingTasks()`: Iterates through the `pendingTasks` queue using a for-each loop (which uses the queue's iterator, not removing elements) and prints each task.
 *     *   `listAvailableWorkers()`: Iterates through the `availableWorkers` list and prints each worker.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields (`pendingTasks`, `availableWorkers`, `scanner` in `WarehouseDispatchSystem`, `id`, `description` in `Task`, `id`, `name` in `Worker`) are `private`. Access is provided via public methods (`addTask`, `dispatchTask`, etc.) and getters.
 *     *   **Naming:** Variable, method, and class names are descriptive (e.g., `pendingTasks`, `dispatchTask`, `WarehouseDispatchSystem`).
 *     *   **Comments/Documentation:** Javadoc comments are included for classes and key methods explaining their purpose. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Checks for empty strings for task descriptions and worker names are included. The `try-catch` handles invalid numeric input.
 * 
 * This solution effectively integrates all required Java components to build a functional, albeit simplified, system that demonstrates core object-oriented principles and error handling techniques expected in advanced Java programming.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task in the warehouse.
 */
class Task {
    private static int nextTaskId = 1;
    private int id;
    private String description;

    /**
     * Constructs a new Task with an auto-generated ID.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextTaskId++;
        this.description = description;
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task #" + id + " - " + description;
    }
}

/**
 * Represents a worker in the warehouse.
 */
class Worker {
    private static int nextWorkerId = 1;
    private int id;
    private String name;

    /**
     * Constructs a new Worker with an auto-generated ID.
     * @param name The name of the worker.
     */
    public Worker(String name) {
        this.id = nextWorkerId++;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Worker #" + id + " - " + name;
    }
}

/**
 * Manages tasks and workers for dispatching.
 */
public class WarehouseDispatchSystem {

    private Queue<Task> pendingTasks;
    private List<Worker> availableWorkers;
    private Scanner scanner;

    /**
     * Constructs a new WarehouseDispatchSystem.
     */
    public WarehouseDispatchSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.availableWorkers = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is safer than add, returns false if failed
        System.out.println("Task added: " + newTask);
    }

    /**
     * Adds a new worker to the list of available workers.
     * @param name The name of the worker.
     */
    public void addWorker(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Worker name cannot be empty.");
            return;
        }
        Worker newWorker = new Worker(name.trim());
        availableWorkers.add(newWorker);
        System.out.println("Worker added: " + newWorker);
    }

    /**
     * Attempts to dispatch the next pending task to an available worker.
     */
    public void dispatchTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to dispatch.");
            return;
        }

        if (availableWorkers.isEmpty()) {
            System.err.println("Error: No available workers to dispatch tasks.");
            return;
        }

        // Get the next task from the queue (FIFO)
        Task taskToDispatch = pendingTasks.poll(); // poll returns null if queue is empty, but we checked above

        // For simplicity, assign to the first worker in the list
        Worker worker = availableWorkers.get(0); // Assuming availableWorkers is not empty, checked above

        if (taskToDispatch != null && worker != null) {
             System.out.println(taskToDispatch + " assigned to " + worker + ".");
             // In a real system, the worker would become busy, task state would change, etc.
             // For this problem, we just simulate the assignment and remove from queue.
        } else {
             // This case should ideally not be reached due to checks above, but good practice
             System.err.println("Error: Could not dispatch task due to an internal issue.");
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all available workers.
     */
    public void listAvailableWorkers() {
        System.out.println("--- Available Workers ---");
        if (availableWorkers.isEmpty()) {
            System.out.println("No workers currently available.");
        } else {
            for (Worker worker : availableWorkers) {
                System.out.println(worker);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse Dispatch System Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Add Worker");
        System.out.println("3. Dispatch Task");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. List Available Workers");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main program loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String taskDesc = scanner.nextLine();
                        addTask(taskDesc);
                        break;
                    case 2:
                        System.out.print("Enter worker name: ");
                        String workerName = scanner.nextLine();
                        addWorker(workerName);
                        break;
                    case 3:
                        dispatchTask();
                        break;
                    case 4:
                        listPendingTasks();
                        break;
                    case 5:
                        listAvailableWorkers();
                        break;
                    case 6:
                        System.out.println("Exiting Warehouse Dispatch System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the program.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseDispatchSystem system = new WarehouseDispatchSystem();
        system.run();
    }
}
