/*
 * Exam Question #686
 * Generated on: 2025-05-12 16:25:51
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Package Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Warehouse Package Processing System in Java. The system manages incoming packages that need to be processed and stored. Packages arrive and are placed in an arrival queue. A processing station takes packages from the front of this queue, simulates processing, and then moves them to a list of processed packages. The system should be interactive, allowing a user (simulating a warehouse operator) to perform various actions.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a `Package` class with the following private attributes:
 *     *   `packageId` (int)
 *     *   `description` (String)
 *     *   `weight` (double)
 *     *   Include a constructor, public getter methods for all attributes, and a meaningful `toString()` method.
 * 
 * 2.  **Warehouse System:** Create a `WarehouseSystem` class that manages the package flow.
 *     *   It must contain a `Queue<Package>` named `arrivalQueue` to hold packages awaiting processing. Use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *     *   It must contain a `List<Package>` named `processedPackages` to store packages after processing. Use `java.util.ArrayList` as the concrete implementation for the `List`. Declare it using the `List` interface type.
 * 
 * 3.  **Core Functionality:** Implement the following methods within the `WarehouseSystem` class:
 *     *   `addPackage(int packageId, String description, double weight)`: Creates a new `Package` object and adds it to the `arrivalQueue`.
 *     *   `processNextPackage()`: Removes the package at the front of the `arrivalQueue` and adds it to the `processedPackages` list. If the `arrivalQueue` is empty, it should handle this gracefully and inform the user.
 *     *   `viewArrivalQueue()`: Displays the contents of the `arrivalQueue`.
 *     *   `viewProcessedPackages()`: Displays the contents of the `processedPackages` list.
 *     *   `runSystem()`: Contains the main application loop, displaying a menu, reading user input, and calling the appropriate methods based on the user's choice.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu with options:
 *         1.  Add New Package
 *         2.  Process Next Package
 *         3.  View Arrival Queue
 *         4.  View Processed Packages
 *         5.  Exit
 *     *   Use a `switch` statement within the `runSystem()` method to handle the user's menu choice.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and package lists/queue contents.
 *     *   Use `System.err` to display error messages (e.g., "Invalid menu choice!", "Arrival queue is empty!").
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly within the `runSystem()` method, to catch potential issues like invalid input (`InputMismatchException`) and prevent the program from crashing. Handle the case where the user enters non-integer input for the menu choice.
 * 
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc-style documentation where necessary.
 *     *   Perform basic input validation (e.g., check if queue is empty before processing).
 *     *   Structure the code clearly with separate classes.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. When a user selects an option, the system should perform the action and provide feedback (success message, error message, or list display). Exiting option should terminate the program.
 * 
 * Example interaction flow:
 * *   Display menu.
 * *   User enters '1'.
 * *   Prompt for package details (ID, description, weight).
 * *   User enters details.
 * *   System confirms package added.
 * *   Display menu.
 * *   User enters '2'.
 * *   System processes package or indicates queue empty.
 * *   Display menu.
 * *   User enters '3' or '4'.
 * *   System displays queue/list contents.
 * *   Display menu.
 * *   User enters '5'.
 * *   System exits.
 * *   If user enters invalid input (e.g., 'abc' for menu choice), `System.err` should show an error, and the menu should reappear.
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simplified Warehouse Package Processing System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:** This class is a simple Plain Old Java Object (POJO) representing a package. It has private fields (`packageId`, `description`, `weight`), a constructor to initialize them, public getter methods for accessing the data (encapsulation), and an overridden `toString()` method for easy printing of package details.
 * 
 * 2.  **`WarehouseSystem` Class:** This is the core class managing the system logic.
 *     *   **`Queue<Package> arrivalQueue`**: A `Queue` is used here because it naturally models a waiting line or buffer where packages arrive and are processed in a First-In, First-Out (FIFO) order. `LinkedList` is a common implementation of `Queue` in Java. `offer()` is used for adding, which is a non-throwing variant of `add()` (though `LinkedList` doesn't have capacity limits where this difference matters significantly, it's good practice). `poll()` is used for removing from the front, which is a non-throwing variant of `remove()`, returning `null` if the queue is empty (though we check for emptiness before calling it).
 *     *   **`List<Package> processedPackages`**: A `List` is used to store the packages that have been processed. An `ArrayList` provides dynamic resizing and efficient element access/addition, suitable for storing a growing collection of processed items. It's declared using the `List` interface type (`List<Package> processedPackages = new ArrayList<>();`), which is good practice as it allows changing the underlying implementation (e.g., to `LinkedList` if needed) without affecting code that only relies on the `List` interface methods.
 *     *   **`Scanner scanner`**: Used for reading user input from `System.in`. It's initialized once in the constructor and closed when the system exits.
 *     *   **`addPackage()`**: Creates a `Package` object and adds it to the `arrivalQueue` using `offer()`.
 *     *   **`processNextPackage()`**: Checks if the `arrivalQueue` is empty using `isEmpty()`. If not, it removes the head of the queue using `poll()` and adds it to the `processedPackages` list using `add()`. If the queue is empty, it prints an error message to `System.err`.
 *     *   **`viewArrivalQueue()` and `viewProcessedPackages()`**: These methods iterate through the respective collections (queue and list) using enhanced for loops and print the `toString()` representation of each `Package`. They also check if the collections are empty and print appropriate messages.
 *     *   **`displayMenu()`**: A helper method to print the menu options to `System.out`.
 *     *   **`runSystem()`**: This method contains the main application loop (`while(running)`). It repeatedly displays the menu, reads user input, and uses a `switch` statement to dispatch the action based on the user's integer choice.
 *     *   **Class-wide Exception Handling:** The core logic within the `while` loop in `runSystem()` is wrapped in a `try-catch` block. This handles potential exceptions that might occur during user input, specifically `InputMismatchException` if the user enters non-integer input when an integer is expected (like the menu choice or package ID). When `InputMismatchException` is caught, an error is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input from the buffer, preventing an infinite loop. A general `Exception` catch is also included as a fallback for any other unexpected runtime issues.
 *     *   **Input Validation:** Basic validation is done for package weight (non-negative) and explicitly checking if the queue is empty before attempting to process.
 *     *   **Output Streams:** `System.out.println()` is used for normal messages (menu, prompts, success confirmations, list/queue contents). `System.err.println()` is strictly used for error messages.
 *     *   **Best Practices:** Private fields and public methods enforce encapsulation. Variable and method names are descriptive. Comments explain the purpose of classes and methods. The code is structured into logical classes.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) within a practical, menu-driven application, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with ID, description, and weight.
 */
class Package {
    private int packageId;
    private String description;
    private double weight;

    /**
     * Constructs a new Package object.
     * @param packageId The unique identifier for the package.
     * @param description A brief description of the package contents.
     * @param weight The weight of the package in some unit.
     */
    public Package(int packageId, String description, double weight) {
        this.packageId = packageId;
        this.description = description;
        this.weight = weight;
    }

    // Getters
    public int getPackageId() {
        return packageId;
    }

    public String getDescription() {
        return description;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the Package.
     * @return A formatted string including package details.
     */
    @Override
    public String toString() {
        return "Package{" +
               "ID=" + packageId +
               ", Description='" + description + '\'' +
               ", Weight=" + weight +
               '}';
    }
}

/**
 * Manages the warehouse package processing flow using a queue and a list.
 */
public class WarehouseSystem {
    // Queue for incoming packages awaiting processing
    private Queue<Package> arrivalQueue;
    // List for packages that have been processed
    private List<Package> processedPackages;
    private Scanner scanner;

    /**
     * Constructs a new WarehouseSystem.
     * Initializes the arrival queue and processed packages list.
     */
    public WarehouseSystem() {
        // Use LinkedList as the concrete implementation for Queue
        this.arrivalQueue = new LinkedList<>();
        // Use ArrayList as the concrete implementation for List
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new package to the arrival queue.
     * @param packageId The ID of the package.
     * @param description The description of the package.
     * @param weight The weight of the package.
     */
    public void addPackage(int packageId, String description, double weight) {
        Package newPackage = new Package(packageId, description, weight);
        arrivalQueue.offer(newPackage); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity constrained. Still good practice.
        System.out.println("Package added to arrival queue: " + newPackage);
    }

    /**
     * Processes the next package from the arrival queue.
     * Removes it from the queue and adds it to the processed list.
     */
    public void processNextPackage() {
        if (arrivalQueue.isEmpty()) {
            System.err.println("Error: Arrival queue is empty. No packages to process.");
        } else {
            Package processedPackage = arrivalQueue.poll(); // poll() returns null if queue is empty, but we already checked
            processedPackages.add(processedPackage);
            System.out.println("Package processed: " + processedPackage);
        }
    }

    /**
     * Displays the contents of the arrival queue.
     */
    public void viewArrivalQueue() {
        System.out.println("\n--- Arrival Queue ---");
        if (arrivalQueue.isEmpty()) {
            System.out.println("The arrival queue is currently empty.");
        } else {
            int index = 1;
            for (Package pkg : arrivalQueue) {
                System.out.println(index++ + ". " + pkg);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays the contents of the processed packages list.
     */
    public void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            int index = 1;
            for (Package pkg : processedPackages) {
                System.out.println(index++ + ". " + pkg);
            }
        }
        System.out.println("--------------------------\n");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Arrival Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main interactive system loop.
     * Handles user input and calls appropriate methods.
     * Includes class-wide exception handling for input errors.
     */
    public void runSystem() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling for the main loop
        while (running) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        System.out.print("Enter Package ID: ");
                        int id = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        System.out.print("Enter Description: ");
                        String desc = scanner.nextLine();
                        System.out.print("Enter Weight: ");
                        double weight = scanner.nextDouble();
                        scanner.nextLine(); // Consume newline

                        // Basic validation for non-negative weight
                        if (weight < 0) {
                             System.err.println("Error: Weight cannot be negative. Package not added.");
                             break; // Skip adding package if weight is invalid
                        }

                        addPackage(id, desc, weight);
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewArrivalQueue();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where user enters non-integer for menu or non-double for weight etc.
                System.err.println("Invalid input. Please enter the correct type of value.");
                // Consume the invalid input to prevent infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for better readability between interactions
        }

        // Close the scanner when the system exits
        scanner.close();
    }

    /**
     * Main method to start the Warehouse System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.runSystem();
    }
}
