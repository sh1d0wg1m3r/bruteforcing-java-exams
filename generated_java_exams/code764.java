/*
 * Exam Question #764
 * Generated on: 2025-05-12 16:37:26
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Automated Document Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Automated Document Processing System. This system manages documents that need to be processed sequentially. Documents are added to a queue, and the system processes them one by one in the order they were added. The system should allow users to add new documents, process the next document in the queue, view the current queue, and view documents that have already been processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a class named `Document` to represent a document. It should have:
 *     *   A unique integer `documentId`.
 *     *   A `String documentType` (e.g., "Invoice", "Report", "Form").
 *     *   A `String status` (e.g., "Pending", "Processed").
 *     *   Private fields with public getter methods.
 *     *   A constructor to initialize `documentId` and `documentType`. The initial status should be "Pending".
 *     *   A method `setStatus(String status)` to update the document's status.
 *     *   Override the `toString()` method to provide a user-friendly representation (e.g., "Document [ID: 1, Type: Invoice, Status: Pending]").
 * 
 * 2.  **Processing System Logic:** Create a class named `DocumentProcessor` containing the main logic. This class should manage:
 *     *   A `Queue<Document>` to hold documents awaiting processing.
 *     *   A `List<Document>` to hold documents that have been processed.
 *     *   A mechanism to generate unique document IDs (start from 1 and increment).
 *     *   The `main` method to run the system's command-line interface.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method using `java.util.Scanner`. The system should repeatedly prompt the user for a command until they choose to exit. Supported commands are:
 *     *   `ADD`: Prompts the user for a document type and adds a new document to the processing queue.
 *     *   `PROCESS`: Takes the next document from the queue, changes its status to "Processed", and moves it to the list of processed documents.
 *     *   `VIEW_QUEUE`: Displays all documents currently in the processing queue in their order.
 *     *   `VIEW_PROCESSED`: Displays all documents that have been processed.
 *     *   `EXIT`: Terminates the program.
 * 
 * 4.  **Implementation Details & Best Practices:**
 *     *   Use `java.util.ArrayList` as the concrete implementation for the `List` of processed documents.
 *     *   Use a suitable implementation for the `Queue` (e.g., `java.util.LinkedList`).
 *     *   Declare collection variables using the interface types (`Queue`, `List`).
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Use `System.out.println()` for normal output (prompts, confirmations, list contents).
 *     *   Use `System.err.println()` for displaying error messages (e.g., trying to process when the queue is empty, invalid command).
 *     *   Implement input validation where necessary (e.g., checking for empty input for document type).
 *     *   Implement exception handling: Wrap the main command loop (or the core processing logic) in a `try-catch` block to catch unexpected runtime exceptions and print an error message to `System.err`.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc is a plus).
 *     *   Close the `Scanner` resource when the program exits.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Examples:
 * 
 * ```
 * --- Document Processing System ---
 * Available Commands: ADD, PROCESS, VIEW_QUEUE, VIEW_PROCESSED, EXIT
 * Enter command: ADD
 * Enter document type: Invoice
 * Document [ID: 1, Type: Invoice, Status: Pending] added to queue.
 * Enter command: ADD
 * Enter document type: Report
 * Document [ID: 2, Type: Report, Status: Pending] added to queue.
 * Enter command: VIEW_QUEUE
 * Current Queue:
 * Document [ID: 1, Type: Invoice, Status: Pending]
 * Document [ID: 2, Type: Report, Status: Pending]
 * Enter command: PROCESS
 * Processing document: Document [ID: 1, Type: Invoice, Status: Pending]
 * Document [ID: 1, Type: Invoice, Status: Processed] moved to processed list.
 * Enter command: VIEW_QUEUE
 * Current Queue:
 * Document [ID: 2, Type: Report, Status: Pending]
 * Enter command: VIEW_PROCESSED
 * Processed Documents:
 * Document [ID: 1, Type: Invoice, Status: Processed]
 * Enter command: PROCESS
 * Processing document: Document [ID: 2, Type: Report, Status: Pending]
 * Document [ID: 2, Type: Report, Status: Processed] moved to processed list.
 * Enter command: PROCESS
 * Error: The processing queue is empty.
 * Enter command: INVALID_COMMAND
 * Error: Invalid command. Please use ADD, PROCESS, VIEW_QUEUE, VIEW_PROCESSED, or EXIT.
 * Enter command: EXIT
 * Exiting Document Processing System.
 * ```
 * 
 * Your solution should be a single Java file containing both the `Document` and `DocumentProcessor` classes.
 *
 * EXPLANATION:
 * This solution implements the Automated Document Processing System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Document` Class:**
 *     *   Encapsulation is used with `private` fields (`documentId`, `documentType`, `status`) and `public` getter methods.
 *     *   The constructor initializes the required fields and sets the default status to "Pending".
 *     *   `setStatus` allows updating the status externally.
 *     *   `toString()` is overridden for convenient printing of document details.
 * 
 * 2.  **`DocumentProcessor` Class:**
 *     *   `Queue<Document> documentQueue`: A `LinkedList` is used to implement the `Queue` interface, suitable for FIFO (First-In, First-Out) processing where documents are added to the end and removed from the beginning.
 *     *   `List<Document> processedDocuments`: An `ArrayList` is used to implement the `List` interface, suitable for storing processed documents where order is maintained and elements can be easily iterated over.
 *     *   `nextDocumentId`: A simple integer counter ensures unique IDs for each new document.
 *     *   **`addDocument(String type)`:** Creates a new `Document` instance with the next available ID and the provided type. It adds the document to the `documentQueue` using `queue.add()`. Includes basic input validation for the document type.
 *     *   **`processNextDocument()`:** Checks if the queue is empty using `queue.isEmpty()`. If not empty, it uses `queue.poll()` to retrieve and remove the document at the head of the queue. It then updates the document's status and adds it to the `processedDocuments` list using `list.add()`. An error message is printed to `System.err` if the queue is empty.
 *     *   **`viewQueue()`:** Iterates through the `documentQueue` using a for-each loop to display its contents without removing elements. Checks for emptiness first.
 *     *   **`viewProcessed()`:** Iterates through the `processedDocuments` list using a for-each loop to display its contents. Checks for emptiness first.
 *     *   **`main(String[] args)`:**
 *         *   Initializes the `DocumentProcessor` and `Scanner`.
 *         *   The core logic is within a `while(running)` loop.
 *         *   A `try-catch(Exception e)` block wraps the entire main loop. This provides a safety net, catching any unexpected `Exception` that might occur during the program's execution within the loop and printing an error to `System.err`. This fulfills the "class-wide exception handling" requirement by protecting the main execution flow.
 *         *   Inside the loop, it reads user input using `scanner.nextLine()`.
 *         *   A `switch` statement handles the different commands (`ADD`, `PROCESS`, `VIEW_QUEUE`, `VIEW_PROCESSED`, `EXIT`), converting input to uppercase for case-insensitivity.
 *         *   Each case calls the appropriate method of the `DocumentProcessor` instance.
 *         *   The `default` case of the `switch` handles invalid commands, printing an error to `System.err`.
 *         *   The `EXIT` case sets `running` to `false`, terminating the loop.
 *         *   A `finally` block ensures that the `scanner.close()` method is called regardless of whether the loop finishes normally or an exception is caught, releasing the system resource.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical, object-oriented structure, demonstrating key Java concepts and best practices suitable for an advanced exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a document to be processed.
 */
class Document {
    private int documentId;
    private String documentType;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Document with the given ID and type.
     * Status is initialized to "Pending".
     *
     * @param documentId The unique ID for the document.
     * @param documentType The type of the document (e.g., "Invoice", "Report").
     */
    public Document(int documentId, String documentType) {
        this.documentId = documentId;
        this.documentType = documentType;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getDocumentId() {
        return documentId;
    }

    public String getDocumentType() {
        return documentType;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the document.
     *
     * @param status The new status (e.g., "Processed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Document.
     *
     * @return A formatted string describing the document.
     */
    @Override
    public String toString() {
        return "Document [ID: " + documentId + ", Type: " + documentType + ", Status: " + status + "]";
    }
}

/**
 * Manages a queue of documents for processing and a list of processed documents.
 * Provides a command-line interface for interaction.
 */
public class DocumentProcessor {

    private Queue<Document> documentQueue;
    private List<Document> processedDocuments;
    private int nextDocumentId; // To generate unique IDs

    /**
     * Constructs a new DocumentProcessor, initializing the queue and list.
     */
    public DocumentProcessor() {
        this.documentQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start IDs from 1
    }

    /**
     * Adds a new document to the processing queue.
     *
     * @param type The type of the document to add.
     */
    public void addDocument(String type) {
        if (type == null || type.trim().isEmpty()) {
            System.err.println("Error: Document type cannot be empty.");
            return;
        }
        Document newDocument = new Document(nextDocumentId++, type.trim());
        documentQueue.add(newDocument);
        System.out.println(newDocument + " added to queue.");
    }

    /**
     * Processes the next document from the queue.
     * Moves the document from the queue to the processed list.
     */
    public void processNextDocument() {
        if (documentQueue.isEmpty()) {
            System.err.println("Error: The processing queue is empty.");
            return;
        }

        Document docToProcess = documentQueue.poll(); // Get and remove the head of the queue
        System.out.println("Processing document: " + docToProcess);

        docToProcess.setStatus("Processed"); // Update status
        processedDocuments.add(docToProcess); // Add to processed list

        System.out.println(docToProcess + " moved to processed list.");
    }

    /**
     * Displays all documents currently in the processing queue.
     */
    public void viewQueue() {
        if (documentQueue.isEmpty()) {
            System.out.println("The processing queue is empty.");
            return;
        }
        System.out.println("--- Current Queue ---");
        // Iterate without removing elements
        for (Document doc : documentQueue) {
            System.out.println(doc);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all documents that have been processed.
     */
    public void viewProcessed() {
        if (processedDocuments.isEmpty()) {
            System.out.println("No documents have been processed yet.");
            return;
        }
        System.out.println("--- Processed Documents ---");
        for (Document doc : processedDocuments) {
            System.out.println(doc);
        }
        System.out.println("---------------------------");
    }

    /**
     * Main method to run the Document Processing System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DocumentProcessor processor = new DocumentProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Document Processing System ---");
        System.out.println("Available Commands: ADD, PROCESS, VIEW_QUEUE, VIEW_PROCESSED, EXIT");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toUpperCase(); // Read command and normalize

                switch (command) {
                    case "ADD":
                        System.out.print("Enter document type: ");
                        String docType = scanner.nextLine(); // Read document type
                        processor.addDocument(docType);
                        break;
                    case "PROCESS":
                        processor.processNextDocument();
                        break;
                    case "VIEW_QUEUE":
                        processor.viewQueue();
                        break;
                    case "VIEW_PROCESSED":
                        processor.viewProcessed();
                        break;
                    case "EXIT":
                        running = false;
                        System.out.println("Exiting Document Processing System.");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please use ADD, PROCESS, VIEW_QUEUE, VIEW_PROCESSED, or EXIT.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed even if an exception occurs
            scanner.close();
            System.out.println("Scanner closed."); // Indicate resource cleanup
        }
    }
}
