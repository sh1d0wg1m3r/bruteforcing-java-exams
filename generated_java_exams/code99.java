/*
 * Exam Question #99
 * Generated on: 2025-05-11 22:14:03
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Print Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Print Queue Management System. The system manages print jobs submitted by various users. Jobs are added to a queue and processed one by one by a single "printer" resource. The system should prioritize jobs based on a priority level, processing the highest priority job currently in the queue next, rather than strictly following a FIFO order. The system must also maintain a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a console-based Java application with the following features:
 * 
 * 1.  **Add Print Job:** Allows a user to submit a new print job. A job should have a unique ID (automatically generated), a user name, a file name, and a priority level (an integer, where a lower number indicates higher priority, e.g., 1 = highest, 5 = lowest). New jobs are added to a pending queue.
 * 2.  **Process Next Job:** Simulates the printer processing the next job. This function should find the job with the *highest priority* currently in the pending queue, remove it from the queue, mark its status as completed, and move it to a history list of completed jobs. If the queue is empty, report an error.
 * 3.  **View Pending Jobs:** Displays a list of all jobs currently in the pending queue, showing their ID, user, file name, and priority.
 * 4.  **View Completed Jobs:** Displays a list of all jobs that have been processed, showing their ID, user, file name, and status.
 * 5.  **Cancel Print Job:** Allows a user to cancel a pending job by its ID. If the job is found in the pending queue, remove it and report success. If not found or the queue is empty, report an error.
 * 6.  **Exit:** Terminates the application.
 * 
 * **Technical Constraints:**
 * 
 * Your solution *must* utilize the following Java components:
 * 
 * *   `java.util.Queue` (specifically, use a class that implements `Queue`, like `LinkedList`) for storing pending print jobs.
 * *   `java.util.ArrayList` for storing completed print jobs.
 * *   `java.util.List` interface (used in method signatures or variable declarations where appropriate, e.g., when returning lists of jobs).
 * *   `java.util.Scanner` for reading user input from the console.
 * *   `switch` statement for handling the main menu options.
 * *   `System.err` for printing error messages (e.g., invalid input, queue empty, job not found).
 * *   `System.out` for printing normal output (menu, job details, success messages).
 * *   Class-wide exception handling using `try-catch` blocks, particularly for handling invalid user input (e.g., non-integer where an integer is expected) and potentially for unexpected runtime errors.
 * 
 * **Implementation Details & Best Practices:**
 * 
 * *   Create separate classes for `PrintJob` and `PrintQueueManager`.
 * *   Use proper encapsulation (`private` fields, `public` methods) for your classes.
 * *   Employ meaningful variable and method names.
 * *   Include appropriate comments and Javadoc for clarity.
 * *   Implement robust input validation (e.g., ensure menu choices are valid, priority is within a reasonable range, job ID for cancellation is an integer).
 * *   Handle edge cases gracefully (e.g., empty queue when processing or cancelling).
 * *   The priority processing (`processNextJob`) should iterate through the `Queue` implementation (e.g., `LinkedList`) to find the highest priority job and then remove it using an `Iterator`'s `remove()` method to avoid `ConcurrentModificationException` or inefficient list manipulation.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu to the user and respond to their choices. Error messages should be clearly distinguished using `System.err`.
 * 
 * ```
 * --- Print Queue Management ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Cancel Print Job
 * 6. Exit
 * Enter your choice:
 * ```
 * 
 * *(Subsequent output will depend on user interaction, showing job details, success messages, or errors.)*
 * 
 * **Evaluation Criteria:**
 * 
 * Your solution will be evaluated based on:
 * 
 * *   Correctness and functionality according to the requirements.
 * *   Adherence to all technical constraints (usage of specified components).
 * *   Implementation of best practices (encapsulation, naming, comments, clean structure).
 * *   Effectiveness of input validation and error handling (`try-catch`, `System.err`).
 * *   Correct implementation of priority-based processing from the `Queue`.
 *
 * EXPLANATION:
 * This solution implements the Print Queue Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The system is divided into three classes:
 *     *   `PrintJob`: A simple POJO (Plain Old Java Object) encapsulating the data for a single print job. It has private fields (`jobId`, `userName`, `fileName`, `priority`, `status`) and public getter methods, demonstrating encapsulation. It also includes a `toString()` method for easy printing and basic validation in the constructor.
 *     *   `PrintQueueManager`: This class holds the core logic for managing the print jobs. It contains a `Queue<PrintJob>` (`pendingJobs`) using `LinkedList` as the concrete implementation and a `List<PrintJob>` (`completedJobs`) using `ArrayList`. It includes methods for adding, processing, viewing, and cancelling jobs.
 *     *   `PrintSystem`: This is the main class with the `main` method. It handles user interaction via `Scanner`, presents the menu using `System.out`, uses a `switch` statement to control the application flow based on user input, and calls the appropriate methods in `PrintQueueManager`.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `pendingJobs` is declared as `Queue<PrintJob>` and initialized with `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing methods like `offer()` (to add to the end) and allowing iteration.
 *     *   `completedJobs` is declared and initialized as `new ArrayList<>()`, which implements the `List` interface.
 *     *   Method signatures like `viewPendingJobs()` and `viewCompletedJobs()` return `List<PrintJob>`, adhering to the requirement of using the `List` interface.
 * 
 * 3.  **User Input (`Scanner`) and Flow Control (`switch`):**
 *     *   A `Scanner` object is used in the `main` method to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used on the user's menu choice to direct execution to the corresponding logic block.
 * 
 * 4.  **Error Handling (`try-catch`, `System.err`):**
 *     *   Input validation for menu choices, priority, and job ID is performed using `try-catch(InputMismatchException)` blocks around `scanner.nextInt()`. Invalid input is caught, an error message is printed to `System.err`, and the invalid input is consumed using `scanner.nextLine()` to prevent infinite loops.
 *     *   Edge cases like trying to process or cancel a job when the `pendingJobs` queue is empty are handled with `if` checks, printing informative error messages to `System.err`.
 *     *   A broader `try-catch(Exception)` block is wrapped around the main application loop in `main` to catch any unexpected runtime errors, printing the error message and stack trace to `System.err`.
 *     *   The `PrintJob` constructor includes basic validation for priority and throws `IllegalArgumentException`, which is caught when adding a job in `PrintQueueManager`.
 * 
 * 5.  **Priority Processing from `Queue`:**
 *     *   The `processNextJob()` method demonstrates a non-standard use of a basic `Queue` (`LinkedList`) to achieve priority processing. It first iterates through the queue elements to find the job with the highest priority (lowest integer value).
 *     *   Crucially, it then uses an `Iterator` obtained from the `pendingJobs` queue (`LinkedList`) to iterate again and safely remove the identified highest-priority job using `iterator.remove()`. This avoids potential `ConcurrentModificationException` that could occur if trying to remove while using a standard enhanced `for` loop. This specific logic fulfills the requirement of using `Queue` while implementing priority-based removal, which is more complex than a simple `poll()`.
 *     *   The `cancelJob()` method uses a similar iterator-based approach to find and remove a job by its ID from the pending queue.
 * 
 * 6.  **Output (`System.out`, `System.err`):**
 *     *   The menu, job details, and success messages are printed to `System.out`.
 *     *   All error messages (invalid input, queue empty, job not found) are printed to `System.err`, clearly separating them from normal output.
 * 
 * 7.  **Best Practices:**
 *     *   Encapsulation is used effectively in the `PrintJob` and `PrintQueueManager` classes.
 *     *   Variable and method names are descriptive (e.g., `pendingJobs`, `processNextJob`, `cancelJob`).
 *     *   Comments and Javadoc are included to explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation and error handling are integrated throughout the user interaction logic.
 *     *   The code is structured into logical classes, promoting modularity.
 * 
 * This solution effectively integrates all the required Java components into a cohesive, practical system while addressing complexity through priority processing on a standard `Queue` implementation and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;

// Represents a single print job
class PrintJob {
    private int jobId;
    private String userName;
    private String fileName;
    private int priority; // Lower number = higher priority
    private String status; // e.g., PENDING, COMPLETED, CANCELLED

    public PrintJob(int jobId, String userName, String fileName, int priority) {
        if (priority < 1) {
            throw new IllegalArgumentException("Priority must be 1 or higher.");
        }
        this.jobId = jobId;
        this.userName = userName;
        this.fileName = fileName;
        this.priority = priority;
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getUserName() {
        return userName;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Job ID: " + jobId + ", User: " + userName + ", File: " + fileName +
               ", Priority: " + priority + ", Status: " + status;
    }
}

// Manages the print queue and completed jobs
class PrintQueueManager {
    // Use LinkedList as a Queue for pending jobs
    private Queue<PrintJob> pendingJobs;
    // Use ArrayList for completed jobs history
    private List<PrintJob> completedJobs;
    private int nextJobId; // Counter for unique job IDs

    public PrintQueueManager() {
        this.pendingJobs = new LinkedList<>(); // Implements Queue
        this.completedJobs = new ArrayList<>(); // Implements List
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue.
     * @param userName The user submitting the job.
     * @param fileName The name of the file to print.
     * @param priority The priority level (lower is higher priority).
     */
    public void addJob(String userName, String fileName, int priority) {
        try {
            PrintJob newJob = new PrintJob(nextJobId++, userName, fileName, priority);
            pendingJobs.offer(newJob); // Add to the end of the queue
            System.out.println("Job added: " + newJob.toString());
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding job: " + e.getMessage());
        }
    }

    /**
     * Finds and processes the highest priority job from the pending queue.
     * Removes the job from the queue and adds it to the completed list.
     */
    public void processNextJob() {
        if (pendingJobs.isEmpty()) {
            System.err.println("Error: No pending jobs to process.");
            return;
        }

        PrintJob jobToProcess = null;
        int highestPriority = Integer.MAX_VALUE; // Lower number = higher priority

        // Find the highest priority job in the queue without removing yet
        for (PrintJob job : pendingJobs) {
            if (job.getPriority() < highestPriority) {
                highestPriority = job.getPriority();
                jobToProcess = job;
            } else if (job.getPriority() == highestPriority) {
                // If priorities are equal, process the one that has been in the queue longer (FIFO within same priority)
                // The iteration order of LinkedList provides this FIFO behavior.
                if (jobToProcess == null) { // First job found with this priority
                     jobToProcess = job;
                }
                // If jobToProcess is already set to a job with this priority, the current job
                // will be processed later as it's further down the queue.
            } else if (jobToProcess == null && highestPriority == Integer.MAX_VALUE) {
                 // Handles case where the very first job checked is the only one or highest so far.
                 jobToProcess = job;
                 highestPriority = job.getPriority();
            }
        }

        // Now, remove the selected job using an iterator to safely remove while iterating
        Iterator<PrintJob> iterator = pendingJobs.iterator();
        while (iterator.hasNext()) {
            PrintJob job = iterator.next();
            if (job.getJobId() == jobToProcess.getJobId()) {
                iterator.remove(); // Safely remove the current element
                break; // Job found and removed, exit loop
            }
        }

        // Simulate printing and move to completed
        System.out.println("Processing Job ID: " + jobToProcess.getJobId() +
                           " (User: " + jobToProcess.getUserName() +
                           ", File: " + jobToProcess.getFileName() + ")");
        jobToProcess.setStatus("COMPLETED"); // Update status
        completedJobs.add(jobToProcess); // Add to completed list (ArrayList)
        System.out.println("Job ID " + jobToProcess.getJobId() + " completed.");
    }

    /**
     * Returns a List of all pending print jobs.
     * @return A List containing pending PrintJob objects.
     */
    public List<PrintJob> viewPendingJobs() {
        // Return a new ArrayList containing the elements to avoid external modification
        // of the internal queue structure.
        return new ArrayList<>(pendingJobs); // Queue elements copied to List
    }

    /**
     * Returns a List of all completed print jobs.
     * @return A List containing completed PrintJob objects.
     */
    public List<PrintJob> viewCompletedJobs() {
        // Return the internal ArrayList directly as it's meant to be viewed/read
        return completedJobs; // ArrayList is a List
    }

    /**
     * Cancels a pending print job by its ID.
     * @param jobId The ID of the job to cancel.
     */
    public void cancelJob(int jobId) {
        if (pendingJobs.isEmpty()) {
            System.err.println("Error: No pending jobs to cancel.");
            return;
        }

        PrintJob jobToCancel = null;
        Iterator<PrintJob> iterator = pendingJobs.iterator();

        // Iterate and find the job by ID, removing it safely
        while (iterator.hasNext()) {
            PrintJob job = iterator.next();
            if (job.getJobId() == jobId) {
                jobToCancel = job;
                iterator.remove(); // Safely remove using iterator
                break; // Job found and removed
            }
        }

        if (jobToCancel != null) {
            jobToCancel.setStatus("CANCELLED"); // Update status
            System.out.println("Job ID " + jobId + " cancelled successfully.");
            // Optionally, you could add cancelled jobs to a separate list or the completed list
            // For this problem, we just remove and report.
        } else {
            System.err.println("Error: Job ID " + jobId + " not found in pending queue.");
        }
    }
}

// Main application class
public class PrintSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager manager = new PrintQueueManager();
        boolean running = true;

        // Main application loop with general exception handling
        try {
            while (running) {
                printMenu();
                int choice = -1;

                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to next iteration
                }

                // Use switch for menu options
                switch (choice) {
                    case 1: // Add Print Job
                        System.out.print("Enter User Name: ");
                        String userName = scanner.nextLine();
                        System.out.print("Enter File Name: ");
                        String fileName = scanner.nextLine();
                        int priority = -1;
                        // Input validation for priority
                        try {
                            System.out.print("Enter Priority (1=highest, 5=lowest): ");
                            priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            if (priority < 1) {
                                System.err.println("Invalid priority. Must be 1 or higher.");
                                continue; // Skip adding job
                            }
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for priority. Please enter a number.");
                            scanner.nextLine(); // Consume invalid input
                            continue; // Skip adding job
                        }
                        manager.addJob(userName, fileName, priority);
                        break;

                    case 2: // Process Next Job
                        manager.processNextJob();
                        break;

                    case 3: // View Pending Jobs
                        List<PrintJob> pending = manager.viewPendingJobs();
                        if (pending.isEmpty()) {
                            System.out.println("No pending jobs.");
                        } else {
                            System.out.println("--- Pending Jobs ---");
                            for (PrintJob job : pending) {
                                System.out.println(job);
                            }
                            System.out.println("--------------------");
                        }
                        break;

                    case 4: // View Completed Jobs
                        List<PrintJob> completed = manager.viewCompletedJobs();
                        if (completed.isEmpty()) {
                            System.out.println("No completed jobs.");
                        } else {
                            System.out.println("--- Completed Jobs ---");
                            for (PrintJob job : completed) {
                                System.out.println(job);
                            }
                            System.out.println("--------------------");
                        }
                        break;

                    case 5: // Cancel Print Job
                        int jobIdToCancel = -1;
                        // Input validation for job ID
                        try {
                            System.out.print("Enter Job ID to cancel: ");
                            jobIdToCancel = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for Job ID. Please enter a number.");
                            scanner.nextLine(); // Consume invalid input
                            continue; // Skip cancellation
                        }
                        manager.cancelJob(jobIdToCancel);
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Print Queue Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Print Queue Management ---");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Cancel Print Job");
        System.out.println("6. Exit");
    }
}
