/*
 * Exam Question #1069
 * Generated on: 2025-05-12 17:20:47
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Exam Question Title:** Advanced Task Processing System
 * 
 * **Problem Description:**
 * Design and implement a simplified Task Processing System in Java. This system should manage a queue of tasks waiting to be processed and a list of tasks that have been completed. The system should interact with the user via the console, allowing them to add new tasks, process the next task in the queue, view the current queue, and view the list of completed tasks.
 * 
 * Your solution must demonstrate proficiency in using various core Java concepts and collections.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Components:** Your solution *must* utilize the following Java components from the `java.util` package:
 *     *   `Queue` (use an implementation like `LinkedList`)
 *     *   `ArrayList` (as an implementation)
 *     *   `List` (as an interface type for a variable)
 *     *   `Scanner` (for reading user input from `System.in`)
 *     *   `switch` statement (for handling different user commands)
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing normal output, prompts, and results)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., around the main interaction loop or core operations).
 * 
 * 2.  **System Functionality:** Implement the following commands via user input:
 *     *   `add`: Prompts the user for a task description and adds a new task to the end of the processing queue. The task description cannot be empty.
 *     *   `process`: Removes the task at the front of the queue, marks it as completed, and moves it to the list of completed tasks. If the queue is empty, an appropriate error message should be displayed using `System.err`.
 *     *   `view_queue`: Displays all tasks currently in the processing queue in order. Indicate if the queue is empty.
 *     *   `view_completed`: Displays all tasks that have been completed. Indicate if no tasks have been completed.
 *     *   `exit`: Terminates the program.
 * 
 * 3.  **Task Representation:** Create a simple `Task` class with at least a description and a status (e.g., completed/pending).
 * 
 * 4.  **System Class:** Create a `TaskProcessingSystem` class that encapsulates the `Queue` and `List` and provides methods for the operations described above (`addTask`, `processNextTask`, `viewQueue`, `viewCompletedTasks`).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement input validation (e.g., check for empty task description, handle empty queue).
 *     *   Implement proper error handling using `System.err` for user-level errors and `try-catch` for exceptions.
 *     *   Structure your code cleanly (e.g., separate classes).
 * 
 * **Expected Output:**
 * The program should interact with the user, displaying prompts and results to `System.out` and errors to `System.err`. The output for viewing queues/lists should clearly list the tasks.
 * 
 * Example Interaction:
 * ```
 * Welcome to the Task Processing System!
 * Available commands: add, process, view_queue, view_completed, exit
 * 
 * Enter command: add
 * Enter task description: Buy groceries
 * Task added to queue: Buy groceries
 * 
 * Enter command: add
 * Enter task description: Walk the dog
 * Task added to queue: Walk the dog
 * 
 * Enter command: view_queue
 * 
 * --- Current Task Queue ---
 * 1. [Pending] Buy groceries
 * 2. [Pending] Walk the dog
 * --------------------------
 * 
 * 
 * Enter command: process
 * Task processed: Buy groceries
 * 
 * Enter command: view_queue
 * 
 * --- Current Task Queue ---
 * 1. [Pending] Walk the dog
 * --------------------------
 * 
 * 
 * Enter command: view_completed
 * 
 * --- Completed Tasks ---
 * 1. [Completed] Buy groceries
 * -----------------------
 * 
 * 
 * Enter command: process
 * Task processed: Walk the dog
 * 
 * Enter command: process
 * Error: The task queue is empty. No tasks to process.
 * 
 * Enter command: view_completed
 * 
 * --- Completed Tasks ---
 * 1. [Completed] Buy groceries
 * 2. [Completed] Walk the dog
 * -----------------------
 * 
 * 
 * Enter command: exit
 * Exiting Task Processing System.
 * System shutdown complete.
 * ```
 * 
 * **Submission:**
 * Provide the complete Java code for all necessary classes (`Task`, `TaskProcessingSystem`, and the main class containing the `main` method).
 *
 * EXPLANATION:
 * This solution implements a simplified Task Processing System using the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Task`: A simple class to represent a task with a `description` and a boolean `isCompleted` status. It includes a constructor, getters, a `markCompleted()` method, and an overridden `toString()` for easy printing. Fields are `private` for encapsulation.
 *     *   `TaskProcessingSystem`: This class manages the core logic. It holds a `Queue<Task>` for tasks waiting to be processed and a `List<Task>` (implemented by `ArrayList`) for completed tasks. Methods like `addTask`, `processNextTask`, `viewQueue`, and `viewCompletedTasks` encapsulate the operations on these collections. Fields are `private`.
 *     *   `TaskSystemExam`: This is the main class containing the `main` method. It handles user interaction, creates an instance of `TaskProcessingSystem`, reads commands using `Scanner`, and uses a `switch` statement to delegate actions to the `TaskProcessingSystem` instance.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: The `taskQueue` field in `TaskProcessingSystem` is declared as `Queue<Task>` and initialized with a `LinkedList`, which is a common `Queue` implementation providing FIFO (First-In, First-Out) behavior suitable for a processing queue. `addTask` uses `add()` and `processNextTask` uses `poll()`.
 *     *   `ArrayList`: The `completedTasks` field is initialized as an `ArrayList<Task>`, providing a dynamic, ordered list to store completed tasks.
 *     *   `List interface`: The `completedTasks` field is declared with the `List` interface type, demonstrating good practice of programming to interfaces.
 *     *   `Scanner`: An instance is created in `main` to read user commands and task descriptions from `System.in`.
 *     *   `switch statement`: Used in `main` to determine which action to perform based on the user's input command string.
 *     *   `System.err`: Used to print error messages, such as when an unknown command is entered, when `process` is called on an empty queue, or when an empty task description is provided during `add`. It's also used to print the stack trace for unexpected exceptions.
 *     *   `System.out`: Used for all normal output, including prompts, success messages (e.g., "Task added"), and displaying the contents of the queue and completed tasks list.
 *     *   Class-wide exception handling with `try-catch`: The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level catch for any unexpected runtime exceptions that might occur during the program's execution. Additionally, a specific `try-catch(IllegalArgumentException e)` is used around the `system.addTask(description)` call to handle the validation error for empty descriptions gracefully, printing a user-friendly error message to `System.err`. The `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskProcessingSystem` are `private`, accessible only through public methods, protecting the internal state.
 *     *   **Meaningful Names:** Variable and method names (`taskQueue`, `completedTasks`, `addTask`, `processNextTask`, `viewQueue`, `viewCompletedTasks`, `description`, `isCompleted`) are descriptive of their purpose.
 *     *   **Comments and Documentation:** Javadoc-style comments are included for classes and methods, explaining their purpose, parameters, and return values or exceptions. Inline comments clarify specific code logic where necessary.
 *     *   **Input Validation:** The `addTask` method explicitly checks if the provided description is null or empty/whitespace and throws an `IllegalArgumentException`. The `processNextTask` method checks if the `taskQueue` is empty before attempting to `poll`, preventing potential errors and providing a user-friendly message via `System.err`.
 *     *   **Error Handling:** User-level errors (like invalid commands or empty queues) are reported via `System.err`. Specific exceptions (`IllegalArgumentException`) are caught and handled locally, while a general `catch(Exception e)` provides robustness against unexpected issues.
 *     *   **Clean Code Structure:** The code is divided into logical classes (`Task`, `TaskProcessingSystem`, `TaskSystemExam`) with clear responsibilities.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, interactive application, adhering to best practices for robust and maintainable code.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single task in the system.
 * Follows best practices for encapsulation.
 */
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task with a description.
     * Tasks are initially pending.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.isCompleted = false; // Tasks start as not completed
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task including its status.
     * @return A formatted string for the task.
     */
    @Override
    public String toString() {
        return "[" + (isCompleted ? "Completed" : "Pending") + "] " + description;
    }
}

/**
 * Manages the task processing queue and completed tasks list.
 * Encapsulates the collection logic.
 */
class TaskProcessingSystem {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queue and completed tasks list.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as a Queue implementation for FIFO behavior
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation for completed tasks history
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the processing queue.
     * Includes input validation for the task description.
     * @param description The description of the task. Must not be null or empty/whitespace.
     * @throws IllegalArgumentException if the description is null or empty/whitespace.
     */
    public void addTask(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        taskQueue.add(newTask); // Add task to the end of the queue
        System.out.println("Task added to queue: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the front of the queue, marks it completed, and adds it to the completed list.
     * Handles the case where the queue is empty.
     * @return true if a task was successfully processed, false if the queue was empty.
     */
    public boolean processNextTask() {
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.err.println("Error: The task queue is empty. No tasks to process.");
            return false;
        }

        // Retrieve and remove the head of the queue
        Task taskToProcess = taskQueue.poll();

        // This check is defensive as isEmpty() was just called, but poll() can return null if empty.
        if (taskToProcess != null) {
            taskToProcess.markCompleted(); // Mark the task as completed
            completedTasks.add(taskToProcess); // Add the completed task to the list
            System.out.println("Task processed: " + taskToProcess.getDescription());
            return true;
        }
        return false; // Should theoretically not be reached due to the isEmpty check
    }

    /**
     * Displays all tasks currently in the processing queue to System.out.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("--------------------------\n");
    }

    /**
     * Displays all tasks that have been completed to System.out.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the completed tasks list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("-----------------------\n");
    }

    // Optional: Getters for sizes if needed elsewhere, though not required by prompt
    public int getQueueSize() {
        return taskQueue.size();
    }

    public int getCompletedCount() {
        return completedTasks.size();
    }
}

/**
 * Main class for the Task Processing System user interface.
 * Handles user interaction via console.
 * Includes the main method and class-wide exception handling.
 */
public class TaskSystemExam {

    public static void main(String[] args) {
        // Use Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        System.out.println("Welcome to the Task Processing System!");
        System.out.println("Available commands: add, process, view_queue, view_completed, exit");

        // Class-wide exception handling for the main interaction loop
        try {
            while (running) {
                System.out.print("\nEnter command: ");
                // Read command and trim whitespace, convert to lower case for case-insensitivity
                String command = scanner.nextLine().trim().toLowerCase();

                // Use switch statement for command handling
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine(); // Read the entire line as description
                        try {
                            // Call system method to add task, handles validation internally
                            system.addTask(description);
                        } catch (IllegalArgumentException e) {
                            // Use System.err for input validation errors
                            System.err.println("Input Error: " + e.getMessage());
                        }
                        break;

                    case "process":
                        // Call system method to process the next task
                        system.processNextTask(); // Error message handled inside the system class
                        break;

                    case "view_queue":
                        // Call system method to view the queue
                        system.viewQueue();
                        break;

                    case "view_completed":
                        // Call system method to view completed tasks
                        system.viewCompletedTasks();
                        break;

                    case "exit":
                        // Set running flag to false to exit the loop
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;

                    default:
                        // Handle unknown commands using System.err
                        System.err.println("Error: Unknown command '" + command + "'. Please use add, process, view_queue, view_completed, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that might occur
            // Print error details to System.err
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace for debugging
        } finally {
            // Ensure the Scanner resource is closed regardless of exceptions
            scanner.close();
            System.out.println("System shutdown complete.");
        }
    }
}
