/*
 * Exam Question #987
 * Generated on: 2025-05-12 17:08:58
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Automated Assembly Line Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of an automated assembly line. Products arrive, are processed one by one, and then moved to a storage area. The system needs to manage products waiting for assembly, handle the assembly process which can occasionally fail, and keep track of completed (assembled or rejected) products. The user should be able to interact with the simulation via a console menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Representation:** Create a `Product` class with private fields for `id` (int), `name` (String), and `status` (String, e.g., "PENDING", "ASSEMBLED", "REJECTED"). Include a constructor and public getter methods. Add a method `setStatus(String status)` and override `toString()` for easy printing.
 * 2.  **Assembly Line Management:** Create an `AssemblyLine` class.
 *     *   It must use a `java.util.Queue<Product>` to hold products waiting for assembly.
 *     *   It must use a `java.util.List<Product>` (specifically implemented using `java.util.ArrayList`) to store products after they have been processed (either assembled or rejected).
 *     *   Include methods:
 *         *   `addProduct(Product product)`: Adds a product to the waiting queue.
 *         *   `processNextProduct()`: Takes the next product from the queue, simulates processing. There should be a *chance* (e.g., 80% success, 20% failure) that processing fails. If successful, the product's status is set to "ASSEMBLED" and it's added to the completed list. If it fails, the status is set to "REJECTED" and it's also added to the completed list. Handle the case where the queue is empty.
 *         *   `viewPendingProducts()`: Prints details of all products currently in the waiting queue.
 *         *   `viewCompletedProducts()`: Prints details of all products in the completed list.
 *         *   `runSimulation(Scanner scanner)`: This method should contain the main simulation loop. It should present a menu to the user (Add Product, Process Next, View Pending, View Completed, Exit). It should use the provided `Scanner` for input.
 * 3.  **User Interaction (`runSimulation`):**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Use `System.err` for invalid input messages.
 *     *   When adding a product, prompt the user for ID and name. Validate that the ID is a positive integer and the name is not empty. Use `System.err` for validation errors.
 * 4.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks within the `runSimulation` method to catch potential runtime errors that might occur during the simulation loop (e.g., unexpected issues during processing simulation). Use `System.err` to report caught exceptions.
 * 5.  **Output:** Use `System.out` for all normal output (menu, product details, success messages). Use `System.err` for all error messages (input validation errors, processing errors, caught exceptions).
 * 6.  **Best Practices:** Adhere to Java best practices including proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments and documentation (using Javadoc-style comments), and clean code structure.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 1
 * Enter Product ID: 101
 * Enter Product Name: Widget A
 * Product 101 added to pending queue.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 1
 * Enter Product ID: abc
 * Error: Invalid input. Please enter an integer for Product ID.
 * Enter Product Name:
 * Error: Product name cannot be empty.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 2
 * Processing product 101 (Widget A)...
 * Product 101 (Widget A) successfully assembled.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Products ---
 * Queue is empty.
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Products ---
 * [ID: 101, Name: Widget A, Status: ASSEMBLED]
 * 
 * --- Assembly Line Menu ---
 * 1. Add New Product
 * 2. Process Next Product
 * 3. View Pending Products
 * 4. View Completed Products
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Assembly Line Menu ---
 * ... (continue simulation) ...
 * Enter your choice: 5
 * Exiting simulation.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective use of `try-catch` for exception handling.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Input validation and error handling robustness.
 * *   Code clarity, readability, and documentation.
 * *   Correctness of the simulation logic (adding, processing, viewing).
 * 
 * Implement the `Product` and `AssemblyLine` classes and a main method to start the simulation.
 *
 * EXPLANATION:
 * This solution implements a simplified assembly line simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Product` Class:**
 *     *   Represents an individual item with `id`, `name`, and `status`.
 *     *   Uses private fields and public getters/setters for encapsulation.
 *     *   The constructor includes basic validation for ID (positive) and name (not empty), throwing `IllegalArgumentException`.
 *     *   `toString()` provides a convenient way to print product details.
 * 
 * 2.  **`AssemblyLine` Class:**
 *     *   **Collections:**
 *         *   `pendingProducts`: Declared as `Queue<Product>` and instantiated with `LinkedList<Product>`. `LinkedList` is a common implementation for `Queue` that supports FIFO (First-In, First-Out) operations efficiently. Products waiting for assembly are stored here.
 *         *   `completedProducts`: Declared as `List<Product>` and instantiated with `ArrayList<Product>`. `ArrayList` is used to store products after they have been processed, regardless of success or failure. `List` interface is used for the declaration as good practice, allowing flexibility in the underlying implementation later if needed.
 *     *   **`addProduct(Product product)`:** Uses `queue.offer()` to add a product to the end of the pending queue.
 *     *   **`processNextProduct()`:**
 *         *   Checks if the queue is empty before attempting to process.
 *         *   Uses `queue.poll()` to remove and retrieve the product at the front of the queue.
 *         *   Simulates processing success or failure using `Random` and a predefined `SUCCESS_RATE`.
 *         *   Sets the product's status to "ASSEMBLED" or "REJECTED" accordingly.
 *         *   Adds the processed product to the `completedProducts` list.
 *         *   Includes a `try-catch` block specifically around the processing logic (though for this simple simulation, the main loop's try-catch is sufficient, this demonstrates localized handling if processing was more complex).
 *         *   Uses `System.out` for success messages and `System.err` for rejection messages.
 *     *   **`viewPendingProducts()` and `viewCompletedProducts()`:** Iterate through the respective collections and print product details using the `Product.toString()` method.
 *     *   **`runSimulation(Scanner scanner)`:**
 *         *   Contains the main event loop (`while(running)`).
 *         *   Presents a menu using `System.out`.
 *         *   Reads user input using the provided `Scanner`.
 *         *   Uses a `switch` statement to direct execution based on the user's `choice`.
 *         *   Includes `try-catch` blocks:
 *             *   An `InputMismatchException` is caught specifically when reading the menu choice or product ID to handle non-integer input gracefully using `System.err`. `scanner.nextLine()` is crucial here to clear the invalid input from the buffer.
 *             *   An `IllegalArgumentException` is caught, which can be thrown by the `Product` constructor during input validation.
 *             *   A general `Exception` is caught as the "class-wide" handler, wrapping the core `switch` logic. This catches any other unexpected runtime exceptions that might occur within the loop, preventing the program from crashing and reporting the error using `System.err`.
 *         *   Calls helper method `addProductFromInput` to handle the details of getting product input.
 *     *   **`addProductFromInput(Scanner scanner)`:** A private helper method to encapsulate the logic for getting product ID and name from the user, including input validation (`InputMismatchException` for ID, checking if name is empty) before creating and adding the `Product`.
 * 
 * 3.  **`AssemblyLineSimulation` (Main Class):**
 *     *   Contains the `main` method.
 *     *   Creates a `Scanner` instance to read from `System.in`.
 *     *   Creates an `AssemblyLine` instance.
 *     *   Calls `line.runSimulation(scanner)` to start the interactive loop.
 *     *   Ensures the `Scanner` is closed after the simulation exits.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) within a practical, simulated scenario, while adhering to good programming practices like encapsulation, meaningful names, and error handling. The complexity comes from the combination of data structures, user interaction, input validation, and simulated processing logic with potential failures, all tied together with robust exception handling.
 */

import java.util.LinkedList; // Common Queue implementation
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

/**
 * Represents a product in the assembly line simulation.
 */
class Product {
    private int id;
    private String name;
    private String status; // e.g., "PENDING", "ASSEMBLED", "REJECTED"

    /**
     * Constructs a new Product.
     * @param id The unique identifier for the product.
     * @param name The name of the product.
     */
    public Product(int id, String name) {
        if (id <= 0) {
            throw new IllegalArgumentException("Product ID must be positive.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Product name cannot be empty.");
        }
        this.id = id;
        this.name = name.trim();
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the product.
     * @param status The new status (e.g., "ASSEMBLED", "REJECTED").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the product.
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", Name: " + name + ", Status: " + status + "]";
    }
}

/**
 * Simulates an assembly line managing products.
 */
class AssemblyLine {
    private Queue<Product> pendingProducts;
    private List<Product> completedProducts;
    private Random random; // For simulating processing success/failure
    private static final double SUCCESS_RATE = 0.8; // 80% success chance

    /**
     * Constructs a new AssemblyLine.
     */
    public AssemblyLine() {
        // Use LinkedList as a Queue implementation
        this.pendingProducts = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedProducts = new ArrayList<>();
        this.random = new Random();
    }

    /**
     * Adds a product to the pending queue.
     * @param product The product to add.
     */
    public void addProduct(Product product) {
        pendingProducts.offer(product); // offer is generally preferred over add for queues
        System.out.println("Product " + product.getId() + " added to pending queue.");
    }

    /**
     * Processes the next product from the queue.
     * Simulates assembly success or failure.
     */
    public void processNextProduct() {
        if (pendingProducts.isEmpty()) {
            System.out.println("No products in the pending queue to process.");
            return;
        }

        Product productToProcess = pendingProducts.poll(); // Remove from the front of the queue
        System.out.println("Processing product " + productToProcess.getId() + " (" + productToProcess.getName() + ")...");

        try {
            // Simulate processing time/effort (optional, but adds realism)
            // Thread.sleep(100);

            // Simulate processing success or failure
            if (random.nextDouble() < SUCCESS_RATE) {
                productToProcess.setStatus("ASSEMBLED");
                completedProducts.add(productToProcess);
                System.out.println("Product " + productToProcess.getId() + " (" + productToProcess.getName() + ") successfully assembled.");
            } else {
                productToProcess.setStatus("REJECTED");
                completedProducts.add(productToProcess);
                System.err.println("Processing failed for product " + productToProcess.getId() + " (" + productToProcess.getName() + "). Product rejected.");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during processing simulation
            productToProcess.setStatus("REJECTED"); // Mark as rejected due to error
            completedProducts.add(productToProcess);
            System.err.println("An unexpected error occurred while processing product " + productToProcess.getId() + ": " + e.getMessage());
            // Re-throw or handle as needed; for this simulation, just log and continue.
        }
    }

    /**
     * Prints all products currently in the pending queue.
     */
    public void viewPendingProducts() {
        System.out.println("--- Pending Products ---");
        if (pendingProducts.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate without removing
            for (Product product : pendingProducts) {
                System.out.println(product);
            }
        }
    }

    /**
     * Prints all products in the completed list.
     */
    public void viewCompletedProducts() {
        System.out.println("--- Completed Products ---");
        if (completedProducts.isEmpty()) {
            System.out.println("No products have been completed yet.");
        } else {
            for (Product product : completedProducts) {
                System.out.println(product);
            }
        }
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     * @param scanner The Scanner object for user input.
     */
    public void runSimulation(Scanner scanner) {
        boolean running = true;
        while (running) {
            printMenu();
            int choice = -1;

            // Class-wide exception handling for the simulation loop
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addProductFromInput(scanner);
                        break;
                    case 2:
                        processNextProduct();
                        break;
                    case 3:
                        viewPendingProducts();
                        break;
                    case 4:
                        viewCompletedProducts();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulation.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (IllegalArgumentException e) {
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop execution
                System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging in a real scenario
            }
            System.out.println(); // Add a newline for better readability between iterations
        }
    }

    /**
     * Helper method to get product details from user input and add the product.
     * @param scanner The Scanner object for user input.
     */
    private void addProductFromInput(Scanner scanner) {
        int id = -1;
        String name = null;

        System.out.print("Enter Product ID: ");
        try {
            id = scanner.nextInt();
            scanner.nextLine(); // Consume newline
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter an integer for Product ID.");
            scanner.nextLine(); // Consume the invalid input
            return; // Exit method if ID input is invalid
        }

        System.out.print("Enter Product Name: ");
        name = scanner.nextLine();

        try {
            Product newProduct = new Product(id, name);
            addProduct(newProduct);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Product constructor
            System.err.println("Error adding product: " + e.getMessage());
        }
    }

    /**
     * Prints the main menu options.
     */
    private void printMenu() {
        System.out.println("--- Assembly Line Menu ---");
        System.out.println("1. Add New Product");
        System.out.println("2. Process Next Product");
        System.out.println("3. View Pending Products");
        System.out.println("4. View Completed Products");
        System.out.println("5. Exit");
    }
}

/**
 * Main class to start the Assembly Line Simulation.
 */
public class AssemblyLineSimulation {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        AssemblyLine line = new AssemblyLine();

        line.runSimulation(scanner);

        scanner.close(); // Close the scanner when done
    }
}
