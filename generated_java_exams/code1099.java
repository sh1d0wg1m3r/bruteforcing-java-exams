/*
 * Exam Question #1099
 * Generated on: 2025-05-12 17:24:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Help Desk Support System
 * 
 * **Problem Description:**
 * 
 * You are required to develop a command-line simulation of a simple Help Desk Support System. The system will manage incoming support requests, allow processing of these requests in a First-In, First-Out (FIFO) manner, and maintain a record of resolved requests.
 * 
 * The application must present a menu to the user and perform actions based on their choice.
 * 
 * **Required Functionalities:**
 * 
 * 1.  **Add New Request:** Prompt the user for a description of the support request. Assign a unique sequential ID to each new request and add it to a queue of pending requests.
 * 2.  **Process Next Request:** Take the oldest request from the front of the queue, mark its status as "Resolved", and move it to an archive list. If there are no requests in the queue, inform the user.
 * 3.  **View Current Queue:** Display all requests currently waiting in the pending queue, showing their ID, status (which should be "Open"), and description. Display them in the order they would be processed.
 * 4.  **View Archived Requests:** Display all requests that have been processed and moved to the archive list, showing their ID, status ("Resolved"), and description.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must strictly adhere to the following:
 * 
 * *   Utilize the `java.util.Queue` interface (specifically, use `java.util.LinkedList` as the implementation) for managing the pending support requests.
 * *   Utilize the `java.util.List` interface (specifically, use `java.util.ArrayList` as the implementation) for storing the archived (resolved) requests.
 * *   Use `java.util.Scanner` to handle all user input from the console.
 * *   Implement the main menu selection logic using a `switch` statement.
 * *   Use `System.out` exclusively for displaying menu options, prompts, informational messages (e.g., "Request added"), and listing requests from the queue or archive.
 * *   Use `System.err` exclusively for displaying all error messages (e.g., invalid input, attempting to process an empty queue, unexpected errors).
 * *   Implement class-wide exception handling using `try-catch` blocks within the main application loop (`run` method or equivalent) to gracefully handle potential runtime issues, especially related to user input or unexpected system states.
 * *   Create a separate class, `SupportRequest`, to model a single support request. This class should encapsulate the request's unique ID, description, and status.
 * *   Apply best practices:
 *     *   Use private fields and public methods (`getters`, status update method) in `SupportRequest` for proper encapsulation.
 *     *   Use meaningful and descriptive names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation for user inputs (e.g., checking if menu choice is a valid number within the range, handling potentially empty request descriptions).
 *     *   Handle the specific case of attempting to process a request when the queue is empty.
 *     *   Ensure a clean and logical code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu. User interactions (adding, processing, viewing) should result in informative messages printed to `System.out`. Errors or invalid inputs should be reported to `System.err`. The format of displayed requests should be clear (e.g., showing ID, status, description).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Help Desk System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Current Queue
 * 4. View Archived Requests
 * 0. Exit
 * -----------------------------
 * Enter your choice: 1
 * Enter request description: My computer won't turn on
 * 
 * Request ID 1 added to the queue.
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Request Queue ---
 * 1. Request ID: 1 | Status: Open | Description: My computer won't turn on
 * -----------------------------
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processed and archived Request ID: 1
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Archived Requests ---
 * 1. Request ID: 1 | Status: Resolved | Description: My computer won't turn on
 * -------------------------
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: 2
 * No requests in the queue to process.
 * 
 * --- Help Desk System Menu ---
 * ...
 * Enter your choice: 0
 * 
 * Exiting Help Desk System. Goodbye!
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Correct usage of `System.out` and `System.err`.
 * *   Effective implementation of class-wide `try-catch` for robustness.
 * *   Proper encapsulation in the `SupportRequest` class.
 * *   Meaningful naming, comments, and code structure.
 * *   Correct implementation of all required functionalities.
 * *   Effective input validation and error handling (especially for empty queue and invalid input).
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for this Help Desk Support System. You may use a single file with multiple classes or separate files, as long as the code is complete and runnable. Include necessary imports.
 *
 * EXPLANATION:
 * This solution implements the Help Desk Support System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue` and `java.util.LinkedList`:** The `requestQueue` is declared as a `Queue<SupportRequest>` and instantiated as a `LinkedList`. This correctly models the FIFO requirement for pending requests. Methods like `offer()` (for adding) and `poll()` (for removing from the head) are used, which are standard `Queue` operations and safer than their `Collection` counterparts (`add`, `remove`) as they handle capacity restrictions or empty states gracefully (though `LinkedList` is unbounded).
 * 2.  **`java.util.List` and `java.util.ArrayList`:** The `archivedRequests` is declared as a `List<SupportRequest>` and instantiated as an `ArrayList`. `ArrayList` provides a dynamic array implementation, suitable for storing the processed requests in a list where order is maintained and elements can be accessed sequentially.
 * 3.  **`java.util.Scanner`:** The `scanner` object is used throughout the `run()` method to read user input for menu choices and request descriptions. Careful handling with `scanner.hasNextInt()` and `scanner.nextLine()` after `scanner.nextInt()` is implemented to avoid common `Scanner` pitfalls related to newline characters.
 * 4.  **`switch` statement:** The `switch` statement in the `run()` method is used to control the program flow based on the user's integer input for the menu selection, cleanly directing execution to the corresponding functionality.
 * 5.  **`System.out` vs. `System.err`:** `System.out.println()` is used for all standard output, including the menu, prompts, success messages, and displaying the contents of the queue and archive. `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, attempting to process an empty queue, or reporting caught exceptions.
 * 6.  **Class-wide Exception Handling with `try-catch`:** The main `run()` method's logic is wrapped in a `try-catch` block. This provides a central point for handling potential runtime errors that might occur during the execution of the application loop. Specific `catch` blocks for `InputMismatchException`, `NoSuchElementException`, and `IllegalStateException` handle common `Scanner`-related issues, while a general `catch (Exception e)` acts as a fallback for any other unexpected errors, reporting them to `System.err`. The `addRequest` method also includes a specific `catch` for `IllegalArgumentException` thrown by the `SupportRequest` constructor during validation. A `finally` block ensures the `Scanner` is closed.
 * 7.  **`SupportRequest` Class and Encapsulation:** A separate `SupportRequest` class is defined to model the data for a single request. Its fields (`id`, `description`, `status`) are declared `private`, and access is provided through `public` getter methods (`getId`, `getDescription`, `getStatus`) and a specific method (`markResolved`) to change the status. This demonstrates proper object-oriented encapsulation.
 * 8.  **Input Validation and Error Handling:**
 *     *   The `SupportRequest` constructor validates that the description is not empty using an `IllegalArgumentException`.
 *     *   The `run()` method checks if the scanner has an integer (`hasNextInt()`) before reading it to handle non-integer input gracefully. It also checks if the integer choice is within the valid range in the `default` case of the `switch`.
 *     *   The `processNextRequest()` method explicitly checks if the `requestQueue` is `isEmpty()` before attempting to `poll()`, preventing potential errors and providing a user-friendly message via `System.err`.
 * 9.  **Best Practices:** The code uses descriptive variable names (`requestQueue`, `archivedRequests`, `nextRequestId`), method names (`addRequest`, `processNextRequest`, `viewQueue`, `printMenu`), and includes Javadoc comments explaining the purpose of classes and methods. The code is structured logically into separate methods for distinct operations, making it readable and maintainable.
 * 
 * The solution effectively integrates the required Java components into a functional simulation, demonstrating understanding of collection types, input handling, control flow, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a support request in the help desk system.
 * Encapsulates request details: ID, description, and status.
 */
class SupportRequest {
    private int id;
    private String description;
    private String status; // e.g., "Open", "Resolved"

    private static final String STATUS_OPEN = "Open";
    private static final String STATUS_RESOLVED = "Resolved";

    /**
     * Constructs a new SupportRequest.
     *
     * @param id The unique identifier for the request.
     * @param description A description of the request.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public SupportRequest(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            // Using IllegalArgumentException for invalid constructor arguments
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = STATUS_OPEN; // Initially, the request is open
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the request's status as Resolved.
     */
    public void markResolved() {
        this.status = STATUS_RESOLVED;
    }

    /**
     * Provides a string representation of the SupportRequest.
     * @return Formatted string of the request details.
     */
    @Override
    public String toString() {
        return String.format("Request ID: %d | Status: %s | Description: %s",
                             id, status, description);
    }
}

/**
 * Manages the Help Desk System, including request queue and archive.
 * Handles user interaction via a command-line menu.
 */
public class HelpDeskSystem {

    // Queue to hold pending support requests (FIFO processing)
    private Queue<SupportRequest> requestQueue;
    // List to hold archived (resolved) support requests
    private List<SupportRequest> archivedRequests;
    // Counter for assigning unique request IDs
    private int nextRequestId;
    // Scanner for reading user input from the console
    private Scanner scanner;

    /**
     * Constructs a new HelpDeskSystem.
     * Initializes the queue, list, ID counter, and scanner.
     */
    public HelpDeskSystem() {
        // LinkedList implements Queue and provides efficient FIFO operations
        this.requestQueue = new LinkedList<>();
        // ArrayList implements List and is suitable for storing archived items
        this.archivedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start request IDs from 1
        this.scanner = new Scanner(System.in); // Initialize the scanner
    }

    /**
     * Adds a new support request to the pending queue.
     * Validates the description before creating the request.
     *
     * @param description The description provided by the user.
     */
    public void addRequest(String description) {
        try {
            // Create a new SupportRequest object
            SupportRequest newRequest = new SupportRequest(nextRequestId, description);
            // Add the new request to the end of the queue
            boolean added = requestQueue.offer(newRequest); // offer is safer than add
            if (added) {
                nextRequestId++; // Increment ID only if successfully added
                System.out.println("Request ID " + newRequest.getId() + " added to the queue.");
            } else {
                 // This case is rare with LinkedList but good practice with Queue interface
                 System.err.println("Failed to add request to the queue.");
            }
        } catch (IllegalArgumentException e) {
            // Catch validation error from SupportRequest constructor
            System.err.println("Error adding request: " + e.getMessage());
        }
    }

    /**
     * Processes the next support request from the queue.
     * Removes the request from the queue, marks it resolved, and adds it to the archive.
     */
    public void processNextRequest() {
        // Check if the queue is empty before attempting to process
        if (requestQueue.isEmpty()) {
            System.err.println("No requests in the queue to process.");
            return; // Exit the method
        }

        // Retrieve and remove the head of the queue (oldest request)
        // poll() returns null if the queue is empty, but we already checked isEmpty()
        SupportRequest requestToProcess = requestQueue.poll();

        if (requestToProcess != null) {
            // Mark the request as resolved
            requestToProcess.markResolved();
            // Add the resolved request to the archive list
            archivedRequests.add(requestToProcess);
            System.out.println("Processed and archived Request ID: " + requestToProcess.getId());
        } else {
             // Fallback error message, should not be reached if isEmpty() check works
             System.err.println("An internal error occurred while retrieving the next request.");
        }
    }

    /**
     * Displays all requests currently waiting in the pending queue.
     * Iterates through the queue without removing elements.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Request Queue ---");
        // Check if the queue is empty
        if (requestQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate and print each request in the queue
            int index = 1;
            for (SupportRequest request : requestQueue) {
                System.out.println(index++ + ". " + request);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays all requests stored in the archive list.
     * Iterates through the list.
     */
    public void viewArchive() {
        System.out.println("\n--- Archived Requests ---");
        // Check if the archive list is empty
        if (archivedRequests.isEmpty()) {
            System.out.println("The archive is empty.");
        } else {
            // Iterate and print each request in the archive list
            int index = 1;
            for (SupportRequest request : archivedRequests) {
                System.out.println(index++ + ". " + request);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("\n--- Help Desk System Menu ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Current Queue");
        System.out.println("4. View Archived Requests");
        System.out.println("0. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Runs the main application loop. Displays the menu, reads user input,
     * and calls the appropriate methods based on the user's choice.
     * Includes class-wide exception handling for robustness.
     */
    public void run() {
        int choice = -1; // Variable to store user's menu choice

        // Class-wide try-catch block to handle exceptions occurring within the main loop
        try {
            // Loop continues until the user chooses to exit (choice 0)
            while (choice != 0) {
                printMenu(); // Display the menu

                System.out.print("Enter your choice: ");

                // --- Input Validation for Menu Choice ---
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt(); // Read the integer input
                    scanner.nextLine(); // Consume the leftover newline character

                    // --- Switch Statement for Flow Control ---
                    switch (choice) {
                        case 1: // Add New Request
                            System.out.print("Enter request description: ");
                            String description = scanner.nextLine(); // Read the full description line
                            addRequest(description); // Call method to add request
                            break; // Exit switch case
                        case 2: // Process Next Request
                            processNextRequest(); // Call method to process request
                            break; // Exit switch case
                        case 3: // View Current Queue
                            viewQueue(); // Call method to view queue
                            break; // Exit switch case
                        case 4: // View Archived Requests
                            viewArchive(); // Call method to view archive
                            break; // Exit switch case
                        case 0: // Exit
                            System.out.println("Exiting Help Desk System. Goodbye!");
                            break; // Exit switch case and loop condition becomes false
                        default: // Handle choices outside the valid range (1-4, 0)
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                            break; // Exit switch case
                    }
                } else {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                System.out.println(); // Add a blank line for better readability between operations

            } // End of while loop (choice == 0)
        } catch (InputMismatchException e) {
            // Catches errors if nextInt() receives input that cannot be parsed as int
            // This is partially handled by hasNextInt(), but included for robustness.
            System.err.println("Severe input format error. Please restart the system.");
            // No need to consume line here, as the program is likely ending or in a bad state.
        } catch (NoSuchElementException e) {
             // Catches error if input stream is closed or empty unexpectedly
             System.err.println("Input stream exhausted. Cannot read further input.");
        } catch (IllegalStateException e) {
             // Catches error if scanner is used after being closed
             System.err.println("Scanner is closed. Cannot read further input.");
        } catch (Exception e) {
            // Generic catch-all for any other unexpected runtime exceptions
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging to see the stack trace
        } finally {
             // Ensure the scanner is closed when the program exits the try block
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * Main method to start the Help Desk System application.
     * Creates an instance of HelpDeskSystem and runs its main loop.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the system
        HelpDeskSystem system = new HelpDeskSystem();
        // Start the main application loop
        system.run();
    }
}
