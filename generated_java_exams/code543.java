/*
 * Exam Question #543
 * Generated on: 2025-05-11 23:27:12
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Automated Workflow Management System Simulator**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulator for an Automated Workflow Management System. This system processes "Tasks" in the order they are received. Completed tasks are moved to a history log. The system should be interactive, allowing a user to add new tasks, process the next task in the queue, view pending tasks, and view completed tasks.
 * 
 * Your solution must demonstrate proficiency in using various Java collections and control flow structures, along with proper error handling and user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields:
 *     *   `int id`: A unique identifier for the task.
 *     *   `String description`: A brief description of the task.
 *     *   `TaskStatus status`: An enum `TaskStatus` with values `PENDING` and `COMPLETED`.
 *     *   Include a constructor, public getter methods for all fields, and a method to set the status to `COMPLETED`. Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Workflow System Class:** Create a class (e.g., `WorkflowSystem`) that manages the tasks. This class must use:
 *     *   A `Queue<Task>` to hold tasks that are pending processing (FIFO).
 *     *   A `List<Task>` (specifically implemented as `ArrayList<Task>`) to store tasks that have been completed.
 *     *   A mechanism to generate unique task IDs (e.g., a simple counter).
 * 
 * 3.  **Core Functionality (Methods in WorkflowSystem):**
 *     *   `addTask(String description)`: Creates a new `Task` with status `PENDING` and adds it to the pending queue. Assigns a unique ID. Validate that the description is not empty.
 *     *   `processNextTask()`: Takes the task from the front of the pending queue, sets its status to `COMPLETED`, and adds it to the completed list. If the queue is empty, indicate an error.
 *     *   `viewPendingTasks()`: Displays all tasks currently in the pending queue.
 *     *   `viewCompletedTasks()`: Displays all tasks currently in the completed list.
 * 
 * 4.  **User Interface (in `main` method or a separate UI class/method):**
 *     *   Use `java.util.Scanner` to get user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task information, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty task description, trying to process when the queue is empty).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. Wrap the main application loop or critical operations within a `try` block to catch potential exceptions (e.g., input errors from `Scanner`) and handle them gracefully, printing an error message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (`private` fields, `public` methods where necessary).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes/methods).
 *     *   Perform input validation (e.g., non-empty task description, valid menu choice).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested operation, and print results or errors. Examples:
 * 
 * ```
 * --- Workflow System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * 
 * Task added: Task{id=1, description='Write report', status=PENDING}
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task{id=1, description='Write report', status=PENDING}
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processing task: Task{id=1, description='Write report', status=PENDING}
 * Task completed: Task{id=1, description='Write report', status=COMPLETED}
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task{id=1, description='Write report', status=COMPLETED}
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Workflow System Menu ---
 * ...
 * Enter your choice: 5
 * 
 * Exiting Workflow System.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accurate simulation of the task workflow (FIFO processing).
 * *   Proper encapsulation and code structure.
 * *   Effective input validation and error handling.
 * *   Clear and correct output formatting.
 * *   Meaningful variable names and comments.
 * 
 * **Note:** You should provide the complete, runnable Java code for the solution.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Automated Workflow Management System simulator, fulfilling all the requirements of the exam task.
 * 
 * **Core Components and Usage:**
 * 
 * 1.  **`Queue<Task> pendingTasks`**: A `java.util.Queue` is used via its common implementation, `java.util.LinkedList`. This collection stores `Task` objects that are waiting to be processed. The `addTask()` method uses `offer()` to add new tasks to the end of the queue (FIFO), and `processNextTask()` uses `poll()` to retrieve and remove the task from the front. `viewPendingTasks()` iterates through the queue using a for-each loop to display its contents without removing elements.
 * 
 * 2.  **`List<Task> completedTasks`**: A `java.util.List` is used via its common implementation, `java.util.ArrayList`. This collection stores `Task` objects once they have been processed. The `processNextTask()` method adds the completed task to this list using `add()`. `viewCompletedTasks()` iterates through the list using a for-each loop to display its contents.
 * 
 * 3.  **`Scanner scanner`**: An instance of `java.util.Scanner` is used in the `runApp()` method to read integer input for the menu choice and in `addTask()` to read the String input for the task description from `System.in`.
 * 
 * 4.  **`switch (choice)`**: A `switch` statement is used within the `runApp()` loop to control the program's flow based on the integer input received from the user via the `Scanner`. Each case corresponds to a menu option, calling the appropriate method of the `WorkflowSystem` class.
 * 
 * 5.  **`System.err`**: Used for displaying error messages. Examples include:
 *     *   Invalid menu choices (`default` case in `switch`).
 *     *   Empty task descriptions (input validation in `addTask()`).
 *     *   Attempting to process a task when the queue is empty (in `processNextTask()`).
 *     *   Handling `InputMismatchException` for non-integer input.
 *     *   Catching and reporting unexpected exceptions in the main `try-catch` block.
 * 
 * 6.  **`System.out`**: Used for normal program output, such as:
 *     *   Displaying the main menu (`displayMenu()`).
 *     *   Confirming task additions and completions.
 *     *   Displaying the contents of the pending and completed task lists.
 *     *   Printing the exit message.
 * 
 * 7.  **`try-catch` blocks**:
 *     *   A specific `try-catch(InputMismatchException e)` block is placed *inside* the `while` loop in `runApp()` around the `scanner.nextInt()` call. This handles the common case where the user enters non-integer input for the menu choice, prevents the program from crashing, prints an error to `System.err`, consumes the invalid input, and allows the loop to continue.
 *     *   A broader `try-catch(Exception e)` block is wrapped around the entire `while` loop within the `runApp()` method. This serves as the **class-wide exception handling** mechanism, catching any *other* unexpected runtime errors that might occur during the execution of any code within the loop (e.g., NullPointerException, IndexOutOfBoundsException, etc., although less likely with the current logic). It prints a generic error message and the exception details to `System.err`. The `finally` block ensures the `Scanner` is closed regardless of whether the loop finishes normally or an exception occurs.
 * 
 * **Best Practices and Structure:**
 * 
 * *   **Encapsulation:** The `Task` class has `private` fields with `public` getters and a specific method (`setCompleted()`) to modify the status. The `WorkflowSystem` class has `private` fields for its collections and counter, with `public` methods (`addTask`, `processNextTask`, etc.) providing the interface for interaction. The `displayMenu()` method is `private` as it's an internal helper.
 * *   **Meaningful Names:** Variable names like `pendingTasks`, `completedTasks`, `nextTaskId`, `description`, `status`, and method names like `addTask`, `processNextTask`, `viewPendingTasks` are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods, explaining their purpose, parameters, and return values. Inline comments explain specific logic where needed.
 * *   **Input Validation:** The `addTask()` method explicitly checks if the provided description is null or empty/whitespace using `trim().isEmpty()`. The `runApp()` method handles invalid integer input via `InputMismatchException` and invalid menu numbers via the `default` case in the `switch`.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for different failure conditions (empty queue, invalid input, empty description). The `try-catch` structure handles potential runtime errors.
 * *   **Clean Code:** The logic is separated into distinct methods (`addTask`, `processNextTask`, etc.), making the `runApp` method clean and focused on the main loop and menu dispatch. The `Task` class is separate, representing a single entity.
 * 
 * This solution effectively combines the required Java components in a practical scenario, demonstrating key concepts like collection usage (Queue for processing, List for history), control flow (`switch`, loops), user interaction (`Scanner`), and robust error handling (`try-catch`, `System.err`, input validation).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    COMPLETED
}

/**
 * Represents a single task in the workflow system.
 */
class Task {
    private final int id;
    private final String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task to COMPLETED.
     */
    public void setCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation including id, description, and status.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", status=" + status +
               '}';
    }
}

/**
 * Simulates an Automated Workflow Management System.
 * Manages pending tasks in a queue and completed tasks in a list.
 */
public class WorkflowSystem {

    private Queue<Task> pendingTasks; // Queue for FIFO processing
    private List<Task> completedTasks; // List to store completed tasks
    private int nextTaskId; // Counter for generating unique task IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new WorkflowSystem.
     * Initializes the task collections and the task ID counter.
     */
    public WorkflowSystem() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Workflow System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the pending queue.
     * Prompts the user for the task description.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if description is invalid
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("\nTask added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the pending queue to process.");
        } else {
            System.out.println("\nProcessing task: " + taskToProcess);
            taskToProcess.setCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task completed: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction and menu selection.
     * Includes class-wide exception handling.
     */
    public void runApp() {
        int choice = -1;

        // Class-wide exception handling for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    choice = scanner.nextInt(); // Read user choice
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue the loop
                    continue; // Skip the switch and go to the next iteration
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("\nExiting Workflow System.");
                        break;
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions during the application run
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits or an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Workflow System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WorkflowSystem system = new WorkflowSystem();
        system.runApp();
    }
}
