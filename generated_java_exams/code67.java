/*
 * Exam Question #67
 * Generated on: 2025-05-11 22:08:15
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Digital Asset Processing System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line application simulating a system for managing and processing digital assets. The system maintains a queue of assets waiting for processing and a list of assets that have been successfully processed. Users interact with the system via a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to hold tasks (assets) waiting to be processed. Tasks should be processed in a First-In, First-Out (FIFO) order.
 *     *   Use an `ArrayList` to store tasks that have completed processing.
 *     *   Declare the variable for the completed tasks list using the `List` interface type.
 * 
 * 2.  **Task Representation:**
 *     *   Create a class named `ProcessingTask` to represent a single asset processing request.
 *     *   This class must have private fields for:
 *         *   A unique task ID (integer).
 *         *   The asset name (String).
 *         *   The asset type (String, e.g., "Image", "Video", "Document").
 *         *   The processing status (e.g., "PENDING", "COMPLETED"). An `enum` is recommended for status.
 *     *   Implement a constructor to initialize a task with ID, name, type, and initial status.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public method to update the status (e.g., `markAsCompleted()`).
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task.
 * 
 * 3.  **Main Application Logic:**
 *     *   Create a main class (e.g., `AssetProcessingSystem`) containing the `main` method.
 *     *   Inside this class, manage the `Queue` of pending tasks and the `List` of completed tasks.
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Implement a main loop that presents a menu to the user with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement based on the user's menu choice to execute the corresponding action.
 *     *   Generate unique task IDs (e.g., using a simple counter starting from 1).
 * 
 * 4.  **Functionality Details:**
 *     *   **Add New Task:** Prompt the user for the asset name and type. Create a new `ProcessingTask` with a unique ID and "PENDING" status, and add it to the processing queue. Print a confirmation message to `System.out`.
 *     *   **Process Next Task:**
 *         *   Attempt to retrieve the next task from the queue using a method that returns `null` if the queue is empty (e.g., `poll()`).
 *         *   If a task is retrieved, update its status to "COMPLETED" using the task's method and add it to the completed tasks list. Print a success message to `System.out`.
 *         *   If the queue is empty, print an error message to `System.err`.
 *     *   **View Pending Tasks:** Iterate through the pending queue and print the details of each task using its `toString()` method. If the queue is empty, print a message to `System.out`.
 *     *   **View Completed Tasks:** Iterate through the completed list and print the details of each task using its `toString()` method. If the list is empty, print a message to `System.out`.
 *     *   **Exit:** Terminate the application.
 * 
 * 5.  **Error Handling and Input Validation:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically to catch potential `InputMismatchException` if the user enters non-integer input for the menu choice. Handle this gracefully by printing an error to `System.err` and consuming the invalid input.
 *     *   Handle the case where the user tries to process a task when the queue is empty (as described in requirement 4).
 *     *   Consider basic input validation for asset name/type (e.g., not empty strings), although this can be minimal for the exam scope.
 * 
 * 6.  **Best Practices:**
 *     *   Follow Java coding conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain logic.
 *     *   Apply encapsulation principles in the `ProcessingTask` class.
 *     *   Use `System.out` for normal output and `System.err` for error messages.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interaction might look like this:
 * 
 * ```
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter asset name: image1.jpg
 * Enter asset type: Image
 * Task 1 (image1.jpg - Image) added to queue.
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter asset name: video.mp4
 * Enter asset type: Video
 * Task 2 (video.mp4 - Video) added to queue.
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 1, Name: image1.jpg, Type: Image, Status: PENDING]
 * [ID: 2, Name: video.mp4, Type: Video, Status: PENDING]
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: [ID: 1, Name: image1.jpg, Type: Image, Status: COMPLETED]
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 2, Name: video.mp4, Type: Video, Status: PENDING]
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [ID: 1, Name: image1.jpg, Type: Image, Status: COMPLETED]
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * --- Asset Processing System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should implement the classes and logic described above, adhering to all requirements.
 *
 * EXPLANATION:
 * This solution implements the `AssetProcessingSystem` as required, demonstrating the use of all specified Java components and best practices.
 * 
 * 1.  **`ProcessingTask` Class:** This class encapsulates the data for a single task (`taskId`, `assetName`, `assetType`, `status`). It uses an `enum` (`TaskStatus`) for better type safety and readability of the status. Private fields and public getters/methods (`markAsCompleted`) ensure proper encapsulation. The `toString()` method provides a convenient way to display task details.
 * 
 * 2.  **`AssetProcessingSystem` Class:** This is the main application class.
 *     *   It holds the `pendingTasksQueue` (declared as `Queue<ProcessingTask>` and instantiated as `LinkedList`) and `completedTasksList` (declared as `List<ProcessingTask>` and instantiated as `ArrayList`), fulfilling the requirements for using both data structures and the `List` interface.
 *     *   A `Scanner` is used for reading user input.
 *     *   `nextTaskId` is a simple counter for unique IDs.
 *     *   The `run()` method contains the main application loop. It repeatedly displays the menu and processes user input.
 *     *   The `try-catch` block within the `run` loop handles `InputMismatchException`, which occurs if the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop. The `finally` block ensures that the newline character left by `nextInt()` is consumed, preventing issues with subsequent `scanner.nextLine()` calls. This demonstrates class-wide exception handling for input errors.
 *     *   The `switch` statement in `run()` directs the program flow based on the user's valid choice, calling the appropriate private methods (`addNewTask`, `processNextTask`, etc.).
 *     *   `addNewTask()` takes user input, creates a `ProcessingTask`, and adds it to the `pendingTasksQueue` using `offer()` (a standard Queue method that is generally preferred over `add()` as it handles capacity-constrained queues more gracefully, though `LinkedList` is not capacity-constrained).
 *     *   `processNextTask()` uses `pendingTasksQueue.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, which is checked to print an error to `System.err`. If a task is retrieved, its status is updated, and it's added to the `completedTasksList`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()` iterate through their respective collections to print task details. They check for emptiness and print appropriate messages to `System.out`.
 *     *   `System.out` is used for all normal output (menu, confirmations, task lists).
 *     *   `System.err` is specifically used for error messages (invalid input type, invalid menu choice, trying to process an empty queue).
 *     *   The `scanner` is closed when the application exits.
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrates handling different states (pending/completed tasks), manages input with validation and error handling using `try-catch` and `System.err`, and follows good object-oriented principles like encapsulation.
 */

import java.util.LinkedList; // LinkedList implements Queue
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the processing status of a task
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Class to represent a single processing task
class ProcessingTask {
    private int taskId;
    private String assetName;
    private String assetType;
    private TaskStatus status;

    /**
     * Constructs a new ProcessingTask.
     * @param taskId The unique identifier for the task.
     * @param assetName The name of the asset.
     * @param assetType The type of the asset.
     */
    public ProcessingTask(int taskId, String assetName, String assetType) {
        this.taskId = taskId;
        this.assetName = assetName;
        this.assetType = assetType;
        this.status = TaskStatus.PENDING; // Default status is PENDING
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getAssetName() {
        return assetName;
    }

    public String getAssetType() {
        return assetType;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Updates the task status to COMPLETED.
     */
    public void markAsCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return String.format("[ID: %d, Name: %s, Type: %s, Status: %s]",
                taskId, assetName, assetType, status);
    }
}

// Main class for the Asset Processing System
public class AssetProcessingSystem {

    // Queue for tasks waiting to be processed (FIFO)
    private Queue<ProcessingTask> pendingTasksQueue;
    // List for tasks that have been completed
    private List<ProcessingTask> completedTasksList;
    // Scanner for user input
    private Scanner scanner;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs the AssetProcessingSystem.
     */
    public AssetProcessingSystem() {
        // Using LinkedList as it implements the Queue interface
        this.pendingTasksQueue = new LinkedList<>();
        // Using ArrayList as it implements the List interface
        this.completedTasksList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Asset Processing System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the pending queue based on user input.
     */
    private void addNewTask() {
        System.out.print("Enter asset name: ");
        String name = scanner.nextLine();
        System.out.print("Enter asset type: ");
        String type = scanner.nextLine();

        // Simple input validation
        if (name.trim().isEmpty() || type.trim().isEmpty()) {
            System.err.println("Asset name and type cannot be empty.");
            return;
        }

        ProcessingTask newTask = new ProcessingTask(nextTaskId++, name, type);
        pendingTasksQueue.offer(newTask); // offer is preferred over add in queues
        System.out.println("Task " + newTask.getTaskId() + " (" + name + " - " + type + ") added to queue.");
    }

    /**
     * Processes the next task in the pending queue.
     */
    private void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if empty
        ProcessingTask taskToProcess = pendingTasksQueue.poll();

        if (taskToProcess != null) {
            taskToProcess.markAsCompleted();
            completedTasksList.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
        } else {
            // Using System.err for error condition
            System.err.println("No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (ProcessingTask task : pendingTasksQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasksList.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (ProcessingTask task : completedTasksList) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            // Class-wide exception handling for input
            try {
                choice = scanner.nextInt();
            } catch (InputMismatchException e) {
                // Using System.err for error message
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the switch and show menu again
            } finally {
                 // Consume the newline character left by nextInt()
                 // This is crucial before calling nextLine() in addNewTask()
                 if (scanner.hasNextLine()) {
                     scanner.nextLine();
                 }
            }


            // Switch statement for flow control based on user choice
            switch (choice) {
                case 1:
                    addNewTask();
                    break;
                case 2:
                    processNextTask();
                    break;
                case 3:
                    viewPendingTasks();
                    break;
                case 4:
                    viewCompletedTasks();
                    break;
                case 5:
                    running = false; // Set flag to exit loop
                    System.out.println("Exiting system.");
                    break;
                default:
                    // Using System.err for invalid choice error
                    System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssetProcessingSystem system = new AssetProcessingSystem();
        system.run();
    }
}
