/*
 * Exam Question #422
 * Generated on: 2025-05-11 23:08:49
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Banking Transaction Processor
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified banking system that processes transactions in the order they are received. The system should manage multiple bank accounts and handle deposit and withdrawal requests submitted by users. Transactions are placed in a queue and processed one by one upon command.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the `Account` class:**
 *     *   Must have private fields for `accountNumber` (int) and `balance` (double).
 *     *   Provide a constructor to initialize `accountNumber` and `initialBalance`.
 *     *   Implement public methods `deposit(double amount)` and `withdraw(double amount)`.
 *     *   `deposit` should add the amount to the balance. Validate that the deposit amount is positive.
 *     *   `withdraw` should subtract the amount from the balance. Validate that the withdrawal amount is positive and that there are sufficient funds. If funds are insufficient, throw a custom exception `InsufficientFundsException`.
 *     *   Provide a public getter for `balance` (`getBalance()`) and `accountNumber` (`getAccountNumber()`).
 *     *   Ensure proper encapsulation.
 * 
 * 2.  **Implement Custom Exceptions:**
 *     *   Create a custom checked exception `InsufficientFundsException`.
 *     *   Create a custom checked exception `AccountNotFoundException`.
 * 
 * 3.  **Implement the `Transaction` class:**
 *     *   Must have private fields for `type` (enum, e.g., `DEPOSIT`, `WITHDRAW`), `accountNumber` (int), and `amount` (double).
 *     *   Provide a constructor to initialize these fields.
 *     *   Provide public getters for all fields.
 * 
 * 4.  **Implement the `BankingSystem` class:**
 *     *   Must have a private field to store accounts using `java.util.List` (specifically, use `java.util.ArrayList` for instantiation).
 *     *   Must have a private field to store pending transactions using `java.util.Queue`.
 *     *   Provide a constructor to initialize the account list and transaction queue (use `java.util.LinkedList` as the `Queue` implementation).
 *     *   Implement `addAccount(int accountNumber, double initialBalance)`: Adds a new `Account` to the list. Validate that the account number is positive and initial balance is non-negative.
 *     *   Implement `addTransaction(Transaction transaction)`: Adds a `Transaction` to the queue.
 *     *   Implement `processNextTransaction()`:
 *         *   Retrieves and removes the next `Transaction` from the queue.
 *         *   If the queue is empty, print a message and return.
 *         *   Find the corresponding `Account` in the list. If not found, throw `AccountNotFoundException`.
 *         *   Use a `switch` statement based on the `Transaction` type (`DEPOSIT` or `WITHDRAW`).
 *         *   Call the appropriate method (`deposit` or `withdraw`) on the `Account` object.
 *         *   Handle `InsufficientFundsException` thrown by `withdraw` *within* this method, printing an error message using `System.err` and indicating the transaction failed. Do NOT re-throw it.
 *         *   For successful transactions, print a success message using `System.out`.
 *     *   Implement `displayAccountBalance(int accountNumber)`: Finds the account and prints its balance using `System.out`. Throws `AccountNotFoundException` if the account is not found.
 *     *   Include a helper method `findAccount(int accountNumber)` that returns the `Account` object or `null` if not found.
 * 
 * 5.  **Implement the main application class (`BankingApp`):**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Create an instance of `BankingSystem`.
 *     *   Implement a menu-driven interface allowing the user to:
 *         1.  Add a new Account
 *         2.  Add a new Transaction (Deposit or Withdraw)
 *         3.  Process Next Transaction
 *         4.  View Account Balance
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices, account numbers, and amounts. Use `System.err` for invalid input messages.
 *     *   Wrap the main command processing loop in a `try-catch` block to demonstrate class-wide exception handling. This block should catch any `AccountNotFoundException` propagated from `BankingSystem` methods and any unexpected `RuntimeException` (like `NumberFormatException` if input validation fails to catch it early enough). Print appropriate error messages using `System.err`.
 *     *   Use `System.out` for menu display, prompts, and successful output.
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Required Components Checklist (Must Use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling with `try-catch` blocks
 * 
 * **Expected Output Format:**
 * 
 * The program should display a menu, prompt the user for input, and print output or error messages based on the operations.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Banking System Menu:
 * 1. Add Account
 * 2. Add Transaction
 * 3. Process Next Transaction
 * 4. View Account Balance
 * 5. Exit
 * Enter your choice: 1
 * Enter account number: 101
 * Enter initial balance: 500.0
 * Account 101 created with balance 500.0
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 2
 * Enter transaction type (DEPOSIT/WITHDRAW): DEPOSIT
 * Enter account number: 101
 * Enter amount: 100.0
 * Transaction added to queue.
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 3
 * Processing transaction for account 101: DEPOSIT 100.0
 * Deposit successful for account 101. New balance: 600.0
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 4
 * Enter account number: 101
 * Account 101 balance: 600.0
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 2
 * Enter transaction type (DEPOSIT/WITHDRAW): WITHDRAW
 * Enter account number: 101
 * Enter amount: 700.0
 * Transaction added to queue.
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 3
 * Processing transaction for account 101: WITHDRAW 700.0
 * Error: Insufficient funds for account 101. Withdrawal of 700.0 failed. Current balance: 600.0
 * 
 * Banking System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Banking System.
 * ```
 * 
 * **Note:** Pay close attention to input validation, error handling, and the correct usage of the required Java components.
 *
 * EXPLANATION:
 * This solution implements a basic banking transaction processing system, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`Account` Class:** Encapsulates account data (`accountNumber`, `balance`) and business logic (`deposit`, `withdraw`). It includes input validation (positive amounts) and throws a custom `InsufficientFundsException` on withdrawal failure, adhering to best practices for representing domain-specific errors.
 * 
 * 2.  **Custom Exceptions (`InsufficientFundsException`, `AccountNotFoundException`):** These checked exceptions signal specific error conditions within the banking logic. Using custom exceptions makes the code more readable and allows for more specific error handling by the caller.
 * 
 * 3.  **`Transaction` Class:** A simple class to hold the details of a transaction request (`type`, `accountNumber`, `amount`). Using an `enum` for `Type` provides type safety and clarity.
 * 
 * 4.  **`BankingSystem` Class:** This is the core class managing the system's state and operations.
 *     *   It uses `java.util.List<Account>` instantiated as `ArrayList` to store accounts, allowing efficient access and storage. The `List` interface is used for the field type, promoting good design.
 *     *   It uses `java.util.Queue<Transaction>` instantiated as `LinkedList` to store transactions. The `Queue` interface ensures transactions are processed in a First-In, First-Out (FIFO) manner, simulating a real-world processing queue. `offer` is used to add to the queue, and `poll` is used to retrieve and remove from the head.
 *     *   `addAccount` and `addTransaction` methods handle adding data to the respective collections.
 *     *   `processNextTransaction` is the key method demonstrating queue usage and transaction logic. It retrieves a transaction using `poll()`, finds the account using `findAccount()`, and uses a `switch` statement on the `Transaction.Type` to perform the correct operation (`deposit` or `withdraw`). It specifically catches `InsufficientFundsException` thrown by `Account.withdraw` and prints an error message using `System.err`, preventing the transaction from halting the entire system but clearly indicating its failure. `AccountNotFoundException` is thrown if the account does not exist for the transaction.
 *     *   `findAccount` is a helper method demonstrating searching within the `List`.
 *     *   `displayAccountBalance` demonstrates accessing account data and also throws `AccountNotFoundException`.
 * 
 * 5.  **`BankingApp` Class (Main Application):**
 *     *   This class provides the user interface using `java.util.Scanner` for console input.
 *     *   A menu is displayed, and a `switch` statement processes the user's integer choice.
 *     *   Input validation is performed using `try-catch (NumberFormatException)` when parsing integer or double inputs. If input is invalid, an error is printed to `System.err`, and the loop continues.
 *     *   Each menu option calls the appropriate method(s) on the `BankingSystem` instance.
 *     *   A large `try-catch` block wraps the main `while(true)` loop. This fulfills the "class-wide exception handling" requirement by providing a top-level handler for exceptions that might propagate up from the `BankingSystem` methods (like `AccountNotFoundException` or potentially `IllegalArgumentException` if not fully handled lower down, though some are handled within the `switch` cases for better specificity). Any uncaught `RuntimeException` would also be caught here, providing a safety net and printing an error message to `System.err`.
 *     *   `System.out` is used for the menu, prompts, and successful operation messages.
 *     *   `System.err` is used exclusively for error messages (invalid input, account not found, unexpected system errors).
 *     *   A `finally` block ensures the `Scanner` resource is closed properly before the program exits.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (via `List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, object-oriented structure, demonstrating encapsulation, validation, and error handling as requested.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Custom Exception for insufficient funds
class InsufficientFundsException extends Exception {
    public InsufficientFundsException(String message) {
        super(message);
    }
}

// Custom Exception for account not found
class AccountNotFoundException extends Exception {
    public AccountNotFoundException(String message) {
        super(message);
    }
}

// Represents a bank account
class Account {
    private int accountNumber;
    private double balance;

    /**
     * Constructs a new Account.
     * @param accountNumber The unique account number.
     * @param initialBalance The initial balance for the account.
     * @throws IllegalArgumentException if account number is not positive or initial balance is negative.
     */
    public Account(int accountNumber, double initialBalance) {
        if (accountNumber <= 0) {
            throw new IllegalArgumentException("Account number must be positive.");
        }
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative.");
        }
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public int getAccountNumber() {
        return accountNumber;
    }

    public double getBalance() {
        return balance;
    }

    /**
     * Deposits a positive amount into the account.
     * @param amount The amount to deposit.
     * @throws IllegalArgumentException if the amount is not positive.
     */
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive.");
        }
        this.balance += amount;
    }

    /**
     * Withdraws a positive amount from the account, if sufficient funds are available.
     * @param amount The amount to withdraw.
     * @throws IllegalArgumentException if the amount is not positive.
     * @throws InsufficientFundsException if the balance is less than the withdrawal amount.
     */
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive.");
        }
        if (this.balance < amount) {
            throw new InsufficientFundsException("Insufficient funds for withdrawal.");
        }
        this.balance -= amount;
    }

    @Override
    public String toString() {
        return "Account{" +
               "accountNumber=" + accountNumber +
               ", balance=" + balance +
               '}';
    }
}

// Represents a transaction request
class Transaction {
    public enum Type {
        DEPOSIT, WITHDRAW
    }

    private Type type;
    private int accountNumber;
    private double amount;

    /**
     * Constructs a new Transaction.
     * @param type The type of transaction (DEPOSIT or WITHDRAW).
     * @param accountNumber The account number the transaction applies to.
     * @param amount The transaction amount.
     */
    public Transaction(Type type, int accountNumber, double amount) {
        this.type = type;
        this.accountNumber = accountNumber;
        this.amount = amount;
    }

    public Type getType() {
        return type;
    }

    public int getAccountNumber() {
        return accountNumber;
    }

    public double getAmount() {
        return amount;
    }

    @Override
    public String toString() {
        return type + " [Account: " + accountNumber + ", Amount: " + amount + "]";
    }
}

// Manages accounts and processes transactions
class BankingSystem {
    // Using List interface, instantiated with ArrayList
    private List<Account> accounts;
    // Using Queue interface, instantiated with LinkedList
    private Queue<Transaction> transactionQueue;

    /**
     * Constructs a new BankingSystem.
     */
    public BankingSystem() {
        this.accounts = new ArrayList<>();
        this.transactionQueue = new LinkedList<>();
    }

    /**
     * Adds a new account to the system.
     * @param accountNumber The account number.
     * @param initialBalance The initial balance.
     * @throws IllegalArgumentException if inputs are invalid or account number already exists.
     */
    public void addAccount(int accountNumber, double initialBalance) {
        // Validation is also in Account constructor, but check for duplicates here
        if (accountNumber <= 0) {
             throw new IllegalArgumentException("Account number must be positive.");
        }
         if (initialBalance < 0) {
             throw new IllegalArgumentException("Initial balance cannot be negative.");
        }
        if (findAccount(accountNumber) != null) {
            throw new IllegalArgumentException("Account number " + accountNumber + " already exists.");
        }
        Account newAccount = new Account(accountNumber, initialBalance); // Account constructor validates again
        accounts.add(newAccount);
        System.out.println("Account " + accountNumber + " created with balance " + initialBalance);
    }

    /**
     * Adds a transaction to the processing queue.
     * @param transaction The transaction to add.
     */
    public void addTransaction(Transaction transaction) {
        transactionQueue.offer(transaction); // offer is standard for Queue insertion
        System.out.println("Transaction added to queue: " + transaction);
    }

    /**
     * Processes the next transaction in the queue.
     * Handles InsufficientFundsException internally. Throws AccountNotFoundException.
     * Note: IllegalArgumentException from Account methods would propagate up to the main try-catch
     * if not caught here. For this example, we let IllegalArgumentException propagate.
     * @throws AccountNotFoundException if the account for the transaction is not found.
     */
    public void processNextTransaction() throws AccountNotFoundException {
        Transaction transaction = transactionQueue.poll(); // poll retrieves and removes the head

        if (transaction == null) {
            System.out.println("No pending transactions in the queue.");
            return;
        }

        System.out.println("Processing transaction: " + transaction);

        Account account = findAccount(transaction.getAccountNumber());

        if (account == null) {
            throw new AccountNotFoundException("Account " + transaction.getAccountNumber() + " not found.");
        }

        try {
            switch (transaction.getType()) {
                case DEPOSIT:
                    account.deposit(transaction.getAmount());
                    System.out.println("Deposit successful for account " + account.getAccountNumber() + ". New balance: " + account.getBalance());
                    break;
                case WITHDRAW:
                    account.withdraw(transaction.getAmount()); // This might throw InsufficientFundsException
                    System.out.println("Withdrawal successful for account " + account.getAccountNumber() + ". New balance: " + account.getBalance());
                    break;
                default:
                    // This case should ideally not be reached with the current enum
                    System.err.println("Unknown transaction type: " + transaction.getType());
            }
        } catch (InsufficientFundsException e) {
            // Handle InsufficientFundsException specifically within this processing method
            System.err.println("Error: " + e.getMessage() + " for account " + account.getAccountNumber() + ". Withdrawal of " + transaction.getAmount() + " failed. Current balance: " + account.getBalance());
        }
        // Note: IllegalArgumentException from deposit/withdraw (e.g., negative amount)
        // is allowed to propagate to the main try-catch for simplicity in this example.
    }

    /**
     * Finds an account by its account number.
     * @param accountNumber The account number to search for.
     * @return The Account object if found, otherwise null.
     */
    public Account findAccount(int accountNumber) {
        for (Account account : accounts) {
            if (account.getAccountNumber() == accountNumber) {
                return account;
            }
        }
        return null; // Account not found
    }

    /**
     * Displays the balance of a specific account.
     * @param accountNumber The account number.
     * @throws AccountNotFoundException if the account is not found.
     */
    public void displayAccountBalance(int accountNumber) throws AccountNotFoundException {
        Account account = findAccount(accountNumber);
        if (account == null) {
            throw new AccountNotFoundException("Account " + accountNumber + " not found.");
        }
        System.out.println("Account " + account.getAccountNumber() + " balance: " + account.getBalance());
    }
}

// Main application class
public class BankingApp {

    private static void printMenu() {
        System.out.println("\nBanking System Menu:");
        System.out.println("1. Add Account");
        System.out.println("2. Add Transaction");
        System.out.println("3. Process Next Transaction");
        System.out.println("4. View Account Balance");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        BankingSystem system = new BankingSystem();
        Scanner scanner = new Scanner(System.in);

        // Class-wide exception handling wrapping the main application loop
        try {
            while (true) {
                printMenu();

                int choice;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to next loop iteration
                }

                // Use switch statement for menu options
                switch (choice) {
                    case 1: // Add Account
                        try {
                            System.out.print("Enter account number: ");
                            int accNumber = Integer.parseInt(scanner.nextLine());
                            System.out.print("Enter initial balance: ");
                            double initialBalance = Double.parseDouble(scanner.nextLine());
                            system.addAccount(accNumber, initialBalance);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid number format. Please enter valid numbers for account number and balance.");
                        } catch (IllegalArgumentException e) {
                             System.err.println("Error adding account: " + e.getMessage());
                        }
                        break;

                    case 2: // Add Transaction
                        try {
                            System.out.print("Enter transaction type (DEPOSIT/WITHDRAW): ");
                            String typeStr = scanner.nextLine().trim().toUpperCase();
                            Transaction.Type type;
                            try {
                                type = Transaction.Type.valueOf(typeStr);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Invalid transaction type. Use DEPOSIT or WITHDRAW.");
                                break; // Exit case 2
                            }

                            System.out.print("Enter account number: ");
                            int transAccNumber = Integer.parseInt(scanner.nextLine());
                            System.out.print("Enter amount: ");
                            double amount = Double.parseDouble(scanner.nextLine());

                            if (amount <= 0) {
                                System.err.println("Transaction amount must be positive.");
                                break; // Exit case 2
                            }

                            Transaction transaction = new Transaction(type, transAccNumber, amount);
                            system.addTransaction(transaction);

                        } catch (NumberFormatException e) {
                            System.err.println("Invalid number format. Please enter valid numbers for account number and amount.");
                        }
                        break;

                    case 3: // Process Next Transaction
                        try {
                            system.processNextTransaction(); // This method handles InsufficientFundsException internally
                        } catch (AccountNotFoundException e) {
                             // Catch AccountNotFoundException propagated from processNextTransaction
                             System.err.println("Transaction processing failed: " + e.getMessage());
                        } catch (IllegalArgumentException e) {
                            // Catch IllegalArgumentException from Account methods (e.g., negative amount passed incorrectly)
                            System.err.println("Transaction processing failed due to invalid data: " + e.getMessage());
                        }
                        break;

                    case 4: // View Account Balance
                        try {
                            System.out.print("Enter account number: ");
                            int viewAccNumber = Integer.parseInt(scanner.nextLine());
                            system.displayAccountBalance(viewAccNumber);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid number format. Please enter a valid account number.");
                        } catch (AccountNotFoundException e) {
                            // Catch AccountNotFoundException propagated from displayAccountBalance
                            System.err.println("Error viewing balance: " + e.getMessage());
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Banking System.");
                        return; // Exit the main method

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Top-level catch for any unexpected errors not handled elsewhere
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure scanner is closed regardless of exceptions
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
