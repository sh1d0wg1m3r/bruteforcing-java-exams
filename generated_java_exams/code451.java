/*
 * Exam Question #451
 * Generated on: 2025-05-11 23:13:02
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Exam Task: Advanced Task Management System**
 * 
 * Design and implement a simple command-line based Task Management System in Java. The system should allow users to add tasks to a pending queue, process the next task from the queue, and view both pending and completed tasks.
 * 
 * Your solution must demonstrate advanced understanding of Java collections, control flow, user input handling, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple class `Task` to represent a task. It should contain at least a `description` (String).
 * 2.  **Task Processing Logic:** Create a class `TaskProcessor` that manages the tasks. It must internally use:
 *     *   A `java.util.Queue` (specifically `java.util.LinkedList` which implements `Queue`) to store pending tasks in FIFO order.
 *     *   A `java.util.List` (specifically `java.util.ArrayList` which implements `List`) to store completed tasks.
 * 3.  **Functionality:** The `TaskProcessor` class must provide the following public methods:
 *     *   `addTask(String description)`: Adds a new task to the pending queue. Should validate that the description is not empty or null.
 *     *   `processNextTask()`: Removes the next task from the pending queue and adds it to the completed list. Should handle the case where the pending queue is empty.
 *     *   `getPendingTasks()`: Returns a `List` of all tasks currently in the pending queue.
 *     *   `getCompletedTasks()`: Returns a `List` of all tasks currently in the completed list.
 * 4.  **User Interface:** Implement a command-line interface in a `main` method within a separate class (e.g., `TaskManagementApp`). This interface should:
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options (e.g., Add Task, Process Task, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Display normal output and prompts using `System.out`.
 *     *   Display error messages using `System.err`.
 * 5.  **Error Handling:** Implement robust error handling:
 *     *   Use `try-catch` blocks for class-wide exception handling, particularly around user input reading and operations that might fail (like processing an empty queue).
 *     *   Validate user input (e.g., menu choices, task descriptions).
 *     *   Handle cases where the pending queue or completed list is empty when viewing or processing.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc and inline) to explain the code.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Examples of interactions:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: Buy groceries
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task added: Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Buy groceries
 * 2. Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Buy groceries
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Buy groceries
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Pay bills
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * System.err: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: five
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be provided as a single file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** A basic class with a `description` field, a constructor, a getter, and an overridden `toString()` method for easy printing. It includes a basic null/empty check in the constructor, though the primary validation is done in `TaskProcessor`.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   **Encapsulation:** It holds the `pendingTasks` (a `Queue`) and `completedTasks` (a `List`) as private fields.
 *     *   **Queue Usage:** `pendingTasks` is declared as `Queue<Task>` and initialized as `new LinkedList<>()`. `LinkedList` implements `Queue` and is suitable for adding (`offer`) and removing (`poll`) elements efficiently from the ends, which is exactly what's needed for a task queue (FIFO).
 *     *   **List/ArrayList Usage:** `completedTasks` is declared as `List<Task>` and initialized as `new ArrayList<>()`. `ArrayList` is suitable for storing completed tasks where iteration and potentially random access (though not strictly needed here) are common operations.
 *     *   **`addTask` Method:** Takes a description, validates it, creates a `Task` object, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask` Method:** Removes the head of the `pendingTasks` queue using `poll()`. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling of this case without throwing an exception. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   **`getPendingTasks` and `getCompletedTasks` Methods:** These methods provide access to the task lists. `getPendingTasks` creates a new `ArrayList` from the queue elements to return a snapshot, which is good practice to avoid external modification of the internal queue state. `getCompletedTasks` returns the internal `ArrayList` directly for simplicity in this exam context.
 * 
 * 3.  **`TaskManagementApp` Class (Main Application):**
 *     *   **`main` Method:** This is the entry point and contains the main application loop.
 *     *   **`Scanner`:** An instance of `Scanner` is used to read user input from `System.in`. It's declared as `static` and closed in a `finally` block to ensure resource cleanup.
 *     *   **User Interface Loop:** A `while (running)` loop keeps the application active until the user chooses to exit.
 *     *   **Menu Display:** The `displayMenu` helper method prints the options using `System.out`.
 *     *   **Input Reading and `try-catch`:** The core loop uses a `try-catch` block specifically for reading the menu choice.
 *         *   It attempts to read an integer using `scanner.nextInt()`.
 *         *   If the input is not an integer (`InputMismatchException`), the `catch` block is executed. An error message is printed to `System.err`, `scanner.next()` consumes the invalid token to prevent an infinite loop, and `continue` restarts the `while` loop, redisplaying the menu.
 *         *   A `finally` block ensures that `scanner.nextLine()` is called after `scanner.nextInt()` to consume the newline character left in the buffer, preventing issues when reading the task description string later.
 *     *   **`switch` Statement:** Handles the valid integer choice read from the user. Each case corresponds to a menu option, calling the appropriate method on the `taskProcessor` instance.
 *         *   Case 1 (`Add New Task`): Prompts for description, reads the line using `scanner.nextLine()`, and calls `taskProcessor.addTask()`. This call is wrapped in another `try-catch` to specifically handle the `IllegalArgumentException` thrown by `addTask` if the description is empty.
 *         *   Case 2 (`Process Next Task`): Calls `taskProcessor.processNextTask()`. The handling for an empty queue is done *within* the `processNextTask` method itself by checking the return value of `poll()`.
 *         *   Case 3 (`View Pending Tasks`): Calls `taskProcessor.getPendingTasks()`, gets the list, and iterates through it using a `for` loop, printing each task's description. It checks if the list is empty first. `System.out` is used for normal output.
 *         *   Case 4 (`View Completed Tasks`): Similar to Case 3, but uses `taskProcessor.getCompletedTasks()`.
 *         *   Case 5 (`Exit`): Sets `running` to `false` to terminate the loop.
 *         *   `default`: Handles any integer input outside the 1-5 range, printing an error to `System.err`.
 *     *   **Outer `try-catch`:** A broader `try-catch` block wraps the entire `while` loop. This serves as a class-wide handler for any *unexpected* exceptions that might occur elsewhere in the loop's execution, printing an error to `System.err` and the stack trace.
 *     *   **`finally` Block:** Ensures `scanner.close()` is called when the application finishes, releasing system resources.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating proper object-oriented design (encapsulation), input validation, and robust error handling, making it a challenging yet solvable exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            // In a real app, might throw IllegalArgumentException or handle differently
            // For this exam, we'll rely on validation in TaskProcessor or App.
            this.description = "Unnamed Task"; // Fallback, though App validates
        } else {
            this.description = description.trim();
        }
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return The task description.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages pending and completed tasks using a Queue and a List.
 */
class TaskProcessor {
    // Use LinkedList as it implements Queue and is efficient for adding/removing from ends
    private Queue<Task> pendingTasks;
    // Use ArrayList for completed tasks as random access and iteration are common
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessor, initializing task collections.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description);
        pendingTasks.offer(newTask); // offer is preferred over add for capacity-constrained queues (though LinkedList is not)
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the pending queue, moving it to the completed list.
     *
     * @return The task that was processed, or null if no pending tasks.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask.getDescription());
        } else {
            System.err.println("No pending tasks to process.");
        }
        return nextTask;
    }

    /**
     * Gets a list of all pending tasks.
     *
     * @return A List containing the pending tasks. Returns an empty list if none are pending.
     */
    public List<Task> getPendingTasks() {
        // Returning a new ArrayList prevents external modification of the internal queue,
        // but for simplicity in an exam, returning the underlying list from LinkedList's
        // iterator or just iterating over the queue elements is sufficient.
        // Let's collect into a new list for a cleaner snapshot.
        return new ArrayList<>(pendingTasks); // Creates a snapshot list from the queue elements
    }

    /**
     * Gets a list of all completed tasks.
     *
     * @return A List containing the completed tasks. Returns an empty list if none are completed.
     */
    public List<Task> getCompletedTasks() {
        // Returning the internal list directly is okay if external modification isn't a concern,
        // or return an unmodifiable list: Collections.unmodifiableList(completedTasks);
        // For an exam, returning the list is usually acceptable.
        return completedTasks;
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interface, input, and delegates tasks to TaskProcessor.
 */
public class TaskManagementApp {

    private static TaskProcessor taskProcessor = new TaskProcessor();
    private static Scanner scanner = new Scanner(System.in);

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Task Management Application.
     * Handles the user interaction loop and delegates actions.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;

                try {
                    // Attempt to read integer input
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    // Consume the rest of the line after reading the integer
                    // This is important to prevent issues with reading strings later
                    scanner.nextLine();
                }

                // Use a switch statement to handle the valid integer choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            taskProcessor.addTask(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;
                    case 2:
                        taskProcessor.processNextTask();
                        break;
                    case 3:
                        List<Task> pending = taskProcessor.getPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (int i = 0; i < pending.size(); i++) {
                                System.out.println((i + 1) + ". " + pending.get(i).getDescription());
                            }
                        }
                        break;
                    case 4:
                        List<Task> completed = taskProcessor.getCompletedTasks();
                        System.out.println("--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (int i = 0; i < completed.size(); i++) {
                                System.out.println((i + 1) + ". " + completed.get(i).getDescription());
                            }
                        }
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Handle choices outside the valid range 1-5
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that weren't handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
