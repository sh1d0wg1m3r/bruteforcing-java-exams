/*
 * Exam Question #1058
 * Generated on: 2025-05-12 17:19:11
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Manufacturing Plant Resource Allocation System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for managing tasks and allocating them to available resources in a manufacturing plant. Tasks arrive and are placed in a waiting queue. Resources become available and are assigned tasks from the queue. The system needs to handle incoming tasks, manage a pool of available resources, allocate tasks when both tasks and resources are ready, and provide status updates.
 * 
 * **Your Task:**
 * Implement a Java program that simulates this system. The program should provide a command-line interface for users (plant operators) to interact with the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple `Task` class with fields for a unique task ID (integer) and a description (String).
 * 2.  **Resource Representation:** Represent resources simply by their unique names or IDs (String).
 * 3.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks waiting for allocation. Tasks should be processed in a FIFO manner from this queue.
 *     *   Use a `java.util.ArrayList` to store the IDs of resources that are currently available. Use the `java.util.List` interface as the declared type for this collection.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         *   `add_task`: Prompt for a task description and add a new task to the waiting queue. Assign a unique, sequential ID starting from 1.
 *         *   `add_resource`: Prompt for a resource ID (String) and add it to the list of available resources.
 *         *   `allocate`: Attempt to allocate the next waiting task to an available resource. If successful, remove the task from the queue and the resource from the available list, and report the allocation. If either the queue is empty or no resources are available, report the reason.
 *         *   `status`: Display the number of tasks currently waiting in the queue and the number of resources currently available. List the descriptions of waiting tasks and the IDs of available resources.
 *         *   `exit`: Terminate the program.
 * 5.  **Control Flow:** Use a `switch` statement to process the user's command input.
 * 6.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying menu options, successful operations (task added, resource added, task allocated), and status reports.
 *     *   Use `System.err` for displaying error messages, such as invalid commands, empty task descriptions, empty resource IDs, or allocation failures due to no tasks or no resources.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during user input (e.g., non-integer input if you were reading integers, though commands are strings here) or unexpected issues in the main processing loop. A general `catch(Exception e)` around the main loop is sufficient for this requirement.
 * 7.  **Best Practices:**
 *     *   Apply encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement basic input validation (e.g., ensure task description and resource ID are not empty).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output:**
 * The program should display a menu, accept commands, and provide informative output based on the operations performed, using `System.out` for success and `System.err` for errors.
 * 
 * ```
 * Manufacturing Plant Resource Allocation System
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > add_task
 * Enter task description: Calibrate Machine X
 * Task 1 added to the queue.
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > add_resource
 * Enter resource ID: Robot_A
 * Resource Robot_A added.
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > allocate
 * Allocating Task 1 ('Calibrate Machine X') to Resource Robot_A.
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > status
 * --- System Status ---
 * Tasks waiting: 0
 * Resources available: 0
 * ---------------------
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > add_task
 * Enter task description: Inspect Conveyor Belt
 * Task 2 added to the queue.
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > status
 * --- System Status ---
 * Tasks waiting: 1
 *   - Task 2: Inspect Conveyor Belt
 * Resources available: 0
 * ---------------------
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > allocate
 * System.err: Allocation failed: No resources available.
 * Enter command (add_task, add_resource, allocate, status, exit):
 * > exit
 * Exiting system.
 * ```
 * 
 * **Constraints:**
 * *   Focus on implementing the core logic using the specified Java components.
 * *   Assume resource availability is binary (either in the available list or not). Resources do not become available again after allocation in this simplified model.
 * 
 * This task requires you to integrate multiple core Java concepts into a cohesive, practical application, demonstrating your understanding of data structures, object-oriented principles, user interaction, and error handling.
 *
 * EXPLANATION:
 * 
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Iterator; // To iterate over collections for status

/**
 * Represents a manufacturing task waiting for allocation.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task " + id + ": " + description;
    }
}

/**
 * Manages tasks and resources for allocation in a manufacturing plant.
 */
public class ResourceAllocationSystem {

    // Queue to hold tasks waiting for a resource (FIFO)
    private Queue<Task> waitingTasks;

    // List to hold IDs of resources that are currently available
    private List<String> availableResources;

    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new ResourceAllocationSystem.
     */
    public ResourceAllocationSystem() {
        waitingTasks = new LinkedList<>(); // LinkedList implements Queue
        availableResources = new ArrayList<>(); // ArrayList implements List
        nextTaskId = 1;
    }

    /**
     * Adds a new task to the waiting queue.
     *
     * @param description The description of the task.
     * @return true if the task was added successfully, false otherwise (e.g., invalid description).
     */
    public boolean addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Task description cannot be empty.");
            return false;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        waitingTasks.offer(newTask); // offer is generally preferred over add for queues (doesn't throw exception on capacity issues, though LinkedList is unbounded)
        System.out.println("Task " + newTask.getId() + " added to the queue.");
        return true;
    }

    /**
     * Adds a resource ID to the list of available resources.
     *
     * @param resourceId The ID of the resource.
     * @return true if the resource was added successfully, false otherwise (e.g., invalid ID).
     */
    public boolean addResource(String resourceId) {
        if (resourceId == null || resourceId.trim().isEmpty()) {
            System.err.println("Resource ID cannot be empty.");
            return false;
        }
         if (availableResources.contains(resourceId.trim())) {
             System.err.println("Resource " + resourceId.trim() + " is already available.");
             return false;
         }
        availableResources.add(resourceId.trim());
        System.out.println("Resource " + resourceId.trim() + " added.");
        return true;
    }

    /**
     * Attempts to allocate the next waiting task to an available resource.
     */
    public void allocateTask() {
        if (waitingTasks.isEmpty()) {
            System.err.println("Allocation failed: No tasks waiting.");
            return;
        }

        if (availableResources.isEmpty()) {
            System.err.println("Allocation failed: No resources available.");
            return;
        }

        // Get the next task from the queue (FIFO)
        Task taskToAllocate = waitingTasks.poll(); // poll retrieves and removes the head

        // Get the first available resource
        String resourceId = availableResources.remove(0); // remove(0) retrieves and removes the first element

        System.out.println("Allocating " + taskToAllocate + " to Resource " + resourceId + ".");
        // In a real system, the resource would now be marked busy, and the task status updated.
        // For this simulation, the resource is simply removed from the available list.
    }

    /**
     * Displays the current status of the system (waiting tasks and available resources).
     */
    public void displayStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Tasks waiting: " + waitingTasks.size());
        // List waiting tasks
        if (!waitingTasks.isEmpty()) {
            System.out.println("  Waiting tasks:");
            // Iterate without removing elements
            Iterator<Task> taskIterator = waitingTasks.iterator();
            while (taskIterator.hasNext()) {
                System.out.println("    - " + taskIterator.next());
            }
        }

        System.out.println("Resources available: " + availableResources.size());
        // List available resources
        if (!availableResources.isEmpty()) {
            System.out.println("  Available resources:");
            for (String resource : availableResources) {
                System.out.println("    - " + resource);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Main method to run the resource allocation system CLI.
     * Handles user input and command processing.
     */
    public static void main(String[] args) {
        ResourceAllocationSystem system = new ResourceAllocationSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Manufacturing Plant Resource Allocation System");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.println("\nEnter command (add_task, add_resource, allocate, status, exit):");
                String command = scanner.nextLine().trim().toLowerCase();

                // Using switch statement for command processing
                switch (command) {
                    case "add_task":
                        System.out.print("Enter task description: ");
                        String taskDescription = scanner.nextLine();
                        system.addTask(taskDescription);
                        break;

                    case "add_resource":
                        System.out.print("Enter resource ID: ");
                        String resourceId = scanner.nextLine();
                        system.addResource(resourceId);
                        break;

                    case "allocate":
                        system.allocateTask();
                        break;

                    case "status":
                        system.displayStatus();
                        break;

                    case "exit":
                        System.out.println("Exiting system.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid command. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging stack trace
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
