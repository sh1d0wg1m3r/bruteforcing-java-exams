/*
 * Exam Question #12
 * Generated on: 2025-05-11 21:32:38
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Prioritization and Processing System
 * 
 * **Scenario:**
 * 
 * A small project team needs a simple command-line system to manage their tasks. Tasks have a description and a priority level. New tasks are added to a list of all tasks and placed into a queue for processing. The system should allow users to add tasks, process the next task in the queue, view tasks waiting in the queue, and view a history of all tasks ever created.
 * 
 * **Task Requirements:**
 * 
 * Design and implement a Java application named `TaskManagementSystem` that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `id`: A unique integer identifier (auto-generated by the system).
 *     *   `description`: A String describing the task.
 *     *   `priority`: An enum `Priority` with values `HIGH`, `MEDIUM`, `LOW`.
 *     *   Implement appropriate getters for these attributes.
 *     *   Provide a meaningful `toString()` method for displaying task information.
 * 
 * 2.  **Task Management Logic:** Create a class `TaskManager` that manages the tasks. It should use the following data structures:
 *     *   A `java.util.List` (implemented by `java.util.ArrayList`) to store *all* tasks ever created.
 *     *   A `java.util.Queue` (implemented by `java.util.LinkedList`) to store tasks currently waiting for processing. Tasks should be processed in the order they are added to the queue (FIFO).
 * 
 * 3.  **Functionality:** The `TaskManager` class should provide the following methods:
 *     *   A constructor to initialize the data structures and any necessary state (like the next task ID).
 *     *   `addTask(String description, Priority priority)`: Creates a new `Task`, assigns a unique ID, adds it to the list of all tasks, and adds it to the processing queue. Returns the ID of the newly added task.
 *     *   `processNextTask()`: Removes the next task from the processing queue and returns it. If the queue is empty, it should indicate that no tasks are available.
 *     *   `getPendingTasks()`: Returns a `java.util.List` containing the tasks currently in the processing queue (without removing them).
 *     *   `getAllTasks()`: Returns a `java.util.List` containing all tasks ever created.
 * 
 * 4.  **User Interface:** Implement a command-line interface in the `main` method (or a separate `run` method called from `main`) that interacts with the `TaskManager`. The interface should:
 *     *   Display a menu of options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View All Tasks
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read user input for menu choices, task description, and priority.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Implement input validation for menu choices and priority levels.
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process a task when the queue is empty).
 * 
 * 5.  **Exception Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Handle potential issues like invalid user input (e.g., non-integer input for menu choice, invalid priority string).
 *     *   Handle cases where operations are attempted on empty collections (e.g., processing an empty queue).
 *     *   Include a top-level `try-catch` block in the main execution loop to catch unexpected errors and prevent the program from crashing abruptly.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but basic comments are required).
 *     *   Ensure clean code structure and formatting.
 *     *   Declare collection variables using interface types (`List`, `Queue`).
 * 
 * **Expected Output:**
 * 
 * The system should provide clear prompts and output.
 * - When adding a task, confirm the task ID.
 * - When processing a task, show the details of the task processed.
 * - When viewing tasks, list them clearly with their ID, description, and priority.
 * - Error messages should be distinct and printed to `System.err`.
 * - The program should loop until the user chooses to exit.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter priority (LOW): LOW
 * Task added with ID: 2
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 3
 * Pending Tasks:
 * [ID: 1, Priority: HIGH, Description: Implement login feature]
 * [ID: 2, Priority: LOW, Description: Write documentation]
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: [ID: 1, Priority: HIGH, Description: Implement login feature]
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 3
 * Pending Tasks:
 * [ID: 2, Priority: LOW, Description: Write documentation]
 * 
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View All Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System adhering to all specified requirements.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`Queue` (from `java.util.Queue`):** The `processingQueue` is declared as a `Queue` interface type and implemented using `java.util.LinkedList`. It is used to hold `Task` objects that are waiting to be processed. Tasks are added using `offer()` and removed using `poll()`, ensuring a FIFO (First-In, First-Out) processing order. `poll()` is preferred over `remove()` because it returns `null` if the queue is empty, allowing for graceful handling without throwing an exception in the `processNextTask` method.
 * 2.  **`ArrayList` (from `java.util.ArrayList`):** The `allTasks` list is implemented using `ArrayList`. It serves as a historical record, storing every `Task` object created since the system started. `ArrayList` provides dynamic resizing and efficient element access by index (though not heavily used here) and iteration.
 * 3.  **`List` interface (from `java.util.List`):** Both `allTasks` and the return type of `getPendingTasks()` and `getAllTasks()` are declared using the `List` interface. This promotes good practice by programming to the interface rather than the concrete implementation (`ArrayList`). It allows for potential future changes in the underlying list implementation without affecting code that uses the `List` interface.
 * 4.  **`Scanner` for user input (from `java.util.Scanner`):** A `Scanner` object is used in the `run()` method of `TaskManager` to read user input from the console (`System.in`). It reads integer choices (`nextInt()`) and string inputs (`nextLine()`) for task details. Proper handling of the newline character after `nextInt()` is included (`scanner.nextLine();`).
 * 5.  **`Switch` statement for flow control:** A `switch` statement in the `run()` method is used to direct the program flow based on the user's integer choice from the main menu, providing a clear and structured way to handle multiple options.
 * 6.  **`System.err` for error messages:** `System.err.println()` is used specifically for outputting error messages, such as invalid menu choices, invalid priority input, or attempting to process tasks when the queue is empty. This distinguishes error output from normal program output.
 * 7.  **`System.out` for normal output:** `System.out.println()` is used for all standard output, including the menu, prompts, task details, and success messages.
 * 8.  **Class-wide exception handling with `try-catch` blocks:**
 *     *   The main application loop within the `run()` method is wrapped in a `try-catch` block to catch any unexpected `Exception` and provide a fallback error message, preventing the program from crashing. A `finally` block ensures the `Scanner` is closed.
 *     *   Inner `try-catch` blocks are used within the loop to handle specific, anticipated errors:
 *         *   `InputMismatchException` is caught when `scanner.nextInt()` fails due to non-integer input, preventing an infinite loop and prompting the user correctly.
 *         *   `IllegalArgumentException` is caught when parsing the priority string if the user enters a value that doesn't match the `Priority` enum values.
 *         *   The `processNextTask` method uses `queue.poll()`, which returns `null` on empty, avoiding the `NoSuchElementException` that `queue.remove()` would throw. A check for `null` is then used to print an error message to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` class fields (`id`, `description`, `priority`) and `TaskManager` fields (`allTasks`, `processingQueue`, `nextTaskId`) are declared as `private`. Public getter methods are provided in `Task` for accessing its data. Public methods in `TaskManager` control access and modification of the internal state.
 * *   **Meaningful Names:** Classes (`Task`, `TaskManager`), methods (`addTask`, `processNextTask`, `getPendingTasks`), variables (`description`, `priorityString`, `choice`), and enum values (`HIGH`, `MEDIUM`, `LOW`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Basic comments explain the purpose of classes, methods, and key logic sections. Javadoc-style comments are used for methods to describe their function, parameters, and return values.
 * *   **Input Validation:** The code checks if the user's menu choice is within the valid range (1-5) and validates the task priority input string against the `Priority` enum.
 * *   **Proper Error Handling:** Specific exceptions are caught and handled appropriately, providing informative messages to the user via `System.err`. The top-level `try-catch` ensures the application exits gracefully even on unforeseen errors.
 * *   **Clean Code Structure:** The code is divided into logical units (`Task` class, `TaskManager` class, `Priority` enum). Methods are relatively small and focused on single responsibilities. The main application logic is contained within the `TaskManager.run()` method.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a functional, albeit simple, real-world simulation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents the priority levels for tasks.
 */
enum Priority {
    HIGH, MEDIUM, LOW
}

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private Priority priority;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Priority: " + priority + ", Description: " + description + "]";
    }
}

/**
 * Manages tasks using a list for all tasks and a queue for pending tasks.
 */
class TaskManager {
    // Using List interface for all tasks, implemented by ArrayList
    private List<Task> allTasks;
    // Using Queue interface for pending tasks, implemented by LinkedList
    private Queue<Task> processingQueue;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager, initializing collections and task ID counter.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // ArrayList implements List
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Creates a Task object, adds it to the list of all tasks,
     * and adds it to the processing queue.
     * @param description The description of the task.
     * @param priority The priority of the task.
     * @return The ID of the newly created task.
     */
    public int addTask(String description, Priority priority) {
        Task newTask = new Task(nextTaskId, description, priority);
        allTasks.add(newTask); // Add to the list of all tasks
        processingQueue.offer(newTask); // Add to the processing queue (FIFO)
        return nextTaskId++; // Increment and return the next ID
    }

    /**
     * Processes the next task in the queue.
     * Removes and returns the task at the front of the processing queue.
     * Handles the case where the queue is empty.
     * @return The processed Task, or null if the queue is empty.
     */
    public Task processNextTask() {
        // Using poll() which returns null if queue is empty, avoiding NoSuchElementException
        Task taskToProcess = processingQueue.poll();
        if (taskToProcess == null) {
            // Using System.err for error-like message (no task available)
            System.err.println("Error: No tasks in the processing queue.");
        }
        return taskToProcess;
    }

    /**
     * Gets a list of tasks currently waiting in the processing queue.
     * Returns a new ArrayList containing the elements from the queue
     * to avoid external modification of the queue itself.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the queue
        return new ArrayList<>(processingQueue);
    }

    /**
     * Gets a list of all tasks ever created in the system.
     * Returns the internal list (can be modified externally - for simplicity
     * in this exam problem, returning the direct list is acceptable, though
     * returning a copy or unmodifiable list is better practice in larger systems).
     * @return A List of all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks; // For simplicity, returning the direct list
    }

    /**
     * Parses a string input into a Priority enum.
     * @param priorityString The string input (e.g., "HIGH").
     * @return The corresponding Priority enum value.
     * @throws IllegalArgumentException if the string does not match a valid priority.
     */
    private Priority parsePriority(String priorityString) throws IllegalArgumentException {
        return Priority.valueOf(priorityString.toUpperCase());
    }

    /**
     * Runs the main command-line interface loop for the Task Management System.
     * Uses Scanner for input, switch for menu handling, and try-catch for errors.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                            String priorityString = scanner.nextLine();
                            try {
                                Priority priority = parsePriority(priorityString);
                                int taskId = addTask(description, priority);
                                System.out.println("Task added with ID: " + taskId);
                            } catch (IllegalArgumentException e) {
                                // Using System.err for invalid input error
                                System.err.println("Error: Invalid priority entered. Please use HIGH, MEDIUM, or LOW.");
                            }
                            break;

                        case 2: // Process Next Task
                            Task processedTask = processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processing task: " + processedTask);
                            }
                            // processNextTask() already prints an error if queue is empty
                            break;

                        case 3: // View Pending Tasks
                            List<Task> pendingTasks = getPendingTasks();
                            System.out.println("--- Pending Tasks ---");
                            if (pendingTasks.isEmpty()) {
                                System.out.println("No tasks currently pending.");
                            } else {
                                for (Task task : pendingTasks) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("---------------------");
                            break;

                        case 4: // View All Tasks
                            List<Task> allTasksList = getAllTasks();
                            System.out.println("--- All Tasks Ever Created ---");
                            if (allTasksList.isEmpty()) {
                                System.out.println("No tasks have been created yet.");
                            } else {
                                for (Task task : allTasksList) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("----------------------------");
                            break;

                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting Task Management System.");
                            break;

                        default:
                            // Using System.err for invalid menu choice
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Using System.err for non-integer input error
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions within the loop
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to System.err for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
             // Top-level catch for any exceptions escaping the inner loop handling
             System.err.println("A critical error occurred outside the main loop: " + e.getMessage());
             e.printStackTrace(System.err);
        } finally {
            scanner.close(); // Close the scanner resource
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View All Tasks");
        System.out.println("5. Exit");
    }
}

/**
 * Main class to start the Task Management System application.
 */
public class TaskManagementSystem {
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application loop
    }
}
