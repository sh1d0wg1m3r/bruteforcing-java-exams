/*
 * Exam Question #549
 * Generated on: 2025-05-11 23:28:03
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processing System
 * 
 * **Problem Description:**
 * 
 * You are required to develop a console-based Task Processing System. This system will manage tasks submitted by a user, process them in a specific order, and maintain a history of completed tasks. The system should be interactive, robust against common input errors, and demonstrate advanced Java programming concepts.
 * 
 * Your implementation must strictly adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue<String>` to store tasks that are waiting to be processed. Tasks should be processed in the order they are submitted (First-In, First-Out - FIFO). Choose an appropriate concrete class that implements `Queue`.
 *     *   Use a `java.util.List<String>` variable, initialized with a `java.util.ArrayList<String>`, to store the history of completed tasks. The history should maintain the order of completion.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` connected to `System.in` to read user input from the console.
 *     *   Present a menu with the following options to the user:
 *         1.  Submit new task
 *         2.  Process next task
 *         3.  View pending tasks
 *         4.  View task history
 *         5.  Exit
 *     *   The program should continuously display the menu and process user input until the user explicitly chooses to exit.
 * 3.  **Functionality:**
 *     *   **Submit Task (Option 1):** Prompt the user to enter a description for the new task (a string). Add this task description to the *end* of the pending task queue. Provide confirmation output. Handle empty task descriptions as an error.
 *     *   **Process Next Task (Option 2):** Attempt to retrieve and remove the task at the *front* of the pending task queue. If a task is successfully retrieved, add it to the *end* of the completed task history list. Provide confirmation output showing the processed task. If the queue is empty when this option is selected, display an appropriate error message.
 *     *   **View Pending Tasks (Option 3):** Display the current contents of the pending task queue. List the tasks in the order they would be processed (from front to back). Do *not* remove tasks from the queue. If the queue is empty, indicate that there are no pending tasks.
 *     *   **View Task History (Option 4):** Display the contents of the completed task history list. List the tasks in the order they were completed. If the history is empty, indicate that no tasks have been processed yet.
 *     *   **Exit (Option 5):** Terminate the program gracefully.
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 5.  **Output Streams:**
 *     *   Use `System.out.println` for all standard output, including the menu, prompts, confirmations of actions, and the contents of the task queue and history lists.
 *     *   Use `System.err.println` for all error messages, such as invalid user input or attempts to perform actions on empty data structures (like processing an empty queue).
 * 6.  **Error Handling:**
 *     *   Implement input validation for the menu choice. If the user enters input that is not a valid integer, or an integer outside the range of the menu options (1-5), catch the relevant exception (`InputMismatchException` is likely) and display an error message using `System.err`. The program should then re-display the menu.
 *     *   Handle the case where the user attempts to process a task when the queue is empty, displaying an error message using `System.err`.
 *     *   Implement class-wide exception handling by wrapping the main application logic loop (the part that displays the menu and processes choices) within a `try-catch(Exception e)` block. This block should catch any unexpected runtime exceptions that might occur during the program's execution and print a generic error message along with the exception details to `System.err`. Ensure the `Scanner` resource is closed even if an exception occurs.
 * 7.  **Code Structure and Best Practices:**
 *     *   Organize your code within a single class (e.g., `TaskProcessingSystem`).
 *     *   Use private fields for your data structures (`taskQueue`, `taskHistory`).
 *     *   Use meaningful variable and method names (e.g., `submitTask()`, `processNextTask()`).
 *     *   Include comments where necessary to clarify logic, especially around error handling or complex operations.
 *     *   Ensure proper indentation and code formatting.
 * 
 * **Expected Output:**
 * 
 * The system should display the menu clearly, prompt for necessary input, provide feedback on successful operations, and output error messages using `System.err` when appropriate. The display of pending tasks and history should be formatted clearly, showing the order of tasks.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Submit new task
 * 2. Process next task
 * 3. View pending tasks
 * 4. View task history
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task "Buy groceries" submitted.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task "Pay bills" submitted.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Buy groceries
 * 2. Pay bills
 * ---------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Buy groceries
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * --- Task History ---
 * 1. Buy groceries
 * --------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Pay bills
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks pending in the queue.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a console-based Task Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `java.util.Queue<String>` named `taskQueue` is used to manage pending tasks. The `LinkedList` class is chosen as the concrete implementation because it efficiently supports the `offer()` (add to end) and `poll()` (remove from front) operations required for Queue behavior.
 *     *   A `java.util.List<String>` named `taskHistory` is used to store completed tasks. It is initialized with a `new java.util.ArrayList<String>()`. Using the `List` interface type for the variable `taskHistory` while using `ArrayList` as the implementation is a good practice that promotes flexibility. `ArrayList` is suitable here as tasks are added to the end (`add()`) and viewed sequentially.
 * 
 * 2.  **User Interaction (`Scanner`):**
 *     *   A `java.util.Scanner` is initialized to read input from `System.in`. It's used within the `processUserInput` and `submitTask` methods to get the user's menu choice and task descriptions, respectively. The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 * 
 * 3.  **Control Flow (`switch`):**
 *     *   The `processUserInput` method uses a `switch` statement based on the user's integer choice. This clearly directs the program flow to the appropriate method (`submitTask`, `processNextTask`, `viewPendingTasks`, `viewTaskHistory`) or sets the `running` flag to `false` for exiting. The `default` case handles invalid integer inputs.
 * 
 * 4.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println` is used for all standard informational output, including the menu, prompts, confirmations of successful actions, and the formatted lists of pending tasks and history.
 *     *   `System.err.println` is specifically used for displaying error messages. This is a standard convention to separate errors from normal output, which can be useful for logging or redirecting output streams. Examples include invalid menu input, processing an empty queue, or attempting to submit an empty task.
 * 
 * 5.  **Error Handling (`try-catch`):**
 *     *   **Input Validation:** Within `processUserInput`, a `try-catch(InputMismatchException e)` block is used specifically to handle cases where the user enters non-integer input when prompted for a menu choice. An error message is printed to `System.err`, and `scanner.nextLine()` is called within the catch block to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *     *   **Empty Queue Handling:** The `processNextTask` method checks if `taskQueue.poll()` returns `null`, which indicates the queue was empty. If so, an error message is printed to `System.err`.
 *     *   **Class-wide Exception Handling:** The entire `while(running)` loop within the `start()` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level safety net, catching any unhandled runtime exception that might occur during the execution of the core application logic. An error message is printed to `System.err`, and the `finally` block ensures that the `scanner` resource is closed properly, preventing resource leaks, even if an unexpected exception occurs.
 * 
 * 6.  **Code Structure and Best Practices:**
 *     *   The code is structured within a single class, `TaskProcessingSystem`.
 *     *   The data structures (`taskQueue`, `taskHistory`, `scanner`, `running`) are declared as `private` fields, adhering to encapsulation principles.
 *     *   Methods have meaningful names (`displayMenu`, `processUserInput`, `submitTask`, etc.) that clearly indicate their purpose.
 *     *   Comments are included to explain the purpose of the class, methods, fields, and specific logic like input validation or exception handling.
 *     *   The code is formatted with consistent indentation.
 * 
 * The solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional system that simulates a practical task management scenario. It demonstrates proper data structure usage, user interaction handling, flow control, and robust error management, fulfilling the requirements of a challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // For handling non-integer input

/**
 * A simple console-based Task Processing System that manages pending and completed tasks.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch, System.out, System.err,
 * and exception handling.
 */
public class TaskProcessingSystem {

    // Use LinkedList for the Queue implementation as it's efficient for adding/removing from ends
    private Queue<String> taskQueue;

    // Use ArrayList for the List implementation to store history
    private List<String> taskHistory;

    private Scanner scanner;
    private boolean running; // Flag to control the main application loop

    /**
     * Constructs a new TaskProcessingSystem, initializing data structures and scanner.
     */
    public TaskProcessingSystem() {
        taskQueue = new LinkedList<>(); // Initialize the queue
        taskHistory = new ArrayList<>(); // Initialize the history list
        scanner = new Scanner(System.in);
        running = true; // System starts in running state
    }

    /**
     * Starts the main task processing loop.
     * Includes class-wide exception handling for robustness.
     */
    public void start() {
        // Wrap the main loop in a try-catch block for class-wide exception handling
        try {
            while (running) {
                displayMenu();
                processUserInput();
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optional: print stack trace for debugging purposes in case of unexpected errors
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
            }
        }
        // This line is reached when running is false (user chose exit) or an exception occurred
        System.out.println("Exiting Task Processing System.");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Submit new task");
        System.out.println("2. Process next task");
        System.out.println("3. View pending tasks");
        System.out.println("4. View task history");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads user input for the menu choice and directs execution based on the choice.
     * Includes input validation and uses a switch statement.
     */
    private void processUserInput() {
        int choice = -1; // Default invalid choice
        try {
            // Attempt to read an integer for the menu choice
            choice = scanner.nextInt();
            // Consume the rest of the line after reading the integer to prevent issues
            scanner.nextLine();
        } catch (InputMismatchException e) {
            // Catch non-integer input specifically
            System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
            // Consume the invalid input from the scanner to clear the buffer
            scanner.nextLine();
            return; // Exit the method to re-display the menu without processing an invalid choice
        }

        // Use a switch statement to handle valid integer choices
        switch (choice) {
            case 1:
                submitTask();
                break;
            case 2:
                processNextTask();
                break;
            case 3:
                viewPendingTasks();
                break;
            case 4:
                viewTaskHistory();
                break;
            case 5:
                running = false; // Set the flag to false to exit the main loop
                break;
            default:
                // Handle integer choices outside the valid range (1-5)
                System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                break;
        }
    }

    /**
     * Prompts the user for a task description and adds it to the pending task queue.
     * Validates that the task description is not empty.
     */
    private void submitTask() {
        System.out.print("Enter task description: ");
        String task = scanner.nextLine();
        // Basic validation for empty or whitespace-only task description
        if (task != null && !task.trim().isEmpty()) {
            taskQueue.offer(task.trim()); // Add task to the end of the queue (offer returns boolean)
            System.out.println("Task \"" + task.trim() + "\" submitted.");
        } else {
             System.err.println("Error: Task description cannot be empty.");
        }
    }

    /**
     * Processes the next task from the queue by removing it and adding it to history.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        // Retrieve and remove the head of the queue. poll() returns null if queue is empty.
        String task = taskQueue.poll();
        if (task != null) {
            taskHistory.add(task); // Add the processed task to the end of the history list
            System.out.println("Processed task: " + task);
        } else {
            // Display an error message using System.err if the queue is empty
            System.err.println("Error: No tasks pending in the queue.");
        }
    }

    /**
     * Displays the tasks currently in the pending queue without removing them.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate through the queue using an enhanced for loop (maintains order)
            int i = 1;
            for (String task : taskQueue) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the history of completed tasks.
     */
    private void viewTaskHistory() {
        System.out.println("--- Task History ---");
        if (taskHistory.isEmpty()) {
            System.out.println("No tasks processed yet.");
        } else {
            // Iterate through the history list using a traditional for loop or enhanced for loop
            for (int i = 0; i < taskHistory.size(); i++) {
                System.out.println((i + 1) + ". " + taskHistory.get(i));
            }
            // Alternative using enhanced for loop (if index is not needed):
            // int i = 1;
            // for (String task : taskHistory) {
            //     System.out.println(i++ + ". " + task);
            // }
        }
        System.out.println("--------------------");
    }

    /**
     * The main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.start(); // Begin the system's operation
    }
}
