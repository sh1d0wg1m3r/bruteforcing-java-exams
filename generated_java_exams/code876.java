/*
 * Exam Question #876
 * Generated on: 2025-05-12 16:53:55
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation of a single production line in a small factory. The production line processes manufacturing orders one unit at a time. Orders arrive and are placed in a queue. The system should allow adding new orders, processing the next unit on the line, and viewing the current status of pending orders and completed units.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage incoming production orders. Orders should be processed in the order they were received (FIFO).
 *     *   Use a `java.util.ArrayList` (declared as a `java.util.List`) to keep track of all units that have been successfully produced.
 * 2.  **Classes:**
 *     *   Create an `Order` class to represent a production order. Each order should have a `productName` (String) and a `quantity` (int). Implement appropriate encapsulation (private fields, public getters). Include a method to decrement the quantity and a method to check if the order is completed (quantity is 0).
 *     *   Create a main class (e.g., `ProductionLineManager`) that contains the `main` method and manages the simulation logic. This class should hold the `Queue` of pending orders and the `List` of completed units.
 * 3.  **Functionality (via User Input):**
 *     *   The program should present a menu of options to the user:
 *         *   Add New Order
 *         *   Process Next Unit
 *         *   View Status
 *         *   Exit
 *     *   Use `java.util.Scanner` to read user input for menu selection and order details.
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Add New Order:**
 *     *   Prompt the user for the product name and quantity.
 *     *   Validate the quantity: It must be a positive integer. If not, display an error message using `System.err` and do not add the order.
 *     *   If valid, create an `Order` object and add it to the end of the pending orders `Queue`.
 *     *   Display a confirmation message using `System.out`.
 * 5.  **Process Next Unit:**
 *     *   Check if the pending orders `Queue` is empty. If so, display a message using `System.out` and do nothing further.
 *     *   If the queue is not empty, take the order at the front of the queue (using `peek()`).
 *     *   Decrement the quantity of this order.
 *     *   Add a string representation of the completed unit (e.g., "Completed Unit: [Product Name]") to the `completedUnits` `List`.
 *     *   If the order's quantity becomes 0 after decrementing, remove the order from the front of the `Queue` (using `remove()`).
 *     *   Display a message indicating which unit was processed using `System.out`.
 * 6.  **View Status:**
 *     *   Display the current contents of the pending orders `Queue`. Clearly label this section.
 *     *   Display the current contents of the completed units `List`. Clearly label this section.
 *     *   If a list/queue is empty, indicate that.
 *     *   Use `System.out` for all status output.
 * 7.  **Error Handling:**
 *     *   Implement class-wide exception handling using a `try-catch` block around the main simulation loop to catch unexpected runtime errors. Print an error message to `System.err` if an exception occurs.
 *     *   Handle potential input errors (e.g., `InputMismatchException`) when reading integer input (quantity, menu choice). Display an error message using `System.err` and clear the invalid input.
 *     *   Use `System.err` exclusively for error output and `System.out` for all normal output (menu, prompts, confirmations, status).
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments where necessary.
 *     *   Ensure proper encapsulation in the `Order` class.
 *     *   Add a way to cleanly exit the program.
 *     *   Close the `Scanner` resource properly.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, showing processing results, and displaying status. Error messages should go to the standard error stream.
 * 
 * ```
 * --- Production Line Simulation ---
 * Choose an option:
 * 1. Add New Order
 * 2. Process Next Unit
 * 3. View Status
 * 4. Exit
 * Enter choice: 1
 * Enter product name: Widget
 * Enter quantity: 5
 * Order added: Widget (5 units)
 * 
 * --- Production Line Simulation ---
 * Choose an option:
 * 1. Add New Order
 * 2. Process Next Unit
 * 3. View Status
 * 4. Exit
 * Enter choice: 2
 * Processed unit: Widget
 * 
 * --- Production Line Simulation ---
 * Choose an option:
 * 1. Add New Order
 * 2. Process Next Unit
 * 3. View Status
 * 4. Exit
 * Enter choice: 3
 * --- Pending Orders ---
 * [Order{productName='Widget', quantity=4}]
 * --- Completed Units ---
 * [Completed Unit: Widget]
 * 
 * --- Production Line Simulation ---
 * Choose an option:
 * 1. Add New Order
 * 2. Process Next Unit
 * 3. View Status
 * 4. Exit
 * Enter choice: 4
 * Exiting simulation.
 * ```
 * 
 * (Error output example)
 * ```
 * --- Production Line Simulation ---
 * Choose an option:
 * 1. Add New Order
 * 2. Process Next Unit
 * 3. View Status
 * 4. Exit
 * Enter choice: 1
 * Enter product name: Gadget
 * Enter quantity: -2
 * Error: Quantity must be a positive integer.
 * ```
 * 
 * **Your Task:**
 * 
 * Write the complete Java code for the `Order` class and the `ProductionLineManager` class that fulfills all the requirements.
 *
 * EXPLANATION:
 * This solution implements a production line simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Order` Class:**
 *     *   Represents a single production order with `productName` and `quantity`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides `public` getters (`getProductName`, `getQuantity`).
 *     *   Includes `decrementQuantity()` to simulate processing one unit.
 *     *   `isCompleted()` checks if the order quantity has reached zero.
 *     *   The constructor includes input validation, throwing an `IllegalArgumentException` if the quantity is not positive. This is a form of pre-condition check.
 *     *   `toString()` is overridden for easy printing of `Order` objects.
 * 
 * 2.  **`ProductionLineManager` Class:**
 *     *   **`Queue`:** `private Queue<Order> incomingOrders = new LinkedList<>();` A `LinkedList` is used as a concrete implementation of the `Queue` interface to store `Order` objects. This follows the FIFO principle required for a production line queue.
 *     *   **`List` & `ArrayList`:** `private List<String> completedUnits = new ArrayList<>();` An `ArrayList` is used as a concrete implementation of the `List` interface to store strings representing completed units. This demonstrates declaring a variable using the interface type (`List`) while instantiating a concrete class (`ArrayList`).
 *     *   **`Scanner`:** `private Scanner scanner = new Scanner(System.in);` Used to read user input from the console.
 *     *   **`runSimulation()`:** This is the main loop of the program.
 *         *   It uses a `boolean running` flag to control the loop.
 *         *   **Class-wide `try-catch`:** A `try-catch` block wraps the entire `while(running)` loop. This provides a top-level handler for any unexpected exceptions that might occur during the simulation, preventing the program from crashing abruptly. Error messages are printed to `System.err`.
 *         *   A `finally` block ensures the `Scanner` is closed when the simulation ends, regardless of whether it exited normally or due to an exception.
 *     *   **Menu and `switch`:** `displayMenu()` prints the options, `getUserChoice()` reads the integer input, and a `switch` statement in `runSimulation()` directs execution based on the user's valid choice.
 *     *   **Input Validation and Error Handling (`Scanner`, `System.err`, `try-catch`):**
 *         *   `getUserChoice()` and `addOrder()` methods specifically handle `InputMismatchException` that occurs if the user enters non-integer input when an integer is expected. They print an error to `System.err` and use `scanner.next()` or `scanner.nextLine()` to consume the invalid input, preventing an infinite loop.
 *         *   `addOrder()` also catches the `IllegalArgumentException` thrown by the `Order` constructor if a non-positive quantity is entered, again printing an error to `System.err`.
 *     *   **`System.out` vs. `System.err`:** All normal output (menu, prompts, confirmations, status displays) uses `System.out.println()`. All error messages (invalid input, quantity errors, unexpected exceptions) use `System.err.println()`.
 *     *   **`addOrder()`:** Prompts for product name and quantity, validates quantity using a `try-catch` block around the `Order` creation and the `IllegalArgumentException` check, and adds the valid `Order` to the `incomingOrders` queue using `add()`.
 *     *   **`processNextUnit()`:**
 *         *   Checks if the queue is empty first to avoid errors.
 *         *   Uses `incomingOrders.peek()` to look at the next order without removing it.
 *         *   Calls `decrementQuantity()` on the peeked order.
 *         *   Adds a descriptive string to the `completedUnits` list.
 *         *   Checks if the order is now completed (`isCompleted()`) and, if so, removes it from the queue using `incomingOrders.remove()`. `remove()` is safe here because we already checked `!isEmpty()` and `peek()` succeeded.
 *     *   **`viewStatus()`:** Prints the contents of both the `incomingOrders` queue and the `completedUnits` list using `System.out`. It includes checks for empty lists/queues.
 *     *   **Best Practices:** Meaningful names (`incomingOrders`, `completedUnits`, `processNextUnit`), comments, encapsulation in `Order`, clear output/error streams, and proper `Scanner` closing are implemented.
 * 
 * This solution effectively combines various core and advanced Java concepts to simulate a practical scenario, requiring students to manage data structures, handle user interaction, implement control flow (`switch`), perform input validation, and manage errors using `try-catch` blocks and different output streams.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a production order
class Order {
    private String productName;
    private int quantity;

    public Order(String productName, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }
        this.productName = productName;
        this.quantity = quantity;
    }

    public String getProductName() {
        return productName;
    }

    public int getQuantity() {
        return quantity;
    }

    // Decrements the quantity of the order
    public void decrementQuantity() {
        if (quantity > 0) {
            quantity--;
        }
    }

    // Checks if the order is completed
    public boolean isCompleted() {
        return quantity == 0;
    }

    @Override
    public String toString() {
        return "Order{productName='" + productName + "', quantity=" + quantity + '}';
    }
}

// Manages the production line simulation
public class ProductionLineManager {
    private Queue<Order> incomingOrders;
    private List<String> completedUnits;
    private Scanner scanner;
    private boolean running;

    public ProductionLineManager() {
        // Use LinkedList as an implementation of Queue
        this.incomingOrders = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedUnits = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    // Runs the main simulation loop
    public void runSimulation() {
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();

                // Switch statement for flow control
                switch (choice) {
                    case 1:
                        addOrder();
                        break;
                    case 2:
                        processNextUnit();
                        break;
                    case 3:
                        viewStatus();
                        break;
                    case 4:
                        exitSimulation();
                        break;
                    default:
                        // System.err for error messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to stderr
        } finally {
            // Ensure scanner is closed even if an exception occurs
            closeScanner();
            System.out.println("Simulation ended.");
        }
    }

    // Displays the main menu
    private void displayMenu() {
        // System.out for normal output
        System.out.println("\n--- Production Line Simulation ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Unit");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
        System.out.print("Enter choice: ");
    }

    // Gets user's menu choice with input validation
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle non-integer input
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        }
        return choice;
    }

    // Adds a new order based on user input
    private void addOrder() {
        // Consume newline left by nextInt()
        scanner.nextLine();

        System.out.print("Enter product name: ");
        String productName = scanner.nextLine();

        System.out.print("Enter quantity: ");
        int quantity = -1;
        try {
            quantity = scanner.nextInt();
            // Consume newline left by nextInt()
            scanner.nextLine();

            // Input validation for quantity
            Order newOrder = new Order(productName, quantity);
            incomingOrders.add(newOrder);
            System.out.println("Order added: " + newOrder);

        } catch (InputMismatchException e) {
            // Handle non-integer input for quantity
            System.err.println("Invalid input. Please enter a valid integer quantity.");
            scanner.next(); // Consume the invalid input
        } catch (IllegalArgumentException e) {
            // Handle negative or zero quantity from Order constructor
            System.err.println("Error: " + e.getMessage());
        }
    }

    // Processes the next unit from the production line
    private void processNextUnit() {
        if (incomingOrders.isEmpty()) {
            System.out.println("No pending orders to process.");
            return;
        }

        // Peek at the order without removing it yet
        Order currentOrder = incomingOrders.peek();

        if (currentOrder != null) {
            currentOrder.decrementQuantity();
            // Add completed unit to the list
            completedUnits.add("Completed Unit: " + currentOrder.getProductName());
            System.out.println("Processed unit: " + currentOrder.getProductName());

            // If the order is now complete, remove it from the queue
            if (currentOrder.isCompleted()) {
                incomingOrders.remove(); // Remove the head element (which is currentOrder)
                System.out.println("Order completed and removed from queue: " + currentOrder.getProductName());
            }
        }
        // Note: We don't need explicit try-catch here for remove/peek on empty
        // because we already checked incomingOrders.isEmpty().
    }

    // Displays the current status of orders and completed units
    private void viewStatus() {
        System.out.println("\n--- Pending Orders ---");
        if (incomingOrders.isEmpty()) {
            System.out.println("No orders in the queue.");
        } else {
            // Using toString of Queue and Order classes
            System.out.println(incomingOrders);
        }

        System.out.println("\n--- Completed Units ---");
        if (completedUnits.isEmpty()) {
            System.out.println("No units completed yet.");
        } else {
            // Using toString of List and String classes
            System.out.println(completedUnits);
        }
    }

    // Sets the flag to exit the simulation loop
    private void exitSimulation() {
        running = false;
        System.out.println("Exiting simulation.");
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    // Main method to start the simulation
    public static void main(String[] args) {
        ProductionLineManager manager = new ProductionLineManager();
        manager.runSimulation();
    }
}
