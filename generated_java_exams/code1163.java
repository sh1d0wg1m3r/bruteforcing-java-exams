/*
 * Exam Question #1163
 * Generated on: 2025-05-12 17:33:44
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Kitchen Order Management System**
 * 
 * **Scenario:**
 * You are tasked with creating a simplified system to manage kitchen orders in a small restaurant. New orders arrive and are placed into a queue for the kitchen staff to prepare. The kitchen staff prepares orders one at a time, always taking the oldest order first. Once an order is prepared, it is moved to a list of completed orders. The system should allow staff to add new orders, prepare the next pending order, view the list of pending orders, and view the list of completed orders via a simple console interface.
 * 
 * **Requirements:**
 * 1.  **Implement two classes:**
 *     *   `KitchenOrder`: Represents a single order. It should store a unique order ID, a list of items, and a status (e.g., "Pending", "Completed").
 *     *   `KitchenSystem`: Contains the main application logic, managing the collection of orders.
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue` (specifically, a suitable implementation like `LinkedList`) to manage **pending** orders, ensuring they are processed in First-In, First-Out (FIFO) order.
 *     *   Use `java.util.List` (specifically, an `ArrayList` implementation) to store **completed** orders.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a main menu with the following options, controlled by a `switch` statement:
 *         1.  **Add New Order:** Prompt the user to enter items for the order as a comma-separated string. Create a `KitchenOrder` object with a unique, sequential ID (starting from 1) and add it to the pending queue.
 *         2.  **Prepare Next Order:** Take the order from the head of the pending queue, change its status to "Completed", and move it to the completed list. If the pending queue is empty, output an appropriate error message.
 *         3.  **View Pending Orders:** Display the details of all orders currently in the pending queue. If the queue is empty, indicate so.
 *         4.  **View Completed Orders:** Display the details of all orders currently in the completed list. If the list is empty, indicate so.
 *         5.  **Exit:** Terminate the program.
 * 4.  **Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, confirmations, displaying order details).
 *     *   Use `System.err` for printing error messages (e.g., invalid menu choice, attempting to prepare from an empty queue, invalid item input).
 * 5.  **Exception Handling:**
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the `KitchenSystem` class, particularly around the user input loop, to gracefully handle potential issues like non-integer input for menu choices or other unexpected runtime errors during the main operation flow. Ensure the program doesn't crash due to invalid input.
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement input validation (e.g., check for valid menu choice range, handle non-integer input, validate items input).
 *     *   Provide clear and informative error messages.
 *     *   Structure the code cleanly.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output & Behavior:**
 * The program should display a menu, accept user input, and perform the requested action. Error messages should be printed to the standard error stream (`System.err`). Invalid menu input (non-integer or out of range) should be handled without crashing, prompting the user to try again. Attempting to prepare an order when none are pending should result in an error message.
 * 
 * Example interaction flow (partial):
 * ```
 * --- Kitchen Order Management ---
 * 1. Add New Order
 * 2. Prepare Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: 1
 * Enter items (comma-separated): Pizza, Coke, Salad
 * Order 1 added to queue.
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: 3
 * --- Pending Orders ---
 * Order ID: 1, Items: [Pizza, Coke, Salad], Status: Pending
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: 2
 * Processing order 1... Order 1 completed.
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: 3
 * --- Pending Orders ---
 * (Queue is empty)
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: 4
 * --- Completed Orders ---
 * Order ID: 1, Items: [Pizza, Coke, Salad], Status: Completed
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: 2
 * No pending orders to prepare. (This should go to System.err)
 * 
 * --- Kitchen Order Management ---
 * ...
 * Enter choice: invalid
 * Invalid input. Please enter a number between 1 and 5. (This should go to System.err)
 * ```
 * 
 * Your solution should consist of the Java code for the `KitchenOrder` and `KitchenSystem` classes and a brief explanation of the implementation.
 *
 * EXPLANATION:
 * This solution implements a simple Kitchen Order Management System using the required Java components and best practices.
 * 
 * 1.  **`KitchenOrder` Class:** This class encapsulates the data for a single order: `orderId`, `items` (stored as a `List<String>`), and `status`. It follows encapsulation principles with private fields and public getter methods. The `markCompleted()` method updates the status, and the `toString()` method provides a convenient way to display order details.
 * 
 * 2.  **`KitchenSystem` Class:** This is the main class that manages the collection of orders and handles user interaction.
 *     *   **Data Structures:** It uses a `java.util.Queue<KitchenOrder>` (`pendingOrdersQueue`, implemented with `LinkedList`) to store orders waiting to be prepared, ensuring orders are processed in the order they were received (FIFO). It uses a `java.util.List<KitchenOrder>` (`completedOrdersList`, implemented with `ArrayList`) to store orders after they have been prepared. Using the `List` interface for the completed list variable demonstrates programming to interfaces.
 *     *   **Order Management Methods:** Methods like `addOrder`, `prepareNextOrder`, `viewPendingOrders`, and `viewCompletedOrders` handle the core logic of the system, interacting with the queue and list.
 *     *   **User Interaction (`run` method):** The `run` method contains the main application loop. It displays a menu using `System.out`, reads user input using `Scanner`, and uses a `switch` statement to direct execution based on the user's choice.
 *     *   **Input Validation and Error Handling:**
 *         *   Input validation is performed to check if the pending queue is empty before attempting to prepare an order (`prepareNextOrder`). If empty, an error message is printed to `System.err`.
 *         *   Input validation is also included for the items input when adding an order, checking if the input results in an empty list of items.
 *         *   **Exception Handling:** The `run` method incorporates nested `try-catch` blocks. The inner `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice. This prevents the program from crashing, prints an error to `System.err`, consumes the invalid input from the scanner, and allows the loop to continue. The outer `try-catch(Exception e)` provides a broader, "class-wide" safety net for the main operational loop, catching any other unexpected runtime exceptions that might occur and printing error details, including a stack trace, to `System.err`.
 *     *   **Resource Management:** A `finally` block is used to ensure the `Scanner` resource is closed properly when the application loop terminates, preventing resource leaks.
 * 
 * 3.  **Best Practices:** The solution adheres to best practices by using meaningful names, including Javadoc comments for classes and methods, using private fields for encapsulation, validating user input, providing specific error messages via `System.err`, and structuring the code into logical methods within classes.
 * 
 * This solution effectively demonstrates the practical use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` in a cohesive, simulated real-world application, while following standard Java programming practices.
 */

// File: KitchenOrder.java
package com.example.kitchen; // Example package structure

import java.util.List;

/**
 * Represents a single kitchen order with items and status.
 * Follows encapsulation principles with private fields and public getters.
 */
public class KitchenOrder {
    private int orderId;
    private List<String> items;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new KitchenOrder.
     * Initializes status to "Pending".
     *
     * @param orderId The unique identifier for the order.
     * @param items   The list of items included in the order.
     */
    public KitchenOrder(int orderId, List<String> items) {
        this.orderId = orderId;
        this.items = items;
        this.status = "Pending"; // Default status upon creation
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public List<String> getItems() {
        return items;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the order to "Completed".
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a formatted string representation of the order's details.
     *
     * @return A string displaying order ID, items, and status.
     */
    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Items: " + items + ", Status: " + status;
    }
}
```
```java
// File: KitchenSystem.java
package com.example.kitchen; // Example package structure

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // A common implementation of List
import java.util.Scanner; // For reading user input
import java.util.Arrays; // Utility for array operations, used here for splitting strings
import java.util.InputMismatchException; // Specific exception for scanner input type mismatches

/**
 * Manages the flow of kitchen orders.
 * Uses a Queue for pending orders and a List for completed orders.
 * Handles user interaction via console input.
 * Demonstrates use of various Java collections and control structures.
 */
public class KitchenSystem {

    // --- Private Fields ---
    // Queue to hold orders waiting to be prepared (FIFO)
    private Queue<KitchenOrder> pendingOrdersQueue;
    // List to hold orders that have been prepared
    private List<KitchenOrder> completedOrdersList;
    // Counter for assigning unique order IDs
    private int nextOrderId;
    // Scanner for reading input from the console
    private Scanner scanner;

    /**
     * Constructs a new KitchenSystem.
     * Initializes the order queues/lists and the scanner.
     */
    public KitchenSystem() {
        // Initialize the Queue using LinkedList
        this.pendingOrdersQueue = new LinkedList<>();
        // Initialize the List using ArrayList
        this.completedOrdersList = new ArrayList<>();
        // Start order IDs from 1
        this.nextOrderId = 1;
        // Initialize the scanner for standard input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Creates a new order with provided items and adds it to the pending queue.
     * Assigns a unique sequential order ID.
     *
     * @param items The list of items for the new order.
     */
    public void addOrder(List<String> items) {
        KitchenOrder newOrder = new KitchenOrder(nextOrderId++, items);
        pendingOrdersQueue.add(newOrder); // Add order to the tail of the queue
        System.out.println("Order " + newOrder.getOrderId() + " added to queue."); // Normal output
    }

    /**
     * Processes the next order from the front of the pending queue.
     * Removes the order from the queue, marks it as completed, and adds it
     * to the completed orders list. Handles the case where the queue is empty.
     */
    public void prepareNextOrder() {
        // Input validation: Check if there are any orders to prepare
        if (pendingOrdersQueue.isEmpty()) {
            System.err.println("No pending orders to prepare."); // Error output
            return; // Exit the method if queue is empty
        }

        // Retrieve and remove the head of the queue (FIFO principle)
        KitchenOrder orderToPrepare = pendingOrdersQueue.poll();

        // This check is primarily for robustness, poll returns null if empty,
        // but we already checked isEmpty() above.
        if (orderToPrepare != null) {
            orderToPrepare.markCompleted(); // Change order status
            completedOrdersList.add(orderToPrepare); // Add to completed list
            System.out.println("Processing order " + orderToPrepare.getOrderId() + "... Order " + orderToPrepare.getOrderId() + " completed."); // Normal output
        } else {
             // Should ideally not be reached due to the isEmpty() check
             System.err.println("An internal error occurred while retrieving the order."); // Error output
        }
    }

    /**
     * Displays all orders currently waiting in the pending queue.
     */
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---"); // Normal output
        if (pendingOrdersQueue.isEmpty()) {
            System.out.println("(Queue is empty)"); // Normal output
        } else {
            // Iterate through the queue elements without removing them
            // Queue is Iterable, so a for-each loop works
            for (KitchenOrder order : pendingOrdersQueue) {
                System.out.println(order); // Normal output (uses KitchenOrder's toString)
            }
        }
    }

    /**
     * Displays all orders that have been moved to the completed orders list.
     */
    public void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---"); // Normal output
        if (completedOrdersList.isEmpty()) {
            System.out.println("(No completed orders yet)"); // Normal output
        } else {
            // Iterate through the list elements
            for (KitchenOrder order : completedOrdersList) {
                System.out.println(order); // Normal output (uses KitchenOrder's toString)
            }
        }
    }

    /**
     * Displays the main interactive menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Kitchen Order Management ---"); // Normal output
        System.out.println("1. Add New Order"); // Normal output
        System.out.println("2. Prepare Next Order"); // Normal output
        System.out.println("3. View Pending Orders"); // Normal output
        System.out.println("4. View Completed Orders"); // Normal output
        System.out.println("5. Exit"); // Normal output
        System.out.print("Enter choice: "); // Normal output
    }

    /**
     * Contains the main application loop for user interaction.
     * Includes exception handling for input and general runtime errors.
     */
    public void run() {
        int choice = -1; // Variable to store user's menu choice

        // Class-wide exception handling block for the main application loop.
        // This outer try-catch catches any unexpected runtime exceptions
        // that might occur within the main loop's execution, providing a
        // safety net for the overall application flow.
        try {
            while (choice != 5) { // Loop continues until user chooses to exit (option 5)
                displayMenu(); // Show menu options

                // Inner try-catch specifically to handle potential InputMismatchException
                // when reading the integer menu choice. This allows recovery from
                // non-integer input without terminating the program.
                try {
                    choice = scanner.nextInt(); // Read integer input for menu choice
                    scanner.nextLine(); // Consume the leftover newline character after reading the integer

                    // Switch statement for flow control based on the valid integer choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter items (comma-separated): "); // Normal output
                            String itemsInput = scanner.nextLine(); // Read the entire line for items
                            // Split the input string by comma, optionally followed by zero or more spaces
                            List<String> items = Arrays.asList(itemsInput.split(",\\s*"));
                            // Basic validation: Check if the resulting list is empty or contains only an empty string after trimming
                            if (items.isEmpty() || (items.size() == 1 && items.get(0).trim().isEmpty())) {
                                System.err.println("Invalid input: Please enter at least one item."); // Error output for invalid item input
                            } else {
                                addOrder(items); // Call method to add the order
                            }
                            break;
                        case 2:
                            prepareNextOrder(); // Call method to prepare the next order
                            break;
                        case 3:
                            viewPendingOrders(); // Call method to view pending orders
                            break;
                        case 4:
                            viewCompletedOrders(); // Call method to view completed orders
                            break;
                        case 5:
                            System.out.println("Exiting Kitchen System. Goodbye!"); // Normal output for exit
                            break;
                        default:
                            // Handles integer inputs that are outside the 1-5 range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Error output for invalid choice
                    }
                } catch (InputMismatchException e) {
                    // Catch block for the inner try: specifically handles non-integer input
                    System.err.println("Invalid input. Please enter a number between 1 and 5."); // Error output
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input from the scanner buffer to prevent an infinite loop
                    choice = -1; // Reset choice to a non-exit value to ensure the loop continues
                }
                 // Note: No explicit catch needed here for the outer try if the inner catch
                 // and the default switch case handle expected user input issues.
                 // The outer catch remains as a general safety net for unexpected runtime errors.
            }
        } catch (Exception e) {
            // Catch block for the outer try: handles any other unexpected runtime exceptions
            System.err.println("An unexpected system error occurred: " + e.getMessage()); // Error output
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
             // The finally block ensures resources are cleaned up regardless of
             // whether an exception occurred or the loop exited normally.
             if (scanner != null) {
                 scanner.close(); // Close the scanner resource
             }
        }
    }

    /**
     * The main entry point for the Kitchen Order Management System application.
     * Creates an instance of KitchenSystem and starts the main application loop.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        KitchenSystem system = new KitchenSystem();
        system.run(); // Start the application
    }
}
