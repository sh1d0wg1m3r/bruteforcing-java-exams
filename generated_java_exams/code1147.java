/*
 * Exam Question #1147
 * Generated on: 2025-05-12 17:31:26
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple, command-line based system to manage tasks. New tasks arrive and are placed in a queue to be processed in a First-In, First-Out (FIFO) manner. Once a task is processed, it is moved to a list of completed tasks. The system should allow users to add new tasks, process the next task in the queue, view the current queue, and view the list of completed tasks.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java program (`.java` file) that includes:
 * 
 * 1.  A `Task` class representing a single task with attributes like `taskId` (String) and `description` (String). This class should follow proper encapsulation.
 * 2.  A main class (e.g., `TaskProcessingSystem`) containing the application logic.
 * 3.  The system must use the following Java components exactly as specified:
 *     *   `java.util.Queue` (specifically, use `LinkedList` as the implementation for the task queue).
 *     *   `java.util.ArrayList` (as the concrete implementation for the completed tasks list).
 *     *   `java.util.List` (declare the variable holding completed tasks using this interface type).
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   A `switch` statement to handle the main menu options.
 *     *   `System.err` to output all error messages (e.g., invalid input, trying to process an empty queue).
 *     *   `System.out` to output all normal information (menu, task details, success messages).
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues, especially around user input.
 * 4.  Implement the following functionalities via a text-based menu:
 *     *   **Add Task:** Prompt the user for a task ID and description, create a `Task` object, and add it to the task queue. Basic validation should check if ID or description are empty.
 *     *   **Process Next Task:** Take the task at the front of the queue, remove it, and add it to the list of completed tasks. If the queue is empty, output an error message.
 *     *   **View Task Queue:** Display all tasks currently in the queue, without removing them. Show task ID and description. Indicate if the queue is empty.
 *     *   **View Completed Tasks:** Display all tasks in the completed tasks list. Show task ID and description. Indicate if the list is empty.
 *     *   **Exit:** Terminate the program.
 * 5.  Follow best practices:
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic or class/method purpose.
 *     *   Ensure proper input validation and error handling as described.
 *     *   Structure the code logically with private fields and public methods where appropriate.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the user's choice, the program should perform the requested action, printing appropriate messages to `System.out` for success/information and `System.err` for errors.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter Task ID: T001
 * Enter Description: Setup development environment
 * Task T001 added to the queue.
 * 
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter Task ID: T002
 * Enter Description: Configure database
 * Task T002 added to the queue.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Task Queue ---
 * Task ID: T001, Description: Setup development environment
 * Task ID: T002, Description: Configure database
 * -------------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: T001, Description: Setup development environment
 * Task T001 moved to completed.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Task Queue ---
 * Task ID: T002, Description: Configure database
 * -------------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: T001, Description: Setup development environment
 * -----------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: T002, Description: Configure database
 * Task T002 moved to completed.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * System.err: Task queue is empty. No tasks to process.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: T001, Description: Setup development environment
 * Task ID: T002, Description: Configure database
 * -----------------------
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should be robust enough to handle incorrect input types (e.g., entering text when a number is expected) and display an error using `System.err` before showing the menu again.
 * 
 * **Submission:** Provide the complete Java code for your solution.
 *
 * EXPLANATION:
 * The solution implements a simple Task Processing System as required, demonstrating the use of various core Java concepts.
 * 
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a task. It has `private` fields (`taskId`, `description`) and `public` getter methods (`getTaskId`, `getDescription`) and a constructor, adhering to encapsulation principles. The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the main class containing the application logic.
 *     *   **Fields:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface with a `LinkedList` implementation, fulfilling the requirement for a FIFO structure for incoming tasks. `private` access modifier ensures encapsulation.
 *         *   `completedTasksList`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This correctly uses the `List` interface with an `ArrayList` implementation, fulfilling the requirements and demonstrating programming to an interface. `private` access modifier ensures encapsulation.
 *         *   `scanner`: An instance of `Scanner` to read input from `System.in`. `private` access modifier and initialization in the constructor are standard practice.
 *     *   **Constructor:** Initializes the `taskQueue`, `completedTasksList`, and `scanner`.
 *     *   **`displayMenu()`:** A `private` helper method to print the menu options to `System.out`.
 *     *   **`addTask()`:**
 *         *   Prompts the user for input using `System.out`.
 *         *   Reads input using `scanner.nextLine()`. Using `nextLine()` after `nextInt()` is crucial to consume the leftover newline character and prevent input issues in subsequent reads.
 *         *   Includes basic validation using `isEmpty()` and outputs errors to `System.err`.
 *         *   Creates a new `Task` object.
 *         *   Adds the new task to the `taskQueue` using `offer()`, which is the standard way to add elements to a queue.
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextTask()`:**
 *         *   Retrieves and removes the head of the queue using `taskQueue.poll()`. `poll()` is suitable as it returns `null` if the queue is empty, allowing for graceful handling.
 *         *   Checks if the result is `null`. If so, it means the queue was empty, and an error message is printed to `System.err`.
 *         *   If a task was retrieved, it's added to the `completedTasksList` using `add()`, which is the standard way to add to a `List`.
 *         *   Success messages are printed to `System.out`.
 *     *   **`viewTaskQueue()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the queue is empty and prints a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `taskQueue` using a `for-each` loop. This iterates over the elements without removing them, which is the correct behavior for viewing. Each task's `toString()` representation is printed to `System.out`.
 *     *   **`viewCompletedTasks()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the list is empty and prints a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `completedTasksList` using a `for-each` loop and prints each task's `toString()` representation to `System.out`.
 *     *   **`run()`:**
 *         *   This is the main application loop method.
 *         *   It uses a `while` loop to keep the system running until the user chooses to exit.
 *         *   **Exception Handling:** A `try-catch` block wraps the entire `while` loop. This is a class-wide exception handling mechanism.
 *             *   An inner `try-catch` specifically handles `InputMismatchException` that might occur if the user enters non-integer input when prompted for a menu choice. The error message is printed to `System.err`, and `scanner.nextLine()` is called to clear the invalid input from the buffer, preventing an infinite loop. `continue` skips to the next iteration.
 *             *   The outer `catch (Exception e)` catches any other unexpected runtime exceptions that might occur within the loop, printing an error to `System.err` and the stack trace for debugging.
 *         *   **Flow Control:** A `switch` statement is used based on the user's integer choice to call the appropriate method (`addTask`, `processNextTask`, etc.). This fulfills the `switch` requirement.
 *         *   The "Exit" case sets a boolean flag to `true`, terminating the `while` loop.
 *         *   A `default` case in the `switch` handles invalid numeric choices, printing an error to `System.err`.
 *         *   **Resource Management:** A `finally` block ensures that the `scanner` is closed using `scanner.close()`, releasing the system resource regardless of whether the program exits normally or due to an exception.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `TaskProcessingSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, task management simulation, while adhering to best practices like encapsulation, meaningful names, input validation, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private String taskId;
    private String description;

    /**
     * Constructs a new Task.
     *
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(String taskId, String description) {
        this.taskId = taskId;
        this.description = description;
    }

    /**
     * Gets the task ID.
     *
     * @return The task ID.
     */
    public String getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description;
    }
}

/**
 * Main class for the Task Processing System.
 * Manages a queue of pending tasks and a list of completed tasks.
 */
public class TaskProcessingSystem {

    // Use Queue interface with LinkedList implementation for FIFO task processing
    private Queue<Task> taskQueue;

    // Use List interface with ArrayList implementation for storing completed tasks
    private List<Task> completedTasksList;

    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queue and completed tasks list.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasksList = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the queue based on user input.
     * Includes basic input validation.
     */
    private void addTask() {
        System.out.print("Enter Task ID: ");
        String taskId = scanner.nextLine().trim(); // Use nextLine() after reading numbers to consume newline

        System.out.print("Enter Description: ");
        String description = scanner.nextLine().trim();

        if (taskId.isEmpty() || description.isEmpty()) {
            System.err.println("Error: Task ID and Description cannot be empty.");
            return;
        }

        Task newTask = new Task(taskId, description);
        taskQueue.offer(newTask); // offer() is preferred for queues, returns false on failure (rare for LinkedList)
        System.out.println("Task " + taskId + " added to the queue.");
    }

    /**
     * Processes the next task from the queue (FIFO).
     * Moves the processed task to the completed list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        Task nextTask = taskQueue.poll(); // poll() retrieves and removes the head, returns null if empty

        if (nextTask == null) {
            System.err.println("Task queue is empty. No tasks to process.");
        } else {
            completedTasksList.add(nextTask);
            System.out.println("Processing task: " + nextTask);
            System.out.println("Task " + nextTask.getTaskId() + " moved to completed.");
        }
    }

    /**
     * Displays all tasks currently in the task queue without removing them.
     */
    private void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate over the queue elements without removing them
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasksList.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate over the list elements
            for (Task task : completedTasksList) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main application loop.
     * Displays the menu, reads input, and performs actions based on user choice.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean exit = false;

        try {
            while (!exit) {
                displayMenu();
                int choice = -1;

                try {
                    // Read user choice, expecting an integer
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip to the next iteration of the while loop
                }

                // Use switch statement for menu flow control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewTaskQueue();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        exit = true;
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the program exits or an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
