/*
 * Exam Question #107
 * Generated on: 2025-05-11 22:15:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Automated Build and Deployment Queue System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of an automated build and deployment system. Developers submit build requests, which are placed in a queue to be processed sequentially. Once a build is processed, it is added to a history log. The system should allow users to interact via a command-line interface to submit new builds, process the next build, view pending builds, view completed builds, and exit the system.
 * 
 * **Task Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the **pending** build requests. Requests should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store the history of **completed** build requests.
 * 
 * 2.  **Classes:**
 *     *   Create a class `BuildRequest` to represent a single build request. It should contain private fields for `projectName` (String) and `version` (String). Include a constructor and a meaningful `toString()` method. Implement basic validation in the constructor (e.g., project name and version cannot be null or empty).
 *     *   Create a class `BuildSystemManager` that encapsulates the `Queue` of pending requests and the `List` of completed requests. This class will handle the system logic and user interaction.
 * 
 * 3.  **User Interface (Command Line):**
 *     *   Use `java.util.Scanner` to read commands from the user via standard input (`System.in`).
 *     *   Implement the following commands:
 *         *   `submit <projectName> <version>`: Creates a `BuildRequest` and adds it to the pending queue.
 *         *   `process`: Takes the next request from the head of the pending queue, simulates processing, and moves it to the completed history list.
 *         *   `pending`: Displays all requests currently in the pending queue without removing them.
 *         *   `history`: Displays all requests in the completed history list.
 *         *   `exit`: Terminates the program.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement within the main command processing loop in `BuildSystemManager` to handle the different user commands.
 * 
 * 5.  **Input/Output:**
 *     *   Use `System.out` for normal program output (e.g., success messages, displaying lists).
 *     *   Use `System.err` for error messages (e.g., invalid command format, missing arguments, attempting to process an empty queue).
 * 
 * 6.  **Error Handling:**
 *     *   Implement input validation for commands (e.g., check if `submit` command has the required number of arguments). Print validation errors to `System.err`.
 *     *   Implement exception handling using `try-catch` blocks. Include a general `try-catch(Exception e)` block around the main command processing loop in `BuildSystemManager` to catch any unexpected runtime errors (demonstrating a context for class-wide handling). Also, handle specific operational errors, such as attempting to `process` when the pending queue is empty, printing an informative message to `System.err`. Handle potential `IllegalArgumentException` from the `BuildRequest` constructor.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation by declaring data fields as `private` and providing public methods for interaction.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., explaining method purpose).
 *     *   Ensure the `Scanner` is closed properly when the program exits.
 * 
 * **Example Interaction:**
 * 
 * ```
 * --- Automated Build and Deployment Queue System ---
 * Commands: submit <projectName> <version>, process, pending, history, exit
 * > submit ProjectA 1.0
 * Build request submitted: ProjectA v1.0
 * > submit ProjectB 2.0
 * Build request submitted: ProjectB v2.0
 * > pending
 * Pending builds:
 * ProjectA v1.0
 * ProjectB v2.0
 * > process
 * Processing build for ProjectA v1.0...
 * Build completed.
 * > process
 * Processing build for ProjectB v2.0...
 * Build completed.
 * > process
 * No pending builds to process.
 * > history
 * Completed builds:
 * 1. ProjectA v1.0
 * 2. ProjectB v2.0
 * > submit
 * Usage: submit <projectName> <version>
 * > unknown_command
 * Unknown command: unknown_command
 * Commands: submit, process, pending, history, exit
 * > exit
 * Exiting build system. Goodbye!
 * ```
 * 
 * Your solution should consist of the complete Java code for the `BuildRequest` and `BuildSystemManager` classes, including a `main` method to start the system.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Automated Build and Deployment Queue System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`BuildRequest` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) to model a build request.
 *     *   It uses `private` fields (`projectName`, `version`) to enforce encapsulation.
 *     *   The constructor includes basic input validation using `IllegalArgumentException` to ensure requests are created with valid data.
 *     *   The `toString()` method provides a convenient way to represent a `BuildRequest` object as a string for printing.
 * 
 * 2.  **`BuildSystemManager` Class:**
 *     *   This is the main class that orchestrates the system.
 *     *   It holds two key data structures as private fields:
 *         *   `pendingBuilds`: Declared as `java.util.Queue<BuildRequest>`, implemented using `java.util.LinkedList`. A `Queue` is used because build requests are processed in the order they are submitted (FIFO). Methods like `offer()` (to add) and `poll()` (to retrieve and remove from the head) are used, which are standard `Queue` operations.
 *         *   `completedBuilds`: Declared as `java.util.List<BuildRequest>`, implemented using `java.util.ArrayList`. A `List` is suitable for storing a history where the order of completion is maintained and elements can be accessed sequentially. `ArrayList` is a common and efficient implementation for dynamic arrays.
 *     *   The constructor initializes these data structures.
 * 
 * 3.  **User Interaction (`runSystem` method):**
 *     *   The `runSystem()` method contains the main loop for interacting with the user via the command line.
 *     *   A `java.util.Scanner` reads lines of input from `System.in`.
 *     *   Input lines are split into command and arguments.
 *     *   A `switch` statement is used on the command string to direct execution to the appropriate logic for each command (`submit`, `process`, `pending`, `history`, `exit`). This fulfills the `switch` statement requirement for flow control.
 * 
 * 4.  **Command Implementation:**
 *     *   `submit <projectName> <version>`: Parses the arguments, attempts to create a `BuildRequest`, and adds it to the `pendingBuilds` queue using `offer()`. It includes a `try-catch` block to handle `IllegalArgumentException` thrown by the `BuildRequest` constructor if the input is invalid.
 *     *   `process`: Calls `pendingBuilds.poll()` to get and remove the next request from the queue. If `poll()` returns `null` (indicating an empty queue), it prints an error message to `System.err`. Otherwise, it prints processing messages to `System.out` and adds the completed request to the `completedBuilds` list using `add()`.
 *     *   `pending`: Checks if `pendingBuilds` is empty. If not, it iterates through the queue (using `forEach` or an enhanced for loop, which uses an iterator internally) and prints each request to `System.out` without removing them.
 *     *   `history`: Checks if `completedBuilds` is empty. If not, it iterates through the `List` (using a standard for loop with index or an enhanced for loop) and prints each completed request to `System.out`.
 *     *   `exit`: Prints a goodbye message, closes the `Scanner`, and uses `return` to exit the `runSystem` method, terminating the program.
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   The code checks the number of arguments provided for each command (`parts.length`) and prints usage messages to `System.err` if incorrect.
 *     *   Specific error messages (e.g., "No pending builds to process.") are printed to `System.err` for operational errors.
 *     *   A general `try-catch(Exception e)` block wraps the main `while` loop in `runSystem()`. This demonstrates catching unexpected exceptions that might occur during the execution of command logic, providing a form of "class-wide" handling for the core operational method. The `finally` block ensures the `Scanner` is closed even if an exception occurs.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in both classes.
 *     *   Method and variable names are descriptive (`pendingBuilds`, `processNextRequest`, `displayHistory`, etc.).
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   `System.out` is used for normal output, and `System.err` is correctly used for error messages, following the requirement.
 *     *   The `Scanner` is closed in a `finally` block to prevent resource leaks.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application that demonstrates understanding of fundamental Java programming principles, data structures, control flow, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single build request with project name and version.
 */
class BuildRequest {
    private String projectName;
    private String version;

    /**
     * Constructs a new BuildRequest.
     * @param projectName The name of the project.
     * @param version The version of the project.
     * @throws IllegalArgumentException if project name or version is null or empty.
     */
    public BuildRequest(String projectName, String version) {
        // Basic validation
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be null or empty.");
        }
        if (version == null || version.trim().isEmpty()) {
            throw new IllegalArgumentException("Version cannot be null or empty.");
        }
        this.projectName = projectName.trim();
        this.version = version.trim();
    }

    // Getters (optional but good practice for encapsulation)
    public String getProjectName() {
        return projectName;
    }

    public String getVersion() {
        return version;
    }

    /**
     * Returns a string representation of the build request.
     * @return String in the format "ProjectName vVersion".
     */
    @Override
    public String toString() {
        return projectName + " v" + version;
    }
}

/**
 * Manages the queue of pending build requests and the history of completed builds.
 * Provides a command-line interface for interaction.
 */
public class BuildSystemManager {

    // Use Queue for pending builds (FIFO processing)
    private Queue<BuildRequest> pendingBuilds;

    // Use List for completed builds history
    private List<BuildRequest> completedBuilds;

    /**
     * Constructs a new BuildSystemManager, initializing the data structures.
     */
    public BuildSystemManager() {
        // LinkedList implements the Queue interface and is suitable for this use case
        this.pendingBuilds = new LinkedList<>();
        // ArrayList implements the List interface and is suitable for storing history
        this.completedBuilds = new ArrayList<>();
    }

    /**
     * Submits a new build request to the pending queue.
     * Handles validation errors from BuildRequest constructor.
     * @param projectName The name of the project.
     * @param version The version of the project.
     */
    public void submitRequest(String projectName, String version) {
        try {
            BuildRequest request = new BuildRequest(projectName, version);
            // offer() is preferred over add() in queues when capacity constraints might exist (though not in LinkedList)
            pendingBuilds.offer(request);
            System.out.println("Build request submitted: " + request);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from the BuildRequest constructor
            System.err.println("Error submitting build request: " + e.getMessage());
        }
    }

    /**
     * Processes the next pending build request.
     * Removes the request from the pending queue and adds it to the completed history.
     * Handles the case where the queue is empty.
     */
    public void processNextRequest() {
        // poll() retrieves and removes the head of the queue, returning null if the queue is empty
        BuildRequest request = pendingBuilds.poll();

        if (request != null) {
            System.out.println("Processing build for " + request + "...");
            // Simulate processing (e.g., a delay could be added here)
            System.out.println("Build completed.");
            completedBuilds.add(request); // Add the completed request to the history list
        } else {
            // Specific error handling for an empty queue
            System.err.println("No pending builds to process.");
        }
    }

    /**
     * Displays the list of all pending build requests currently in the queue.
     */
    public void displayPending() {
        if (pendingBuilds.isEmpty()) {
            System.out.println("No pending builds.");
        } else {
            System.out.println("Pending builds:");
            // Iterate through the queue using forEach or an iterator without removing elements
            pendingBuilds.forEach(System.out::println);
        }
    }

    /**
     * Displays the history of all completed build requests.
     */
    public void displayHistory() {
        if (completedBuilds.isEmpty()) {
            System.out.println("No completed builds yet.");
        } else {
            System.out.println("Completed builds:");
            // Iterate through the List
            for (int i = 0; i < completedBuilds.size(); i++) {
                 System.out.println((i + 1) + ". " + completedBuilds.get(i));
            }
        }
    }

    /**
     * Runs the interactive command-line interface for the build system manager.
     * Includes the main command processing loop and class-wide exception handling context.
     */
    public void runSystem() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("--- Automated Build and Deployment Queue System ---");
        System.out.println("Commands: submit <projectName> <version>, process, pending, history, exit");

        // Class-wide exception handling context: Wrap the main operational loop
        // This catches any unexpected runtime exceptions that might occur during command processing
        try {
            while (true) {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Ignore empty lines
                }

                // Split the input line into command and arguments
                String[] parts = inputLine.split("\\s+");
                String command = parts[0].toLowerCase(); // Get the command, make it case-insensitive

                // Use a switch statement to handle different commands
                switch (command) {
                    case "submit":
                        // Validate number of arguments for submit command
                        if (parts.length == 3) {
                            String projectName = parts[1];
                            String version = parts[2];
                            submitRequest(projectName, version); // Call the submit method
                        } else {
                            System.err.println("Usage: submit <projectName> <version>");
                        }
                        break; // End of submit case

                    case "process":
                        // Validate number of arguments for process command
                        if (parts.length == 1) {
                            processNextRequest(); // Call the process method
                        } else {
                             System.err.println("Usage: process");
                        }
                        break; // End of process case

                    case "pending":
                         // Validate number of arguments for pending command
                         if (parts.length == 1) {
                            displayPending(); // Call the displayPending method
                        } else {
                             System.err.println("Usage: pending");
                        }
                        break; // End of pending case

                    case "history":
                        // Validate number of arguments for history command
                        if (parts.length == 1) {
                            displayHistory(); // Call the displayHistory method
                        } else {
                             System.err.println("Usage: history");
                        }
                        break; // End of history case

                    case "exit":
                        System.out.println("Exiting build system. Goodbye!");
                        // No break; here, we will return from the method
                        return; // Exit the runSystem method, which ends the program

                    default:
                        // Handle unknown commands
                        System.err.println("Unknown command: " + command);
                        System.err.println("Commands: submit, process, pending, history, exit");
                        break; // End of default case
                }
            }
        } catch (Exception e) {
            // This general catch block handles any unexpected exceptions
            // demonstrating a class-wide handling approach for the main operational method
            System.err.println("An unexpected error occurred during system execution: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits (normally or by exception)
            if (scanner != null) {
                 scanner.close();
            }
        }
    }

    /**
     * Main method to start the build system manager.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BuildSystemManager manager = new BuildSystemManager();
        manager.runSystem(); // Start the interactive system
    }
}
