/*
 * Exam Question #1065
 * Generated on: 2025-05-12 17:20:05
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: IT Support Task Prioritization and Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified IT support system that manages incoming support tasks. The system should allow users (simulating support staff) to add new tasks, process the next task waiting in the queue, and view both pending and completed tasks.
 * 
 * The system must adhere to the following functional requirements:
 * 
 * 1.  **Task Representation:** Each task should have a unique ID, a description, and a priority level (e.g., High, Medium, Low).
 * 2.  **Task Queue:** New tasks are added to a queue for processing. Tasks should be processed in a First-In, First-Out (FIFO) manner based on their arrival time in the queue.
 * 3.  **Completed Tasks:** Once a task is processed, it should be moved to a list of completed tasks.
 * 4.  **User Interface:** Provide a simple text-based menu for user interaction.
 * 5.  **Operations:** The system must support the following operations via the menu:
 *     *   Add New Task: Prompt for description and priority. Assign a unique ID automatically. Add the task to the pending queue.
 *     *   Process Next Task: Take the task at the front of the pending queue, remove it, and add it to the completed tasks list. Handle the case where the queue is empty.
 *     *   View Pending Tasks: Display all tasks currently in the pending queue.
 *     *   View Completed Tasks: Display all tasks that have been processed.
 *     *   Exit: Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate proficiency in fundamental and advanced Java concepts by utilizing *all* of the following components:
 * 
 * *   `java.util.Queue`: To manage the pending tasks waiting for processing.
 * *   `java.util.ArrayList`: To store the completed tasks.
 * *   `java.util.List` interface: Declare the variable holding completed tasks using the `List` interface type.
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the different menu options selected by the user.
 * *   `System.err`: To print error messages (e.g., invalid input, attempting to process an empty queue, invalid priority).
 * *   `System.out`: To print normal output (e.g., menu, prompts, task details, success messages).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, including catching specific input errors (`InputMismatchException`) and potentially custom or general exceptions during processing. The main interaction loop or the primary processing method should be wrapped in a `try-catch` block to demonstrate class-wide handling.
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation using `private` fields and `public` methods.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and Javadoc documentation for classes and methods.
 * *   Validate user input where necessary (e.g., ensure priority is one of the allowed values, handle non-integer input for menu choice).
 * *   Structure your code into appropriate classes (e.g., a `Task` class and a `TaskProcessingSystem` class).
 * 
 * **Expected Output:**
 * 
 * The output should include:
 * *   A welcome message.
 * *   The main menu displayed repeatedly until the user chooses to exit.
 * *   Clear prompts for user input.
 * *   Confirmation messages upon successful task addition or processing.
 * *   Lists of pending and completed tasks when requested.
 * *   Informative error messages printed to `System.err` when invalid operations or input occur.
 * *   A polite exit message.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- IT Support Task Processing System ---
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Fix printer in Room 101
 * Enter task priority (High, Medium, Low): Medium
 * Task added: [ID:1] [Medium] Fix printer in Room 101
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 1
 * Enter task description: Setup new laptop for CEO
 * Enter task priority (High, Medium, Low): High
 * Task added: [ID:2] [High] Setup new laptop for CEO
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [ID:1] [Medium] Fix printer in Room 101
 * 2. [ID:2] [High] Setup new laptop for CEO
 * ---------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * Task processed: [ID:1] [Medium] Fix printer in Room 101
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [ID:2] [High] Setup new laptop for CEO
 * ---------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. [ID:1] [Medium] Fix printer in Room 101
 * -----------------------
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * Task processed: [ID:2] [High] Setup new laptop for CEO
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Select an option:
 * ... (menu again) ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the IT Support Task Processing System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) that encapsulates the data for a single task: `id`, `description`, and `priority`. It uses `private` fields and provides a constructor and a `toString()` method for easy representation.
 * 
 * 2.  **TaskProcessingSystem Class:** This is the main class that orchestrates the system logic.
 *     *   **Data Structures:** It uses a `Queue<Task>` named `taskQueue` (implemented by `LinkedList`) to store pending tasks, adhering to the FIFO principle for processing. It uses a `List<Task>` named `completedTasks` (implemented by `ArrayList`) to store processed tasks. Declaring `completedTasks` as `List` demonstrates using the interface type.
 *     *   **Encapsulation:** All data fields (`taskQueue`, `completedTasks`, `nextTaskId`) are `private`. Operations are performed via `public` methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `run`).
 *     *   **`addTask` Method:** Creates a new `Task` object with a unique ID (`nextTaskId++`). It includes input validation for the `priority` string, throwing an `IllegalArgumentException` if the priority is not one of the expected values. The new task is added to the `taskQueue` using `offer()`. Success messages are printed to `System.out`.
 *     *   **`processNextTask` Method:** Retrieves and removes the head of the `taskQueue` using `poll()`. `poll()` is suitable because it returns `null` if the queue is empty, which is handled explicitly. If a task is retrieved, it's added to the `completedTasks` list. Success is printed to `System.out`. If the queue is empty, an error message is printed to `System.err`.
 *     *   **`viewPendingTasks` and `viewCompletedTasks` Methods:** These methods iterate through their respective collections (`taskQueue` and `completedTasks`) and print the details of each task using the `Task` class's `toString()` method. They handle the case where the lists/queue are empty and print status messages to `System.out`.
 *     *   **`printMenu` Method:** A simple helper method to display the menu options using `System.out`.
 *     *   **`run` Method:** This is the core of the application's interaction logic.
 *         *   It initializes a `Scanner` for user input.
 *         *   It contains the main `while` loop that continues until the user chooses to exit (option 0).
 *         *   Inside the loop, it prints the menu and prompts the user for input using `System.out`.
 *         *   A nested `try-catch` block handles potential errors during input reading and operation execution.
 *         *   `scanner.nextInt()` reads the menu choice. `scanner.nextLine()` is crucial after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls for task description/priority.
 *         *   A `switch` statement is used to direct execution based on the user's `choice`, calling the appropriate methods (`addTask`, `processNextTask`, etc.). The `default` case handles invalid numeric choices, printing an error to `System.err`.
 *         *   **Specific Exception Handling:** The inner `catch` blocks handle `InputMismatchException` (for non-integer menu input) and `IllegalArgumentException` (thrown by `addTask` for invalid priority). Error messages are printed to `System.err`.
 *         *   **Class-wide Exception Handling:** An outer `try-catch` block wraps the entire `while` loop within the `run` method. This demonstrates catching any potential exceptions that might occur within the scope of the `run` method and weren't specifically caught by the inner blocks. While the inner blocks handle the most probable errors, the outer block serves as a fallback, fulfilling the requirement for class-wide handling within this method's execution context. Error messages are printed to `System.err`.
 *         *   **`finally` Block:** Ensures the `Scanner` resource is closed when the `run` method finishes execution (either by exiting the loop normally or due to an unhandled exception).
 *     *   **`main` Method:** The entry point of the application. It creates an instance of `TaskProcessingSystem` and calls its `run()` method to start the system.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured application that follows best practices like encapsulation, meaningful naming, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the IT Support system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // e.g., High, Medium, Low

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param priority The priority level (e.g., High, Medium, Low).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters (included for completeness, though not strictly needed for this problem's logic)
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return A formatted string including task ID, description, and priority.
     */
    @Override
    public String toString() {
        return "[ID:" + id + "] [" + priority + "] " + description;
    }
}

/**
 * Manages the IT Support Task Prioritization and Processing System.
 * Handles adding, processing, and viewing tasks using a Queue and a List.
 */
public class TaskProcessingSystem {
    // Queue to hold tasks that are pending processing (FIFO)
    private Queue<Task> taskQueue;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem, initializing the task queue and completed tasks list.
     */
    public TaskProcessingSystem() {
        // LinkedList is a common implementation of the Queue interface
        taskQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        completedTasks = new ArrayList<>();
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending task queue.
     * Validates the priority input.
     * @param description The description of the task.
     * @param priority The priority of the task (High, Medium, Low).
     * @throws IllegalArgumentException if the priority is not valid.
     */
    public void addTask(String description, String priority) throws IllegalArgumentException {
        // Input validation for priority
        if (!priority.equalsIgnoreCase("High") && !priority.equalsIgnoreCase("Medium") && !priority.equalsIgnoreCase("Low")) {
            throw new IllegalArgumentException("Invalid priority. Must be High, Medium, or Low (case-insensitive).");
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        taskQueue.offer(newTask); // offer() is preferred for queues as it returns false if capacity is full (not an issue for LinkedList)
        System.out.println("Task added: " + newTask); // Use System.out for success message
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from the pending queue to the completed tasks list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        Task processedTask = taskQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty
        if (processedTask != null) {
            completedTasks.add(processedTask);
            System.out.println("Task processed: " + processedTask); // Use System.out for success message
        } else {
            System.err.println("Error: No pending tasks to process."); // Use System.err for error message
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---"); // Use System.out
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks."); // Use System.out
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Task task : taskQueue) {
                System.out.println(i++ + ". " + task); // Use System.out
            }
        }
        System.out.println("---------------------"); // Use System.out
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---"); // Use System.out
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks."); // Use System.out
        } else {
            // Iterate through the list
            int i = 1;
            for (Task task : completedTasks) {
                System.out.println(i++ + ". " + task); // Use System.out
            }
        }
        System.out.println("-----------------------"); // Use System.out
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:"); // Use System.out
        System.out.println("1. Add New Task"); // Use System.out
        System.out.println("2. Process Next Task"); // Use System.out
        System.out.println("3. View Pending Tasks"); // Use System.out
        System.out.println("4. View Completed Tasks"); // Use System.out
        System.out.println("0. Exit"); // Use System.out
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide and specific exception handling.
     */
    public void run() {
        // Use Scanner for reading input
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        System.out.println("--- IT Support Task Processing System ---"); // Use System.out

        // Class-wide exception handling demonstrated by wrapping the main interaction loop
        try {
            while (choice != 0) {
                printMenu(); // Print the menu

                try {
                    System.out.print("Enter your choice: "); // Prompt for input
                    choice = scanner.nextInt(); // Read integer choice
                    scanner.nextLine(); // Consume the leftover newline character

                    // Use switch statement for menu control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: "); // Use System.out
                            String description = scanner.nextLine();
                            System.out.print("Enter task priority (High, Medium, Low): "); // Use System.out
                            String priority = scanner.nextLine();
                            addTask(description, priority); // Call method to add task (includes validation)
                            break;
                        case 2:
                            processNextTask(); // Call method to process task
                            break;
                        case 3:
                            viewPendingTasks(); // Call method to view pending tasks
                            break;
                        case 4:
                            viewCompletedTasks(); // Call method to view completed tasks
                            break;
                        case 0:
                            System.out.println("Exiting system. Goodbye!"); // Use System.out for exit message
                            break;
                        default:
                            // Handle choices outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 0 and 4."); // Use System.err
                    }
                } catch (InputMismatchException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Invalid input. Please enter a number for your choice."); // Use System.err
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent an infinite loop
                } catch (IllegalArgumentException e) {
                    // Catch specific exception for invalid priority input from addTask
                    System.err.println("Error adding task: " + e.getMessage()); // Use System.err
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the inner loop execution
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage()); // Use System.err
                    // e.printStackTrace(); // Uncomment for detailed debugging stack trace
                }
            }
        } catch (Exception mainException) {
             // This outer catch block catches any exceptions that might escape the inner block,
             // demonstrating the "Class-wide exception handling" requirement.
             // In a real application, this might log the error and attempt a clean shutdown.
             System.err.println("A critical system error occurred: " + mainException.getMessage());
             // mainException.printStackTrace(); // Uncomment for debugging
        } finally {
             // Ensure the scanner is closed when the application exits the run method
             scanner.close();
             System.out.println("Scanner closed."); // Optional: indicate scanner closure
        }
    }

    /**
     * The main method that starts the Task Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run(); // Start the main application loop
    }
}
