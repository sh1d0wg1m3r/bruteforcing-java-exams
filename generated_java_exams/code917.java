/*
 * Exam Question #917
 * Generated on: 2025-05-12 16:59:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: E-commerce System Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified backend simulation for an e-commerce system. The system needs to manage a catalog of products and a queue of pending customer orders. Users should be able to interact with the system via a command-line interface to perform operations like adding products, viewing the catalog, placing orders, and processing orders.
 * 
 * Your solution must demonstrate advanced understanding of Java collections, I/O, control flow, exception handling, and object-oriented principles.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of available `Product` objects using an `ArrayList`. This collection must be referenced using the `List` interface type.
 *     *   Maintain a queue of pending customer `Order` objects using the `Queue` interface.
 * 
 * 2.  **Classes:**
 *     *   Create a `Product` class with private fields for `productId` (String), `name` (String), `price` (double), and `stock` (int). Include a constructor, public getters, and a `toString()` method.
 *     *   Create an `Order` class with private fields for `orderId` (String), `productId` (String), and `quantity` (int). Include a constructor, public getters, and a `toString()` method.
 *     *   Create an `ECommerceSystem` class that encapsulates the product catalog (`List<Product>`) and the pending orders queue (`Queue<Order>`). This class will contain the main application logic.
 * 
 * 3.  **Functionality (Implemented in `ECommerceSystem`):**
 *     *   **Add Product:** Prompt the user for product details (ID, name, price, stock). Add a new `Product` to the catalog. Validate input (price > 0, stock >= 0, non-empty strings). Report errors using `System.err`.
 *     *   **View Catalog:** Display all products currently in the catalog with their details. Use `System.out`. If the catalog is empty, print a message.
 *     *   **Place Order:** Prompt the user for a product ID and quantity. Find the product in the catalog. Validate input (quantity > 0). Check if sufficient stock is available. If valid and in stock, create an `Order` object, add it to the pending orders queue, and *decrease* the stock of the product in the catalog. Report success using `System.out` and errors (product not found, insufficient stock) using `System.err`.
 *     *   **Process Next Order:** Take the next order from the front of the pending orders queue. Simulate processing by printing the order details. If the queue is empty, report it using `System.out`. (Note: Stock is deducted when placing the order, processing just removes it from the queue).
 *     *   **View Pending Orders:** Display all orders currently in the pending queue without removing them. Use `System.out`. If the queue is empty, print a message.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   The system should run in a loop until the user chooses to exit.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main interaction loop to catch unexpected runtime errors and prevent the program from crashing. Print a generic error message to `System.err`.
 *     *   Implement specific input validation and error checks within each function (e.g., non-numeric input where numbers are expected, invalid product ID, insufficient stock). Report these specific errors using `System.err`. Handle `InputMismatchException` for Scanner input errors.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for all normal program output (menu, product listings, order details, success messages, empty collection messages).
 *     *   Use `System.err` for all error messages and validation failures.
 * 
 * 7.  **Best Practices:**
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc for classes/methods, inline for complex logic).
 *     *   Ensure the `Scanner` is properly managed (e.g., closed when done).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide feedback based on the user's actions. Error messages should go to standard error, while normal output goes to standard output.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * --- E-commerce System Menu ---
 * 1. Add Product
 * 2. View Catalog
 * 3. Place Order
 * 4. Process Next Order
 * 5. View Pending Orders
 * 6. Exit
 * Enter your choice: 1
 * Enter Product ID: P101
 * Enter Product Name: Laptop
 * Enter Price: 1200.50
 * Enter Stock: 10
 * Product added successfully.
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 2
 * --- Product Catalog ---
 * Product ID: P101, Name: Laptop, Price: 1200.5, Stock: 10
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 3
 * Enter Product ID to order: P101
 * Enter Quantity: 2
 * Order placed successfully (Order ID: O1). Stock updated.
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 5
 * --- Pending Orders ---
 * Order ID: O1, Product ID: P101, Quantity: 2
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 4
 * Processing order: Order ID: O1, Product ID: P101, Quantity: 2
 * Order processed.
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 5
 * --- Pending Orders ---
 * No pending orders.
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 2
 * --- Product Catalog ---
 * Product ID: P101, Name: Laptop, Price: 1200.5, Stock: 8
 * 
 * --- E-commerce System Menu ---
 * 1. Add Product
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Correct implementation of all required functionalities.
 * *   Robustness of input validation and error handling.
 * *   Code clarity, readability, and adherence to best practices (naming, comments, formatting).
 * *   Efficiency of the implementation (within reasonable limits for the task).
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a simplified e-commerce system backend, demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Their Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):** The `pendingOrders` field is declared as `Queue<Order>` and instantiated with `LinkedList<Order>`. `LinkedList` is a common implementation of `Queue` that provides FIFO (First-In, First-Out) behavior suitable for processing orders sequentially.
 *     *   `pendingOrders.offer(newOrder)`: Adds a new order to the end of the queue.
 *     *   `pendingOrders.poll()`: Removes and returns the order at the front of the queue. Returns `null` if the queue is empty, which is handled to report "No pending orders".
 *     *   `pendingOrders.isEmpty()`: Checks if the queue is empty before attempting to process or view.
 *     *   `pendingOrders.iterator()`: Used in `viewPendingOrders` to iterate through the queue elements without removing them, allowing the user to see the current state of the queue.
 * 
 * 2.  **`ArrayList` (`java.util.ArrayList`):** The product catalog is managed using `ArrayList`. This provides dynamic resizing and efficient access/iteration for the product list.
 *     *   Instantiated as `new ArrayList<>()`.
 * 
 * 3.  **`List` interface (`java.util.List`):** The `productCatalog` field is declared with the `List<Product>` interface type: `private List<Product> productCatalog;`. This demonstrates programming to the interface rather than the specific implementation (`ArrayList`), promoting flexibility.
 * 
 * 4.  **`Scanner` (`java.util.Scanner`):** Used to read user input from `System.in` in the `runSystem` method and helper methods like `addProduct`, `placeOrder`.
 *     *   A single `Scanner` instance is created and managed.
 *     *   Using a try-with-resources block (`try (Scanner inputScanner = new Scanner(System.in))`) ensures the scanner is automatically closed when the `runSystem` method exits, preventing resource leaks.
 *     *   `scanner.nextInt()` reads integer input, and `scanner.nextLine()` is used to consume the leftover newline character after reading a number. `scanner.nextLine()` is also used for reading string inputs.
 * 
 * 5.  **`switch` statement:** Located in the `runSystem` method, the `switch` statement is used to direct the program flow based on the user's integer choice from the menu. Each case calls the corresponding private method (`addProduct`, `viewCatalog`, etc.).
 * 
 * 6.  **`System.err`:** Used specifically for printing error messages and validation failures, such as invalid input format, negative price/stock, insufficient stock, product not found, etc. This separates error output from normal program output (`System.out`).
 * 
 * 7.  **`System.out`:** Used for all normal program output, including the menu, product listings, success messages (product added, order placed, order processed), and messages indicating empty collections (catalog or queue).
 * 
 * 8.  **Class-wide `try-catch` blocks:**
 *     *   A main `try-catch(Exception e)` block wraps the core `while` loop within `runSystem`. This catches any unexpected runtime exceptions that might occur during program execution and prints a generic error message to `System.err`, preventing the program from crashing abruptly.
 *     *   Specific `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls to handle cases where the user enters non-integer input when an integer is expected. This prevents the program from throwing an exception and allows it to prompt the user again.
 *     *   Input validation within methods (`addProduct`, `placeOrder`) checks for invalid values (negative price/stock/quantity, empty strings, insufficient stock) using `if` statements and prints specific error messages to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** `Product` and `Order` classes have private fields with public getter methods. The `ECommerceSystem` class encapsulates the collections (`productCatalog`, `pendingOrders`) and the `Scanner`.
 * *   **Meaningful Names:** Variable names (`productCatalog`, `pendingOrders`, `productId`, `quantity`), method names (`addProduct`, `placeOrder`, `processNextOrder`), and class names (`Product`, `Order`, `ECommerceSystem`) are descriptive.
 * *   **Comments:** Javadoc comments explain the purpose of classes and methods. Inline comments explain specific logic points (like Scanner newline consumption or Queue iterator).
 * *   **Input Validation:** Checks are performed for valid data types (`InputMismatchException`), non-negative numbers, positive quantities, and non-empty strings.
 * *   **Error Handling:** A layered approach is used: specific validation checks within methods report errors to `System.err`, and a broader `try-catch` in the main loop handles unexpected exceptions.
 * *   **Clean Code Structure:** The code is organized into separate classes with distinct responsibilities. The `main` method is minimal, primarily starting the system loop. Helper methods (`displayMenu`, `findProductById`) keep the main logic cleaner.
 * 
 * This solution effectively integrates the required Java components into a functional simulation, demonstrating key concepts like data structure selection, object-oriented design, user interaction, and robust error handling. The use of interfaces (`List`, `Queue`) and specific exceptions (`InputMismatchException`) further highlights advanced understanding. The stock deduction logic during order placement and the queue-based processing simulate a realistic workflow.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // Needed to view queue contents without removing

// --- Product Class ---
/**
 * Represents a product in the e-commerce system.
 */
class Product {
    private String productId;
    private String name;
    private double price;
    private int stock;

    /**
     * Constructs a new Product.
     * @param productId The unique ID of the product.
     * @param name The name of the product.
     * @param price The price of the product.
     * @param stock The current stock quantity.
     */
    public Product(String productId, String name, double price, int stock) {
        this.productId = productId;
        this.name = name;
        this.price = price;
        this.stock = stock;
    }

    // Getters
    public String getProductId() {
        return productId;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getStock() {
        return stock;
    }

    // Setter for stock (used when placing orders)
    public void setStock(int stock) {
        this.stock = stock;
    }

    @Override
    public String toString() {
        return String.format("Product ID: %s, Name: %s, Price: %.2f, Stock: %d",
                             productId, name, price, stock);
    }
}

// --- Order Class ---
/**
 * Represents a customer order in the e-commerce system.
 */
class Order {
    private static int orderCounter = 0; // Simple counter for unique order IDs
    private String orderId;
    private String productId;
    private int quantity;

    /**
     * Constructs a new Order.
     * @param productId The ID of the product being ordered.
     * @param quantity The quantity of the product ordered.
     */
    public Order(String productId, int quantity) {
        this.orderId = "O" + (++orderCounter); // Generate simple unique ID
        this.productId = productId;
        this.quantity = quantity;
    }

    // Getters
    public String getOrderId() {
        return orderId;
    }

    public String getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return String.format("Order ID: %s, Product ID: %s, Quantity: %d",
                             orderId, productId, quantity);
    }
}

// --- ECommerceSystem Class ---
/**
 * Simulates the backend of an e-commerce system.
 * Manages product catalog and pending orders.
 */
public class ECommerceSystem {

    // Use List interface for catalog, implemented by ArrayList
    private List<Product> productCatalog;

    // Use Queue interface for pending orders, implemented by LinkedList
    private Queue<Order> pendingOrders;

    private Scanner scanner;

    /**
     * Constructs a new ECommerceSystem.
     * Initializes the catalog, order queue, and scanner.
     */
    public ECommerceSystem() {
        this.productCatalog = new ArrayList<>(); // Use ArrayList for the List
        this.pendingOrders = new LinkedList<>(); // Use LinkedList for the Queue
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- E-commerce System Menu ---");
        System.out.println("1. Add Product");
        System.out.println("2. View Catalog");
        System.out.println("3. Place Order");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new product to the catalog based on user input.
     * Handles input validation.
     */
    private void addProduct() {
        System.out.print("Enter Product ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Product Name: ");
        String name = scanner.nextLine();

        double price = -1;
        int stock = -1;

        // Input validation for price
        while (price < 0) {
            System.out.print("Enter Price: ");
            try {
                price = Double.parseDouble(scanner.nextLine());
                if (price < 0) {
                    System.err.println("Error: Price cannot be negative.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid price format. Please enter a number.");
            }
        }

        // Input validation for stock
        while (stock < 0) {
            System.out.print("Enter Stock: ");
            try {
                stock = Integer.parseInt(scanner.nextLine());
                if (stock < 0) {
                    System.err.println("Error: Stock cannot be negative.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid stock format. Please enter an integer.");
            }
        }

        // Basic validation for non-empty strings
        if (id.trim().isEmpty() || name.trim().isEmpty()) {
             System.err.println("Error: Product ID and Name cannot be empty.");
             return; // Exit method if basic validation fails
        }

        // Check for duplicate product ID (optional but good practice)
        for (Product p : productCatalog) {
            if (p.getProductId().equals(id)) {
                System.err.println("Error: Product with ID " + id + " already exists.");
                return; // Prevent adding duplicate ID
            }
        }


        Product newProduct = new Product(id, name, price, stock);
        productCatalog.add(newProduct);
        System.out.println("Product added successfully.");
    }

    /**
     * Displays all products in the catalog.
     */
    private void viewCatalog() {
        System.out.println("\n--- Product Catalog ---");
        if (productCatalog.isEmpty()) {
            System.out.println("Catalog is empty.");
        } else {
            for (Product product : productCatalog) {
                System.out.println(product);
            }
        }
    }

    /**
     * Finds a product by its ID in the catalog.
     * @param productId The ID to search for.
     * @return The Product object if found, null otherwise.
     */
    private Product findProductById(String productId) {
        for (Product product : productCatalog) {
            if (product.getProductId().equals(productId)) {
                return product;
            }
        }
        return null; // Product not found
    }

    /**
     * Places a new order based on user input.
     * Handles validation and stock deduction.
     */
    private void placeOrder() {
        System.out.print("Enter Product ID to order: ");
        String productId = scanner.nextLine();

        Product product = findProductById(productId);

        if (product == null) {
            System.err.println("Error: Product with ID " + productId + " not found.");
            return;
        }

        int quantity = -1;
         // Input validation for quantity
        while (quantity <= 0) {
            System.out.print("Enter Quantity: ");
            try {
                quantity = Integer.parseInt(scanner.nextLine());
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid quantity format. Please enter an integer.");
            }
        }


        if (product.getStock() < quantity) {
            System.err.println("Error: Insufficient stock for product " + product.getName() +
                               ". Available: " + product.getStock() + ", Requested: " + quantity);
            return;
        }

        // Deduct stock and create order
        product.setStock(product.getStock() - quantity);
        Order newOrder = new Order(productId, quantity);
        pendingOrders.offer(newOrder); // offer() is preferred over add() for queues
        System.out.println("Order placed successfully (" + newOrder.getOrderId() + "). Stock updated.");
    }

    /**
     * Processes the next order in the queue (removes it).
     */
    private void processNextOrder() {
        System.out.println("\n--- Processing Next Order ---");
        Order nextOrder = pendingOrders.poll(); // poll() retrieves and removes, returns null if empty

        if (nextOrder == null) {
            System.out.println("No pending orders to process.");
        } else {
            System.out.println("Processing order: " + nextOrder);
            System.out.println("Order processed.");
        }
    }

    /**
     * Displays all orders currently in the pending queue without removing them.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate over the queue without removing elements
            Iterator<Order> iterator = pendingOrders.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        }
    }

    /**
     * Runs the main e-commerce system loop.
     * Handles user interaction and general exception handling.
     */
    public void runSystem() {
        int choice = 0;
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner inputScanner = new Scanner(System.in)) {
             this.scanner = inputScanner; // Assign the auto-closable scanner

            while (choice != 6) {
                displayMenu();
                try {
                    // Read choice and handle potential non-integer input
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            addProduct();
                            break;
                        case 2:
                            viewCatalog();
                            break;
                        case 3:
                            placeOrder();
                            break;
                        case 4:
                            processNextOrder();
                            break;
                        case 5:
                            viewPendingOrders();
                            break;
                        case 6:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = 0; // Reset choice to continue loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging purposes
                }
            }
        } finally {
             // Scanner is automatically closed by try-with-resources
             // Any other cleanup could go here if needed
        }
    }

    /**
     * Main method to start the e-commerce system.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ECommerceSystem system = new ECommerceSystem();
        system.runSystem();
    }
}
