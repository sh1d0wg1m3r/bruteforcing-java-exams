/*
 * Exam Question #635
 * Generated on: 2025-05-12 16:18:03
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Warehouse Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks in a warehouse. The warehouse handles two main types of tasks: receiving incoming shipments and processing outgoing orders. Tasks must be processed in the order they are received (First-In, First-Out). The system should allow users to add new tasks, process the next pending task, and view a history of all completed tasks.
 * 
 * Your solution must be a well-structured Java program that adheres to best practices and utilizes specific Java components as listed below.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. Each task should have a unique ID, a type (e.g., "RECEIVE", "PROCESS"), a description, and a status (e.g., "PENDING", "COMPLETED"). Use proper encapsulation (private fields, public getters/setters where necessary, and a constructor).
 * 2.  **Task Management Logic:** Create a `WarehouseManager` class that encapsulates the core logic. This class should manage two collections: one for tasks that are waiting to be processed and one for tasks that have been completed.
 * 3.  **Pending Tasks:** Use a `java.util.Queue` to store tasks that are waiting to be processed. Tasks should be added to the end of the queue and processed from the front.
 * 4.  **Completed Tasks:** Use a `java.util.List` (specifically, instantiate it as a `java.util.ArrayList`) to store tasks once they have been processed. This list represents the history of completed tasks.
 * 5.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` to interact with the user. The program should present a menu with the following options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Completed Tasks History
 *     *   4. Exit
 * 6.  **Flow Control:** Use a `switch` statement to handle the user's menu choice.
 * 7.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and the list of completed tasks.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process a task when the queue is empty, errors during task creation/processing).
 * 8.  **Error Handling:** Implement robust error handling using `try-catch` blocks. This includes:
 *     *   Handling invalid user input (e.g., non-numeric input for menu choice).
 *     *   Handling cases where a task cannot be added (e.g., invalid type/description provided).
 *     *   Handling the case where the user tries to process a task but the pending queue is empty.
 *     *   Implement a class-wide `try-catch` block around the main interaction loop in your `WarehouseManager` (or main application class) to catch unexpected runtime exceptions.
 * 9.  **Input Validation:** Validate user input for task types and descriptions to ensure they are not empty or null.
 * 10. **Best Practices:** Ensure your code follows Java best practices, including meaningful variable and method names, appropriate comments (including Javadoc for classes/methods), and clean code structure.
 * 
 * **Expected Interaction (Example):**
 * 
 * ```
 * --- Warehouse Task Manager ---
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 1
 * Enter task type (RECEIVE/PROCESS): RECEIVE
 * Enter task description: Shipment from Vendor A
 * Task added: Task [ID=1, Type=RECEIVE, Status=PENDING, Description='Shipment from Vendor A']
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 1
 * Enter task type (RECEIVE/PROCESS): PROCESS
 * Enter task description: Order #1001 for Customer B
 * Task added: Task [ID=2, Type=PROCESS, Status=PENDING, Description='Order #1001 for Customer B']
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 2
 * Processing task: Task [ID=1, Type=RECEIVE, Status=PENDING, Description='Shipment from Vendor A']
 * Task completed: 1
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 2
 * Processing task: Task [ID=2, Type=PROCESS, Status=PENDING, Description='Order #1001 for Customer B']
 * Task completed: 2
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 3
 * 
 * --- Completed Task History ---
 * 1. Task [ID=1, Type=RECEIVE, Status=COMPLETED, Description='Shipment from Vendor A']
 * 2. Task [ID=2, Type=PROCESS, Status=COMPLETED, Description='Order #1001 for Customer B']
 * ------------------------------
 * 
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks History
 * 4. Exit
 * ------------
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Menu ---
 * ... (and so on)
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java source code for the application.
 *
 * EXPLANATION:
 * This solution implements the Warehouse Task Management System as described in the problem.
 * 
 * 1.  **Task Representation (`Task` class):**
 *     *   The `Task` class encapsulates the data for a single task: `taskId`, `type`, `description`, and `status`.
 *     *   `taskId` is automatically generated using `AtomicInteger` to ensure uniqueness across tasks.
 *     *   Fields are `private`, and public getter methods are provided for accessing the data. A `setStatus` method allows changing the task's status.
 *     *   The constructor includes input validation using `IllegalArgumentException` if type or description are null or empty.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **Task Management Logic (`WarehouseManager` class):**
 *     *   This class holds the two main data structures: `pendingTasks` (a `Queue`) and `completedTasks` (a `List`).
 *     *   `pendingTasks` is declared as a `Queue` and instantiated as a `LinkedList`. `LinkedList` is a common implementation of `Queue` that supports efficient FIFO operations (`offer` for adding to the tail, `poll` for removing from the head). This fulfills the `Queue` and `LinkedList` requirements.
 *     *   `completedTasks` is declared as a `List` and instantiated as an `ArrayList`. `ArrayList` is suitable for storing completed tasks where access by index or iteration is needed, fulfilling the `List` and `ArrayList` requirements.
 *     *   The class has methods `addNewTaskFromInput`, `processNextTask`, and `viewCompletedTasksHistory` corresponding to the menu options.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   The `WarehouseManager.run()` method contains the main application loop.
 *     *   A `Scanner` object (passed from `main`) is used to read user input from `System.in`. This fulfills the `Scanner` requirement.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice from the menu, fulfilling the `switch` requirement.
 *     *   `displayMenu()` is a helper method to print the menu options using `System.out`.
 * 
 * 4.  **Output and Error Handling:**
 *     *   `System.out` is used for all normal output, such as prompts, success messages, menu display, and the completed task history. This fulfills the `System.out` requirement.
 *     *   `System.err` is used specifically for printing error messages, such as invalid user input, attempting to process an empty queue, or errors caught during task creation/processing. This fulfills the `System.err` requirement.
 *     *   `try-catch` blocks are strategically placed:
 *         *   In `addNewTaskFromInput`, it catches `IllegalArgumentException` thrown by the `Task` constructor if input validation fails.
 *         *   In `processNextTask`, it catches `IllegalArgumentException` if setting the status fails (though less likely in this simple example).
 *         *   A large `try-catch` block surrounds the core logic inside the `while` loop in `run()`. This serves as the class-wide exception handling, catching any unexpected runtime errors that might occur during user interaction or method calls within the loop. This fulfills the class-wide `try-catch` requirement.
 *         *   The `main` method also has a `try-catch-finally` block to handle potential errors during the initial setup of the `Scanner` or `WarehouseManager` and ensures the `Scanner` is closed.
 * 
 * 5.  **Input Validation:**
 *     *   Basic input validation is done in the `Task` constructor to ensure type and description are not empty.
 *     *   In `WarehouseManager.run()`, `scanner.hasNextInt()` is used to check if the next input is an integer before attempting to read it with `scanner.nextInt()`. If not, an error is printed to `System.err`, the invalid input is consumed (`scanner.next()`), and the loop continues, preventing an `InputMismatchException`.
 *     *   The `switch` statement's `default` case handles integer inputs that are outside the valid menu range.
 *     *   Checks for empty `pendingTasks` queue and empty `completedTasks` list prevent errors when trying to process or view history, respectively.
 * 
 * 6.  **Best Practices:**
 *     *   The code is organized into logical classes (`Task`, `WarehouseManager`, `WarehouseApp`).
 *     *   Fields are `private` (`pendingTasks`, `completedTasks`, `scanner` in `WarehouseManager`, and fields in `Task`).
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `viewCompletedTasksHistory`).
 *     *   Comments, including Javadoc for classes and methods, explain the purpose and functionality.
 *     *   The `Scanner` resource is properly closed in the `finally` block in the `main` method.
 * 
 * This solution effectively demonstrates the required Java concepts and components in a practical, albeit simplified, application scenario, while adhering to good programming practices.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For unique Task IDs

/**
 * Represents a single task in the warehouse management system.
 * Tasks can be for receiving shipments or processing orders.
 */
class Task {
    private static final AtomicInteger idCounter = new AtomicInteger(); // To generate unique task IDs
    private final int taskId;
    private final String type; // e.g., "RECEIVE", "PROCESS"
    private final String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Task with a unique ID.
     * @param type The type of the task (e.g., "RECEIVE", "PROCESS"). Must not be null or empty.
     * @param description The description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if type or description are null or empty.
     */
    public Task(String type, String description) {
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Task type cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.taskId = idCounter.incrementAndGet();
        this.type = type.trim().toUpperCase(); // Store type in uppercase
        this.description = description.trim();
        this.status = "PENDING"; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    /**
     * Sets the status of the task.
     * @param status The new status (e.g., "COMPLETED"). Must not be null or empty.
     * @throws IllegalArgumentException if status is null or empty.
     */
    public void setStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
             throw new IllegalArgumentException("Status cannot be null or empty.");
        }
        this.status = status.trim().toUpperCase(); // Store status in uppercase
    }

    /**
     * Returns a string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Type=" + type + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the pending and completed tasks for the warehouse.
 * Uses a Queue for pending tasks (FIFO) and a List for completed task history.
 */
class WarehouseManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner; // Scanner is managed externally but passed in

    /**
     * Constructs a WarehouseManager.
     * @param scanner The Scanner object to use for user input.
     */
    public WarehouseManager(Scanner scanner) {
        // Requirement: Use Queue and instantiate as LinkedList
        this.pendingTasks = new LinkedList<>();
        // Requirement: Use List and instantiate as ArrayList
        this.completedTasks = new ArrayList<>();
        this.scanner = scanner;
    }

    /**
     * Adds a new task to the pending tasks queue based on user input.
     */
    public void addNewTaskFromInput() {
        System.out.print("Enter task type (RECEIVE/PROCESS): ");
        String type = scanner.nextLine().trim();

        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        try {
            // Input validation is done within the Task constructor
            Task newTask = new Task(type, description);
            pendingTasks.offer(newTask); // offer is the standard way to add to a queue
            System.out.println("Task added: " + newTask.toString());
        } catch (IllegalArgumentException e) {
            // Requirement: Use System.err for error messages
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the pending queue (FIFO).
     * Removes the task from the pending queue and adds it to the completed list.
     */
    public void processNextTask() {
        // Check if the queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("No pending tasks to process.");
            return;
        }

        // poll() retrieves and removes the head of the queue, returns null if empty (checked above)
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess.toString());
            try {
                // Simulate processing and update status
                taskToProcess.setStatus("COMPLETED");
                // Add the completed task to the history list
                completedTasks.add(taskToProcess);
                System.out.println("Task completed: " + taskToProcess.getTaskId());
            } catch (IllegalArgumentException e) {
                 // Requirement: Use System.err for error messages
                 System.err.println("Error marking task as completed: " + e.getMessage());
                 // Note: If status update fails, the task is removed from the queue but not added to completedTasks.
                 // A more complex system might handle this differently (e.g., retry, error queue).
            }
        }
    }

    /**
     * Displays the history of completed tasks from the completed tasks list.
     */
    public void viewCompletedTasksHistory() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }

        System.out.println("\n--- Completed Task History ---");
        // Requirement: Iterate and display from the List
        for (int i = 0; i < completedTasks.size(); i++) {
            Task task = completedTasks.get(i);
            System.out.println((i + 1) + ". " + task.toString());
        }
        System.out.println("------------------------------\n");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Completed Tasks History");
        System.out.println("4. Exit");
        System.out.println("------------");
    }

    /**
     * Runs the main interactive loop of the warehouse manager application.
     * Handles user input and calls appropriate methods.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Warehouse Task Manager ---");

        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter your choice: ");

                // Validate that the next input is an integer
                if (scanner.hasNextInt()) {
                     choice = scanner.nextInt();
                } else {
                     // Requirement: Use System.err for error messages
                     System.err.println("Invalid input. Please enter a number.");
                     scanner.next(); // Consume the invalid input token to prevent infinite loop
                     continue; // Skip the rest of the loop body and show menu again
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Requirement: Use a switch statement for flow control
                switch (choice) {
                    case 1:
                        addNewTaskFromInput();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewCompletedTasksHistory();
                        break;
                    case 4:
                        System.out.println("Exiting Warehouse Task Manager. Goodbye!");
                        running = false; // Set flag to exit loop
                        break; // Exit switch
                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (Exception e) {
                // Requirement: Class-wide exception handling
                // This catches any unexpected runtime exceptions within the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }
             System.out.println(); // Add a newline for better readability between menu interactions
        }
    }
}

/**
 * Main class to start the Warehouse Task Management application.
 * Responsible for initializing the Scanner and the WarehouseManager, and handling
 * potential errors during initialization.
 */
public class WarehouseApp {
     public static void main(String[] args) {
        Scanner scanner = null;
        try {
            // Requirement: Use Scanner for user input
            scanner = new Scanner(System.in);
            WarehouseManager manager = new WarehouseManager(scanner);
            manager.run(); // Start the main application loop
        } catch (Exception e) {
            // Catch block for errors during Scanner or Manager initialization
            // Requirement: Use System.err for error messages
            System.err.println("Fatal error initializing the application: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
        }
     }
}
