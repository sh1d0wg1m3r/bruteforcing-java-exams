/*
 * Exam Question #562
 * Generated on: 2025-05-11 23:29:52
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Scheduling System
 * 
 * **Objective:** Implement a simplified Task Scheduling System that manages a queue of pending tasks and a history of all tasks (pending and completed). The system should allow users to add new tasks, process the next task in the queue, view pending tasks, view completed tasks, and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): Represents the current status ("Pending" or "Completed").
 *     *   Implement appropriate private fields, a constructor, public getter methods for all attributes, a public setter for the status, and a `toString()` method for easy display.
 * 
 * 2.  **Task Scheduler Class:** Create a `TaskScheduler` class that manages the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed (pending tasks).
 *     *   A `List<Task>` (specifically using an `ArrayList` implementation) to keep a record of ALL tasks ever added to the system, regardless of their current status. Use the `List` interface type for declaration.
 *     *   A mechanism to generate unique task IDs (e.g., an internal counter).
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object, assigns a unique ID, sets status to "Pending", adds it to both the `Queue` and the `List`.
 *         *   `processNextTask()`: Retrieves and removes the next task from the `Queue`. If a task is retrieved, update its status to "Completed" in the `List` (you'll need to find the task in the list by its ID). Return the processed `Task` object, or `null` if the queue was empty.
 *         *   `viewPendingTasks()`: Returns a `List<Task>` containing all tasks currently in the system that have the status "Pending". (Hint: Iterate the `allTasks` list and filter by status).
 *         *   `viewCompletedTasks()`: Returns a `List<Task>` containing all tasks currently in the system that have the status "Completed". (Hint: Iterate the `allTasks` list and filter by status).
 *         *   `viewAllTasks()`: Returns the complete `List<Task>` containing all tasks.
 * 
 * 3.  **Main Application Logic:**
 *     *   In the `main` method (either within `TaskScheduler` or a separate class), create an instance of `TaskScheduler`.
 *     *   Use `Scanner` to interact with the user via the console.
 *     *   Present a menu of options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  View All Tasks
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task information, and success messages.
 *     *   Use `System.err` to print error messages (e.g., "Queue is empty, no task to process.", "Invalid input.").
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Handle `InputMismatchException` if the user enters non-integer input.
 *     *   Implement a class-wide `try-catch` block that wraps the main application loop in the `main` method to catch any unexpected exceptions during execution and print an error message to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc is encouraged).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and perform the requested actions, printing task details or error messages to the console (`System.out` or `System.err`) as appropriate.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View All Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task{taskId=1, description='Write report', status='Pending'}
 * 
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter task description: Code feature
 * Task added: Task{taskId=2, description='Code feature', status='Pending'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{taskId=1, description='Write report', status='Pending'}
 * Task{taskId=2, description='Code feature', status='Pending'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task{taskId=1, description='Write report', status='Completed'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{taskId=2, description='Code feature', status='Pending'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{taskId=1, description='Write report', status='Completed'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task{taskId=2, description='Code feature', status='Completed'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * System.err: Queue is empty, no task to process.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{taskId=1, description='Write report', status='Completed'}
 * Task{taskId=2, description='Code feature', status='Completed'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 7
 * System.err: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: abc
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Scheduler.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of specified components), robustness (error handling, input validation), code structure, and best practices.
 *
 * EXPLANATION:
 * The solution implements a `TaskScheduler` system according to the requirements, demonstrating the use of various Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It uses `private` fields (`taskId`, `description`, `status`) to enforce encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A public setter is provided for the `status` as it's the only attribute that changes after creation. Basic validation is included in the setter.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **TaskScheduler Class:**
 *     *   **`Queue<Task> pendingTasks`**: A `Queue` (specifically a `LinkedList`) is used to store tasks waiting for processing. This adheres to the FIFO (First-In, First-Out) principle, meaning tasks are processed in the order they were added. Methods like `offer()` (to add) and `poll()` (to retrieve and remove) are used, which are generally safer than `add()` and `remove()` as they return special values (`false`/`null`) instead of throwing exceptions on failure (like a capacity-constrained queue or empty queue).
 *     *   **`List<Task> allTasks`**: An `ArrayList` is used to store *all* tasks ever created. It's declared using the `List` interface type (`List<Task> allTasks = new ArrayList<>();`) to demonstrate using the interface rather than the specific implementation type where appropriate. This list serves as a historical record and allows viewing tasks by status (pending or completed) regardless of whether they are still in the processing queue.
 *     *   **`nextTaskId`**: A simple integer counter is used to generate unique IDs for new tasks, incrementing with each new task added.
 *     *   **`addTask(String description)`**: Creates a new `Task` object, adds it to both the `pendingTasks` queue (`offer()`) and the `allTasks` list (`add()`).
 *     *   **`processNextTask()`**: Uses `pendingTasks.poll()` to get the next task. If `poll()` returns a task (not null), it iterates through the `allTasks` list to find the *same* task object (or one with the same ID) and updates its status to "Completed". This ensures the status change is reflected in the main list of all tasks. If `poll()` returns `null`, it indicates an empty queue, and an error message is printed to `System.err`.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`**: These methods iterate through the `allTasks` list and filter tasks based on their `getStatus()` method, returning a *new* `List` containing only the tasks matching the requested status.
 *     *   **`viewAllTasks()`**: Simply returns the `allTasks` list.
 * 
 * 3.  **Main Application Logic (`run()` method and `main()`):**
 *     *   The `main` method creates a `TaskScheduler` instance and calls its `run()` method to start the application loop.
 *     *   **`Scanner`**: A `Scanner` object reads user input from `System.in`.
 *     *   **Menu and Loop**: A `while(running)` loop keeps the application alive until the user chooses to exit. The `displayMenu()` method shows the options.
 *     *   **Input Validation**: Before reading the integer choice, `scanner.hasNextInt()` checks if the next input token is an integer. If not, an error is printed to `System.err`, the invalid input is consumed, and the loop continues. If it *is* an integer, `scanner.nextInt()` reads it, and `scanner.nextLine()` is called immediately after to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls for task descriptions.
 *     *   **`switch` Statement**: The `switch` statement is used to direct the program flow based on the validated integer `choice`. Each case calls the appropriate method in the `TaskScheduler` instance.
 *     *   **`System.out` and `System.err`**: Used as required for normal output and error messages, respectively. Error messages like "Queue is empty" or "Invalid choice" go to `System.err`.
 *     *   **Class-wide `try-catch`**: The main `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This acts as a safety net to catch any unexpected runtime exceptions that might occur during the program's execution (beyond the specific input validation or empty queue checks). If such an exception occurs, a generic error message and the stack trace are printed to `System.err`, preventing the program from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `viewCompletedTasks`).
 *     *   Javadoc comments are included for classes and public methods.
 *     *   The code is structured logically with separate methods for different functionalities (displaying menu, running the loop, task operations).
 *     *   Input validation and specific error handling (empty queue) are implemented alongside the general `try-catch` block.
 * 
 * This solution effectively combines the required Java components to create a functional, albeit simple, task management system, demonstrating understanding of data structures, object-oriented principles, input handling, and error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the scheduling system.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // "Pending" or "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // Public getter methods
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Public setter method for status
    public void setStatus(String status) {
        // Basic validation for status
        if ("Pending".equals(status) || "Completed".equals(status)) {
            this.status = status;
        } else {
            System.err.println("Invalid status provided: " + status);
        }
    }

    @Override
    public String toString() {
        return "Task{" +
               "taskId=" + taskId +
               ", description='" + description + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Manages a collection of tasks using a Queue for pending tasks
 * and a List for all tasks.
 */
public class TaskScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> allTasks; // Using List interface, implemented by ArrayList
    private int nextTaskId;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();      // Using ArrayList for the List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the scheduler.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // Add to the end of the queue
        allTasks.add(newTask);       // Add to the list of all tasks
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Updates the task's status to "Completed" in the allTasks list.
     * @return The processed Task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Get and remove the head of the queue
        if (taskToProcess != null) {
            // Find the task in the allTasks list and update its status
            for (Task task : allTasks) {
                if (task.getTaskId() == taskToProcess.getTaskId()) {
                    task.setStatus("Completed");
                    break; // Found and updated
                }
            }
            System.out.println("Processed task: " + taskToProcess);
            return taskToProcess;
        } else {
            System.err.println("Queue is empty, no task to process.");
            return null;
        }
    }

    /**
     * Returns a list of all tasks with status "Pending".
     * @return A List of pending Tasks.
     */
    public List<Task> viewPendingTasks() {
        List<Task> pending = new ArrayList<>();
        for (Task task : allTasks) {
            if ("Pending".equals(task.getStatus())) {
                pending.add(task);
            }
        }
        return pending;
    }

    /**
     * Returns a list of all tasks with status "Completed".
     * @return A List of completed Tasks.
     */
    public List<Task> viewCompletedTasks() {
        List<Task> completed = new ArrayList<>();
        for (Task task : allTasks) {
            if ("Completed".equals(task.getStatus())) {
                completed.add(task);
            }
        }
        return completed;
    }

    /**
     * Returns the list of all tasks in the system.
     * @return The List of all Tasks.
     */
    public List<Task> viewAllTasks() {
        return allTasks;
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View All Tasks");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide try-catch block wrapping the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description != null && !description.trim().isEmpty()) {
                             addTask(description.trim());
                        } else {
                             System.err.println("Task description cannot be empty.");
                        }
                        break;
                    case 2:
                        processNextTask(); // Method already handles empty queue message
                        break;
                    case 3:
                        List<Task> pending = viewPendingTasks();
                        System.out.println("\n--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 4:
                        List<Task> completed = viewCompletedTasks();
                        System.out.println("\n--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 5:
                        List<Task> all = viewAllTasks();
                        System.out.println("\n--- All Tasks ---");
                        if (all.isEmpty()) {
                            System.out.println("No tasks in the system yet.");
                        } else {
                            for (Task task : all) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 6:
                        System.out.println("Exiting Task Scheduler.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Class-wide catch for unexpected runtime errors
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
