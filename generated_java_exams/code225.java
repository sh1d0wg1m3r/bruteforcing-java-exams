/*
 * Exam Question #225
 * Generated on: 2025-05-11 22:35:21
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:** You are tasked with building a simple command-line application to help a small team manage their tasks. The system should allow adding new tasks, processing the next task in line, and viewing tasks.
 * 
 * **Task Details:** Each task should have a unique integer ID, a description (String), a priority (HIGH, MEDIUM, or LOW), and a status (pending or completed).
 * 
 * **Processing Logic:** Tasks should be processed in a First-In, First-Out (FIFO) manner among pending tasks.
 * 
 * **User Interface:** The system should present a menu to the user and accept commands via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Implement a `Task` class with private fields for `id`, `description`, `priority`, and `isCompleted`. Include a constructor, public getters for all fields, a public method `markCompleted()`, and a `toString()` method that clearly displays the task details including its status (Pending/Completed).
 * 2.  **Priority Enumeration:** Define a `Priority` enum with constants `HIGH`, `MEDIUM`, and `LOW`.
 * 3.  **Task Management Logic:** Implement a `TaskManager` class responsible for managing the collection of tasks.
 *     *   It **must** use a `java.util.Queue<Task>` to hold tasks that are currently pending and awaiting processing. Use `java.util.LinkedList` as the concrete implementation for the Queue to ensure FIFO order.
 *     *   It **must** use a `java.util.List<Task>` (specifically a `java.util.ArrayList`) to keep track of ***all*** tasks ever added to the system (both pending and completed), allowing easy lookup by ID.
 *     *   It should maintain a counter for generating unique task IDs.
 *     *   It must have the following public methods:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task` object, assigns a unique ID, adds it to the list of all tasks, and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the task at the head of the pending queue. If successful, it finds this task in the list of all tasks (using its ID) and calls its `markCompleted()` method. This method should handle the case where the pending queue is empty.
 *         *   `getPendingTasks()`: Returns a `java.util.List<Task>` containing all tasks currently in the pending queue, preserving their order. This list should be a snapshot and not expose the internal queue structure directly.
 *         *   `getAllTasks()`: Returns an unmodifiable `java.util.List<Task>` containing all tasks ever added to the system.
 * 4.  **Main Application:** Implement a main application class (`TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Implement a menu-driven interface using a `switch` statement for the following options:
 *         *   `1`: Add New Task (prompts user for description and priority string).
 *         *   `2`: Process Next Pending Task.
 *         *   `3`: View All Tasks.
 *         *   `4`: View Pending Tasks.
 *         *   `5`: Exit.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu input, invalid priority string, attempting to process from an empty queue).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the main loop to handle potential issues such as:
 *         *   `NumberFormatException` for invalid menu input.
 *         *   `IllegalArgumentException` when converting a user-provided priority string to the `Priority` enum.
 *         *   `java.util.NoSuchElementException` when attempting to process a task from an empty queue.
 * 5.  **Best Practices:**
 *     *   Adhere to Java best practices: use appropriate access modifiers (private fields, public methods), meaningful names for classes, methods, variables, and enum constants.
 *     *   Include comments where necessary to explain complex logic or key sections.
 *     *   Validate user input where appropriate (specifically the priority string).
 *     *   Ensure proper resource management (close the `Scanner` when exiting).
 *     *   Structure your code logically into separate classes/enum.
 * 
 * **Expected Output:**
 * 
 * The program should guide the user through the menu options. When listing tasks, display their ID, description, priority, and status. Error messages should be distinct and printed to `System.err`. Success messages and general output should go to `System.out`. The application should gracefully handle errors and continue running until the user chooses to exit.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Pending Task
 * 3. View All Tasks
 * 4. View Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation slides
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully!
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Review project proposal
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added successfully!
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tasks ---
 * ID: 1, Desc: Prepare presentation slides, Priority: HIGH, Status: Pending
 * ID: 2, Desc: Review project proposal, Priority: MEDIUM, Status: Pending
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: ID: 1, Desc: Prepare presentation slides, Priority: HIGH, Status: Pending
 * Task ID 1 marked as completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tasks ---
 * ID: 2, Desc: Review project proposal, Priority: MEDIUM, Status: Pending
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- All Tasks ---
 * ID: 1, Desc: Prepare presentation slides, Priority: HIGH, Status: Completed
 * ID: 2, Desc: Review project proposal, Priority: MEDIUM, Status: Pending
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 9
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: ID: 2, Desc: Review project proposal, Priority: MEDIUM, Status: Pending
 * Task ID 2 marked as completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Assessment:** Your solution will be assessed on correctness, adherence to all requirements (including the use of specified Java components and best practices), error handling robustness, and code clarity.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System as required by the exam question. It demonstrates the use of all specified Java components and adheres to best practices.
 * 
 * **Key Components Used and Demonstrated:**
 * 
 * 1.  **`java.util.Queue`**: The `TaskManager` class uses a `Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList`. This correctly models the requirement for processing tasks in a FIFO (First-In, First-Out) manner. `pendingTasks.offer()` is used to add tasks to the end, and `pendingTasks.remove()` is used to get and remove the task from the front.
 * 2.  **`java.util.ArrayList`**: The `TaskManager` class uses a `java.util.ArrayList<Task>` (`allTasks`) to store a complete record of every task ever added to the system. This allows viewing all tasks, regardless of their completion status, and provides a way to locate a task by ID after it's processed from the queue.
 * 3.  **`java.util.List` interface**: The `allTasks` field is declared as `List<Task>`, demonstrating programming to the interface. Additionally, the `getPendingTasks()` and `getAllTasks()` methods return `List<Task>`, providing flexible return types while hiding the underlying concrete implementations (`LinkedList` for queue snapshot, `ArrayList` for all tasks). `Collections.unmodifiableList()` is used for `getAllTasks()` to enforce immutability from the caller's perspective, which is a good practice.
 * 4.  **`java.util.Scanner`**: The `TaskApp` class uses a `Scanner` object (`scanner`) to read user input from `System.in` for menu choices, task descriptions, and priorities.
 * 5.  **`switch` statement**: The `main` method in `TaskApp` uses a `switch` statement to control the program flow based on the user's integer menu choice.
 * 6.  **`System.err`**: Error messages, such as invalid input, invalid priority strings, or attempting to process from an empty queue, are printed to `System.err`, distinguishing them from normal program output.
 * 7.  **`System.out`**: All normal program output, including the menu, prompts, success messages, and task lists, is printed to `System.out`.
 * 8.  **Class-wide exception handling with `try-catch`**: The main `while` loop in `TaskApp.main` is wrapped in a `try-catch` block. This block handles potential `NumberFormatException` when parsing the menu choice. Inside the `switch` cases, specific operations that might fail (like `Priority.valueOf()` or `Queue.remove()`) are either handled directly within smaller `try-catch` blocks (though in this solution, `IllegalArgumentException` and `NoSuchElementException` are allowed to propagate to the main `try-catch` for a more centralized handling demonstration, which is also a valid "class-wide" approach in a simple `main` method context) or their potential exceptions are listed in the method signature (`processNextTask() throws NoSuchElementException`) to be caught by the caller (`main`). This demonstrates robust error handling that prevents the program from crashing due to common input or operational errors.
 * 
 * **Best Practices Implemented:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, with access provided through `public` methods (getters, `markCompleted`, `addTask`, etc.).
 * *   **Meaningful Names:** Class names (`Task`, `Priority`, `TaskManager`, `TaskApp`), variable names (`pendingTasks`, `allTasks`, `nextTaskId`, `description`, `priority`), method names (`addTask`, `processNextTask`, `getPendingTasks`, `getAllTasks`, `printMenu`, `viewAllTasks`), and enum constants (`HIGH`, `MEDIUM`, `LOW`) are descriptive and indicate their purpose.
 * *   **Appropriate Comments and Documentation:** Javadoc-style comments are used for class and method descriptions, explaining their purpose, parameters, and potential exceptions. Inline comments explain specific logic points.
 * *   **Input Validation:** The priority input string is validated indirectly by using `Priority.valueOf()`. If the string does not match a valid enum constant, `valueOf()` throws an `IllegalArgumentException`, which is caught and reported to the user via `System.err`. Menu input is validated by catching `NumberFormatException` and checking the integer range in the `switch`'s `default` case.
 * *   **Proper Error Handling:** Specific exceptions (`NumberFormatException`, `IllegalArgumentException`, `NoSuchElementException`) are caught and handled gracefully, providing informative messages to the user via `System.err`. A general `Exception` catch is included as a fallback for unexpected errors.
 * *   **Clean Code Structure:** The code is organized into logical classes (`Task`, `TaskManager`, `TaskApp`) and an enum (`Priority`), separating concerns (data representation, business logic, user interface). Helper methods (`printMenu`, `addTask`, etc.) are used in `TaskApp` to keep the `main` method clean and readable.
 * *   **Resource Management:** The `Scanner` object is explicitly closed before the application exits to release system resources.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating core object-oriented principles and robust error handling techniques expected at an advanced level.
 */

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Required for Queue.remove() exception

// 2. Priority Enumeration
enum Priority {
    HIGH, MEDIUM, LOW
}

// 1. Task Representation Class
class Task {
    private int id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    // Constructor
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Initially, tasks are not completed
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // Method to mark the task as completed
    public void markCompleted() {
        this.isCompleted = true;
    }

    // toString method for easy display
    @Override
    public String toString() {
        return String.format("ID: %d, Desc: %s, Priority: %s, Status: %s",
                             id, description, priority, isCompleted ? "Completed" : "Pending");
    }
}

// 3. Task Management Logic Class
class TaskManager {
    // Must use java.util.Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Must use java.util.List (specifically ArrayList) for all tasks
    private List<Task> allTasks;
    private int nextTaskId; // Counter for unique task IDs

    // Constructor
    public TaskManager() {
        // Use LinkedList for Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList for List implementation
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Creates a new Task object, adds it to the list of all tasks,
     * and adds it to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String description, Priority priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasks.offer(newTask); // Add to the pending queue (FIFO)
        System.out.println("Task added successfully! " + newTask);
    }

    /**
     * Processes the next pending task.
     * Removes the task at the head of the pending queue. If successful,
     * it finds this task in the list of all tasks and marks it as completed.
     * Throws NoSuchElementException if the pending queue is empty.
     */
    public void processNextTask() throws NoSuchElementException {
        // Queue.remove() throws NoSuchElementException if the queue is empty
        Task taskToProcess = pendingTasks.remove(); // Get and remove the head of the queue

        // Find the task in the allTasks list and mark it as completed
        // We iterate through allTasks to find the specific task object by ID
        // Alternatively, if Task had proper equals/hashCode based on ID, we could use allTasks.indexOf or similar,
        // but iterating is clearer here given we already have the taskToProcess object.
        for (Task task : allTasks) {
            if (task.getId() == taskToProcess.getId()) {
                task.markCompleted();
                System.out.println("Processing task: " + taskToProcess);
                System.out.println("Task ID " + task.getId() + " marked as completed.");
                return; // Task found and marked, exit loop
            }
        }
        // This part should ideally not be reached if the task was successfully removed from the queue,
        // as it must exist in allTasks. But as a safeguard:
        System.err.println("Error: Processed task not found in all tasks list (ID: " + taskToProcess.getId() + ")");
    }

    /**
     * Returns a List containing all tasks currently in the pending queue.
     * The returned list is a snapshot and does not modify the queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList to hold the pending tasks snapshot
        List<Task> pendingList = new ArrayList<>();
        // Iterate through the queue elements without removing them
        for (Task task : pendingTasks) {
            pendingList.add(task);
        }
        return pendingList; // Return the snapshot list
    }

    /**
     * Returns an unmodifiable List containing all tasks ever added to the system.
     * @return An unmodifiable List of all tasks.
     */
    public List<Task> getAllTasks() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableList(allTasks);
    }
}

// 4. Main Application Class
public class TaskApp {

    // Use Scanner for user input (class-wide for potential multiple uses if needed,
    // but main loop usage is sufficient here)
    private static Scanner scanner = new Scanner(System.in);
    private static TaskManager taskManager = new TaskManager();

    public static void main(String[] args) {
        boolean running = true;

        // Class-wide exception handling with try-catch blocks in the main loop
        while (running) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                // Read the entire line to avoid issues with nextInt/nextLine mix
                String inputLine = scanner.nextLine();
                int choice = Integer.parseInt(inputLine); // Potential NumberFormatException

                // Switch statement for menu options
                switch (choice) {
                    case 1: // Add New Task
                        addTask();
                        break;
                    case 2: // Process Next Pending Task
                        processTask();
                        break;
                    case 3: // View All Tasks
                        viewAllTasks();
                        break;
                    case 4: // View Pending Tasks
                        viewPendingTasks();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default: // Invalid menu choice
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Handle non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (IllegalArgumentException e) {
                // Handle invalid priority string input (caught during Priority.valueOf)
                System.err.println("Error adding task: " + e.getMessage());
            } catch (NoSuchElementException e) {
                 // Handle processing from an empty queue (caught from TaskManager.processNextTask)
                 System.err.println("Error: No pending tasks to process.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        // Ensure proper resource management: close the Scanner
        scanner.close();
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. Exit");
    }

    // Helper method for adding a task (Option 1)
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read description

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priorityString = scanner.nextLine().toUpperCase(); // Read priority and convert to uppercase

        // This part is within the main try-catch, so IllegalArgumentException from valueOf will be caught
        Priority priority = Priority.valueOf(priorityString); // Potential IllegalArgumentException

        taskManager.addTask(description, priority);
    }

    // Helper method for processing the next task (Option 2)
    private static void processTask() throws NoSuchElementException {
        // Call TaskManager method; NoSuchElementException is handled in main try-catch
        taskManager.processNextTask();
    }

    // Helper method for viewing all tasks (Option 3)
    private static void viewAllTasks() {
        List<Task> allTasks = taskManager.getAllTasks();
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("(No tasks added yet)");
        } else {
            for (Task task : allTasks) {
                System.out.println(task); // Uses Task.toString()
            }
        }
    }

    // Helper method for viewing pending tasks (Option 4)
    private static void viewPendingTasks() {
        List<Task> pendingTasks = taskManager.getPendingTasks();
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("(No pending tasks)");
        } else {
            for (Task task : pendingTasks) {
                System.out.println(task); // Uses Task.toString()
            }
        }
    }
}
