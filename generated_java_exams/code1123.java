/*
 * Exam Question #1123
 * Generated on: 2025-05-12 17:28:10
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Seating Management System**
 * 
 * You are tasked with developing a simplified Event Seating Management System. The system should allow managing attendees waiting to check in and assigning them to different seating sections within a venue.
 * 
 * **Scenario:**
 * 
 * An event has several seating sections (e.g., VIP, General). Attendees arrive and join a waiting line for check-in. Once checked in, they are assigned to a specific seating section if space is available. The system needs to manage the check-in queue, track seating availability, and provide status views.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a waiting line for attendees using a `java.util.Queue`.
 *     *   Maintain a list of all registered attendees using a `java.util.ArrayList`.
 *     *   Maintain a list of seating sections using a `java.util.List` (specifically, use `ArrayList` for the implementation).
 * 
 * 2.  **Classes:**
 *     *   `Attendee`: A class representing an attendee with a `name` (String) and a `status` (String, e.g., "WAITING", "CHECKED_IN", "SEATED"). Include appropriate getters and setters.
 *     *   `SeatingSection`: A class representing a seating section with a `name` (String), `capacity` (int), and `occupiedCount` (int). Include a method to check if space is available and a method to assign an attendee (increment `occupiedCount`). Include appropriate getters.
 *     *   `EventManager`: The main class that orchestrates the system. It should contain the `Queue` of waiting attendees, the `List` of registered attendees, and the `List` of seating sections. It will handle user interactions and system logic.
 * 
 * 3.  **Functionality (via a text-based menu):**
 *     *   **1. Add Attendee to Check-in Queue:** Prompt the user for an attendee name. If the attendee exists in the registered list and is not already waiting or seated, add them to the check-in queue.
 *     *   **2. Process Next Check-in:** Dequeue the next attendee from the check-in queue. Prompt the user for a seating section name. If the section exists and has space, assign the attendee to that section (update attendee status, increment section's occupied count). Handle cases where the queue is empty, the section is full, or the section name is invalid.
 *     *   **3. View Check-in Queue:** Display the names of all attendees currently in the check-in queue.
 *     *   **4. View Seating Status:** Display the name, capacity, and occupied count for each seating section.
 *     *   **5. Exit:** Terminate the program.
 * 
 * 4.  **Input Handling:**
 *     *   Use `java.util.Scanner` to read user input for menu choices, attendee names, and section names.
 *     *   Implement input validation where necessary (e.g., checking if a menu choice is a valid number).
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err.println()` for displaying error messages (e.g., "Invalid choice", "Attendee not found", "Queue is empty", "Section full", "Invalid section name").
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially around input processing and critical operations.
 * 
 * 6.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, prompts, status updates, and successful operation messages.
 * 
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments explaining the purpose of classes, methods, and complex logic.
 *     *   Structure the code clearly into separate classes.
 * 
 * **Initial Setup:**
 * 
 * *   Initialize the `EventManager` with a few predefined `Attendee` objects in the `registeredAttendees` list (all initially with status "REGISTERED").
 * *   Initialize the `EventManager` with a few predefined `SeatingSection` objects.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting the menu, accepting input, performing the requested action, and displaying status or results, including appropriate error messages using `System.err` and normal output using `System.out`.
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add Attendee to Check-in Queue
 * 2. Process Next Check-in
 * 3. View Check-in Queue
 * 4. View Seating Status
 * 5. Exit
 * Enter your choice:
 * ```
 * (Followed by output based on user interaction)
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Proper implementation of the required functionality.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Effective error handling and input validation.
 * *   Code readability and structure (naming, comments).
 * 
 * **Note:** Focus on implementing the core logic and using the required components effectively within the given constraints.
 *
 * EXPLANATION:
 * This solution implements a basic Event Seating Management System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee`: A simple class holding attendee `name` and `status`. Encapsulation is used with private fields and public getters/setters.
 *     *   `SeatingSection`: Manages a section's `name`, `capacity`, and `occupiedCount`. It provides methods to check availability (`hasSpace`) and assign attendees (`assignAttendee`), incrementing the occupied count.
 *     *   `EventManager`: This is the core class. It holds the main data structures and application logic.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue (java.util.Queue)`: The `checkInQueue` is declared as `Queue<Attendee>` and initialized using `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface. `offer()` is used to add elements (enqueue), `poll()` to remove the head (dequeue during check-in), and `peek()` to view the head without removing it.
 *     *   `ArrayList (java.util.ArrayList)`: Used explicitly to initialize the `registeredAttendees` list (`new ArrayList<>()`).
 *     *   `List interface (java.util.List)`: Used as the type declaration for `registeredAttendees` and `seatingSections`, demonstrating the use of the interface rather than the concrete implementation (`ArrayList`) where appropriate. The actual objects are `ArrayList` instances.
 *     *   `Scanner (java.util.Scanner)`: An instance `scanner` is created to read user input from `System.in`. `nextInt()` is used for the menu choice, and `nextLine()` is used for reading names and consuming the newline character after reading an integer.
 *     *   `Switch statement`: Used in the `run()` method to direct program flow based on the user's menu choice.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid menu choices, input errors, queue empty, section full, or not found issues. This differentiates errors from normal output.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, success messages, and status views.
 *     *   Class-wide exception handling with `try-catch`: A `try-catch` block wraps the main logic within the `while` loop in the `run()` method. It specifically catches `InputMismatchException` for invalid numeric input from `Scanner` and a general `Exception` to catch any other unexpected runtime errors, printing messages to `System.err`.
 * 
 * 3.  **Functionality Implementation:**
 *     *   The `EventManager` constructor initializes the data structures and populates the initial lists of attendees and sections.
 *     *   Methods like `addAttendeeToQueue`, `processNextCheckIn`, `viewCheckInQueue`, and `viewSeatingStatus` implement the menu options, interacting with the data structures and handling specific scenarios (e.g., attendee not found, queue empty, section full).
 *     *   Helper methods `findRegisteredAttendee` and `findSeatingSection` are used for locating objects by name.
 * 
 * 4.  **Best Practices:**
 *     *   Private fields in classes enforce encapsulation.
 *     *   Method names like `addAttendeeToQueue`, `processNextCheckIn`, `viewSeatingStatus` are descriptive.
 *     *   Comments are included to explain the purpose of classes, fields, and key methods.
 *     *   Input validation is present (e.g., checking if attendee/section exists, checking section capacity, handling `InputMismatchException`).
 *     *   Error handling uses `System.err` and `try-catch`.
 *     *   The code is structured into logical classes.
 * 
 * This solution provides a practical simulation of a real-world scenario while effectively demonstrating the required advanced Java concepts and best practices within a cohesive program.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class representing an Attendee
class Attendee {
    private String name;
    private String status; // e.g., "REGISTERED", "WAITING", "SEATED"

    public Attendee(String name) {
        this.name = name;
        this.status = "REGISTERED"; // Initial status
    }

    // Getters
    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    // Setters
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return name + " (" + status + ")";
    }
}

// Class representing a Seating Section
class SeatingSection {
    private String name;
    private int capacity;
    private int occupiedCount;
    // In a real system, you might store assigned attendees here,
    // but for simplicity, we only track the count.

    public SeatingSection(String name, int capacity) {
        this.name = name;
        this.capacity = capacity;
        this.occupiedCount = 0;
    }

    // Getters
    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    public int getOccupiedCount() {
        return occupiedCount;
    }

    // Method to check if space is available
    public boolean hasSpace() {
        return occupiedCount < capacity;
    }

    // Method to assign an attendee (increment occupied count)
    public boolean assignAttendee() {
        if (hasSpace()) {
            occupiedCount++;
            return true;
        }
        return false; // Section is full
    }

    @Override
    public String toString() {
        return name + " [Capacity: " + capacity + ", Occupied: " + occupiedCount + ", Available: " + (capacity - occupiedCount) + "]";
    }
}

// Main class managing the event logic
public class EventManager {
    // Required: Queue for attendees waiting to check in
    private Queue<Attendee> checkInQueue;
    // Required: List for all registered attendees
    private List<Attendee> registeredAttendees;
    // Required: List for seating sections (using ArrayList implementation)
    private List<SeatingSection> seatingSections;
    // Required: Scanner for user input
    private Scanner scanner;

    public EventManager() {
        // Initialize required data structures
        this.checkInQueue = new LinkedList<>(); // LinkedList implements Queue
        this.registeredAttendees = new ArrayList<>(); // Required: ArrayList
        this.seatingSections = new ArrayList<>(); // Required: List interface, ArrayList implementation
        this.scanner = new Scanner(System.in);

        // --- Initial Setup ---
        // Add sample registered attendees
        registeredAttendees.add(new Attendee("Alice"));
        registeredAttendees.add(new Attendee("Bob"));
        registeredAttendees.add(new Attendee("Charlie"));
        registeredAttendees.add(new Attendee("David"));
        registeredAttendees.add(new Attendee("Eve"));

        // Add sample seating sections
        seatingSections.add(new SeatingSection("VIP", 2));
        seatingSections.add(new SeatingSection("General", 5));
        seatingSections.add(new SeatingSection("Balcony", 3));
    }

    // Method to find an attendee by name in the registered list
    private Attendee findRegisteredAttendee(String name) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getName().equalsIgnoreCase(name)) {
                return attendee;
            }
        }
        return null; // Attendee not found
    }

    // Method to find a seating section by name
    private SeatingSection findSeatingSection(String name) {
        for (SeatingSection section : seatingSections) {
            if (section.getName().equalsIgnoreCase(name)) {
                return section;
            }
        }
        return null; // Section not found
    }

    // Functionality: Add Attendee to Check-in Queue
    private void addAttendeeToQueue() {
        System.out.print("Enter name of attendee to add to queue: ");
        String name = scanner.nextLine();

        Attendee attendee = findRegisteredAttendee(name);

        if (attendee == null) {
            System.err.println("Error: Attendee '" + name + "' not found in registered list.");
        } else if (attendee.getStatus().equals("WAITING")) {
            System.err.println("Error: Attendee '" + name + "' is already in the check-in queue.");
        } else if (attendee.getStatus().equals("SEATED")) {
             System.err.println("Error: Attendee '" + name + "' is already seated.");
        }
        else {
            checkInQueue.offer(attendee); // Add to the end of the queue
            attendee.setStatus("WAITING");
            System.out.println("Attendee '" + name + "' added to check-in queue.");
        }
    }

    // Functionality: Process Next Check-in
    private void processNextCheckIn() {
        if (checkInQueue.isEmpty()) {
            System.err.println("Error: The check-in queue is empty.");
            return;
        }

        Attendee currentAttendee = checkInQueue.peek(); // Get the head without removing
        System.out.println("Processing check-in for: " + currentAttendee.getName());

        System.out.print("Enter seating section name for " + currentAttendee.getName() + ": ");
        String sectionName = scanner.nextLine();

        SeatingSection section = findSeatingSection(sectionName);

        if (section == null) {
            System.err.println("Error: Seating section '" + sectionName + "' not found.");
        } else if (!section.hasSpace()) {
            System.err.println("Error: Seating section '" + sectionName + "' is full.");
        } else {
            // Successfully assign attendee
            checkInQueue.poll(); // Remove from queue
            section.assignAttendee(); // Assign to section
            currentAttendee.setStatus("SEATED"); // Update attendee status
            System.out.println(currentAttendee.getName() + " successfully checked in and assigned to section '" + section.getName() + "'.");
        }
    }

    // Functionality: View Check-in Queue
    private void viewCheckInQueue() {
        System.out.println("\n--- Check-in Queue ---");
        if (checkInQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Attendee attendee : checkInQueue) {
                System.out.println(i++ + ". " + attendee.getName());
            }
        }
        System.out.println("----------------------\n");
    }

    // Functionality: View Seating Status
    private void viewSeatingStatus() {
        System.out.println("\n--- Seating Status ---");
        if (seatingSections.isEmpty()) {
            System.out.println("No seating sections defined.");
        } else {
            for (SeatingSection section : seatingSections) {
                System.out.println(section); // Uses SeatingSection's toString()
            }
        }
        System.out.println("----------------------\n");
    }

    // Main application loop
    public void run() {
        int choice = -1;
        while (choice != 5) {
            printMenu();
            try {
                // Required: Scanner for user input
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Required: Switch statement for flow control
                switch (choice) {
                    case 1:
                        addAttendeeToQueue();
                        break;
                    case 2:
                        processNextCheckIn();
                        break;
                    case 3:
                        viewCheckInQueue();
                        break;
                    case 4:
                        viewSeatingStatus();
                        break;
                    case 5:
                        System.out.println("Exiting Event Management System. Goodbye!");
                        break;
                    default:
                        // Required: System.err for error messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Required: Class-wide exception handling with try-catch
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                 // Required: Class-wide exception handling with try-catch
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to err
            }
            System.out.println(); // Add a newline for better formatting
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Method to print the menu
    private void printMenu() {
        // Required: System.out for normal output
        System.out.println("--- Event Management Menu ---");
        System.out.println("1. Add Attendee to Check-in Queue");
        System.out.println("2. Process Next Check-in");
        System.out.println("3. View Check-in Queue");
        System.out.println("4. View Seating Status");
        System.out.println("5. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
