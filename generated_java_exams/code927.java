/*
 * Exam Question #927
 * Generated on: 2025-05-12 17:00:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Production Line Task Management System**
 * 
 * You are tasked with developing a simple command-line application to simulate a production line's task management system. The system should manage incoming tasks, process them in order, and keep track of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "PENDING", "COMPLETED").
 *     *   Include a constructor and public getter methods for these fields.
 * 
 * 2.  **Task Management System:** Create a class named `ProductionLineManager`. This class will manage the tasks.
 *     *   It must contain a `java.util.Queue` to hold tasks that are waiting to be processed (the "pending tasks queue").
 *     *   It must contain a `java.util.List` (specifically, use `ArrayList` but declare the field as `List`) to hold tasks that have been completed (the "completed tasks list").
 *     *   Implement the following functionalities via methods:
 *         *   `addTask(String description)`: Creates a new `Task` object with a unique ID, "PENDING" status, and the given description. Adds this task to the pending tasks queue. Assign unique IDs sequentially starting from 1.
 *         *   `processNextTask()`: Removes the task at the front of the pending tasks queue, updates its status to "COMPLETED", and adds it to the completed tasks list. If the queue is empty, report an error.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending tasks queue.
 *         *   `viewCompletedTasks()`: Displays all tasks currently in the completed tasks list.
 * 
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in the `main` method of `ProductionLineManager`. The program should present a menu of options to the user:
 *     *   1: Add New Task
 *     *   2: Process Next Task
 *     *   3: View Pending Tasks
 *     *   4: View Completed Tasks
 *     *   5: Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Input Handling and Validation:**
 *     *   When adding a task, prompt the user for the task description. Ensure the description is not empty.
 *     *   Handle potential `InputMismatchException` if the user enters non-integer input for the menu choice.
 *     *   Handle the case where the user tries to process a task when the pending queue is empty.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task details, and successful operation messages.
 *     *   Use `System.err` for printing error messages (e.g., invalid menu choice, empty task description, trying to process from an empty queue, invalid input type).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle errors like invalid input format.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Format:**
 * 
 * *   Menu should be clearly displayed.
 * *   Task details should be displayed in a readable format (e.g., "ID: [id], Description: [desc], Status: [status]").
 * *   Error messages should clearly indicate the problem.
 * *   Success messages (e.g., "Task added.", "Task processed.") are encouraged.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Production Line Manager ---
 * 1: Add New Task
 * 2: Process Next Task
 * 3: View Pending Tasks
 * 4: View Completed Tasks
 * 5: Exit
 * Enter your choice: 1
 * Enter task description: Assemble component A
 * Task added.
 * 
 * --- Production Line Manager ---
 * ... (menu again) ...
 * Enter your choice: 1
 * Enter task description: Test unit B
 * Task added.
 * 
 * --- Production Line Manager ---
 * ... (menu again) ...
 * Enter your choice: 3
 * Pending Tasks:
 * ID: 1, Description: Assemble component A, Status: PENDING
 * ID: 2, Description: Test unit B, Status: PENDING
 * 
 * --- Production Line Manager ---
 * ... (menu again) ...
 * Enter your choice: 2
 * Task processed: ID: 1, Description: Assemble component A
 * 
 * --- Production Line Manager ---
 * ... (menu again) ...
 * Enter your choice: 4
 * Completed Tasks:
 * ID: 1, Description: Assemble component A, Status: COMPLETED
 * 
 * --- Production Line Manager ---
 * ... (menu again) ...
 * Enter your choice: 5
 * Exiting Production Line Manager.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `ProductionLineManager` that simulates a simple task processing flow using core Java collections and control structures.
 * 
 * 1.  **`Task` Class:**
 *     *   This class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It demonstrates **encapsulation** by keeping its fields `private` and providing `public` getter methods.
 *     *   A `setStatus` method is included to allow updating the status when the task is processed.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`ProductionLineManager` Class:**
 *     *   It contains the main logic for managing tasks.
 *     *   `taskQueue`: A `java.util.Queue<Task>` is used to store pending tasks. `LinkedList` is a common implementation of `Queue` and is suitable here because we need efficient adding to the end (`add`) and removing from the front (`poll`). This correctly models a waiting line or queue where tasks are processed in the order they arrive (FIFO - First-In, First-Out).
 *     *   `completedTasks`: A `java.util.List<Task>` is used to store completed tasks. `ArrayList` is used as the concrete implementation, but the field is declared as `List` to demonstrate **programming to the interface**, which promotes flexibility.
 *     *   `nextTaskId`: An integer counter is used to generate unique IDs for new tasks, ensuring each task can be uniquely identified.
 * 
 * 3.  **Methods:**
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `taskQueue`. It includes **input validation** to check for empty descriptions and uses `System.err` for the error message.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. It checks if the queue is empty first, printing an error to `System.err` if it is. If a task is retrieved, its status is updated, and it's added to the `completedTasks` list.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections and print the task details using `System.out`. `taskQueue.forEach()` is used to iterate the queue without removing elements.
 *     *   `displayMenu()`: A helper method to print the user options to `System.out`.
 *     *   `run()`: Contains the main application loop. It uses a `Scanner` to read user input.
 * 
 * 4.  **User Interface and Flow Control:**
 *     *   The `run()` method uses a `while` loop to keep the application running until the user chooses to exit.
 *     *   `Scanner` is used to read integer input for the menu choice and string input for the task description.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, executing the corresponding management method.
 * 
 * 5.  **Error Handling:**
 *     *   **Input Validation:** Checks for empty task descriptions and empty queues before processing. Error messages go to `System.err`.
 *     *   **Exception Handling (`try-catch`):** A `try-catch` block wraps the `scanner.nextInt()` call within the main loop. This specifically catches `InputMismatchException` if the user enters non-numeric input for the menu choice, preventing the program from crashing and printing an informative error message to `System.err`. The `scanner.next()` call inside the catch block is crucial to consume the invalid input and avoid an infinite loop. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime issues, printing to `System.err`.
 *     *   **`System.out` vs. `System.err`:** `System.out` is used for normal program output (menu, task details, success messages), while `System.err` is reserved for error messages, following standard practice.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Clearly demonstrated in the `Task` class and the private fields of `ProductionLineManager`.
 *     *   **Meaningful Names:** Variable names (`taskQueue`, `completedTasks`, `nextTaskId`, `description`, `status`) and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `run`) are descriptive.
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Clean Code Structure:** The code is organized into logical methods, and the `Task` class is separate from the `ProductionLineManager` class. The `main` method simply creates an instance of the manager and calls its `run` method.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating advanced understanding through proper design, error handling, and adherence to best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the production line
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    // Constructor
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the production line tasks
public class ProductionLineManager {

    // Queue for tasks waiting to be processed
    private Queue<Task> taskQueue;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    // Constructor
    public ProductionLineManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.add(newTask);
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue, moving it to completed.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        Task taskToProcess = taskQueue.poll(); // Removes and returns the head of the queue
        if (taskToProcess != null) {
            taskToProcess.setStatus("COMPLETED"); // Update status
            completedTasks.add(taskToProcess); // Add to completed list
            System.out.println("Task processed: " + taskToProcess);
        } else {
             // This case should ideally not happen with isEmpty() check, but good practice
             System.err.println("Error: Failed to retrieve task from queue.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Production Line Manager ---");
        System.out.println("1: Add New Task");
        System.out.println("2: Process Next Task");
        System.out.println("3: View Pending Tasks");
        System.out.println("4: View Completed Tasks");
        System.out.println("5: Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = 0;
        boolean running = true;

        while (running) {
            displayMenu();

            // Class-wide exception handling for scanner input
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character

                // Switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Production Line Manager.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }

    // Main method to start the application
    public static void main(String[] args) {
        ProductionLineManager manager = new ProductionLineManager();
        manager.run();
    }
}
