/*
 * Exam Question #569
 * Generated on: 2025-05-11 23:30:44
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Vehicle Service Center Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage vehicles in a service center. The system needs to handle vehicles arriving for service, moving them through a waiting queue, performing services, and keeping track of service history.
 * 
 * **Requirements:**
 * 
 * 1.  **Vehicle Representation:** Create a `Vehicle` class to represent a vehicle. It should have:
 *     *   A unique `String` ID.
 *     *   A `String` model.
 *     *   A `List` of `ServiceRecord` objects representing its service history.
 *     *   Appropriate constructor, getters, and a method to add a service record.
 * 
 * 2.  **Service Record Representation:** Create a `ServiceRecord` class to represent a completed service. It should have:
 *     *   A `String` description of the service performed.
 *     *   A `double` cost of the service.
 *     *   A timestamp (e.g., using `java.time.LocalDateTime`) when the service was recorded.
 *     *   Appropriate constructor and getters.
 * 
 * 3.  **Service Center Logic:** Create a `ServiceCenter` class to manage the overall process. It should contain:
 *     *   A `Queue` of `Vehicle` objects representing vehicles waiting for service.
 *     *   A `List` of *all* `Vehicle` objects ever managed by the center (for history lookup).
 *     *   A `Vehicle` object representing the vehicle currently being serviced (can be `null`).
 *     *   Methods for the following operations:
 *         *   `addVehicleToQueue(Vehicle vehicle)`: Adds a new vehicle to the list of all vehicles and to the waiting queue. Should prevent adding vehicles with duplicate IDs.
 *         *   `startNextService()`: Moves the first vehicle from the waiting queue to the `currentlyServicing` state. Throws a custom exception if the queue is empty.
 *         *   `performService(String description, double cost)`: Adds a `ServiceRecord` to the `currentlyServicing` vehicle. Throws a custom exception if no vehicle is currently being serviced.
 *         *   `viewServiceHistory(String vehicleId)`: Finds a vehicle by its ID in the list of all vehicles and prints its service history. Throws a custom exception if the vehicle is not found.
 *         *   `listWaitingQueue()`: Prints the IDs and models of vehicles currently in the waiting queue.
 * 
 * 4.  **Main Application Flow:** Create a `Main` class with a `main` method to run the application.
 *     *   Use a `Scanner` to read commands from the user.
 *     *   Implement a command loop that accepts the following commands:
 *         *   `ADD <vehicleId> <model>`: Add a new vehicle to the system and queue.
 *         *   `START`: Start servicing the next vehicle in the queue.
 *         *   `SERVICE <description> <cost>`: Record a service for the currently serviced vehicle.
 *         *   `HISTORY <vehicleId>`: View the service history for a specific vehicle.
 *         *   `QUEUE`: List vehicles currently in the waiting queue.
 *         *   `EXIT`: Terminate the application.
 *     *   Use a `switch` statement to process the commands.
 * 
 * 5.  **Error Handling:**
 *     *   Implement custom exceptions for specific error conditions (e.g., `QueueEmptyException`, `NoVehicleCurrentlyServicingException`, `VehicleNotFoundException`, `DuplicateVehicleIdException`).
 *     *   Use `try-catch` blocks in the `main` method to catch these custom exceptions and standard exceptions (like `InputMismatchException` for invalid input) and print informative error messages using `System.err`.
 *     *   Use `System.out` for all normal output (prompts, confirmations, lists, history).
 * 
 * 6.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`).
 *     *   Provide meaningful variable and method names.
 *     *   Include basic comments where necessary.
 *     *   Perform basic input validation (e.g., checking if required arguments are provided, handling non-numeric input for cost).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Successful commands should print confirmations or requested information to `System.out`. Errors (invalid commands, missing arguments, non-existent vehicles, empty queue, etc.) should print messages to `System.err`.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): ADD V001 Sedan
 * Vehicle V001 (Sedan) added to queue.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): ADD V002 SUV
 * Vehicle V002 (SUV) added to queue.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): QUEUE
 * Waiting Queue:
 * - V001 (Sedan)
 * - V002 (SUV)
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): START
 * Started servicing vehicle V001 (Sedan).
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): QUEUE
 * Waiting Queue:
 * - V002 (SUV)
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): SERVICE Oil Change 55.50
 * Service 'Oil Change' ($55.50) recorded for V001.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): SERVICE Tire Rotation 30
 * Service 'Tire Rotation' ($30.00) recorded for V001.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): HISTORY V001
 * Service History for V001 (Sedan):
 * - [YYYY-MM-DDTHH:MM:SS.SSS] Oil Change ($55.50)
 * - [YYYY-MM-DDTHH:MM:SS.SSS] Tire Rotation ($30.00)
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): HISTORY V999
 * Error: Vehicle with ID V999 not found.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): START
 * Started servicing vehicle V002 (SUV).
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): START
 * Error: Waiting queue is empty.
 * Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): EXIT
 * Exiting Service Center application.
 * ```
 * 
 * **Constraint Checklist & Component Usage:**
 * 
 * *   `Queue` (java.util.Queue): Used in `ServiceCenter` for the waiting queue.
 * *   `ArrayList` (java.util.ArrayList): Used in `Vehicle` for service history and in `ServiceCenter` for the list of all vehicles.
 * *   `List` interface (java.util.List): Used for type hinting in methods/fields dealing with lists (`List<ServiceRecord>`, `List<Vehicle>`).
 * *   `Scanner` (java.util.Scanner): Used in `Main` for reading user input.
 * *   `Switch statement`: Used in `Main` to handle different commands.
 * *   `System.err`: Used in `Main`'s `catch` blocks for error messages.
 * *   `System.out`: Used in `Main` for normal output.
 * *   Class-wide exception handling with `try-catch`: Implemented in the `main` loop to catch exceptions from `ServiceCenter` methods and `Scanner`.
 * 
 * Your solution should provide the complete Java code for all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple Vehicle Service Center Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `ServiceRecord`: Represents a single service performed on a vehicle, storing description, cost, and the timestamp. It uses a `LocalDateTime` for the date.
 *     *   `Vehicle`: Represents a vehicle in the system. It stores a unique ID, model, and a `List<ServiceRecord>` (specifically an `ArrayList`) to maintain its history.
 *     *   `ServiceCenter`: The core class managing the service center operations. It holds a `Queue<Vehicle>` (`LinkedList` implementation) for vehicles waiting, a `List<Vehicle>` (`ArrayList` implementation) of all vehicles known to the system (for history lookup), and a `Vehicle` reference for the one currently being serviced.
 *     *   `Main`: The entry point of the application. It contains the main loop, command processing, user input handling using `Scanner`, and class-wide exception handling.
 * 
 * 2.  **Component Usage:**
 *     *   **`Queue` (`java.util.Queue`)**: The `waitingQueue` in `ServiceCenter` is declared as a `Queue<Vehicle>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of the `Queue` interface, providing methods like `offer()` (to add to the end) and `poll()` (to remove from the front). This correctly models a waiting line where vehicles are serviced in FIFO (First-In, First-Out) order.
 *     *   **`ArrayList` (`java.util.ArrayList`)**: Used in two places:
 *         *   Inside the `Vehicle` class for the `serviceHistory` field. `ArrayList` provides dynamic resizing and efficient element addition/retrieval by index, suitable for storing a list of service records.
 *         *   Inside the `ServiceCenter` class for the `allVehicles` list. This list keeps track of every vehicle registered, allowing history lookup (`HISTORY` command) even if the vehicle is not currently in the queue or being serviced.
 *     *   **`List` interface (`java.util.List`)**: Used as the type declaration for `serviceHistory` in `Vehicle` and `allVehicles` in `ServiceCenter`. This promotes good practice by programming to the interface rather than the specific implementation (`ArrayList`), making the code more flexible if a different `List` implementation were needed in the future.
 *     *   **`Scanner` (`java.util.Scanner`)**: Used in the `Main` class to read user commands and arguments from standard input (`System.in`). The `nextLine()` method reads the entire line, which is then split to parse commands and arguments.
 *     *   **`Switch statement`**: Used in the `Main` class's command loop to dispatch execution based on the user-entered command string (`ADD`, `START`, `SERVICE`, `HISTORY`, `QUEUE`, `EXIT`). This provides a clean and readable way to handle multiple distinct command options.
 *     *   **`System.err`**: Used exclusively within the `catch` blocks in the `Main` method's loop to print error messages. This differentiates error output from normal application messages (`System.out`), which is a standard practice.
 *     *   **`System.out`**: Used for all successful operations, prompts, confirmations, and data displays (like the queue list or service history).
 *     *   **Class-wide exception handling with `try-catch`**: The main `while` loop in `Main` is wrapped in a `try-catch` block. Methods in `ServiceCenter` throw specific custom exceptions (`QueueEmptyException`, `NoVehicleCurrentlyServicingException`, `VehicleNotFoundException`, `DuplicateVehicleIdException`) and standard exceptions (`IllegalArgumentException`). The `catch` blocks in `Main` intercept these exceptions, print informative messages to `System.err`, and allow the program to continue running for the next command, preventing a crash. A general `Exception` catch is included as a fallback for unexpected errors.
 * 
 * 3.  **Error Handling and Input Validation:**
 *     *   Custom exceptions are defined for specific operational errors, making the error types clear.
 *     *   Methods in `ServiceCenter` throw these exceptions when preconditions are not met (e.g., queue is empty for `START`, no vehicle is being serviced for `SERVICE`, vehicle ID not found for `HISTORY`, duplicate ID for `ADD`).
 *     *   Basic input validation is done within the `Main` loop (checking number of arguments for commands) and within class constructors/methods (checking for empty strings, negative cost).
 *     *   `NumberFormatException` is specifically caught when parsing the `cost` argument for the `SERVICE` command.
 *     *   The `Scanner` is closed upon exiting the loop.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Vehicle`, `ServiceRecord`, and `ServiceCenter` are `private`. Public methods (`getters`, `addServiceRecord`, operational methods) provide controlled access.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `waitingQueue`, `startNextService`, `viewServiceHistory`).
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, and custom exceptions.
 *     *   **Readability:** The code is structured logically into classes, and the `switch` statement in `Main` makes the command processing flow easy to follow.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, exception handling, and basic I/O in Java.
 */

import java.util.*;
import java.time.LocalDateTime;
import java.util.concurrent.LinkedListBlockingQueue; // Could use LinkedList directly for Queue interface
import java.util.LinkedList; // Using LinkedList as a Queue implementation

// Custom Exceptions
class QueueEmptyException extends Exception {
    public QueueEmptyException(String message) {
        super(message);
    }
}

class NoVehicleCurrentlyServicingException extends Exception {
    public NoVehicleCurrentlyServicingException(String message) {
        super(message);
    }
}

class VehicleNotFoundException extends Exception {
    public VehicleNotFoundException(String message) {
        super(message);
    }
}

class DuplicateVehicleIdException extends Exception {
    public DuplicateVehicleIdException(String message) {
        super(message);
    }
}

// Represents a completed service record
class ServiceRecord {
    private String description;
    private double cost;
    private LocalDateTime date;

    public ServiceRecord(String description, double cost) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Service description cannot be empty.");
        }
        if (cost < 0) {
            throw new IllegalArgumentException("Service cost cannot be negative.");
        }
        this.description = description;
        this.cost = cost;
        this.date = LocalDateTime.now();
    }

    public String getDescription() {
        return description;
    }

    public double getCost() {
        return cost;
    }

    public LocalDateTime getDate() {
        return date;
    }

    @Override
    public String toString() {
        return String.format("[%s] %s ($%.2f)", date.toString(), description, cost);
    }
}

// Represents a vehicle
class Vehicle {
    private String id;
    private String model;
    private List<ServiceRecord> serviceHistory; // Uses List interface, implemented by ArrayList

    public Vehicle(String id, String model) {
        if (id == null || id.trim().isEmpty()) {
             throw new IllegalArgumentException("Vehicle ID cannot be empty.");
        }
         if (model == null || model.trim().isEmpty()) {
             throw new IllegalArgumentException("Vehicle model cannot be empty.");
        }
        this.id = id;
        this.model = model;
        this.serviceHistory = new ArrayList<>(); // Uses ArrayList implementation
    }

    public String getId() {
        return id;
    }

    public String getModel() {
        return model;
    }

    public List<ServiceRecord> getServiceHistory() {
        // Return a copy to prevent external modification
        return new ArrayList<>(serviceHistory);
    }

    public void addServiceRecord(ServiceRecord record) {
        if (record != null) {
            this.serviceHistory.add(record);
        }
    }

    @Override
    public String toString() {
        return id + " (" + model + ")";
    }
}

// Manages the service center operations
class ServiceCenter {
    private Queue<Vehicle> waitingQueue; // Uses Queue interface
    private List<Vehicle> allVehicles; // Uses List interface, implemented by ArrayList
    private Vehicle currentlyServicing;

    public ServiceCenter() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allVehicles = new ArrayList<>(); // ArrayList implements List
        this.currentlyServicing = null;
    }

    /**
     * Adds a new vehicle to the system and the waiting queue.
     * @param vehicle The vehicle to add.
     * @throws DuplicateVehicleIdException if a vehicle with the same ID already exists.
     */
    public void addVehicleToQueue(Vehicle vehicle) throws DuplicateVehicleIdException {
        // Check for duplicate ID
        for (Vehicle existingVehicle : allVehicles) {
            if (existingVehicle.getId().equals(vehicle.getId())) {
                throw new DuplicateVehicleIdException("Vehicle with ID " + vehicle.getId() + " already exists.");
            }
        }

        allVehicles.add(vehicle); // Add to the list of all vehicles
        waitingQueue.offer(vehicle); // Add to the waiting queue (offer returns false if failed, but LinkedList doesn't have capacity limit)
        System.out.println("Vehicle " + vehicle + " added to queue.");
    }

    /**
     * Moves the next vehicle from the waiting queue to the currently servicing state.
     * @throws QueueEmptyException if the waiting queue is empty.
     */
    public void startNextService() throws QueueEmptyException {
        Vehicle nextVehicle = waitingQueue.poll(); // Retrieves and removes the head of the queue
        if (nextVehicle == null) {
            throw new QueueEmptyException("Waiting queue is empty. Cannot start service.");
        }
        this.currentlyServicing = nextVehicle;
        System.out.println("Started servicing vehicle " + currentlyServicing + ".");
    }

    /**
     * Records a service for the vehicle currently being serviced.
     * @param description The description of the service.
     * @param cost The cost of the service.
     * @throws NoVehicleCurrentlyServicingException if no vehicle is currently being serviced.
     * @throws IllegalArgumentException if description or cost is invalid.
     */
    public void performService(String description, double cost) throws NoVehicleCurrentlyServicingException, IllegalArgumentException {
        if (currentlyServicing == null) {
            throw new NoVehicleCurrentlyServicingException("No vehicle is currently being serviced.");
        }
        ServiceRecord record = new ServiceRecord(description, cost);
        currentlyServicing.addServiceRecord(record);
        System.out.println("Service '" + description + "' ($" + String.format("%.2f", cost) + ") recorded for " + currentlyServicing.getId() + ".");
    }

    /**
     * Finds a vehicle by ID and prints its service history.
     * @param vehicleId The ID of the vehicle.
     * @throws VehicleNotFoundException if the vehicle ID is not found in the system.
     */
    public void viewServiceHistory(String vehicleId) throws VehicleNotFoundException {
        Vehicle vehicle = findVehicleById(vehicleId);
        if (vehicle == null) {
            throw new VehicleNotFoundException("Vehicle with ID " + vehicleId + " not found.");
        }

        System.out.println("Service History for " + vehicle + ":");
        List<ServiceRecord> history = vehicle.getServiceHistory();
        if (history.isEmpty()) {
            System.out.println("  No service history found.");
        } else {
            for (ServiceRecord record : history) {
                System.out.println("  - " + record);
            }
        }
    }

    /**
     * Prints the list of vehicles currently waiting in the queue.
     */
    public void listWaitingQueue() {
        System.out.println("Waiting Queue:");
        if (waitingQueue.isEmpty()) {
            System.out.println("  Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Vehicle vehicle : waitingQueue) {
                System.out.println("  - " + vehicle);
            }
        }
    }

    /**
     * Helper method to find a vehicle by ID in the list of all vehicles.
     * @param vehicleId The ID to search for.
     * @return The Vehicle object or null if not found.
     */
    private Vehicle findVehicleById(String vehicleId) {
        for (Vehicle vehicle : allVehicles) {
            if (vehicle.getId().equals(vehicleId)) {
                return vehicle;
            }
        }
        return null;
    }

    // Optional: Method to indicate when a service is finished on currently serviced vehicle
    // (Not strictly required by prompt, but good design)
    public void finishCurrentService() {
         if (currentlyServicing != null) {
             System.out.println("Finished service on " + currentlyServicing + ".");
             currentlyServicing = null; // Make it available for the next one
         } else {
             System.err.println("Warning: No vehicle was currently being serviced to finish.");
         }
    }
}

// Main application class
public class Main {

    public static void main(String[] args) {
        ServiceCenter center = new ServiceCenter();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Welcome to the Vehicle Service Center Management System!");

        // Class-wide exception handling loop
        while (running) {
            System.out.print("Enter command (ADD, START, SERVICE, HISTORY, QUEUE, EXIT): ");
            String commandLine = scanner.nextLine().trim();
            String[] parts = commandLine.split("\\s+");
            String command = parts[0].toUpperCase();

            try {
                // Use switch statement for command processing
                switch (command) {
                    case "ADD":
                        if (parts.length < 3) {
                            System.err.println("Error: ADD command requires Vehicle ID and Model. Usage: ADD <id> <model>");
                        } else {
                            String id = parts[1];
                            String model = parts[2];
                            // Reconstruct model if it contains spaces
                            if (parts.length > 3) {
                                StringBuilder modelBuilder = new StringBuilder(model);
                                for (int i = 3; i < parts.length; i++) {
                                    modelBuilder.append(" ").append(parts[i]);
                                }
                                model = modelBuilder.toString();
                            }
                            Vehicle newVehicle = new Vehicle(id, model);
                            center.addVehicleToQueue(newVehicle);
                        }
                        break;

                    case "START":
                        if (parts.length > 1) {
                            System.err.println("Error: START command takes no arguments. Usage: START");
                        } else {
                            center.startNextService();
                        }
                        break;

                    case "SERVICE":
                        if (parts.length < 3) {
                            System.err.println("Error: SERVICE command requires description and cost. Usage: SERVICE <description> <cost>");
                        } else {
                            // Description can have spaces, cost is the last part
                            String description = parts[1];
                            StringBuilder descriptionBuilder = new StringBuilder(description);
                            for(int i = 2; i < parts.length - 1; i++) {
                                descriptionBuilder.append(" ").append(parts[i]);
                            }
                            description = descriptionBuilder.toString();

                            String costStr = parts[parts.length - 1];
                            try {
                                double cost = Double.parseDouble(costStr);
                                center.performService(description, cost);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid cost format. Cost must be a number.");
                            }
                        }
                        break;

                    case "HISTORY":
                        if (parts.length != 2) {
                            System.err.println("Error: HISTORY command requires Vehicle ID. Usage: HISTORY <id>");
                        } else {
                            String id = parts[1];
                            center.viewServiceHistory(id);
                        }
                        break;

                    case "QUEUE":
                        if (parts.length > 1) {
                            System.err.println("Error: QUEUE command takes no arguments. Usage: QUEUE");
                        } else {
                            center.listWaitingQueue();
                        }
                        break;

                    case "EXIT":
                        if (parts.length > 1) {
                            System.err.println("Error: EXIT command takes no arguments. Usage: EXIT");
                        } else {
                            running = false;
                            System.out.println("Exiting Service Center application.");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command. Available commands: ADD, START, SERVICE, HISTORY, QUEUE, EXIT");
                        break;
                }
            } catch (IllegalArgumentException e) {
                 // Catch exceptions from constructors or methods due to invalid data
                 System.err.println("Input Error: " + e.getMessage());
            } catch (QueueEmptyException e) {
                System.err.println("Operation Error: " + e.getMessage());
            } catch (NoVehicleCurrentlyServicingException e) {
                System.err.println("Operation Error: " + e.getMessage());
            } catch (VehicleNotFoundException e) {
                System.err.println("Operation Error: " + e.getMessage());
            } catch (DuplicateVehicleIdException e) {
                 System.err.println("Operation Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when exiting
    }
}
