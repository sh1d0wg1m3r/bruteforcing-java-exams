/*
 * Exam Question #112
 * Generated on: 2025-05-11 22:16:09
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a basic console-based system to manage tasks for a small team. Tasks have a description and a priority level. High-priority tasks should be processed first, while others are kept in a backlog for later consideration.
 * 
 * **Requirements:**
 * 
 * Implement a Java console application that meets the following requirements:
 * 
 * 1.  **`Task` Class:**
 *     *   Create a class named `Task`.
 *     *   It must have private fields: `int id`, `String description`, and `int priority`.
 *     *   Implement a constructor to initialize these fields.
 *     *   Implement public getter methods for all fields.
 *     *   Override the `toString()` method to provide a clear string representation of a `Task` object.
 *     *   Priority 1 should specifically indicate a high-priority task. Any other positive integer priority indicates a lower priority for the backlog.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Create a class named `TaskManager`.
 *     *   It must have private fields:
 *         *   A `Queue<Task>` to hold high-priority tasks ready for immediate processing.
 *         *   A `List<Task>` to hold tasks designated for the backlog.
 *     *   Implement a constructor to initialize these collections (e.g., using `java.util.LinkedList` for the `Queue` and `java.util.ArrayList` for the `List`).
 *     *   Maintain a simple mechanism (like an incrementing counter) within `TaskManager` to assign a unique `id` to each new task.
 *     *   Implement the following public methods:
 *         *   `void addTask(String description, int priority)`:
 *             *   Creates a new `Task` object with a unique ID.
 *             *   Validate that the `priority` input is a positive integer. If not, print an error message to `System.err` and do not add the task.
 *             *   If the `priority` is 1, add the task to the high-priority queue.
 *             *   Otherwise (priority > 1), add the task to the backlog list.
 *             *   Print a confirmation message to `System.out` indicating where the task was added.
 *         *   `void viewNextHighPriorityTask()`:
 *             *   Peek at the task at the front of the high-priority queue without removing it.
 *             *   If the queue is empty, print a message to `System.out` indicating that.
 *             *   Otherwise, print the `toString()` representation of the next task to `System.out`.
 *         *   `void completeNextHighPriorityTask()`:
 *             *   Poll (remove and return) the task from the front of the high-priority queue.
 *             *   If the queue was empty when attempting to poll, print an error message to `System.err`.
 *             *   Otherwise, print a confirmation message to `System.out` indicating which task was completed.
 *         *   `void viewBacklog()`:
 *             *   Iterate through and print the `toString()` representation of all tasks currently in the backlog list to `System.out`.
 *             *   If the backlog list is empty, print a message to `System.out`.
 * 
 * 3.  **Main Application (`ExamRunner` class):**
 *     *   Create a class named `ExamRunner` with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 *     *   Create an instance of `TaskManager`.
 *     *   Implement a loop that continuously displays a menu of options to the user and prompts for a command.
 *     *   Use a `switch` statement based on the user's input character (case-insensitive, e.g., 'A' for Add, 'N' for View Next, 'C' for Complete, 'B' for View Backlog, 'Q' for Quit).
 *     *   Handle potential `NumberFormatException` when reading the priority input for adding a task using a `try-catch` block. Print an error message to `System.err` if parsing fails.
 *     *   For invalid command inputs, print an error message to `System.err`.
 *     *   Ensure the `Scanner` resource is properly closed when the application exits.
 *     *   Implement class-wide exception handling where appropriate using `try-catch` blocks (e.g., around input parsing).
 * 
 * 4.  **General Requirements:**
 *     *   You **must** use `java.util.Queue`, `java.util.ArrayList`, and the `java.util.List` interface.
 *     *   You **must** use `java.util.Scanner` for user input.
 *     *   You **must** use a `switch` statement for flow control in the main command loop.
 *     *   You **must** use `System.err` for all error messages (invalid input, operation failures like completing from an empty queue).
 *     *   You **must** use `System.out` for menu display, prompts, confirmations, successful output, and informational messages (like indicating empty collections when viewing).
 *     *   Implement class-wide exception handling with `try-catch` blocks, particularly for handling issues related to user input parsing.
 *     *   Follow Java best practices: proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments and documentation (Javadocs are encouraged), input validation, proper error handling, and a clean code structure.
 * 
 * **Example Interaction:**
 * 
 * ```
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: A
 * Enter task description: Fix critical bug
 * Enter priority (1 for High): 1
 * Task added to high priority queue: Task{id=1, description='Fix critical bug', priority=1}
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: A
 * Enter task description: Write documentation
 * Enter priority (1 for High): 3
 * Task added to backlog: Task{id=2, description='Write documentation', priority=3}
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: N
 * Next high priority task: Task{id=1, description='Fix critical bug', priority=1}
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: B
 * --- Backlog ---
 * Task{id=2, description='Write documentation', priority=3}
 * --- End Backlog ---
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: C
 * Completed task: Task{id=1, description='Fix critical bug', priority=1}
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: C
 * System.err: Error: No high-priority task available to complete.
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: A
 * Enter task description: Update dependencies
 * Enter priority (1 for High): invalid input
 * System.err: Invalid priority input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: X
 * System.err: Invalid command. Please enter A, N, C, B, or Q.
 * 
 * --- Task Management Menu ---
 * A: Add Task
 * N: View Next High Priority
 * C: Complete Next High Priority
 * B: View Backlog
 * Q: Quit
 * Enter command: Q
 * Exiting Task Management System.
 * ```
 * 
 * **Time Allotment:** This task is designed to be challenging but solvable within approximately 45-60 minutes. Focus on a correct and clean implementation demonstrating the required concepts.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based task management system as required by the exam question. It is structured into three classes: `Task`, `TaskManager`, and `ExamRunner`.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It demonstrates basic encapsulation with private fields (`id`, `description`, `priority`) and public getter methods. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`TaskManager` Class:** This class is the core of the task management logic.
 *     *   It uses a `Queue<Task>` (`highPriorityQueue`) to manage high-priority tasks, leveraging the FIFO (First-In, First-Out) nature of a queue. Tasks are added using `offer()` and removed using `poll()`. `peek()` is used to view the next task without removing it. `LinkedList` is used as a concrete implementation of the `Queue` interface.
 *     *   It uses a `List<Task>` (`backlogList`) to store lower-priority tasks. `ArrayList` is used as a concrete implementation of the `List` interface. Tasks are added using `add()`. Iteration over the list is used in `viewBacklog()`.
 *     *   A simple `nextTaskId` counter ensures each task gets a unique ID.
 *     *   Methods like `addTask`, `viewNextHighPriorityTask`, `completeNextHighPriorityTask`, and `viewBacklog` implement the required operations, demonstrating how to interact with the chosen collection types.
 *     *   Input validation for priority (checking if positive) is performed in `addTask`.
 *     *   Error conditions, such as attempting to complete a task when the high-priority queue is empty, are handled by checking the return value of `poll()` (which is `null` for an empty queue) and printing an error message.
 * 
 * 3.  **`ExamRunner` Class:** This class contains the `main` method and handles the user interface.
 *     *   It uses `java.util.Scanner` to read commands and task details from the console.
 *     *   A `while` loop keeps the application running until the user chooses to quit.
 *     *   A `switch` statement is used to process the user's command, directing the flow to the appropriate `TaskManager` method calls or application exit logic. This fulfills the requirement for using a `switch` statement for control flow.
 *     *   `System.out` is used extensively for displaying the menu, prompts, task information, and confirmation messages, as required.
 *     *   `System.err` is used specifically for error messages, such as invalid commands or issues during task operations (like trying to complete a task from an empty queue or providing non-numeric priority input). This meets the requirement for using `System.err`.
 *     *   Exception handling is implemented using `try-catch`. Specifically, a `try-catch (NumberFormatException)` block is used around `Integer.parseInt()` when reading the task priority. This handles cases where the user enters non-numeric input for the priority, preventing the program from crashing and printing an informative error to `System.err`. The main loop is also wrapped in a `try-finally` block to ensure the `Scanner` resource is closed properly, demonstrating resource management and a form of class-wide exception handling for setup/cleanup.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Task`, `TaskManager`, `ExamRunner`), encapsulation (private fields, public methods), and object interaction.
 * *   **Collections Framework:** Practical use of `java.util.Queue` (specifically `LinkedList`) for managing a priority-based processing order and `java.util.List` (specifically `ArrayList`) for managing a general backlog. Demonstrates choosing appropriate data structures for different purposes.
 * *   **Input/Output:** Reading user input from `System.in` using `Scanner` and directing output/errors to `System.out` and `System.err`.
 * *   **Control Flow:** Using a `while` loop for the main application loop and a `switch` statement for handling discrete user commands.
 * *   **Exception Handling:** Using `try-catch` blocks to gracefully handle predictable runtime errors like invalid input format (`NumberFormatException`). Using `try-finally` for resource cleanup.
 * *   **Best Practices:** Adherence to naming conventions, adding comments/Javadocs, basic input validation, and separating concerns into different classes.
 * 
 * This solution effectively integrates all the required Java components into a functional, albeit simple, application that simulates a real-world scenario, demonstrating a solid understanding of core and intermediate Java concepts.
 */

// Task.java
package com.exam;

/**
 * Represents a single task with an ID, description, and priority.
 */
public class Task {
    private int id;
    private String description;
    private int priority; // 1 for High, > 1 for lower priority backlog tasks

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (1 for high).
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string detailing the task.
     */
    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", priority=" + priority +
               '}';
    }
}
```

```java
// TaskManager.java
package com.exam;

import java.util.Queue; // Required: Queue
import java.util.LinkedList; // A common implementation for Queue
import java.util.List; // Required: List interface
import java.util.ArrayList; // Required: ArrayList (implementation for List)

/**
 * Manages tasks, separating them into a high-priority queue and a general backlog list.
 */
public class TaskManager {
    // Required: Queue for high priority, List for backlog
    private Queue<Task> highPriorityQueue;
    private List<Task> backlogList;
    private int nextTaskId; // Simple counter for assigning unique IDs

    /**
     * Constructs a new TaskManager, initializing the collections.
     */
    public TaskManager() {
        // Initialize the required collections
        this.highPriorityQueue = new LinkedList<>(); // LinkedList implements Queue
        this.backlogList = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task ID from 1
    }

    /**
     * Adds a new task to the appropriate collection based on its priority.
     * High priority (1) tasks go to the queue, others go to the backlog.
     * @param description The task description.
     * @param priority The task priority (must be positive, 1 for high).
     */
    public void addTask(String description, int priority) {
        // Input validation for priority value
        if (priority <= 0) {
            // Required: System.err for error messages
            System.err.println("Error: Priority must be a positive integer.");
            return; // Do not add task if priority is invalid
        }

        // Create the new task with a unique ID
        Task newTask = new Task(nextTaskId++, description, priority);

        if (priority == 1) {
            // Add to the high-priority queue
            highPriorityQueue.offer(newTask); // offer is generally preferred for capacity-constrained queues, but add works too
            // Required: System.out for normal output
            System.out.println("Task added to high priority queue: " + newTask);
        } else {
            // Add to the general backlog list
            backlogList.add(newTask);
            // Required: System.out for normal output
            System.out.println("Task added to backlog: " + newTask);
        }
    }

    /**
     * Views the next task in the high-priority queue without removing it.
     */
    public void viewNextHighPriorityTask() {
        // Peek at the head of the queue
        Task nextTask = highPriorityQueue.peek();

        // Required: System.out for normal output (info message for empty queue)
        if (nextTask == null) {
            System.out.println("High priority queue is empty.");
        } else {
            System.out.println("Next high priority task: " + nextTask);
        }
    }

    /**
     * Completes (removes) the next task from the high-priority queue.
     */
    public void completeNextHighPriorityTask() {
        // Poll (remove and return) the head of the queue
        Task completedTask = highPriorityQueue.poll();

        // Required: System.err for error messages (when queue was empty)
        if (completedTask == null) {
            System.err.println("Error: No high-priority task available to complete.");
        } else {
            // Required: System.out for normal output (confirmation)
            System.out.println("Completed task: " + completedTask);
        }
    }

    /**
     * Views all tasks currently stored in the backlog list.
     */
    public void viewBacklog() {
        // Required: System.out for normal output
        System.out.println("--- Backlog ---");
        // Check if the list is empty
        if (backlogList.isEmpty()) {
            System.out.println("Backlog is empty.");
        } else {
            // Iterate and print all tasks in the backlog (using the List interface)
            for (Task task : backlogList) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Backlog ---");
    }
}
```

```java
// ExamRunner.java
package com.exam;

import java.util.Scanner; // Required: Scanner

/**
 * Main class to run the Simple Task Management System application.
 * Handles user interaction via the console.
 */
public class ExamRunner {

    public static void main(String[] args) {
        // Required: Scanner for user input
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Required: Class-wide exception handling (using try-finally for Scanner and try-catch for input parsing)
        try {
            while (running) {
                printMenu();
                // Required: System.out for prompts
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toUpperCase();

                // Required: Switch statement for command processing
                switch (command) {
                    case "A": // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (1 for High): ");
                        try {
                            // Required: try-catch block for handling NumberFormatException
                            int priority = Integer.parseInt(scanner.nextLine().trim());
                            taskManager.addTask(description, priority);
                        } catch (NumberFormatException e) {
                            // Required: System.err for error messages
                            System.err.println("Invalid priority input. Please enter a number.");
                        }
                        break;

                    case "N": // View Next High Priority
                        taskManager.viewNextHighPriorityTask();
                        break;

                    case "C": // Complete Next High Priority
                        taskManager.completeNextHighPriorityTask();
                        break;

                    case "B": // View Backlog
                        taskManager.viewBacklog();
                        break;

                    case "Q": // Quit
                        running = false;
                        // Required: System.out for normal output (exit message)
                        System.out.println("Exiting Task Management System.");
                        break;

                    default:
                        // Required: System.err for error messages (invalid command)
                        System.err.println("Invalid command. Please enter A, N, C, B, or Q.");
                }
                // Add a newline after each command execution for better readability
                System.out.println();
            }
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        // Required: System.out for menu display
        System.out.println("--- Task Management Menu ---");
        System.out.println("A: Add Task");
        System.out.println("N: View Next High Priority");
        System.out.println("C: Complete Next High Priority");
        System.out.println("B: View Backlog");
        System.out.println("Q: Quit");
    }
}
