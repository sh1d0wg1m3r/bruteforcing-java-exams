/*
 * Exam Question #219
 * Generated on: 2025-05-11 22:34:09
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Team Task Manager
 * 
 * **Problem Description:**
 * 
 * Design and implement a console-based application in Java to manage tasks for a small team. The system should allow users to add new tasks, process the next pending task, view pending tasks, and view completed tasks. This task requires demonstrating proficiency in core Java collections, input handling, control flow, and exception handling.
 * 
 * **Specific Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent individual tasks. Each `Task` should have:
 *     *   A unique integer ID.
 *     *   A string description.
 *     *   A boolean status indicating if it's completed.
 *     *   Appropriate constructor, getters, and a method to mark the task as completed.
 *     *   An overridden `toString()` method for easy printing of task details.
 *     *   Use proper encapsulation (private fields, public methods).
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` that will manage the collections of tasks and handle user interactions. The `TaskManager` class must:
 *     *   Use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks). Tasks should be processed in the order they were added (FIFO).
 *     *   Use a `java.util.ArrayList<Task>` (declared using the `java.util.List` interface, i.e., `List<Task> completedTasks = new ArrayList<>();`) to store tasks that have been completed.
 *     *   Maintain a counter for generating unique task IDs.
 *     *   Implement methods for adding tasks, processing the next task, viewing pending tasks, and viewing completed tasks.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and task details from the console.
 *     *   Implement a main application loop within the `TaskManager` that presents a menu to the user.
 *     *   Use a `switch` statement based on the user's menu choice to invoke the corresponding task management logic.
 * 
 * 4.  **Output:**
 *     *   Display the menu, task lists, and success messages using `System.out`.
 *     *   Display error messages (e.g., invalid input, no tasks to process) using `System.err`.
 * 
 * 5.  **Error Handling & Validation:**
 *     *   Implement input validation for task descriptions (a description cannot be empty or contain only whitespace). If invalid, print an error to `System.err` and do not add the task.
 *     *   Handle the scenario where the user attempts to process a task when the pending queue is empty. Print an informative error message to `System.err`.
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main application loop (`run` method) in `TaskManager` to catch any unexpected runtime exceptions that might occur during program execution. Print the error details to `System.err`. Include a `finally` block to ensure the `Scanner` resource is closed.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for classes and methods).
 *     *   Ensure the code structure is clean and readable.
 * 
 * **User Interaction Flow:**
 * 
 * The application should repeatedly display the following menu and process user input until the user chooses to exit:
 * 
 * ```
 * --- Task Manager ---
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Pending Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the choice:
 * *   **1:** Prompt for a task description. Validate the input. Add the task to the pending queue.
 * *   **2:** Attempt to process the next task from the pending queue. If successful, move it to completed. If the queue is empty, print an error.
 * *   **3:** List all tasks currently in the pending queue.
 * *   **4:** List all tasks currently in the completed list.
 * *   **5:** Print an exit message and terminate the application loop.
 * *   **Any other input:** Print an "Invalid choice" error message.
 * 
 * **Expected Output:**
 * 
 * Your output should clearly show the menu, prompts for input, task details being listed (including ID, description, and status), and error messages appearing on the error stream when applicable.
 * 
 * **Constraint:** You must use ALL the Java components listed in requirement 2-5 (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch` for class-wide handling).
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Manager application, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and `isCompleted`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide access to the fields.
 *     *   `markCompleted()` is a public method to change the task's state.
 *     *   `toString()` is overridden to provide a user-friendly representation of a task.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the core class managing the task collections and user interaction.
 *     *   **`Queue<Task> pendingTasks = new LinkedList<>();`**: A `java.util.Queue` is used via its `LinkedList` implementation. This correctly models the requirement that tasks are processed in the order they are added (FIFO - First-In, First-Out). `offer()` is used for adding tasks and `poll()` for retrieving and removing the head of the queue.
 *     *   **`List<Task> completedTasks = new ArrayList<>();`**: A `java.util.List` is used via its `ArrayList` implementation. This is suitable for storing completed tasks where order might be maintained (insertion order) but the primary operations are adding and iterating, not necessarily FIFO processing.
 *     *   **`Scanner scanner = new Scanner(System.in);`**: A `Scanner` is used to read user input from `System.in`. It's managed as a class member and closed in the `finally` block.
 *     *   **`addTask(String description)`**: Adds a new task to the `pendingTasks` queue after validating the description. It uses `System.err` for validation errors and `System.out` for success messages.
 *     *   **`processNextTask()`**: Removes the next task from `pendingTasks` using `poll()`, marks it complete, and adds it to `completedTasks`. It checks if the queue is empty first, printing an error to `System.err` if it is.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`**: Iterate through the respective collections and print task details using `System.out`. They also handle the case where the lists are empty.
 *     *   **`printMenu()`**: A helper method to display the menu options using `System.out`.
 *     *   **`run()`**: This is the main application loop.
 *         *   It contains a `while(running)` loop that continues until the user chooses to exit.
 *         *   Inside the loop, it calls `printMenu()`, reads the user's choice using `scanner.nextLine()`. Reading as a String handles potential non-numeric input more gracefully than reading as an integer directly, which could throw `InputMismatchException`.
 *         *   A **`switch` statement** is used on the trimmed user input string (`choiceStr.trim()`) to direct execution to the appropriate method (`addTask`, `processNextTask`, etc.) or handle the "Exit" command. The `default` case handles invalid input, printing an error to `System.err`.
 *     *   **Class-wide Exception Handling (`try-catch-finally`)**: The entire `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)`. This serves as a top-level handler for any unexpected runtime exceptions that might propagate up from the called methods or the input processing. It prints an error message and the stack trace to `System.err`. The `finally` block ensures that the `scanner` resource is closed, preventing resource leaks, regardless of whether the loop finishes normally or an exception occurs.
 * 
 * 3.  **Output Streams:** `System.out` is used for all standard application output (menu, prompts, task listings, success messages). `System.err` is specifically used for error conditions (invalid input, empty queue/list errors, unexpected exceptions).
 * 
 * 4.  **Input Validation and Error Handling:** Input validation for the task description is done directly in the `addTask` method using an `if` check and `System.err`. The `processNextTask` method checks for an empty queue before attempting to `poll()`, also using `System.err` for the error message. The main `try-catch` block provides a safety net for unforeseen issues.
 * 
 * 5.  **Best Practices:** Encapsulation is used in the `Task` class. Meaningful names like `pendingTasks`, `completedTasks`, `processNextTask` are used. Javadoc comments are included for classes and public methods. The code is structured logically with separate methods for distinct operations.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of collections, control flow, basic I/O, and robust error handling principles suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although reading as String, good practice to know

/**
 * Represents a single task in the task management system.
 */
class Task {
    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.isCompleted = false; // Tasks are pending by default
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Returns a string representation of the task.
     * @return String representation including ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\", Status: " + (isCompleted ? "Completed" : "Pending");
    }
}

/**
 * Manages a collection of tasks, including pending and completed tasks.
 * Handles user interaction via the console.
 */
public class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared as List, implemented as ArrayList
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new TaskManager.
     * Initializes task collections and the task ID counter.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * Validates the task description.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Do not add task if description is invalid
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // Use offer() which is designed for capacity-constrained queues
        System.out.println("Task added: " + newTask.toString());
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the processed task to the completed list.
     * Handles the case where there are no pending tasks.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue
        taskToProcess.markCompleted();
        completedTasks.add(taskToProcess); // Add to the completed list
        System.out.println("Task processed: " + taskToProcess.toString());
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task.toString());
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks that have been marked as completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task.toString());
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Task Manager ---");
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop for the Task Manager.
     * Handles user input and delegates operations based on choice.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();
                String choiceStr = scanner.nextLine(); // Read input as string

                // Use switch statement for flow control based on user choice
                switch (choiceStr.trim()) {
                    case "1":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description); // addTask performs validation and uses System.err
                        break;
                    case "2":
                        processNextTask(); // processNextTask checks for empty queue and uses System.err
                        break;
                    case "3":
                        viewPendingTasks(); // Uses System.out
                        break;
                    case "4":
                        viewCompletedTasks(); // Uses System.out
                        break;
                    case "5":
                        System.out.println("Exiting Task Manager. Goodbye!"); // Uses System.out
                        running = false; // Exit the loop
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Uses System.err
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime errors during the main loop
            System.err.println("An unexpected error occurred during operation: " + e.getMessage());
            e.printStackTrace(System.err); // Print the stack trace to the error stream
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }

    /**
     * Main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
