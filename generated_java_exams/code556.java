/*
 * Exam Question #556
 * Generated on: 2025-05-11 23:28:58
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam - Task Management System Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application that simulates a task management and processing system. The system should allow users to add tasks, process the next available task, and view pending and processed tasks. Tasks have an auto-generated ID, a description, and a priority level.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a task with the following properties:
 *     *   `taskId` (int): A unique identifier, automatically generated by the system.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (higher number = higher priority).
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Override `toString()` to provide a user-friendly representation of a task.
 * 
 * 2.  **Task Management System:** Create a `TaskManagementSystem` class that manages the tasks. It must internally use:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `List<Task>` (specifically instantiated as an `ArrayList<Task>`) to store tasks that have been processed (either successfully or with a simulated failure).
 * 
 * 3.  **Functionality:** The `TaskManagementSystem` class must provide the following methods:
 *     *   `addTask(String description, int priority)`: Creates a new `Task` with an auto-incrementing ID and adds it to the pending task queue.
 *     *   `processNextTask()`:
 *         *   Retrieves and removes the next task from the pending queue.
 *         *   If the queue is empty, it should indicate this error.
 *         *   Simulate processing: Generate a random number between 0.0 and 1.0. If the random number is less than `(task.priority / 10.0)`, simulate a successful completion. Otherwise, simulate a failure. (Assume priority is 1-10 for this simulation, though the system should handle any integer).
 *         *   If processing fails (simulated), throw a custom exception `TaskProcessingException`.
 *         *   Regardless of success or failure (caught exception), the task should be moved from the pending queue to the processed tasks list.
 *         *   Provide appropriate output indicating success or failure.
 *     *   `listPendingTasks()`: Displays all tasks currently in the pending queue.
 *     *   `listProcessedTasks()`: Displays all tasks currently in the processed tasks list.
 * 
 * 4.  **User Interface:** Implement a command-line interface in the `main` method using `java.util.Scanner`. The system should present a menu with the following options:
 *     *   Add New Task
 *     *   Process Next Task
 *     *   List Pending Tasks
 *     *   List Processed Tasks
 *     *   Exit
 * 
 * 5.  **Control Flow and Error Handling:**
 *     *   Use a `switch` statement in the `main` loop to handle user menu selections.
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, invalid input format, queue empty, task processing failure).
 *     *   Implement input validation for task priority (ensure it's an integer). Handle `NumberFormatException` using `try-catch`.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to catch `TaskProcessingException` thrown by `processNextTask`, as well as other potential exceptions during input or operation.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic JavaDocs where appropriate.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting the menu, accepting user input, and displaying results or errors as described above.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter task priority (1-10): 8
 * Task added: Task{id=1, description='Implement login feature', priority=8}
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Implement login feature', priority=8}
 * Task 1 processed successfully.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter task priority (1-10): high
 * Error: Invalid input. Please enter a valid integer for priority.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * Processed Tasks:
 * Task{id=1, description='Implement login feature', priority=8}
 * ```
 * 
 * **Constraints:**
 * 
 * *   You must use all the components listed in the requirements (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   The solution should be a single Java file for submission simplicity.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System simulation using the required Java components and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task with private fields (`taskId`, `description`, `priority`) and public getters for encapsulation. The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **TaskProcessingException:** A custom exception class is created to specifically signal a simulated failure during task processing, fulfilling the requirement for class-wide exception handling involving a specific scenario.
 * 
 * 3.  **TaskManagementSystem Class:**
 *     *   It uses a `java.util.Queue` (implemented by `java.util.LinkedList`) called `pendingTasks` to manage tasks waiting to be processed. The Queue's FIFO (First-In, First-Out) nature is suitable for processing tasks in the order they were added.
 *     *   It uses a `java.util.List` (instantiated as `java.util.ArrayList`) called `processedTasks` to store tasks after they have been processed, regardless of success or failure. `ArrayList` provides dynamic resizing and easy storage of processed items. The variable is declared as `List` to demonstrate programming to the interface.
 *     *   `nextTaskId` is an integer counter used to assign unique IDs to new tasks, demonstrating a simple state management within the system.
 *     *   `addTask`: Creates a `Task` object and adds it to the `pendingTasks` queue using `queue.add()`.
 *     *   `processNextTask`:
 *         *   It first checks if the queue is empty and prints an error to `System.err` if it is.
 *         *   It uses `queue.poll()` to retrieve and remove the next task from the queue.
 *         *   It simulates processing success/failure based on the task's priority and a random number.
 *         *   If a simulated failure occurs, it throws the custom `TaskProcessingException`.
 *         *   Crucially, it adds the task to the `processedTasks` list using `list.add()` *before* throwing the exception (or after the successful processing logic) to ensure the task is moved regardless of outcome, as per the requirement.
 *     *   `listPendingTasks` and `listProcessedTasks`: These methods iterate through their respective collections (`Queue` and `List`) and print task details to `System.out`. They check for emptiness before listing.
 * 
 * 4.  **TaskManagementSystemApp Class (main method):**
 *     *   This class contains the `main` method, which serves as the application entry point and user interface handler.
 *     *   A `java.util.Scanner` is used to read user input from the console (`System.in`).
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, `printMenu()` displays the options using `System.out`.
 *     *   User input for the menu choice is read using `scanner.nextLine()` and parsed into an integer.
 *     *   A `switch` statement is used to direct the program flow based on the user's choice, calling the appropriate methods of the `TaskManagementSystem` instance.
 *     *   **Error Handling (`try-catch`):**
 *         *   The core of the `main` loop is wrapped in a `try-catch` block to catch potential `NumberFormatException` if the user enters non-integer input for the menu choice.
 *         *   The `case 1` (Add Task) includes a nested `try-catch` block specifically for parsing the priority input, handling `NumberFormatException` and printing the error to `System.err`.
 *         *   The `case 2` (Process Task) includes a `try-catch` block to catch the `TaskProcessingException` thrown by `system.processNextTask()`, demonstrating class-wide exception handling in the caller (`main`). It also includes a general `Exception` catch for any other unexpected errors during processing. All caught errors in `main` are printed to `System.err`.
 *     *   `System.out` is used for normal output (menu, prompts, success messages, task lists).
 *     *   `System.err` is used exclusively for printing error messages, fulfilling a specific requirement.
 * 
 * 5.  **Best Practices:**
 *     *   Private fields and public methods ensure proper encapsulation.
 *     *   Variable names (`pendingTasks`, `processedTasks`, `nextTaskId`, `successChance`) and method names (`addTask`, `processNextTask`, `listPendingTasks`) are descriptive.
 *     *   Basic JavaDocs and inline comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation for numbers (`try-catch NumberFormatException`) is implemented.
 *     *   Error messages are informative and directed to `System.err`.
 *     *   The code is structured into logical classes (`Task`, `TaskProcessingSystem`, `TaskManagementSystemApp`).
 *     *   Resources like `Scanner` are closed.
 * 
 * This solution effectively integrates all specified Java components within a practical scenario, demonstrating understanding of data structures (`Queue`, `List`/`ArrayList`), control flow (`switch`, loops), input/output (`Scanner`, `System.out`, `System.err`), exception handling (`try-catch`, custom exceptions), and object-oriented principles (encapsulation).
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Random;

/**
 * Custom exception for task processing failures.
 */
class TaskProcessingException extends Exception {
    public TaskProcessingException(String message) {
        super(message);
    }
}

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level (higher is more important).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "', priority=" + priority + "}";
    }
}

/**
 * Manages a collection of tasks, including pending and processed lists.
 */
class TaskManagementSystem {
    // Using LinkedList as a Queue implementation
    private Queue<Task> pendingTasks;
    // Using ArrayList for processed tasks, declared as List interface
    private List<Task> processedTasks;
    private int nextTaskId;
    private Random random; // For simulating processing success/failure

    /**
     * Constructs a new TaskManagementSystem.
     */
    public TaskManagementSystem() {
        this.pendingTasks = new LinkedList<>();
        this.processedTasks = new ArrayList<>(); // Instantiated as ArrayList
        this.nextTaskId = 1;
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.add(newTask);
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Simulates success or failure based on priority.
     * @throws TaskProcessingException If processing fails (simulated).
     */
    public void processNextTask() throws TaskProcessingException {
        if (pendingTasks.isEmpty()) {
            // Use System.err for error message as required
            System.err.println("Error: No tasks in the pending queue.");
            return; // Exit the method if queue is empty
        }

        // Retrieve but do not remove yet, in case of simulated failure needing to move it
        // Or poll first and then handle moving to processed list later
        // Let's poll first, then add to processed list in the finally block or after catch
        Task taskToProcess = pendingTasks.poll();

        System.out.println("Processing task: " + taskToProcess);

        // Simulate processing success based on priority (priority/10.0 chance)
        // Ensure priority is treated reasonably, e.g., max 10 for chance calculation
        double successChance = Math.min(10, Math.max(0, taskToProcess.getPriority())) / 10.0;
        double randomValue = random.nextDouble();

        try {
            if (randomValue < successChance) {
                // Simulated success
                System.out.println("Task " + taskToProcess.getTaskId() + " processed successfully.");
            } else {
                // Simulated failure - throw custom exception
                throw new TaskProcessingException("Simulated processing failure for task " + taskToProcess.getTaskId());
            }
        } catch (TaskProcessingException e) {
            // Catch the specific task processing exception
            System.err.println(e.getMessage()); // Use System.err for this specific error
            // Re-throw or handle. Requirement is to catch in main, so re-throw.
            // But the requirement also says "Regardless of success or failure (caught exception),
            // the task should be moved from the pending queue to the processed tasks list."
            // The task was already polled (removed from pending), so now we just need to add it to processed.
            // We can add it to processed here or outside the try/catch. Let's add it outside
            // so it happens whether an exception was thrown and caught here, or if it succeeded.
            // The exception needs to be caught *in main* as per requirement 5 ("class-wide exception handling... in the main method").
            // So, the TaskManagementSystem method should *throw* the exception, and main catches it.
            // Let's adjust: poll, try simulation, if fail, throw. Main catches, adds to processed.
            // If success, TaskManagementSystem adds to processed. This requires the task object to be available after the call in main.
            // A simpler approach fitting the "move to processed regardless" is to poll, try, *always* add to processed, and throw *after* adding if failed.

            // Revised approach: Poll, simulate, add to processed, THEN throw if failed.
             processedTasks.add(taskToProcess); // Add to processed list
             throw e; // Re-throw the caught exception to be handled in main
        }

        // If we reach here, it means it was a simulated success (no exception thrown)
        processedTasks.add(taskToProcess); // Add to processed list on success
    }


    /**
     * Lists all tasks currently waiting in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate without removing
            for (Task task : pendingTasks) {
                System.out.println(task); // Uses Task's toString()
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Lists all tasks that have been processed.
     */
    public void listProcessedTasks() {
        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No processed tasks.");
        } else {
            for (Task task : processedTasks) {
                System.out.println(task); // Uses Task's toString()
            }
        }
        System.out.println("---------------------\n");
    }
}

/**
 * Main application class for the Task Management System.
 */
public class TaskManagementSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManagementSystem system = new TaskManagementSystem();
        boolean running = true;

        System.out.println("Welcome to the Task Management System!");

        while (running) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use try-catch for input parsing
            try {
                int choice = Integer.parseInt(scanner.nextLine());

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (integer): ");
                        // Use try-catch for priority input
                        try {
                            int priority = Integer.parseInt(scanner.nextLine());
                            system.addTask(description, priority);
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid input. Please enter a valid integer for priority.");
                        }
                        break;

                    case 2: // Process Next Task
                        // Class-wide exception handling for processNextTask
                        try {
                            system.processNextTask();
                        } catch (TaskProcessingException e) {
                            // Error message already printed by TaskManagementSystem
                            // This catch block is here to fulfill the requirement
                            // of catching TaskProcessingException in main.
                            // No further action needed here as the task was already moved to processed.
                        } catch (Exception e) {
                            // Catch any other unexpected exceptions during processing
                             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
                        }
                        break;

                    case 3: // List Pending Tasks
                        system.listPendingTasks();
                        break;

                    case 4: // List Processed Tasks
                        system.listProcessedTasks();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch exception if user input for choice is not an integer
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                 // Catch any other unexpected exceptions in the main loop
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for debugging if needed
            }
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Processed Tasks");
        System.out.println("5. Exit");
    }
}
