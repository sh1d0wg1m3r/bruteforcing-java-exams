/*
 * Exam Question #71
 * Generated on: 2025-05-11 22:08:50
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Print Queue Simulation System**
 * 
 * You are required to design and implement a console-based application in Java that simulates a simple print queue. The system should allow users to submit print jobs, process the next job in the queue, and view lists of jobs.
 * 
 * Your solution must demonstrate your understanding of core Java concepts, including collections, control flow, user input, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Logic (`PrintQueueManager`):**
 *     *   Create a class named `PrintJob` with private fields: `jobId` (int), `description` (String), and `status` (use an enum or String, e.g., "PENDING", "COMPLETED"). Include a constructor, getters, a method to set the status, and a `toString()` method.
 *     *   Create a class named `PrintQueueManager` that manages the print jobs.
 *     *   Inside `PrintQueueManager`, use a `java.util.Queue<PrintJob>` to store jobs that are currently pending processing (FIFO order). You should use a concrete implementation like `java.util.LinkedList`.
 *     *   Inside `PrintQueueManager`, use a `java.util.List<PrintJob>` to store a history of *all* jobs ever submitted, regardless of their current status. This list should be initialized using `java.util.ArrayList`.
 *     *   Implement the following public methods in `PrintQueueManager`:
 *         *   `submitJob(String description)`: Creates a new `PrintJob` with a unique ID, adds it to both the pending queue and the history list, and returns the new job's ID. Include basic validation (e.g., description not empty).
 *         *   `processNextJob()`: Removes the next job from the pending queue, updates its status to "COMPLETED" in the history list, and returns the processed `PrintJob`.
 *         *   `getPendingJobs()`: Returns a `List<PrintJob>` containing all jobs currently in the pending queue.
 *         *   `getAllJobs()`: Returns a `List<PrintJob>` containing all jobs from the history list (pending and completed).
 * 
 * 2.  **User Interface (`PrintQueueApp`):**
 *     *   Create a main class named `PrintQueueApp` with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present the user with a menu of options using `System.out`:
 *         1.  Submit New Print Job
 *         2.  Process Next Job
 *         3.  List Pending Jobs
 *         4.  List All Jobs (History)
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 
 * 3.  **Exception Handling:**
 *     *   Define a custom exception, e.g., `EmptyQueueException`, to be thrown by `processNextJob()` if the pending queue is empty.
 *     *   Implement class-wide exception handling in `PrintQueueApp.main` using a `try-catch` block that wraps the main application loop and user interaction logic. Catch your custom `EmptyQueueException` specifically when calling `processNextJob()`. Also, include a general `catch (Exception e)` for any unexpected errors.
 *     *   Use `System.err` to print all error messages (e.g., invalid choice, empty queue error, invalid input error, unexpected errors).
 *     *   Use `System.out` for all normal output (menu, prompts, successful operations, job listings, exit message).
 * 
 * 4.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments (especially Javadoc for public methods).
 *     *   Implement basic input validation (as mentioned for `submitJob`).
 *     *   Structure your code cleanly (e.g., separate classes for `PrintJob`, `PrintQueueManager`, the main app, and the exception).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the corresponding action, and print appropriate messages to `System.out` for success/information or `System.err` for errors. The listings should clearly show the jobs and their statuses.
 *
 * EXPLANATION:
 * This solution implements a Print Queue Simulation system demonstrating various core Java concepts as required.
 * 
 * 1.  **Core Logic (`PrintJob`, `JobStatus`, `PrintQueueManager`):**
 *     *   The `JobStatus` enum provides a clear and type-safe way to represent the state of a print job.
 *     *   The `PrintJob` class encapsulates the data for a single print job (`jobId`, `description`, `status`) with appropriate getters and a setter for status, adhering to encapsulation principles. The `toString()` method provides a convenient way to print job details.
 *     *   The `PrintQueueManager` class is the central component for managing the jobs.
 *         *   It uses a `Queue<PrintJob>` (`printQueue`) implemented by `LinkedList` to maintain the pending jobs in FIFO order. `LinkedList` is chosen because it efficiently supports queue operations (`offer`, `poll`).
 *         *   It uses a `List<PrintJob>` (`allJobs`) implemented by `ArrayList` to store a history of all jobs. `ArrayList` is suitable for storing and iterating over a dynamic list of elements.
 *         *   The `submitJob` method creates a new `PrintJob`, adds it to both the `printQueue` and the `allJobs` list, and handles basic input validation for the description, throwing an `IllegalArgumentException` if it's invalid.
 *         *   The `processNextJob` method uses `printQueue.poll()` to retrieve and remove the head of the queue. If the queue is empty, `poll()` returns `null`, which is checked to throw the custom `EmptyQueueException`. If a job is retrieved, its status is updated to `COMPLETED`. Note that since `allJobs` stores references to the same `PrintJob` objects as the queue, updating the status of the job object updates it in both the queue (before removal) and the history list.
 *         *   `getPendingJobs` returns a `new ArrayList<>(printQueue)`. This is important: it returns a *copy* of the queue's contents as a `List`, fulfilling the requirement to return a `List` and preventing external code from directly modifying the internal `printQueue` structure.
 *         *   `getAllJobs` returns the `allJobs` list, also fulfilling the requirement to return a `List`.
 * 
 * 2.  **User Interface (`PrintQueueApp`):**
 *     *   The `PrintQueueApp` class contains the `main` method, which serves as the application's entry point and handles user interaction.
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   A `while(true)` loop runs the main application cycle until explicitly exited.
 *     *   The `printMenu` method displays the available options using `System.out`.
 *     *   A `switch` statement dispatches control based on the user's input string (`choice`), calling the appropriate methods on the `PrintQueueManager` instance.
 * 
 * 3.  **Exception Handling:**
 *     *   A custom exception `EmptyQueueException` is defined, extending `Exception`. This provides a specific type of exception for the empty queue scenario.
 *     *   The `processNextJob` method explicitly throws `EmptyQueueException` when the queue is empty.
 *     *   The `submitJob` method throws `IllegalArgumentException` for invalid input.
 *     *   In `PrintQueueApp.main`, a `try-catch` block wraps the entire `while` loop, demonstrating "class-wide" handling of exceptions originating from the application's core interaction flow.
 *     *   Specific `catch` blocks within the loop handle `EmptyQueueException` (for processing) and `IllegalArgumentException` (for submitting), allowing for tailored error messages printed to `System.err`.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors, printing a generic error message and the stack trace to `System.err`.
 *     *   `System.err.println()` is used exclusively for printing error messages, distinguishing them from normal application output which uses `System.out.println()`.
 *     *   A `finally` block ensures the `Scanner` resource is closed when the `try` block is exited, whether normally or due to an exception, which is a good practice for resource management.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is used in `PrintJob` and `PrintQueueManager` by making fields private and providing public methods for interaction.
 *     *   Meaningful names (`printQueue`, `allJobs`, `submitJob`, `processNextJob`, `EmptyQueueException`) are used throughout the code.
 *     *   Javadoc comments are provided for classes and public methods explaining their purpose, parameters, return values, and thrown exceptions.
 *     *   Basic input validation is implemented in `submitJob`.
 *     *   The code is structured into logical classes and an enum, improving readability and maintainability. The use of the `List` interface type for variables holding `ArrayList` instances (`pendingJobs`, `allJobs`) demonstrates polymorphism.
 * 
 * This solution effectively integrates the required components to simulate a practical scenario while demonstrating key Java programming skills and best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

// Enum for Print Job Status
enum JobStatus {
    PENDING, COMPLETED
}

// Class representing a single Print Job
class PrintJob {
    private int jobId;
    private String description;
    private JobStatus status;

    /**
     * Constructs a new PrintJob with default status PENDING.
     * @param jobId The unique ID for the job.
     * @param description A brief description of the job.
     */
    public PrintJob(int jobId, String description) {
        this.jobId = jobId;
        this.description = description;
        this.status = JobStatus.PENDING; // Default status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getDescription() {
        return description;
    }

    public JobStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the print job.
     * @param status The new status for the job.
     */
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Job [ID=" + jobId + ", Desc='" + description + "', Status=" + status + "]";
    }
}

// Custom exception for operations on an empty queue
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Class managing the Print Queue and Job History
class PrintQueueManager {
    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<PrintJob> printQueue;
    // List to hold all jobs ever submitted (for history)
    private List<PrintJob> allJobs;
    // Counter for generating unique job IDs
    private int nextJobId;

    /**
     * Constructs a new PrintQueueManager, initializing the queue and list.
     */
    public PrintQueueManager() {
        // Use LinkedList as it implements the Queue interface
        this.printQueue = new LinkedList<>();
        // Use ArrayList as it implements the List interface
        this.allJobs = new ArrayList<>();
        this.nextJobId = 1;
    }

    /**
     * Submits a new print job to the queue and adds it to the history list.
     * Assigns a unique ID to the job.
     * @param description The description of the print job. Must not be empty.
     * @return The ID of the newly submitted job.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public int submitJob(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        PrintJob newJob = new PrintJob(nextJobId++, description.trim());
        printQueue.offer(newJob); // Add to the end of the queue (FIFO)
        allJobs.add(newJob);      // Keep track of all jobs in history list
        System.out.println("Job submitted: " + newJob); // Print confirmation using System.out
        return newJob.getJobId();
    }

    /**
     * Processes the next job in the queue.
     * Removes the job from the pending queue, updates its status to COMPLETED in the history list,
     * and returns the processed job.
     * @return The PrintJob that was processed.
     * @throws EmptyQueueException if the print queue is currently empty.
     */
    public PrintJob processNextJob() throws EmptyQueueException {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        PrintJob jobToProcess = printQueue.poll();
        if (jobToProcess == null) {
            // Throw custom exception if queue is empty
            throw new EmptyQueueException("Print queue is currently empty. No jobs to process.");
        }
        // Update status in the allJobs list (the reference in allJobs is the same object)
        jobToProcess.setStatus(JobStatus.COMPLETED);
        System.out.println("Processing job: " + jobToProcess); // Print processing info using System.out
        return jobToProcess;
    }

    /**
     * Gets a list of all jobs currently in the pending queue.
     * Returns a new list to prevent external modification of the internal queue structure.
     * @return A List of PrintJob objects in the pending queue.
     */
    public List<PrintJob> getPendingJobs() {
        // Create and return a new ArrayList containing elements from the queue
        // This fulfills the requirement of using List interface and ArrayList implementation
        return new ArrayList<>(printQueue);
    }

    /**
     * Gets a list of all jobs ever submitted, including pending and completed jobs.
     * @return A List of all PrintJob objects.
     */
    public List<PrintJob> getAllJobs() {
        // Return the reference to the internal allJobs list (an ArrayList)
        // This fulfills the requirement of using List interface and ArrayList implementation
        return allJobs;
    }
}

// Main application class handling user interaction and overall flow
public class PrintQueueApp {

    public static void main(String[] args) {
        // Use Scanner for reading user input from the console
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager manager = new PrintQueueManager();

        System.out.println("--- Print Queue Simulation ---");

        // Class-wide exception handling: Wrap the main application loop in a try-catch block
        try {
            // Main application loop
            while (true) {
                printMenu();
                System.out.print("Enter your choice: ");
                // Read the entire line of input
                String choice = scanner.nextLine();

                // Use a switch statement to handle different user choices
                switch (choice) {
                    case "1": // Submit New Print Job
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        try {
                             // Delegate submission to the manager
                             manager.submitJob(description);
                        } catch (IllegalArgumentException e) {
                            // Catch specific validation errors from submitJob
                            System.err.println("Error submitting job: " + e.getMessage()); // Use System.err for errors
                        }
                        break;
                    case "2": // Process Next Job
                        try {
                            // Delegate processing to the manager
                            manager.processNextJob();
                        } catch (EmptyQueueException e) {
                            // Catch custom exception for empty queue
                            System.err.println("Error processing job: " + e.getMessage()); // Use System.err for errors
                        }
                        break;
                    case "3": // List Pending Jobs
                        // Get pending jobs using the List interface type
                        List<PrintJob> pendingJobs = manager.getPendingJobs();
                        if (pendingJobs.isEmpty()) {
                            System.out.println("No jobs currently pending in the queue."); // Use System.out for normal output
                        } else {
                            System.out.println("\n--- Pending Jobs ---"); // Use System.out
                            // Iterate and print using the List variable
                            for (PrintJob job : pendingJobs) {
                                System.out.println(job); // Use System.out
                            }
                            System.out.println("--------------------"); // Use System.out
                        }
                        break;
                    case "4": // List All Jobs (History)
                        // Get all jobs using the List interface type
                        List<PrintJob> allJobs = manager.getAllJobs();
                         if (allJobs.isEmpty()) {
                            System.out.println("No jobs have been submitted yet."); // Use System.out
                        } else {
                            System.out.println("\n--- All Jobs (Including Completed) ---"); // Use System.out
                             // Iterate and print using the List variable
                            for (PrintJob job : allJobs) {
                                System.out.println(job); // Use System.out
                            }
                            System.out.println("------------------------------------"); // Use System.out
                        }
                        break;
                    case "5": // Exit
                        System.out.println("Exiting Print Queue Simulation. Goodbye!"); // Use System.out
                        return; // Exit the main method, terminating the program

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Use System.err
                }
                System.out.println(); // Add a blank line for readability using System.out
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that weren't handled by more specific catches
            System.err.println("An unexpected error occurred: " + e.getMessage()); // Use System.err
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
             // Ensure the scanner resource is closed when the program ends
             // This block executes even if an unexpected exception occurs
             if (scanner != null) {
                 scanner.close();
                 // System.out.println("Scanner resource closed."); // Optional confirmation
             }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Choose an action:"); // Use System.out
        System.out.println("1. Submit New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. List Pending Jobs");
        System.out.println("4. List All Jobs (History)");
        System.out.println("5. Exit");
    }
}
