/*
 * Exam Question #204
 * Generated on: 2025-05-11 22:31:30
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Warehouse Task Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified Warehouse Task Management System. The system should manage a queue of tasks that warehouse workers need to perform, such as picking items for orders, packing items, or stocking new inventory. The system should allow a user (simulating a warehouse manager) to interact via a command-line interface to add tasks, process the next task in the queue, view the current task queue, and view the available inventory.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a queue of tasks waiting to be processed.
 *     *   Maintain a list representing the current inventory (a simple list of item names is sufficient for this problem).
 * 2.  **Task Representation:**
 *     *   Create a `WarehouseTask` class to represent individual tasks. Each task should have a type (e.g., "PICK", "PACK", "STOCK"), an item name, and a quantity. Ensure proper encapsulation.
 * 3.  **Functionality (Menu-driven):**
 *     *   **Add New Task:** Prompt the user for task details (type, item name, quantity) and add the task to the end of the task queue.
 *     *   **Process Next Task:** Take the next task from the front of the queue and simulate its execution based on its type.
 *         *   `PICK`: Simulate picking the item. If the item is not in the (simulated) inventory list, report an error.
 *         *   `PACK`: Simulate packing the item.
 *         *   `STOCK`: Simulate stocking the item. If the item is not already in the inventory list, add it.
 *     *   **View Task Queue:** Display all tasks currently in the queue in order.
 *     *   **View Inventory:** Display the current list of items in the inventory.
 *     *   **Exit:** Terminate the program.
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input for menu choices and task details.
 *     *   Use `System.out` for displaying the menu, success messages, task/inventory lists, and the exit message.
 *     *   Use `System.err` to report *all* error conditions (e.g., invalid menu choice, invalid task type, invalid quantity input, processing an empty queue, item not found for PICK task).
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options.
 *     *   Use a `switch` statement within the task processing logic to handle different task types.
 * 6.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Handle `NumberFormatException` for invalid numeric input (like quantity).
 *     *   Handle cases where the user tries to process a task when the queue is empty.
 *     *   Handle invalid task types entered by the user.
 *     *   Handle the scenario where a `PICK` task is requested for an item not in the inventory.
 *     *   Include a general catch block in the main loop or processing methods for unexpected errors, printing details to `System.err`.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Perform input validation (e.g., check task type, positive quantity).
 * 
 * **Required Java Components (must use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, print appropriate output or error messages, and loop until the user chooses to exit. Example interactions might look like:
 * 
 * ```
 * Warehouse Task Management System initialized.
 * Current Inventory: [Laptop, Keyboard, Mouse, Monitor]
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Inventory
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter Task Type (PICK, PACK, STOCK): PICK
 * Enter Item Name: Laptop
 * Enter Quantity: 2
 * Task added to queue: Task [Type: PICK, Item: Laptop, Qty: 2]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Current Task Queue ---
 * 1. Task [Type: PICK, Item: Laptop, Qty: 2]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Processing Next Task ---
 * Processing: Task [Type: PICK, Item: Laptop, Qty: 2]
 * Successfully picked 2 units of Laptop
 * Task processing complete.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Processing Next Task ---
 * Error: Task queue is empty. No tasks to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter Task Type (STOCK)
 * Enter Item Name: Gadget
 * Enter Quantity: 10
 * Task added to queue: Task [Type: STOCK, Item: Gadget, Qty: 10]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Processing Next Task ---
 * Processing: Task [Type: STOCK, Item: Gadget, Qty: 10]
 * Added 'Gadget' to inventory during STOCK task.
 * Successfully stocked 10 units of Gadget
 * Task processing complete.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Current Inventory ---
 * Total unique items: 5
 * - Laptop
 * - Keyboard
 * - Mouse
 * - Monitor
 * - Gadget
 * 
 * --- Menu ---
 * ...
 * Enter your choice: invalid
 * 
 * Error: Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter Task Type (PICK, PACK, STOCK): PULL
 * Error: Invalid task type. Please use PICK, PACK, or STOCK.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Warehouse Task Management System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing the `WarehouseTask` class and the main application class (`WarehouseManager` or similar) with a `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple Warehouse Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Core Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `taskQueue` is declared as a `Queue<WarehouseTask>` and implemented using `java.util.LinkedList`. This correctly models the "first-in, first-out" nature of tasks waiting for processing. The `offer()` method is used to add tasks to the end of the queue, and `poll()` is used to retrieve and remove tasks from the front. Iteration over the queue to view tasks is done using a for-each loop, which iterates without removing elements.
 * 2.  **`java.util.ArrayList` and `java.util.List`:** The `inventory` is declared using the `List<String>` interface and implemented with `java.util.ArrayList`. This is appropriate for storing and accessing a dynamic collection of inventory item names. `ArrayList` provides efficient access by index (`get()`) and dynamic resizing. Declaring it as a `List` demonstrates programming to the interface.
 * 3.  **`java.util.Scanner`:** The `scanner` object is used throughout the `run()` and `addTask()` methods to read user input from the console (`System.in`). Reading entire lines using `scanner.nextLine()` and then parsing (`Integer.parseInt()`) is used to correctly handle numerical input and prevent common issues with the newline character left behind by methods like `nextInt()`.
 * 4.  **`switch` statement:**
 *     *   The main application loop in the `run()` method uses a `switch` statement to dispatch control based on the user's menu choice (1-5).
 *     *   The `processNextTask()` method uses another `switch` statement to determine the logic to execute based on the `type` of the `WarehouseTask` being processed ("PICK", "PACK", "STOCK").
 * 5.  **`System.err`:** All error messages generated by the application, such as invalid input, empty queue conditions, task-specific failures (like item not found for PICK), and unexpected exceptions, are printed to `System.err`. This distinguishes error output from normal program output (`System.out`).
 * 6.  **`System.out`:** Normal program output, including the menu display, task/inventory listings, success messages, and the exit message, is printed to `System.out`.
 * 7.  **`try-catch` blocks:** Exception handling is implemented in several key areas:
 *     *   In `addTask()`: A `try-catch(NumberFormatException)` is used to handle non-integer input for the quantity. A separate `try-catch(IllegalArgumentException)` handles validation errors thrown by the `WarehouseTask` constructor. A general `catch(Exception)` catches any other unexpected errors during task addition.
 *     *   In `processNextTask()`: A `try-catch` block wraps the core processing logic to handle potential exceptions during task execution. While `poll()` doesn't throw `NoSuchElementException`, this block demonstrates where such queue-related exceptions *could* be handled if a different queue method like `remove()` were used. A general `catch(Exception)` is included for robustness against unforeseen issues during processing.
 *     *   In `run()`: A `try-catch(NumberFormatException)` is used to handle non-integer input for the main menu choice. A general `catch(Exception)` catches any other unexpected errors that might occur within the main application loop. This demonstrates class-wide handling of errors originating from user interaction or unexpected runtime conditions.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `WarehouseTask` class has private fields (`type`, `itemName`, `quantity`) and public getter methods. The `WarehouseManager` class also has private fields (`taskQueue`, `inventory`, `scanner`) accessed or modified only through its public/private methods.
 * *   **Meaningful Names:** Variable names (`taskQueue`, `inventory`, `itemName`, `quantity`, `taskToProcess`), method names (`addTask`, `processNextTask`, `viewTaskQueue`, `displayMenu`, `run`), and class names (`WarehouseTask`, `WarehouseManager`) are descriptive and indicate their purpose.
 * *   **Comments:** Comments are included to explain the purpose of classes, methods, constructors, and key sections of code, enhancing readability.
 * *   **Input Validation:** Input validation is performed for task type and quantity before creating a `WarehouseTask`. The `WarehouseTask` constructor itself also validates its inputs.
 * *   **Error Handling:** Errors are clearly reported to `System.err`. Specific exceptions (`NumberFormatException`, `IllegalArgumentException`) are caught where appropriate, alongside general `Exception` catches for broader robustness. Empty queue conditions and task-specific logic errors (like item not found for PICK) are explicitly checked and reported.
 * *   **Clean Code Structure:** The code is organized into two classes with clear responsibilities. Methods are focused on single tasks (adding, processing, viewing, displaying menu). The main `run()` method provides the application's structure. Closing the `Scanner` resource is handled upon exit.
 * 
 * This solution provides a comprehensive demonstration of integrating these fundamental and advanced Java concepts within a practical, albeit simplified, application context.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // A common implementation of List
import java.util.Scanner;
import java.util.NoSuchElementException; // Although poll() doesn't throw this, good to know for Queue operations

/**
 * Represents a single task in the warehouse management system.
 * Tasks have a type, item name, and quantity.
 */
class WarehouseTask {
    private String type;
    private String itemName;
    private int quantity;

    /**
     * Constructs a new WarehouseTask.
     *
     * @param type     The type of task (e.g., "PICK", "PACK", "STOCK").
     * @param itemName The name of the item associated with the task.
     * @param quantity The quantity of the item.
     * @throws IllegalArgumentException if task details are invalid (null, empty, or non-positive quantity).
     */
    public WarehouseTask(String type, String itemName, int quantity) {
        // Input validation in the constructor
        if (type == null || type.trim().isEmpty()) {
            throw new IllegalArgumentException("Task type cannot be null or empty.");
        }
        if (itemName == null || itemName.trim().isEmpty()) {
            throw new IllegalArgumentException("Item name cannot be null or empty.");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }

        // Standardize type to uppercase
        this.type = type.trim().toUpperCase();
        this.itemName = itemName.trim();
        this.quantity = quantity;
    }

    // --- Getters ---
    public String getType() {
        return type;
    }

    public String getItemName() {
        return itemName;
    }

    public int getQuantity() {
        return quantity;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [Type: " + type + ", Item: " + itemName + ", Qty: " + quantity + "]";
    }
}

/**
 * Manages the warehouse tasks and inventory.
 * Provides a command-line interface for interaction.
 */
public class WarehouseManager {

    // --- Required Data Structures ---
    private Queue<WarehouseTask> taskQueue; // Queue for tasks waiting to be processed
    private List<String> inventory;         // List for tracking available inventory items (simple names)
    private Scanner scanner;                // Scanner for reading user input

    /**
     * Constructs a new WarehouseManager, initializing data structures and sample inventory.
     */
    public WarehouseManager() {
        // Use LinkedList as a concrete implementation of Queue
        taskQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        inventory = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Initialize some sample inventory items
        inventory.add("Laptop");
        inventory.add("Keyboard");
        inventory.add("Mouse");
        inventory.add("Monitor");

        System.out.println("Warehouse Task Management System initialized.");
        viewInventory(); // Display initial inventory
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Inventory");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts the user for task details and adds a new task to the queue.
     * Includes input validation and error handling.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");

        System.out.print("Enter Task Type (PICK, PACK, STOCK): ");
        String type = scanner.nextLine().trim().toUpperCase(); // Read line and standardize

        // Validate task type
        if (!type.equals("PICK") && !type.equals("PACK") && !type.equals("STOCK")) {
            System.err.println("Error: Invalid task type '" + type + "'. Please use PICK, PACK, or STOCK.");
            return; // Exit method on validation failure
        }

        System.out.print("Enter Item Name: ");
        String itemName = scanner.nextLine().trim();

        int quantity = 0;
        // Use try-catch for quantity input to handle non-integer input
        try {
            System.out.print("Enter Quantity: ");
            // Read line and parse to avoid issues with scanner.nextInt() and newline characters
            quantity = Integer.parseInt(scanner.nextLine().trim());

            // Validate quantity value
            if (quantity <= 0) {
                 System.err.println("Error: Quantity must be a positive number.");
                 return; // Exit method on validation failure
            }
        } catch (NumberFormatException e) {
            // Catch specific exception for non-integer input
            System.err.println("Error: Invalid quantity input. Please enter a valid number.");
            return; // Exit method on error
        }

        // Try to create and add the task
        try {
            WarehouseTask newTask = new WarehouseTask(type, itemName, quantity);
            // offer() is generally preferred over add() for queues as it handles capacity-constrained queues gracefully
            taskQueue.offer(newTask);
            System.out.println("Task added to queue: " + newTask);
        } catch (IllegalArgumentException e) {
             // Catch validation errors from the WarehouseTask constructor
             System.err.println("Error creating task: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation/adding
             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        }
    }

    /**
     * Processes the next task from the front of the queue.
     * Uses a switch statement to handle different task types.
     * Includes error handling for an empty queue and task-specific issues.
     */
    private void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");

        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. No tasks to process.");
            return; // Exit method if queue is empty
        }

        try {
            // Retrieve and remove the head of the queue. poll() returns null if empty,
            // but we already checked isEmpty(). remove() throws NoSuchElementException if empty.
            WarehouseTask taskToProcess = taskQueue.poll();
            System.out.println("Processing: " + taskToProcess);

            // Use a switch statement to handle different task types
            switch (taskToProcess.getType()) {
                case "PICK":
                    // Simulate picking: Check if the item exists in the inventory list
                    if (inventory.contains(taskToProcess.getItemName())) {
                        System.out.println("Successfully picked " + taskToProcess.getQuantity() + " units of " + taskToProcess.getItemName() + " for an order.");
                        // In a real system, you would update inventory counts here.
                    } else {
                        // Report error if item is not found for PICK task
                        System.err.println("Error: Item '" + taskToProcess.getItemName() + "' not found in inventory for PICK task.");
                        // Option: Re-queue the task or log it as failed. For simplicity, we just report.
                    }
                    break; // Exit switch case

                case "PACK":
                    // Simulate packing
                    System.out.println("Successfully packed " + taskToProcess.getQuantity() + " units of " + taskToProcess.getItemName());
                    break; // Exit switch case

                case "STOCK":
                    // Simulate stocking: Add the item to inventory if it's not already there
                    if (!inventory.contains(taskToProcess.getItemName())) {
                         inventory.add(taskToProcess.getItemName());
                         System.out.println("Added '" + taskToProcess.getItemName() + "' to inventory during STOCK task.");
                    }
                    System.out.println("Successfully stocked " + taskToProcess.getQuantity() + " units of " + taskToProcess.getItemName());
                    // In a real system, you would update inventory counts here.
                    break; // Exit switch case

                default:
                    // This case should ideally not be reached if addTask() validates types,
                    // but included for robustness against unexpected data.
                    System.err.println("Error: Encountered unknown task type: " + taskToProcess.getType());
                    break; // Exit switch case
            }
            System.out.println("Task processing complete.");

        } catch (NoSuchElementException e) {
            // This catch block would be relevant if using taskQueue.remove(), but poll() returns null.
            // Keeping it here demonstrates handling potential queue-specific exceptions.
            System.err.println("Error processing task: Queue became empty unexpectedly.");
        } catch (Exception e) {
             // Catch any other unexpected runtime errors during task processing
             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        }
    }

    /**
     * Displays the current tasks in the queue without removing them.
     */
    private void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue elements using a for-each loop
            int index = 1;
            for (WarehouseTask task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the current items in the inventory list.
     * Demonstrates using List interface methods.
     */
    private void viewInventory() {
        System.out.println("\n--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            // Use List interface methods like size() and get()
            System.out.println("Total unique items: " + inventory.size());
            for (int i = 0; i < inventory.size(); i++) {
                System.out.println("- " + inventory.get(i));
            }
        }
    }

    /**
     * The main application loop that displays the menu and processes user input.
     * Uses a try-catch block for handling general input errors in the loop.
     */
    public void run() {
        int choice = -1;
        // Loop until the user chooses to exit (option 5)
        while (choice != 5) {
            displayMenu();
            try {
                // Read the entire line of input and parse it as an integer
                // This helps avoid issues with scanner.nextInt() leaving newline characters
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine.trim()); // Trim whitespace before parsing

                // Use a switch statement for the main menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewTaskQueue();
                        break;
                    case 4:
                        viewInventory();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse Task Management System. Goodbye!");
                        break; // Exit the switch, loop condition will be checked
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch specific exception if input cannot be parsed as an integer
                System.err.println("Error: Invalid input. Please enter a number.");
                choice = -1; // Reset choice to prevent accidental exit if 5 was entered before error
            } catch (Exception e) {
                // Catch any other unexpected errors occurring in the main loop
                System.err.println("An unexpected error occurred in the main loop: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
        }
        // Close the scanner resource when the application exits
        scanner.close();
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the WarehouseManager and start the application
        WarehouseManager manager = new WarehouseManager();
        manager.run();
    }
}
