/*
 * Exam Question #443
 * Generated on: 2025-05-11 23:11:56
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: IT Support Desk Simulation
 * 
 * **Objective:** Design and implement a command-line application simulating a simplified IT Support Desk system. The system must manage support tickets through different stages (waiting, assigned, resolved) and handle interactions with support agents. This task requires demonstrating proficiency in using core Java collections, basic I/O, control flow, and exception handling.
 * 
 * **Scenario:**
 * Users submit support tickets with a description of their issue. These tickets are placed in a waiting queue. Support agents can pick up the next available ticket from the queue to work on it. Once an agent has finished addressing the issue, they can resolve the ticket. The system needs to maintain a record of all tickets created and allow viewing tickets based on their current status.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following attributes:
 *     *   A unique integer ID.
 *     *   A `String` description of the issue.
 *     *   A `TicketStatus` (use an `enum` for WAITING, ASSIGNED, RESOLVED).
 *     *   A `String` representing the ID of the assigned agent (can be `null` if not assigned).
 *     *   Implement appropriate getters and setters.
 *     *   Override `toString()` for easy display of ticket details.
 * 
 * 2.  **Agent Representation:** Create a simple `Agent` class with a `String` ID.
 * 
 * 3.  **SupportDesk Logic:** Create a `SupportDesk` class that manages the tickets and agents. It must use the following data structures:
 *     *   A `java.util.Queue` to hold tickets that are currently WAITING for assignment. Use `java.util.LinkedList` to implement the `Queue` interface.
 *     *   A `java.util.List` to hold *all* tickets ever created in the system, regardless of their status. Use `java.util.ArrayList` to implement the `List` interface. This list serves as a historical record and allows finding any ticket by its ID.
 *     *   A `java.util.List` to hold the available `Agent` objects. Use `java.util.ArrayList` to implement the `List` interface.
 * 
 * 4.  **Core Functionalities:** The `SupportDesk` class must provide methods for:
 *     *   `submitTicket(String description)`: Creates a new ticket, assigns it a unique ID, sets its status to WAITING, adds it to both the waiting queue and the master list of all tickets.
 *     *   `assignNextTicketToAgent(String agentId)`: Finds the agent by ID. If the agent exists and the waiting queue is not empty, it takes the next ticket from the *front* of the waiting queue, changes its status to ASSIGNED, sets the assigned agent, and removes it from the waiting queue.
 *     *   `resolveTicket(int ticketId)`: Finds the ticket by its ID in the master list. If the ticket exists and its current status is ASSIGNED, it changes the status to RESOLVED.
 *     *   `viewWaitingQueue()`: Displays all tickets currently in the waiting queue.
 *     *   `viewAllTickets()`: Displays all tickets ever created in the system.
 *     *   `viewArchivedTickets()`: Displays all tickets from the master list that have a status of RESOLVED.
 * 
 * 5.  **User Interface (in `main` method):** Implement a command-line interface in the `main` method of the `SupportDesk` class using `java.util.Scanner`. The `main` method should:
 *     *   Create a `SupportDesk` instance.
 *     *   Add a few initial agents to the desk.
 *     *   Display a menu of available commands (Submit Ticket, Assign Ticket, Resolve Ticket, View Queue, View All, View Archived, Exit).
 *     *   Read user input for the command using `Scanner`.
 *     *   Use a `switch` statement to process the user's command, calling the appropriate `SupportDesk` methods.
 *     *   Prompt the user for necessary details (description, agent ID, ticket ID) based on the command.
 * 
 * 6.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and ticket lists.
 *     *   Use `System.err` for all error messages (e.g., invalid command, queue is empty, ticket not found, invalid ticket status for action, agent not found, invalid input type).
 *     *   Implement input validation where necessary (e.g., ensuring ticket ID is a number, agent ID exists, description is not empty).
 *     *   Implement **class-wide exception handling** by wrapping the main command processing loop in `main` with a `try-catch` block to catch potential runtime errors (like `InputMismatchException` from `Scanner` or unexpected `NullPointerException`s) and print an error message to `System.err` without crashing the program, allowing the user to continue (if possible).
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Expected Output:**
 * The program should start by indicating initialization. It should then repeatedly display a menu, accept a numerical command, perform the requested action (potentially asking for more input), and print the result or an error message. Listing commands should print details of the relevant tickets. Exiting should terminate the program gracefully.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Support Desk initialized with agents: AgentA, AgentB, AgentC.
 * 
 * --- Support Desk Menu ---
 * 1. Submit New Ticket
 * 2. Assign Next Waiting Ticket to Agent
 * 3. Resolve Ticket by ID
 * 4. View Waiting Queue
 * 5. View All Tickets
 * 6. View Archived Tickets
 * 0. Exit
 * Enter command: 1
 * Enter ticket description: My computer is making strange noises.
 * Ticket submitted successfully: Ticket ID: 1 | Description: My computer is making strange noises. | Status: WAITING | Assigned Agent: None
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 4
 * --- Waiting Tickets Queue ---
 * Ticket ID: 1 | Description: My computer is making strange noises. | Status: WAITING | Assigned Agent: None
 * -----------------------------
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 2
 * Enter agent ID: AgentA
 * Ticket 1 assigned to AgentA.
 * Ticket ID: 1 | Description: My computer is making strange noises. | Status: ASSIGNED | Assigned Agent: AgentA
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 4
 * --- Waiting Tickets Queue ---
 * Queue is empty. No tickets waiting.
 * -----------------------------
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 3
 * Enter ticket ID to resolve: 1
 * Ticket 1 resolved successfully.
 * Ticket ID: 1 | Description: My computer is making strange noises. | Status: RESOLVED | Assigned Agent: AgentA
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 6
 * --- Archived (Resolved) Tickets ---
 * Ticket ID: 1 | Description: My computer is making strange noises. | Status: RESOLVED | Assigned Agent: AgentA
 * -----------------------------------
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 99
 * Invalid command. Please enter a number from the menu.
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: abc
 * Invalid input. Please enter a number.
 * 
 * --- Support Desk Menu ---
 * ...
 * Enter command: 0
 * Exiting Support Desk. Goodbye!
 * Scanner closed.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simplified IT Support Desk simulation using the required Java components and best practices.
 * 
 * **Core Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming:** The problem is broken down into logical classes (`Agent`, `Ticket`, `SupportDesk`), each with encapsulated data (private fields) and well-defined behaviors (public methods).
 * 2.  **Data Structures (`java.util.Queue`, `java.util.List`, `java.util.ArrayList`):**
 *     *   `Queue<Ticket> waitingTickets = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface. This structure is ideal for the waiting queue because tickets are added to the rear (`offer`) and removed from the front (`poll`), adhering to the FIFO (First-In, First-Out) principle of a queue.
 *     *   `List<Ticket> allTickets = new ArrayList<>();`: An `ArrayList` is used to implement the `List` interface. This list stores *all* tickets ever created. It allows easy iteration and searching (`findTicketById`) and serves as the source for viewing archived tickets by filtering based on status.
 *     *   `List<Agent> agents = new ArrayList<>();`: Another `ArrayList` implementing the `List` interface is used to store the available agents. This list is used to validate agent IDs during assignment.
 * 3.  **Input/Output (`java.util.Scanner`, `System.out`, `System.err`):**
 *     *   `Scanner` is used in the `main` method to read user commands and input details like ticket descriptions or agent IDs from the console (`System.in`).
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, and successful operation messages.
 *     *   `System.err.println()` is specifically used for printing error messages, making them distinct from normal output.
 * 4.  **Control Flow (`switch`, `do-while`):**
 *     *   A `do-while` loop in `main` keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to efficiently handle the different command options entered by the user, directing the program flow to the appropriate method calls.
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block is placed around the main `do-while` loop in the `main` method. This provides "class-wide" handling for exceptions that might occur during the user interaction process (e.g., the user entering text when a number is expected, which throws `InputMismatchException`).
 *     *   Specific `catch` blocks handle `InputMismatchException` and `NoSuchElementException` (less common in simple console apps but good practice for Scanner), and a general `catch (Exception e)` handles any other unexpected runtime errors, preventing the program from crashing and providing a user-friendly error message via `System.err`. The `finally` block ensures the `Scanner` is closed.
 * 6.  **Input Validation and Error Reporting:**
 *     *   Methods like `submitTicket`, `assignNextTicketToAgent`, and `resolveTicket` include checks for invalid input (e.g., empty description, non-existent agent/ticket) or invalid state (e.g., trying to resolve a ticket that isn't assigned).
 *     *   Input validation for the command number and ticket ID number is also included within the `main` method's loop before attempting to read integers with `scanner.nextInt()`. Invalid input is consumed (`scanner.next()`) to prevent infinite loops caused by the `Scanner` failing to read the expected type.
 *     *   All validation failures and runtime errors are reported using `System.err`.
 * 7.  **Best Practices:**
 *     *   Fields in classes (`Ticket`, `Agent`, `SupportDesk`) are `private` with public getters/setters or methods to manage their state (encapsulation).
 *     *   Variable and method names (e.g., `waitingTickets`, `assignNextTicketToAgent`, `findTicketById`) are descriptive.
 *     *   Basic Javadoc comments are included for classes and methods, explaining their purpose.
 *     *   The code is structured logically with separate classes for different entities and clear methods for actions.
 * 
 * This solution effectively integrates the required Java components into a functional application, demonstrating an understanding of how to use these elements together in a practical, albeit simplified, system while adhering to important programming principles like error handling and encapsulation.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Enum to represent the status of a support ticket
enum TicketStatus {
    WAITING, ASSIGNED, RESOLVED
}

// Represents a support agent
class Agent {
    private String agentId;

    /**
     * Constructs an Agent with a specific ID.
     * @param agentId The unique identifier for the agent.
     */
    public Agent(String agentId) {
        this.agentId = agentId;
    }

    /**
     * Gets the ID of the agent.
     * @return The agent's ID.
     */
    public String getAgentId() {
        return agentId;
    }

    /**
     * Returns a string representation of the agent.
     * @return The agent's ID.
     */
    @Override
    public String toString() {
        return agentId;
    }
}

// Represents a support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;
    private String assignedAgent; // Null if not assigned

    /**
     * Constructs a new Ticket.
     * @param id The unique ID for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.WAITING;
        this.assignedAgent = null;
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    public String getAssignedAgent() {
        return assignedAgent;
    }

    // --- Setters (for state changes) ---

    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    public void setAssignedAgent(String assignedAgent) {
        this.assignedAgent = assignedAgent;
    }

    /**
     * Returns a formatted string representation of the ticket.
     * @return String containing ticket details.
     */
    @Override
    public String toString() {
        return String.format("Ticket ID: %d | Description: %s | Status: %s | Assigned Agent: %s",
                id, description, status, (assignedAgent == null ? "None" : assignedAgent));
    }
}

// The main class managing the support desk operations
public class SupportDesk {
    // Queue for tickets awaiting assignment (implements Queue)
    private Queue<Ticket> waitingTickets;
    // List for all tickets ever created (implements List)
    private List<Ticket> allTickets;
    // List of available agents (implements List)
    private List<Agent> agents;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new SupportDesk.
     * Initializes data structures and adds some default agents.
     */
    public SupportDesk() {
        // Use LinkedList as a Queue implementation
        waitingTickets = new LinkedList<>();
        // Use ArrayList as a List implementation
        allTickets = new ArrayList<>();
        // Use ArrayList as a List implementation
        agents = new ArrayList<>();
        nextTicketId = 1;

        // Add some default agents for demonstration
        agents.add(new Agent("AgentA"));
        agents.add(new Agent("AgentB"));
        agents.add(new Agent("AgentC"));
        System.out.println("Support Desk initialized with agents: AgentA, AgentB, AgentC.");
    }

    /**
     * Submits a new support ticket.
     * Creates a ticket, adds it to the waiting queue and the master list.
     * @param description The description of the issue. Must not be null or empty.
     */
    public void submitTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        waitingTickets.offer(newTicket); // Add to the waiting queue (at the end)
        allTickets.add(newTicket);       // Add to the master list of all tickets
        System.out.println("Ticket submitted successfully: " + newTicket.toString());
    }

    /**
     * Assigns the next waiting ticket from the queue to a specified agent.
     * Removes the ticket from the waiting queue upon assignment.
     * @param agentId The ID of the agent to assign the ticket to.
     */
    public void assignNextTicketToAgent(String agentId) {
        Agent agent = findAgentById(agentId);
        if (agent == null) {
            System.err.println("Error: Agent '" + agentId + "' not found.");
            return;
        }

        // Get and remove the head of the waiting queue
        Ticket ticketToAssign = waitingTickets.poll();
        if (ticketToAssign == null) {
            System.err.println("Error: No tickets currently waiting in the queue.");
            return;
        }

        // Update the ticket status and assigned agent.
        // Since the Ticket object in allTickets is the same reference,
        // updating ticketToAssign updates the object in the allTickets list as well.
        ticketToAssign.setStatus(TicketStatus.ASSIGNED);
        ticketToAssign.setAssignedAgent(agent.getAgentId());

        System.out.println("Ticket " + ticketToAssign.getId() + " assigned to " + agent.getAgentId() + ".");
        System.out.println(ticketToAssign.toString());
    }

    /**
     * Resolves an assigned ticket given its ID.
     * Changes the ticket's status to RESOLVED.
     * @param ticketId The ID of the ticket to resolve.
     */
    public void resolveTicket(int ticketId) {
        Ticket ticket = findTicketById(ticketId);

        if (ticket == null) {
            System.err.println("Error: Ticket with ID " + ticketId + " not found.");
            return;
        }

        if (ticket.getStatus() != TicketStatus.ASSIGNED) {
            System.err.println("Error: Ticket " + ticketId + " is not currently assigned. Cannot resolve.");
            System.err.println("Current status: " + ticket.getStatus());
            return;
        }

        // Update status to RESOLVED
        ticket.setStatus(TicketStatus.RESOLVED);
        // Tickets remain in the allTickets list; archived view filters this list.
        System.out.println("Ticket " + ticketId + " resolved successfully.");
        System.out.println(ticket.toString());
    }

    /**
     * Displays all tickets currently in the waiting queue.
     */
    public void viewWaitingQueue() {
        System.out.println("\n--- Waiting Tickets Queue ---");
        if (waitingTickets.isEmpty()) {
            System.out.println("Queue is empty. No tickets waiting.");
        } else {
            // Iterate over the queue without removing elements
            for (Ticket ticket : waitingTickets) {
                System.out.println(ticket.toString());
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays all tickets ever created in the system, regardless of status.
     */
    public void viewAllTickets() {
        System.out.println("\n--- All Tickets ---");
        if (allTickets.isEmpty()) {
            System.out.println("No tickets have been created yet.");
        } else {
            for (Ticket ticket : allTickets) {
                System.out.println(ticket.toString());
            }
        }
        System.out.println("-------------------");
    }

    /**
     * Displays all tickets that have been resolved (archived).
     * Filters the master list for tickets with RESOLVED status.
     */
    public void viewArchivedTickets() {
        System.out.println("\n--- Archived (Resolved) Tickets ---");
        boolean found = false;
        // Iterate through the master list and filter by status
        for (Ticket ticket : allTickets) {
            if (ticket.getStatus() == TicketStatus.RESOLVED) {
                System.out.println(ticket.toString());
                found = true;
            }
        }
        if (!found) {
            System.out.println("No tickets have been resolved yet.");
        }
        System.out.println("-----------------------------------");
    }

    /**
     * Helper method to find a ticket by its ID in the master list.
     * @param id The ID of the ticket to find.
     * @return The Ticket object if found, null otherwise.
     */
    private Ticket findTicketById(int id) {
        for (Ticket ticket : allTickets) {
            if (ticket.getId() == id) {
                return ticket;
            }
        }
        return null; // Ticket not found
    }

    /**
     * Helper method to find an agent by their ID.
     * Case-insensitive comparison for agent ID.
     * @param agentId The ID of the agent to find.
     * @return The Agent object if found, null otherwise.
     */
    private Agent findAgentById(String agentId) {
        if (agentId == null) return null;
        for (Agent agent : agents) {
            if (agent.getAgentId().equalsIgnoreCase(agentId.trim())) {
                return agent;
            }
        }
        return null; // Agent not found
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Desk Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Assign Next Waiting Ticket to Agent");
        System.out.println("3. Resolve Ticket by ID");
        System.out.println("4. View Waiting Queue");
        System.out.println("5. View All Tickets");
        System.out.println("6. View Archived Tickets");
        System.out.println("0. Exit");
        System.out.print("Enter command: ");
    }

    /**
     * Main method to run the Support Desk application.
     * Handles user interaction, command processing, and delegates to SupportDesk methods.
     * Includes class-wide exception handling for the main loop.
     */
    public static void main(String[] args) {
        SupportDesk desk = new SupportDesk();
        Scanner scanner = new Scanner(System.in);

        // --- Class-wide exception handling for the main interaction loop ---
        try {
            int command;
            // Loop until the user enters the exit command (0)
            do {
                desk.displayMenu();

                // Input validation for the command itself
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number from the menu.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of this iteration
                }

                command = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement to handle different commands
                switch (command) {
                    case 1: // Submit Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        desk.submitTicket(description);
                        break;

                    case 2: // Assign Next Ticket
                        System.out.print("Enter agent ID: ");
                        String agentId = scanner.nextLine();
                        desk.assignNextTicketToAgent(agentId);
                        break;

                    case 3: // Resolve Ticket
                        System.out.print("Enter ticket ID to resolve: ");
                        int ticketIdToResolve;
                        // Validate if the next input is an integer before reading
                        if (!scanner.hasNextInt()) {
                             System.err.println("Invalid input. Please enter a valid ticket ID (a number).");
                             scanner.next(); // Consume invalid input
                             // No break here, let the loop continue after error message
                             break; // Exit this case, continue the do-while loop
                        }
                        ticketIdToResolve = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        desk.resolveTicket(ticketIdToResolve);
                        break;

                    case 4: // View Waiting Queue
                        desk.viewWaitingQueue();
                        break;

                    case 5: // View All Tickets
                        desk.viewAllTickets();
                        break;

                    case 6: // View Archived Tickets
                        desk.viewArchivedTickets();
                        break;

                    case 0: // Exit
                        System.out.println("Exiting Support Desk. Goodbye!");
                        break; // Exit the switch, the do-while condition will be checked

                    default: // Command not recognized
                        System.err.println("Invalid command. Please enter a number from the menu.");
                }

            } while (command != 0); // Continue loop until command is 0

        } catch (InputMismatchException e) {
            // Catches errors specifically related to Scanner expecting a different type
            System.err.println("A fatal input type error occurred. Please restart and ensure you enter the correct data type when prompted.");
            // Optionally print stack trace for debugging: e.printStackTrace();
        } catch (NoSuchElementException e) {
             // Catches errors if the input stream is unexpectedly closed or empty
             System.err.println("Input stream exhausted. The application cannot read further input.");
             // Optionally print stack trace for debugging: e.printStackTrace();
        } catch (Exception e) {
            // Generic catch block for any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging: e.printStackTrace();
        } finally {
             // Ensure the scanner is closed when the application finishes or encounters a fatal error
             if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed.");
             }
        }
    }
}
