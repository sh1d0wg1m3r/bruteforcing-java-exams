/*
 * Exam Question #659
 * Generated on: 2025-05-12 16:21:08
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Software Build Queue Manager**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Software Build Queue Manager system. This system will manage build requests for various software projects. Build requests are added to a queue, processed one by one, and then moved to a history of completed builds.
 * 
 * Your program should allow users to interact with the system via a command-line interface. The system needs to handle different user commands, manage the build queue, store completed builds, and provide appropriate feedback, including error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store pending build requests.
 *     *   Use an `ArrayList` to store completed build requests.
 *     *   Declare the collection holding completed builds using the `List` interface type.
 * 
 * 2.  **User Interface:**
 *     *   Use `Scanner` to read user commands and input (like project names).
 *     *   Present a menu of options to the user:
 *         *   `1`: Add New Build Request
 *         *   `2`: Process Next Build
 *         *   `3`: View Pending Build Queue
 *         *   `4`: View Completed Builds History
 *         *   `0`: Exit
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, queue status, and completed build history.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue).
 * 
 * 3.  **Build Request Management:**
 *     *   Create a `BuildRequest` class (or an inner class) to represent a single build request. It should minimally contain:
 *         *   A unique integer `id`.
 *         *   A `String` for the `projectName`.
 *         *   A `String` for the `status` (e.g., "PENDING", "PROCESSING", "COMPLETED_SUCCESS", "COMPLETED_FAILURE").
 *     *   Assign unique IDs to build requests sequentially, starting from 1.
 *     *   When processing a build, simulate a potential failure: there should be a small random chance (e.g., 20%) that the build fails. Update the status accordingly.
 * 
 * 4.  **Flow Control:**
 *     *   Use a `switch` statement to handle the different user menu choices.
 *     *   The program should run in a loop until the user chooses the 'Exit' option.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main interaction loop to catch unexpected errors.
 *     *   Specifically handle `InputMismatchException` if the user enters non-integer input for the menu choice.
 *     *   Handle the case where the user tries to process a build when the queue is empty.
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) within your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform input validation (e.g., check if the project name is empty when adding a build).
 * 
 * **Expected Output:**
 * 
 * *   Upon starting, the program should display the menu.
 * *   Adding a build request should print a confirmation message including the build ID and project name.
 * *   Processing a build should print which build is being processed and its final status (SUCCESS or FAILURE). If the queue is empty, print an error to `System.err`.
 * *   Viewing the pending queue should list all requests currently in the queue, or state that the queue is empty.
 * *   Viewing completed builds should list all requests that have been processed, including their final status, or state that no builds have been completed.
 * *   Invalid menu choices should result in an error message printed to `System.err`.
 * *   Non-integer input for the menu should be caught, an error printed to `System.err`, and the loop should continue.
 * *   Exiting should terminate the program gracefully.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Build Queue Manager Menu ---
 * 1. Add New Build Request
 * 2. Process Next Build
 * 3. View Pending Build Queue
 * 4. View Completed Builds History
 * 0. Exit
 * Enter your choice:
 * 1
 * Enter project name: ProjectA
 * Build request #1 for ProjectA added to queue.
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 1
 * Enter project name: ProjectB
 * Build request #2 for ProjectB added to queue.
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 3
 * Pending Queue:
 * [#1 ProjectA (PENDING), #2 ProjectB (PENDING)]
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 2
 * Processing build #1 for ProjectA...
 * Build #1 for ProjectA completed with status: COMPLETED_SUCCESS
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 4
 * Completed Builds History:
 * [#1 ProjectA (COMPLETED_SUCCESS)]
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 2
 * Processing build #2 for ProjectB...
 * Build #2 for ProjectB completed with status: COMPLETED_FAILURE
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 4
 * Completed Builds History:
 * [#1 ProjectA (COMPLETED_SUCCESS), #2 ProjectB (COMPLETED_FAILURE)]
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 99
 * Invalid choice. Please enter a number from the menu.
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * abc
 * Invalid input. Please enter a number.
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 2
 * Error: No builds in the pending queue to process.
 * 
 * --- Build Queue Manager Menu ---
 * ...
 * Enter your choice:
 * 0
 * Exiting Build Queue Manager.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements the `BuildQueueManager` system as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`BuildRequest` Class:**
 *     *   This simple class encapsulates the data for a single build request: `id`, `projectName`, and `status`.
 *     *   Fields are `private` and accessed via public getters and a status setter, adhering to encapsulation principles.
 *     *   The `toString()` method provides a convenient way to represent a build request for printing.
 * 
 * 2.  **`BuildQueueManager` Class:**
 *     *   This is the core class managing the system logic.
 *     *   **`Queue<BuildRequest> pendingBuilds;`**: Declared as a `Queue` interface type and initialized with `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, allowing us to use queue-specific methods like `offer()` (to add) and `poll()` (to retrieve and remove). This fulfills the requirement to use `Queue`.
 *     *   **`List<BuildRequest> completedBuilds;`**: Declared as a `List` interface type and initialized with `new ArrayList<>()`. `ArrayList` implements the `List` interface, providing dynamic array capabilities for storing the history. This fulfills the requirements for both `ArrayList` and `List interface`.
 *     *   **`nextBuildId`**: A simple counter to ensure unique IDs for each build request.
 *     *   **`random`**: Used to simulate the random success or failure of a build.
 * 
 * 3.  **Methods:**
 *     *   **`addBuildRequest(String projectName)`**: Creates a new `BuildRequest` with the next available ID and "PENDING" status, then adds it to the `pendingBuilds` queue using `offer()`. Includes basic input validation for the project name.
 *     *   **`processNextBuild()`**: Uses `poll()` to get and remove the head of the `pendingBuilds` queue. It checks if the result is `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it simulates processing, updates the build's status (with a random outcome), prints the result to `System.out` (or `System.err` for failure), and adds the processed build to the `completedBuilds` list.
 *     *   **`viewPendingQueue()`**: Prints the contents of the `pendingBuilds` queue. `LinkedList`'s default `toString()` is convenient for this, showing the elements in order.
 *     *   **`viewCompletedBuilds()`**: Iterates through the `completedBuilds` list and prints each completed build request.
 *     *   **`displayMenu()`**: A helper method to print the user menu to `System.out`.
 *     *   **`runManager()`**: This is the main interaction loop.
 *         *   It uses `Scanner` to read user input.
 *         *   The core of the method is a `while` loop that continues until the user enters '0'.
 *         *   **`try-catch` blocks**:
 *             *   An outer `try-catch` wraps the entire `while` loop. This provides class-wide exception handling, catching any unexpected `Exception` that might occur during the execution of the loop or methods called within it. It also includes specific catches for `InputMismatchException` and `NoSuchElementException`.
 *             *   A nested `try-catch` specifically targets the `scanner.nextInt()` call to catch `InputMismatchException` if the user enters non-numeric input for the menu choice. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *             *   A catch for `NoSuchElementException` is included for robustness against issues with the input stream.
 *             *   A general `catch (Exception e)` is the fallback for any other runtime error, printing a message to `System.err`.
 *         *   **`switch (choice)`**: Inside the loop (and within the inner `try`), a `switch` statement directs the program flow based on the valid integer input, calling the appropriate manager method for each case.
 *         *   `System.out` is used for all normal output (menu, prompts, success messages, queue/history display).
 *         *   `System.err` is used exclusively for error messages (empty queue, invalid menu choice, invalid input type, general exceptions).
 *         *   A `finally` block ensures the `Scanner` is closed when the `runManager` method exits, whether normally or due to an exception.
 * 
 * 4.  **`main` Method:**
 *     *   The entry point of the application. It simply creates an instance of `BuildQueueManager` and calls its `runManager()` method to start the interactive session.
 * 
 * This solution effectively uses all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), simulates a practical scenario, incorporates best practices like encapsulation and input validation, and provides robust error handling, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Random;

/**
 * Represents a single software build request.
 */
class BuildRequest {
    private int id;
    private String projectName;
    private String status; // e.g., "PENDING", "PROCESSING", "COMPLETED_SUCCESS", "COMPLETED_FAILURE"

    /**
     * Constructs a new BuildRequest.
     *
     * @param id The unique identifier for the request.
     * @param projectName The name of the project to build.
     */
    public BuildRequest(int id, String projectName) {
        this.id = id;
        this.projectName = projectName;
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getProjectName() {
        return projectName;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used during processing)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the build request.
     */
    @Override
    public String toString() {
        return "#" + id + " " + projectName + " (" + status + ")";
    }
}

/**
 * Manages the queue of software build requests and completed builds history.
 */
public class BuildQueueManager {

    // Queue for pending build requests
    private Queue<BuildRequest> pendingBuilds;
    // List for completed build requests history - declared using the List interface
    private List<BuildRequest> completedBuilds;

    private int nextBuildId; // Counter for assigning unique build IDs
    private Random random; // For simulating build success/failure

    /**
     * Constructs a new BuildQueueManager.
     */
    public BuildQueueManager() {
        // Initialize the queue using LinkedList (implements Queue)
        this.pendingBuilds = new LinkedList<>();
        // Initialize the list using ArrayList (implements List)
        this.completedBuilds = new ArrayList<>();
        this.nextBuildId = 1; // Start IDs from 1
        this.random = new Random(); // Initialize random for simulation
    }

    /**
     * Adds a new build request to the pending queue.
     *
     * @param projectName The name of the project for the build.
     */
    public void addBuildRequest(String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            System.err.println("Error: Project name cannot be empty.");
            return;
        }
        BuildRequest newRequest = new BuildRequest(nextBuildId++, projectName.trim());
        pendingBuilds.offer(newRequest); // offer() is preferred over add() for capacity-constrained queues
        System.out.println("Build request #" + newRequest.getId() + " for " + newRequest.getProjectName() + " added to queue.");
    }

    /**
     * Processes the next build request from the pending queue.
     * Simulates processing and potential success/failure.
     */
    public void processNextBuild() {
        BuildRequest buildToProcess = pendingBuilds.poll(); // poll() retrieves and removes the head of the queue

        if (buildToProcess == null) {
            System.err.println("Error: No builds in the pending queue to process.");
            return;
        }

        System.out.println("Processing build #" + buildToProcess.getId() + " for " + buildToProcess.getProjectName() + "...");

        // Simulate build process - set status to PROCESSING briefly (optional, but good practice)
        buildToProcess.setStatus("PROCESSING");
        // In a real system, this would involve external tools/processes.
        // Here, we just simulate the outcome.

        // Simulate success or failure (e.g., 20% chance of failure)
        boolean success = random.nextInt(100) < 80; // 80% chance of success

        if (success) {
            buildToProcess.setStatus("COMPLETED_SUCCESS");
            System.out.println("Build #" + buildToProcess.getId() + " for " + buildToProcess.getProjectName() + " completed with status: COMPLETED_SUCCESS");
        } else {
            buildToProcess.setStatus("COMPLETED_FAILURE");
            System.err.println("Build #" + buildToProcess.getId() + " for " + buildToProcess.getProjectName() + " completed with status: COMPLETED_FAILURE");
        }

        // Move the processed build to the completed builds history
        completedBuilds.add(buildToProcess);
    }

    /**
     * Displays the build requests currently in the pending queue.
     */
    public void viewPendingQueue() {
        System.out.println("\n--- Pending Queue ---");
        if (pendingBuilds.isEmpty()) {
            System.out.println("The pending queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            // A simple way is to print the collection's toString() or iterate
            System.out.println(pendingBuilds); // LinkedList's toString is helpful here
            // Or iterate:
            // for (BuildRequest request : pendingBuilds) {
            //     System.out.println(request);
            // }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the history of completed build requests.
     */
    public void viewCompletedBuilds() {
        System.out.println("\n--- Completed Builds History ---");
        if (completedBuilds.isEmpty()) {
            System.out.println("No builds have been completed yet.");
        } else {
            // Iterate through the list
            for (BuildRequest request : completedBuilds) {
                System.out.println(request);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Build Queue Manager Menu ---");
        System.out.println("1. Add New Build Request");
        System.out.println("2. Process Next Build");
        System.out.println("3. View Pending Build Queue");
        System.out.println("4. View Completed Builds History");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main interaction loop for the Build Queue Manager.
     * Includes class-wide exception handling.
     */
    public void runManager() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide exception handling around the main interaction loop
        try {
            while (choice != 0) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter project name: ");
                            String projectName = scanner.nextLine();
                            addBuildRequest(projectName);
                            break;
                        case 2:
                            processNextBuild();
                            break;
                        case 3:
                            viewPendingQueue();
                            break;
                        case 4:
                            viewCompletedBuilds();
                            break;
                        case 0:
                            System.out.println("Exiting Build Queue Manager.");
                            break;
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number from the menu.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                }
                // Other specific exceptions could be caught here if needed
            }
        } catch (NoSuchElementException e) {
             // Handle potential errors with the input stream itself
             System.err.println("Error reading from input stream. Exiting.");
        } catch (Exception e) {
            // General catch-all for any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // In a real application, you would log the full stack trace: e.printStackTrace();
        } finally {
            // Ensure the scanner is closed even if exceptions occur
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Build Queue Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BuildQueueManager manager = new BuildQueueManager();
        manager.runManager();
    }
}
