/*
 * Exam Question #837
 * Generated on: 2025-05-12 16:48:42
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Topic:** Data Structures, Control Flow, Exception Handling, and Object-Oriented Design
 * **Duration:** 60 minutes
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified Warehouse Task Management System. This system will manage tasks that need to be performed by warehouse workers. Tasks are processed in a First-In, First-Out (FIFO) manner. Once a task is completed, it is moved to a list of completed tasks. The system should allow adding new tasks, processing the next available task, viewing pending tasks, viewing completed tasks, and exiting.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (unique identifier, automatically generated)
 *     *   `description` (String)
 *     *   `status` (Enum: `PENDING`, `COMPLETED`)
 *     *   Implement appropriate getters and a constructor.
 *     *   Override `toString()` to provide a user-friendly representation of the task.
 * 2.  **Warehouse Task System Class:** Create a `WarehouseTaskSystem` class that manages the tasks.
 *     *   It must have a private `Queue<Task>` to hold tasks that are waiting to be processed (pending tasks). Use a `LinkedList` implementation.
 *     *   It must have a private `List<Task>` to hold tasks that have been completed. Use an `ArrayList` implementation.
 *     *   It must maintain a counter for generating unique task IDs.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with status `PENDING`, assigns a unique ID, and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the next task from the front of the pending tasks queue, changes its status to `COMPLETED`, and adds it to the completed tasks list. Handle the case where there are no pending tasks.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending tasks queue without removing them.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed tasks list.
 * 3.  **Main Application:**
 *     *   Create a `main` method in a separate class (e.g., `WarehouseApp`).
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         *   1. Add New Task
 *         *   2. Process Next Task
 *         *   3. View Pending Tasks
 *         *   4. View Completed Tasks
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 4.  **Exception Handling:**
 *     *   Implement `try-catch` blocks to handle potential exceptions, particularly around user input operations (e.g., `InputMismatchException` if the user enters non-integer input for the menu choice).
 *     *   Implement a mechanism to handle the scenario where `processNextTask()` is called but the pending queue is empty. This should be handled gracefully without crashing.
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, input errors, attempting to process an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, task details, success messages).
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc for classes/methods, inline for complex logic).
 *     *   Validate user input where necessary (e.g., menu choice range).
 *     *   Maintain clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform actions based on the input.
 * - Adding a task should confirm the task was added.
 * - Processing a task should indicate which task was completed or if the queue was empty.
 * - Viewing tasks should list them with their details and status.
 * - Invalid input or operations on an empty queue should result in an error message printed to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Warehouse Task Management ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Pick items for Order #101
 * Task added: [ID: 1, Desc: Pick items for Order #101, Status: PENDING]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 1
 * Enter task description: Restock shelf A5
 * Task added: [ID: 2, Desc: Restock shelf A5, Status: PENDING]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 1, Desc: Pick items for Order #101, Status: PENDING]
 * [ID: 2, Desc: Restock shelf A5, Status: PENDING]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 2
 * Processing task: [ID: 1, Desc: Pick items for Order #101, Status: PENDING]
 * Task completed: [ID: 1, Desc: Pick items for Order #101, Status: COMPLETED]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 2, Desc: Restock shelf A5, Status: PENDING]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [ID: 1, Desc: Pick items for Order #101, Status: COMPLETED]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 2
 * Processing task: [ID: 2, Desc: Restock shelf A5, Status: PENDING]
 * Task completed: [ID: 2, Desc: Restock shelf A5, Status: COMPLETED]
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Warehouse Task Management ---
 * ...
 * Enter your choice: 5
 * Exiting Warehouse Task Management. Goodbye!
 * ```
 * 
 * Implement the Java code to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements a basic Warehouse Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   Represents the core data unit.
 *     *   Uses an `enum` (`TaskStatus`) for clear status representation.
 *     *   Fields (`taskId`, `description`, `status`) are `private` for encapsulation.
 *     *   Provides `public` getters.
 *     *   Includes a `setStatus` method, specifically needed for the `processNextTask` operation.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **WarehouseTaskSystem Class:**
 *     *   Acts as the controller for managing tasks.
 *     *   Uses a `private Queue<Task>` implemented by `LinkedList`. `LinkedList` is a common choice for implementing `Queue` because `offer()` (add to end) and `poll()` (remove from front) operations are efficient (O(1)). This fulfills the FIFO requirement.
 *     *   Uses a `private List<Task>` implemented by `ArrayList`. `ArrayList` is suitable for storing completed tasks as an ordered collection, allowing easy iteration and storage in completion order. This fulfills the requirement to use `ArrayList` and the `List` interface.
 *     *   `taskIdCounter` ensures unique IDs for tasks.
 *     *   Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewCompletedTasks` encapsulate the logic for manipulating the task collections.
 *     *   `addTask` uses `queue.offer()` to add to the end of the queue.
 *     *   `processNextTask` uses `queue.poll()` to remove from the front of the queue and `list.add()` to add to the completed list. It correctly handles the `null` return value of `poll()` when the queue is empty.
 *     *   `viewPendingTasks` iterates through the queue using a for-each loop, which uses the queue's iterator and does not remove elements.
 *     *   `viewCompletedTasks` iterates through the list using a for-each loop.
 * 
 * 3.  **WarehouseApp Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses `Scanner` to get input from `System.in`. The `try-with-resources` block ensures the scanner is closed automatically.
 *     *   A `boolean running` variable controls the main application loop.
 *     *   `displayMenu()` is a helper method for clarity.
 *     *   The main loop is wrapped in a `try-catch(Exception e)` block to catch any unexpected runtime errors, providing a basic form of "class-wide" or application-level exception handling for unhandled exceptions.
 *     *   Input reading for the menu choice is placed inside a `while (!validInput)` loop with a nested `try-catch(InputMismatchException e)`. This specifically handles cases where the user enters non-integer input for the menu, prints an error to `System.err`, consumes the invalid input using `scanner.next()`, and prompts the user again, preventing an infinite loop.
 *     *   `scanner.nextLine()` is called after reading the integer choice (`scanner.nextInt()`) to consume the leftover newline character, which is crucial before reading the task description string using `scanner.nextLine()`.
 *     *   A `switch` statement effectively handles the different menu options, calling the appropriate methods in the `WarehouseTaskSystem`.
 *     *   Input validation is included for the task description (not empty) and menu choice (range 1-5). Invalid inputs or operations (like processing an empty queue) result in messages printed to `System.err`. Valid operations and prompts use `System.out`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a structured, object-oriented design that simulates a practical scenario, demonstrating advanced Java concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED
}

/**
 * Represents a single task in the warehouse.
 */
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param taskId      The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for status (used when processing) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a user-friendly string representation of the Task.
     */
    @Override
    public String toString() {
        return "[ID: " + taskId + ", Desc: " + description + ", Status: " + status + "]";
    }
}

/**
 * Manages the collection of warehouse tasks using a Queue for pending and a List for completed tasks.
 */
class WarehouseTaskSystem {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int taskIdCounter; // Counter for generating unique task IDs

    /**
     * Constructs a new WarehouseTaskSystem.
     */
    public WarehouseTaskSystem() {
        // Use LinkedList for Queue implementation (FIFO)
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList for List implementation (ordered collection)
        this.completedTasks = new ArrayList<>();
        this.taskIdCounter = 0; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     *
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        taskIdCounter++; // Increment counter for next ID
        Task newTask = new Task(taskIdCounter, description);
        pendingTasks.offer(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task, updates its status, and moves it to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess); // Add to the end of the completed list
            System.out.println("Task completed: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate without removing using the Queue's iterator
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the List
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }
}

/**
 * Main application class for the Warehouse Task Management System.
 * Handles user interaction and delegates tasks to the WarehouseTaskSystem.
 */
public class WarehouseApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Warehouse Task Management ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Warehouse Task Management application.
     * Handles the main application loop and user input.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            WarehouseTaskSystem system = new WarehouseTaskSystem();
            boolean running = true;

            // Main application loop wrapped in try-catch for robustness
            try {
                while (running) {
                    displayMenu();

                    int choice = 0;
                    boolean validInput = false;

                    // Input validation loop for menu choice
                    while (!validInput) {
                        try {
                            choice = scanner.nextInt();
                            validInput = true; // Input was successfully read as an integer
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a number.");
                            scanner.next(); // Consume the invalid input to prevent infinite loop
                            displayMenu(); // Re-display menu after error
                            System.out.print("Enter your choice: "); // Re-prompt
                        }
                    }

                    // Consume the rest of the line after reading the integer choice
                    // This is important before reading string input later (e.g., task description)
                    scanner.nextLine();

                    // Switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            if (description != null && !description.trim().isEmpty()) {
                                system.addTask(description.trim());
                            } else {
                                System.err.println("Error: Task description cannot be empty.");
                            }
                            break;
                        case 2:
                            system.processNextTask();
                            break;
                        case 3:
                            system.viewPendingTasks();
                            break;
                        case 4:
                            system.viewCompletedTasks();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Warehouse Task Management. Goodbye!");
                            break;
                        default:
                            // Handle invalid menu choices
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions in the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
    }
}
