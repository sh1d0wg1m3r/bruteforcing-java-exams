/*
 * Exam Question #322
 * Generated on: 2025-05-11 22:55:04
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Technical Support Ticket System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified technical support ticket management system. The system should allow users to add new support tickets, process the next available ticket, resolve the ticket currently being processed, and view the status of tickets in the queue and in the history.
 * 
 * Your implementation must adhere to the following technical requirements and best practices:
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class to represent a support ticket. Each ticket should have:
 *     *   A unique integer ID.
 *     *   A description of the issue (String).
 *     *   A status (using an `enum` called `TicketStatus` with values: `NEW`, `IN_PROGRESS`, `RESOLVED`).
 *     *   Implement appropriate methods (constructor, getters, setters for status, `toString`).
 * 
 * 2.  **Support System Logic:** Create a `SupportSystem` class that manages the tickets. It should contain the following components:
 *     *   A `Queue` to hold incoming tickets (`NEW` status).
 *     *   A `List` (specifically using `ArrayList`) to store tickets that have been processed (`IN_PROGRESS` or `RESOLVED`).
 *     *   A variable to hold the `Ticket` currently being processed (can be null).
 *     *   A counter for generating unique ticket IDs.
 * 
 * 3.  **System Operations (Methods in `SupportSystem`):**
 *     *   `addTicket(String description)`: Creates a new `Ticket` with the next available ID and `NEW` status, and adds it to the incoming ticket `Queue`.
 *     *   `processNextTicket()`: Removes the next ticket from the `Queue`, sets its status to `IN_PROGRESS`, and assigns it to the variable holding the current ticket being processed. If the queue is empty or a ticket is already being processed, print an appropriate error message to `System.err`.
 *     *   `resolveCurrentTicket()`: Sets the status of the ticket currently being processed to `RESOLVED`, adds it to the history `List`, and clears the variable holding the current ticket being processed. If no ticket is currently being processed, print an appropriate error message to `System.err`.
 *     *   `viewQueue()`: Prints the details of all tickets currently in the incoming `Queue` to `System.out`.
 *     *   `viewHistory()`: Prints the details of all tickets in the history `List` to `System.out`.
 * 
 * 4.  **User Interface:** Implement a `main` method (either in `SupportSystem` or a separate class) that provides a command-line interface using `Scanner` to interact with the `SupportSystem`. The interface should present a menu with options for each operation (add ticket, process next, resolve, view queue, view history, exit) and use a `switch` statement to handle user choices.
 * 
 * 5.  **Error Handling & Output:**
 *     *   Use `Scanner` to read user input.
 *     *   Use `System.out` for displaying the menu, successful operation messages, and ticket details.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, queue empty, no ticket being processed, invalid input type).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle potential runtime errors during user interaction (e.g., non-integer input for menu choice) or within the system logic.
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus, but simple comments explaining logic are sufficient for the exam).
 *     *   Validate user input where necessary (e.g., check if the queue is empty before processing).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Format:**
 * 
 * *   Menu displayed clearly.
 * *   User prompts for input (e.g., "Enter ticket description:").
 * *   Successful operations confirmed with messages to `System.out`.
 * *   Error conditions reported clearly to `System.err`.
 * *   Queue and History listings show ticket details (ID, description, status).
 * *   Program exits cleanly when requested.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Technical Support System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. Resolve Current Ticket
 * 4. View Incoming Queue
 * 5. View Processed History
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket 1 added to the queue.
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 4
 * Incoming Queue:
 * Ticket ID: 1, Description: My printer is not working., Status: NEW
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket 1.
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 4
 * Incoming Queue:
 * (Queue is empty)
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 3
 * Ticket 1 resolved.
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 5
 * Processed History:
 * Ticket ID: 1, Description: My printer is not working., Status: RESOLVED
 * 
 * --- Technical Support System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Support System.
 * ```
 * 
 * **Note:** Focus on demonstrating the required Java components and error handling. The system does not need to persist data beyond the program's execution.
 *
 * EXPLANATION:
 * This solution implements a basic Technical Support Ticket System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:** This class encapsulates the data for a single ticket (ID, description, status). The `TicketStatus` enum provides a clear and type-safe way to represent the different states a ticket can be in. Getters and a setter for status are provided, and `toString()` is overridden for easy printing.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   **`Queue<Ticket> incomingTickets`:** A `LinkedList` is used here because it implements the `Queue` interface and is suitable for adding to the end (`offer`) and removing from the beginning (`poll`), simulating a waiting line for new tickets.
 *     *   **`List<Ticket> processedTicketsHistory`:** An `ArrayList` is used, declared with the `List` interface type. This list stores tickets after they have been processed (either moved to `IN_PROGRESS` and then `RESOLVED`). `ArrayList` is a good choice for storing a dynamic list of items where elements might be added over time.
 *     *   **`currentTicketBeingProcessed`:** A simple `Ticket` variable holds the single ticket that is currently being worked on by a support agent. This variable is `null` when no ticket is active.
 *     *   **`nextTicketId`:** An integer counter ensures each new ticket gets a unique ID.
 *     *   **Methods:** Each public method (`addTicket`, `processNextTicket`, `resolveCurrentTicket`, `viewQueue`, `viewHistory`) performs a specific operation, interacting with the collections and the `currentTicketBeingProcessed` variable. They follow the logic described in the problem, including checking preconditions (e.g., queue not empty, ticket being processed) before attempting an operation.
 *     *   **Encapsulation:** All data fields (`incomingTickets`, `processedTicketsHistory`, `currentTicketBeingProcessed`, `nextTicketId`) are `private`, and public methods provide controlled access and modification of the system's state.
 * 
 * 3.  **User Interface (`main` method):**
 *     *   A `Scanner` is used to read input from the console.
 *     *   A `while` loop keeps the system running until the user chooses to exit.
 *     *   The `displayMenu` method presents the options using `System.out`.
 *     *   A `switch` statement efficiently directs the program flow based on the user's integer choice, calling the corresponding `SupportSystem` methods.
 *     *   `System.out` is used for standard informational output (menu, success messages, list contents).
 *     *   `System.err` is used specifically for error messages, making them distinct from normal output.
 * 
 * 4.  **Error Handling (`try-catch` and `System.err`):**
 *     *   A large `try-catch (Exception e)` block surrounds the main `while` loop. This demonstrates **class-wide exception handling**, catching any unexpected `RuntimeException` or other `Exception` that might propagate up, preventing the program from crashing abruptly.
 *     *   A more specific `try-catch (InputMismatchException e)` is nested within the loop when reading the menu choice. This specifically handles cases where the user enters non-integer input. It prints an error to `System.err` and, crucially, calls `scanner.next()` to consume the invalid token, preventing an infinite loop caused by the `Scanner` repeatedly trying to read the same bad input.
 *     *   The `finally` block ensures the `Scanner` resource is closed when the program exits, releasing system resources.
 *     *   Within the `SupportSystem` methods (`processNextTicket`, `resolveCurrentTicket`), specific error conditions (like trying to process from an empty queue or resolve when no ticket is active) are checked *before* performing the action. If an error condition is met, an informative message is printed directly to `System.err`, and the method returns, preventing an invalid state change. This is a form of input validation and error reporting specific to the system's business logic.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names (`incomingTickets`, `processNextTicket`, `resolveCurrentTicket`, `TicketStatus`) are used throughout.
 *     *   Comments explain the purpose of classes, methods, and key variables.
 *     *   Input validation includes checking for empty queue, checking for an active ticket, and handling non-integer input.
 *     *   The code is structured into logical classes (`Ticket`, `SupportSystem`) for clarity and maintainability.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`) within a practical scenario, demonstrating proper object-oriented design, error handling, and basic input/output operations suitable for assessing advanced Java understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues

// Enum for Ticket Status
enum TicketStatus {
    NEW,
    IN_PROGRESS,
    RESOLVED
}

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.NEW; // New tickets start with NEW status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: %s, Status: %s",
                             id, description, status);
    }
}

// Manages the support tickets using Queue and List
class SupportSystem {
    // Queue for tickets waiting to be processed
    private Queue<Ticket> incomingTickets;
    // List for tickets that have been processed (IN_PROGRESS or RESOLVED)
    private List<Ticket> processedTicketsHistory;
    // The ticket currently being worked on
    private Ticket currentTicketBeingProcessed;
    // Counter for assigning unique ticket IDs
    private int nextTicketId;

    public SupportSystem() {
        // Use LinkedList as it implements the Queue interface
        this.incomingTickets = new LinkedList<>();
        // Use ArrayList for the history list
        this.processedTicketsHistory = new ArrayList<>();
        this.currentTicketBeingProcessed = null; // No ticket initially being processed
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the incoming queue.
     * @param description The description of the support issue.
     */
    public void addTicket(String description) {
        Ticket newTicket = new Ticket(nextTicketId++, description);
        incomingTickets.offer(newTicket); // offer() is preferred over add() for queues
        System.out.println("Ticket " + newTicket.getId() + " added to the queue.");
    }

    /**
     * Processes the next ticket from the queue, if available and no ticket is currently being processed.
     */
    public void processNextTicket() {
        if (currentTicketBeingProcessed != null) {
            System.err.println("Error: A ticket (ID " + currentTicketBeingProcessed.getId() + ") is already being processed.");
            return;
        }

        Ticket nextTicket = incomingTickets.poll(); // poll() retrieves and removes the head, returns null if empty

        if (nextTicket == null) {
            System.err.println("Error: The incoming ticket queue is empty.");
        } else {
            nextTicket.setStatus(TicketStatus.IN_PROGRESS);
            currentTicketBeingProcessed = nextTicket;
            // Although IN_PROGRESS, it's not yet 'history'. It moves to history upon resolving.
            System.out.println("Processing ticket " + nextTicket.getId() + ".");
        }
    }

    /**
     * Resolves the ticket currently being processed, if any.
     */
    public void resolveCurrentTicket() {
        if (currentTicketBeingProcessed == null) {
            System.err.println("Error: No ticket is currently being processed.");
            return;
        }

        currentTicketBeingProcessed.setStatus(TicketStatus.RESOLVED);
        processedTicketsHistory.add(currentTicketBeingProcessed); // Add to history list
        System.out.println("Ticket " + currentTicketBeingProcessed.getId() + " resolved.");
        currentTicketBeingProcessed = null; // Clear the current ticket
    }

    /**
     * Displays the tickets currently in the incoming queue.
     */
    public void viewQueue() {
        System.out.println("\nIncoming Queue:");
        if (incomingTickets.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing elements
            for (Ticket ticket : incomingTickets) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Displays the tickets in the processed history list.
     */
    public void viewHistory() {
        System.out.println("\nProcessed History:");
        if (processedTicketsHistory.isEmpty()) {
            System.out.println("(History is empty)");
        } else {
            for (Ticket ticket : processedTicketsHistory) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Technical Support System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. Resolve Current Ticket");
        System.out.println("4. View Incoming Queue");
        System.out.println("5. View Processed History");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the system
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide try-catch block to handle unexpected exceptions during execution
        try {
            while (running) {
                system.displayMenu();

                // Specific try-catch for reading integer choice to handle non-integer input
                int choice = -1; // Default invalid choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Consume the rest of the line after nextInt() to avoid issues with nextLine()
                     // This is a common pitfall with Scanner.
                     scanner.nextLine();
                }


                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Error: Ticket description cannot be empty.");
                        } else {
                             system.addTicket(description.trim());
                        }
                        break;
                    case 2:
                        system.processNextTicket();
                        break;
                    case 3:
                        system.resolveCurrentTicket();
                        break;
                    case 4:
                        system.viewQueue();
                        break;
                    case 5:
                        system.viewHistory();
                        break;
                    case 6:
                        System.out.println("Exiting Support System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Generic catch for any other unexpected runtime errors
            System.err.println("An unexpected system error occurred.");
            e.printStackTrace(); // Print stack trace for debugging in an exam context
        } finally {
            // Ensure the scanner is closed when the program exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
