/*
 * Exam Question #198
 * Generated on: 2025-05-11 22:30:32
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Task Management System**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team. The system should allow users to add new tasks, complete the next pending task, view all pending and completed tasks, and exit the application.
 * 
 * Tasks have a description and a priority level (e.g., High, Medium, Low). New tasks are added to a queue of pending tasks. When a task is completed, it is moved from the pending queue to an archive list of completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java concepts and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String). Include a constructor, public getter methods for the fields, and a `toString()` method for easy display.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It should have a private `Queue<Task>` to hold pending tasks. Use a `LinkedList` as the implementation for the `Queue`.
 *     *   It should have a private `List<Task>` to hold completed tasks. Use an `ArrayList` as the implementation for the `List`.
 *     *   Implement a `addTask(Task task)` method to add a new task to the pending queue.
 *     *   Implement a `completeNextTask()` method that removes the next task from the pending queue and adds it to the completed tasks list. Handle the case where the queue is empty.
 *     *   Implement a `getPendingTasks()` method returning a `List<Task>` (perhaps a copy or unmodifiable list to maintain encapsulation, but returning the underlying list is acceptable for this exam context if clearly documented or handled carefully).
 *     *   Implement a `getCompletedTasks()` method returning a `List<Task>`.
 * 3.  **User Interface (Console):**
 *     *   Implement the main application logic in a separate class (e.g., `TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user: Add Task, Complete Task, View Tasks, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   For "Add Task", prompt for the task description and priority. Validate the priority input (e.g., only accept "High", "Medium", "Low" - case-insensitive).
 *     *   For "Complete Task", call the `completeNextTask()` method.
 *     *   For "View Tasks", display both pending tasks (from the queue) and completed tasks (from the list).
 *     *   Use `System.out` for menu display, prompts, and successful output (task lists, confirmation messages).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid priority, trying to complete a task when none are pending).
 * 4.  **Exception Handling:** Implement class-wide exception handling using a `try-catch` block around the main application loop in the `main` method to catch and report unexpected errors gracefully using `System.err`. Also, handle specific expected input errors (like non-integer menu input) within the loop.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc documentation.
 *     *   Implement input validation as described.
 *     *   Ensure proper error handling as described.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * *   A clear menu displayed upon starting and after each operation (except exit).
 * *   Prompts for input when adding a task.
 * *   Confirmation messages for successful operations.
 * *   Lists of pending and completed tasks when viewing.
 * *   Error messages printed to `System.err` for invalid inputs or operations.
 * *   A graceful exit message.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View All Tasks
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter priority (High, Medium, Low): High
 * Task added: [Description: Write report, Priority: High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Enter priority (High, Medium, Low): Medium
 * Task added: [Description: Schedule meeting, Priority: Medium]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [Description: Write report, Priority: High]
 * [Description: Schedule meeting, Priority: Medium]
 * --- Completed Tasks ---
 * (None)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: [Description: Write report, Priority: High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [Description: Schedule meeting, Priority: Medium]
 * --- Completed Tasks ---
 * [Description: Write report, Priority: High]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: [Description: Schedule meeting, Priority: Medium]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks pending to complete.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Exiting Task Management System.
 * ```
 * 
 * Implement the Java code for this Task Management System.
 *
 * EXPLANATION:
 * The solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `description` and `priority`.
 *     *   Private fields ensure encapsulation.
 *     *   Public getters provide controlled access to the data.
 *     *   The constructor includes basic validation to prevent empty description or priority, throwing `IllegalArgumentException`.
 *     *   `toString()` provides a convenient string representation for display.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the collections of tasks.
 *     *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. Tasks are added to the end and removed from the front, simulating a waiting line. `offer()` is used for adding, which is the preferred `Queue` method as it handles capacity constraints (though `LinkedList` is unbounded). `poll()` is used for removing from the front, returning `null` if the queue is empty.
 *     *   `completedTasks`: A `List<Task>` implemented using `ArrayList`. Completed tasks are simply added to this list. `ArrayList` is suitable for storing and iterating over completed tasks.
 *     *   `addTask(Task task)`: Adds a task to the `pendingTasks` queue using `offer()`.
 *     *   `completeNextTask()`: Removes the head of the `pendingTasks` queue using `poll()`. If a task is successfully removed (`poll()` returns non-null), it's added to the `completedTasks` list.
 *     *   `getPendingTasks()`: Returns a *new* `ArrayList` containing the elements from the `pendingTasks` queue. This is a good practice to prevent external code from modifying the internal queue structure directly.
 *     *   `getCompletedTasks()`: Returns the internal `completedTasks` list reference. For simplicity in this exam, modifying this list externally wouldn't break the core logic, but in a production system, returning a copy or an unmodifiable list would be safer.
 *     *   `isPendingTasksEmpty()`: A helper method to check if the queue is empty before attempting to complete a task, allowing for a cleaner error message.
 * 
 * 3.  **`TaskApp` Class:**
 *     *   Contains the `main` method and the application's main loop.
 *     *   Uses `Scanner` to get user input.
 *     *   The `run()` method contains the main loop (`while(running)`).
 *     *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This catches any unexpected runtime exception that might occur within the loop, preventing the application from crashing abruptly and printing an error message to `System.err`.
 *     *   **Input Handling and `switch`:**
 *         *   `displayMenu()` prints the options to `System.out`.
 *         *   The code attempts to read an integer choice using `scanner.nextInt()`.
 *         *   A specific `catch (InputMismatchException e)` block handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   `scanner.nextLine()` is called in a `finally` block (or after `nextInt()` in the `try`) to consume the leftover newline character after reading the integer, preventing issues with subsequent `nextLine()` calls.
 *         *   A `switch` statement processes the valid integer choice, calling the appropriate handler method (`handleAddTask`, `handleCompleteTask`, `handleViewTasks`).
 *         *   The `default` case of the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   **Handler Methods (`handleAddTask`, `handleCompleteTask`, `handleViewTasks`):**
 *         *   Interact with the user via `System.out` for prompts and success messages.
 *         *   Call methods on the `taskManager` instance to perform operations.
 *         *   Implement input validation for task priority in `handleAddTask` using a `while` loop and checking against valid values (case-insensitive). Invalid priority input results in an error message to `System.err`.
 *         *   `handleCompleteTask` checks if the pending queue is empty using `taskManager.isPendingTasksEmpty()` before calling `completeNextTask()`, providing a specific error message to `System.err` if the queue is empty.
 *         *   `handleViewTasks` retrieves lists from the `taskManager` and iterates through them, printing tasks to `System.out`. It also prints "(None)" if a list is empty.
 *     *   **Resource Management:** The `Scanner` is closed in the `finally` block of the main `try-catch` to release system resources when the application exits (either normally or due to an uncaught exception).
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating encapsulation, input validation, and error handling according to best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task (e.g., "High", "Medium", "Low").
     */
    public Task(String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null || priority.trim().isEmpty()) {
             throw new IllegalArgumentException("Task priority cannot be empty.");
        }
        this.description = description.trim();
        this.priority = priority.trim();
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the priority of the task.
     *
     * @return The task priority.
     */
    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "[Description: " + description + ", Priority: " + priority + "]";
    }
}

/**
 * Manages collections of pending and completed tasks.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // Using LinkedList as a Queue implementation
        this.completedTasks = new ArrayList<>(); // Using ArrayList as a List implementation
    }

    /**
     * Adds a new task to the queue of pending tasks.
     *
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasks.offer(task); // offer is preferred over add for queues
        }
    }

    /**
     * Completes the next task in the pending queue by moving it to the completed list.
     *
     * @return The completed task, or null if the pending queue was empty.
     */
    public Task completeNextTask() {
        Task completedTask = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        if (completedTask != null) {
            completedTasks.add(completedTask);
        }
        return completedTask;
    }

    /**
     * Gets a list of all pending tasks.
     *
     * @return A new ArrayList containing the pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new list to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     *
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Returning the internal list reference for simplicity in this exam context
    }

    /**
     * Checks if there are any pending tasks.
     *
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingTasksEmpty() {
        return pendingTasks.isEmpty();
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and orchestrates TaskManager operations.
 */
public class TaskApp {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs a new TaskApp, initializing the TaskManager and Scanner.
     */
    public TaskApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     */
    private void handleAddTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        String priority;
        while (true) {
            System.out.print("Enter priority (High, Medium, Low): ");
            priority = scanner.nextLine().trim();
            if (priority.equalsIgnoreCase("High") || priority.equalsIgnoreCase("Medium") || priority.equalsIgnoreCase("Low")) {
                break; // Valid priority entered
            } else {
                System.err.println("Invalid priority. Please enter High, Medium, or Low.");
            }
        }

        try {
            Task newTask = new Task(description, priority);
            taskManager.addTask(newTask);
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating task: " + e.getMessage());
        }
    }

    /**
     * Attempts to complete the next pending task.
     */
    private void handleCompleteTask() {
        if (taskManager.isPendingTasksEmpty()) {
            System.err.println("Error: No tasks pending to complete.");
        } else {
            Task completedTask = taskManager.completeNextTask();
            if (completedTask != null) {
                System.out.println("Completed task: " + completedTask);
            } else {
                 // This case should theoretically not be reached due to the isEmpty check,
                 // but included for robustness in case poll() returns null unexpectedly.
                System.err.println("Error completing task.");
            }
        }
    }

    /**
     * Displays all pending and completed tasks.
     */
    private void handleViewTasks() {
        List<Task> pending = taskManager.getPendingTasks();
        List<Task> completed = taskManager.getCompletedTasks();

        System.out.println("\n--- Pending Tasks ---");
        if (pending.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < pending.size(); i++) {
                System.out.println((i + 1) + ". " + pending.get(i));
            }
        }

        System.out.println("\n--- Completed Tasks ---");
        if (completed.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (int i = 0; i < completed.size(); i++) {
                 // Note: Iterating over ArrayList is straightforward
                System.out.println((i + 1) + ". " + completed.get(i));
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop iteration
                } finally {
                     // Consume the newline character left by nextInt()
                    scanner.nextLine();
                }

                switch (choice) {
                    case 1:
                        handleAddTask();
                        break;
                    case 2:
                        handleCompleteTask();
                        break;
                    case 3:
                        handleViewTasks();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception during the application runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskApp app = new TaskApp();
        app.run();
    }
}
