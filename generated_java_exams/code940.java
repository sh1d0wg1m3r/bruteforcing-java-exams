/*
 * Exam Question #940
 * Generated on: 2025-05-12 17:02:44
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Objective:** Implement a console-based application that simulates a simple task management system. The system should allow users to add tasks, view pending tasks, complete the next pending task, and view completed tasks. This task requires you to demonstrate your understanding of core Java data structures, control flow, user input handling, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` (specifically, an implementation from `java.util`) to store tasks that are pending completion. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use an `ArrayList` to store tasks that have been completed.
 *     *   Declare the completed tasks storage using the `List` interface.
 * 
 * 2.  **User Interface:**
 *     *   Implement a simple console menu using `System.out` for options and prompts.
 *     *   Use `Scanner` to read user input for menu choices and task details.
 * 
 * 3.  **Application Flow:**
 *     *   The application should run in a loop until the user chooses to exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement the following menu options:
 *         *   **Add New Task:** Prompt the user for a task description and add it to the pending tasks queue.
 *         *   **View Pending Tasks:** Display all tasks currently in the pending queue without removing them.
 *         *   **Complete Next Pending Task:** Remove the task at the front of the pending queue and add it to the completed tasks list.
 *         *   **View Completed Tasks:** Display all tasks in the completed tasks list.
 *         *   **Exit:** Terminate the application.
 * 
 * 4.  **Error Handling & Validation:**
 *     *   Implement input validation for the task description (e.g., disallow empty descriptions).
 *     *   Handle cases where the user tries to complete a task when the pending queue is empty.
 *     *   Use `System.err` to report error messages (e.g., invalid menu input, empty description, attempting to complete from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues, such as the user entering non-integer input for the menu choice.
 * 
 * 5.  **Code Structure & Best Practices:**
 *     *   Create a `Task` class (or similar) to represent a task with at least a description. Use proper encapsulation (private fields, public getters).
 *     *   Create a main class (e.g., `TaskManager`) to manage the queues, lists, and application logic.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex parts or the purpose of classes/methods.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, accept user input, and provide feedback using `System.out` and `System.err` as specified. Example interaction might look like:
 * 
 * ```
 * ===== Task Manager Menu =====
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Complete Next Pending Task
 * 4. View Completed Tasks
 * 5. Exit
 * ===========================
 * Enter choice: 1
 * Enter task description: Write exam question
 * Task added: "Write exam question"
 * 
 * ===== Task Manager Menu =====
 * 1. Add New Task
 * ...
 * Enter choice: 1
 * Enter task description: Review solution
 * Task added: "Review solution"
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 2
 * --- Pending Tasks ---
 * 1. - Write exam question
 * 2. - Review solution
 * ---------------------
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 3
 * Completed task: "Write exam question"
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 2
 * --- Pending Tasks ---
 * 1. - Review solution
 * ---------------------
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 4
 * --- Completed Tasks ---
 * 1. - Write exam question
 * -----------------------
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: abc
 * Invalid input. Please enter a number.
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 3
 * Completed task: "Review solution"
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 3
 * Error: No pending tasks to complete.
 * 
 * ===== Task Manager Menu =====
 * ...
 * Enter choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Your solution should provide the complete Java code for this application.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Task Management System, fulfilling all the specified requirements and demonstrating the use of the required Java components and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** A `LinkedList` is used to implement the `Queue` interface for `pendingTasks`. This ensures tasks are processed in a First-In, First-Out (FIFO) order, which is typical for task queues. The `offer()` method is used to add tasks, and `poll()` is used to remove and retrieve the head of the queue when a task is completed. Iteration is done using a for-each loop without removing elements to display pending tasks.
 * 2.  **`java.util.ArrayList`:** An `ArrayList` is used to store `completedTasks`. This provides a dynamic array implementation suitable for storing a growing list of completed items.
 * 3.  **`java.util.List` interface:** The `completedTasks` variable is declared using the `List<Task>` interface type, although it's instantiated as an `ArrayList`. This demonstrates programming to an interface, a key object-oriented design principle that promotes flexibility.
 * 4.  **`java.util.Scanner`:** An instance of `Scanner` is used to read user input from `System.in`. It's used to read both integer choices (`nextInt()`) and String descriptions (`nextLine()`). Care is taken to consume the leftover newline character after reading an integer using `scanner.nextLine()`. The scanner is closed when the application exits.
 * 5.  **`switch` statement:** A `switch` statement is used in the `run()` method to control the application flow based on the user's integer input for the menu choice. Each case corresponds to a specific menu option, calling the appropriate method in the `TaskManager` class.
 * 6.  **`System.err`:** `System.err.println()` is used specifically for outputting error messages, such as invalid menu input, empty task descriptions, or attempting to complete a task when the pending queue is empty. This distinguishes error output from normal application messages.
 * 7.  **`System.out`:** `System.out.println()` is used for all standard application output, including displaying the menu, prompts, task listings, and success messages (like confirming a task was added or completed).
 * 8.  **Class-wide `try-catch`:** A `try-catch` block is placed around the core logic within the `run()` method's `while` loop. This block attempts to read user input and process the menu choice. It catches `InputMismatchException` if the user enters non-integer input for the menu, preventing the program from crashing and allowing the loop to continue after reporting the error. A general `catch (Exception e)` is also included as a fallback for any other unexpected errors during the loop's execution, providing a basic level of robustness.
 * 9.  **Encapsulation:** The `Task` class has a private `description` field with a public getter method. The `TaskManager` class has private fields (`pendingTasks`, `completedTasks`, `scanner`) and public methods (`addTask`, `viewPendingTasks`, etc.) that provide controlled access to the internal state.
 * 10. **Meaningful Names:** Classes (`Task`, `TaskManager`), fields (`pendingTasks`, `completedTasks`), and methods (`addTask`, `completeNextTask`, `run`, `printMenu`) have names that clearly indicate their purpose.
 * 11. **Comments:** Basic comments are included to explain the purpose of classes, fields, methods, and specific code blocks (like the try-catch or scanner newline consumption).
 * 12. **Input Validation:** The `addTask` method explicitly checks if the provided description is null or empty/whitespace, using `trim().isEmpty()`, and reports an error via `System.err` if invalid.
 * 13. **Error Handling:** Beyond the `try-catch` for input, methods like `completeNextTask` and `viewPendingTasks`/`viewCompletedTasks` explicitly check for empty collections before attempting operations that would fail or be meaningless, providing user-friendly error messages via `System.err` or informative messages via `System.out`.
 * 14. **Clean Structure:** The code is divided into logical units (`Task` class, `TaskManager` class) with a clear entry point (`main`) and a dedicated method (`run`) for the main application loop.
 * 
 * This solution effectively integrates the required components into a functional and well-structured program, demonstrating a solid understanding of fundamental and intermediate Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string for the task.
     */
    @Override
    public String toString() {
        return "- " + description;
    }
}

// Manages the collection of pending and completed tasks
public class TaskManager {
    // Queue for tasks waiting to be completed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending tasks queue and completed tasks list.
     */
    public TaskManager() {
        // Use LinkedList as it implements Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as it implements List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Validates that the description is not empty.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        // offer() is preferred for queues, returns false on failure but LinkedList doesn't really fail
        pendingTasks.offer(new Task(description.trim()));
        System.out.println("Task added: \"" + description.trim() + "\"");
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Does not remove tasks from the queue.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }
        System.out.println("--- Pending Tasks ---");
        // Iterate through the queue elements without removing them
        int index = 1;
        for (Task task : pendingTasks) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("---------------------");
    }

    /**
     * Completes the next task in the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * Reports an error if the pending queue is empty.
     */
    public void completeNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to complete.");
            return;
        }
        // poll() removes and returns the head of the queue, or null if empty (handled by the if check)
        Task completedTask = pendingTasks.poll();
        completedTasks.add(completedTask); // Add to the completed list
        System.out.println("Completed task: \"" + completedTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
            return;
        }
        System.out.println("--- Completed Tasks ---");
        int index = 1;
        for (Task task : completedTasks) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("-----------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("===== Task Manager Menu =====");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Complete Next Pending Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("===========================");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling for input and general errors.
     */
    public void run() {
        int choice = -1;
        // Loop until the user chooses to exit (choice 5)
        while (choice != 5) {
            printMenu();
            try {
                System.out.print("Enter choice: ");
                // Read integer input for menu choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description); // Call method to add task
                        break;
                    case 2:
                        viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 3:
                        completeNextTask(); // Call method to complete next task
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to prevent accidental exit if '5' was attempted with invalid chars
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
            System.out.println(); // Add a newline for better separation between interactions
        }
        scanner.close(); // Close the scanner resource when exiting
    }

    /**
     * Main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application loop
    }
}
