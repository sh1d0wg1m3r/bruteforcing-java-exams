/*
 * Exam Question #1122
 * Generated on: 2025-05-12 17:28:04
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam: Clinic Appointment Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line application for a small clinic to manage patient check-ins and appointment scheduling. The system needs to handle patients arriving and waiting, and assign them to pre-defined doctor appointment slots as they become available.
 * 
 * Your solution must demonstrate a strong understanding of fundamental and advanced Java concepts, including data structures, object-oriented programming, user interaction, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a waiting list of patients using a `java.util.Queue`. Patients check in and are added to the end of this queue.
 *     *   Maintain a list of available appointment slots using `java.util.ArrayList`, declared as a `java.util.List`. These slots are pre-defined with a doctor and time.
 * 2.  **Classes:**
 *     *   Create a `Patient` class with a private field for the patient's name, a constructor, and a public getter.
 *     *   Create an `AppointmentSlot` class with private fields for the doctor's name, time, a boolean indicating if it's booked, and a reference to the `Patient` who booked it (or null if not booked). Include a constructor, public getters, and a public method to `bookSlot(Patient patient)` which marks the slot as booked and assigns the patient. This method should throw an exception if the slot is already booked.
 *     *   Create a main `ClinicSystem` class that orchestrates the application logic.
 * 3.  **Functionality (in `ClinicSystem`):**
 *     *   Initialize the system with a few sample `AppointmentSlot` objects in the `availableSlots` list.
 *     *   Implement a command-line menu for the user with the following options:
 *         *   `1. Patient Check-in`: Prompt for patient name and add a new `Patient` object to the waiting queue.
 *         *   `2. View Waiting Queue`: Display the names of all patients currently in the queue, in order.
 *         *   `3. View Available Slots`: Display all appointment slots, indicating whether each is available or booked (and by whom).
 *         *   `4. Assign Next Patient to Slot`: Take the patient at the front of the waiting queue and assign them to the *first available* appointment slot found in the `availableSlots` list. If the queue is empty or no slots are available, provide an appropriate message. If successful, update the slot's status and remove the patient from the queue.
 *         *   `5. Exit`: Terminate the application.
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for all normal output (menu, status messages, list/queue contents).
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, queue empty, no slots available, invalid patient name).
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use a loop to keep the menu running until the user chooses to exit.
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop (`ClinicSystem.run()`) to gracefully handle potential issues like invalid user input (`InputMismatchException`) or unexpected errors during operations.
 *     *   The `AppointmentSlot.bookSlot()` method should throw an exception if attempting to book an already booked slot. Handle this exception appropriately where the method is called.
 *     *   Handle cases where the queue is empty or no slots are available during the "Assign Patient" operation without throwing exceptions, but by printing informative messages to `System.err`.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes and public methods).
 *     *   Implement basic input validation (e.g., patient name not empty).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform the requested actions, printing status and results to `System.out` and errors to `System.err`. For example:
 * 
 * ```
 * --- Clinic Management Menu ---
 * 1. Patient Check-in
 * 2. View Waiting Queue
 * 3. View Available Slots
 * 4. Assign Next Patient to Slot
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * 
 * Patient Alice checked in and added to the waiting queue.
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Waiting Queue ---
 * 1. Alice
 * ---------------------
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Available Slots ---
 * Slot 1: Dr. Smith at 10:00 AM [Available]
 * Slot 2: Dr. Jones at 10:30 AM [Available]
 * Slot 3: Dr. Smith at 11:00 AM [Booked by Bob]
 * ---------------------
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * Assigning next patient...
 * Patient Alice assigned to slot with Dr. Smith at 10:00 AM.
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * Assigning next patient...
 * Error: No patients in the waiting queue.
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Available Slots ---
 * Slot 1: Dr. Smith at 10:00 AM [Booked by Alice]
 * Slot 2: Dr. Jones at 10:30 AM [Available]
 * Slot 3: Dr. Smith at 11:00 AM [Booked by Bob]
 * ---------------------
 * 
 * --- Clinic Management Menu ---
 * ...
 * Enter your choice: 5
 * 
 * Exiting Clinic Management System.
 * ```
 * 
 * Your solution should be provided as a single block of Java code.
 *
 * EXPLANATION:
 * This solution implements a simplified clinic appointment management system, fulfilling all the specified requirements and demonstrating key Java concepts.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming (OOP):**
 *     *   **Encapsulation:** The `Patient` and `AppointmentSlot` classes use private fields (`name`, `doctorName`, `time`, `isBooked`, `bookedPatient`) and public getter methods (`getName`, `getDoctorName`, etc.) to control access to their internal state.
 *     *   **Classes and Objects:** The system is built around distinct objects (`Patient`, `AppointmentSlot`, `ClinicSystem`) interacting with each other.
 * 
 * 2.  **Data Structures (`java.util`):**
 *     *   **`Queue`:** A `LinkedList` is used to implement the `Queue` interface for the `waitingQueue`. This correctly simulates patients arriving and waiting in a first-in, first-out (FIFO) manner. `add()` is used for enqueueing, and `poll()` is used for dequeueing. `peek()` is used to look at the next patient without removing them.
 *     *   **`ArrayList` and `List`:** An `ArrayList` is used to store `AppointmentSlot` objects, declared using the `List` interface (`List<AppointmentSlot> availableSlots = new ArrayList<>();`). This demonstrates polymorphism and the use of the `List` contract. `ArrayList` provides dynamic resizing and efficient element access/iteration.
 *     *   The interaction between the `Queue` (waiting patients) and the `List` (available slots) is central to the `assignNextPatientToSlot` logic.
 * 
 * 3.  **User Interaction (`java.util.Scanner`):**
 *     *   A `Scanner` object reads input from `System.in`, allowing the user to interact with the menu.
 *     *   `scanner.nextInt()` is used for reading the menu choice, and `scanner.nextLine()` is used to read string input (patient name) and also crucially to consume the newline character left after reading an integer, preventing input issues in the next loop iteration. The scanner is closed upon exiting the application.
 * 
 * 4.  **Control Flow (`switch`, `while`):**
 *     *   A `while` loop keeps the application running until the user chooses to exit (`choice == 5`).
 *     *   A `switch` statement efficiently handles the different menu options selected by the user, directing execution to the appropriate methods.
 * 
 * 5.  **Input/Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, success messages, and the contents of the queue and slot list.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid menu choices, empty queues, no available slots, or invalid patient names. This separates error output from normal program output.
 * 
 * 6.  **Exception Handling (`try-catch`, `throws`):**
 *     *   A `try-catch` block is used in the main `run()` loop to provide class-wide exception handling. It specifically catches `InputMismatchException` for invalid non-integer menu input, preventing the program from crashing and prompting the user to try again.
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing a generic error message and the stack trace to `System.err` for debugging.
 *     *   The `AppointmentSlot.bookSlot()` method uses `throws IllegalStateException` to indicate that it might throw this specific exception if called on an already booked slot.
 *     *   The `assignNextPatientToSlot()` method calls `bookSlot()` within a `try-catch` block to handle the `IllegalStateException` thrown by `bookSlot`, although the logic is designed to avoid this by finding the *first available* slot. It also includes a general `catch (Exception e)` for other potential issues during assignment.
 * 
 * 7.  **Best Practices:**
 *     *   Meaningful names (`waitingQueue`, `availableSlots`, `addPatientToQueue`, `assignNextPatientToSlot`) improve code readability.
 *     *   Basic Javadoc comments explain the purpose of classes and public methods.
 *     *   Input validation is performed for the patient name to ensure it's not empty.
 *     *   Error handling for specific operational issues (empty queue, no slots) is handled gracefully with `System.err` messages rather than crashing.
 *     *   The code is structured into logical methods (`addPatientToQueue`, `viewWaitingQueue`, etc.) within the `ClinicSystem` class, promoting modularity and maintainability.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating advanced understanding of Java programming principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the clinic system.
 */
class Patient {
    private String name;

    /**
     * Constructs a new Patient object.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Represents an available appointment slot with a doctor.
 */
class AppointmentSlot {
    private String doctorName;
    private String time;
    private boolean isBooked;
    private Patient bookedPatient;

    /**
     * Constructs a new AppointmentSlot.
     * @param doctorName The name of the doctor.
     * @param time The time of the appointment slot.
     */
    public AppointmentSlot(String doctorName, String time) {
        this.doctorName = doctorName;
        this.time = time;
        this.isBooked = false;
        this.bookedPatient = null;
    }

    /**
     * Gets the name of the doctor for this slot.
     * @return The doctor's name.
     */
    public String getDoctorName() {
        return doctorName;
    }

    /**
     * Gets the time of this slot.
     * @return The slot time.
     */
    public String getTime() {
        return time;
    }

    /**
     * Checks if the slot is currently booked.
     * @return true if booked, false otherwise.
     */
    public boolean isBooked() {
        return isBooked;
    }

    /**
     * Gets the patient booked for this slot, or null if not booked.
     * @return The booked Patient object or null.
     */
    public Patient getBookedPatient() {
        return bookedPatient;
    }

    /**
     * Books this appointment slot for a given patient.
     * @param patient The patient to book the slot for.
     * @throws IllegalStateException if the slot is already booked.
     */
    public void bookSlot(Patient patient) throws IllegalStateException {
        if (this.isBooked) {
            throw new IllegalStateException("Slot with " + doctorName + " at " + time + " is already booked.");
        }
        this.bookedPatient = patient;
        this.isBooked = true;
    }

    @Override
    public String toString() {
        return "Dr. " + doctorName + " at " + time +
               " [" + (isBooked ? "Booked by " + bookedPatient.getName() : "Available") + "]";
    }
}

/**
 * Main class for the Clinic Appointment Management System.
 * Manages the patient waiting queue and available appointment slots.
 */
public class ClinicSystem {

    private Queue<Patient> waitingQueue;
    private List<AppointmentSlot> availableSlots;
    private Scanner scanner;

    /**
     * Constructs a new ClinicSystem, initializing data structures and sample slots.
     */
    public ClinicSystem() {
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        availableSlots = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);

        // Initialize with some sample slots
        availableSlots.add(new AppointmentSlot("Smith", "10:00 AM"));
        availableSlots.add(new AppointmentSlot("Jones", "10:30 AM"));
        availableSlots.add(new AppointmentSlot("Smith", "11:00 AM"));
        availableSlots.add(new AppointmentSlot("Jones", "11:30 AM"));
        availableSlots.add(new AppointmentSlot("Smith", "01:00 PM"));
        // Example of a pre-booked slot
        try {
             AppointmentSlot preBooked = new AppointmentSlot("Jones", "02:00 PM");
             preBooked.bookSlot(new Patient("Bob")); // Assuming Bob was booked externally
             availableSlots.add(preBooked);
        } catch (IllegalStateException e) {
             // Should not happen with a new slot, but good practice
             System.err.println("Error initializing pre-booked slot: " + e.getMessage());
        }
    }

    /**
     * Adds a new patient to the waiting queue.
     */
    private void addPatientToQueue() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        Patient patient = new Patient(name);
        waitingQueue.add(patient);
        System.out.println("\nPatient " + patient.getName() + " checked in and added to the waiting queue.");
    }

    /**
     * Displays the current waiting queue.
     */
    private void viewWaitingQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            int i = 1;
            // Iterating over a Queue does not remove elements
            for (Patient patient : waitingQueue) {
                System.out.println(i++ + ". " + patient.getName());
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all available and booked appointment slots.
     */
    private void viewAvailableSlots() {
        System.out.println("\n--- Available Slots ---");
        if (availableSlots.isEmpty()) {
            System.out.println("No appointment slots defined.");
        } else {
            int i = 1;
            for (AppointmentSlot slot : availableSlots) {
                System.out.println("Slot " + i++ + ": " + slot);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Assigns the next patient from the queue to the first available slot.
     */
    private void assignNextPatientToSlot() {
        System.out.println("\nAssigning next patient...");

        if (waitingQueue.isEmpty()) {
            System.err.println("Error: No patients in the waiting queue.");
            return;
        }

        Patient nextPatient = waitingQueue.peek(); // Peek to get without removing yet

        AppointmentSlot availableSlot = null;
        for (AppointmentSlot slot : availableSlots) {
            if (!slot.isBooked()) {
                availableSlot = slot;
                break; // Found the first available slot
            }
        }

        if (availableSlot == null) {
            System.err.println("Error: No available appointment slots at the moment.");
            // Patient remains in the queue
        } else {
            try {
                availableSlot.bookSlot(nextPatient); // Book the slot
                waitingQueue.poll(); // Remove patient from queue ONLY after successful booking
                System.out.println("Patient " + nextPatient.getName() +
                                   " assigned to slot with " + availableSlot.getDoctorName() +
                                   " at " + availableSlot.getTime() + ".");
            } catch (IllegalStateException e) {
                // This catch block handles the specific exception from bookSlot
                // In this logic, we find the first available slot, so this catch
                // should ideally not be hit unless there's a concurrency issue
                // or logic error elsewhere, but included as per requirements.
                System.err.println("System Error: Tried to book an already booked slot. " + e.getMessage());
                 // Patient remains in queue in case of this unexpected booking failure
            } catch (Exception e) {
                 // Catch any other unexpected errors during assignment
                 System.err.println("An unexpected error occurred during assignment: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace to System.err
                 // Patient remains in queue
            }
        }
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Clinic Management Menu ---");
        System.out.println("1. Patient Check-in");
        System.out.println("2. View Waiting Queue");
        System.out.println("3. View Available Slots");
        System.out.println("4. Assign Next Patient to Slot");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;

        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                switch (choice) {
                    case 1:
                        addPatientToQueue();
                        break;
                    case 2:
                        viewWaitingQueue();
                        break;
                    case 3:
                        viewAvailableSlots();
                        break;
                    case 4:
                        assignNextPatientToSlot();
                        break;
                    case 5:
                        System.out.println("\nExiting Clinic Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue the loop
            } catch (Exception e) {
                // Class-wide catch for any other unexpected runtime exceptions
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ClinicSystem system = new ClinicSystem();
        system.run();
    }
}
