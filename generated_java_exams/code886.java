/*
 * Exam Question #886
 * Generated on: 2025-05-12 16:55:07
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam: Event Seating Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Seating Management System. The system should allow attendees to register for an event and manage their entry into the seating area. Due to limited capacity and high demand, attendees are added to a queue for seating in the order they register.
 * 
 * Your system must manage a list of all registered attendees and a separate queue for attendees currently waiting to be seated.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Representation:** Create a class `Attendee` with private fields for `id` (a unique integer, auto-generated), `name`, `email`, and a boolean `isSeated` (initially `false`). Provide a constructor and public getter methods for these fields. The `id` should be assigned sequentially starting from 1 upon object creation using a static counter.
 * 2.  **Event Management:** Create a class `EventManager` that manages the event state.
 *     *   It must contain a `java.util.List` (specifically implemented as `java.util.ArrayList`) to store *all* registered attendees.
 *     *   It must contain a `java.util.Queue` (you can choose an appropriate implementation like `java.util.LinkedList` or `java.util.ArrayDeque`) to store attendees currently waiting in the seating queue.
 *     *   Implement the following public methods in `EventManager`:
 *         *   `registerAttendee(String name, String email)`: Creates a new `Attendee` object, adds it to *both* the list of all attendees and the seating queue. Validate that name and email are not empty. Return the created `Attendee` object, or `null` if validation fails.
 *         *   `processNextSeating()`: Removes the next attendee from the *seating queue*. If the queue is not empty, update the `isSeated` status of this attendee to `true` in the *list of all attendees*. Return the `Attendee` who was seated, or `null` if the queue was empty.
 *         *   `viewSeatingQueue()`: Returns a `List` containing the attendees currently in the seating queue, preserving their order.
 *         *   `viewAllAttendees()`: Returns the `List` of all registered attendees.
 * 3.  **User Interface:** Create a main class (e.g., `EventApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to interact with the user via the console.
 *     *   Present a menu of options:
 *         1.  Register Attendee
 *         2.  Process Next Seating
 *         3.  View Seating Queue
 *         4.  View All Attendees
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 4.  **Input Handling and Validation:**
 *     *   Prompt the user for necessary input (name, email).
 *     *   Validate user input (e.g., name/email not empty). If invalid, print an error message using `System.err` and do not proceed with registration.
 *     *   Handle potential `java.util.InputMismatchException` if the user enters non-integer input for the menu choice. Print an error using `System.err` and clear the invalid input from the scanner.
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print all error messages (e.g., validation failures, queue empty, invalid menu input).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, list/queue contents).
 *     *   Implement class-wide exception handling within the `main` method's loop using `try-catch` blocks to catch potential runtime errors or specific exceptions like `InputMismatchException`.
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested actions, and print results or errors to the console using `System.out` and `System.err` appropriately.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Event Seating Management ---
 * 1. Register Attendee
 * 2. Process Next Seating
 * 3. View Seating Queue
 * 4. View All Attendees
 * 5. Exit
 * Enter choice: 1
 * Enter attendee name: Alice
 * Enter attendee email: alice@example.com
 * Attendee #1 (Alice) registered and added to seating queue.
 * 
 * --- Event Seating Management ---
 * 1. Register Attendee
 * ...
 * Enter choice: 1
 * Enter attendee name: Bob
 * Enter attendee email: bob@example.com
 * Attendee #2 (Bob) registered and added to seating queue.
 * 
 * --- Event Seating Management ---
 * 1. Register Attendee
 * ...
 * Enter choice: 3
 * --- Seating Queue ---
 * #1 Alice (Waiting)
 * #2 Bob (Waiting)
 * ---------------------
 * 
 * --- Event Seating Management ---
 * 1. Register Attendee
 * ...
 * Enter choice: 2
 * Processing seating queue...
 * Attendee #1 (Alice) has been seated.
 * 
 * --- Event Seating Management ---
 * 1. Register Attendee
 * ...
 * Enter choice: 3
 * --- Seating Queue ---
 * #2 Bob (Waiting)
 * ---------------------
 * 
 * --- Event Seating Management ---
 * 1. Register Attendee
 * ...
 * Enter choice: 4
 * --- All Registered Attendees ---
 * #1 Alice (Seated)
 * #2 Bob (Waiting)
 * --------------------------------
 * ... (and so on)
 * ```
 * 
 * If invalid input is entered for the menu:
 * ```
 * --- Event Seating Management ---
 * ...
 * Enter choice: abc
 * ERROR: Invalid input. Please enter a number.
 * --- Event Seating Management ---
 * ...
 * ```
 * 
 * If registration input is invalid:
 * ```
 * --- Event Seating Management ---
 * ...
 * Enter choice: 1
 * Enter attendee name:
 * Enter attendee email: test@example.com
 * ERROR: Name and email cannot be empty. Registration failed.
 * --- Event Seating Management ---
 * ...
 * ```
 * 
 * If processing seating queue when empty:
 * ```
 * --- Event Seating Management ---
 * ...
 * Enter choice: 2
 * Processing seating queue...
 * ERROR: Seating queue is empty. No one to seat.
 * --- Event Seating Management ---
 * ...
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Event Seating Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Attendee` Class:**
 *     *   Represents an attendee with `id`, `name`, `email`, and `isSeated`.
 *     *   Uses a `static` field `nextId` to ensure each new attendee gets a unique, sequential ID, fulfilling the auto-generation requirement.
 *     *   Encapsulates data with `private` fields and provides `public` getter methods. A `setSeated` method is provided to allow the `EventManager` to update the status.
 *     *   Includes a `toString()` method for easy printing of attendee information.
 * 
 * 2.  **`EventManager` Class:**
 *     *   Manages the core logic and data structures.
 *     *   Uses `private List<Attendee> allAttendees = new ArrayList<>();` to store all registered attendees. `ArrayList` is chosen as it's a common `List` implementation suitable for storing and potentially iterating through all elements.
 *     *   Uses `private Queue<Attendee> seatingQueue = new LinkedList<>();` to manage attendees waiting for seating. `LinkedList` is a good choice here as it efficiently implements the `Queue` interface, providing O(1) time complexity for adding to the end (`add`) and removing from the front (`remove` or `poll`), which are typical queue operations.
 *     *   `registerAttendee`: Adds the new `Attendee` to *both* the `allAttendees` list and the `seatingQueue` queue. It includes input validation for name and email, using `System.err` for the error message if validation fails.
 *     *   `processNextSeating`: Calls `seatingQueue.remove()` to get the next attendee. It uses a `try-catch` block specifically for `NoSuchElementException` which `remove()` throws if the queue is empty, printing an error to `System.err`. If successful, it iterates through `allAttendees` to find the corresponding attendee by ID and updates their `isSeated` status. This demonstrates interaction and data consistency between the `List` and `Queue`.
 *     *   `viewSeatingQueue` and `viewAllAttendees`: Provide access to the current state of the queue and the list. `viewSeatingQueue` returns a *copy* (`new ArrayList<>(seatingQueue)`) to prevent external modification of the live queue, which is a good practice, though not strictly required by the prompt's output example. `viewAllAttendees` returns the internal `ArrayList` directly, which is simpler but allows external modification (acceptable for this exam context).
 * 
 * 3.  **`EventApp` Class (Main):**
 *     *   Contains the `main` method where execution begins.
 *     *   Initializes `Scanner` for user input and `EventManager`.
 *     *   Implements the main application loop (`while(running)`).
 *     *   **Class-wide Exception Handling:** The entire main loop is wrapped in a `try-catch(Exception e)` block. This catches any unhandled exceptions that might occur within the loop's execution, printing a generic error message to `System.err` and the stack trace. This fulfills the requirement for class-wide exception handling.
 *     *   **Menu and `switch`:** Presents a menu and uses a `switch` statement to direct control flow based on the user's integer input.
 *     *   **Input Validation & Error Handling:**
 *         *   Inside the `switch` block, specific actions like registration handle their own validation (checking for empty strings).
 *         *   A `try-catch(InputMismatchException e)` block is nested within the main loop's `try` block. This specifically catches cases where the user enters non-integer input for the menu choice, prints an error to `System.err`, and crucially, calls `scanner.nextLine()` to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *     *   `System.out` is used for the menu, prompts, success messages, and displaying list/queue contents.
 *     *   `System.err` is used exclusively for error messages (validation errors, queue empty errors, invalid menu input errors, and general exceptions).
 *     *   The `finally` block ensures the `Scanner` resource is closed when the application exits.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, encapsulated, and well-structured application, meeting all specified requirements and demonstrating advanced understanding of these concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents an attendee for an event.
 */
class Attendee {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String name;
    private String email;
    private boolean isSeated;

    /**
     * Constructs a new Attendee.
     * Assigns a unique ID and initializes seating status to false.
     * @param name The name of the attendee.
     * @param email The email of the attendee.
     */
    public Attendee(String name, String email) {
        this.id = nextId++;
        this.name = name;
        this.email = email;
        this.isSeated = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

    public boolean isSeated() {
        return isSeated;
    }

    // --- Setter for seating status ---
    public void setSeated(boolean seated) {
        isSeated = seated;
    }

    /**
     * Returns a string representation of the Attendee.
     */
    @Override
    public String toString() {
        return "#" + id + " " + name + " (" + (isSeated ? "Seated" : "Waiting") + ")";
    }
}

/**
 * Manages the event, including attendees and the seating queue.
 */
class EventManager {
    private List<Attendee> allAttendees; // List to store all registered attendees
    private Queue<Attendee> seatingQueue; // Queue for attendees waiting to be seated

    /**
     * Constructs an EventManager.
     * Initializes the list of attendees and the seating queue.
     */
    public EventManager() {
        this.allAttendees = new ArrayList<>();
        this.seatingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Registers a new attendee.
     * Adds the attendee to both the list of all attendees and the seating queue.
     * @param name The name of the attendee.
     * @param email The email of the attendee.
     * @return The registered Attendee object, or null if input is invalid.
     */
    public Attendee registerAttendee(String name, String email) {
        if (name == null || name.trim().isEmpty() || email == null || email.trim().isEmpty()) {
            System.err.println("ERROR: Name and email cannot be empty. Registration failed.");
            return null;
        }

        Attendee newAttendee = new Attendee(name.trim(), email.trim());
        allAttendees.add(newAttendee); // Add to the list of all attendees
        seatingQueue.add(newAttendee); // Add to the seating queue

        System.out.println("Attendee #" + newAttendee.getId() + " (" + newAttendee.getName() + ") registered and added to seating queue.");
        return newAttendee;
    }

    /**
     * Processes the next attendee in the seating queue.
     * Removes the attendee from the queue and updates their status in the allAttendees list.
     * @return The Attendee who was seated, or null if the queue was empty.
     */
    public Attendee processNextSeating() {
        System.out.println("Processing seating queue...");
        try {
            Attendee seatedAttendee = seatingQueue.remove(); // Removes and returns the head of the queue

            // Find the attendee in the allAttendees list and update their status
            // We can iterate or use a stream. Since the list is not expected to be
            // astronomically large in this simple example, iteration is fine.
            // A more efficient approach for very large lists might involve a Map<Integer, Attendee>
            // but that's beyond the current requirements.
            for (Attendee attendee : allAttendees) {
                if (attendee.getId() == seatedAttendee.getId()) {
                    attendee.setSeated(true);
                    break; // Found and updated
                }
            }

            System.out.println("Attendee " + seatedAttendee.toString() + " has been seated.");
            return seatedAttendee;

        } catch (NoSuchElementException e) {
            System.err.println("ERROR: Seating queue is empty. No one to seat.");
            return null;
        }
    }

    /**
     * Returns a list of attendees currently in the seating queue.
     * @return A List of Attendees in the queue order.
     */
    public List<Attendee> viewSeatingQueue() {
        // Returning a new ArrayList copy to prevent external modification of the internal queue state
        return new ArrayList<>(seatingQueue);
    }

    /**
     * Returns the list of all registered attendees.
     * @return The List of all registered Attendees.
     */
    public List<Attendee> viewAllAttendees() {
        // Returning the internal list directly is acceptable for this problem,
        // but in a real application, returning a copy might be safer.
        return allAttendees;
    }
}

/**
 * Main class to run the Event Seating Management System.
 * Provides a command-line interface for user interaction.
 */
public class EventApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager();
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                printMenu();

                try {
                    System.out.print("Enter choice: ");
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                    switch (choice) {
                        case 1: // Register Attendee
                            System.out.print("Enter attendee name: ");
                            String name = scanner.nextLine();
                            System.out.print("Enter attendee email: ");
                            String email = scanner.nextLine();
                            eventManager.registerAttendee(name, email);
                            break;

                        case 2: // Process Next Seating
                            eventManager.processNextSeating();
                            break;

                        case 3: // View Seating Queue
                            List<Attendee> queueList = eventManager.viewSeatingQueue();
                            System.out.println("--- Seating Queue ---");
                            if (queueList.isEmpty()) {
                                System.out.println("Queue is empty.");
                            } else {
                                for (Attendee attendee : queueList) {
                                    System.out.println(attendee);
                                }
                            }
                            System.out.println("---------------------");
                            break;

                        case 4: // View All Attendees
                            List<Attendee> allList = eventManager.viewAllAttendees();
                            System.out.println("--- All Registered Attendees ---");
                            if (allList.isEmpty()) {
                                System.out.println("No attendees registered yet.");
                            } else {
                                for (Attendee attendee : allList) {
                                    System.out.println(attendee);
                                }
                            }
                            System.out.println("--------------------------------");
                            break;

                        case 5: // Exit
                            System.out.println("Exiting system. Goodbye!");
                            running = false;
                            break;

                        default:
                            System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("ERROR: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                System.out.println(); // Add a newline for better formatting between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Close the scanner resource
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Event Seating Management ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Process Next Seating");
        System.out.println("3. View Seating Queue");
        System.out.println("4. View All Attendees");
        System.out.println("5. Exit");
    }
}
