/*
 * Exam Question #622
 * Generated on: 2025-05-12 16:16:04
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simplified simulation of a manufacturing production line. The system manages a queue of production tasks waiting to be processed and a list of tasks that have been completed. The user interacts with the system via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **ProductionTask Class:** Create a class named `ProductionTask` to represent a single task.
 *     *   It should have private fields: `taskId` (int), `description` (String), and `processingTime` (int - representing simulated minutes).
 *     *   Provide a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a useful string representation of the task (e.g., "Task ID: [ID], Description: [Desc], Time: [Time] min").
 * 2.  **ProductionLineSimulator Class:** Create a class named `ProductionLineSimulator` that contains the main simulation logic.
 *     *   It must have two private instance variables:
 *         *   A `Queue<ProductionTask>` to hold tasks waiting to be processed.
 *         *   A `List<ProductionTask>` to hold completed tasks.
 *     *   Use `java.util.LinkedList` as the implementation for the `Queue`.
 *     *   Use `java.util.ArrayList` as the implementation for the `List`.
 *     *   Implement the following functionality via a console menu:
 *         *   **Add New Task:** Prompt the user for task ID, description, and processing time. Create a `ProductionTask` object and add it to the waiting queue. Validate input: task ID and processing time must be positive integers. Use `System.err` for validation errors. Handle potential `NumberFormatException` during input parsing.
 *         *   **Process Next Task:** Take the next task from the front of the waiting queue, simulate its processing (print a message), and move it to the list of completed tasks. If the queue is empty, print an error message using `System.err`.
 *         *   **View Status:** Display the current number of tasks in the waiting queue and the number of completed tasks. Optionally, list the tasks in the queue (simple `toString` output is sufficient).
 *         *   **Exit:** Terminate the program.
 *     *   Use a `Scanner` object to read user input.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main program loop or the `switch` statement to catch unexpected runtime errors and print an error message to `System.err`.
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, status).
 *     *   Ensure proper encapsulation, meaningful names, and basic comments.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user input. Examples:
 * 
 * ```
 * Production Line Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Description: Assemble Widget A
 * Enter Processing Time (minutes): 15
 * Task added to queue.
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 3
 * Status:
 * Tasks in queue: 1
 * Completed tasks: 0
 * Queue: [Task ID: 101, Description: Assemble Widget A, Time: 15 min]
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 2
 * Processing Task ID: 101...
 * Task 101 completed and moved to completed list.
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 3
 * Status:
 * Tasks in queue: 0
 * Completed tasks: 1
 * Queue: []
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 2
 * Error: The production queue is empty. No tasks to process.
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 1
 * Enter Task ID: abc
 * Error: Invalid input. Please enter a valid integer for Task ID.
 * 
 * Production Line Menu:
 * ...
 * Enter your choice: 4
 * Exiting Production Line Simulator.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of `ProductionTask` class.
 * *   Correct use of `Queue` (`LinkedList`) and `List` (`ArrayList`) for task management.
 * *   Effective use of `Scanner` for input.
 * *   Proper flow control using `switch`.
 * *   Correct and appropriate use of `System.out` and `System.err`.
 * *   Robust exception handling (`try-catch`) for input parsing and general errors.
 * *   Input validation for task details.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   The program runs without crashing for valid and invalid inputs as described.
 * 
 * **Note:** Focus on the core logic and required components. Complex simulation details (like actual time delays) are not necessary.
 *
 * EXPLANATION:
 * The solution implements a `ProductionLineSimulator` based on the requirements, demonstrating the use of various Java concepts.
 * 
 * 1.  **`ProductionTask` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the task's data (`taskId`, `description`, `processingTime`) with private fields and provides public getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`ProductionLineSimulator` Class:** This class orchestrates the simulation.
 *     *   **Data Structures:**
 *         *   `private Queue<ProductionTask> waitingQueue = new LinkedList<>();`: A `Queue` is used to store tasks in a FIFO (First-In, First-Out) order, which is appropriate for a processing line where tasks are processed in the order they arrive. `LinkedList` is a common implementation of the `Queue` interface.
 *         *   `private List<ProductionTask> completedTasks = new ArrayList<>();`: A `List` is used to store tasks after they have been processed. `ArrayList` is a common implementation of the `List` interface, suitable for storing and potentially accessing completed tasks (though simple storage is sufficient here). Using the `List` interface variable type is good practice as it allows flexibility to change the implementation later if needed.
 *     *   **`Scanner`:** A `Scanner` is initialized to read input from `System.in`. It's closed in a `finally` block to ensure resources are released.
 *     *   **Main Loop and Exception Handling:** The core simulation runs within a `while(running)` loop inside a `try-catch` block. This provides class-wide exception handling, catching any unexpected `Exception` that might occur during the program's execution and printing an error to `System.err`.
 *     *   **Menu and `switch`:** The `printMenu` method displays options, `getUserChoice` reads the user's input (with specific handling for non-integer input using `InputMismatchException` and `System.err`), and `processChoice` uses a `switch` statement to direct execution based on the valid integer choice. This demonstrates structured flow control.
 *     *   **`addNewTask` Method:**
 *         *   Prompts the user for task details.
 *         *   Uses nested `try-catch` blocks specifically for handling `InputMismatchException` during the reading of integer inputs (`taskId`, `processingTime`), printing errors to `System.err` and returning early if input is invalid or parsing fails.
 *         *   Includes input validation (`taskId > 0`, `processingTime > 0`) and uses `System.err` for validation failure messages.
 *         *   Creates a `ProductionTask` object.
 *         *   Uses `waitingQueue.offer(newTask)` to add the task to the queue. `offer()` is generally preferred over `add()` for queues as it returns `false` if the element cannot be added immediately (though `LinkedList` won't fail).
 *         *   Uses `System.out` for success messages.
 *         *   `scanner.nextLine()` calls are included after `nextInt()` calls to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   **`processNextTask` Method:**
 *         *   Checks if the `waitingQueue` is empty using `isEmpty()`. If empty, it prints an error message to `System.err`.
 *         *   If not empty, it uses `waitingQueue.poll()` to retrieve and remove the task from the front of the queue. `poll()` is the standard way to remove from a queue and returns `null` if the queue is empty (which is handled by the `isEmpty()` check).
 *         *   Adds the processed task to the `completedTasks` `List` using `add()`.
 *         *   Uses `System.out` for processing and completion messages.
 *     *   **`viewStatus` Method:**
 *         *   Prints the size of both the queue and the list using `size()`.
 *         *   Prints the contents of the `waitingQueue` directly. The default `toString()` of `LinkedList` (and `ArrayList`) calls the `toString()` of its elements, so the custom `ProductionTask.toString()` is used here automatically.
 *         *   Uses `System.out` for all status information.
 *     *   **`exitSimulation` Method:** Sets the `running` flag to `false`, causing the main loop to terminate.
 *     *   **`main` Method:** Creates an instance of the `ProductionLineSimulator` and calls `startSimulation()` to begin the program.
 * 
 * This solution effectively combines the required Java components to build a functional, albeit simple, simulation while adhering to good programming practices like encapsulation, input validation, and layered error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single production task with ID, description, and processing time.
 */
class ProductionTask {
    private int taskId;
    private String description;
    private int processingTime;

    /**
     * Constructs a new ProductionTask.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param processingTime The time required to process the task in simulated minutes.
     */
    public ProductionTask(int taskId, String description, int processingTime) {
        this.taskId = taskId;
        this.description = description;
        this.processingTime = processingTime;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getProcessingTime() {
        return processingTime;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Time: " + processingTime + " min";
    }
}

/**
 * Simulates a production line managing a queue of tasks and a list of completed tasks.
 */
public class ProductionLineSimulator {

    private Queue<ProductionTask> waitingQueue;
    private List<ProductionTask> completedTasks;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a new ProductionLineSimulator.
     */
    public ProductionLineSimulator() {
        // Use LinkedList for Queue implementation
        this.waitingQueue = new LinkedList<>();
        // Use ArrayList for List implementation
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts the simulation, displaying the menu and processing user input.
     */
    public void startSimulation() {
        System.out.println("--- Production Line Simulator ---");
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();
                processChoice(choice);
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the simulation ends
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nProduction Line Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Gets the user's menu choice, handling invalid integer input.
     * @return The user's valid integer choice.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle non-integer input specifically
            System.err.println("Error: Invalid input. Please enter a number.");
            // Consume the invalid input to prevent infinite loop
            scanner.next();
        }
        return choice;
    }

    /**
     * Processes the user's menu choice using a switch statement.
     * @param choice The integer choice entered by the user.
     */
    private void processChoice(int choice) {
        // Use switch statement for flow control based on user choice
        switch (choice) {
            case 1:
                addNewTask();
                break;
            case 2:
                processNextTask();
                break;
            case 3:
                viewStatus();
                break;
            case 4:
                exitSimulation();
                break;
            default:
                // Handle choices outside the valid range
                if (choice != -1) { // Avoid printing error if InputMismatchException already handled
                   System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                }
                break;
        }
    }

    /**
     * Handles adding a new task based on user input.
     * Includes input validation and NumberFormatException handling.
     */
    private void addNewTask() {
        System.out.print("Enter Task ID: ");
        int taskId = -1;
        try {
            taskId = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();

            // Input validation: Task ID must be positive
            if (taskId <= 0) {
                System.err.println("Error: Task ID must be a positive integer.");
                return; // Exit the method if validation fails
            }

            System.out.print("Enter Description: ");
            String description = scanner.nextLine();

            System.out.print("Enter Processing Time (minutes): ");
            int processingTime = scanner.nextInt();
            // Consume the newline character
            scanner.nextLine();

            // Input validation: Processing time must be positive
            if (processingTime <= 0) {
                System.err.println("Error: Processing time must be a positive integer.");
                return; // Exit the method if validation fails
            }

            // Create and add the new task to the queue
            ProductionTask newTask = new ProductionTask(taskId, description, processingTime);
            waitingQueue.offer(newTask); // offer() is preferred over add() for queues
            System.out.println("Task added to queue.");

        } catch (InputMismatchException e) {
            // Handle non-integer input for ID or time
            System.err.println("Error: Invalid input. Please enter a valid integer for ID and Processing Time.");
            // Consume the invalid input
            scanner.nextLine(); // Consume the rest of the line after the invalid input
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation
             System.err.println("An error occurred while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the queue, if available.
     */
    private void processNextTask() {
        // Check if the queue is empty before trying to poll
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: The production queue is empty. No tasks to process.");
        } else {
            // Poll the next task from the front of the queue
            ProductionTask taskToProcess = waitingQueue.poll();
            System.out.println("Processing Task ID: " + taskToProcess.getTaskId() + "...");
            // Simulate processing (e.g., wait for processingTime - not required for exam)

            // Move the task to the completed list
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getTaskId() + " completed and moved to completed list.");
        }
    }

    /**
     * Displays the current status of the waiting queue and completed tasks list.
     */
    private void viewStatus() {
        System.out.println("\nStatus:");
        System.out.println("Tasks in queue: " + waitingQueue.size());
        System.out.println("Completed tasks: " + completedTasks.size());

        // Optionally, list tasks in the queue
        if (!waitingQueue.isEmpty()) {
             System.out.println("Queue: " + waitingQueue); // Uses ProductionTask.toString()
        } else {
             System.out.println("Queue: []");
        }
        // Listing completed tasks is optional for the exam requirement, but could be added here
        // if (!completedTasks.isEmpty()) {
        //     System.out.println("Completed: " + completedTasks);
        // }
    }

    /**
     * Sets the flag to exit the simulation.
     */
    private void exitSimulation() {
        System.out.println("Exiting Production Line Simulator.");
        this.running = false;
        // Scanner closure is handled in the finally block of startSimulation
    }

    /**
     * Main method to start the Production Line Simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        simulator.startSimulation();
    }
}
