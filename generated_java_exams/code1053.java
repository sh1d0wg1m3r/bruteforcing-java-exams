/*
 * Exam Question #1053
 * Generated on: 2025-05-12 17:18:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Spooler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation of a print job spooler system. This system will manage a queue of print jobs waiting to be processed and keep a history of completed jobs. Users can add new jobs, process the next job in the queue, view the list of pending jobs, and view the history of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Print Job Class:** Create a class `PrintJob` to represent a single print job. It should have:
 *     *   A unique integer ID.
 *     *   A string `fileName`.
 *     *   An integer `pages`.
 *     *   A status (e.g., an enum or String: "PENDING", "PRINTING", "COMPLETED", "FAILED").
 *     *   Private fields with public getter methods.
 *     *   A constructor to initialize ID, file name, pages, and set initial status to "PENDING".
 *     *   A `toString()` method for easy display.
 * 
 * 2.  **Print Spooler Class:** Create a class `PrintSpooler` to manage the print jobs. It must contain:
 *     *   A `java.util.Queue` to hold pending print jobs. Use a suitable implementation (e.g., `LinkedList`).
 *     *   A `java.util.ArrayList` to store completed/failed jobs.
 *     *   A mechanism to generate unique job IDs (e.g., a simple counter).
 *     *   A method `addJob(String fileName, int pages)`: Creates a new `PrintJob` and adds it to the pending queue. Include basic validation (pages > 0). If validation fails, print an error to `System.err` and do not add the job.
 *     *   A method `processNextJob()`:
 *         *   Retrieves and removes the next job from the pending queue.
 *         *   Simulates printing (e.g., print a message to `System.out`).
 *         *   Randomly (or based on some simple logic, e.g., if pages > 100) simulate a print failure 10-20% of the time.
 *         *   Update the job's status to "COMPLETED" or "FAILED".
 *         *   Add the processed job to the completed/failed jobs list.
 *         *   If the queue is empty, print a message to `System.out` and do nothing.
 *         *   If a job fails, print an error message to `System.err`.
 *     *   A method `getPendingJobs()`: Returns the `Queue` of pending jobs (or a copy/view of it).
 *     *   A method `getCompletedJobs()`: Returns the `List` of completed/failed jobs (or a copy/view of it).
 * 
 * 3.  **Main Application Class:** Create a class with a `main` method (`PrintSpoolerApp`).
 *     *   Instantiate the `PrintSpooler`.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options using a `switch` statement:
 *         *   1. Add New Job
 *         *   2. Process Next Job
 *         *   3. View Pending Jobs
 *         *   4. View Completed Jobs
 *         *   5. Exit
 *     *   Implement a main loop that continues until the user chooses to exit.
 *     *   Handle potential input errors (e.g., non-integer input when expecting an integer) using `try-catch` blocks around the input reading and processing logic. Print error messages to `System.err`.
 *     *   Ensure all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) are used correctly.
 * 
 * **Expected Output/Interaction:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors.
 * 
 * ```
 * Print Spooler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job added: [ID: 1, File: report.pdf, Pages: 15, Status: PENDING]
 * 
 * Print Spooler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * ...
 * Enter choice: 2
 * Processing job: [ID: 1, File: report.pdf, Pages: 15, Status: PENDING]
 * Job 1 completed successfully.
 * 
 * Print Spooler Menu:
 * ...
 * Enter choice: 3
 * Pending Jobs (Queue):
 * (No jobs pending)
 * 
 * Print Spooler Menu:
 * ...
 * Enter choice: 4
 * Completed Jobs (History):
 * [ID: 1, File: report.pdf, Pages: 15, Status: COMPLETED]
 * 
 * Print Spooler Menu:
 * ...
 * Enter choice: 2
 * No jobs in the pending queue to process.
 * 
 * Print Spooler Menu:
 * ...
 * Enter choice: 5
 * Exiting Print Spooler.
 * ```
 * 
 * *(Error output to `System.err` should appear if input is invalid or a print simulation fails)*
 * 
 * **Constraints:**
 * 
 * *   Use only standard Java library classes unless absolutely necessary (not expected for this task).
 * *   Adhere to good programming practices (encapsulation, meaningful names, comments).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the `PrintJob` and `PrintSpooler` classes.
 * *   Proper encapsulation and code structure.
 * *   Effective input validation and error handling using `System.err` and `try-catch`.
 * *   Adherence to the requirements of the menu-driven interface and job processing logic.
 *
 * EXPLANATION:
 * This solution implements the Print Job Spooler simulation as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:** This class models a single print job. It uses private fields (`id`, `fileName`, `pages`, `status`) and public getters to enforce encapsulation. The `toString()` method provides a convenient way to represent a job object as a string for printing.
 * 
 * 2.  **`PrintSpooler` Class:** This class acts as the core logic handler.
 *     *   It uses a `java.util.Queue<PrintJob>` (specifically a `LinkedList`) named `pendingJobs` to store jobs waiting to be processed. The `Queue` interface is ideal here because print jobs are processed in the order they are added (First-In, First-Out - FIFO), which is handled by `offer()` for adding and `poll()` for removing from the front.
 *     *   It uses a `java.util.ArrayList<PrintJob>` named `completedJobs` to store jobs after they have been processed (either completed or failed). `ArrayList` is suitable for storing a historical list where elements might be accessed by index or iterated over.
 *     *   A simple `nextJobId` counter ensures each job gets a unique ID.
 *     *   `addJob()` validates input (`pages > 0`, `fileName` not empty) before creating and adding a `PrintJob` to the `pendingJobs` queue using `offer()`. Input validation errors are reported to `System.err`.
 *     *   `processNextJob()` retrieves the next job using `poll()`. It checks if the queue is empty first. It simulates printing and then uses a `Random` object to simulate a potential failure, updating the job's status accordingly. Success messages go to `System.out`, failure messages to `System.err`. The processed job is then added to the `completedJobs` `ArrayList`.
 *     *   `getPendingJobs()` and `getCompletedJobs()` provide access to the internal collections. While returning direct references isn't ideal for true encapsulation in larger systems (a copy or unmodifiable view would be better), it suffices for this exam task and demonstrates the required use of `Queue` and `List`.
 * 
 * 3.  **`PrintSpoolerApp` Class:** This class contains the `main` method and handles the user interface.
 *     *   It creates instances of `PrintSpooler` and `Scanner`.
 *     *   The main application loop runs until `running` is set to `false`.
 *     *   A **class-wide `try-catch` block** (wrapping the `while` loop) is used to catch any unexpected `Exception` that might propagate up, preventing the program from crashing abruptly and providing a basic error report on `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   Inside the loop, a smaller `try-catch` block specifically handles `InputMismatchException` when reading the user's menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *     *   A **`switch` statement** is used to direct the program flow based on the user's valid integer input, calling the appropriate methods on the `PrintSpooler` instance.
 *     *   Case 1 (`Add New Job`) includes another `try-catch` block specifically for reading the number of pages, handling potential `InputMismatchException` for that input as well.
 *     *   Case 3 (`View Pending Jobs`) demonstrates iterating through the `Queue` using `forEach` without removing elements (as `poll` or `remove` would). It prints the contents using `System.out`.
 *     *   Case 4 (`View Completed Jobs`) demonstrates iterating through the `List` (specifically an `ArrayList` implementation) using `forEach` and printing to `System.out`. Note the use of the `List` interface type for the `completed` variable.
 *     *   `System.out` is used for the menu, successful operations, and displaying lists.
 *     *   `System.err` is used for input validation errors and simulated print failures.
 *     *   The `printMenu()` method is a simple helper for displaying the options.
 * 
 * This solution effectively integrates all the required components within a practical simulation, demonstrating understanding of data structures (`Queue`, `List`/`ArrayList`), user interaction (`Scanner`), control flow (`switch`, loops), error handling (`try-catch`, `System.err`), and object-oriented principles (encapsulation, class design).
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int id;
    private String fileName;
    private int pages;
    private String status; // PENDING, PRINTING (optional simulation step), COMPLETED, FAILED

    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used by spooler)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", File: " + fileName + ", Pages: " + pages + ", Status: " + status + "]";
    }
}

// Manages the queue and history of print jobs
class PrintSpooler {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs;
    private int nextJobId;
    private Random random; // For simulating print failures

    public PrintSpooler() {
        this.pendingJobs = new LinkedList<>(); // Queue implementation
        this.completedJobs = new ArrayList<>(); // List implementation
        this.nextJobId = 1; // Start job IDs from 1
        this.random = new Random();
    }

    /**
     * Adds a new print job to the pending queue.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the file.
     */
    public void addJob(String fileName, int pages) {
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be greater than 0.");
            return;
        }

        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim(), pages);
        pendingJobs.offer(newJob); // Add to the end of the queue
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the pending queue.
     * Simulates printing and moves the job to the completed list.
     */
    public void processNextJob() {
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs in the pending queue to process.");
            return;
        }

        PrintJob jobToProcess = pendingJobs.poll(); // Get and remove the head of the queue
        System.out.println("Processing job: " + jobToProcess);

        // Simulate printing time (optional, could add Thread.sleep)
        // jobToProcess.setStatus("PRINTING"); // Could add a printing status step

        // Simulate print failure (e.g., 20% chance)
        if (random.nextInt(100) < 20) { // 0-19 out of 0-99
            jobToProcess.setStatus("FAILED");
            System.err.println("Job " + jobToProcess.getId() + " failed during printing.");
        } else {
            jobToProcess.setStatus("COMPLETED");
            System.out.println("Job " + jobToProcess.getId() + " completed successfully.");
        }

        completedJobs.add(jobToProcess); // Add to the completed list
    }

    /**
     * Returns the queue of pending jobs.
     * @return A Queue containing pending PrintJob objects.
     */
    public Queue<PrintJob> getPendingJobs() {
        // Return a copy or unmodifiable view if needed, but for this exam simple return is fine.
        return pendingJobs;
    }

    /**
     * Returns the list of completed and failed jobs.
     * @return A List containing processed PrintJob objects.
     */
    public List<PrintJob> getCompletedJobs() {
        // Return a copy or unmodifiable view if needed, but for this exam simple return is fine.
        return completedJobs;
    }
}

// Main application class with user interface
public class PrintSpoolerApp {

    public static void main(String[] args) {
        PrintSpooler spooler = new PrintSpooler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        int pages = -1;
                        try {
                            System.out.print("Enter number of pages: ");
                            pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            spooler.addJob(fileName, pages);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for pages. Please enter a number.");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;

                    case 2: // Process Next Job
                        spooler.processNextJob();
                        break;

                    case 3: // View Pending Jobs
                        System.out.println("\n--- Pending Jobs (Queue) ---");
                        Queue<PrintJob> pending = spooler.getPendingJobs();
                        if (pending.isEmpty()) {
                            System.out.println("(No jobs pending)");
                        } else {
                            // Iterate through the queue without removing elements
                            pending.forEach(System.out::println);
                        }
                        System.out.println("----------------------------\n");
                        break;

                    case 4: // View Completed Jobs
                        System.out.println("\n--- Completed Jobs (History) ---");
                        List<PrintJob> completed = spooler.getCompletedJobs(); // Using List interface
                        if (completed.isEmpty()) {
                            System.out.println("(No jobs completed yet)");
                        } else {
                            // Iterate through the list
                            completed.forEach(System.out::println);
                        }
                        System.out.println("------------------------------\n");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Print Spooler.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nPrint Spooler Menu:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
