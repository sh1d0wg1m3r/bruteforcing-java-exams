/*
 * Exam Question #1079
 * Generated on: 2025-05-12 17:22:08
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Topic:** Data Structures, Control Flow, Exception Handling, and I/O
 * **Duration:** 60 minutes
 * 
 * **Task: Warehouse Inventory and Order Fulfillment System**
 * 
 * Design and implement a simple command-line application that simulates a basic warehouse inventory and order fulfillment system. The system should manage a list of inventory items and process incoming customer orders using a queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Inventory Management:** Maintain a collection of `InventoryItem` objects. Each `InventoryItem` should have a unique integer ID, a String name, and an integer quantity in stock.
 * 2.  **Order Management:** Maintain a queue of `Order` objects. Each `Order` should have a unique integer order ID, the ID of the item requested, and the quantity requested.
 * 3.  **User Interface:** Provide a command-line interface using `java.util.Scanner` to interact with the system. The user should be presented with a menu of options.
 * 4.  **Functionality:** Implement the following operations:
 *     *   **Add New Inventory Item:** Prompt the user for item ID, name, and initial quantity. Add the item to the inventory. Validate that the item ID is unique.
 *     *   **Place New Order:** Prompt the user for order ID, item ID, and requested quantity. Add the order to the end of the order queue. Validate that the order ID is unique.
 *     *   **Process Next Order:** Take the oldest order from the front of the queue. Check if the requested item exists in inventory and if there is sufficient stock.
 *         *   If successful: Decrease the inventory quantity, print a success message to `System.out`.
 *         *   If item not found: Print an error message to `System.err`.
 *         *   If insufficient stock: Print an error message to `System.err`.
 *         *   In case of failure (item not found or insufficient stock), the order is *not* fulfilled, but it is still removed from the queue as it was the "next" order to be processed.
 *     *   **View Inventory:** Display the current list of all inventory items (ID, Name, Quantity) to `System.out`.
 *     *   **View Pending Orders:** Display the list of all orders currently in the queue (Order ID, Item ID, Quantity) to `System.out`.
 *     *   **Exit:** Terminate the application.
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue` (for the order queue)
 *     *   `java.util.ArrayList` (to store inventory items)
 *     *   `java.util.List` (use the `List` interface type when declaring or referencing the inventory collection)
 *     *   `java.util.Scanner` (for all user input)
 *     *   `switch` statement (for handling the main menu options)
 *     *   `System.err` (for all error messages, e.g., validation errors, processing failures)
 *     *   `System.out` (for all normal output, e.g., menu, prompts, success messages, lists)
 *     *   Class-wide or significant method-level exception handling using `try-catch` blocks (e.g., handling non-integer input, unexpected issues).
 * 6.  **Best Practices:**
 *     *   Use appropriate encapsulation (private fields, public methods) for your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., positive quantities, unique IDs).
 *     *   Handle potential exceptions gracefully using `try-catch`.
 *     *   Organize your code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu. Based on user input, it should perform the requested action, printing success messages or lists to `System.out` and error messages to `System.err`. The system should continue running until the user selects the Exit option.
 * 
 * Example Interaction Snippet (Illustrative):
 * 
 * ```
 * Warehouse System Menu:
 * 1. Add Inventory Item
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter choice: 1
 * Enter Item ID: 101
 * Item ID 101 already exists.
 * Enter choice: 1
 * Enter Item ID: 102
 * Enter Item Name: Widget
 * Enter Quantity: 50
 * Item 102 (Widget) added to inventory.
 * Enter choice: 4
 * Inventory:
 * ID: 102, Name: Widget, Quantity: 50
 * Enter choice: 2
 * Enter Order ID: 501
 * Enter Item ID for order: 102
 * Enter Quantity for order: 5
 * Order 501 placed for Item 102 (Qty 5).
 * Enter choice: 5
 * Pending Orders:
 * Order ID: 501, Item ID: 102, Quantity: 5
 * Enter choice: 3
 * Processing Order 501...
 * Order 501 for Item 102 (Qty 5) successfully fulfilled.
 * Enter choice: 4
 * Inventory:
 * ID: 102, Name: Widget, Quantity: 45
 * Enter choice: 3
 * Processing next order...
 * No pending orders in the queue.
 * Enter choice: 6
 * Exiting Warehouse System.
 * ```
 * 
 * Your code should be a complete, runnable Java program.
 *
 * EXPLANATION:
 * This solution implements the Warehouse Inventory and Order Fulfillment System as described in the problem statement, incorporating all the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `InventoryItem`: A simple class to hold data for an item (`itemId`, `name`, `quantity`) with appropriate getters and a method (`decreaseQuantity`) to manage stock. Encapsulation is used with private fields and public methods.
 *     *   `Order`: A simple class to hold data for an order (`orderId`, `itemId`, `quantity`) with getters. Encapsulation is used.
 *     *   `WarehouseSystem`: The main class that orchestrates the system. It holds the collections for inventory and orders and contains the methods for all operations.
 * 
 * 2.  **Data Structures:**
 *     *   `List<InventoryItem> inventory = new ArrayList<>();`: An `ArrayList` is used to store `InventoryItem` objects. It provides efficient random access and dynamic resizing, suitable for managing a list of items where lookup by ID is needed (though our `findItemById` is a simple linear search, `ArrayList` is a valid `List` implementation for this). The variable is declared using the `List` interface type, fulfilling that requirement.
 *     *   `Queue<Order> orderQueue = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface for storing `Order` objects. A queue is the correct choice here because orders are processed in a First-In, First-Out (FIFO) manner. The `poll()` method is used to retrieve and remove the head of the queue (the next order to process), and `add()` is used to add new orders to the tail. The variable is declared using the `Queue` interface type.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A single `Scanner` instance is created in the `WarehouseSystem` constructor and used throughout the application to read user input from `System.in`.
 *     *   `scanner.nextLine()` is used after reading integers with `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The `runSystem` method contains the main application loop.
 *     *   A `switch` statement is used to handle the user's menu choice, directing the program flow to the appropriate method (`addItem`, `placeOrder`, etc.).
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for all standard output, including the menu, prompts, success messages, and displaying the contents of the inventory and order queue.
 *     *   `System.err.println()` is strictly used for displaying error messages, such as invalid input, duplicate IDs, item not found, or insufficient stock. This separates normal program output from error information, which is a good practice.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   `try-catch` blocks are used in methods that involve user input (`addItem`, `placeOrder`, `runSystem`) to handle `InputMismatchException` if the user enters non-integer input where an integer is expected.
 *     *   Specific error messages are printed to `System.err` when these exceptions occur.
 *     *   The `scanner.nextLine()` call within the `catch` block for `InputMismatchException` is crucial to consume the invalid input and prevent an infinite loop where the scanner keeps trying to read the same bad input.
 *     *   A general `catch (Exception e)` is included in `addItem`, `placeOrder`, and `runSystem` to catch any other unexpected runtime errors that might occur, demonstrating broader error handling capability.
 *     *   While `processNextOrder` uses `poll()` which returns `null` for an empty queue (avoiding `NoSuchElementException` from `remove()`), a `try-catch` is still present to handle potential unexpected issues during the processing logic itself and included a comment about `NoSuchElementException` for educational context regarding queue exceptions.
 * 
 * 7.  **Input Validation:**
 *     *   Checks are performed to ensure item IDs and order IDs are unique before adding new items or orders.
 *     *   Quantities are validated to be non-negative (for inventory) or positive (for orders).
 *     *   Error messages for validation failures are printed to `System.err`.
 * 
 * 8.  **Best Practices:**
 *     *   Fields in `InventoryItem` and `Order` are `private`, accessed via `public` getters (and a controlled setter-like method `decreaseQuantity`), demonstrating encapsulation.
 *     *   Method and variable names are descriptive (e.g., `findItemById`, `orderQueue`, `processNextOrder`).
 *     *   Basic Javadoc comments are provided for classes and methods.
 *     *   The code is structured into logical methods within the `WarehouseSystem` class, improving readability and maintainability.
 * 
 * This solution effectively combines various core Java concepts and data structures to solve a practical problem, meeting all the specified requirements and demonstrating a solid understanding of Java programming principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents an item in the warehouse inventory.
 */
class InventoryItem {
    private int itemId;
    private String name;
    private int quantity;

    /**
     * Constructs an InventoryItem.
     * @param itemId The unique ID of the item.
     * @param name The name of the item.
     * @param quantity The initial quantity in stock.
     */
    public InventoryItem(int itemId, String name, int quantity) {
        this.itemId = itemId;
        this.name = name;
        this.quantity = quantity;
    }

    // --- Getters ---
    public int getItemId() {
        return itemId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    // --- Setters / Updaters ---
    /**
     * Decreases the quantity of the item.
     * @param amount The amount to decrease.
     * @return True if quantity was decreased successfully, false if amount > current quantity.
     */
    public boolean decreaseQuantity(int amount) {
        if (amount < 0) {
            System.err.println("Error: Cannot decrease quantity by a negative amount.");
            return false;
        }
        if (this.quantity >= amount) {
            this.quantity -= amount;
            return true;
        } else {
            return false; // Insufficient stock
        }
    }

    /**
     * Increases the quantity of the item.
     * @param amount The amount to increase.
     */
    public void increaseQuantity(int amount) {
         if (amount < 0) {
            System.err.println("Error: Cannot increase quantity by a negative amount.");
            return;
        }
        this.quantity += amount;
    }

    @Override
    public String toString() {
        return "ID: " + itemId + ", Name: " + name + ", Quantity: " + quantity;
    }
}

/**
 * Represents a customer order.
 */
class Order {
    private int orderId;
    private int itemId;
    private int quantity;

    /**
     * Constructs an Order.
     * @param orderId The unique ID of the order.
     * @param itemId The ID of the item requested.
     * @param quantity The quantity of the item requested.
     */
    public Order(int orderId, int itemId, int quantity) {
        this.orderId = orderId;
        this.itemId = itemId;
        this.quantity = quantity;
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public int getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Item ID: " + itemId + ", Quantity: " + quantity;
    }
}

/**
 * The main system managing inventory and orders.
 */
public class WarehouseSystem {

    // Use List interface type for inventory
    private List<InventoryItem> inventory;
    // Use Queue interface type for orders
    private Queue<Order> orderQueue;
    private Scanner scanner;

    /**
     * Constructs the WarehouseSystem.
     * Initializes inventory and order queue.
     */
    public WarehouseSystem() {
        // Use ArrayList as the implementation for List
        inventory = new ArrayList<>();
        // Use LinkedList as the implementation for Queue
        orderQueue = new LinkedList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Finds an item in the inventory by its ID.
     * @param itemId The ID of the item to find.
     * @return The InventoryItem if found, null otherwise.
     */
    private InventoryItem findItemById(int itemId) {
        for (InventoryItem item : inventory) {
            if (item.getItemId() == itemId) {
                return item;
            }
        }
        return null;
    }

     /**
     * Finds an order in the pending queue by its ID.
     * Used for validation of unique order ID.
     * @param orderId The ID of the order to find.
     * @return The Order if found, null otherwise.
     */
    private Order findOrderById(int orderId) {
         // Iterate through the queue without removing elements
         for (Order order : orderQueue) {
             if (order.getOrderId() == orderId) {
                 return order;
             }
         }
         return null;
     }


    /**
     * Adds a new item to the inventory.
     */
    public void addItem() {
        try {
            System.out.print("Enter Item ID: ");
            int itemId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Validate unique item ID
            if (findItemById(itemId) != null) {
                System.err.println("Error: Item ID " + itemId + " already exists.");
                return;
            }

            System.out.print("Enter Item Name: ");
            String itemName = scanner.nextLine();

            System.out.print("Enter Quantity: ");
            int quantity = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Validate quantity
            if (quantity < 0) {
                System.err.println("Error: Quantity cannot be negative.");
                return;
            }

            InventoryItem newItem = new InventoryItem(itemId, itemName, quantity);
            inventory.add(newItem);
            System.out.println("Item " + itemId + " (" + itemName + ") added to inventory.");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for ID and Quantity.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             // Catch any other unexpected errors during input
            System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
            // e.printStackTrace(); // For debugging
        }
    }

    /**
     * Places a new order into the order queue.
     */
    public void placeOrder() {
        try {
            System.out.print("Enter Order ID: ");
            int orderId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Validate unique order ID
            if (findOrderById(orderId) != null) {
                System.err.println("Error: Order ID " + orderId + " already exists in pending queue.");
                return;
            }


            System.out.print("Enter Item ID for order: ");
            int itemId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            System.out.print("Enter Quantity for order: ");
            int quantity = scanner.nextInt();
            scanner.nextLine(); // Consume newline

             // Validate quantity
            if (quantity <= 0) {
                System.err.println("Error: Order quantity must be positive.");
                return;
            }

            Order newOrder = new Order(orderId, itemId, quantity);
            orderQueue.add(newOrder); // Add to the end of the queue
            System.out.println("Order " + orderId + " placed for Item " + itemId + " (Qty " + quantity + ").");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for IDs and Quantity.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             // Catch any other unexpected errors during input
            System.err.println("An unexpected error occurred while placing order: " + e.getMessage());
            // e.printStackTrace(); // For debugging
        }
    }

    /**
     * Processes the next order from the queue.
     */
    public void processNextOrder() {
        System.out.println("Processing next order...");
        try {
            // Retrieve and remove the head of the queue
            Order nextOrder = orderQueue.poll(); // poll returns null if queue is empty

            if (nextOrder == null) {
                System.out.println("No pending orders in the queue.");
                return;
            }

            System.out.println("Attempting to fulfill " + nextOrder);

            int orderedItemId = nextOrder.getItemId();
            int orderedQuantity = nextOrder.getQuantity();

            // Find the item in inventory
            InventoryItem item = findItemById(orderedItemId);

            if (item == null) {
                System.err.println("Error processing Order " + nextOrder.getOrderId() +
                                   ": Item ID " + orderedItemId + " not found in inventory.");
                return; // Order removed but not fulfilled
            }

            // Check and decrease quantity
            if (item.decreaseQuantity(orderedQuantity)) {
                System.out.println("Order " + nextOrder.getOrderId() +
                                   " for Item " + orderedItemId + " (Qty " + orderedQuantity + ") successfully fulfilled.");
            } else {
                System.err.println("Error processing Order " + nextOrder.getOrderId() +
                                   ": Insufficient stock for Item ID " + orderedItemId +
                                   ". Requested: " + orderedQuantity + ", Available: " + item.getQuantity());
                // Order removed but not fulfilled
            }

        } catch (NoSuchElementException e) {
             // This catch is technically redundant because poll() returns null,
             // but included to show handling potential queue exceptions like remove()
             System.err.println("Error: Attempted to process order from an empty queue (should not happen with poll()).");
        } catch (Exception e) {
             // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred while processing order: " + e.getMessage());
            // e.printStackTrace(); // For debugging
        }
    }

    /**
     * Displays the current inventory.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (InventoryItem item : inventory) {
                System.out.println(item);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the pending orders in the queue.
     */
    public void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\nWarehouse System Menu:");
        System.out.println("1. Add Inventory Item");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate methods.
     */
    public void runSystem() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                // scanner.nextLine(); // Consume newline - handled within methods

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        addItem();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewInventory();
                        break;
                    case 5:
                        viewPendingOrders();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Warehouse System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected runtime exceptions from menu processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // For debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.runSystem();
    }
}
