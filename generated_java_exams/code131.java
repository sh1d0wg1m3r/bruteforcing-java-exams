/*
 * Exam Question #131
 * Generated on: 2025-05-11 22:19:04
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Implement a Console-Based Print Job Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simple simulation of a shared network printer's job management system. Print jobs arrive and are placed in a queue. The printer processes jobs from the front of the queue one by one. A history of completed jobs is maintained.
 * 
 * **Requirements:**
 * Your Java console application must fulfill the following requirements:
 * 
 * 1.  **Print Job Representation:** Create a class `PrintJob` to represent a single print job. It should have private fields for a unique `jobId` (integer), `userName` (String), `fileName` (String), and `pageCount` (integer). Provide public getter methods for these fields (encapsulation).
 * 2.  **Job Management:** Create a class `PrintManager` that will manage the pending and completed jobs.
 *     *   It must use a `java.util.Queue<PrintJob>` to store jobs waiting to be printed (pending queue - FIFO).
 *     *   It must use a `java.util.List<PrintJob>` (specifically an `java.util.ArrayList`) to store jobs that have been successfully processed (completed history).
 *     *   Implement methods in `PrintManager`:
 *         *   `submitJob(String userName, String fileName, int pageCount)`: Creates a new `PrintJob` with a unique ID and adds it to the pending queue.
 *         *   `processNextJob()`: Removes the job at the front of the pending queue and adds it to the completed history. This method should indicate if a job was processed or if the queue was empty.
 *         *   `listPendingJobs()`: Prints the details of all jobs currently in the pending queue.
 *         *   `listCompletedJobs()`: Prints the details of all jobs in the completed history.
 * 3.  **User Interface:** Implement a main application class (e.g., `PrintSystem`) with a `main` method that provides a console menu using `java.util.Scanner` for user interaction. The menu should offer the following options:
 *     *   1. Submit New Print Job
 *     *   2. Process Next Job
 *     *   3. View Pending Jobs Queue
 *     *   4. View Completed Jobs History
 *     *   5. Exit
 * 4.  **Control Flow:** Use a `switch` statement in the main loop to handle the different menu choices.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and job lists.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, invalid input for job details, attempting to process a job when the queue is empty).
 * 6.  **Error Handling & Validation:**
 *     *   Implement input validation for submitting a job: ensure user name and file name are not empty, and page count is a positive integer (> 0). Use `System.err` to report validation errors and re-prompt if necessary.
 *     *   Implement a `try-catch` block to handle potential `NumberFormatException` when reading integer input from the user (both for menu choice and page count). Report the error using `System.err`.
 *     *   Implement a broad `try-catch` block around the main application loop in the `main` method to catch any unexpected exceptions (demonstrating class-wide handling, although more specific catches are also used). Print the error using `System.err`.
 *     *   Handle the case where `processNextJob` is called on an empty queue, reporting the issue via `System.err`.
 * 7.  **Best Practices:** Follow Java coding best practices, including meaningful variable/method names, appropriate comments (especially Javadoc for classes/methods), and clean code structure.
 * 
 * **Expected Interaction:**
 * The application should present the menu, accept integer input for choices, and perform the requested action. If input is invalid or an action cannot be performed (like processing an empty queue), an appropriate error message should be printed to `System.err`, and the menu should be displayed again (unless exiting).
 * 
 * Example Flow:
 * ```
 * Welcome to the Print Job Management System!
 * Print Job Management Menu:
 * 1. Submit New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs Queue
 * 4. View Completed Jobs History
 * 5. Exit
 * Enter your choice: 1
 * --- Submit New Job ---
 * Enter user name: Alice
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job submitted successfully: Job ID: 1, User: Alice, File: report.pdf, Pages: 15
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 1
 * --- Submit New Job ---
 * Enter user name: Bob
 * Enter file name: presentation.pptx
 * Enter number of pages: abc
 * Error: Invalid input for page count. Please enter a number.
 * Enter number of pages: 30
 * Job submitted successfully: Job ID: 2, User: Bob, File: presentation.pptx, Pages: 30
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Print Jobs ---
 * 1. Job ID: 1, User: Alice, File: report.pdf, Pages: 15
 * 2. Job ID: 2, User: Bob, File: presentation.pptx, Pages: 30
 * --------------------------
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 2
 * --- Processing Next Job ---
 * Job processed: Job ID: 1, User: Alice, File: report.pdf, Pages: 15
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 2
 * --- Processing Next Job ---
 * Job processed: Job ID: 2, User: Bob, File: presentation.pptx, Pages: 30
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 2
 * --- Processing Next Job ---
 * Error: No jobs in the queue to process.
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Print Jobs ---
 * 1. Job ID: 1, User: Alice, File: report.pdf, Pages: 15
 * 2. Job ID: 2, User: Bob, File: presentation.pptx, Pages: 30
 * ----------------------------
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Print Job Management Menu:
 * ...
 * Enter your choice: 5
 * Exiting Print Job Management System. Goodbye!
 * ```
 * 
 * Your solution must compile and run from the `main` method and demonstrate the correct usage of all specified components and practices.
 *
 * EXPLANATION:
 * The provided solution implements a console-based Print Job Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) representing a print job.
 *     *   It uses `private` fields (`jobId`, `userName`, `fileName`, `pageCount`) to enforce encapsulation.
 *     *   Public getter methods (`getJobId()`, `getUserName()`, etc.) provide controlled access to the data.
 *     *   The `toString()` method is overridden for easy printing of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   This class is the core of the system logic, managing the state of print jobs.
 *     *   `pendingJobs`: Declared as `Queue<PrintJob>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` that supports the necessary FIFO operations (`offer` for adding, `poll` for removing from the head). This fulfills the `Queue` and `LinkedList` requirements.
 *     *   `completedJobs`: Declared as `List<PrintJob>` and initialized with `new ArrayList<>()`. This fulfills the `List` and `ArrayList` requirements. It stores jobs in the order they are completed.
 *     *   `jobIdCounter`: An `AtomicInteger` is used to generate unique, sequential job IDs. While a simple `int` counter would work in this single-threaded application, `AtomicInteger` is a good practice for ID generation, especially if the system were to evolve to be multi-threaded.
 *     *   Methods like `submitJob`, `processNextJob`, `listPendingJobs`, and `listCompletedJobs` implement the core functionality, interacting with the `pendingJobs` queue and `completedJobs` list.
 *     *   `processNextJob` uses `pendingJobs.poll()`, which returns `null` if the queue is empty, allowing for easy checking and error reporting.
 * 
 * 3.  **`PrintSystem` Class (`main` method):**
 *     *   This class contains the `main` method, the application's entry point.
 *     *   **`Scanner`:** A `Scanner` object is created within a try-with-resources block to read user input from `System.in`. Reading entire lines (`scanner.nextLine()`) is used consistently to avoid common pitfalls when mixing `nextLine()` with `nextInt()` or `nextDouble()`.
 *     *   **Main Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **Menu and `switch`:** The `printMenu()` method displays options using `System.out`. The user's integer input is read and parsed. A `switch` statement is used to direct the program flow based on the valid menu choice, fulfilling the `switch` requirement.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for all standard output (menu, prompts, successful actions, lists). `System.err.println()` is strictly used for error messages (invalid input, queue empty conditions), fulfilling these requirements.
 *     *   **Input Validation:**
 *         *   When submitting a job, the code checks if `userName` or `fileName` are empty after trimming whitespace.
 *         *   A `while` loop and an inner `try-catch` block are used to repeatedly prompt the user for `pageCount` until a valid positive integer is entered. This robustly handles `NumberFormatException` and the business rule (page count > 0).
 *     *   **Error Handling (`try-catch`):**
 *         *   A specific `try-catch (NumberFormatException e)` is used around the parsing of the main menu choice to handle non-integer input gracefully.
 *         *   Another specific `try-catch (NumberFormatException e)` is used within the page count input loop for the same reason.
 *         *   A broad `try-catch (Exception e)` wraps the *entire* main application logic within the `main` method. This demonstrates a class-wide or application-level exception handling strategy, catching any unexpected runtime errors and printing a stack trace to `System.err`. This fulfills the class-wide `try-catch` requirement.
 *         *   The `processNextJob()` call in the `switch` statement checks if the returned job is `null` to detect and report an empty queue condition using `System.err`.
 * 
 * This solution effectively integrates the required Java components into a functional, practical application while adhering to best practices for structure, naming, encapsulation, validation, and error handling, making it a challenging but fair exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For generating unique job IDs

/**
 * Represents a single print job with details like user, file, and page count.
 * Demonstrates encapsulation.
 */
class PrintJob {
    private int jobId;
    private String userName;
    private String fileName;
    private int pageCount;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param userName The user who submitted the job.
     * @param fileName The name of the file to print.
     * @param pageCount The number of pages in the file.
     */
    public PrintJob(int jobId, String userName, String fileName, int pageCount) {
        this.jobId = jobId;
        this.userName = userName;
        this.fileName = fileName;
        this.pageCount = pageCount;
    }

    // --- Public Getter Methods (Encapsulation) ---
    public int getJobId() {
        return jobId;
    }

    public String getUserName() {
        return userName;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPageCount() {
        return pageCount;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return Formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", User: " + userName + ", File: " + fileName + ", Pages: " + pageCount;
    }
}

/**
 * Manages the queue of pending print jobs and the history of completed jobs.
 * Uses Queue and List/ArrayList.
 */
class PrintManager {
    // Queue for jobs waiting to be processed (FIFO)
    private Queue<PrintJob> pendingJobs;
    // List for jobs that have been processed (History)
    private List<PrintJob> completedJobs;
    // Counter to generate unique job IDs
    private AtomicInteger jobIdCounter;

    /**
     * Constructs a new PrintManager, initializing the job queues and history.
     */
    public PrintManager() {
        this.pendingJobs = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.jobIdCounter = new AtomicInteger(1); // Start job IDs from 1
    }

    /**
     * Submits a new print job to the pending queue.
     * Assumes input validation (non-empty strings, positive page count) is done by caller.
     * @param userName The user submitting the job.
     * @param fileName The name of the file to print.
     * @param pageCount The number of pages in the file.
     */
    public void submitJob(String userName, String fileName, int pageCount) {
        int newJobId = jobIdCounter.getAndIncrement(); // Get current ID and increment for the next job
        PrintJob newJob = new PrintJob(newJobId, userName, fileName, pageCount);
        pendingJobs.offer(newJob); // Add job to the end of the queue
        System.out.println("Job submitted successfully: " + newJob);
    }

    /**
     * Processes the next job at the front of the pending queue.
     * Moves the job to the completed history.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob processedJob = pendingJobs.poll(); // Retrieve and remove the head of the queue, returns null if empty
        if (processedJob != null) {
            completedJobs.add(processedJob); // Add the processed job to the history list
            System.out.println("Job processed: " + processedJob);
        }
        return processedJob; // Return null if queue was empty, job otherwise
    }

    /**
     * Lists all pending print jobs currently in the queue.
     * Prints to System.out.
     */
    public void listPendingJobs() {
        System.out.println("\n--- Pending Print Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs in the queue.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PrintJob job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Lists all completed print jobs stored in the history.
     * Prints to System.out.
     */
    public void listCompletedJobs() {
        System.out.println("\n--- Completed Print Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list
            for (int i = 0; i < completedJobs.size(); i++) {
                System.out.println((i + 1) + ". " + completedJobs.get(i));
            }
        }
        System.out.println("----------------------------");
    }

    /**
     * Checks if the pending jobs queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return pendingJobs.isEmpty();
    }
}

/**
 * Main application class for the Print Job Management System.
 * Handles user interaction via console menu, input validation, and exception handling.
 * Demonstrates Scanner, switch, System.out, System.err, and try-catch.
 */
public class PrintSystem {

    /**
     * The main entry point of the application.
     * Contains the main application loop and menu handling.
     * Implements class-wide and specific exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // --- Class-wide exception handling example ---
        // A broad try-catch block wrapping the entire application logic
        try {
            PrintManager printManager = new PrintManager();
            // Use try-with-resources for Scanner to ensure it's closed
            try (Scanner scanner = new Scanner(System.in)) {
                boolean running = true;

                System.out.println("Welcome to the Print Job Management System!");

                while (running) {
                    printMenu(); // Display the menu

                    try {
                        System.out.print("Enter your choice: ");
                        // Read the entire line to avoid issues with nextInt() followed by nextLine()
                        String choiceString = scanner.nextLine();
                        int choice = Integer.parseInt(choiceString); // Potentially throws NumberFormatException

                        // --- Use switch statement for menu navigation ---
                        switch (choice) {
                            case 1: // Submit Job
                                System.out.println("\n--- Submit New Job ---");
                                System.out.print("Enter user name: ");
                                String userName = scanner.nextLine();
                                System.out.print("Enter file name: ");
                                String fileName = scanner.nextLine();
                                int pageCount = 0;
                                boolean validPageCount = false;

                                // Input validation loop for page count
                                while (!validPageCount) {
                                    System.out.print("Enter number of pages: ");
                                    try {
                                        String pageCountString = scanner.nextLine();
                                        pageCount = Integer.parseInt(pageCountString); // Potentially throws NumberFormatException
                                        if (pageCount <= 0) {
                                            System.err.println("Error: Page count must be a positive integer."); // Use System.err for error
                                        } else {
                                            validPageCount = true; // Input is valid
                                        }
                                    } catch (NumberFormatException e) {
                                        System.err.println("Error: Invalid input for page count. Please enter a number."); // Use System.err for error
                                    }
                                }

                                // Basic validation for strings before submitting
                                if (userName.trim().isEmpty() || fileName.trim().isEmpty()) {
                                    System.err.println("Error: User name and file name cannot be empty. Job not submitted."); // Use System.err for error
                                } else {
                                    printManager.submitJob(userName, fileName, pageCount); // Call PrintManager method
                                }
                                break; // End case 1

                            case 2: // Process Next Job
                                System.out.println("\n--- Processing Next Job ---");
                                PrintJob processedJob = printManager.processNextJob(); // Call PrintManager method
                                if (processedJob == null) {
                                    System.err.println("Error: No jobs in the queue to process."); // Use System.err for error
                                }
                                break; // End case 2

                            case 3: // View Pending Jobs
                                printManager.listPendingJobs(); // Call PrintManager method
                                break; // End case 3

                            case 4: // View Completed Jobs
                                printManager.listCompletedJobs(); // Call PrintManager method
                                break; // End case 4

                            case 5: // Exit
                                System.out.println("Exiting Print Job Management System. Goodbye!"); // Use System.out for normal exit
                                running = false; // Set flag to exit loop
                                break; // End case 5

                            default: // Invalid Choice
                                System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Use System.err for error
                                break; // End default case
                        }
                    } catch (NumberFormatException e) {
                        // Catching NumberFormatException specifically for the main menu choice input
                        System.err.println("Error: Invalid input for menu choice. Please enter a number."); // Use System.err for error
                    }
                    System.out.println(); // Add a newline for better readability between operations
                } // End while loop
            } // Scanner is automatically closed here by try-with-resources

        } catch (Exception e) {
            // --- Class-wide catch block ---
            // This catches any unexpected exceptions that might escape the more specific catches
            System.err.println("\nAn unexpected error occurred during application execution:");
            e.printStackTrace(System.err); // Print stack trace to standard error stream
        }
    }

    /**
     * Displays the main menu options to the user via System.out.
     */
    private static void printMenu() {
        System.out.println("Print Job Management Menu:");
        System.out.println("1. Submit New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs Queue");
        System.out.println("4. View Completed Jobs History");
        System.out.println("5. Exit");
    }
}
