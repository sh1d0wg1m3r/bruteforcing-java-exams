/*
 * Exam Question #236
 * Generated on: 2025-05-11 22:37:00
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line Task Management System for a small project team. The system needs to keep track of all tasks defined for the project and manage a queue of tasks that are ready to be actively worked on.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): Represents the current status of the task. Possible statuses are "Pending", "Ready for Processing", and "Completed".
 *     *   Implement appropriate methods (constructor, getters, setters, `toString`). Ensure proper encapsulation.
 * 
 * 2.  **Task Management:** Create a `TaskManager` class that manages the collections of tasks. It should contain:
 *     *   A `List` (specifically, an `ArrayList`) to store *all* tasks defined in the system, regardless of status.
 *     *   A `Queue` to store tasks that are currently "Ready for Processing". Tasks should be added to the end of the queue and processed from the front.
 *     *   A counter to generate unique `taskId` values.
 *     *   Methods to:
 *         *   Add a new task (initially with "Pending" status).
 *         *   View all tasks with their details and status.
 *         *   Mark a task (by ID) as "Ready for Processing". This should move the task from the "Pending" state to "Ready for Processing" and add it to the processing queue.
 *         *   Complete the *next* task from the processing queue. This should remove the task from the queue and update its status in the main task list to "Completed".
 *         *   View tasks currently in the processing queue.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to interact with the user via the command line.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View All Tasks
 *         3.  Mark Task Ready for Processing
 *         4.  Complete Next Task
 *         5.  View Processing Queue
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use `System.out` for displaying the menu, task lists, success messages, and prompts.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, task not found, queue empty, invalid status transition).
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Implement robust input validation for user choices and task IDs. Handle non-integer input.
 *     *   Validate task existence when marking ready or completing.
 *     *   Validate status transitions (e.g., cannot mark a "Completed" task as "Ready").
 *     *   Handle cases where the processing queue is empty when attempting to complete a task.
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main user interaction loop in a `try-catch` block to catch unexpected exceptions and provide a graceful exit or error message. Include specific catches for expected issues like `InputMismatchException`.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper Java coding conventions.
 *     *   Use meaningful variable and method names.
 *     *   Add comments (including Javadoc for classes/methods) explaining the code.
 *     *   Ensure proper encapsulation (`private` fields, `public` methods where appropriate).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform actions, and display results or error messages clearly using `System.out` and `System.err` as specified.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Management System ---
 * Choose an option:
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Mark Task Ready for Processing
 * 4. Complete Next Task
 * 5. View Processing Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 1
 * Enter task description: Implement user authentication
 * Task added with ID: 2
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 2
 * --- All Tasks ---
 * Task ID: 1, Description: Design database schema, Status: Pending
 * Task ID: 2, Description: Implement user authentication, Status: Pending
 * -------------------
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 3
 * Enter Task ID to mark ready: 1
 * Task ID 1 marked as Ready for Processing.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 5
 * --- Processing Queue ---
 * Task ID: 1, Description: Design database schema, Status: Ready for Processing
 * ----------------------
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 4
 * Completed task from queue: Task ID: 1, Description: Design database schema, Status: Ready for Processing
 * Task ID 1 status updated to Completed.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 2
 * --- All Tasks ---
 * Task ID: 1, Description: Design database schema, Status: Completed
 * Task ID: 2, Description: Implement user authentication, Status: Pending
 * -------------------
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 4
 * Error: No tasks in the processing queue.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 3
 * Enter Task ID to mark ready: 99
 * Error: Task with ID 99 not found.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management System ---
 * ... (menu) ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Task Management System as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:** Represents a single task with `taskId`, `description`, and `status`. Fields are `private` for encapsulation. Getters and a setter for status are provided. The `toString()` method offers a convenient way to display task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the core logic and data structures.
 *     *   `allTasks`: An `ArrayList<Task>` is used to store all tasks ever created. `ArrayList` is a concrete implementation of the `List` interface, fulfilling the requirement to use both. It provides efficient random access, which is useful for finding tasks by ID.
 *     *   `processingQueue`: A `Queue<Task>` is used for tasks ready to be worked on. `LinkedList` is chosen as it implements the `Queue` interface and is suitable for FIFO operations (`offer` to add, `poll` to remove).
 *     *   `nextTaskId`: An integer counter ensures unique IDs are assigned to new tasks.
 *     *   `addTask()`: Creates a new `Task` object, assigns it the next available ID, adds it to the `allTasks` list, and increments the counter.
 *     *   `findTaskById()`: A helper method to search the `allTasks` list for a task by its ID. This is used by other methods to locate tasks.
 *     *   `markTaskReadyForProcessing()`: Finds the task by ID. Validates that the task exists and is in the "Pending" status. If valid, it updates the task's status and adds it to the `processingQueue` using `offer()`. Error messages are printed to `System.err`.
 *     *   `completeNextTask()`: Removes and returns the head of the `processingQueue` using `poll()`. If the queue is empty, `poll()` returns `null`, which is handled by printing an error to `System.err`. If a task is retrieved, it finds the corresponding task in `allTasks` (necessary to update the status in the permanent list) and sets its status to "Completed".
 *     *   `viewAllTasks()`: Iterates through the `allTasks` list and prints each task's details using its `toString()` method. Output goes to `System.out`.
 *     *   `viewProcessingQueue()`: Iterates through the `processingQueue` (using a standard `for-each` loop, which doesn't remove elements) and prints task details. Output goes to `System.out`.
 * 
 * 3.  **`TaskSystem` Class (`main` method):**
 *     *   This class contains the main application logic and user interface.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   The main execution is wrapped in a `try-catch (Exception e)` block, fulfilling the "class-wide exception handling" requirement by catching any unexpected errors that might occur within the main loop. A more specific `catch (InputMismatchException e)` is included *before* the general `Exception` catch to handle non-integer input specifically when reading the menu choice or task ID, preventing crashes and infinite loops caused by invalid scanner state.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop:
 *         *   `printMenu()` displays the options using `System.out`.
 *         *   Input is read using `scanner.nextInt()` for the menu choice. A crucial step is `scanner.nextLine()` immediately after `nextInt()` to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls (like reading the task description).
 *         *   A `switch` statement directs the program flow based on the user's integer choice.
 *         *   Each case calls the appropriate `TaskManager` method.
 *         *   Input validation (e.g., checking for empty description, ensuring task ID input is an integer) is performed, with errors reported to `System.err`.
 *         *   Case 6 sets `running` to `false` to exit the loop.
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   A `finally` block ensures the `Scanner` is closed when the program exits, whether normally or due to an exception caught by the outer `try-catch`.
 * 
 * **Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Task`, `TaskManager`) with encapsulated data and methods.
 * *   **Collections:** Effective use of `ArrayList` (implementing `List`) for general storage and `LinkedList` (implementing `Queue`) for managing processing order. Demonstrates choosing appropriate collection types for different purposes.
 * *   **Interfaces:** Using the `List` and `Queue` interfaces for type declarations (`List<Task> allTasks`, `Queue<Task> processingQueue`) promotes flexibility.
 * *   **Input/Output:** Using `Scanner` for input, `System.out` for standard output, and `System.err` for error messages.
 * *   **Control Flow:** Using `switch` for menu selection and `while` for the main application loop.
 * *   **Exception Handling:** Using `try-catch` blocks for both specific expected errors (`InputMismatchException`) and a general catch for unexpected errors, wrapping the core application logic.
 * *   **Data Management Logic:** Implementing the flow of tasks between different states ("Pending", "Ready", "Completed") and moving tasks between the list and the queue based on status transitions.
 * *   **Input Validation:** Checking user input for correctness and handling invalid data gracefully.
 * *   **Method Design:** Using private helper methods (`findTaskById`) and public methods for the main operations.
 * 
 * This solution provides a solid foundation demonstrating advanced Java concepts within a practical, albeit simplified, application context.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements both List and Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Pending", "Ready for Processing", "Completed"

    /**
     * Constructs a new Task.
     *
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the collection of tasks and the processing queue.
 */
class TaskManager {
    private List<Task> allTasks;
    private Queue<Task> processingQueue;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the task list, processing queue, and task ID counter.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Using ArrayList for all tasks
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The description of the new task.
     * @return The newly added Task object.
     */
    public Task addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getTaskId());
        return newTask;
    }

    /**
     * Finds a task by its ID in the list of all tasks.
     *
     * @param taskId The ID of the task to find.
     * @return The Task object if found, otherwise null.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getTaskId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Marks a task as ready for processing and adds it to the queue.
     *
     * @param taskId The ID of the task to mark as ready.
     * @return true if the task was successfully marked ready, false otherwise.
     */
    public boolean markTaskReadyForProcessing(int taskId) {
        Task task = findTaskById(taskId);

        if (task == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return false;
        }

        if (task.getStatus().equals("Pending")) {
            task.setStatus("Ready for Processing");
            processingQueue.offer(task); // Add to the end of the queue
            System.out.println("Task ID " + taskId + " marked as Ready for Processing.");
            return true;
        } else {
            System.err.println("Error: Task ID " + taskId + " is already '" + task.getStatus() + "'. Only 'Pending' tasks can be marked 'Ready'.");
            return false;
        }
    }

    /**
     * Completes the next task from the processing queue.
     *
     * @return true if a task was completed, false if the queue was empty.
     */
    public boolean completeNextTask() {
        Task taskToComplete = processingQueue.poll(); // Retrieve and remove the head of the queue

        if (taskToComplete == null) {
            System.err.println("Error: No tasks in the processing queue.");
            return false;
        }

        // Find the task in the allTasks list to update its status permanently
        Task taskInAllTasks = findTaskById(taskToComplete.getTaskId());

        if (taskInAllTasks != null) {
             // Should always find it if it came from the queue which references tasks in allTasks
            taskInAllTasks.setStatus("Completed");
            System.out.println("Completed task from queue: " + taskToComplete);
            System.out.println("Task ID " + taskToComplete.getTaskId() + " status updated to Completed.");
        } else {
             // This case indicates a potential logic error if a task in the queue isn't in allTasks
             System.err.println("Internal Error: Task from queue (ID " + taskToComplete.getTaskId() + ") not found in all tasks list.");
        }

        return true;
    }

    /**
     * Displays all tasks currently in the system.
     */
    public void viewAllTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks defined yet.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------");
    }

    /**
     * Displays tasks currently waiting in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            // Iterate without removing elements
            for (Task task : processingQueue) {
                System.out.println(task);
            }
        }
        System.out.println("----------------------");
    }
}

/**
 * Main class to run the Task Management System.
 */
public class TaskSystem {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default to an invalid choice

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Use a switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            taskManager.addTask(description.trim());
                        }
                        break;
                    case 2:
                        taskManager.viewAllTasks();
                        break;
                    case 3:
                        System.out.print("Enter Task ID to mark ready: ");
                         try {
                            int taskIdToProcess = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.markTaskReadyForProcessing(taskIdToProcess);
                         } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input. Please enter a valid task ID (number).");
                            scanner.nextLine(); // Consume invalid input
                         }
                        break;
                    case 4:
                        taskManager.completeNextTask();
                        break;
                    case 5:
                        taskManager.viewProcessingQueue();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Mark Task Ready for Processing");
        System.out.println("4. Complete Next Task");
        System.out.println("5. View Processing Queue");
        System.out.println("6. Exit");
    }
}
