/*
 * Exam Question #1125
 * Generated on: 2025-05-12 17:28:13
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Delivery Routing Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation system for a package delivery service. The system needs to manage packages waiting to be routed and track packages that are currently being processed or have completed processing. Packages arrive and are placed in a queue. A dispatcher processes packages one by one from the queue for routing. Once routed, the package moves to a list of packages currently "in transit". The system should also allow marking a package as "delivered" or "failed" from the in-transit list.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this process. The program should interact with the user via the console, accepting commands to manage packages.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a `Package` class with private fields for `packageId` (int), `destination` (String), and `status` (enum `PackageStatus`). Include a constructor and public getter methods. Add a method `updateStatus(PackageStatus newStatus)` that allows changing the package's status.
 *     *   Create a `PackageStatus` enum with states: `PENDING`, `IN_TRANSIT`, `DELIVERED`, `FAILED`.
 *     *   Create a `DeliveryRouteSimulator` class that manages the package collections and processing logic.
 * 
 * 2.  **Data Structures:**
 *     *   The `DeliveryRouteSimulator` class must use a `java.util.Queue<Package>` to hold packages that are `PENDING`.
 *     *   The `DeliveryRouteSimulator` class must use a `java.util.List<Package>` (specifically, instantiate using `java.util.ArrayList`) to hold packages that are `IN_TRANSIT`, `DELIVERED`, or `FAILED`.
 * 
 * 3.  **Functionality (User Commands):**
 *     *   The program should present a menu of options to the user.
 *     *   **`ADD`**: Prompt the user for a package ID (integer) and destination (string). Create a new `Package` object with status `PENDING` and add it to the pending queue. Validate that the package ID is positive.
 *     *   **`PROCESS_NEXT`**: Take the next package from the pending queue. If a package is available, change its status to `IN_TRANSIT` and move it to the processed list. Print a success message including the package ID and destination. If the queue is empty, print a message indicating that no packages are pending.
 *     *   **`COMPLETE <package_id> <status>`**: Prompt the user for a package ID (integer) and a completion status (`DELIVERED` or `FAILED`). Find the package with the given ID in the processed list. If found and its current status is `IN_TRANSIT`, update its status to the specified completion status (`DELIVERED` or `FAILED`). Print a success message. If the package is not found, not in `IN_TRANSIT` status, or the provided status is invalid, print an appropriate error message using `System.err`.
 *     *   **`VIEW_PENDING`**: Display all packages currently in the pending queue, including their ID and destination.
 *     *   **`VIEW_PROCESSED`**: Display all packages currently in the processed list, including their ID, destination, and current status.
 *     *   **`EXIT`**: Terminate the program.
 * 
 * 4.  **Required Java Components:**
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner` (for user input)
 *     *   `switch` statement (for handling user commands)
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for normal output and prompts)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., around the main command processing loop to catch unexpected errors or around input parsing).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement robust input validation for user commands and data.
 *     *   Implement proper error handling using `try-catch` and conditional checks.
 *     *   Maintain a clean and organized code structure.
 * 
 * **Expected Output:**
 * 
 * The program should provide clear prompts and output. Examples:
 * 
 * ```
 * --- Package Delivery Simulator ---
 * Commands: ADD, PROCESS_NEXT, COMPLETE <id> <status>, VIEW_PENDING, VIEW_PROCESSED, EXIT
 * Enter command: ADD
 * Enter Package ID: 101
 * Enter Destination: New York
 * Package 101 added to pending queue.
 * Enter command: ADD
 * Enter Package ID: 102
 * Enter Destination: Los Angeles
 * Package 102 added to pending queue.
 * Enter command: VIEW_PENDING
 * Pending Packages:
 * [ID: 101, Destination: New York]
 * [ID: 102, Destination: Los Angeles]
 * Enter command: PROCESS_NEXT
 * Processing package 101 (New York). Status updated to IN_TRANSIT.
 * Enter command: VIEW_PENDING
 * Pending Packages:
 * [ID: 102, Destination: Los Angeles]
 * Enter command: VIEW_PROCESSED
 * Processed Packages:
 * [ID: 101, Destination: New York, Status: IN_TRANSIT]
 * Enter command: COMPLETE 101 DELIVERED
 * Package 101 status updated to DELIVERED.
 * Enter command: VIEW_PROCESSED
 * Processed Packages:
 * [ID: 101, Destination: New York, Status: DELIVERED]
 * Enter command: COMPLETE 999 FAILED
 * Error: Package with ID 999 not found in processed list or not IN_TRANSIT.
 * Enter command: PROCESS_NEXT
 * Processing package 102 (Los Angeles). Status updated to IN_TRANSIT.
 * Enter command: EXIT
 * Exiting simulator.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation for all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the `Package Delivery Routing Simulator` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class and `PackageStatus` Enum:**
 *     *   The `Package` class encapsulates the data for a package (`packageId`, `destination`, `status`).
 *     *   Fields are `private`, and public getters provide controlled access.
 *     *   An `updateStatus` method is provided to change the package's state.
 *     *   Input validation is performed in the constructor to ensure valid `packageId` and `destination`.
 *     *   `toString()` is overridden for easy printing of package details in the processed list. A `toPendingString()` method is added for a simpler view in the pending queue.
 *     *   The `PackageStatus` enum clearly defines the possible states a package can be in, making the code more readable and preventing invalid status values.
 * 
 * 2.  **`DeliveryRouteSimulator` Class:**
 *     *   This is the main class orchestrating the simulation.
 *     *   It holds two core data structures:
 *         *   `pendingPackages`: Declared as `Queue<Package>` and instantiated as `LinkedList<Package>`. A `Queue` is used because packages are processed in the order they are added (FIFO - First-In, First-Out), which is a natural fit for a queue. `LinkedList` is a common and efficient implementation for a queue in Java. `offer()` and `poll()` methods are used for adding and removing elements, which are standard `Queue` operations that handle capacity issues (though not critical here) and return `null` on failure/empty queue, respectively, which simplifies checks.
 *         *   `processedPackages`: Declared as `List<Package>` and instantiated as `ArrayList<Package>`. A `List` (specifically `ArrayList`) is used here because packages are moved from the queue to this list once processing begins. This list needs to support iteration to view contents and potentially searching (as needed for the `COMPLETE` command), which `List` provides efficiently. `ArrayList` is a good general-purpose list implementation.
 *     *   A `Scanner` is used as a private field to read user input throughout the simulation loop.
 *     *   Methods like `addPackage`, `processNextPackage`, `completePackage`, `viewPendingPackages`, and `viewProcessedPackages` implement the required functionalities.
 *     *   These methods use `System.out` for prompts and normal output messages.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   The `runSimulationLoop()` method contains the main program loop.
 *     *   It continuously reads user input using the `Scanner`.
 *     *   The input command string is split, and a `switch` statement is used to dispatch to the appropriate method based on the first word of the command (`ADD`, `PROCESS_NEXT`, etc.). This fulfills the requirement for using a `switch` statement.
 *     *   The `EXIT` command sets a flag to terminate the loop.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   **Input Validation:**
 *         *   In `addPackage`, `Integer.parseInt` is used, and a `try-catch` handles `NumberFormatException` if the user enters non-integer input for the ID.
 *         *   The `Package` constructor validates that the ID is positive and the destination is not empty.
 *         *   In `completePackage`, input parsing (`Integer.parseInt`) is wrapped in `try-catch`. The number of command parts is checked. The status string is validated against the `PackageStatus` enum and specifically checked if it's `DELIVERED` or `FAILED`.
 *     *   **Error Handling:**
 *         *   A `try-catch (Exception e)` block is placed around the core command processing logic within the `runSimulationLoop`. This serves as a class-wide handler for any unexpected exceptions that might occur during the execution of command methods, preventing the program from crashing abruptly.
 *         *   Specific `try-catch` blocks are used within methods (`addPackage`, `completePackage`) for expected errors like `NumberFormatException` or `IllegalArgumentException`.
 *         *   `System.err.println()` is used exclusively for printing error messages, separating them from normal program output.
 *         *   Scenarios like processing from an empty queue (`processNextPackage`) or trying to complete a non-existent or incorrectly-statused package (`completePackage`) are handled gracefully with informative messages printed to `System.out` or `System.err`.
 * 
 * 5.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Private fields and public methods/getters are used in both classes.
 *     *   **Naming:** Variable names (`pendingPackages`, `processedPackages`, `packageId`, `destination`, `status`), method names (`addPackage`, `processNextPackage`, `viewPendingPackages`, `runSimulationLoop`), and class/enum names are descriptive.
 *     *   **Comments:** Javadoc comments are used for classes and key methods, explaining their purpose and parameters. Inline comments are used where necessary for clarity.
 *     *   **Clean Code:** The code is structured into logical classes and methods, separating concerns (Package data vs. Simulator logic vs. main execution). The use of enums improves readability and type safety.
 * 
 * This solution effectively utilizes all required components, simulates the scenario, implements necessary validation and error handling, and adheres to standard Java best practices, making it a suitable answer for a challenging advanced Java exam question.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException;

// Enum for package status
enum PackageStatus {
    PENDING,
    IN_TRANSIT,
    DELIVERED,
    FAILED
}

// Represents a package
class Package {
    private int packageId;
    private String destination;
    private PackageStatus status;

    /**
     * Constructs a new Package.
     *
     * @param packageId The unique ID of the package.
     * @param destination The destination address.
     */
    public Package(int packageId, String destination) {
        if (packageId <= 0) {
            throw new IllegalArgumentException("Package ID must be positive.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination cannot be null or empty.");
        }
        this.packageId = packageId;
        this.destination = destination;
        this.status = PackageStatus.PENDING;
    }

    // Getters
    public int getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public PackageStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the package.
     *
     * @param newStatus The new status to set.
     */
    public void updateStatus(PackageStatus newStatus) {
        this.status = newStatus;
    }

    @Override
    public String toString() {
        return "[ID: " + packageId + ", Destination: " + destination + ", Status: " + status + "]";
    }

    // Special toString for pending queue display
    public String toPendingString() {
        return "[ID: " + packageId + ", Destination: " + destination + "]";
    }
}

// Simulates the package delivery routing
class DeliveryRouteSimulator {
    private Queue<Package> pendingPackages;
    private List<Package> processedPackages; // Includes IN_TRANSIT, DELIVERED, FAILED packages
    private Scanner scanner;

    /**
     * Constructs a DeliveryRouteSimulator.
     */
    public DeliveryRouteSimulator() {
        this.pendingPackages = new LinkedList<>(); // LinkedList implements Queue
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new package to the pending queue.
     */
    public void addPackage() {
        try {
            System.out.print("Enter Package ID: ");
            int id = Integer.parseInt(scanner.nextLine());

            System.out.print("Enter Destination: ");
            String destination = scanner.nextLine();

            Package newPackage = new Package(id, destination);
            pendingPackages.offer(newPackage); // offer is preferred over add for queues
            System.out.println("Package " + id + " added to pending queue.");

        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid Package ID format. Please enter an integer.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
        }
    }

    /**
     * Processes the next package from the pending queue, moving it to the processed list.
     */
    public void processNextPackage() {
        try {
            Package nextPackage = pendingPackages.poll(); // poll retrieves and removes the head

            if (nextPackage != null) {
                nextPackage.updateStatus(PackageStatus.IN_TRANSIT);
                processedPackages.add(nextPackage);
                System.out.println("Processing package " + nextPackage.getPackageId() + " (" + nextPackage.getDestination() + "). Status updated to IN_TRANSIT.");
            } else {
                System.out.println("No packages are pending.");
            }
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while processing package: " + e.getMessage());
        }
    }

    /**
     * Completes a package by updating its status from IN_TRANSIT to DELIVERED or FAILED.
     *
     * @param parts The command parts, expected to be ["COMPLETE", "<id>", "<status>"].
     */
    public void completePackage(String[] parts) {
        if (parts.length != 3) {
            System.err.println("Error: Invalid COMPLETE command format. Use: COMPLETE <package_id> <status>");
            return;
        }

        try {
            int idToComplete = Integer.parseInt(parts[1]);
            String statusString = parts[2].toUpperCase();
            PackageStatus completionStatus;

            try {
                completionStatus = PackageStatus.valueOf(statusString);
                if (completionStatus != PackageStatus.DELIVERED && completionStatus != PackageStatus.FAILED) {
                     System.err.println("Error: Invalid completion status. Use DELIVERED or FAILED.");
                     return;
                }
            } catch (IllegalArgumentException e) {
                 System.err.println("Error: Invalid completion status '" + statusString + "'. Use DELIVERED or FAILED.");
                 return;
            }


            Package foundPackage = null;
            for (Package pkg : processedPackages) {
                if (pkg.getPackageId() == idToComplete) {
                    foundPackage = pkg;
                    break;
                }
            }

            if (foundPackage == null) {
                System.err.println("Error: Package with ID " + idToComplete + " not found in processed list.");
            } else if (foundPackage.getStatus() != PackageStatus.IN_TRANSIT) {
                 System.err.println("Error: Package " + idToComplete + " is not currently IN_TRANSIT. Cannot complete.");
            }
            else {
                foundPackage.updateStatus(completionStatus);
                System.out.println("Package " + idToComplete + " status updated to " + completionStatus + ".");
            }

        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid Package ID format for COMPLETE command. Please enter an integer.");
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while completing package: " + e.getMessage());
        }
    }


    /**
     * Displays all packages currently in the pending queue.
     */
    public void viewPendingPackages() {
        System.out.println("Pending Packages:");
        if (pendingPackages.isEmpty()) {
            System.out.println("No packages pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : pendingPackages) {
                System.out.println(pkg.toPendingString());
            }
        }
    }

    /**
     * Displays all packages currently in the processed list.
     */
    public void viewProcessedPackages() {
        System.out.println("Processed Packages:");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages processed yet.");
        } else {
            for (Package pkg : processedPackages) {
                System.out.println(pkg); // Uses the standard toString()
            }
        }
    }

    /**
     * Runs the main simulation loop, accepting user commands.
     */
    public void runSimulationLoop() {
        System.out.println("--- Package Delivery Simulator ---");
        System.out.println("Commands: ADD, PROCESS_NEXT, COMPLETE <id> <status>, VIEW_PENDING, VIEW_PROCESSED, EXIT");

        boolean running = true;
        while (running) {
            System.out.print("Enter command: ");
            String commandLine = scanner.nextLine().trim();
            String[] commandParts = commandLine.split("\\s+");
            String command = commandParts[0].toUpperCase();

            // Class-wide exception handling for the main loop
            try {
                switch (command) {
                    case "ADD":
                        addPackage();
                        break;
                    case "PROCESS_NEXT":
                        processNextPackage();
                        break;
                    case "COMPLETE":
                        completePackage(commandParts);
                        break;
                    case "VIEW_PENDING":
                        viewPendingPackages();
                        break;
                    case "VIEW_PROCESSED":
                        viewProcessedPackages();
                        break;
                    case "EXIT":
                        System.out.println("Exiting simulator.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Unknown command. Please use ADD, PROCESS_NEXT, COMPLETE, VIEW_PENDING, VIEW_PROCESSED, or EXIT.");
                        break;
                }
            } catch (Exception e) {
                 // Catch any unexpected exceptions during command execution
                 System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                 e.printStackTrace(System.err); // Print stack trace for debugging unexpected errors
            }
            System.out.println(); // Add a newline for better readability between commands
        }
        scanner.close(); // Close the scanner when exiting
    }

    public static void main(String[] args) {
        DeliveryRouteSimulator simulator = new DeliveryRouteSimulator();
        simulator.runSimulationLoop();
    }
}
