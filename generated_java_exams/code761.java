/*
 * Exam Question #761
 * Generated on: 2025-05-12 16:37:03
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simulated Task Processing System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple simulated task processing system. The system should manage a queue of tasks waiting to be processed and a history of tasks that have been completed. Users should be able to interact with the system through a command-line interface to add new tasks, execute the next waiting task, view the queue, or view the history.
 * 
 * A task is represented by a unique integer ID and a description string.
 * 
 * Your solution must demonstrate advanced understanding of core Java concepts and adhere to best programming practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int) and `description` (String), a constructor, and public getter methods. Include a meaningful `toString()` method for easy printing.
 * 2.  **System Management:** Create a `TaskProcessor` class responsible for managing the task queue and the completed tasks list.
 *     *   It must have a private field for the waiting tasks, declared as `java.util.Queue<Task>`.
 *     *   It must have a private field for the completed tasks, declared as `java.util.List<Task>`.
 *     *   Implement a method `addTask(int id, String description)` that creates a `Task` and adds it to the waiting queue. Validate that the `id` is positive; if not, use `System.err` to report an error and do not add the task.
 *     *   Implement a method `executeNextTask()` that removes the task from the front of the waiting queue and adds it to the completed tasks list. This method should return the executed `Task`. If the queue is empty, it should throw a custom exception (e.g., `QueueEmptyException`).
 *     *   Implement methods `getWaitingTasks()` and `getCompletedTasks()` that return the respective collections.
 * 3.  **User Interface:** Implement a main application class with a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   Display a menu of options to the user: Add Task, Execute Next Task, View Waiting Queue, View Completed History, Exit.
 *     *   Use a `switch` statement to handle user input commands.
 *     *   Read user input using `Scanner`.
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, invalid input, queue empty).
 *     *   Implement robust input handling using `try-catch` blocks to handle potential issues like non-integer input when an integer is expected.
 *     *   Implement class-wide exception handling in the `main` method's interaction loop using `try-catch` blocks to gracefully handle exceptions like the custom `QueueEmptyException` or input errors.
 *     *   Ensure the `Scanner` resource is properly closed.
 * 4.  **Required Components:** Your solution *must* explicitly use and demonstrate the usage of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList` (as the concrete implementation for the completed tasks `List`)
 *     *   `java.util.List` (as the type declaration for the completed tasks collection)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks for exception handling
 * 
 * 5.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs for classes/methods).
 *     *   Input validation.
 *     *   Proper error handling (using exceptions and error streams).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should loop, displaying a menu and processing user commands. Examples:
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Task Description: Process user request
 * Task 101 added to the queue.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: -5
 * Task ID must be a positive integer.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 3
 * Waiting Queue:
 * [Task{id=101, description='Process user request'}]
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 2
 * Executing task: Task{id=101, description='Process user request'}
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 3
 * Waiting Queue:
 * Queue is empty.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 2
 * Error: The task queue is empty.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 4
 * Completed History:
 * [Task{id=101, description='Process user request'}]
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: exit
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your code should be well-structured, commented, and handle errors gracefully as demonstrated above.
 *
 * EXPLANATION:
 * This solution implements a simulated task processing system using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** A simple POJO (`Plain Old Java Object`) representing a task with encapsulated `id` and `description` fields. It includes a constructor, public getters, and an overridden `toString()` method for convenient printing. This demonstrates basic object-oriented principles and encapsulation.
 * 
 * 2.  **`QueueEmptyException`:** A custom checked exception is created to signal when an attempt is made to execute a task from an empty queue. This demonstrates creating and using custom exceptions for specific error conditions, improving code clarity and maintainability.
 * 
 * 3.  **`TaskProcessor` Class:** This class acts as the core logic handler for the system.
 *     *   It uses a `java.util.Queue<Task>` (specifically `LinkedList`) to manage tasks waiting for execution. The `Queue` interface is ideal here because it enforces FIFO (First-In, First-Out) access, which is typical for a processing queue. `offer()` is used for adding tasks and `poll()` for removing and retrieving the head of the queue, which are standard non-blocking `Queue` operations.
 *     *   It uses a `java.util.List<Task>` (specifically `ArrayList`) to store the history of completed tasks. The `List` interface is suitable for ordered collections where elements can be added and retrieved sequentially. `ArrayList` is a common and efficient implementation for dynamic arrays.
 *     *   The `addTask` method includes basic input validation for the task ID, using `System.err` for error reporting.
 *     *   The `executeNextTask` method demonstrates removing from the queue (`poll()`) and adding to the list (`add()`). It correctly throws the custom `QueueEmptyException` if `poll()` returns `null`, indicating an empty queue.
 *     *   Getter methods provide access to the managed collections.
 * 
 * 4.  **`TaskSystemApp` Class (Main Application):**
 *     *   The `main` method contains the application's entry point and user interaction logic.
 *     *   A `java.util.Scanner` is used to read input from the console (`System.in`).
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to dispatch actions based on the user's integer choice, fulfilling the requirement to use a `switch`.
 *     *   `System.out` is used for all standard output, including the menu, prompts, success messages, and displaying the contents of the queue and history list.
 *     *   `System.err` is used specifically for error messages, such as invalid input, invalid choices, or the queue being empty.
 *     *   **Exception Handling (`try-catch`):** The main `while` loop is wrapped in a `try-catch` block. This provides class-wide handling for potential exceptions that might occur during user interaction or calls to the `TaskProcessor`.
 *         *   It specifically catches `QueueEmptyException` thrown by `executeNextTask`.
 *         *   It includes checks using `scanner.hasNextInt()` and a `try-catch` around `scanner.nextInt()` within the loop and case 1 to handle `InputMismatchException` if the user enters non-integer input where an integer is expected, consuming the invalid input to prevent an infinite loop.
 *         *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime issues, printing an error message and stack trace. This demonstrates a layered approach to exception handling.
 *     *   Input validation is performed both in the `TaskProcessor` (`addTask`) and in the `main` loop (checking choice range, checking for integer input).
 *     *   The `scanner.close()` call ensures the `Scanner` resource is released when the application exits.
 *     *   The `printMenu()` method is a simple helper function to keep the `main` method cleaner.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, simulated scenario. It demonstrates key principles like object-oriented design, encapsulation, input validation, error handling using custom exceptions and standard streams, and structured control flow, making it a challenging yet solvable exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for an empty queue
class QueueEmptyException extends Exception {
    public QueueEmptyException(String message) {
        super(message);
    }
}

// Represents a single task
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "'}";
    }
}

// Manages the task queue and completed task history
class TaskProcessor {
    // Using LinkedList as a concrete implementation for Queue
    private Queue<Task> waitingTasks;
    // Using ArrayList as a concrete implementation for List
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessor, initializing the waiting queue and completed list.
     */
    public TaskProcessor() {
        this.waitingTasks = new LinkedList<>(); // Use LinkedList for Queue
        this.completedTasks = new ArrayList<>(); // Use ArrayList for List
    }

    /**
     * Adds a new task to the waiting queue.
     * Validates that the task ID is positive.
     * @param id The ID of the task.
     * @param description The description of the task.
     */
    public void addTask(int id, String description) {
        if (id <= 0) {
            System.err.println("Task ID must be a positive integer.");
            return; // Do not add task if ID is invalid
        }
        Task newTask = new Task(id, description);
        waitingTasks.offer(newTask); // Use offer() for adding to queue
        System.out.println("Task " + id + " added to the queue.");
    }

    /**
     * Executes the next task from the waiting queue.
     * Moves the task from the waiting queue to the completed list.
     * @return The task that was executed.
     * @throws QueueEmptyException if the waiting queue is empty.
     */
    public Task executeNextTask() throws QueueEmptyException {
        Task nextTask = waitingTasks.poll(); // Use poll() for retrieving and removing
        if (nextTask == null) {
            throw new QueueEmptyException("The task queue is empty.");
        }
        completedTasks.add(nextTask);
        return nextTask;
    }

    /**
     * Gets the current waiting task queue.
     * @return The queue of tasks waiting for execution.
     */
    public Queue<Task> getWaitingTasks() {
        return waitingTasks;
    }

    /**
     * Gets the history of completed tasks.
     * @return The list of tasks that have been completed.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

// Main application class for the command-line interface
public class TaskSystemApp {

    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Simulated Task Processing System ---");

        // Class-wide exception handling loop
        while (running) {
            try {
                printMenu();
                System.out.print("Enter your choice: ");

                // Use hasNextInt() to check if the next input is an integer before reading
                if (!scanner.hasNextInt()) {
                    String invalidInput = scanner.next(); // Consume the invalid input
                    System.err.println("Error: Invalid choice '" + invalidInput + "'. Please enter a number between 1 and 5.");
                    continue; // Skip to next iteration
                }

                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter Task ID: ");
                        if (!scanner.hasNextInt()) {
                            System.err.println("Error: Invalid input for Task ID. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit switch case
                        }
                        int id = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        System.out.print("Enter Task Description: ");
                        String description = scanner.nextLine();
                        processor.addTask(id, description);
                        break;

                    case 2: // Execute Next Task
                        Task executedTask = processor.executeNextTask(); // This might throw QueueEmptyException
                        System.out.println("Executing task: " + executedTask);
                        break;

                    case 3: // View Waiting Queue
                        Queue<Task> waiting = processor.getWaitingTasks();
                        System.out.println("Waiting Queue:");
                        if (waiting.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            System.out.println(waiting); // Queue's toString is useful here
                        }
                        break;

                    case 4: // View Completed History
                        List<Task> completed = processor.getCompletedTasks();
                        System.out.println("Completed History:");
                        if (completed.isEmpty()) {
                            System.out.println("History is empty.");
                        } else {
                            System.out.println(completed); // List's toString is useful here
                        }
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting system.");
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (QueueEmptyException e) {
                // Handle custom exception for empty queue
                System.err.println("Error: " + e.getMessage());
            } catch (InputMismatchException e) {
                 // This catch block is less likely to be hit now due to hasNextInt() check,
                 // but good practice to include if reading logic changes.
                 // The hasNextInt() check handles the primary non-integer issue.
                 System.err.println("Error: Invalid input type. Please enter a number.");
                 scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
            System.out.println(); // Add a newline for better readability between interactions
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Execute Next Task");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed History");
        System.out.println("5. Exit");
    }
}
