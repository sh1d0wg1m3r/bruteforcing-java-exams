/*
 * Exam Question #833
 * Generated on: 2025-05-12 16:48:06
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System Dispatcher
 * 
 * **Scenario:** You are tasked with building a simple console-based Task Management System for a small team. The system should manage tasks through different stages: pending, in progress, and completed. Tasks are initially added to a waiting queue. When a team member is available, the next task is dispatched from the queue. Once work is finished, the task is marked as complete. The system should provide views of tasks at each stage.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields: `id` (int, unique), `description` (String), `status` (an `enum` with states like `PENDING`, `IN_PROGRESS`, `COMPLETED`), and `assignedTo` (String, representing assignee ID). Implement a static counter within the `Task` class to generate unique IDs for new tasks. Provide public getter and setter methods where necessary (at minimum for status and assignee). Override `toString()` for easy printing.
 * 2.  **Task Management Logic:** Create a `TaskManager` class to handle the system's operations.
 * 3.  **Data Structures:**
 *     *   Use `java.util.Queue<Task>` (specifically, an implementation like `java.util.LinkedList`) for storing tasks that are waiting to be dispatched (`pendingTasks`).
 *     *   Use `java.util.List<Task>` (specifically, an implementation like `java.util.ArrayList`) for storing tasks that are currently being worked on (`inProgressTasks`).
 *     *   Use `java.util.List<Task>` (specifically, an implementation like `java.util.ArrayList`) for storing tasks that have been completed (`completedTasks`).
 * 4.  **User Interaction:** Use `java.util.Scanner` to read user input from the console.
 * 5.  **Menu and Control Flow:** Implement a main application loop that presents a menu of options to the user. Use a `switch` statement to handle the user's choice. The menu should include:
 *     *   `1. Add New Task`: Prompt for a task description. Create a new `Task` with status `PENDING` and add it to the `pendingTasks` queue.
 *     *   `2. Dispatch Next Task`: If the `pendingTasks` queue is not empty, retrieve (and remove) the next task. Prompt for an assignee ID. Update the task's status to `IN_PROGRESS`, set the `assignedTo` field, and add the task to the `inProgressTasks` list. If the queue is empty, display an error.
 *     *   `3. Mark Task Complete`: Prompt for the task ID to mark complete and the assignee ID. Find the task in the `inProgressTasks` list. If found (and optionally, if the assignee matches), update its status to `COMPLETED`, remove it from `inProgressTasks`, and add it to `completedTasks`. Handle cases where the task is not found or input is invalid.
 *     *   `4. View Pending Tasks`: Display all tasks in the `pendingTasks` queue.
 *     *   `5. View In Progress Tasks`: Display all tasks in the `inProgressTasks` list.
 *     *   `6. View Completed Tasks`: Display all tasks in the `completedTasks` list.
 *     *   `7. Exit`: Terminate the program.
 * 6.  **Output:** Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 * 7.  **Error Handling:** Use `System.err` for displaying all error messages. Implement specific input validation (e.g., non-empty strings for description/assignee, valid integer for task ID) and handle potential issues like parsing errors (`NumberFormatException`).
 * 8.  **Robustness:** Implement class-wide exception handling using a `try-catch` block around the main application loop in the `TaskManager`'s `run` method to catch unexpected runtime errors. Ensure the `Scanner` resource is properly closed.
 * 9.  **Best Practices:** Follow Java coding conventions, use meaningful names for variables and methods, add comments where necessary, and ensure proper encapsulation.
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu and respond to user input.
 * - Successful operations should print informative messages to `System.out`.
 * - Errors (invalid input, empty queues, task not found, etc.) must be reported using `System.err`.
 * - Viewing options should list the tasks in the respective collections with their details.
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Dispatch Next Task
 * 3. Mark Task Complete
 * 4. View Pending Tasks
 * 5. View In Progress Tasks
 * 6. View Completed Tasks
 * 7. Exit
 * Enter choice: 1
 * Enter task description: Implement Task class
 * Task added: Implement Task class (ID: 1)
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 2
 * Enter assignee ID: team_member_A
 * Dispatched task ID 1 to team_member_A
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 5
 * --- In Progress Tasks ---
 * Task [ID=1, Desc='Implement Task class', Status=IN_PROGRESS, Assigned To=team_member_A]
 * -------------------------
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 3
 * Enter ID of task to mark complete: 1
 * Enter assignee ID who completed the task: team_member_A
 * Task ID 1 marked as completed by team_member_A
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 6
 * --- Completed Tasks ---
 * Task [ID=1, Desc='Implement Task class', Status=COMPLETED, Assigned To=team_member_A]
 * -----------------------
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 2
 * Error: No tasks in the pending queue to dispatch.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 3
 * Enter ID of task to mark complete: abc
 * Error: Invalid task ID format. Please enter a number.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 8
 * Error: Invalid choice. Please enter a number between 1 and 7.
 * 
 * Task Management System Menu:
 * ...
 * Enter choice: 7
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements a console-based Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task. It uses private fields (`id`, `description`, `status`, `assignedTo`) and public getters/setters, adhering to **encapsulation**. A static variable `nextId` is used to automatically generate unique IDs for each new task, a common pattern for simple ID generation. An `enum` `TaskStatus` provides a clear and type-safe way to represent the different states a task can be in. The `toString()` method provides a convenient way to display task details.
 * 
 * 2.  **`TaskManager` Class:** This class contains the core logic for managing tasks and interacting with the user.
 *     *   **Data Structures:** It declares three member variables to hold tasks: `pendingTasks` as a `Queue<Task>`, `inProgressTasks` as a `List<Task>`, and `completedTasks` as a `List<Task>`. These are instantiated using `LinkedList` (which implements `Queue`) and `ArrayList` (which implements `List`), fulfilling the requirements for using `Queue`, `ArrayList`, and the `List` interface.
 *     *   **`Scanner`:** A `Scanner` object is initialized to read user input from `System.in`.
 *     *   **Menu and `switch`:** The `displayMenu()` method shows the options. The `run()` method contains the main application loop. Inside the loop, user input for the choice is read, and a **`switch` statement** directs the program flow to the appropriate method (`addTask`, `dispatchTask`, etc.) based on the user's selection.
 *     *   **Operations (`addTask`, `dispatchTask`, `completeTask`, `view...Tasks`):** Each method implements a specific menu option.
 *         *   `addTask` reads a description and adds a new `Task` to the `pendingTasks` queue using `offer()`.
 *         *   `dispatchTask` uses `poll()` to get and remove the head task from `pendingTasks`, updates its status and assignee, and adds it to `inProgressTasks`. It includes a check for an empty queue.
 *         *   `completeTask` prompts for an ID and assignee, searches the `inProgressTasks` list (demonstrating list traversal), updates the task's status, removes it from `inProgressTasks`, and adds it to `completedTasks`.
 *         *   `view...Tasks` methods iterate through the respective collections and print task details.
 *     *   **Input Validation and `System.err`:** Throughout the methods, input validation is performed (e.g., checking for empty strings, ensuring integer input for task ID). Invalid input or operational errors (like trying to dispatch from an empty queue, or a task not being found) trigger error messages printed to **`System.err`**, as required.
 *     *   **`System.out`:** All normal output, including the menu, prompts, success messages, and task lists, is printed using **`System.out`**.
 *     *   **Exception Handling:**
 *         *   A specific `try-catch (NumberFormatException e)` block is used within `completeTask` to handle the case where the user enters non-integer input for the task ID. This demonstrates handling specific expected input errors.
 *         *   A broader `try-catch (Exception e)` block wraps the entire main loop within the `run()` method. This serves as the **class-wide exception handling** mechanism, catching any unexpected runtime errors that might occur during the program's execution. While a real-world application might use more specific catches, this fulfills the requirement to demonstrate a general catch block at a higher level.
 *     *   **Resource Management:** The `finally` block after the main `try-catch` ensures that the `Scanner` resource is closed, preventing resource leaks.
 *     *   **Best Practices:** The code uses meaningful names (`pendingTasks`, `dispatchTask`, `assignee`, etc.), includes basic comments, and is structured into logical methods within a class, adhering to the requested best practices.
 * 
 * This solution effectively integrates all the required Java components into a functional and realistic scenario, demonstrating understanding of data structures, control flow, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task in the system
class Task {
    private static int nextId = 1; // Static counter for unique task IDs

    private int id;
    private String description;
    private TaskStatus status;
    private String assignedTo; // Identifier for the assignee

    // Enum for task status
    public enum TaskStatus {
        PENDING, IN_PROGRESS, COMPLETED, FAILED
    }

    /**
     * Constructs a new Task with PENDING status.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TaskStatus.PENDING;
        this.assignedTo = null; // No assignee initially
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public String getAssignedTo() {
        return assignedTo;
    }

    // --- Setters ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    public void setAssignedTo(String assignedTo) {
        this.assignedTo = assignedTo;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status +
               (assignedTo != null ? ", Assigned To=" + assignedTo : "") + "]";
    }
}

// Manages the collections of tasks and user interaction
public class TaskManager {
    // Using Queue interface, implemented by LinkedList for pending tasks
    private Queue<Task> pendingTasks;
    // Using List interface, implemented by ArrayList for in-progress tasks
    private List<Task> inProgressTasks;
    // Using List interface, implemented by ArrayList for completed tasks
    private List<Task> completedTasks;

    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new TaskManager, initializing task collections and scanner.
     */
    public TaskManager() {
        pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        inProgressTasks = new ArrayList<>(); // ArrayList implements List
        completedTasks = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue based on user input.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
        System.out.println("Task added: " + newTask.getDescription() + " (ID: " + newTask.getId() + ")");
    }

    /**
     * Dispatches the next available task from the pending queue to an assignee.
     */
    public void dispatchTask() {
        // Check if the pending queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No tasks in the pending queue to dispatch.");
            return;
        }

        System.out.print("Enter assignee ID: ");
        String assignee = scanner.nextLine();

        // Input validation for assignee ID
        if (assignee == null || assignee.trim().isEmpty()) {
            System.err.println("Error: Assignee ID cannot be empty.");
            return;
        }

        // Get and remove the head of the queue
        Task taskToDispatch = pendingTasks.poll(); // poll() returns null if queue is empty, but we checked above

        // Update task status and assignee
        taskToDispatch.setStatus(Task.TaskStatus.IN_PROGRESS);
        taskToDispatch.setAssignedTo(assignee.trim());

        // Add the task to the in-progress list
        inProgressTasks.add(taskToDispatch);

        System.out.println("Dispatched task ID " + taskToDispatch.getId() + " to " + taskToDispatch.getAssignedTo());
    }

    /**
     * Marks a task as complete based on user input for task ID and assignee.
     */
    public void completeTask() {
        System.out.print("Enter ID of task to mark complete: ");
        int taskId;
        // Specific exception handling for parsing integer input
        try {
            taskId = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid task ID format. Please enter a number.");
            return;
        }

        System.out.print("Enter assignee ID who completed the task: ");
        String assignee = scanner.nextLine();

         // Input validation for assignee ID
         if (assignee == null || assignee.trim().isEmpty()) {
            System.err.println("Error: Assignee ID cannot be empty.");
            return;
        }
        assignee = assignee.trim();

        // Find the task in the inProgressTasks list
        Task taskToComplete = null;
        int taskIndex = -1; // Keep track of index for removal
        for (int i = 0; i < inProgressTasks.size(); i++) {
            Task task = inProgressTasks.get(i);
            if (task.getId() == taskId) {
                taskToComplete = task;
                taskIndex = i;
                break; // Found the task, exit loop
            }
        }

        // Handle cases: task not found or assignee mismatch
        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found in In Progress list.");
        } else if (!taskToComplete.getAssignedTo().equals(assignee)) {
             System.err.println("Error: Assignee ID mismatch. Task " + taskId + " is assigned to " + taskToComplete.getAssignedTo() + ".");
        }
        else {
            // Update status, remove from in-progress, add to completed
            taskToComplete.setStatus(Task.TaskStatus.COMPLETED);
            inProgressTasks.remove(taskIndex); // Remove using the found index
            completedTasks.add(taskToComplete);
            System.out.println("Task ID " + taskId + " marked as completed by " + assignee);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the in-progress list.
     */
     public void viewInProgressTasks() {
        System.out.println("\n--- In Progress Tasks ---");
        if (inProgressTasks.isEmpty()) {
            System.out.println("No tasks currently in progress.");
        } else {
            // Iterate through the list
            for (Task task : inProgressTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Dispatch Next Task");
        System.out.println("3. Mark Task Complete");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View In Progress Tasks");
        System.out.println("6. View Completed Tasks");
        System.out.println("7. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop.
     * Contains class-wide exception handling.
     */
    public void run() {
        // Class-wide exception handling around the main loop
        try {
            int choice = -1;
            while (choice != 7) {
                displayMenu();

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the switch and show menu again
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        dispatchTask();
                        break;
                    case 3:
                        completeTask();
                        break;
                    case 4:
                        viewPendingTasks();
                        break;
                    case 5:
                        viewInProgressTasks();
                        break;
                    case 6:
                        viewCompletedTasks();
                        break;
                    case 7:
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 7.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
             // Ensure the scanner resource is closed when the program exits or an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
