/*
 * Exam Question #542
 * Generated on: 2025-05-11 23:27:08
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:** You are tasked with building a simple command-line application to manage tasks for a small team. The system should allow users to add new tasks, view tasks that are pending processing, process the next task in line, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Add a new task with a description.
 *     *   View all tasks currently pending processing.
 *     *   Process the next task that is pending. Processed tasks should be moved to a completed list.
 *     *   View all tasks that have been completed.
 *     *   Exit the application.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage tasks that are pending processing. New tasks should be added to this queue.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare variables or method return types using the `java.util.List` interface where appropriate (e.g., for viewing tasks).
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices and task descriptions).
 *     *   Implement a menu-driven system where the user selects actions by entering a number.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, no tasks to process, empty task description).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid user input (e.g., non-numeric input when a number is expected) or attempting operations on empty data structures where applicable (though robust methods like `poll()` can avoid some exceptions). Ensure the application doesn't crash on typical user errors.
 *     *   Include input validation where necessary (e.g., ensure task description is not empty).
 * 
 * 5.  **Best Practices:**
 *     *   Design classes with proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Structure the code logically into appropriate classes (e.g., a `Task` class, a `TaskManager` class, and a main application class).
 * 
 * **Task:** Write the complete Java code for this Task Management System application that fulfills all the requirements listed above.
 * 
 * **Expected Output Structure:**
 * The application should present a menu, prompt for input, and display results or errors based on the user's choices. Example interaction flow:
 * 
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: 'Write exam question'
 * 
 * Task Management Menu:
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter task description: Create solution code
 * Task added: 'Create solution code'
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * [PENDING] Write exam question
 * [PENDING] Create solution code
 * ---------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Processing Next Task ---
 * Task processed: 'Write exam question'
 * ----------------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * 
 * --- Pending Tasks ---
 * [PENDING] Create solution code
 * ---------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * [COMPLETED] Write exam question
 * -----------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Processing Next Task ---
 * Task processed: 'Create solution code'
 * ----------------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * No pending tasks to process.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should produce similar output and handle the specified error conditions.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System as requested, demonstrating the use of various core Java concepts and data structures.
 * 
 * **Key Components Used:**
 * 
 * 1.  **`java.util.Queue`**: The `pendingTasks` field in the `TaskManager` class is declared as a `Queue<Task>` and initialized with a `LinkedList` instance (`new LinkedList<>()`). The `Queue` is used to store tasks that are waiting to be processed, naturally following a First-In, First-Out (FIFO) order, although the problem didn't strictly require FIFO, `Queue` is the appropriate interface for a processing line. New tasks are added using `pendingTasks.offer()`, and tasks are retrieved and removed for processing using `pendingTasks.poll()`.
 * 
 * 2.  **`java.util.ArrayList`**: The `completedTasks` field in the `TaskManager` class is initialized as an `ArrayList<Task>` (`new ArrayList<>()`). This `ArrayList` is used to store tasks once they have been processed. Tasks are added to this list using `completedTasks.add()` after being moved from the pending queue. `ArrayList` provides dynamic resizing and efficient element access, suitable for storing a growing list of completed items.
 * 
 * 3.  **`java.util.List` interface**: The `completedTasks` field is declared using the `List` interface (`private List<Task> completedTasks;`), even though it's instantiated as an `ArrayList`. Furthermore, the `getPendingTasks()` and `getCompletedTasks()` methods in `TaskManager` return a `List<Task>`. Using the `List` interface promotes flexibility and good design practices by programming to the interface rather than the concrete implementation (`ArrayList`).
 * 
 * 4.  **`java.util.Scanner`**: An instance of `Scanner` is used in the `main` method of `TaskManagementApp` to read user input from `System.in`. It is used to read the user's menu choice (`scanner.nextInt()`) and the task description (`scanner.nextLine()`). The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the newline character left in the input buffer, preventing issues with subsequent `nextLine()` calls.
 * 
 * 5.  **`switch` statement**: A `switch` statement in the `main` method is used to control the flow of the program based on the integer choice entered by the user. Each `case` corresponds to a menu option (Add, View Pending, Process, View Completed, Exit), and a `default` case handles invalid integer inputs.
 * 
 * 6.  **`System.err`**: `System.err.println()` is used to print error messages to the standard error stream. This is used in `TaskManager.addTask` for empty descriptions, in `TaskManager.processNextTask` when there are no pending tasks, and in `TaskManagementApp.main` for invalid menu choices and non-numeric input errors caught by the `try-catch` blocks. Using `System.err` visually distinguishes error output from normal program output (`System.out`).
 * 
 * 7.  **`System.out`**: `System.out.println()` is used extensively for normal program output, including displaying the main menu, prompts for input, success messages after adding or processing tasks, and listing the contents of the pending and completed task lists.
 * 
 * 8.  **`try-catch` blocks**: Exception handling is implemented using `try-catch`. A main `try` block wraps the entire user interaction loop in `TaskManagementApp.main`. Inside this, a nested `try-catch` specifically handles `InputMismatchException` which occurs if the user enters non-integer input when `scanner.nextInt()` is expected. A general `catch (Exception e)` is also included to catch any other unexpected runtime exceptions that might occur during the execution of menu options, providing a level of robustness. A `finally` block ensures the `Scanner` resource is closed properly when the application exits, whether normally or due to an exception.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskManager` classes encapsulate their data (private fields like `description`, `status`, `pendingTasks`, `completedTasks`) and expose functionality through public methods (`getDescription`, `setStatus`, `addTask`, `processNextTask`, etc.). This hides the internal implementation details.
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskManagementApp`), variable names (`pendingTasks`, `completedTasks`, `description`, `choice`), method names (`addTask`, `processNextTask`, `printMenu`), and enum values (`PENDING`, `COMPLETED`) are chosen to clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and methods explaining their purpose, parameters, and return values. Inline comments clarify specific code logic where needed.
 * *   **Input Validation:** The `TaskManager.addTask` method checks if the provided description is null or empty, preventing the creation of invalid tasks. The `try-catch` blocks in `main` handle invalid user input format.
 * *   **Error Handling:** As detailed in point 8 above, robust error handling is implemented using `try-catch` and `System.err` for specific expected errors (like `InputMismatchException` or no pending tasks) and general unexpected exceptions.
 * *   **Clean Code Structure:** The code is organized into three logical classes, separating the data structure (`Task`), the business logic (`TaskManager`), and the user interface/application entry point (`TaskManagementApp`). Methods are kept relatively short and focused on single responsibilities (e.g., `printMenu` just prints the menu).
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating an understanding of data structures, control flow, user interaction, and robust error handling principles.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Enum representing the possible statuses of a task.
 */
enum TaskStatus {
    PENDING,
    COMPLETED
}

/**
 * Represents a single task with a description and status.
 */
class Task {
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with default PENDING status.
     * @param description The description of the task. Must not be null or empty.
     */
    public Task(String description) {
        // Basic validation could be here, but handled by TaskManager's addTask
        this.description = description;
        this.status = TaskStatus.PENDING; // Default status for new tasks
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     * @return The task status (PENDING or COMPLETED).
     */
    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task including its status and description.
     * @return Formatted string of the task.
     */
    @Override
    public String toString() {
        return "[" + status + "] " + description;
    }
}

/**
 * Manages tasks using a queue for pending tasks and a list for completed tasks.
 * Provides methods for adding, processing, and viewing tasks.
 */
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO behavior is typical for Queue)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager with empty task lists.
     */
    public TaskManager() {
        // LinkedList is a common and efficient implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common and efficient implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the queue of pending tasks.
     * Performs basic validation on the description.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for error messages
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        // offer() is the preferred way to add elements to a queue,
        // returning true on success, false if queue is full (not an issue here).
        pendingTasks.offer(newTask);
        // Use System.out for success messages
        System.out.println("Task added: '" + description.trim() + "'");
    }

    /**
     * Processes the next task from the pending queue.
     * If a task is available, it is removed from the queue, its status is updated to COMPLETED,
     * and it is added to the list of completed tasks.
     * @return The processed Task object, or null if no pending tasks were available.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, returning null if the queue is empty.
        Task nextTask = pendingTasks.poll();
        if (nextTask != null) {
            nextTask.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(nextTask);
            // Use System.out for success messages
            System.out.println("Task processed: '" + nextTask.getDescription() + "'");
        } else {
            // Use System.err when no task was available to process
            System.err.println("No pending tasks to process.");
        }
        return nextTask;
    }

    /**
     * Gets a list of tasks currently in the pending queue.
     * Returns a new ArrayList containing the elements from the queue
     * to avoid external modification of the internal queue state.
     * Declared return type as List interface.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList from the queue elements
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets the list of completed tasks.
     * Declared return type as List interface.
     * @return A List of completed tasks (specifically an ArrayList instance).
     */
    public List<Task> getCompletedTasks() {
        // Return the actual list of completed tasks.
        return completedTasks;
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction, menu display, and delegates operations to TaskManager.
 */
public class TaskManagementApp {

    public static void main(String[] args) {
        // Instantiate the TaskManager
        TaskManager taskManager = new TaskManager();
        // Instantiate Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide or main method try-catch block for robust error handling
        // This try block wraps the main application loop.
        try {
            while (running) {
                printMenu(); // Display menu
                int choice = -1;

                // Inner try-catch block specifically for handling potential input errors
                try {
                    System.out.print("Enter your choice: ");
                    // Read the integer input for the menu choice
                    choice = scanner.nextInt();
                    // Consume the rest of the line after reading the integer
                    // This is crucial to prevent issues with nextLine() reading empty strings later.
                    scanner.nextLine();

                    // Use a switch statement to perform actions based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            taskManager.addTask(description); // Delegate adding task to TaskManager
                            break;
                        case 2:
                            System.out.println("\n--- Pending Tasks ---");
                            // Get pending tasks using the List interface
                            List<Task> pending = taskManager.getPendingTasks();
                            if (pending.isEmpty()) {
                                System.out.println("No pending tasks.");
                            } else {
                                // Iterate and print pending tasks
                                pending.forEach(System.out::println);
                            }
                            System.out.println("---------------------\n");
                            break;
                        case 3:
                            System.out.println("\n--- Processing Next Task ---");
                            taskManager.processNextTask(); // Delegate processing to TaskManager
                            System.out.println("----------------------------\n");
                            break;
                        case 4:
                            System.out.println("\n--- Completed Tasks ---");
                             // Get completed tasks using the List interface (implemented by ArrayList)
                            List<Task> completed = taskManager.getCompletedTasks();
                            if (completed.isEmpty()) {
                                System.out.println("No completed tasks.");
                            } else {
                                // Iterate and print completed tasks
                                completed.forEach(System.out::println);
                            }
                            System.out.println("-----------------------\n");
                            break;
                        case 5:
                            running = false; // Set running to false to exit the loop
                            System.out.println("Exiting Task Management System.");
                            break;
                        default:
                            // Handle choices outside the valid range using System.err
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch exception specifically for non-integer input when nextInt() is called
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input from the scanner to prevent an infinite loop
                    scanner.nextLine();
                } catch (Exception e) {
                    // Catch any other unexpected exceptions that might occur during operations
                    // This provides a safety net for unforeseen issues.
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging: e.printStackTrace();
                }
            }
        } finally {
            // The finally block ensures that resources like the Scanner are closed
            // regardless of whether an exception occurred or the loop exited normally.
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed. Application finished.");
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
