/*
 * Exam Question #559
 * Generated on: 2025-05-11 23:29:20
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Management System. The system will manage a fixed number of appointment slots and a waiting list for patients who cannot immediately book their desired slot.
 * 
 * The system should allow users (patients) to:
 * 1.  Book an appointment for a specific slot.
 * 2.  Cancel an existing appointment.
 * 3.  View all confirmed appointments and the current waiting list.
 * 4.  Exit the application.
 * 
 * There are a total of **5 fixed appointment slots**, numbered 1 through 5. Each slot can hold only one appointment at a time.
 * 
 * If a patient tries to book a slot that is already taken, they should be added to a waiting list. When an appointment is cancelled, the system should indicate that a slot has opened, but it is not required to automatically book the next waiting patient into that slot within this implementation.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must strictly adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.List` (specifically `java.util.ArrayList`) to store the confirmed appointments.
 *     *   Use `java.util.Queue` (specifically `java.util.LinkedList` is a common implementation, but you can use any `Queue` implementation) to manage the waiting list.
 * 2.  **Input:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user menu options (Book, Cancel, View, Exit).
 * 4.  **Output:**
 *     *   Use `System.out.println()` for normal messages, menu display, and system output (confirmed appointments, waiting list).
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, slot unavailable, appointment not found).
 * 5.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. This means the main operational loop of your application should be enclosed within a `try-catch` block to catch potential runtime errors gracefully.
 * 6.  **Object-Oriented Design:**
 *     *   Create appropriate classes (e.g., `Patient`, `Appointment`, `HospitalScheduler`).
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 * 7.  **Best Practices:**
 *     *   Include comments where necessary to explain complex logic.
 *     *   Implement basic input validation (e.g., checking if slot numbers are within the valid range, handling non-integer input for choices/slots).
 * 
 * **Class Structure Suggestions:**
 * 
 * *   `Patient` class: Simple class, maybe just a `String name`.
 * *   `Appointment` class: Holds a `Patient` object and the `int slotNumber`.
 * *   `HospitalScheduler` class: Contains the `List<Appointment>` and `Queue<Patient>`, and methods for booking, canceling, viewing, and the main interactive loop. The `main` method should be in this class.
 * 
 * **User Interaction Flow:**
 * 
 * The program should display a menu with options (Book, Cancel, View, Exit). Based on the user's choice, it should perform the corresponding action, prompting for necessary details (patient name, slot number). It should loop until the user chooses to exit.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Welcome to Hospital Appointment System!
 * Available Slots: 1 to 5
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter desired slot number (1-5): 3
 * Appointment booked successfully for Alice in slot 3.
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 1
 * Enter patient name: Bob
 * Enter desired slot number (1-5): 3
 * Slot 3 is already booked. Adding Bob to the waiting list.
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 3
 * --- Confirmed Appointments ---
 * Slot 3: Alice
 * --- Waiting List ---
 * Bob
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 2
 * Enter patient name: Alice
 * Enter slot number to cancel (1-5): 3
 * Appointment for Alice in slot 3 cancelled successfully.
 * A slot has opened. The waiting list currently has 1 patient(s).
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 3
 * --- Confirmed Appointments ---
 * (No appointments)
 * --- Waiting List ---
 * Bob
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * Menu:
 * 1. Book Appointment
 * 2. Cancel Appointment
 * 3. View Appointments and Waiting List
 * 4. Exit
 * Enter your choice: 4
 * Exiting system. Goodbye!
 * ```
 * 
 * **Expected Output:**
 * 
 * Your program should produce output similar to the example interaction, clearly indicating confirmed appointments by slot and the patients in the waiting list. Error messages should be distinct (using `System.err`).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Effective implementation of class-wide `try-catch` for exception handling.
 * *   Proper object-oriented design (encapsulation, meaningful names).
 * *   Correct logic for booking (checking availability, adding to waiting list), canceling, and viewing.
 * *   Input validation and error handling as specified.
 * *   Code clarity, comments, and adherence to best practices.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Hospital Appointment Management System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` class: A basic class to hold patient information (just the name). Encapsulation is used with a private `name` field and a public getter.
 *     *   `Appointment` class: Represents a confirmed appointment, linking a `Patient` object to a specific `slotNumber`. It includes a helper method `matches` for easy searching during cancellation and a `toString` for display. Encapsulation is used for its fields.
 *     *   `HospitalScheduler` class: This is the main class that orchestrates the system. It holds the core data structures (`confirmedAppointments` and `waitingList`) and the methods for the system's operations (booking, canceling, viewing). It also contains the `main` method.
 * 
 * 2.  **Data Structures:**
 *     *   `confirmedAppointments`: Declared as `List<Appointment>` and initialized as an `ArrayList<Appointment>`. `ArrayList` is suitable here because we need to add, remove, and iterate through appointments. Using `List` as the interface type is good practice.
 *     *   `waitingList`: Declared as `Queue<Patient>` and initialized as a `LinkedList<Patient>`. A `Queue` is the perfect fit for a waiting list because patients are added to the end (`offer`) and processed from the front (`poll` - although not fully implemented in this simplified version, the structure is correct for FIFO).
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is created in the `HospitalScheduler` constructor to read input from `System.in`.
 *     *   `scanner.nextLine()` is used to read string input (patient names).
 *     *   `scanner.nextInt()` is used to read integer input (menu choice, slot number).
 *     *   Crucially, `scanner.nextLine()` is called *after* `scanner.nextInt()` (often within a `finally` block or immediately after the `try-catch` for `nextInt`) to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The `main` method in `HospitalScheduler` contains a `while` loop that keeps the application running.
 *     *   Inside the loop, after getting the user's integer choice, a `switch` statement is used to direct execution to the appropriate method (`bookAppointment`, `cancelAppointment`, `viewAppointments`) or to exit the loop (`case 4`).
 *     *   A `default` case handles invalid integer choices.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, confirmation messages, the list of confirmed appointments, and the waiting list.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid slot numbers, appointment not found during cancellation, or invalid menu input (non-numeric or out of range). This makes error messages stand out in the console.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Class-Wide Handling:** The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This demonstrates handling potential unexpected errors that might occur anywhere within the main execution flow. While less specific, it fulfills the requirement for a class-wide catch-all. A more robust application would have more specific catches.
 *     *   **Input Validation Handling:** `try-catch(InputMismatchException e)` blocks are used specifically around `scanner.nextInt()` calls in `bookAppointment`, `cancelAppointment`, and `main` to catch cases where the user enters non-integer input when a number is expected. This prevents the program from crashing due to bad input format. The `finally` block or immediate `nextLine()` call ensures the scanner state is clean regardless of whether an exception occurred or not.
 * 
 * 7.  **Logic:**
 *     *   **Booking:** It checks if the requested slot is already present in the `confirmedAppointments` list. If found, the patient is added to the `waitingList` using `offer()`. If not found, a new `Appointment` object is created and added to the `confirmedAppointments` list using `add()`.
 *     *   **Canceling:** It iterates through the `confirmedAppointments` list (or uses `removeIf` for a cleaner approach) to find an appointment matching both the patient name and slot number. If found, it's removed. A message about the waiting list size is printed if the list is not empty.
 *     *   **Viewing:** It prints the contents of both the `confirmedAppointments` list and the `waitingList`. For the waiting list, it iterates using a for-each loop (since we don't want to remove elements with `poll()` just by viewing).
 * 
 * 8.  **Best Practices:**
 *     *   Encapsulation: Achieved by making fields private and providing public methods (`getName`, `getSlotNumber`, etc.).
 *     *   Meaningful Names: Class names (`Patient`, `Appointment`, `HospitalScheduler`), variable names (`confirmedAppointments`, `waitingList`, `slotNumber`, `patientName`), and method names (`bookAppointment`, `cancelAppointment`, `viewAppointments`) are descriptive.
 *     *   Input Validation: Checks for valid slot number ranges (1 to `TOTAL_SLOTS`) and handles `InputMismatchException`.
 *     *   Comments: Added to explain the purpose of classes, methods, and key logic sections.
 *     *   Clean Code: Methods are relatively short and focused on a single task.
 * 
 * This solution effectively uses all the required components in a practical scenario, demonstrating understanding of core Java data structures, control flow, error handling, and object-oriented principles suitable for an advanced programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents an appointment for a specific slot
class Appointment {
    private Patient patient;
    private int slotNumber;

    public Appointment(Patient patient, int slotNumber) {
        this.patient = patient;
        this.slotNumber = slotNumber;
    }

    public Patient getPatient() {
        return patient;
    }

    public int getSlotNumber() {
        return slotNumber;
    }

    // Helper method to check if an appointment matches a patient and slot
    public boolean matches(String patientName, int slot) {
        return this.patient.getName().equalsIgnoreCase(patientName) && this.slotNumber == slot;
    }

    @Override
    public String toString() {
        return "Slot " + slotNumber + ": " + patient.getName();
    }
}

// Manages appointments and the waiting list
public class HospitalScheduler {
    private List<Appointment> confirmedAppointments;
    private Queue<Patient> waitingList;
    private static final int TOTAL_SLOTS = 5;
    private Scanner scanner;

    public HospitalScheduler() {
        // Use ArrayList for confirmed appointments as per requirement (List interface)
        this.confirmedAppointments = new ArrayList<>();
        // Use LinkedList as a common implementation for Queue
        this.waitingList = new LinkedList<>();
        this.scanner = new Scanner(System.in);
    }

    // Method to book an appointment
    public void bookAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine();

        int slotNumber = -1;
        try {
            System.out.print("Enter desired slot number (1-" + TOTAL_SLOTS + "): ");
            slotNumber = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number for the slot.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             // Consume the newline character left by nextInt()
             // This is crucial to prevent nextLine() from skipping input later
             scanner.nextLine();
        }


        // Validate slot number range
        if (slotNumber < 1 || slotNumber > TOTAL_SLOTS) {
            System.err.println("Invalid slot number. Please enter a number between 1 and " + TOTAL_SLOTS + ".");
            return;
        }

        // Check if the slot is already booked
        boolean slotBooked = false;
        for (Appointment appt : confirmedAppointments) {
            if (appt.getSlotNumber() == slotNumber) {
                slotBooked = true;
                break;
            }
        }

        if (slotBooked) {
            System.out.println("Slot " + slotNumber + " is already booked. Adding " + patientName + " to the waiting list.");
            waitingList.offer(new Patient(patientName)); // Add to the end of the queue
        } else {
            // Book the appointment
            confirmedAppointments.add(new Appointment(new Patient(patientName), slotNumber));
            System.out.println("Appointment booked successfully for " + patientName + " in slot " + slotNumber + ".");
        }
    }

    // Method to cancel an appointment
    public void cancelAppointment() {
        if (confirmedAppointments.isEmpty()) {
            System.out.println("No appointments to cancel.");
            return;
        }

        System.out.print("Enter patient name for appointment to cancel: ");
        String patientName = scanner.nextLine();

        int slotNumber = -1;
         try {
            System.out.print("Enter slot number of appointment to cancel (1-" + TOTAL_SLOTS + "): ");
            slotNumber = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number for the slot.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline
        }

        // Validate slot number range
        if (slotNumber < 1 || slotNumber > TOTAL_SLOTS) {
            System.err.println("Invalid slot number. Please enter a number between 1 and " + TOTAL_SLOTS + ".");
            return;
        }


        // Find and remove the appointment
        boolean removed = confirmedAppointments.removeIf(appt -> appt.matches(patientName, slotNumber));

        if (removed) {
            System.out.println("Appointment for " + patientName + " in slot " + slotNumber + " cancelled successfully.");
            if (!waitingList.isEmpty()) {
                System.out.println("A slot has opened. The waiting list currently has " + waitingList.size() + " patient(s).");
                // Note: We are not automatically booking the next patient as per requirements
            }
        } else {
            System.err.println("Could not find an appointment for " + patientName + " in slot " + slotNumber + ".");
        }
    }

    // Method to view all appointments and the waiting list
    public void viewAppointments() {
        System.out.println("--- Confirmed Appointments ---");
        if (confirmedAppointments.isEmpty()) {
            System.out.println("(No appointments booked)");
        } else {
            // Sort appointments by slot number for better readability (optional but good practice)
            confirmedAppointments.sort((a1, a2) -> Integer.compare(a1.getSlotNumber(), a2.getSlotNumber()));
            for (Appointment appt : confirmedAppointments) {
                System.out.println(appt);
            }
        }

        System.out.println("--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("(Waiting list is empty)");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Patient patient : waitingList) {
                System.out.println(i++ + ". " + patient.getName());
            }
        }
    }

    // Method to display the main menu
    private void displayMenu() {
        System.out.println("\nWelcome to Hospital Appointment System!");
        System.out.println("Available Slots: 1 to " + TOTAL_SLOTS);
        System.out.println("\nMenu:");
        System.out.println("1. Book Appointment");
        System.out.println("2. Cancel Appointment");
        System.out.println("3. View Appointments and Waiting List");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the scheduler
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        boolean running = true;

        // Class-wide exception handling around the main operational loop
        try {
            while (running) {
                scheduler.displayMenu();
                int choice = -1;
                try {
                    choice = scheduler.scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scheduler.scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                } finally {
                     scheduler.scanner.nextLine(); // Consume the newline character
                }


                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        scheduler.bookAppointment();
                        break;
                    case 2:
                        scheduler.cancelAppointment();
                        break;
                    case 3:
                        scheduler.viewAppointments();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Generic catch block for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scheduler.scanner != null) {
                scheduler.scanner.close();
            }
        }
    }
}
