/*
 * Exam Question #388
 * Generated on: 2025-05-11 23:03:52
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small team. The system needs to allow users to add tasks, mark tasks as urgent, view all tasks, view the next urgent task in priority, process (simulate working on) the next urgent task, and mark tasks as completed. The system should handle basic user interactions and errors gracefully.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   An integer `id` (unique identifier, automatically generated).
 *     *   A `String` `description` of the task.
 *     *   A boolean flag `isUrgent` indicating if the task is urgent.
 *     *   Provide appropriate constructors, getters, and a method to mark the task as urgent. Override `toString()` for easy printing.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing tasks.
 *     *   Use a `java.util.List` (specifically, instantiate with `java.util.ArrayList`) to store *all* tasks in the system.
 *     *   Use a `java.util.Queue` (e.g., `java.util.LinkedList`) to manage *urgent* tasks, representing a priority queue where the oldest urgent task is processed first.
 *     *   Implement the following methods in `TaskManager`:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and adds it to the list of all tasks.
 *         *   `markTaskUrgent(int taskId)`: Finds a task by its ID. If found and not already urgent, mark it as urgent and add it to the urgent tasks queue. Throw custom exceptions (`TaskNotFoundException`, `TaskAlreadyUrgentException`) if the task is not found or is already urgent.
 *         *   `viewAllTasks()`: Prints details of all tasks currently in the system from the list.
 *         *   `viewNextUrgentTask()`: Prints details of the next task in the urgent queue *without* removing it (peek). Handle the case where the queue is empty.
 *         *   `processNextUrgentTask()`: Prints details of the next task in the urgent queue and *removes* it (poll), simulating starting work on it. Handle the case where the queue is empty. Note: This does not remove the task from the main list; completion is a separate step.
 *         *   `completeTask(int taskId)`: Finds a task by its ID in the list of all tasks and removes it. If the task was also in the urgent queue, attempt to remove it from there as well. Throw `TaskNotFoundException` if the task is not found.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `ExamTaskApp`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Display a menu of options to the user (Add Task, Mark Urgent, View All, View Next Urgent, Process Next Urgent, Complete Task, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices and task IDs (e.g., ensuring integer input).
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.out` for displaying the menu, task lists, prompts, and success messages.
 *     *   Use `System.err` to print error messages (e.g., invalid input, task not found, task already urgent, empty queue operations).
 *     *   Implement exception handling using `try-catch` blocks. Include specific catches for expected issues (like `NumberFormatException` for invalid integer input, and your custom exceptions) and a general `catch (Exception e)` at a higher level (e.g., around the main application loop) for unexpected errors (class-wide handling).
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc comments for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu. User input should be prompted appropriately. Task lists should be formatted clearly. Success messages should confirm actions. Error messages should be informative and printed to `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Mark Task as Urgent
 * ...
 * 0. Exit
 * -------------------------
 * Enter your choice: 1
 * Enter task description: Implement login screen
 * Task added.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- All Tasks ---
 * Task ID: 1, Description: "Implement login screen"
 * -----------------
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Enter Task ID to mark urgent: 1
 * Task 1 marked as urgent.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Next Urgent Task (Peek) ---
 * Task ID: 1, Description: "Implement login screen" [URGENT]
 * -----------------------------
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 6
 * Enter Task ID to complete: 1
 * Task 1 completed.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- All Tasks ---
 * No tasks available.
 * -----------------
 * ```
 * 
 * *(Error examples)*
 * ```
 * Enter your choice: abc
 * Invalid input. Please enter a number. (Printed to System.err)
 * 
 * Enter your choice: 6
 * Enter Task ID to complete: 99
 * Error: Task with ID 99 not found. (Printed to System.err)
 * ```
 * 
 * **Constraint:** Your solution must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, a `switch` statement, `System.err`, `System.out`, and `try-catch` blocks for exception handling as specified.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Task Class:**
 *     *   Represents a single task with `id`, `description`, and `isUrgent`.
 *     *   Uses private fields and public getters for encapsulation.
 *     *   The `markUrgent()` method modifies the task's state.
 *     *   `toString()` provides a user-friendly representation for printing.
 * 
 * 2.  **TaskManager Class:**
 *     *   Manages the collections of tasks.
 *     *   `allTasks`: Declared as `List<Task>` and initialized as `new ArrayList<>()`. This demonstrates using the interface type (`List`) which is good practice, while using the concrete implementation (`ArrayList`) for dynamic resizing and efficient element access/addition/removal by index or object.
 *     *   `urgentTasksQueue`: Declared as `Queue<Task>` and initialized as `new LinkedList<>()`. `LinkedList` is a common and efficient implementation of the `Queue` interface, suitable for FIFO (First-In, First-Out) operations like `offer` (add to tail), `peek` (view head), and `poll` (remove and return head).
 *     *   `nextTaskId`: A static counter ensures each task gets a unique ID starting from 1.
 *     *   Methods like `addTask`, `markTaskUrgent`, `viewAllTasks`, `viewNextUrgentTask`, `processNextUrgentTask`, and `completeTask` implement the core logic, interacting with the `allTasks` list and `urgentTasksQueue`.
 *     *   The `findTaskById` helper method encapsulates the logic for searching the `allTasks` list and throws a `TaskNotFoundException` if the task doesn't exist, promoting cleaner code in the calling methods.
 *     *   `markTaskUrgent` adds the *same* `Task` object reference from `allTasks` to the `urgentTasksQueue`.
 *     *   `completeTask` removes the task from `allTasks` using `ArrayList.remove(Object)`. It also attempts to remove the *same* `Task` object from `urgentTasksQueue` using `Queue.remove(Object)`. This relies on object identity comparison, which is correct because the same object instance is shared between the list and the queue.
 * 
 * 3.  **ExamTaskApp Class (Main Application):**
 *     *   The `main` method contains the application's entry point and the primary interaction loop.
 *     *   A `Scanner` is used to read input from `System.in`. It is closed in a `finally` block to ensure resource cleanup.
 *     *   The `displayMenu()` method outputs the options to `System.out`.
 *     *   A `while(true)` loop runs the application until the user chooses to exit.
 *     *   User input for the menu choice is read as a `String` first to safely handle non-integer input.
 *     *   A `try-catch (NumberFormatException)` block immediately handles cases where the user enters non-numeric input for the main menu choice, printing an error to `System.err`.
 *     *   A `switch` statement directs the program flow based on the valid integer choice.
 *     *   Inside the `switch` cases, further logic is implemented:
 *         *   Calling appropriate `TaskManager` methods.
 *         *   Reading additional input (like description or Task ID) using `scanner.nextLine()`.
 *         *   Specific `try-catch` blocks are used within cases 2 and 6 to handle `NumberFormatException` when parsing Task IDs and to catch the custom exceptions (`TaskNotFoundException`, `TaskAlreadyUrgentException`) thrown by `TaskManager` methods. Error messages from these catches are printed to `System.err`.
 *         *   Cases 4 and 5 check if the `urgentTasksQueue` is empty before attempting `peek()` or `poll()` and print informative messages to `System.out` if it is empty, avoiding potential `NullPointerException` if `peek`/`poll` returned `null`.
 *     *   A top-level `try-catch (Exception e)` block wraps the entire `while` loop. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might propagate up from the `TaskManager` or other parts of the code, preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 * 
 * 4.  **Error Handling and Output:**
 *     *   `System.out` is used exclusively for normal program output (menu, prompts, lists, success messages).
 *     *   `System.err` is used exclusively for error messages, including invalid input, task not found errors, and other specific error conditions caught by the `try-catch` blocks.
 *     *   Custom exceptions (`TaskNotFoundException`, `TaskAlreadyUrgentException`) are used to signal specific business logic errors from the `TaskManager` to the calling `ExamTaskApp`, where they are caught and reported to the user via `System.err`.
 * 
 * This solution effectively combines the required data structures (`List`, `Queue`, `ArrayList`) and control flow mechanisms (`Scanner`, `switch`, `try-catch`) within a realistic application context, demonstrating key object-oriented principles and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal if iterating, though remove(Object) is used here.

// Custom exception for when a task is not found
class TaskNotFoundException extends Exception {
    public TaskNotFoundException(String message) {
        super(message);
    }
}

// Custom exception for when a task is already urgent
class TaskAlreadyUrgentException extends Exception {
     public TaskAlreadyUrgentException(String message) {
        super(message);
    }
}

/**
 * Represents a single task with an ID, description, and urgency status.
 */
class Task {
    private int id;
    private String description;
    private boolean isUrgent;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.isUrgent = false; // Tasks are not urgent by default
    }

    // --- Getters ---

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is marked as urgent.
     * @return true if the task is urgent, false otherwise.
     */
    public boolean isUrgent() {
        return isUrgent;
    }

    // --- Setter/Modifier ---

    /**
     * Marks the task as urgent.
     */
    public void markUrgent() {
        this.isUrgent = true;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string including task ID, description, and urgency status.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\"" + (isUrgent ? " [URGENT]" : "");
    }

    // Note: Default equals() and hashCode() from Object are sufficient here
    // as we compare Task objects based on identity when removing from the queue.
}

/**
 * Manages a collection of tasks, including a list of all tasks and a queue for urgent tasks.
 */
class TaskManager {
    // Using List interface type, instantiated with ArrayList
    private List<Task> allTasks;
    // Using Queue interface type, instantiated with LinkedList
    private Queue<Task> urgentTasksQueue;
    private static int nextTaskId = 1; // Static counter for generating unique task IDs

    /**
     * Constructs a new TaskManager.
     * Initializes the task collections.
     */
    public TaskManager() {
        allTasks = new ArrayList<>();
        urgentTasksQueue = new LinkedList<>(); // LinkedList is a common implementation for Queue
    }

    /**
     * Adds a new task to the system.
     * @param description The description of the new task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Marks a task as urgent and adds it to the urgent queue.
     * @param taskId The ID of the task to mark as urgent.
     * @throws TaskNotFoundException If the task ID does not exist.
     * @throws TaskAlreadyUrgentException If the task is already marked as urgent.
     */
    public void markTaskUrgent(int taskId) throws TaskNotFoundException, TaskAlreadyUrgentException {
        Task taskToMark = findTaskById(taskId); // findTaskById throws TaskNotFoundException

        if (taskToMark.isUrgent()) {
            throw new TaskAlreadyUrgentException("Task " + taskId + " is already marked as urgent.");
        }

        taskToMark.markUrgent(); // Set the urgent flag on the task object
        urgentTasksQueue.offer(taskToMark); // Add the task object to the urgent queue
    }

    /**
     * Displays all tasks currently in the system.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("\n--- All Tasks ---");
            System.out.println("No tasks available.");
            System.out.println("-----------------");
            return;
        }

        System.out.println("\n--- All Tasks ---");
        for (Task task : allTasks) {
            System.out.println(task); // Uses Task's toString()
        }
        System.out.println("-----------------");
    }

    /**
     * Displays the next urgent task without removing it from the queue (peek operation).
     */
    public void viewNextUrgentTask() {
        Task nextUrgent = urgentTasksQueue.peek(); // Peek at the head of the queue

        if (nextUrgent == null) {
            System.out.println("\n--- Next Urgent Task (Peek) ---");
            System.out.println("No urgent tasks in the queue.");
            System.out.println("-----------------------------");
        } else {
            System.out.println("\n--- Next Urgent Task (Peek) ---");
            System.out.println(nextUrgent);
            System.out.println("-----------------------------");
        }
    }

    /**
     * Simulates processing the next urgent task by removing it from the queue (poll operation).
     */
    public void processNextUrgentTask() {
        Task processedTask = urgentTasksQueue.poll(); // Poll (remove and return) the head of the queue

        if (processedTask == null) {
            System.out.println("\n--- Processing Urgent Task ---");
            System.out.println("No urgent tasks to process.");
            System.out.println("----------------------------");
        } else {
            System.out.println("\n--- Processing Urgent Task ---");
            System.out.println("Processed: " + processedTask); // Uses Task's toString()
            // Note: Task remains in allTasks until completed via the 'Complete Task' option.
            System.out.println("----------------------------");
        }
    }

    /**
     * Completes a task by removing it from the list of all tasks.
     * If the task was urgent, it is also removed from the urgent queue.
     * @param taskId The ID of the task to complete.
     * @throws TaskNotFoundException If the task ID does not exist in the list of all tasks.
     */
    public void completeTask(int taskId) throws TaskNotFoundException {
        Task taskToComplete = findTaskById(taskId); // findTaskById throws TaskNotFoundException

        // Remove the task from the list of all tasks
        // ArrayList.remove(Object) works by iterating and using equals()
        // Since we are removing the exact Task object instance returned by findTaskById,
        // default Object.equals() (identity check) is sufficient.
        boolean removedFromAll = allTasks.remove(taskToComplete);

        // Although findTaskById guarantees it exists, checking the return of remove is good practice
        if (!removedFromAll) {
             // This case should theoretically not be reached if findTaskById succeeded,
             // but included for robustness.
             throw new TaskNotFoundException("Task with ID " + taskId + " could not be removed from all tasks list.");
        }

        // If the task was marked urgent, also remove it from the urgent queue
        if (taskToComplete.isUrgent()) {
             // Queue.remove(Object) works similarly to List.remove(Object)
             urgentTasksQueue.remove(taskToComplete); // Remove the task object from the queue if present
             // Note: No need to check return value; if it wasn't in the queue (e.g., already processed),
             // remove returns false, which is fine.
        }
    }

    /**
     * Helper method to find a task by its ID in the list of all tasks.
     * @param taskId The ID to search for.
     * @return The Task object if found.
     * @throws TaskNotFoundException If no task with the given ID is found.
     */
    private Task findTaskById(int taskId) throws TaskNotFoundException {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        // If loop finishes without finding the task
        throw new TaskNotFoundException("Task with ID " + taskId + " not found.");
    }
}

/**
 * Main application class for the Simple Task Management System.
 * Handles user interaction, menu display, and delegates operations to TaskManager.
 */
public class ExamTaskApp {

    /**
     * Displays the main menu options to the console.
     */
    private static void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Mark Task as Urgent");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Next Urgent Task (Peek)");
        System.out.println("5. Process Next Urgent Task (Poll)");
        System.out.println("6. Complete Task");
        System.out.println("0. Exit");
        System.out.println("-------------------------");
    }

    /**
     * The main entry point of the application.
     * Manages the main application loop and user interactions.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);

        // Class-wide exception handling for the main application loop
        try {
            // Main application loop
            while (true) {
                displayMenu();
                System.out.print("Enter your choice: ");
                String choiceStr = scanner.nextLine();

                try {
                    // Input validation: ensure choice is an integer
                    int choice = Integer.parseInt(choiceStr);

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Task description cannot be empty.");
                            } else {
                                taskManager.addTask(description.trim());
                            }
                            break;
                        case 2: // Mark Task Urgent
                            System.out.print("Enter Task ID to mark urgent: ");
                            // Specific try-catch for parsing task ID
                            try {
                                int urgentTaskId = Integer.parseInt(scanner.nextLine());
                                taskManager.markTaskUrgent(urgentTaskId);
                                System.out.println("Task " + urgentTaskId + " marked as urgent.");
                            } catch (NumberFormatException e) {
                                System.err.println("Invalid input. Please enter a valid Task ID (number).");
                            } catch (TaskNotFoundException | TaskAlreadyUrgentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3: // View All Tasks
                            taskManager.viewAllTasks();
                            break;
                        case 4: // View Next Urgent Task (Peek)
                            taskManager.viewNextUrgentTask();
                            break;
                        case 5: // Process Next Urgent Task (Poll)
                            taskManager.processNextUrgentTask();
                            break;
                        case 6: // Complete Task
                             System.out.print("Enter Task ID to complete: ");
                            // Specific try-catch for parsing task ID
                             try {
                                int completeTaskId = Integer.parseInt(scanner.nextLine());
                                taskManager.completeTask(completeTaskId);
                                System.out.println("Task " + completeTaskId + " completed.");
                            } catch (NumberFormatException e) {
                                System.err.println("Invalid input. Please enter a valid Task ID (number).");
                            } catch (TaskNotFoundException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 0: // Exit
                            System.out.println("Exiting Task Manager. Goodbye!");
                            return; // Exit the main method and thus the program
                        default:
                            // Handle invalid menu numbers
                            System.err.println("Invalid choice. Please enter a number between 0 and 6.");
                    }
                } catch (NumberFormatException e) {
                    // Catch non-integer input for the main menu choice
                    System.err.println("Invalid input. Please enter a number corresponding to a menu option.");
                }
                // Note: Specific exceptions like TaskNotFoundException, TaskAlreadyUrgentException
                // are caught within the respective case blocks where they are thrown.
                // This outer try-catch is for unexpected errors.
            }
        } catch (Exception e) {
            // General catch block for any unhandled exceptions occurring in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging in case of unexpected errors
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
