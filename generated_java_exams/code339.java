/*
 * Exam Question #339
 * Generated on: 2025-05-11 22:57:17
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Scheduling Simulation**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line application that simulates a basic task scheduling and processing system. The system manages a queue of incoming tasks and keeps a record of completed tasks. Users can add new tasks, process the next available task, view pending tasks, view completed tasks, and exit the application.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `status` (enum or String, e.g., "Pending", "Completed"). Include a constructor, getter methods, and a method to update the status.
 * 2.  **Scheduler Core:** Create a `TaskScheduler` class that manages the task flow. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `List<Task>` to hold tasks that have been completed. Declare this using the `List` interface type.
 *     *   Methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, updates its status to "Completed", and adds it to the completed tasks list. This method should handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` (or similar collection view) of tasks currently in the pending queue.
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 *         *   Proper encapsulation (private fields, public methods).
 * 3.  **User Interface:** Implement a main application class (e.g., `TaskSchedulerApp`) with a `main` method that provides a command-line interface using `Scanner`.
 *     *   Present a menu of options to the user: Add Task, Process Task, View Pending Tasks, View Completed Tasks, Exit.
 *     *   Use a `switch` statement to handle user input and execute the corresponding `TaskScheduler` methods.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 4.  **Input Handling:**
 *     *   Use `Scanner` to read user input for menu choices and task details (ID, description).
 *     *   Validate user input. For example, ensure task ID is a positive integer and the description is not empty.
 *     *   Handle potential `InputMismatchException` or `NumberFormatException` when reading integer input.
 * 5.  **Error Handling:**
 *     *   Use `System.err.println()` to display error messages (e.g., invalid input, queue is empty when processing).
 *     *   Use `System.out.println()` for normal output (menu, task details, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks. This could involve catching exceptions in the main loop or specific input handling logic.
 * 6.  **Required Java Components:** The solution *must* explicitly use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, a `switch` statement, `System.err`, `System.out`, and `try-catch` blocks for exception handling.
 * 7.  **Best Practices:** Follow Java coding best practices, including meaningful names, comments, and clear code structure.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, accept user commands, and provide feedback.
 * *   Adding a task should confirm the addition.
 * *   Processing a task should indicate which task was processed or state that the queue was empty.
 * *   Viewing tasks should list the tasks with their details.
 * *   Invalid input should result in an error message on `System.err`.
 * *   Any unexpected errors should be caught and reported.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID (integer): 101
 * Enter Task Description: Finish report
 * Task added: Task{id=101, description='Finish report', status=Pending}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 1
 * Enter Task ID (integer): 102
 * Enter Task Description: Code review
 * Task added: Task{id=102, description='Code review', status=Pending}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=101, description='Finish report', status=Pending}
 * Task{id=102, description='Code review', status=Pending}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=101, description='Finish report', status=Pending}
 * Task completed: Task{id=101, description='Finish report', status=Completed}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=102, description='Code review', status=Pending}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=101, description='Finish report', status=Completed}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=102, description='Code review', status=Pending}
 * Task completed: Task{id=102, description='Code review', status=Completed}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * No tasks in the queue to process.
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Focus on demonstrating the required Java components in a practical, albeit simplified, application.
 * *   The task processing logic can be a simple status update and transfer between collections.
 * 
 * **Submission:**
 * 
 * Provide the complete, runnable Java code for the `Task`, `TaskScheduler`, and `TaskSchedulerApp` classes.
 *
 * EXPLANATION:
 * This solution implements a simple task scheduling system demonstrating the required Java concepts.
 * 
 * **Code Structure:**
 * 
 * *   **`Task` Class:** Represents a single task with an ID, description, and status. It enforces basic validation in its constructor and provides getters and a status setter. The `toString()` method provides a convenient string representation for printing.
 * *   **`TaskScheduler` Class:** This is the core logic class. It holds two collections:
 *     *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. This follows the First-In, First-Out (FIFO) principle, where tasks are processed in the order they are added. The `offer()` method is used for adding, and `poll()` is used for removing from the head.
 *     *   `completedTasks`: A `List<Task>` implemented using `ArrayList`. This simply stores tasks once they are processed. It's declared using the `List` interface type, adhering to good practice.
 *     *   Methods like `addTask`, `processNextTask`, `getPendingTasks`, and `getCompletedTasks` manage the flow and state of tasks between these collections. `processNextTask` handles the empty queue case gracefully by checking if `poll()` returns `null`.
 * *   **`TaskSchedulerApp` Class:** Contains the `main` method, which acts as the application's entry point and user interface handler.
 *     *   It uses a `Scanner` to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement dispatches actions based on the user's menu choice.
 *     *   Helper methods (`printMenu`, `getUserChoice`, `addTaskFromInput`, `viewPendingTasks`, `viewCompletedTasks`) encapsulate specific parts of the UI logic.
 * 
 * **Required Components Usage:**
 * 
 * *   **`java.util.Queue`:** Used in `TaskScheduler` (`pendingTasks`) to manage tasks awaiting processing in a FIFO manner. `offer()` and `poll()` methods are used.
 * *   **`java.util.ArrayList`:** Used in `TaskScheduler` (`completedTasks`) as the concrete implementation of the `List` storing finished tasks. Also used to create a copy of the pending tasks for viewing (`getPendingTasks`).
 * *   **`java.util.List`:** The `completedTasks` field and the return type of `getPendingTasks` and `getCompletedTasks` are declared using the `List` interface, promoting flexibility and good design.
 * *   **`java.util.Scanner`:** Used in `TaskSchedulerApp` (`scanner`) to read user input from the console.
 * *   **`switch` statement:** Used in the `main` method of `TaskSchedulerApp` to handle different user menu options.
 * *   **`System.err`:** Used in `TaskSchedulerApp` and `TaskScheduler` to display error messages (e.g., invalid input, queue empty, task creation errors).
 * *   **`System.out`:** Used throughout `TaskSchedulerApp` and `TaskScheduler` for normal application output (menu, prompts, success messages, task details).
 * *   **`try-catch` blocks:** Used for exception handling:
 *     *   In `TaskSchedulerApp.main`, a general `catch(Exception e)` is used around the main loop to catch any unexpected runtime errors, fulfilling the "class-wide" requirement for the main execution flow.
 *     *   In `TaskSchedulerApp.getUserChoice`, a `try-catch(InputMismatchException)` handles cases where the user enters non-integer input for the menu choice.
 *     *   In `TaskSchedulerApp.addTaskFromInput`, a `try-catch(NumberFormatException)` handles invalid integer input for the task ID, and a `catch(IllegalArgumentException)` handles validation errors thrown by the `Task` constructor (like negative ID or empty description). A general `catch(Exception e)` is also included for robustness during input.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskScheduler` are private, accessed via public methods.
 * *   **Meaningful Names:** Classes, variables, and methods have descriptive names (`pendingTasks`, `processNextTask`, `addTaskFromInput`).
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** `Task` constructor validates ID and description. `addTaskFromInput` handles `NumberFormatException` and `IllegalArgumentException`. `getUserChoice` handles `InputMismatchException`.
 * *   **Error Handling:** Specific exceptions are caught and handled with informative messages printed to `System.err`. The general `catch(Exception e)` in `main` prevents the program from crashing on unexpected errors.
 * *   **Clean Code Structure:** The code is separated into logical classes, and the `main` method delegates complex operations to helper methods and the `TaskScheduler` instance. Using `scanner.nextLine()` after reading an integer helps prevent common `Scanner` issues with newline characters. Returning a copy of the pending tasks list in `getPendingTasks` is a good practice to protect the internal state of the `TaskScheduler`.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simplified, real-world simulation, demonstrating understanding of data structures, object-oriented principles, input handling, and exception management.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private int id;
    private String description;
    private String status; // "Pending", "Completed"

    /**
     * Constructs a new Task with initial status "Pending".
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @throws IllegalArgumentException if id is not positive or description is null/empty.
     */
    public Task(int id, String description) {
        if (id <= 0) {
            throw new IllegalArgumentException("Task ID must be positive.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (for status update) ---
    public void setStatus(String status) {
        // Basic validation, could use an enum for better type safety
        if ("Pending".equals(status) || "Completed".equals(status)) {
            this.status = status;
        } else {
            // Potentially log or throw an error for invalid status
            System.err.println("Warning: Attempted to set invalid task status: " + status);
        }
    }

    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

// Manages the collection of tasks
class TaskScheduler {
    // Using LinkedList as a Queue implementation
    private Queue<Task> pendingTasks;
    // Using ArrayList as a List implementation
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // Required: Queue
        this.completedTasks = new ArrayList<>(); // Required: List (using ArrayList)
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasks.offer(task); // offer() is generally preferred over add() for queues
            System.out.println("Task added: " + task);
        } else {
             System.err.println("Cannot add a null task.");
        }
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the pending queue, updates its status,
     * and adds it to the completed tasks list.
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll() returns null if queue is empty

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed"); // Update status
            completedTasks.add(taskToProcess);    // Add to completed list
            System.out.println("Task completed: " + taskToProcess);
            return taskToProcess;
        } else {
            System.err.println("No tasks in the queue to process."); // Required: System.err
            return null;
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Note: This returns a new ArrayList copy to avoid external modification
     * of the internal queue structure during iteration.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns the list of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Can return direct reference as it's just a list for viewing/storage
    }
}

// Main application class handling user interaction
public class TaskSchedulerApp {

    private static TaskScheduler scheduler = new TaskScheduler();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Welcome to the Task Scheduler!");

        boolean running = true;
        // Class-wide exception handling (around the main application loop)
        try {
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Required: Switch statement
                switch (choice) {
                    case 1:
                        addTaskFromInput();
                        break;
                    case 2:
                        scheduler.processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Scheduler.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Required: System.err
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // General catch-all for unexpected errors in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("Task Scheduler Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles InputMismatchException.
     * @return The valid menu choice.
     */
    private static int getUserChoice() {
        int choice = -1;
        // Required: try-catch for input handling
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number."); // Required: System.err
            // Consume the invalid input to prevent infinite loop
            scanner.next();
        }
        // Consume the rest of the line after the integer
        scanner.nextLine();
        return choice;
    }

    /**
     * Prompts user for task details and adds a new task to the scheduler.
     * Handles input validation and exceptions.
     */
    private static void addTaskFromInput() {
        int id = -1;
        String description = null;

        // Required: try-catch for input handling
        try {
            System.out.print("Enter Task ID (integer): ");
            // Use hasNextLine and nextLine + parsing for robust integer input
            String idLine = scanner.nextLine();
            id = Integer.parseInt(idLine);

            System.out.print("Enter Task Description: ");
            description = scanner.nextLine();

            // Input validation handled by Task constructor
            Task newTask = new Task(id, description);
            scheduler.addTask(newTask);

        } catch (NumberFormatException e) {
            System.err.println("Invalid input for Task ID. Please enter a valid integer."); // Required: System.err
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating task: " + e.getMessage()); // Required: System.err
        } catch (Exception e) {
            // Catch any other unexpected errors during input
            System.err.println("An unexpected error occurred while adding task: " + e.getMessage()); // Required: System.err
            e.printStackTrace(System.err);
        }
    }

    /**
     * Displays all pending tasks to System.out.
     */
    private static void viewPendingTasks() {
        List<Task> pending = scheduler.getPendingTasks(); // Required: List interface
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            System.out.println("Pending Tasks:");
            for (Task task : pending) {
                System.out.println(task); // Task's toString() is used here
            }
        }
    }

    /**
     * Displays all completed tasks to System.out.
     */
    private static void viewCompletedTasks() {
        List<Task> completed = scheduler.getCompletedTasks(); // Required: List interface
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            System.out.println("Completed Tasks:");
            for (Task task : completed) {
                System.out.println(task); // Task's toString() is used here
            }
        }
    }
}
