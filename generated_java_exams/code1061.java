/*
 * Exam Question #1061
 * Generated on: 2025-05-12 17:19:36
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Automated Task Dispatch System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Automated Task Dispatch System. This system manages tasks that need to be processed in the order they are received. It should allow users to add new tasks, process the next available task, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task, automatically generated by the system.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (enum `Priority`): The priority level of the task (e.g., `LOW`, `MEDIUM`, `HIGH`).
 *     *   Implement a `toString()` method for easy printing of task details.
 *     *   Ensure proper encapsulation (private fields, public getters).
 * 
 * 2.  **Task Dispatch System:** Create a `TaskProcessingSystem` class responsible for managing tasks.
 *     *   It must use a `java.util.Queue` (specifically `java.util.LinkedList` which implements `Queue`) to store tasks that are pending processing. Tasks should be processed in FIFO (First-In, First-Out) order.
 *     *   It must use a `java.util.ArrayList` (declared as `java.util.List`) to store tasks that have been completed.
 *     *   Implement the following methods:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task` object with a unique ID and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, marks it as completed (you don't need a status field in `Task`, just move it to the completed list), and adds it to the completed tasks list. This method should handle the case where the pending queue is empty.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed tasks list.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of a separate class (e.g., `DispatchSystemApp`) that interacts with the `TaskProcessingSystem`.
 *     *   Use `java.util.Scanner` to read user commands and input.
 *     *   Present a menu of available commands: `ADD`, `PROCESS`, `VIEW_PENDING`, `VIEW_COMPLETED`, `EXIT`.
 *     *   Use a `switch` statement to handle different user commands.
 *     *   For the `ADD` command, prompt the user for the task description and priority. Validate the priority input (accepting "LOW", "MEDIUM", "HIGH" case-insensitively).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main command processing loop or relevant methods to gracefully handle potential issues such as:
 *         *   Attempting to process a task when the queue is empty.
 *         *   Invalid priority input when adding a task.
 *         *   Any other unexpected errors during input reading or processing.
 *     *   Use `System.err` to display error messages to the user.
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and task lists.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting commands, and providing feedback or displaying task lists. Error messages should be clearly indicated using `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Dispatch System Menu ---
 * ADD - Add a new task
 * PROCESS - Process the next task
 * VIEW_PENDING - View pending tasks
 * VIEW_COMPLETED - View completed tasks
 * EXIT - Exit the application
 * -----------------------------------
 * Enter command: ADD
 * Enter task description: Prepare report
 * Enter priority (LOW, MEDIUM, HIGH): HIGH
 * Task added: Task ID: 1, Description: Prepare report, Priority: HIGH
 * 
 * Enter command: ADD
 * Enter task description: Schedule meeting
 * Enter priority (low)
 * Task added: Task ID: 2, Description: Schedule meeting, Priority: LOW
 * 
 * Enter command: VIEW_PENDING
 * --- Pending Tasks ---
 * Task ID: 1, Description: Prepare report, Priority: HIGH
 * Task ID: 2, Description: Schedule meeting, Priority: LOW
 * ---------------------
 * 
 * Enter command: PROCESS
 * Processing task: Task ID: 1, Description: Prepare report, Priority: HIGH
 * Task completed.
 * 
 * Enter command: VIEW_PENDING
 * --- Pending Tasks ---
 * Task ID: 2, Description: Schedule meeting, Priority: LOW
 * ---------------------
 * 
 * Enter command: VIEW_COMPLETED
 * --- Completed Tasks ---
 * Task ID: 1, Description: Prepare report, Priority: HIGH
 * -----------------------
 * 
 * Enter command: PROCESS
 * Processing task: Task ID: 2, Description: Schedule meeting, Priority: LOW
 * Task completed.
 * 
 * Enter command: PROCESS
 * Error: No pending tasks to process.
 * 
 * Enter command: EXIT
 * Exiting Task Dispatch System.
 * ```
 * 
 * Your solution should provide the complete Java code for the `Priority` enum, `Task` class, `TaskProcessingSystem` class, and the main application class (`DispatchSystemApp`).
 *
 * EXPLANATION:
 * This solution implements the Automated Task Dispatch System as described in the problem. It effectively utilizes all the required Java components and demonstrates best practices.
 * 
 * 1.  **`Priority` Enum:** Defines the possible priority levels, providing a type-safe way to represent task priority. The `fromString` method adds a convenient way to parse user input into the enum, including case-insensitivity and basic validation.
 * 
 * 2.  **`Task` Class:** Represents a single task. It uses private fields (`taskId`, `description`, `priority`) and public getters, adhering to encapsulation principles. The constructor includes basic validation for description and priority. The `toString()` method provides a clean format for displaying task information.
 * 
 * 3.  **`TaskProcessingSystem` Class:** This is the core logic class.
 *     *   `pendingTasks`: A `Queue<Task>` implemented by `LinkedList` is used to store tasks awaiting processing. `LinkedList` is a common choice for implementing `Queue` when a doubly-linked list structure is suitable, and it naturally supports FIFO behavior.
 *     *   `completedTasks`: A `List<Task>` declared as `List` and instantiated as `ArrayList`. Using the `List` interface for the variable type is a good practice, promoting flexibility if you later decide to switch to a different `List` implementation (though `ArrayList` is appropriate here for storing a history). `ArrayList` provides dynamic resizing and easy access to completed tasks.
 *     *   `taskIdCounter`: A simple integer counter ensures each task gets a unique ID.
 *     *   `addTask`: Creates a `Task` object and uses `pendingTasks.offer()` to add it to the queue. `offer()` is generally preferred over `add()` for queues as it's designed for capacity-constrained queues (though `LinkedList` isn't), and it returns `false` instead of throwing an exception if the element cannot be added (which isn't an issue here but is good queue practice). Includes a `try-catch` around the `Task` constructor call to handle potential validation errors from the `Task` class itself.
 *     *   `processNextTask`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` is used because it returns `null` if the queue is empty, which is handled by throwing a `NoSuchElementException` (as required by the problem implicitly by asking to handle the empty queue case). The processed task is then added to the `completedTasks` list.
 *     *   `viewPendingTasks`: Iterates through the `pendingTasks` queue using a for-each loop. This allows viewing elements without removing them from the queue.
 *     *   `viewCompletedTasks`: Iterates through the `completedTasks` list using a for-each loop.
 * 
 * 4.  **`DispatchSystemApp` Class:** Contains the `main` method and the user interface logic.
 *     *   `Scanner`: Used to read input from `System.in`. Reading the entire line (`scanner.nextLine()`) for commands and input ensures that newline characters are consumed correctly, preventing issues in subsequent reads.
 *     *   `Switch Statement`: Handles the different command inputs (`ADD`, `PROCESS`, etc.) received from the user. The command is converted to uppercase for case-insensitive matching.
 *     *   **Class-wide Exception Handling (`try-catch`):** The main `while` loop that processes commands is wrapped in a `try-catch` block. This ensures that if an exception occurs during the execution of any command (e.g., `NoSuchElementException` from processing an empty queue, `IllegalArgumentException` from invalid priority input handled within the `ADD` case), the program doesn't crash but instead prints an error message to `System.err` and continues running, prompting for the next command. A general `catch (Exception e)` is included as a fallback for any unforeseen runtime errors.
 *     *   `System.err` and `System.out`: Used appropriately for error messages and normal output/prompts, respectively.
 *     *   Resource Management: The `Scanner` object is closed using `scanner.close()` when the program exits to release system resources.
 *     *   `printMenu()`: A helper method to keep the `main` method cleaner.
 * 
 * This solution effectively integrates the required data structures (`Queue`, `ArrayList`, `List`), control flow (`switch`), input/output (`Scanner`, `System.out`, `System.err`), and error handling (`try-catch`, specific exceptions) to create a functional and robust system, demonstrating an advanced understanding of core Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Specific exception for empty queue

// Enum for Task Priority
enum Priority {
    LOW, MEDIUM, HIGH;

    /**
     * Converts a string representation to a Priority enum.
     * Case-insensitive.
     * @param priorityStr The string representation of the priority.
     * @return The corresponding Priority enum.
     * @throws IllegalArgumentException if the string does not match any priority.
     */
    public static Priority fromString(String priorityStr) {
        if (priorityStr == null) {
            throw new IllegalArgumentException("Priority string cannot be null");
        }
        return Priority.valueOf(priorityStr.trim().toUpperCase());
    }
}

// Represents a single task in the system
class Task {
    private int taskId;
    private String description;
    private Priority priority;

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public Task(int taskId, String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
             throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
             throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation of the Task.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Priority: %s",
                             taskId, description, priority);
    }
}

// Manages the collection of pending and completed tasks
class TaskProcessingSystem {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList
    private int taskIdCounter; // Counter for unique task IDs

    /**
     * Constructs a new TaskProcessingSystem.
     */
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // Queue implemented by LinkedList
        this.completedTasks = new ArrayList<>(); // List implemented by ArrayList
        this.taskIdCounter = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String description, Priority priority) {
        try {
            Task newTask = new Task(taskIdCounter++, description, priority);
            pendingTasks.offer(newTask); // offer is preferred over add for queues as it doesn't throw exception on capacity issues (though LinkedList is unbounded)
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            // Catching validation errors from Task constructor
            System.err.println("Error adding task: " + e.getMessage());
             // Decrement counter if task creation failed after incrementing
            taskIdCounter--; // Rollback counter if task creation failed
        }
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * @throws NoSuchElementException if the pending queue is empty.
     */
    public void processNextTask() throws NoSuchElementException {
        Task taskToProcess = pendingTasks.poll(); // poll returns null if queue is empty

        if (taskToProcess == null) {
            throw new NoSuchElementException("No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            completedTasks.add(taskToProcess);
            System.out.println("Task completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate over the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

// Main application class with the command-line interface
public class DispatchSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        System.out.println("--- Welcome to the Automated Task Dispatch System ---");

        while (running) {
            printMenu();
            System.out.print("Enter command: ");
            String command = scanner.nextLine().trim().toUpperCase(); // Read command line

            // Class-wide exception handling for the command loop
            try {
                switch (command) {
                    case "ADD":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (LOW, MEDIUM, HIGH): ");
                        String priorityStr = scanner.nextLine();
                        try {
                            Priority priority = Priority.fromString(priorityStr);
                            system.addTask(description, priority);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: Invalid priority entered. Please use LOW, MEDIUM, or HIGH.");
                            // No need to call system.addTask here, as it's handled inside addTask's try-catch
                            // However, if Task constructor didn't validate, we would validate/catch here.
                            // Let's keep the validation in fromString and catch it here for robustness
                        }
                        break;

                    case "PROCESS":
                        system.processNextTask(); // processNextTask throws NoSuchElementException
                        break;

                    case "VIEW_PENDING":
                        system.viewPendingTasks();
                        break;

                    case "VIEW_COMPLETED":
                        system.viewCompletedTasks();
                        break;

                    case "EXIT":
                        running = false;
                        System.out.println("Exiting Task Dispatch System.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please try again.");
                        break;
                }
            } catch (NoSuchElementException e) {
                // Catching exceptions specifically from processNextTask when queue is empty
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catching any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner resource
        System.out.println("Goodbye!");
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Task Dispatch System Menu ---");
        System.out.println("ADD - Add a new task");
        System.out.println("PROCESS - Process the next task");
        System.out.println("VIEW_PENDING - View pending tasks");
        System.out.println("VIEW_COMPLETED - View completed tasks");
        System.out.println("EXIT - Exit the application");
        System.out.println("-----------------------------------");
    }
}
