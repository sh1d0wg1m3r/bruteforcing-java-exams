/*
 * Exam Question #725
 * Generated on: 2025-05-12 16:31:31
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line task management system for a small team. The system should allow users to add new tasks, process the next task in line, and view lists of pending and completed tasks. Tasks are processed in the order they are added (First-In, First-Out), but the system should be flexible enough to potentially handle different processing orders later (hence the use of a Queue). Completed tasks need to be stored for review.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a class named `Task`.
 *     *   Each `Task` object must have a unique integer ID and a String description.
 *     *   Use appropriate access modifiers (private fields, public getters).
 *     *   Include a `toString()` method to easily represent a task as a string (e.g., `[ID] Description`).
 * 
 * 2.  **Task Management Logic:**
 *     *   Create a class named `TaskManager`.
 *     *   This class will manage the collections of tasks.
 *     *   It must use a `java.util.Queue<Task>` to store pending tasks.
 *     *   It must use a `java.util.List<Task>` to store completed tasks. The concrete implementation for the `List` should be `java.util.ArrayList`.
 *     *   Use a `java.util.Scanner` to get user input from the console.
 *     *   Implement the following methods:
 *         *   `addTask()`: Prompts the user for a task description, creates a new `Task` object with a unique ID, and adds it to the pending tasks queue. Implement input validation to ensure the description is not empty.
 *         *   `processNextTask()`: Removes the task from the front of the pending tasks queue and adds it to the completed tasks list. If the queue is empty, display an appropriate error message.
 *         *   `listPendingTasks()`: Displays all tasks currently in the pending tasks queue. Indicate if the queue is empty.
 *         *   `listCompletedTasks()`: Displays all tasks currently in the completed tasks list. Indicate if the list is empty.
 *         *   `displayMenu()`: Prints the main menu options to the console.
 *         *   `run()`: Contains the main application loop. It should repeatedly display the menu, read the user's choice using `Scanner`, and use a `switch` statement to call the appropriate method based on the choice. The loop should continue until the user chooses to exit.
 * 
 * 3.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the task description (cannot be empty).
 *     *   Handle the case where the user tries to process a task when the pending queue is empty.
 *     *   Include a class-wide `try-catch` block within the `run()` method to catch potential unexpected exceptions during the application's execution. Also, handle specific input errors from `Scanner` (like non-integer input for menu choice) within the `run()` method's loop.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * Task Management System
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 0. Exit
 * Enter choice:
 * ```
 * 
 * Based on user input, it should perform the requested action and display relevant output, including error messages via `System.err` when applicable. Examples:
 * 
 * *   Adding a task:
 *     ```
 *     Enter task description: Write exam question
 *     Task added: [1] Write exam question
 *     ```
 * *   Listing pending tasks:
 *     ```
 *     --- Pending Tasks ---
 *     [1] Write exam question
 *     [2] Create solution code
 *     ---------------------
 *     ```
 * *   Processing a task:
 *     ```
 *     Processing task: [1] Write exam question
 *     Task [1] marked as completed.
 *     ```
 * *   Attempting to process with empty queue:
 *     ```
 *     Error: No pending tasks to process.
 *     ```
 * *   Listing completed tasks:
 *     ```
 *     --- Completed Tasks ---
 *     [1] Write exam question
 *     -----------------------
 *     ```
 * *   Invalid menu input:
 *     ```
 *     Error: Invalid input. Please enter a number.
 *     ```
 *     or
 *     ```
 *     Error: Invalid choice. Please try again.
 *     ```
 * 
 * You need to provide the complete Java code for the `Task` and `TaskManager` classes, including a `main` method to start the application.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A simple Plain Old Java Object (POJO) representing a task with `id` and `description`. It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class orchestrates the task management logic.
 *     *   **`Queue<Task> pendingTasks`:** A `java.util.Queue` is used to store tasks awaiting processing. The `LinkedList` class is used as a concrete implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for processing tasks in the order they are added. `offer()` is used for adding and `poll()` for removing, which are standard Queue operations.
 *     *   **`List<Task> completedTasks`:** A `java.util.List` is used to store tasks that have been processed. The `ArrayList` class is used as the concrete implementation, providing dynamic array capabilities for storing completed tasks in the order they are finished.
 *     *   **`Scanner scanner`:** An instance of `java.util.Scanner` is used to read user input from `System.in`. It's initialized in the constructor and closed in the `finally` block of the `run` method to release the system resource.
 *     *   **`switch` Statement:** The `run()` method uses a `switch` statement to control the flow of execution based on the user's menu choice, directing the program to call the appropriate method (`addTask`, `processNextTask`, etc.).
 *     *   **`System.out` and `System.err`:** `System.out` is used for standard messages like the menu, prompts, and lists of tasks. `System.err` is specifically used for printing error messages, making them distinguishable from normal output, which is a good practice for command-line applications.
 *     *   **Exception Handling (`try-catch`):**
 *         *   A class-wide `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This demonstrates catching unexpected exceptions that might occur during the execution of the program's core logic.
 *         *   An inner `try-catch(InputMismatchException e)` block is specifically used around the `scanner.nextInt()` call. This is crucial for handling cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt the user again. The `scanner.nextLine()` call within the catch block is essential to consume the invalid input and prevent an infinite loop.
 *     *   **Input Validation:** The `addTask()` method checks if the entered task description is empty or contains only whitespace (`trim().isEmpty()`) and prints an error to `System.err` if it's invalid.
 *     *   **Error Handling (Business Logic):** The `processNextTask()` method explicitly checks if the `pendingTasks` queue is empty using `pendingTasks.poll() == null`. If it is, an informative error message is printed to `System.err` instead of attempting an operation that would fail or throw an exception (like `remove()`).
 *     *   **Encapsulation:** Private fields (`pendingTasks`, `completedTasks`, `scanner`, `nextTaskId`) and public methods (`addTask`, `processNextTask`, etc.) are used in `TaskManager` to control access to the internal state.
 *     *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `nextTaskId`, `description`, `choice`) and methods (`addTask`, `processNextTask`, `listPendingTasks`, `displayMenu`, `run`) have names that clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific code logic.
 *     *   **Clean Code Structure:** The code is organized into separate classes (`Task`, `TaskManager`) with distinct responsibilities. Methods are relatively short and focused on a single task.
 *     *   **Resource Management:** The `finally` block in the `run()` method ensures that the `scanner` object is closed when the application finishes or exits due to an exception, releasing the underlying system resource.
 * 
 * This solution effectively combines various core and advanced Java concepts to solve a practical problem, demonstrating a solid understanding of data structures, control flow, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the task management system.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string [ID] Description.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + description;
    }
}

/**
 * Manages pending and completed tasks using a Queue and a List.
 */
class TaskManager {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a TaskManager. Initializes collections and scanner.
     */
    public TaskManager() {
        // Use LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task based on user input.
     * Prompts for description, validates, creates Task, adds to pending queue.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read line and trim whitespace

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if description is invalid
        }

        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues as it returns false on failure instead of throwing exception (though unlikely with LinkedList)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes task from queue, adds to completed list. Handles empty queue.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of this queue, or returns null if this queue is empty.

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            completedTasks.add(taskToProcess);
            System.out.println("Processing task: " + taskToProcess);
            System.out.println("Task [" + taskToProcess.getId() + "] marked as completed.");
        }
    }

    /**
     * Lists all tasks currently in the pending tasks queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all tasks currently in the completed tasks list.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\nTask Management System");
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("0. Exit");
    }

    /**
     * Runs the main application loop.
     * Displays menu, reads input, and performs actions using a switch statement.
     * Includes class-wide exception handling and specific input handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block to handle potential unexpected exceptions
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Try-catch for handling non-integer input specifically
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop body and show menu again
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        listPendingTasks();
                        break;
                    case 4:
                        listCompletedTasks();
                        break;
                    case 0:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please try again.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred during execution: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging output
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
