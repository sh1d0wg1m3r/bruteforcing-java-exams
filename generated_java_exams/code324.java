/*
 * Exam Question #324
 * Generated on: 2025-05-11 22:55:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Lab Equipment Request Management System
 * 
 * **Scenario:**
 * You are tasked with building a simple console-based system for managing requests for laboratory equipment. The system should allow lab personnel to add equipment, submit requests for equipment, process requests in the order they were received, and view the status of equipment and requests.
 * 
 * **Task:**
 * Implement a Java program that models this system. Your program should provide a menu-driven interface for user interaction and correctly manage the state of equipment and requests using appropriate data structures.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of available `Equipment` objects.
 *     *   Maintain a collection of pending `Request` objects, processed in a First-Come, First-Served (FCFS) manner.
 *     *   Maintain a collection of processed `Request` objects for historical tracking.
 * 
 * 2.  **Functionality:**
 *     *   **Add New Equipment:** Allow adding new equipment items with a unique ID and a name.
 *     *   **Submit Equipment Request:** Allow submitting a request for a specific piece of equipment by its ID. Requests should be added to the pending queue.
 *     *   **Process Next Request:** Take the oldest request from the pending queue, mark it as processed, and move it to the processed list.
 *     *   **View Available Equipment:** Display all equipment currently in the system.
 *     *   **View Pending Requests:** Display all requests currently in the pending queue.
 *     *   **View Processed Requests:** Display all requests that have been processed.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **Required Java Components:** Your solution MUST utilize ALL of the following:
 *     *   `java.util.Queue` (used as an interface type)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as an interface type)
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for implementing the menu navigation.
 *     *   `System.err` for displaying error messages (e.g., invalid input, equipment not found, queue empty).
 *     *   `System.out` for displaying the menu, prompts, normal output, and successful operation messages.
 *     *   Class-wide exception handling using `try-catch` blocks to manage potential runtime issues (e.g., `InputMismatchException` for non-integer input, or other unexpected errors).
 * 
 * 4.  **Best Practices:** Your code should demonstrate:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments or documentation explaining the purpose of classes, methods, and complex logic.
 *     *   Input validation (e.g., checking if requested equipment exists before submitting a request, handling non-numeric input gracefully).
 *     *   Robust error handling (displaying informative error messages using `System.err`).
 *     *   Clean and organized code structure (e.g., separate classes for entities, main logic in a dedicated class/method).
 * 
 * **Expected Output:**
 * The program should run as a console application. Upon starting, it should display a menu. The user selects an option by entering a number. The system then performs the requested action, providing feedback via `System.out` for success/information and `System.err` for errors. The menu should reappear after each action until the user chooses to exit.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * ```
 * --- Lab Management System Menu ---
 * 1. Add New Equipment
 * 2. Submit Equipment Request
 * 3. Process Next Request
 * 4. View Available Equipment
 * 5. View Pending Requests
 * 6. View Processed Requests
 * 7. Exit
 * Enter your choice: 1
 * Enter Equipment ID: 101
 * Enter Equipment Name: Microscope
 * Equipment added: ID=101, Name=Microscope
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 4
 * --- Available Equipment ---
 * Equipment [ID=101, Name=Microscope]
 * -------------------------
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 2
 * Enter Equipment ID to request: 101
 * Request submitted: Request [ID=1, EquipmentID=101, Status=Pending]
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 3
 * Request processed: Request [ID=1, EquipmentID=101, Status=Processed]
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 5
 * No pending requests.
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 6
 * --- Processed Requests ---
 * Request [ID=1, EquipmentID=101, Status=Processed]
 * ------------------------
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 7.
 * 
 * --- Lab Management System Menu ---
 * ...
 * Enter your choice: 7
 * Exiting Lab Management System. Goodbye!
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements the `Lab Management System` as requested, demonstrating the use of various core Java concepts and data structures.
 * 
 * **Class Structure:**
 * - `Equipment` class: A simple class representing a piece of equipment with an ID and a name. It uses private fields and public getter methods, adhering to encapsulation principles.
 * - `Request` class: Represents a request for equipment, containing a unique request ID, the ID of the requested equipment, and a status ("Pending" or "Processed"). It also follows encapsulation.
 * - `LabManagementSystem` class: This is the main class that orchestrates the system. It holds the collections (`List` and `Queue`) and contains the application logic, including the user interface (`run` method).
 * 
 * **Data Structures and Interfaces:**
 * - `java.util.List`: The `availableEquipment` and `processedRequests` collections are declared using the `List` interface. This promotes good practice by coding to the interface rather than the specific implementation (`ArrayList`). `ArrayList` is chosen as the concrete implementation for these lists because it provides efficient random access and dynamic resizing, which is suitable for storing and iterating over equipment and processed requests.
 * - `java.util.Queue`: The `pendingRequests` collection is declared using the `Queue` interface. This is crucial for implementing the First-Come, First-Served (FCFS) processing order. `LinkedList` is used as the concrete implementation because it efficiently supports adding elements to the end (`offer`) and removing elements from the beginning (`poll`), which are the primary operations for a queue.
 * 
 * **Core Functionality Implementation:**
 * - The `LabManagementSystem` class manages the state using the declared `List` and `Queue` fields.
 * - `addEquipment`, `submitRequest`, and `processNextRequest` methods encapsulate the logic for modifying these collections.
 * - `viewAvailableEquipment`, `viewPendingRequests`, and `viewProcessedRequests` methods iterate over the collections to display their contents using `System.out`. Iterating over the `Queue` (`pendingRequests`) is done using a for-each loop, which traverses the elements without removing them, as required for viewing.
 * 
 * **User Interface and Control Flow:**
 * - `java.util.Scanner`: An instance of `Scanner` is used to read integer and string input from the console (`System.in`) within the `run()` method.
 * - `displayMenu()`: A separate method is used to print the menu options to `System.out`, promoting code organization.
 * - `switch` statement: Inside the `run()` method's main loop, a `switch` statement is used to direct the program flow based on the user's integer input, calling the appropriate methods for each menu option.
 * 
 * **Error Handling and Validation:**
 * - `System.err`: Used exclusively for printing error messages, distinguishing them from normal output.
 * - Input Validation:
 *     - When submitting a request, the `submitRequest` method checks if the provided equipment ID exists in the `availableEquipment` list using the `findEquipmentById` helper method. An error message is printed to `System.err` if the equipment is not found.
 *     - When processing a request, the `processNextRequest` method checks if the `pendingRequests` queue is empty before attempting to `poll()`. An error is reported via `System.err` if the queue is empty.
 *     - The `addEquipment` method includes an optional check (implemented in the solution) to see if equipment with the same ID already exists, printing an error if it does.
 * - Class-wide `try-catch`: A `try-catch` block wraps the core logic inside the `while` loop in the `run()` method.
 *     - `catch (InputMismatchException e)`: This specific catch block handles cases where the user enters non-integer input when an integer is expected (e.g., for menu choice or equipment ID). It prints an informative error to `System.err` and consumes the invalid input from the `Scanner` to prevent an infinite loop.
 *     - `catch (Exception e)`: A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime exceptions that might occur during program execution, printing a generic error message to `System.err`.
 * 
 * **Best Practices:**
 * - **Encapsulation:** Private fields and public methods are consistently used across all classes.
 * - **Naming:** Variable and method names are descriptive (e.g., `availableEquipment`, `processNextRequest`, `findEquipmentById`).
 * - **Comments:** Javadoc-style comments are used for classes and methods, explaining their purpose. Inline comments explain specific logic points.
 * - **Clean Structure:** The code is divided into logical units (classes and methods), making it readable and maintainable. The main application loop is contained within the `run()` method, separating it from the `main` entry point. The `Scanner` is closed upon exiting the loop.
 * 
 * This solution effectively combines the required Java components and best practices to create a functional and robust system for managing lab equipment requests.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a piece of lab equipment.
 */
class Equipment {
    private int id;
    private String name;

    /**
     * Constructs a new Equipment object.
     * @param id The unique identifier for the equipment.
     * @param name The name of the equipment.
     */
    public Equipment(int id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * Gets the ID of the equipment.
     * @return The equipment ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the name of the equipment.
     * @return The equipment name.
     */
    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the Equipment object.
     * @return A formatted string representing the equipment.
     */
    @Override
    public String toString() {
        return "Equipment [ID=" + id + ", Name=" + name + "]";
    }
}

/**
 * Represents a request for a piece of lab equipment.
 */
class Request {
    private int requestId;
    private int equipmentId;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Request object.
     * @param requestId The unique identifier for the request.
     * @param equipmentId The ID of the equipment being requested.
     */
    public Request(int requestId, int equipmentId) {
        this.requestId = requestId;
        this.equipmentId = equipmentId;
        this.status = "Pending"; // Initial status
    }

    /**
     * Gets the ID of the request.
     * @return The request ID.
     */
    public int getRequestId() {
        return requestId;
    }

    /**
     * Gets the ID of the requested equipment.
     * @return The equipment ID.
     */
    public int getEquipmentId() {
        return equipmentId;
    }

    /**
     * Gets the current status of the request.
     * @return The request status ("Pending" or "Processed").
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the request.
     * @param status The new status for the request.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Request object.
     * @return A formatted string representing the request.
     */
    @Override
    public String toString() {
        return "Request [ID=" + requestId + ", EquipmentID=" + equipmentId + ", Status=" + status + "]";
    }
}

/**
 * Manages the lab equipment and requests.
 * This class contains the main application logic and user interface.
 */
public class LabManagementSystem {

    // List to store all available equipment
    private List<Equipment> availableEquipment;
    // Queue to store pending requests (FCFS)
    private Queue<Request> pendingRequests;
    // List to store processed requests
    private List<Request> processedRequests;
    // Scanner for reading user input
    private Scanner scanner;
    // Counter for generating unique request IDs
    private int nextRequestId;

    /**
     * Constructs a new LabManagementSystem, initializing collections and scanner.
     */
    public LabManagementSystem() {
        // Use ArrayList for lists as it provides dynamic array implementation
        availableEquipment = new ArrayList<>();
        processedRequests = new ArrayList<>();
        // Use LinkedList as it implements the Queue interface and is efficient for additions/removals at ends
        pendingRequests = new LinkedList<>();
        scanner = new Scanner(System.in);
        nextRequestId = 1; // Start request IDs from 1
    }

    /**
     * Helper method to find an equipment by its ID.
     * @param id The ID of the equipment to find.
     * @return The Equipment object if found, null otherwise.
     */
    private Equipment findEquipmentById(int id) {
        for (Equipment eq : availableEquipment) {
            if (eq.getId() == id) {
                return eq;
            }
        }
        return null; // Equipment not found
    }

    /**
     * Adds a new equipment to the system.
     * Performs basic validation to prevent duplicate IDs.
     * @param id The ID of the equipment.
     * @param name The name of the equipment.
     */
    public void addEquipment(int id, String name) {
        // Input validation: Check if equipment with same ID already exists
        if (findEquipmentById(id) != null) {
             System.err.println("Error: Equipment with ID " + id + " already exists. Cannot add.");
             return;
        }
        availableEquipment.add(new Equipment(id, name));
        System.out.println("Success: Equipment added: ID=" + id + ", Name=" + name);
    }

    /**
     * Submits a new request for equipment.
     * Validates if the requested equipment exists.
     * @param equipmentId The ID of the equipment being requested.
     */
    public void submitRequest(int equipmentId) {
        // Input validation: Check if the equipment exists in the system
        if (findEquipmentById(equipmentId) == null) {
            System.err.println("Error: Equipment with ID " + equipmentId + " not found. Cannot submit request.");
            return;
        }

        // Create a new request and add it to the pending queue
        Request newRequest = new Request(nextRequestId++, equipmentId);
        pendingRequests.offer(newRequest); // offer() is preferred over add() for queues
        System.out.println("Success: Request submitted: " + newRequest);
    }

    /**
     * Processes the next request in the pending queue (FCFS).
     * Handles the case where the queue is empty.
     */
    public void processNextRequest() {
        // Check if there are any pending requests
        if (pendingRequests.isEmpty()) {
            System.err.println("Error: No pending requests to process.");
            return;
        }

        // Get and remove the head of the queue
        Request processed = pendingRequests.poll(); // poll() removes and returns the head
        processed.setStatus("Processed"); // Update the status
        processedRequests.add(processed); // Move to the processed list
        System.out.println("Success: Request processed: " + processed);
    }

    /**
     * Displays all available equipment in the system.
     */
    public void viewAvailableEquipment() {
        if (availableEquipment.isEmpty()) {
            System.out.println("No equipment available in the system.");
            return;
        }
        System.out.println("\n--- Available Equipment ---");
        // Iterate through the List and print each equipment
        for (Equipment eq : availableEquipment) {
            System.out.println(eq);
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays all pending requests in the queue.
     */
    public void viewPendingRequests() {
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
            return;
        }
        System.out.println("\n--- Pending Requests ---");
        // Iterate through the Queue without removing elements
        for (Request req : pendingRequests) {
             System.out.println(req);
        }
        System.out.println("------------------------");
    }

     /**
     * Displays all processed requests.
     */
     public void viewProcessedRequests() {
        if (processedRequests.isEmpty()) {
            System.out.println("No requests have been processed yet.");
            return;
        }
        System.out.println("\n--- Processed Requests ---");
        // Iterate through the List and print each processed request
        for (Request req : processedRequests) {
            System.out.println(req);
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    public void displayMenu() {
        System.out.println("\n--- Lab Management System Menu ---");
        System.out.println("1. Add New Equipment");
        System.out.println("2. Submit Equipment Request");
        System.out.println("3. Process Next Request");
        System.out.println("4. View Available Equipment");
        System.out.println("5. View Pending Requests");
        System.out.println("6. View Processed Requests");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu navigation.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Main application loop
        while (running) {
            displayMenu();
            // Use a try-catch block to handle potential exceptions during input and processing
            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt() to prevent issues with nextLine()
                scanner.nextLine();

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        // Add New Equipment
                        System.out.print("Enter Equipment ID (integer): ");
                        int eqId = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        System.out.print("Enter Equipment Name: ");
                        String eqName = scanner.nextLine();
                        addEquipment(eqId, eqName);
                        break;
                    case 2:
                        // Submit Equipment Request
                        System.out.print("Enter Equipment ID to request (integer): ");
                        int reqEqId = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        submitRequest(reqEqId);
                        break;
                    case 3:
                        // Process Next Request
                        processNextRequest();
                        break;
                    case 4:
                        // View Available Equipment
                        viewAvailableEquipment();
                        break;
                    case 5:
                        // View Pending Requests
                        viewPendingRequests();
                        break;
                    case 6:
                        // View Processed Requests
                        viewProcessedRequests();
                        break;
                    case 7:
                        // Exit
                        System.out.println("Exiting Lab Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input specifically
                System.err.println("Invalid input. Please enter a valid integer for the choice or ID.");
                scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // For debugging, you might uncomment the line below:
                // e.printStackTrace();
            }
        }
        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * The main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        LabManagementSystem system = new LabManagementSystem();
        system.run();
    }
}
