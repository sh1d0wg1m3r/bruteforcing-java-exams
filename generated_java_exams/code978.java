/*
 * Exam Question #978
 * Generated on: 2025-05-12 17:08:04
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Workshop Waitlist Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple application to manage attendees and a waitlist for a popular programming workshop with a limited capacity. People can join a waitlist if the workshop is full. When a spot becomes available, the next person on the waitlist is automatically moved to the list of confirmed attendees.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this workshop management system. The program should present a menu to the user allowing them to interact with the system.
 * 
 * **Specific Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the waitlist (First-In, First-Out).
 *     *   Use a `java.util.List` (implemented by `java.util.ArrayList`) to store the confirmed attendees.
 *     *   Define a fixed maximum capacity for the workshop attendees.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu with options:
 *         1.  Add a person to the waitlist.
 *         2.  Process the next person from the waitlist (move to attendees if capacity allows).
 *         3.  View the current waitlist.
 *         4.  View the current attendees.
 *         5.  Exit.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use a loop to keep the program running until the user chooses to exit.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, confirmations, and lists of people.
 *     *   Use `System.err` for displaying error messages (e.g., waitlist empty, invalid input, name cannot be empty).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation (e.g., check if the menu choice is valid, check if a name is entered).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors, especially related to input processing.
 * 
 * 6.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public/private methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic comments explaining logic are sufficient for this exam).
 *     *   Ensure a clean code structure.
 * 
 * **Implementation Details:**
 * 
 * *   The `processNextFromWaitlist` operation should check if the attendees list has reached maximum capacity *before* attempting to move someone. If capacity is full, inform the user. If not full and the waitlist is not empty, remove the person from the waitlist and add them to the attendees list. Handle the case where the waitlist is empty.
 * *   Set a small, reasonable maximum capacity (e.g., 5-10) for testing.
 * 
 * **Expected Output Structure:**
 * 
 * The program should display a menu, prompt for input, and based on the input, perform the action, print results to `System.out` or errors to `System.err`, and then display the menu again until the user exits.
 * 
 * ```
 * --- Workshop Waitlist Manager ---
 * Choose an action:
 * 1. Add person to waitlist
 * 2. Process next person from waitlist (if space available)
 * 3. View waitlist
 * 4. View attendees
 * 5. Exit
 * Enter your choice: [User Input]
 * [Output based on action - confirmation, list, or error message]
 * 
 * [Repeat Menu]
 * ```
 * 
 * Your solution should be a single Java file containing the complete program.
 *
 * EXPLANATION:
 * This solution implements the `WorkshopManager` class to simulate the workshop waitlist system as described.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The `WorkshopManager` class encapsulates all the data (`waitlist`, `attendees`, `maxCapacity`, `scanner`) and operations related to managing the workshop.
 *     *   Fields are declared as `private` to enforce encapsulation.
 *     *   Methods are declared as `public` (`startManager`, `main`) or `private` (`displayMenu`, `addToWaitlist`, `processNextFromWaitlist`, `viewWaitlist`, `viewAttendees`) based on whether they are part of the public interface or internal helpers.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `private Queue<String> waitlist;`: Declared using the `Queue` interface, implemented using `java.util.LinkedList`. `LinkedList` is a common choice for implementing `Queue` as it provides efficient add/remove operations at both ends. The `waitlist` stores names (`String`) in FIFO order. `add()` is used to add to the tail, and `poll()` is used to remove from the head.
 *     *   `private List<String> attendees;`: Declared using the `List` interface, implemented using `java.util.ArrayList`. `ArrayList` is suitable for storing the confirmed attendees where indexed access and iteration are common. `add()` is used to add attendees.
 *     *   `private final int maxCapacity;`: A constant field defining the maximum number of attendees.
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`Switch`, Loop):**
 *     *   `private Scanner scanner;`: An instance of `Scanner` is used to read input from `System.in`. It's initialized in the constructor and closed in the `finally` block to release system resources.
 *     *   The `startManager` method contains the main application loop (`while (choice != 5)`).
 *     *   Inside the loop, `displayMenu()` shows options, and `scanner.nextLine()` reads the user's input.
 *     *   The input string is parsed into an integer. A `try-catch (NumberFormatException)` block specifically handles cases where the user enters non-numeric input for the menu choice, printing an error to `System.err` and allowing the loop to continue.
 *     *   A `switch` statement is used to direct execution based on the valid integer choice, calling the appropriate private method for each action. The `default` case handles invalid numeric inputs outside the 1-5 range.
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, successful operations, and the contents of the waitlist and attendees lists.
 *     *   `System.err.println()` is used exclusively for printing error messages, such as validation failures (empty name) or logical errors (waitlist empty for processing, invalid menu input).
 * 
 * 5.  **Error Handling (`try-catch`) and Input Validation:**
 *     *   **Class-wide `try-catch`:** The main `while` loop in `startManager` is wrapped in a `try-catch (Exception e)` block. This provides a safety net for any unhandled runtime exceptions that might occur within the loop, printing an error message to `System.err` before the program potentially terminates or exits the loop.
 *     *   **Specific `try-catch`:** A `try-catch (NumberFormatException)` is used around `Integer.parseInt(inputLine)` to specifically handle non-integer input for the menu choice.
 *     *   **Input Validation:**
 *         *   In `startManager`, it checks if `inputLine` is empty or just whitespace before attempting to parse.
 *         *   In `addToWaitlist`, it checks if the entered `name` is empty after trimming whitespace. An error is printed to `System.err`, and the method returns early if invalid.
 *     *   **Logical Error Handling:**
 *         *   `processNextFromWaitlist` checks if the `waitlist` is empty and prints an error to `System.err` if so.
 *         *   `processNextFromWaitlist` checks if `attendees.size() >= maxCapacity` and informs the user via `System.out` if the workshop is full, preventing the addition.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names like `waitlist`, `attendees`, `maxCapacity`, `addToWaitlist`, `processNextFromWaitlist` improve code readability.
 *     *   Basic comments explain the purpose of the class, constructor, and key methods.
 *     *   The code is structured into logical methods, making it modular.
 *     *   The `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * The solution effectively combines the required Java components (`Queue`, `List`, `ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) in a practical scenario, demonstrating understanding of data structures, control flow, basic I/O, and error handling principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages attendees and a waitlist for a limited-capacity workshop.
 */
public class WorkshopManager {

    // Using LinkedList as an implementation of Queue for the waitlist
    private Queue<String> waitlist;
    // Using ArrayList as an implementation of List for attendees
    private List<String> attendees;
    private final int maxCapacity;
    private Scanner scanner;

    /**
     * Constructs a WorkshopManager with a specified maximum capacity.
     * @param maxCapacity The maximum number of attendees allowed in the workshop.
     */
    public WorkshopManager(int maxCapacity) {
        if (maxCapacity <= 0) {
            // Basic validation for capacity
            System.err.println("Warning: Maximum capacity must be positive. Setting to default 10.");
            this.maxCapacity = 10;
        } else {
            this.maxCapacity = maxCapacity;
        }
        this.waitlist = new LinkedList<>();
        this.attendees = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void startManager() {
        System.out.println("--- Workshop Waitlist Manager ---");
        int choice = -1;

        try { // Class-wide exception handling for the main loop
            while (choice != 5) {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Use nextLine to read the whole line and handle potential InputMismatchException
                String inputLine = scanner.nextLine();
                if (inputLine.trim().isEmpty()) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration
                }

                try {
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input format. Please enter a number (1-5).");
                    continue; // Skip to the next iteration, asking for input again
                }

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        addToWaitlist();
                        break;
                    case 2:
                        processNextFromWaitlist();
                        break;
                    case 3:
                        viewWaitlist();
                        break;
                    case 4:
                        viewAttendees();
                        break;
                    case 5:
                        System.out.println("Exiting Workshop Waitlist Manager. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed when the program exits or an unexpected error occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Add person to waitlist");
        System.out.println("2. Process next person from waitlist (if space available)");
        System.out.println("3. View waitlist");
        System.out.println("4. View attendees");
        System.out.println("5. Exit");
    }

    /**
     * Prompts the user for a name and adds it to the waitlist.
     * Includes input validation for the name.
     */
    private void addToWaitlist() {
        System.out.print("Enter name to add to waitlist: ");
        String name = scanner.nextLine().trim(); // Read name and remove leading/trailing whitespace

        if (name.isEmpty()) {
            System.err.println("Error: Name cannot be empty.");
            return; // Exit the method if name is invalid
        }

        waitlist.add(name); // Add the name to the end of the queue
        System.out.println(name + " added to the waitlist.");
    }

    /**
     * Attempts to move the next person from the waitlist to the attendees list.
     * Checks if the waitlist is empty or if the workshop is at maximum capacity.
     */
    private void processNextFromWaitlist() {
        if (waitlist.isEmpty()) {
            System.err.println("Waitlist is currently empty. No one to process.");
            return; // Exit if waitlist is empty
        }

        if (attendees.size() >= maxCapacity) {
            System.out.println("Workshop is already at full capacity (" + maxCapacity + "). Cannot add more attendees from the waitlist.");
            // Optionally, peek at the next person without removing them:
            // System.out.println("Next person on waitlist: " + waitlist.peek());
            return; // Exit if capacity is full
        }

        // If waitlist is not empty AND capacity is available
        String nextPerson = waitlist.poll(); // Remove the head of the queue
        attendees.add(nextPerson); // Add the person to the attendees list

        System.out.println(nextPerson + " has been moved from the waitlist to the attendees list.");
        System.out.println("Current attendees: " + attendees.size() + "/" + maxCapacity);
    }

    /**
     * Displays the current list of people on the waitlist.
     */
    private void viewWaitlist() {
        System.out.println("--- Current Waitlist (" + waitlist.size() + " people) ---");
        if (waitlist.isEmpty()) {
            System.out.println("Waitlist is empty.");
        } else {
            // Iterate through the queue elements without removing them
            int i = 1;
            for (String person : waitlist) {
                System.out.println(i++ + ". " + person);
            }
        }
        System.out.println("----------------------------------");
    }

    /**
     * Displays the current list of confirmed attendees.
     */
    private void viewAttendees() {
        System.out.println("--- Current Attendees (" + attendees.size() + "/" + maxCapacity + ") ---");
        if (attendees.isEmpty()) {
            System.out.println("Attendees list is empty.");
        } else {
            // Iterate through the list elements
            for (int i = 0; i < attendees.size(); i++) {
                System.out.println((i + 1) + ". " + attendees.get(i));
            }
        }
        System.out.println("----------------------------------");
    }

    /**
     * The main method to start the Workshop Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Set a small capacity for testing purposes
        int capacity = 5;
        WorkshopManager manager = new WorkshopManager(capacity);
        manager.startManager();
    }
}
