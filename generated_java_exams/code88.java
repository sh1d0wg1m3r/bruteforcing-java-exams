/*
 * Exam Question #88
 * Generated on: 2025-05-11 22:12:06
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified hospital appointment scheduling system. The system should manage a waiting list of patients, a list of available doctor time slots, and a list of scheduled appointments. Patients arrive and are added to a waiting queue. When a scheduling action is performed, the next patient from the waiting queue is assigned the earliest available time slot.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Core Data Structures:**
 *     *   Use a `java.util.Queue` (specifically, an implementation like `LinkedList`) to represent the **patient waiting list**. Patients should be processed in the order they check in (FIFO).
 *     *   Use a `java.util.ArrayList` to store the **scheduled appointments**.
 *     *   Use the `java.util.List` interface (e.g., implemented by `ArrayList`) to manage a list of **available doctor time slots**.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Check-in Patient
 *         2.  Schedule Next Appointment
 *         3.  View Waiting Queue
 *         4.  View Scheduled Appointments
 *         5.  Exit
 *     *   Use a `switch` statement to process the user's menu choice.
 * 
 * 3.  **Functionality:**
 *     *   **Check-in Patient:** Prompt the user for the patient's name and add them to the waiting queue.
 *     *   **Schedule Next Appointment:**
 *         *   Check if the waiting queue is empty. If so, display an error message.
 *         *   Check if there are any available slots. If so, display an error message.
 *         *   If both queue and slots are available:
 *             *   Remove the next patient from the queue.
 *             *   Remove the *first* available slot from the list of slots.
 *             *   Create a new appointment record linking the patient and the slot.
 *             *   Add the appointment record to the list of scheduled appointments.
 *             *   Display a success message showing the scheduled appointment details.
 *     *   **View Waiting Queue:** Display the names of all patients currently in the waiting queue, in order.
 *     *   **View Scheduled Appointments:** Display the details of all scheduled appointments.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.err.println()` to display error messages (e.g., invalid menu input, queue empty, no slots available).
 *     *   Use `System.out.println()` for all other output (menu, prompts, success messages, list contents).
 *     *   Implement **input validation** for the menu choice (ensure it's a number and within the valid range). Handle `InputMismatchException` from the `Scanner`.
 *     *   Implement **class-wide exception handling** using a `try-catch` block to catch any unexpected runtime exceptions that might occur during program execution.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure your code into logical methods and classes (e.g., a main class `HospitalScheduler` and simple data classes like `Patient` and `Appointment`).
 * 
 * **Initial State:**
 * 
 * The system should start with an initial set of available time slots. For example:
 * `["Dr. Smith - 9:00 AM", "Dr. Smith - 9:30 AM", "Dr. Jones - 10:00 AM", "Dr. Jones - 10:30 AM", "Dr. Lee - 11:00 AM"]`
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, taking input, and showing results or errors based on the user's actions. Examples:
 * 
 * *   Displaying the menu.
 * *   Prompting for patient name.
 * *   Confirming patient check-in.
 * *   Displaying error if scheduling fails (empty queue/slots).
 * *   Confirming a successful scheduling action.
 * *   Listing patients in the queue.
 * *   Listing scheduled appointments.
 * *   Handling invalid input gracefully.
 * *   Displaying a generic error message for unexpected exceptions via `System.err`.
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided Java code implements a simplified Hospital Appointment Scheduler system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Scenario and Structure:**
 *     *   The system simulates managing a patient waiting list, available time slots, and scheduled appointments.
 *     *   The code is structured into a main `HospitalScheduler` class and two simple data classes, `Patient` and `Appointment`, promoting modularity and encapsulation.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `waitingQueue` is declared as a `Queue<Patient>` and initialized with a `LinkedList`. Patients are added using `offer()` (FIFO) and removed using `poll()` when scheduling.
 *     *   `java.util.ArrayList`: The `scheduledAppointments` list is declared and initialized as an `ArrayList<Appointment>`. Scheduled appointments are added using `add()`. It's also used internally to initialize the `availableSlots`.
 *     *   `java.util.List interface`: The `availableSlots` list is declared using the `List<String>` interface and initialized with an `ArrayList`. Slots are removed from the list using `remove(0)` when an appointment is scheduled.
 *     *   `java.util.Scanner`: A `Scanner` object is used in the `main` method and passed to the `run` method to read user input for menu choices and patient names.
 *     *   `switch statement`: A `switch` statement in the `run` method processes the user's integer input for the menu selection, directing execution to the appropriate method (`checkInPatient`, `scheduleAppointment`, etc.).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu input, attempting to schedule with an empty queue, or attempting to schedule with no available slots. This distinguishes error output from standard program output.
 *     *   `System.out`: Used for all standard output, including displaying the menu, prompts for input, success messages after operations, and listing the contents of the queue and scheduled appointments.
 *     *   **Class-wide exception handling with try-catch:**
 *         *   A large `try-catch (Exception e)` block is placed in the `main` method, wrapping the core application logic (`scheduler.run(scanner)`). This serves as a safety net to catch any unexpected `RuntimeException` or other `Exception` that might occur anywhere within the program's execution flow that isn't handled by more specific `try-catch` blocks.
 *         *   Additionally, a `try-catch (InputMismatchException e)` is used within the `run` method's loop when reading the menu choice. This specifically handles non-integer input from the user, preventing the program from crashing and allowing the user to try again. A general `catch (Exception e)` is also included within the loop in `run` to catch other potential issues during an operation.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Class fields (`waitingQueue`, `availableSlots`, `scheduledAppointments`, and fields in `Patient`/`Appointment`) are declared `private`. Access and modification are done through public methods (`checkInPatient`, `scheduleAppointment`, `getName`, etc.).
 *     *   **Meaningful Names:** Variable names (`waitingQueue`, `availableSlots`, `patientToSchedule`, `slotToAssign`), method names (`checkInPatient`, `scheduleAppointment`, `viewWaitingQueue`, `displayMenu`), and class names (`HospitalScheduler`, `Patient`, `Appointment`) are descriptive of their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods explaining their purpose. Inline comments clarify specific logic where needed.
 *     *   **Input Validation:** The code explicitly checks for valid menu input (integer within range) using a `try-catch` block for `InputMismatchException` and a `default` case in the `switch`. It also performs a basic check for empty patient name input.
 *     *   **Error Handling:** Specific error conditions (empty queue, no available slots) are checked *before* attempting operations, and informative error messages are printed to `System.err`. The `try-catch` blocks handle potential exceptions during input or execution.
 *     *   **Clean Code Structure:** The logic is broken down into small, single-purpose methods (`displayMenu`, `checkInPatient`, etc.), making the code easier to read, understand, and maintain. The `run` method orchestrates the main application flow. The use of try-with-resources for the `Scanner` in `main` ensures it's closed properly.
 * 
 * This solution effectively integrates the required Java components into a practical application, demonstrating understanding of collection types, control flow, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Arrays;

// Represents a patient in the waiting queue
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a scheduled appointment
class Appointment {
    private String patientName;
    private String slotDetails;

    public Appointment(String patientName, String slotDetails) {
        this.patientName = patientName;
        this.slotDetails = slotDetails;
    }

    public String getPatientName() {
        return patientName;
    }

    public String getSlotDetails() {
        return slotDetails;
    }

    @Override
    public String toString() {
        return "Appointment [Patient: " + patientName + ", Slot: " + slotDetails + "]";
    }
}

/**
 * Hospital Appointment Scheduling System
 * Manages patient check-ins, available slots, and scheduled appointments.
 */
public class HospitalScheduler {

    // Queue for patients waiting for an appointment
    private Queue<Patient> waitingQueue;

    // List for available doctor time slots
    private List<String> availableSlots;

    // ArrayList for scheduled appointments
    private ArrayList<Appointment> scheduledAppointments;

    /**
     * Constructor to initialize the scheduler with initial available slots.
     */
    public HospitalScheduler() {
        // Using LinkedList as the Queue implementation
        this.waitingQueue = new LinkedList<>();

        // Initializing available slots using ArrayList and assigning to List interface
        this.availableSlots = new ArrayList<>(Arrays.asList(
                "Dr. Smith - 9:00 AM",
                "Dr. Smith - 9:30 AM",
                "Dr. Jones - 10:00 AM",
                "Dr. Jones - 10:30 AM",
                "Dr. Lee - 11:00 AM"
        ));

        // Initializing the ArrayList for scheduled appointments
        this.scheduledAppointments = new ArrayList<>();
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment Scheduler ---");
        System.out.println("1. Check-in Patient");
        System.out.println("2. Schedule Next Appointment");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Scheduled Appointments");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the patient check-in process.
     * Prompts for patient name and adds them to the waiting queue.
     * @param scanner Scanner object for reading input.
     */
    private void checkInPatient(Scanner scanner) {
        System.out.print("Enter patient name: ");
        // Consume the newline character left by previous nextInt() or similar
        if (scanner.hasNextLine()) {
             scanner.nextLine();
        }
        String patientName = scanner.nextLine();

        if (patientName == null || patientName.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }

        Patient newPatient = new Patient(patientName);
        waitingQueue.offer(newPatient); // Add to the end of the queue
        System.out.println(patientName + " checked in and added to the waiting queue.");
    }

    /**
     * Schedules the next appointment by taking the next patient from the queue
     * and the first available slot from the list.
     */
    private void scheduleAppointment() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting queue is empty. Cannot schedule.");
            return;
        }

        if (availableSlots.isEmpty()) {
            System.err.println("Error: No available time slots. Cannot schedule.");
            return;
        }

        // Get the next patient from the queue (and remove)
        Patient patientToSchedule = waitingQueue.poll();

        // Get the first available slot from the list (and remove)
        String slotToAssign = availableSlots.remove(0);

        // Create and add the new appointment
        Appointment newAppointment = new Appointment(patientToSchedule.getName(), slotToAssign);
        scheduledAppointments.add(newAppointment); // Add to the ArrayList

        System.out.println("Successfully scheduled: " + newAppointment);
    }

    /**
     * Displays the current patients in the waiting queue.
     */
    private void viewWaitingQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Patient patient : waitingQueue) {
                System.out.println(i++ + ". " + patient.getName());
            }
        }
    }

    /**
     * Displays the list of scheduled appointments.
     */
    private void viewScheduledAppointments() {
        System.out.println("\n--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            // Iterate through the ArrayList
            for (int i = 0; i < scheduledAppointments.size(); i++) {
                System.out.println((i + 1) + ". " + scheduledAppointments.get(i));
            }
        }
    }

    /**
     * Runs the main application loop, handling user input and menu navigation.
     * @param scanner Scanner object for reading input.
     */
    public void run(Scanner scanner) {
        int choice = -1;
        while (choice != 5) {
            displayMenu();

            try {
                choice = scanner.nextInt();

                switch (choice) {
                    case 1:
                        checkInPatient(scanner);
                        break;
                    case 2:
                        scheduleAppointment();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewScheduledAppointments();
                        break;
                    case 5:
                        System.out.println("Exiting Hospital Scheduler. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions within the loop
                 System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                 // Optional: e.printStackTrace();
            }
        }
    }

    /**
     * Main method to start the application.
     * Includes the class-wide exception handling block.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Class-wide exception handling block
        try (Scanner scanner = new Scanner(System.in)) {
            HospitalScheduler scheduler = new HospitalScheduler();
            scheduler.run(scanner);
        } catch (Exception e) {
            // This catches any exception not handled elsewhere, including potential issues
            // with Scanner initialization or closing if not using try-with-resources
            System.err.println("\n--- An unhandled application error occurred ---");
            System.err.println("Error details: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
            System.err.println("The application will now exit.");
        }
    }
}
