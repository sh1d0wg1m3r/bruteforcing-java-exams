/*
 * Exam Question #756
 * Generated on: 2025-05-12 16:36:23
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Resource Scheduler System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to manage and schedule tasks that require specific IT resources. The system should allow users to add new tasks to a processing queue, process the next task in line, view the current tasks awaiting processing, and view tasks that have been completed.
 * 
 * **System Requirements:**
 * 
 * 1.  **Resources:** A predefined list of available IT resources (e.g., "Server_A", "License_X", "Storage_Z"). These resources are not actively managed for availability state in this simplified version, but tasks must specify which ones they *would* require.
 * 2.  **Tasks:** Each task must have:
 *     *   A unique integer ID.
 *     *   A description (String).
 *     *   A list of resource names (Strings) it requires.
 * 3.  **Task Management:**
 *     *   Tasks are added to a **queue** for processing in First-In, First-Out (FIFO) order.
 *     *   The system should allow processing the task at the front of the queue. Processing a task simulates its completion and removes it from the queue, moving it to a list of completed tasks.
 * 4.  **User Interface:** The application must provide a simple command-line menu for interaction using `Scanner`.
 * 5.  **Output:** Display system status, task details, and results of operations using `System.out`. Report errors and invalid inputs using `System.err`.
 * 6.  **Error Handling:** Implement robust input validation and handle potential runtime errors using `try-catch` blocks.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate advanced Java understanding by utilizing **ALL** of the following components:
 * 
 * *   `java.util.Queue` (specifically, an implementation like `LinkedList`) for managing the task queue.
 * *   `java.util.ArrayList` for storing lists of resources and completed tasks.
 * *   `java.util.List` interface (used for declaring variables that hold `ArrayList` instances).
 * *   `java.util.Scanner` for reading user input from the console.
 * *   `switch` statement for handling the main menu options.
 * *   `System.err` for outputting error messages.
 * *   `System.out` for outputting normal program information (menu, prompts, task details, status).
 * *   Class-wide exception handling using a `try-catch` block surrounding the main operational loop.
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation for the `Task` class (private fields, public getters).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes).
 * *   Validate user input thoroughly.
 * *   Structure the code cleanly.
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Task
 * 2.  Process Next Task
 * 3.  View Pending Tasks
 * 4.  View Completed Tasks
 * 5.  Exit
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Resource Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Setup new server
 * Enter required resources (comma-separated, e.g., Server_A,License_X): Server_A,License_X,License_Y
 * Task added: ID 1 - Setup new server [Requires: Server_A, License_X, License_Y]
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: ID 1 - Setup new server
 * Task ID 1 completed and removed from queue.
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks (Queue):
 * Queue is empty.
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * ID 1 - Setup new server [Required: Server_A, License_X, License_Y]
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Resource Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Resource Scheduler.
 * ```
 * 
 * Implement the `Task` class and the main `ResourceScheduler` class with the `main` method to fulfill all requirements.
 *
 * EXPLANATION:
 * This solution implements the `ResourceScheduler` system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and a `List` of `requiredResources`.
 *     *   Uses `private` fields and `public` getters to ensure proper encapsulation.
 *     *   The constructor and getter for `requiredResources` create defensive copies using `new ArrayList<>(...)` to prevent external modification of the internal list state.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`ResourceScheduler` Class:**
 *     *   **Data Structures:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, suitable for FIFO operations (`offer` to add, `poll` to remove from head).
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is used here as a dynamic list to store completed tasks for viewing.
 *         *   `allAvailableResources`: Declared as `List<String>` and initialized with `new ArrayList<>(Arrays.asList(...))`. This `ArrayList` holds the predefined resource names.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read input from `System.in`. It's a class-level field so it can be used across different methods and is closed in the `finally` block.
 *     *   **`nextTaskId`:** An integer to generate unique IDs for new tasks.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addNewTask()`:**
 *         *   Prompts the user for description and required resources.
 *         *   Performs basic input validation: checks if description is empty and if at least one resource is specified. Uses `System.err` for validation errors.
 *         *   Splits the comma-separated resource input string.
 *         *   Creates a new `Task` object with the next ID.
 *         *   Adds the new task to the `taskQueue` using `offer()`.
 *         *   Prints a confirmation message to `System.out`.
 *     *   **`processNextTask()`:**
 *         *   Checks if the `taskQueue` is empty. If so, prints an error to `System.err`.
 *         *   If not empty, retrieves and removes the head of the queue using `poll()`.
 *         *   Prints messages to `System.out` simulating the processing and completion.
 *         *   Adds the processed task to the `completedTasks` `ArrayList`.
 *     *   **`viewPendingTasks()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the `taskQueue` is empty.
 *         *   If not empty, iterates through the `taskQueue` using a for-each loop. This iterates without removing elements, as required for viewing. Prints each task's details to `System.out`.
 *     *   **`viewCompletedTasks()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the `completedTasks` list is empty.
 *         *   If not empty, iterates through the `ArrayList` and prints each completed task's details to `System.out`.
 *     *   **`run()`:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   **Class-wide Exception Handling:** The entire loop and method calls within it are wrapped in a `try-catch(Exception e)` block. This catches any unexpected runtime exceptions that might occur during the program's execution and prints an error message and stack trace to `System.err`.
 *         *   Displays the menu, reads user input.
 *         *   **Input Validation:** Uses a nested `try-catch(NumberFormatException)` to validate that the user's menu choice is a valid integer. If not, it prints an error to `System.err` and continues the loop.
 *         *   **`switch` Statement:** Controls the flow of execution based on the valid integer choice, calling the appropriate method for each option.
 *         *   `default` case in the `switch` handles integer inputs outside the valid menu range (1-5), printing an error to `System.err`.
 *         *   **`finally` Block:** Ensures the `scanner` resource is closed when the `try` or `catch` block finishes, preventing resource leaks.
 *     *   **`main()`:** The entry point of the application. Creates an instance of `ResourceScheduler` and calls its `run()` method.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrates essential programming practices like encapsulation, input validation, and structured error handling using `try-catch` and directing output to `System.out` and `System.err`.
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task requiring specific resources.
 */
class Task {
    private int id;
    private String description;
    private List<String> requiredResources;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param requiredResources A list of resource names required by the task.
     */
    public Task(int id, String description, List<String> requiredResources) {
        this.id = id;
        this.description = description;
        this.requiredResources = new ArrayList<>(requiredResources); // Create a defensive copy
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public List<String> getRequiredResources() {
        return new ArrayList<>(requiredResources); // Return a defensive copy
    }

    @Override
    public String toString() {
        return String.format("ID %d - %s [Required: %s]",
                id, description, String.join(", ", requiredResources));
    }
}

/**
 * Manages a queue of tasks requiring resources.
 */
public class ResourceScheduler {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private List<String> allAvailableResources; // List of known resources (not tracking availability state)
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new ResourceScheduler.
     */
    public ResourceScheduler() {
        taskQueue = new LinkedList<>(); // Using LinkedList as a Queue implementation
        completedTasks = new ArrayList<>(); // Using ArrayList for completed tasks
        // Predefined list of available resources
        allAvailableResources = new ArrayList<>(Arrays.asList(
                "Server_A", "Server_B", "License_X", "License_Y", "Storage_Z", "Network_Device_1"
        ));
        nextTaskId = 1;
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Resource Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the queue based on user input.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        System.out.print("Enter required resources (comma-separated, e.g., Server_A,License_X): ");
        String resourcesInput = scanner.nextLine().trim();

        List<String> requiredResources = new ArrayList<>();
        if (!resourcesInput.isEmpty()) {
            String[] resourceNames = resourcesInput.split(",");
            for (String resourceName : resourceNames) {
                String trimmedName = resourceName.trim();
                if (!trimmedName.isEmpty()) {
                    // Optional: Validate if resource exists in allAvailableResources list
                    // For this problem, we just add whatever the user types, but a real system
                    // might check against a valid list. Let's add a warning for non-listed resources.
                     if (!allAvailableResources.contains(trimmedName)) {
                         System.err.println("Warning: Resource '" + trimmedName + "' is not in the known list of available resources.");
                     }
                    requiredResources.add(trimmedName);
                }
            }
        }

        if (requiredResources.isEmpty()) {
             System.err.println("Error: Task must require at least one resource.");
             return;
        }

        Task newTask = new Task(nextTaskId++, description, requiredResources);
        taskQueue.offer(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task at the front of the queue.
     */
    private void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        Task nextTask = taskQueue.poll(); // Get and remove the head of the queue
        System.out.println("Processing task: " + nextTask.getDescription());
        // Simulate resource allocation/processing logic here if needed
        // In this simplified version, we just move it to completed

        completedTasks.add(nextTask); // Add to the list of completed tasks
        System.out.println("Task ID " + nextTask.getId() + " completed and removed from queue.");
    }

    /**
     * Displays all tasks currently in the processing queue.
     */
    private void viewPendingTasks() {
        System.out.println("\nPending Tasks (Queue):");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that have been processed and completed.
     */
    private void viewCompletedTasks() {
        System.out.println("\nCompleted Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for unexpected errors
        try {
            while (running) {
                displayMenu();
                String choiceInput = scanner.nextLine().trim();
                int choice;

                // Input validation for menu choice
                try {
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    continue; // Go back to the start of the loop
                }

                // Switch statement for menu control
                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Resource Scheduler.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed regardless of how the program exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }

    /**
     * Main method to start the Resource Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ResourceScheduler scheduler = new ResourceScheduler();
        scheduler.run();
    }
}
