/*
 * Exam Question #1064
 * Generated on: 2025-05-12 17:20:04
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Build Request Management
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified system to manage software build requests. Build requests are submitted by developers and are processed sequentially by a simulated build server. The system needs to keep track of pending requests and completed builds.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features:
 * 
 * 1.  **BuildRequest Class:**
 *     *   Create a class named `BuildRequest` to represent a single build request.
 *     *   It should have private fields: `int requestId` and `String moduleName`.
 *     *   Provide a constructor to initialize these fields.
 *     *   Provide public getter methods for both fields.
 *     *   Override the `toString()` method to provide a clear string representation of a build request (e.g., "Request ID: [id], Module: [name]").
 * 
 * 2.  **BuildQueueManager Class:**
 *     *   Create a class named `BuildQueueManager` that orchestrates the system.
 *     *   It must have private fields:
 *         *   A `Queue<BuildRequest>` to hold pending build requests. Use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *         *   A `List<BuildRequest>` to hold completed build requests. Use `java.util.ArrayList` as the concrete implementation for the `List`.
 *         *   An integer counter for generating unique request IDs.
 *     *   Provide a public constructor to initialize the queue, list, and request ID counter.
 *     *   Implement the following public methods:
 *         *   `submitRequest(String moduleName)`: Adds a new `BuildRequest` to the pending queue. Assigns a unique ID using the internal counter. Increments the counter. Validates that the `moduleName` is not empty or null. If invalid, print an error to `System.err` and do not add the request.
 *         *   `processNextRequest()`: Removes the next request from the front of the pending queue and adds it to the completed list. If the queue is empty, it should indicate this error using `System.err` and not perform any action.
 *         *   `viewPendingRequests()`: Prints all requests currently in the pending queue to `System.out`. If the queue is empty, print a message indicating this.
 *         *   `viewCompletedRequests()`: Prints all requests currently in the completed list to `System.out`. If the list is empty, print a message indicating this.
 *         *   `run()`: This method contains the main application loop.
 *             *   It should use `java.util.Scanner` to read user input from the console.
 *             *   It should display a menu of options:
 *                 1.  Submit Build Request
 *                 2.  Process Next Request
 *                 3.  View Pending Requests
 *                 4.  View Completed Requests
 *                 5.  Exit
 *             *   It should read the user's choice.
 *             *   It must use a `switch` statement to handle the different menu options, calling the appropriate methods (`submitRequest`, `processNextRequest`, etc.).
 *             *   The loop should continue until the user chooses to exit.
 *             *   Implement class-wide exception handling using `try-catch` blocks within the `run` method to gracefully handle potential issues such as:
 *                 *   Invalid integer input for the menu choice (`InputMismatchException`).
 *                 *   Any other unexpected runtime errors (`Exception`).
 *             *   Error messages caught by `try-catch` should be printed to `System.err`.
 * 
 * 3.  **Main Method:**
 *     *   Include a `main` method in a separate class (e.g., `BuildSystemApp`) or within `BuildQueueManager` to create an instance of `BuildQueueManager` and call its `run()` method to start the application.
 * 
 * **General Requirements:**
 * 
 * *   Use appropriate Java standard library classes (`java.util.*`).
 * *   Adhere to Java coding best practices:
 *     *   Meaningful variable and method names.
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Add comments where necessary to explain complex logic.
 *     *   Ensure proper input validation as specified.
 *     *   Handle errors gracefully using `System.err` and `try-catch`.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, and printing system status (queue/list contents) or error messages based on user actions. Example interaction:
 * 
 * ```
 * --- Build Request Management System ---
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 1
 * Enter module name: Core
 * Build request submitted: Request ID: 1, Module: Core
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 1
 * Enter module name: UI
 * Build request submitted: Request ID: 2, Module: UI
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 3
 * --- Pending Requests ---
 * Request ID: 1, Module: Core
 * Request ID: 2, Module: UI
 * ------------------------
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 2
 * Processing next request...
 * Request processed: Request ID: 1, Module: Core
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 4
 * --- Completed Requests ---
 * Request ID: 1, Module: Core
 * --------------------------
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 2
 * Processing next request...
 * Request processed: Request ID: 2, Module: UI
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 2
 * Processing next request...
 * Error: Cannot process request. The pending queue is empty.
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Choose an option:
 * 1. Submit Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter choice: 5
 * Exiting Build Request Management System.
 * ```
 * 
 * Your solution must provide the complete, runnable Java code.
 *
 * EXPLANATION:
 * The provided solution implements a simple Build Request Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`BuildRequest` Class:**
 *     *   This class serves as a simple data structure to hold the details of a build request (`requestId` and `moduleName`).
 *     *   It uses `private` fields and public getter methods, adhering to encapsulation principles.
 *     *   The `toString()` method is overridden to provide a user-friendly representation when a `BuildRequest` object is printed.
 * 
 * 2.  **`BuildQueueManager` Class:**
 *     *   This is the core class managing the system state.
 *     *   It uses a `Queue<BuildRequest>` named `pendingRequests` (implemented with `LinkedList`) to store requests in a FIFO (First-In, First-Out) manner, which is natural for a processing queue.
 *     *   It uses a `List<BuildRequest>` named `completedRequests` (implemented with `ArrayList`) to store requests after they have been processed. An `ArrayList` is suitable here as we might need to iterate or access completed requests, and insertion/deletion performance at the ends or iterating is efficient. Declaring it as `List` uses the interface type, promoting flexibility.
 *     *   `nextRequestId` is a private counter ensuring each request gets a unique ID.
 *     *   **`submitRequest(String moduleName)`:**
 *         *   Takes a `moduleName` as input.
 *         *   Includes basic input validation to check if the name is empty or null. If invalid, it prints an error to `System.err` and returns early.
 *         *   Creates a new `BuildRequest` object with the next available ID.
 *         *   Uses `pendingRequests.offer(request)` to add the request to the tail of the queue. `offer()` is standard for queues and handles potential capacity issues gracefully (though `LinkedList` is unbounded).
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextRequest()`:**
 *         *   Uses `pendingRequests.poll()` to retrieve and remove the element at the head of the queue. `poll()` is suitable as it returns `null` if the queue is empty, allowing for easy checking without throwing an exception like `remove()`.
 *         *   Checks if the result of `poll()` is `null`. If it is, it means the queue was empty, and an error message is printed to `System.err`.
 *         *   If a request is retrieved, it is added to the `completedRequests` list using `completedRequests.add()`.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewPendingRequests()` and `viewCompletedRequests()`:**
 *         *   These methods iterate through the respective collections (`Queue` and `List`).
 *         *   They check if the collections are empty and print an appropriate message.
 *         *   They print the string representation of each `BuildRequest` (using the overridden `toString()` method) to `System.out`. Iterating over a `Queue` using a for-each loop is safe; it does not remove elements.
 *     *   **`run()`:**
 *         *   This method contains the main application loop controlled by a `while` loop that continues until the user chooses option 5 (Exit).
 *         *   A `Scanner` is used to read user input. The `try-with-resources` block is typically used for `Scanner` to ensure it's closed, but here a `finally` block is used to ensure `scanner.close()` is called even if exceptions occur, demonstrating another pattern.
 *         *   Inside the `while` loop, a `try-catch` block wraps the core logic (reading choice, the `switch` statement). This block is designed for **class-wide exception handling** within the execution flow.
 *         *   It specifically catches `InputMismatchException` which occurs if the user enters non-integer input when prompted for the menu choice. It prints an error to `System.err` and consumes the invalid input from the scanner buffer (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   It also catches a general `Exception` to handle any other unexpected runtime errors that might occur during the processing of a command. This demonstrates catching broader exceptions.
 *         *   A `switch` statement is used to direct the program flow based on the user's valid integer choice, calling the corresponding methods.
 *         *   The `default` case in the `switch` handles invalid integer choices (numbers outside 1-5), printing an error to `System.err`.
 *         *   `System.out.println()` is used for displaying the menu, prompts, and successful operation messages. `System.err.println()` is used exclusively for error messages.
 * 
 * 3.  **`BuildSystemApp` Class:**
 *     *   This class contains the `main` method, the entry point of the application.
 *     *   It creates an instance of `BuildQueueManager` and calls its `run()` method to start the interactive system.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), follows best practices like encapsulation and input validation, and provides a clear structure for a practical simulation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single build request
class BuildRequest {
    private int requestId;
    private String moduleName;

    /**
     * Constructs a new BuildRequest.
     * @param requestId The unique ID for the request.
     * @param moduleName The name of the software module to build.
     */
    public BuildRequest(int requestId, String moduleName) {
        this.requestId = requestId;
        this.moduleName = moduleName;
    }

    /**
     * Gets the request ID.
     * @return The request ID.
     */
    public int getRequestId() {
        return requestId;
    }

    /**
     * Gets the module name.
     * @return The module name.
     */
    public String getModuleName() {
        return moduleName;
    }

    /**
     * Provides a string representation of the BuildRequest.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Request ID: " + requestId + ", Module: " + moduleName;
    }
}

// Manages the queue of build requests and completed builds
class BuildQueueManager {
    private Queue<BuildRequest> pendingRequests;
    private List<BuildRequest> completedRequests;
    private int nextRequestId;

    /**
     * Constructs a new BuildQueueManager.
     */
    public BuildQueueManager() {
        this.pendingRequests = new LinkedList<>(); // Use LinkedList as Queue implementation
        this.completedRequests = new ArrayList<>(); // Use ArrayList as List implementation
        this.nextRequestId = 1; // Start request IDs from 1
    }

    /**
     * Submits a new build request to the pending queue.
     * @param moduleName The name of the module for the build request.
     */
    public void submitRequest(String moduleName) {
        // Input validation: module name cannot be null or empty
        if (moduleName == null || moduleName.trim().isEmpty()) {
            System.err.println("Error: Module name cannot be empty.");
            return;
        }

        BuildRequest request = new BuildRequest(nextRequestId++, moduleName.trim());
        pendingRequests.offer(request); // offer() is preferred for queues, returns false on failure (rare for LinkedList)
        System.out.println("Build request submitted: " + request);
    }

    /**
     * Processes the next build request from the pending queue.
     * Moves the request to the completed list.
     */
    public void processNextRequest() {
        System.out.println("Processing next request...");
        // Check if the queue is empty before attempting to poll
        BuildRequest requestToProcess = pendingRequests.poll(); // poll() retrieves and removes the head, returns null if empty

        if (requestToProcess != null) {
            completedRequests.add(requestToProcess);
            System.out.println("Request processed: " + requestToProcess);
        } else {
            System.err.println("Error: Cannot process request. The pending queue is empty.");
        }
    }

    /**
     * Displays all pending build requests.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (BuildRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Displays all completed build requests.
     */
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            // Iterate through the list
            for (BuildRequest request : completedRequests) {
                System.out.println(request);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = null; // Declare scanner outside try-with-resources for finally block message
        try {
            scanner = new Scanner(System.in);
            int choice = -1;

            System.out.println("--- Build Request Management System ---");

            while (choice != 5) {
                displayMenu();

                // Use try-catch specifically for reading integer choice
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter module name: ");
                            String moduleName = scanner.nextLine();
                            submitRequest(moduleName);
                            break;
                        case 2:
                            processNextRequest();
                            break;
                        case 3:
                            viewPendingRequests();
                            break;
                        case 4:
                            viewCompletedRequests();
                            break;
                        case 5:
                            System.out.println("Exiting Build Request Management System.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the loop iteration
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally, print stack trace for debugging: e.printStackTrace();
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
            // Ensure scanner is closed if it was successfully created
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("Choose an option:");
        System.out.println("1. Submit Build Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
    }
}

// Main application class
public class BuildSystemApp {
    public static void main(String[] args) {
        BuildQueueManager manager = new BuildQueueManager();
        manager.run(); // Start the application loop
    }
}
