/*
 * Exam Question #117
 * Generated on: 2025-05-11 22:16:46
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line application for managing appointments at a small hospital. The system needs to handle two types of appointment states: *pending* appointments (appointments that have been requested but not yet confirmed) and *scheduled* appointments (appointments that are confirmed and finalized).
 * 
 * Your application should allow users to perform the following actions:
 * 1.  **Schedule a New Appointment:** Collect patient name, doctor name, and desired time slot. The newly created appointment should be placed into a queue of *pending* appointments.
 * 2.  **Confirm Pending Appointment:** Take the oldest appointment from the *pending* queue and move it to the list of *scheduled* appointments.
 * 3.  **View Scheduled Appointments:** Display all appointments currently in the *scheduled* list.
 * 4.  **Cancel Scheduled Appointment:** Allow the user to cancel an appointment from the *scheduled* list by providing the patient's name and time slot.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical constraints:
 * 
 * *   Use `java.util.Queue` to store *pending* appointments.
 * *   Use `java.util.ArrayList` to store *scheduled* appointments. Declare the variable using the `java.util.List` interface.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.err` to print error messages (e.g., invalid input, appointment not found, no pending appointments).
 * *   Use `System.out` to print normal output (menu, prompts, successful operations, appointment details).
 * *   Implement class-wide exception handling using `try-catch` blocks within the main application loop to gracefully handle potential runtime errors during user interaction or processing.
 * *   Design the solution using appropriate classes (at least one class for the appointment details and one main class for the scheduler logic).
 * *   Follow best practices:
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include basic input validation (e.g., check if input strings are empty).
 *     *   Add comments to explain complex parts of the code.
 *     *   Provide clear and informative messages to the user.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu to the user. Based on the user's choice, it should perform the corresponding action, print success/failure messages, or display the requested information. Error messages should go to `System.err`, while regular output goes to `System.out`.
 * 
 * Example Interaction Flow (Illustrative):
 * 
 * ```
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter doctor name: Dr. Smith
 * Enter time slot (e.g., 10:00 AM): 10:00 AM
 * Appointment for Alice at 10:00 AM is pending confirmation.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 2
 * Confirming pending appointment...
 * Appointment for Alice at 10:00 AM confirmed and scheduled.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 3
 * --- Scheduled Appointments ---
 * Patient: Alice, Doctor: Dr. Smith, Time: 10:00 AM
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 4
 * Enter patient name to cancel: Alice
 * Enter time slot to cancel: 10:00 AM
 * Appointment for Alice at 10:00 AM cancelled successfully.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 3
 * --- Scheduled Appointments ---
 * No scheduled appointments found.
 * 
 * --- Hospital Appointment Scheduler ---
 * 1. Schedule New Appointment
 * 2. Confirm Pending Appointment
 * 3. View Scheduled Appointments
 * 4. Cancel Scheduled Appointment
 * 5. Exit
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * **Note:** Focus on demonstrating the required Java concepts and a clear, well-structured design. Simplifications (like using String for time, no complex scheduling conflicts) are acceptable for the scope of this exam task.
 * 
 * **Grading Criteria:** Correct usage of all required components, adherence to best practices, logical flow, proper error handling, clear output, and code structure.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment management system using the required Java components and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingAppointments` field is declared as a `Queue<Appointment>` and initialized with `LinkedList`. `LinkedList` is used because it implements both `Queue` and `List` interfaces, making it suitable for queue operations. The `offer()` method is used to add new appointments to the end of the queue, and `poll()` is used to retrieve and remove the head of the queue (the oldest pending appointment) for confirmation. This correctly models a waiting line or processing queue.
 * 2.  **`java.util.ArrayList` and `java.util.List`:** The `scheduledAppointments` field is declared using the `List<Appointment>` interface and initialized with `ArrayList<Appointment>`. This demonstrates polymorphism and the use of the common `List` interface for managing a dynamic collection of scheduled appointments. `ArrayList` provides efficient storage and retrieval by index, suitable for listing and searching scheduled items.
 * 3.  **`java.util.Scanner`:** A `Scanner` object is used to read user input from `System.in` for menu choices and appointment details. `nextLine()` is used consistently to read full lines, simplifying input handling.
 * 4.  **`switch` statement:** A `switch` statement in the `run()` method is used to control the program flow based on the user's integer menu choice, directing execution to the appropriate method (`scheduleNewAppointment`, `confirmPendingAppointment`, etc.).
 * 5.  **`System.err`:** Error messages, such as invalid input, attempts to confirm when no appointments are pending, or failure to find an appointment for cancellation, are printed to `System.err`. This distinguishes error output from normal program messages which go to `System.out`.
 * 6.  **`System.out`:** Normal program output, including the menu, prompts, success messages, and the list of scheduled appointments, is printed to `System.out`.
 * 7.  **Class-wide `try-catch`:** The main application loop within the `run()` method is wrapped in a `try-catch` block. This demonstrates handling potential exceptions that might occur during input parsing (`NumberFormatException`) or other unexpected runtime issues, preventing the program from crashing abruptly. Specific catch blocks handle known issues (`NumberFormatException`), and a general `Exception` catch block handles others, printing an error message to `System.err`.
 * 8.  **Custom Class (`Appointment`):** A separate `Appointment` class is created to encapsulate the data related to a single appointment (patient name, doctor name, time slot). This promotes modularity and data organization.
 * 9.  **Encapsulation:** Fields in both `Appointment` and `HospitalScheduler` are declared as `private`, and access is provided through public methods (`getters` in `Appointment`). This protects the internal state of the objects.
 * 10. **Meaningful Names:** Variable names (`pendingAppointments`, `scheduledAppointments`, `patientName`, `timeSlot`) and method names (`scheduleNewAppointment`, `confirmPendingAppointment`, `viewScheduledAppointments`) are descriptive, making the code easier to understand.
 * 11. **Input Validation:** Basic validation is performed in `scheduleNewAppointment` and `cancelScheduledAppointment` to check if required input strings are empty after trimming whitespace. An error message is printed to `System.err` if validation fails.
 * 12. **Error Handling:** Specific scenarios like an empty pending queue or a non-existent appointment during cancellation are checked, and informative error messages are printed to `System.err`.
 * 13. **Clean Code Structure:** The code is organized into two classes with distinct responsibilities. Methods are kept relatively short and focused on a single task. Comments explain the purpose of classes and methods, and inline comments clarify specific logic (like using the Iterator for safe removal).
 * 14. **Iterator for Safe Removal:** In `cancelScheduledAppointment`, an `Iterator` is used to loop through the `scheduledAppointments` list. This is the correct and safe way to remove elements from a collection while iterating over it, avoiding `ConcurrentModificationException`.
 * 15. **Resource Management:** The `Scanner` is closed when the application exits (`choice == 5`) to release system resources.
 * 
 * This solution effectively combines several core and advanced Java concepts to build a functional, albeit simplified, application, demonstrating a solid understanding of data structures, object-oriented principles, and robust programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration

/**
 * Represents a single hospital appointment.
 */
class Appointment {
    private String patientName;
    private String doctorName;
    private String timeSlot;

    /**
     * Constructs a new Appointment object.
     * @param patientName The name of the patient.
     * @param doctorName The name of the doctor.
     * @param timeSlot The time slot for the appointment (e.g., "10:00 AM").
     */
    public Appointment(String patientName, String doctorName, String timeSlot) {
        this.patientName = patientName;
        this.doctorName = doctorName;
        this.timeSlot = timeSlot;
    }

    // --- Getters ---
    public String getPatientName() {
        return patientName;
    }

    public String getDoctorName() {
        return doctorName;
    }

    public String getTimeSlot() {
        return timeSlot;
    }

    /**
     * Provides a string representation of the appointment.
     * @return A formatted string describing the appointment.
     */
    @Override
    public String toString() {
        return "Patient: " + patientName + ", Doctor: " + doctorName + ", Time: " + timeSlot;
    }

    /**
     * Checks if this appointment matches another based on patient name and time slot.
     * Useful for cancellation.
     * @param otherPatientName The patient name to match.
     * @param otherTimeSlot The time slot to match.
     * @return true if the patient name and time slot match, false otherwise.
     */
    public boolean matches(String otherPatientName, String otherTimeSlot) {
        // Basic validation before comparison
        if (otherPatientName == null || otherTimeSlot == null) {
            return false;
        }
        return this.patientName.equalsIgnoreCase(otherPatientName.trim()) &&
               this.timeSlot.equalsIgnoreCase(otherTimeSlot.trim());
    }
}

/**
 * Manages the hospital appointment scheduling system.
 */
public class HospitalScheduler {
    // Using LinkedList as it implements both Queue and List, fitting the Queue requirement
    private Queue<Appointment> pendingAppointments;
    // Using ArrayList explicitly as required, declared with List interface
    private List<Appointment> scheduledAppointments;
    private Scanner scanner;

    /**
     * Constructs a new HospitalScheduler.
     * Initializes the pending queue, scheduled list, and scanner.
     */
    public HospitalScheduler() {
        this.pendingAppointments = new LinkedList<>(); // LinkedList for Queue functionality
        this.scheduledAppointments = new ArrayList<>(); // ArrayList for List functionality
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment Scheduler ---");
        System.out.println("1. Schedule New Appointment");
        System.out.println("2. Confirm Pending Appointment");
        System.out.println("3. View Scheduled Appointments");
        System.out.println("4. Cancel Scheduled Appointment");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Schedules a new appointment by collecting user input and adding it to the pending queue.
     * Handles basic input validation.
     */
    private void scheduleNewAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine().trim();
        System.out.print("Enter doctor name: ");
        String doctorName = scanner.nextLine().trim();
        System.out.print("Enter time slot (e.g., 10:00 AM): ");
        String timeSlot = scanner.nextLine().trim();

        // Input validation
        if (patientName.isEmpty() || doctorName.isEmpty() || timeSlot.isEmpty()) {
            System.err.println("Error: All fields (patient, doctor, time) must be filled.");
            return; // Exit method if input is invalid
        }

        Appointment newAppointment = new Appointment(patientName, doctorName, timeSlot);
        pendingAppointments.offer(newAppointment); // Add to the end of the queue
        System.out.println("Appointment for " + patientName + " at " + timeSlot + " is pending confirmation.");
    }

    /**
     * Confirms the oldest pending appointment by moving it from the pending queue
     * to the scheduled list.
     * Handles the case where there are no pending appointments.
     */
    private void confirmPendingAppointment() {
        System.out.println("Confirming pending appointment...");
        Appointment confirmedAppointment = pendingAppointments.poll(); // Retrieve and remove head of queue

        if (confirmedAppointment != null) {
            scheduledAppointments.add(confirmedAppointment); // Add to the end of the list
            System.out.println("Appointment for " + confirmedAppointment.getPatientName() +
                               " at " + confirmedAppointment.getTimeSlot() + " confirmed and scheduled.");
        } else {
            System.err.println("Error: No pending appointments to confirm.");
        }
    }

    /**
     * Displays all appointments currently in the scheduled list.
     * Handles the case where the scheduled list is empty.
     */
    private void viewScheduledAppointments() {
        System.out.println("--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No scheduled appointments found.");
        } else {
            // Iterate through the List and print each appointment
            for (Appointment appt : scheduledAppointments) {
                System.out.println(appt); // Uses Appointment's toString() method
            }
        }
    }

    /**
     * Cancels a scheduled appointment based on patient name and time slot.
     * Handles input validation and the case where the appointment is not found.
     */
    private void cancelScheduledAppointment() {
        System.out.print("Enter patient name to cancel: ");
        String patientName = scanner.nextLine().trim();
        System.out.print("Enter time slot to cancel: ");
        String timeSlot = scanner.nextLine().trim();

        // Input validation
        if (patientName.isEmpty() || timeSlot.isEmpty()) {
            System.err.println("Error: Patient name and time slot are required to cancel.");
            return; // Exit method if input is invalid
        }

        boolean removed = false;
        // Use Iterator for safe removal while iterating
        Iterator<Appointment> iterator = scheduledAppointments.iterator();
        while (iterator.hasNext()) {
            Appointment appointment = iterator.next();
            // Use the matches method for comparison
            if (appointment.matches(patientName, timeSlot)) {
                iterator.remove(); // Safely remove the current element
                System.out.println("Appointment for " + patientName + " at " + timeSlot + " cancelled successfully.");
                removed = true;
                break; // Exit loop once found and removed
            }
        }

        if (!removed) {
            System.err.println("Error: No scheduled appointment found for patient '" + patientName + "' at time '" + timeSlot + "'.");
        }
    }

    /**
     * Runs the main application loop, handling user input and menu navigation.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Read choice, handle potential non-integer input
                String input = scanner.nextLine();
                choice = Integer.parseInt(input);

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        scheduleNewAppointment();
                        break;
                    case 2:
                        confirmPendingAppointment();
                        break;
                    case 3:
                        viewScheduledAppointments();
                        break;
                    case 4:
                        cancelScheduledAppointment();
                        break;
                    case 5:
                        System.out.println("Exiting scheduler.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch error if input is not a valid integer
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions during operation
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * The main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run(); // Start the main application loop
    }
}
