/*
 * Exam Question #505
 * Generated on: 2025-05-11 23:21:35
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * **Objective:** Implement a simple console-based Task Management System that allows users to add, complete, and view tasks. This task requires you to demonstrate proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You need to build a basic system for managing personal or work tasks. Tasks have a description, a priority, and a status. New tasks are added to a queue of pending tasks. When a task is completed, it is moved from the pending queue to a history list.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following properties:
 *     *   `description` (String): A brief description of the task. Must not be empty.
 *     *   `priority` (Enum or String): Represents the urgency, limited to "HIGH", "MEDIUM", "LOW".
 *     *   `status` (Enum or String): Represents the current state, limited to "PENDING" or "COMPLETED".
 *     *   Implement a constructor, appropriate getters, and a method to update the status. Include a `toString()` method for easy display.
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class that manages the tasks. It should contain:
 *     *   A `Queue<Task>` to hold tasks that are pending completion. Use a concrete implementation like `LinkedList`.
 *     *   A `List<Task>` to hold tasks that have been completed. Use a concrete implementation like `ArrayList`.
 *     *   A `Scanner` object for reading user input.
 *     *   Methods for the following operations:
 *         *   `addTask()`: Prompts the user for task description and priority, creates a `Task` object, and adds it to the pending tasks queue. Validate input for description (not empty) and priority (must be one of the valid values).
 *         *   `completeNextTask()`: Removes the task at the front of the pending tasks queue, updates its status to "COMPLETED", and adds it to the completed tasks list. Handle the case where the pending queue is empty.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them. Handle the case where the pending queue is empty.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed tasks list. Handle the case where the completed tasks list is empty.
 *     *   A `run()` method that implements the main application loop, displaying a menu and processing user choices.
 * 
 * 3.  **User Interface:**
 *     *   The `run()` method should display a menu with options: 1. Add Task, 2. Complete Next Task, 3. View Pending Tasks, 4. View Completed Tasks, 5. Exit.
 *     *   Use `Scanner` to read the user's menu choice and task details.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to complete a task when the queue is empty, invalid menu choice).
 *     *   Implement input validation for task details (description, priority).
 *     *   Implement a **class-wide exception handling** mechanism using a `try-catch` block in the `run()` method's main loop to catch unexpected errors. Handle specific input errors (`InputMismatchException`) and a general `Exception`.
 * 
 * 5.  **Code Structure and Best Practices:**
 *     *   Organize your code into appropriate classes (`Task`, `TaskManager`).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc for clarity.
 *     *   Ensure proper resource management (e.g., close the `Scanner`).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue` (and a concrete implementation like `LinkedList`)
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` block
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying a menu, prompting for input, and providing feedback and task lists. Example interaction might look like:
 * 
 * ```
 * --- Welcome to the Task Management System ---
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Prepare exam question
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully: Prepare exam question
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [Priority: HIGH, Status: PENDING] Prepare exam question
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Complete Next Task ---
 * Completed task: Prepare exam question
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * No pending tasks.
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. [Priority: HIGH, Status: COMPLETED] Prepare exam question
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: invalid
 * Invalid input. Please enter a number for your choice.
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management Menu:
 * 1. Add Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Implement the Java code for the `Task` and `TaskManager` classes that fulfills all the above requirements.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Task Management System using the required Java components and best practices.
 * 
 * 1.  **`Priority` and `Status` Enums:** Enums are used to define the fixed possible values for task priority and status, improving code readability and preventing invalid values.
 * 2.  **`Task` Class:** This class models a single task with private fields for `description`, `priority`, and `status`. It includes a constructor for initialization, public getter methods for accessing properties, and a public setter for updating the status (specifically when a task is completed). Input validation is performed in the constructor to ensure description is not empty and priority is not null, throwing `IllegalArgumentException` if validation fails. The `toString()` method provides a convenient way to represent a Task object as a string for printing.
 * 3.  **`TaskManager` Class:** This is the main class that orchestrates the application logic.
 *     *   It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to store tasks waiting to be processed. The `Queue` interface ensures FIFO (First-In, First-Out) behavior, meaning the oldest pending task is completed first.
 *     *   It uses a `List<Task>` (`completedTasks`) implemented by `ArrayList` to store tasks that have been finished. The `List` interface provides ordered storage and allows easy iteration.
 *     *   A `Scanner` object is used to read user input from the console.
 *     *   **`addTask()`:** Prompts the user for description and priority. It includes a loop with a `try-catch` block to validate the priority input against the `Priority` enum using `Priority.valueOf()`. If valid, a new `Task` object is created (which performs its own validation) and added to the `pendingTasks` queue using `offer()`. Error messages for invalid priority or task creation issues caught from the `Task` constructor are printed to `System.err`.
 *     *   **`completeNextTask()`:** Checks if the `pendingTasks` queue is empty. If not, it uses `poll()` to retrieve and remove the task at the head of the queue. The task's status is updated to `COMPLETED`, and it is added to the `completedTasks` list. Messages are printed to `System.out` for success or to `System.out` (not `System.err` as it's not an error condition, just an empty state) if the queue was empty.
 *     *   **`viewPendingTasks()`:** Checks if `pendingTasks` is empty. If not, it iterates through the queue using a for-each loop (which does not remove elements) and prints each task using its `toString()` method to `System.out`.
 *     *   **`viewCompletedTasks()`:** Checks if `completedTasks` is empty. If not, it iterates through the list and prints each completed task to `System.out`.
 *     *   **`printMenu()`:** A helper method to display the available options to the user using `System.out`.
 *     *   **`run()`:** This method contains the main application loop. It repeatedly displays the menu, reads the user's choice using the `Scanner`, and uses a `switch` statement to call the appropriate `TaskManager` method based on the choice.
 *     *   **Class-wide Exception Handling:** The core logic within the `run()` method (reading input, processing choice, calling methods) is wrapped in a `try-catch` block. A specific `catch (InputMismatchException e)` handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. A general `catch (Exception e)` acts as the **class-wide handler**, catching any other unexpected runtime errors that might occur during the execution of the menu options and printing a general error message to `System.err`. A `finally` block ensures the `Scanner` is closed when the `run` method exits.
 *     *   **`main()`:** The entry point of the application, which creates a `TaskManager` instance and calls its `run()` method.
 *     *   **Resource Management:** The `Scanner` is closed in the `finally` block of the `run` method, ensuring the system resource is released regardless of whether the program exits normally or due to an exception.
 * 
 * This solution effectively demonstrates the use of `Queue`, `List` (via `ArrayList`), `Scanner`, `switch`, `System.out`, `System.err`, and class-wide `try-catch` in a practical, cohesive application, while adhering to best practices like encapsulation, input validation, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete Queue implementation
import java.util.List;
import java.util.ArrayList; // Concrete List implementation
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

/**
 * Enum representing the priority levels of a task.
 */
enum Priority {
    HIGH, MEDIUM, LOW
}

/**
 * Enum representing the status of a task.
 */
enum Status {
    PENDING, COMPLETED
}

/**
 * Represents a single task in the task management system.
 * Encapsulates task details: description, priority, and status.
 */
class Task {
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task with the given description and priority.
     * Status is automatically set to PENDING.
     *
     * @param description The description of the task. Must not be empty.
     * @param priority    The priority of the task (HIGH, MEDIUM, LOW). Must not be null.
     * @throws IllegalArgumentException if description is empty or priority is null.
     */
    public Task(String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
             throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.description = description.trim();
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the priority of the task.
     * @return The task priority.
     */
    public Priority getPriority() {
        return priority;
    }

    /**
     * Gets the current status of the task.
     * @return The task status.
     */
    public Status getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status for the task. Must not be null.
     * @throws IllegalArgumentException if status is null.
     */
    public void setStatus(Status status) {
        if (status == null) {
            throw new IllegalArgumentException("Task status cannot be null.");
        }
        this.status = status;
    }

    /**
     * Returns a string representation of the Task.
     * @return A formatted string including priority, status, and description.
     */
    @Override
    public String toString() {
        return "[Priority: " + priority + ", Status: " + status + "] " + description;
    }
}

/**
 * Manages a collection of tasks, separating pending tasks in a queue
 * and completed tasks in a list. Handles user interaction and application flow.
 */
public class TaskManager {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // Use LinkedList as a concrete implementation of Queue (FIFO)
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List (ordered history)
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts the user for task details (description and priority) and adds a new task
     * to the pending tasks queue. Includes input validation for priority.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        // Loop until a valid priority is entered
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase();
            try {
                // Attempt to convert string input to Priority enum
                priority = Priority.valueOf(priorityInput);
                validPriority = true; // Input was valid
            } catch (IllegalArgumentException e) {
                // Handle cases where the input string does not match any enum constant
                System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        try {
            // Create the Task object; its constructor validates description
            Task newTask = new Task(description, priority);
            // Add the new task to the end of the pending queue
            pendingTasks.offer(newTask); // offer is preferred over add for queues
            System.out.println("Task added successfully: " + newTask.getDescription());
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor (e.g., empty description)
            System.err.println("Failed to add task: " + e.getMessage());
        }
    }

    /**
     * Completes the next task in the pending queue.
     * Removes the task from the queue, updates its status, and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void completeNextTask() {
        System.out.println("--- Complete Next Task ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to complete.");
            return; // Exit method if queue is empty
        }

        // Retrieve and remove the head of the queue (FIFO)
        Task taskToComplete = pendingTasks.poll();

        if (taskToComplete != null) { // poll returns null if queue was empty, but checked above
            taskToComplete.setStatus(Status.COMPLETED); // Update status
            completedTasks.add(taskToComplete); // Add to the completed list
            System.out.println("Completed task: " + taskToComplete.getDescription());
        } else {
             // This case should ideally not be reached with the isEmpty check, but handle defensively
             System.err.println("Error retrieving task from queue.");
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue without removing them.
     * Handles the case where the pending queue is empty.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
            return; // Exit method if queue is empty
        }

        // Iterate through the queue using a for-each loop (does not remove elements)
        int index = 1;
        for (Task task : pendingTasks) {
            System.out.println(index++ + ". " + task); // Uses Task's toString()
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     * Handles the case where the completed list is empty.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
            return; // Exit method if list is empty
        }

        // Iterate through the list
        int index = 1;
        for (Task task : completedTasks) {
            System.out.println(index++ + ". " + task); // Uses Task's toString()
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * The main application loop that displays the menu, reads user input,
     * and dispatches to the appropriate task management methods.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Welcome to the Task Management System ---");
        boolean running = true;

        // Class-wide try-catch block wrapping the main application loop
        // This catches exceptions that might occur within the loop's execution,
        // including those propagated from called methods.
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Default invalid choice
                try {
                    // Attempt to read integer input for choice
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        completeNextTask(); // Call method to complete the next task
                        break;
                    case 3:
                        viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                // Optional: Add a short pause or prompt before showing the menu again
                // System.out.println("\nPress Enter to continue...");
                // scanner.nextLine();

            } // End of while loop
        } catch (Exception e) {
            // General catch block for any other unexpected runtime exceptions
            // This demonstrates class-wide handling for errors not specifically anticipated.
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits or if an exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * The application entry point. Creates a TaskManager and starts the application loop.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the task manager application
    }
}
