/*
 * Exam Question #1085
 * Generated on: 2025-05-12 17:22:46
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application to manage a customer service queue. Customers arrive, are added to a waiting queue, and are served one by one by an agent. The system should keep track of customers currently waiting and those who have been processed.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the waiting line of customers.
 *     *   Use a `java.util.ArrayList` to store a history of customers who have been successfully processed.
 *     *   Declare the processed customers history using the `java.util.List` interface type.
 * 
 * 2.  **Functionality:**
 *     *   **Add Customer:** Allow the user to add a new customer to the waiting queue. Each customer should have a unique ID, a name, and a description of their issue. The system should automatically generate IDs.
 *     *   **Process Next Customer:** Allow the user to serve the next customer from the front of the waiting queue. This customer should then be moved to the processed history list.
 *     *   **View Waiting Queue:** Display the list of customers currently waiting in the queue, in the order they will be served.
 *     *   **View Processed History:** Display the list of customers who have been processed.
 *     *   **Exit:** Allow the user to terminate the application.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Add Customer, Process Next, View Queue, View Processed, Exit).
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use `System.out` for displaying the menu, prompts, and normal output (queue status, processed list, success messages).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process from an empty queue).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during the main operation loop (e.g., invalid input format).
 *     *   Validate user input where appropriate (e.g., ensuring name/issue are not empty when adding a customer).
 *     *   Handle the case where the user tries to process a customer when the queue is empty.
 * 
 * 5.  **Best Practices:**
 *     *   Design a `Customer` class to encapsulate customer data (ID, name, issue). Fields should be private.
 *     *   Design a main class (e.g., `CustomerServiceSystem`) to manage the queue and history. Its data fields (`Queue`, `List`) should be private.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu like this:
 * 
 * ```
 * Customer Service Queue System
 * -----------------------------
 * 1. Add Customer
 * 2. Process Next Customer
 * 3. View Waiting Queue
 * 4. View Processed History
 * 5. Exit
 * Enter your choice: 
 * ```
 * 
 * Based on the user's choice, the system should perform the requested action, print relevant output to `System.out`, and handle errors by printing messages to `System.err`. For example:
 * 
 * *   Adding a customer prompts for name and issue, then confirms addition.
 * *   Processing a customer removes the head of the queue, prints which customer was processed, and adds them to history. If the queue is empty, an error message is printed to `System.err`.
 * *   Viewing queues/history prints the details of customers in the respective collections.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the required functionality.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Effective input validation and error handling.
 * *   Clean and readable code structure.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Customer Service Queue Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Customer` Class:**
 *     *   This simple class encapsulates the data for a single customer (`id`, `name`, `issue`).
 *     *   Fields are `private` enforcing encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   The `toString()` method is overridden for easy printing of customer details.
 * 
 * 2.  **`CustomerServiceSystem` Class:**
 *     *   This is the main class managing the system's state and operations.
 *     *   **`private Queue<Customer> waitingQueue;`**: A `Queue` is used because it naturally represents a waiting line where customers are served in First-In, First-Out (FIFO) order. `LinkedList` is a common and suitable implementation of the `Queue` interface.
 *     *   **`private List<Customer> processedCustomers;`**: An `ArrayList` is used to store the history of processed customers. It provides dynamic resizing and allows access by index if needed (though iteration is used here). Crucially, it is declared using the `List` *interface* type, adhering to the requirement and promoting good design principles (coding to interfaces).
 *     *   **`private int nextCustomerId;`**: A simple counter to ensure unique IDs for customers.
 *     *   **`addCustomer(String name, String issue)`**: This method creates a new `Customer` object with an auto-generated ID and adds it to the `waitingQueue` using `offer()`. It includes input validation to check for empty name or issue, printing an error to `System.err` if validation fails.
 *     *   **`processNextCustomer()`**: This method attempts to remove the head of the `waitingQueue` using `poll()`. If the queue is empty, `poll()` returns `null`, which is handled by printing an error message to `System.err`. If a customer is retrieved, it's added to the `processedCustomers` `List`.
 *     *   **`viewWaitingQueue()`**: Iterates through the `waitingQueue` (using a for-each loop, which doesn't remove elements) and prints each customer's details to `System.out`.
 *     *   **`viewProcessedCustomers()`**: Iterates through the `processedCustomers` `List` and prints each customer's details to `System.out`.
 *     *   **`runSystem()`**: This method contains the main application loop.
 *         *   It uses a `Scanner` to read user input.
 *         *   A `while` loop continues until the user chooses to exit (option 5).
 *         *   An inner `try-catch(InputMismatchException)` block specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A broader `try-catch(Exception)` inside the loop catches any other unexpected runtime exceptions that might occur during the execution of a specific menu option, printing an error to `System.err`.
 *         *   An outer `try-catch(Exception)` block wraps the entire `while` loop. This demonstrates a class-wide exception handling mechanism as requested, though in this specific simple application, most foreseeable errors are handled by the inner blocks. It serves as a safety net for truly critical, unexpected issues.
 *         *   A `finally` block ensures the `Scanner` is closed when the loop terminates or an unhandled exception occurs.
 *         *   A `switch` statement processes the validated integer input for the menu choice, calling the appropriate methods.
 *     *   **`printMenu()`**: A helper method to display the menu options to `System.out`.
 *     *   **`main(String[] args)`**: The entry point of the application. It creates an instance of `CustomerServiceSystem` and calls `runSystem()`.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `waitingQueue` (`LinkedList` implementation).
 *     *   `ArrayList`: Used for `processedCustomers` (`ArrayList` implementation).
 *     *   `List`: Used as the declared type for `processedCustomers`.
 *     *   `Scanner`: Used in `runSystem()` to read user input.
 *     *   `switch`: Used in `runSystem()` to handle menu choices.
 *     *   `System.err`: Used for printing error messages (input validation, empty queue, invalid menu choice, exceptions).
 *     *   `System.out`: Used for printing the menu, prompts, success messages, queue/history contents.
 *     *   `try-catch`: Used for handling `InputMismatchException` specifically and a broader `Exception` handling both within the loop for specific operations and wrapping the entire loop for class-wide coverage.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation: `Customer` and `CustomerServiceSystem` fields are private.
 *     *   Naming: Variable and method names are descriptive (e.g., `waitingQueue`, `processNextCustomer`, `nextCustomerId`).
 *     *   Comments: Javadoc-style comments explain classes and methods; inline comments clarify specific logic.
 *     *   Input Validation: Checks for empty name/issue in `addCustomer`.
 *     *   Error Handling: Specific handling for empty queue, invalid number input, and general exceptions using `try-catch` and `System.err`.
 *     *   Clean Code: Methods are relatively short and focused on a single task. The `runSystem` method orchestrates the user interaction flow.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simple, real-world simulation while adhering to good programming practices and error handling principles.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a customer in the service system
class Customer {
    private int id;
    private String name;
    private String issue;

    /**
     * Constructs a new Customer object.
     * @param id The unique ID for the customer.
     * @param name The name of the customer.
     * @param issue A description of the customer's issue.
     */
    public Customer(int id, String name, String issue) {
        this.id = id;
        this.name = name;
        this.issue = issue;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getIssue() {
        return issue;
    }

    /**
     * Provides a string representation of the Customer.
     * @return Formatted string including ID, name, and issue.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Issue: '" + issue + "'";
    }
}

// Manages the customer service queue and history
public class CustomerServiceSystem {

    private Queue<Customer> waitingQueue;
    private List<Customer> processedCustomers; // Declared using the List interface
    private int nextCustomerId; // To generate unique IDs

    /**
     * Constructs a new CustomerServiceSystem.
     * Initializes the waiting queue and processed history list.
     */
    public CustomerServiceSystem() {
        this.waitingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedCustomers = new ArrayList<>(); // ArrayList implements List
        this.nextCustomerId = 1;
    }

    /**
     * Adds a new customer to the waiting queue.
     * Validates input before adding.
     * @param name The name of the customer.
     * @param issue The issue description.
     * @return true if the customer was added successfully, false otherwise.
     */
    public boolean addCustomer(String name, String issue) {
        if (name == null || name.trim().isEmpty() || issue == null || issue.trim().isEmpty()) {
            System.err.println("Error: Customer name and issue cannot be empty.");
            return false;
        }
        Customer newCustomer = new Customer(nextCustomerId++, name.trim(), issue.trim());
        waitingQueue.offer(newCustomer); // offer is generally preferred for queues
        System.out.println("Customer added to queue: " + newCustomer);
        return true;
    }

    /**
     * Processes the next customer from the waiting queue.
     * Moves the customer to the processed history list.
     * Handles the case where the queue is empty.
     */
    public void processNextCustomer() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: The waiting queue is empty. No customer to process.");
            return;
        }
        Customer processed = waitingQueue.poll(); // poll retrieves and removes the head
        processedCustomers.add(processed);
        System.out.println("Processed customer: " + processed);
    }

    /**
     * Displays the current customers in the waiting queue.
     * Prints a message if the queue is empty.
     */
    public void viewWaitingQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int position = 1;
            for (Customer customer : waitingQueue) {
                System.out.println(position++ + ". " + customer);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays the history of processed customers.
     * Prints a message if no customers have been processed.
     */
    public void viewProcessedCustomers() {
        System.out.println("\n--- Processed Customer History ---");
        if (processedCustomers.isEmpty()) {
            System.out.println("No customers have been processed yet.");
        } else {
            for (int i = 0; i < processedCustomers.size(); i++) {
                System.out.println((i + 1) + ". " + processedCustomers.get(i));
            }
        }
        System.out.println("----------------------------------\n");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void runSystem() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide try-catch block for the main loop operations
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter customer name: ");
                            String name = scanner.nextLine();
                            System.out.print("Enter customer issue: ");
                            String issue = scanner.nextLine();
                            addCustomer(name, issue);
                            break;
                        case 2:
                            processNextCustomer();
                            break;
                        case 3:
                            viewWaitingQueue();
                            break;
                        case 4:
                            viewProcessedCustomers();
                            break;
                        case 5:
                            System.out.println("Exiting Customer Service System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during a menu operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging if needed
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception mainException) {
            // This catches exceptions that might escape the inner try-catch,
            // demonstrating a broader handling scope, though less likely in this simple app.
            System.err.println("A critical system error occurred: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            scanner.close(); // Ensure the scanner is closed
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Customer Service Queue System");
        System.out.println("-----------------------------");
        System.out.println("1. Add Customer");
        System.out.println("2. Process Next Customer");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        CustomerServiceSystem system = new CustomerServiceSystem();
        system.runSystem();
    }
}
