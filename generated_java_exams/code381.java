/*
 * Exam Question #381
 * Generated on: 2025-05-11 23:02:51
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Manufacturing Production Line Simulator
 * 
 * **Objective:** Design and implement a simple Java application that simulates a manufacturing production line. The application should manage a queue of incoming products waiting to be processed and a list of products that have been processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the incoming products waiting for processing.
 *     *   Use a `java.util.ArrayList` to store the products that have been finished and moved to inventory.
 *     *   Ensure the `ArrayList` is referenced using the `java.util.List` interface type.
 * 
 * 2.  **Classes:**
 *     *   Create a `Product` class to represent a single product. It should have private fields for `id` (integer), `type` (String, e.g., "A", "B", "C"), and `status` (String, e.g., "QUEUED", "FINISHED"). Include a constructor, getters, a setter for status, and a `toString()` method.
 *     *   Create a `ProductionLine` class to manage the queue and the inventory. It should have private fields for the `Queue` and the `List`. Include methods to:
 *         *   `addProduct(String type)`: Creates a new `Product` with a unique ID and adds it to the incoming queue. Validate the product type.
 *         *   `processNextProduct()`: Removes the next product from the queue, changes its status to "FINISHED", and adds it to the finished inventory list. Handle the case where the queue is empty.
 *         *   `displayStatus()`: Prints the current size of the incoming queue and the finished inventory. Optionally, show details of the next product in the queue and the last processed product.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         *   Add Product to Queue
 *         *   Process Next Product
 *         *   View Status
 *         *   Exit
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and status information.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue, invalid product type).
 *     *   Implement class-wide exception handling in the `main` method using a `try-catch` block that wraps the main application loop to catch unexpected errors. Also, handle specific input errors (like non-integer command input) gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods where needed).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (check for valid product types, check for empty queue before processing).
 *     *   Structure the code into separate classes.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting commands, and providing feedback via `System.out` or `System.err`. Example interaction might look like:
 * 
 * ```
 * --- Manufacturing Production Line Simulator ---
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 1
 * Enter product type (A, B, or C): A
 * Successfully added Product [ID=1, Type=A, Status=QUEUED] to the queue.
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 1
 * Enter product type (A, B, or C): Z
 * Error: Invalid product type 'Z'. Valid types are: [A, B, C]
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 3
 * 
 * --- Production Line Status ---
 * Incoming Queue Size: 1
 *   Next in queue: 1 (A)
 * Finished Inventory Size: 0
 * ----------------------------
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 2
 * Processing Product [ID=1, Type=A, Status=QUEUED]...
 * Product 1 processed and moved to finished inventory.
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 3
 * 
 * --- Production Line Status ---
 * Incoming Queue Size: 0
 * Finished Inventory Size: 1
 *   Last finished: 1 (A)
 * ----------------------------
 * 
 * Select an action:
 * 1. Add Product to Queue
 * 2. Process Next Product
 * 3. View Status
 * 4. Exit
 * Enter command: 2
 * Error: Cannot process. The incoming queue is empty.
 * 
 * Select an action:
 * ... (continue interaction)
 * Enter command: 4
 * Exiting simulator.
 * Simulator shut down.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple manufacturing production line simulator, fulfilling all the specified requirements and demonstrating advanced Java concepts.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):** The `incomingQueue` in the `ProductionLine` class is declared as a `Queue` and implemented using `LinkedList`. This correctly models the "waiting line" nature of products arriving for processing, where items are added to the end (`offer`) and removed from the front (`poll`).
 * 2.  **`ArrayList` (`java.util.ArrayList`):** The `finishedInventory` is implemented using `ArrayList`. This is suitable for storing processed items, allowing easy addition (`add`) and retrieval by index (though we only retrieve the last item here).
 * 3.  **`List` interface (`java.util.List`):** The `finishedInventory` field is declared using the `List` interface type (`List<Product> finishedInventory = new ArrayList<>();`), demonstrating the principle of programming to interfaces rather than concrete implementations.
 * 4.  **`Scanner` (`java.util.Scanner`):** Used in the `main` method to read user input from the console for selecting menu options and entering product types.
 * 5.  **`switch` statement:** The `switch` statement in `main` is used effectively to direct the program flow based on the user's integer command input, invoking the corresponding methods of the `ProductionLine` object.
 * 6.  **`System.err`:** Used specifically for outputting error messages, such as invalid user commands, incorrect product types, or attempting an action on an empty queue. This adheres to the standard practice of separating error output from normal output.
 * 7.  **`System.out`:** Used for all standard program output, including the menu display, prompts, success messages after adding/processing products, and the status report.
 * 8.  **Class-wide `try-catch` handling:** A broad `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This provides a safety net to catch any unexpected runtime exceptions that might occur during the program's execution, preventing the program from crashing abruptly and printing a helpful error message and stack trace to `System.err`. A more specific `try-catch(InputMismatchException e)` is also used within the loop to gracefully handle cases where the user enters non-integer input for the command, preventing the `scanner.nextInt()` method from throwing an unhandled exception and causing an infinite loop. The `finally` block ensures the `Scanner` is closed.
 * 9.  **Encapsulation:** The `Product` and `ProductionLine` classes encapsulate their data using private fields and provide public methods for controlled access and modification.
 * 10. **Meaningful Names:** Classes, methods, and variables have descriptive names (`Product`, `ProductionLine`, `incomingQueue`, `processNextProduct`, `displayStatus`, `validProductTypes`, etc.).
 * 11. **Comments and Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific implementation details.
 * 12. **Input Validation:** The `addProduct` method validates the entered product type against a predefined list (`validProductTypes`). The `processNextProduct` method checks if the queue is empty before attempting to poll an element. The `main` method validates the command input type and range.
 * 13. **Proper Error Handling:** Specific error conditions (invalid type, empty queue, invalid command input) are checked, and informative error messages are printed to `System.err`. Unexpected errors are caught by the main `try-catch` block.
 * 14. **Clean Code Structure:** The code is organized into logical classes (`Product`, `ProductionLine`, `ManufacturingSimulator`), making it modular and easier to understand. Helper methods (`isValidProductType`, `displayMenu`) are used to break down tasks.
 * 
 * The solution effectively simulates the production line flow, demonstrating how to use standard Java collections (`Queue`, `List`, `ArrayList`), handle user interaction (`Scanner`, `switch`), manage output streams (`System.out`, `System.err`), and implement robust error handling (`try-catch`). It serves as a good example of integrating multiple core Java concepts into a single, functional application.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays;
import java.util.InputMismatchException;

// Represents a product in the manufacturing process
class Product {
    private int id;
    private String type; // e.g., "A", "B", "C"
    private String status; // e.g., "QUEUED", "FINISHED"

    /**
     * Constructs a new Product.
     *
     * @param id   Unique product identifier.
     * @param type The type of the product.
     */
    public Product(int id, String type) {
        this.id = id;
        this.type = type;
        this.status = "QUEUED"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Product.
     *
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Product [ID=" + id + ", Type=" + type + ", Status=" + status + "]";
    }
}

// Manages the production line flow
class ProductionLine {
    // Use LinkedList as a Queue implementation for incoming products
    private Queue<Product> incomingQueue;
    // Use ArrayList assigned to a List interface for finished inventory
    private List<Product> finishedInventory;
    private int nextProductId;
    // Allowed product types for validation
    private final List<String> validProductTypes = Arrays.asList("A", "B", "C");

    /**
     * Constructs a new ProductionLine manager.
     */
    public ProductionLine() {
        this.incomingQueue = new LinkedList<>();
        this.finishedInventory = new ArrayList<>();
        this.nextProductId = 1;
    }

    /**
     * Adds a new product to the incoming queue.
     * Validates the product type.
     *
     * @param productType The type of product to add (e.g., "A", "B", "C").
     */
    public void addProduct(String productType) {
        if (productType == null || productType.trim().isEmpty()) {
            System.err.println("Error: Product type cannot be empty.");
            return;
        }
        String typeUpper = productType.trim().toUpperCase();
        if (!isValidProductType(typeUpper)) {
            System.err.println("Error: Invalid product type '" + productType + "'. Valid types are: " + validProductTypes);
            return;
        }

        Product newProduct = new Product(nextProductId++, typeUpper);
        // offer is preferred over add for queues as it returns false instead of throwing exception
        incomingQueue.offer(newProduct);
        System.out.println("Successfully added " + newProduct + " to the queue.");
    }

    /**
     * Processes the next product from the incoming queue.
     * Moves the product to the finished inventory upon processing.
     */
    public void processNextProduct() {
        if (incomingQueue.isEmpty()) {
            System.err.println("Error: Cannot process. The incoming queue is empty.");
            return;
        }

        // poll retrieves and removes the head of the queue
        Product productToProcess = incomingQueue.poll();
        System.out.println("Processing " + productToProcess + "...");

        // Simulate processing (just change status for this example)
        productToProcess.setStatus("FINISHED");

        // Add the processed product to the finished inventory list
        finishedInventory.add(productToProcess);
        System.out.println("Product " + productToProcess.getId() + " processed and moved to finished inventory.");
    }

    /**
     * Displays the current status of the production line.
     * Shows queue size and finished inventory size, plus next/last product details.
     */
    public void displayStatus() {
        System.out.println("\n--- Production Line Status ---");
        System.out.println("Incoming Queue Size: " + incomingQueue.size());
        // Peek at the first item in queue without removing it
        if (!incomingQueue.isEmpty()) {
            Product nextInQueue = incomingQueue.peek();
            System.out.println("  Next in queue: " + nextInQueue.getId() + " (" + nextInQueue.getType() + ")");
        } else {
            System.out.println("  Incoming queue is empty.");
        }

        System.out.println("Finished Inventory Size: " + finishedInventory.size());
        // Get the last item added to inventory without removing it
        if (!finishedInventory.isEmpty()) {
            Product lastFinished = finishedInventory.get(finishedInventory.size() - 1);
            System.out.println("  Last finished: " + lastFinished.getId() + " (" + lastFinished.getType() + ")");
        } else {
             System.out.println("  Finished inventory is empty.");
        }
        System.out.println("----------------------------\n");
    }

    /**
     * Helper method to validate product types.
     *
     * @param type The type string to validate.
     * @return true if the type is valid, false otherwise.
     */
    private boolean isValidProductType(String type) {
        return validProductTypes.contains(type);
    }
}

// Main class to run the Manufacturing Simulator
public class ManufacturingSimulator {

    public static void main(String[] args) {
        // Use Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        ProductionLine productionLine = new ProductionLine();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            System.out.println("--- Manufacturing Production Line Simulator ---");
            while (running) {
                displayMenu();

                int choice = -1;
                // Handle potential non-integer input specifically using a nested try-catch
                try {
                    System.out.print("Enter command: ");
                    // Read the integer command. This can throw InputMismatchException.
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Print error to standard error stream
                    System.err.println("Invalid input. Please enter a number corresponding to a menu option.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    // Consume the rest of the line after nextInt() to prepare for next line reads
                    scanner.nextLine();
                }

                // Use switch statement for command handling based on user choice
                switch (choice) {
                    case 1: // Add Product
                        System.out.print("Enter product type (A, B, or C): ");
                        String typeInput = scanner.nextLine();
                        productionLine.addProduct(typeInput); // addProduct handles type validation and System.err
                        break;
                    case 2: // Process Next
                        productionLine.processNextProduct(); // processNextProduct handles empty queue and System.err
                        break;
                    case 3: // View Status
                        productionLine.displayStatus();
                        break;
                    case 4: // Exit
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;
                    default: // Invalid command number
                        // Print error to standard error stream
                        System.err.println("Invalid command. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Generic catch block for any other unexpected runtime errors
            // Print error details to standard error stream
            System.err.println("An unexpected error occurred during simulation:");
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the program exits, regardless of how it exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Simulator shut down.");
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private static void displayMenu() {
        System.out.println("\nSelect an action:");
        System.out.println("1. Add Product to Queue");
        System.out.println("2. Process Next Product");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
    }
}
