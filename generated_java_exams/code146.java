/*
 * Exam Question #146
 * Generated on: 2025-05-11 22:21:26
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Service Request Dispatch System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Service Request Dispatch System for a small organization. The system should allow users to submit new service requests, dispatch the next available request to a technician, and view lists of pending and completed requests.
 * 
 * The system operates on a first-in, first-out (FIFO) basis for dispatching requests. Once a request is dispatched, it is moved from the pending queue to a history of completed requests.
 * 
 * **System Requirements:**
 * 
 * 1.  **Request Representation:** Create a class `ServiceRequest` to represent a single service request. It should contain:
 *     *   A unique integer `id`.
 *     *   A `String` for the `type` of request (e.g., "IT Support", "Maintenance", "HR").
 *     *   A `String` for the `description` of the problem.
 *     *   A `String` for the `status` (e.g., "Pending", "Dispatched").
 *     *   Appropriate constructor, getters, and a `toString()` method for display.
 * 
 * 2.  **Dispatcher Logic:** Create a class `RequestDispatcher` responsible for managing requests. It must contain:
 *     *   A `Queue<ServiceRequest>` to hold requests that are pending dispatch.
 *     *   A `List<ServiceRequest>` to hold requests that have been dispatched (completed).
 *     *   A mechanism to generate unique request IDs starting from 1.
 *     *   Methods:
 *         *   `addRequest(String type, String description)`: Creates a new `ServiceRequest` with a unique ID and "Pending" status, and adds it to the pending queue. Should perform basic validation (e.g., description not empty).
 *         *   `dispatchNextRequest()`: Removes the request at the head of the pending queue, updates its status to "Dispatched", and adds it to the completed list. If the queue is empty, it should indicate this error condition.
 *         *   `viewPendingRequests()`: Prints details of all requests currently in the pending queue.
 *         *   `viewCompletedRequests()`: Prints details of all requests in the completed list.
 * 
 * 3.  **User Interface:** Implement a `main` method in a separate class (e.g., `ServiceSystem`) that provides a command-line interface:
 *     *   Present a menu with options: Add Request, Dispatch Next Request, View Pending Requests, View Completed Requests, Exit.
 *     *   Use `Scanner` to read user input for menu choices and request details.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Call the appropriate methods of the `RequestDispatcher`.
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, empty description when adding a request, attempting to dispatch from an empty queue).
 *     *   Use `System.out` for menu display, prompts, success messages, and request listings.
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically around the main user interaction loop, to gracefully handle unexpected inputs (like non-integer menu choices) or operational errors (like trying to dispatch from an empty queue). Consider defining a custom exception for the empty queue scenario.
 * 
 * **Required Java Components (Must use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (basic Javadoc is sufficient).
 * *   Input validation.
 * *   Proper error handling.
 * *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept user input, perform requested actions, and print results or error messages. Request listings should clearly show ID, Type, Description, and Status. Example flow:
 * 
 * ```
 * Service Request Dispatch System Menu:
 * 1. Add New Request
 * 2. Dispatch Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request type: IT Support
 * Enter request description: Printer not working
 * Request added with ID 1.
 * 
 * Service Request Dispatch System Menu:
 * 1. Add New Request
 * 2. Dispatch Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request type: Maintenance
 * Enter request description: Leaky faucet in breakroom
 * Request added with ID 2.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 1, Type: IT Support, Description: Printer not working, Status: Pending
 * ID: 2, Type: Maintenance, Description: Leaky faucet in breakroom, Status: Pending
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 2
 * Dispatching request ID: 1
 * Successfully dispatched request ID 1.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 2, Type: Maintenance, Description: Leaky faucet in breakroom, Status: Pending
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Requests ---
 * ID: 1, Type: IT Support, Description: Printer not working, Status: Dispatched
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 2
 * Dispatching request ID: 2
 * Successfully dispatched request ID 2.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 2
 * System.err: Error: No pending requests to dispatch.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: exit
 * System.err: Invalid input. Please enter a number.
 * 
 * Service Request Dispatch System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Service Request Dispatch System.
 * ```
 * 
 * Your solution should consist of the complete Java code for the `ServiceRequest`, `RequestDispatcher`, `EmptyQueueException` (or similar custom exception), and `ServiceSystem` classes.
 *
 * EXPLANATION:
 * The provided solution implements a Service Request Dispatch System, demonstrating the required Java concepts and adhering to best practices.
 * 
 * 1.  **`ServiceRequest` Class:**
 *     *   This class encapsulates the data for a single request: `id`, `type`, `description`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A `setStatus` method allows the dispatcher to change the request's status.
 *     *   The `toString()` method provides a convenient formatted output for displaying request details.
 * 
 * 2.  **`RequestDispatcher` Class:**
 *     *   This class manages the collection of requests.
 *     *   It uses a `Queue<ServiceRequest>` (`LinkedList` implementation) for `pendingRequests`, ensuring FIFO order for dispatching.
 *     *   It uses a `List<ServiceRequest>` (`ArrayList` implementation) for `completedRequests` to store a history of dispatched items.
 *     *   `nextRequestId` is a private field that automatically increments to ensure unique IDs for new requests.
 *     *   `addRequest`: Creates a new `ServiceRequest` and adds it to the `pendingRequests` queue using `queue.add()`. It includes basic input validation for the description and throws an `IllegalArgumentException` if validation fails.
 *     *   `dispatchNextRequest`: Uses `queue.poll()` to retrieve and remove the head of the `pendingRequests` queue. It updates the request's status and adds it to the `completedRequests` list. If `poll()` returns `null` (meaning the queue was empty), it throws a custom `EmptyQueueException`.
 *     *   `viewPendingRequests` and `viewCompletedRequests`: These methods iterate through the respective collections and print the `toString()` representation of each request. They check if the collections are empty to provide informative messages.
 * 
 * 3.  **`EmptyQueueException` Class:**
 *     *   A simple custom exception class extending `Exception`. This provides a specific type of exception that can be caught when attempting an operation (like dispatching) on an empty queue, making error handling clearer than returning `null` or a generic exception.
 * 
 * 4.  **`ServiceSystem` Class (`main` method):**
 *     *   This class contains the entry point of the application and handles user interaction.
 *     *   A `RequestDispatcher` object is instantiated to manage the requests.
 *     *   A `Scanner` is used to read input from `System.in`. The `try-with-resources` statement ensures the `Scanner` is automatically closed when the block is exited.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed, and the user's choice is read.
 *     *   A `switch` statement is used to process the user's choice, calling the appropriate methods on the `dispatcher` object.
 *     *   **Exception Handling:**
 *         *   A `try-catch` block wraps the core logic within the `while` loop (reading input and the `switch` statement). This provides class-wide exception handling for the user interaction flow.
 *         *   `InputMismatchException` is caught specifically to handle cases where the user enters non-integer input for the menu choice. `scanner.nextLine()` is used in the catch block to consume the invalid input line, preventing an infinite loop.
 *         *   The custom `EmptyQueueException` is caught when `dispatchNextRequest()` is called, allowing the system to print a user-friendly error message using `System.err` instead of crashing.
 *         *   `IllegalArgumentException` thrown by `addRequest` is caught within the `case 1` block to handle invalid input for request description, printing the error message to `System.err`.
 *         *   A general `Exception` catch block is included as a fallback for any other unexpected runtime errors, printing an error message and a stack trace to `System.err`.
 *     *   `System.out` is used for all standard output (menu, prompts, success messages, list contents).
 *     *   `System.err` is used exclusively for error messages.
 *     *   Input validation is performed in `addRequest` and handled in `main`.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical application, demonstrating object-oriented principles (encapsulation) and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for empty queue scenario
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single service request in the system.
 */
class ServiceRequest {
    private int id;
    private String type;
    private String description;
    private String status;

    /**
     * Constructs a new ServiceRequest.
     * @param id The unique ID of the request.
     * @param type The type of the request.
     * @param description The description of the request.
     * @param status The initial status of the request.
     */
    public ServiceRequest(int id, String type, String description, String status) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.status = status;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the request.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the request.
     * @return Formatted string of the request details.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Type: %s, Description: %s, Status: %s",
                             id, type, description, status);
    }
}

/**
 * Manages the queue of pending service requests and a list of completed requests.
 */
class RequestDispatcher {
    private Queue<ServiceRequest> pendingRequests;
    private List<ServiceRequest> completedRequests;
    private int nextRequestId;

    /**
     * Constructs a new RequestDispatcher.
     * Initializes the pending queue, completed list, and request ID counter.
     */
    public RequestDispatcher() {
        this.pendingRequests = new LinkedList<>(); // LinkedList implements Queue
        this.completedRequests = new ArrayList<>(); // ArrayList implements List
        this.nextRequestId = 1;
    }

    /**
     * Adds a new service request to the pending queue.
     * @param type The type of the request.
     * @param description The description of the request.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public void addRequest(String type, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        ServiceRequest newRequest = new ServiceRequest(nextRequestId++, type, description, "Pending");
        pendingRequests.add(newRequest);
        System.out.println("Request added with ID " + newRequest.getId() + ".");
    }

    /**
     * Dispatches the next pending request.
     * Moves the request from the pending queue to the completed list.
     * @return The dispatched ServiceRequest.
     * @throws EmptyQueueException if there are no pending requests.
     */
    public ServiceRequest dispatchNextRequest() throws EmptyQueueException {
        ServiceRequest requestToDispatch = pendingRequests.poll(); // Retrieves and removes the head

        if (requestToDispatch == null) {
            throw new EmptyQueueException("No pending requests to dispatch.");
        }

        requestToDispatch.setStatus("Dispatched");
        completedRequests.add(requestToDispatch);
        System.out.println("Dispatching request ID: " + requestToDispatch.getId());
        return requestToDispatch;
    }

    /**
     * Prints details of all pending requests.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate without removing elements
            for (ServiceRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
    }

    /**
     * Prints details of all completed requests.
     */
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            // Iterate through the list
            for (ServiceRequest request : completedRequests) {
                System.out.println(request);
            }
        }
    }
}

/**
 * Main class for the Service Request Dispatch System user interface.
 */
public class ServiceSystem {

    private static void printMenu() {
        System.out.println("\nService Request Dispatch System Menu:");
        System.out.println("1. Add New Request");
        System.out.println("2. Dispatch Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        RequestDispatcher dispatcher = new RequestDispatcher();
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Class-wide exception handling around the main interaction loop
            while (running) {
                printMenu();
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter request type: ");
                            String type = scanner.nextLine();
                            System.out.print("Enter request description: ");
                            String description = scanner.nextLine();
                            try {
                                dispatcher.addRequest(type, description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 2:
                            try {
                                ServiceRequest dispatched = dispatcher.dispatchNextRequest();
                                System.out.println("Successfully dispatched request ID " + dispatched.getId() + ".");
                            } catch (EmptyQueueException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3:
                            dispatcher.viewPendingRequests();
                            break;
                        case 4:
                            dispatcher.viewCompletedRequests();
                            break;
                        case 5:
                            System.out.println("Exiting Service Request Dispatch System.");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                }
            }
        } // Scanner is automatically closed here
    }
}
