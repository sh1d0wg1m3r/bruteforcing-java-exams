/*
 * Exam Question #807
 * Generated on: 2025-05-12 16:43:31
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Help Desk Ticket System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line simulation of a Help Desk Ticket System. The system should manage incoming support tickets, allow agents to process them, and track both pending and resolved issues.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this Help Desk Ticket System. Your program should allow users (simulating system operators) to interact with the system via commands entered into the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Class Structure:**
 *     *   Create a `Ticket` class to represent a single help desk ticket. It should have:
 *         *   A unique integer ID, automatically generated upon creation.
 *         *   A `String` description of the issue.
 *         *   A `String` status (e.g., "Pending", "Resolved").
 *         *   Private fields with public getter methods.
 *         *   A method to mark the ticket as resolved.
 *         *   Input validation in the constructor to ensure the description is not empty or null.
 *     *   Create a `HelpDeskSystem` class to manage the collection of tickets. It should have:
 *         *   A data structure to hold tickets that are waiting to be processed (pending). This *must* be a `java.util.Queue`.
 *         *   A data structure to hold tickets that have been processed (resolved). This *must* be a `java.util.List`, implemented using `java.util.ArrayList`.
 *         *   Methods to:
 *             *   `submitTicket(String description)`: Creates a new `Ticket` and adds it to the pending queue.
 *             *   `processNextTicket()`: Removes the next ticket from the pending queue, marks it as resolved, and adds it to the resolved list. Handles the case where there are no pending tickets.
 *             *   `listPendingTickets()`: Displays all tickets currently in the pending queue.
 *             *   `listResolvedTickets()`: Displays all tickets currently in the resolved list.
 *         *   A `run()` method that contains the main program loop, handling user interaction.
 *         *   A `main` method to create and start the `HelpDeskSystem`.
 * 
 * 2.  **User Interaction (within the `run()` method):**
 *     *   Use `java.util.Scanner` to read user commands from the console (`System.in`).
 *     *   The program should continuously prompt the user for a command until the "exit" command is entered.
 *     *   Use a `switch` statement to handle the different user commands:
 *         *   `submit`: Prompts the user for a ticket description, creates a new ticket, and adds it to the pending queue.
 *         *   `process`: Processes the next ticket in the pending queue.
 *         *   `list pending`: Displays all pending tickets.
 *         *   `list resolved`: Displays all resolved tickets.
 *         *   `exit`: Terminates the program.
 *     *   Handle invalid commands by printing an error message.
 * 
 * 3.  **Output and Error Handling:**
 *     *   Use `System.out` for normal program output (prompts, success messages, listing tickets).
 *     *   Use `System.err` for error messages (e.g., invalid command, attempting to process an empty queue, invalid ticket description).
 *     *   Implement input validation (e.g., ticket description not empty).
 *     *   Implement error handling for operations that might fail (e.g., processing an empty queue).
 *     *   Include a **class-wide `try-catch` block** (e.g., wrapping the main command loop in the `run()` method) to catch any unexpected runtime exceptions that might occur during system operation.
 * 
 * 4.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Help Desk Ticket System
 * Commands: submit, process, list pending, list resolved, exit
 * 
 * Enter command: submit
 * Enter ticket description: Printer is not working
 * 
 * Ticket 1 submitted.
 * 
 * Enter command: submit
 * Enter ticket description: Can't access network drive
 * 
 * Ticket 2 submitted.
 * 
 * Enter command: list pending
 * 
 * --- Pending Tickets ---
 * Ticket{id=1, description='Printer is not working', status='Pending'}
 * Ticket{id=2, description='Can't access network drive', status='Pending'}
 * -----------------------
 * 
 * Enter command: process
 * 
 * Ticket 1 processed and resolved.
 * 
 * Enter command: list resolved
 * 
 * --- Resolved Tickets ---
 * Ticket{id=1, description='Printer is not working', status='Resolved'}
 * ------------------------
 * 
 * Enter command: process
 * 
 * Ticket 2 processed and resolved.
 * 
 * Enter command: process
 * 
 * No pending tickets to process.
 * 
 * Enter command: list pending
 * 
 * --- Pending Tickets ---
 * No tickets currently pending.
 * -----------------------
 * 
 * Enter command: list resolved
 * 
 * --- Resolved Tickets ---
 * Ticket{id=1, description='Printer is not working', status='Resolved'}
 * Ticket{id=2, description='Can't access network drive', status='Resolved'}
 * ------------------------
 * 
 * Enter command: invalid command
 * 
 * Unknown command. Please use submit, process, list pending, list resolved, or exit.
 * 
 * Enter command: submit
 * Enter ticket description:
 * 
 * Error submitting ticket: Ticket description cannot be empty.
 * 
 * Enter command: exit
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing both classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Help Desk Ticket System simulation using the specified Java components and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with a unique ID, description, and status.
 *     *   A `static int nextId` ensures each new ticket gets a unique, sequential ID.
 *     *   Fields are `private` and accessed via `public` getters, demonstrating encapsulation.
 *     *   The constructor includes input validation using `IllegalArgumentException` to prevent tickets with empty descriptions.
 *     *   `markResolved()` updates the ticket's status.
 *     *   `toString()` provides a convenient way to print ticket details.
 * 
 * 2.  **`HelpDeskSystem` Class:**
 *     *   Acts as the controller for the system.
 *     *   Uses a `Queue<Ticket>` (`pendingTickets`) implemented by `LinkedList` to store tickets awaiting processing. The `Queue` interface is ideal here because tickets are processed in the order they are submitted (First-In, First-Out).
 *     *   Uses a `List<Ticket>` (`resolvedTickets`) implemented by `ArrayList` to store tickets that have been resolved. The `List` interface is suitable for storing a collection of resolved items where order of resolution might be relevant, and `ArrayList` provides dynamic resizing.
 *     *   **`submitTicket(String description)`:** Creates a new `Ticket` object. It wraps the ticket creation and queue addition in a `try-catch` block to handle the `IllegalArgumentException` thrown by the `Ticket` constructor if the description is invalid. Uses `System.err` for the error message and `System.out` for the success message.
 *     *   **`processNextTicket()`:** Checks if the `pendingTickets` queue is empty. If so, it prints an error to `System.err`. Otherwise, it uses `pendingTickets.poll()` to retrieve and remove the head of the queue. The retrieved ticket is then marked as resolved and added to the `resolvedTickets` list. A `try-catch` block is included for robustness during the processing step.
 *     *   **`listPendingTickets()`:** Iterates through the `pendingTickets` queue (using a for-each loop, which does not remove elements) and prints each ticket's details to `System.out`.
 *     *   **`listResolvedTickets()`:** Iterates through the `resolvedTickets` list and prints each ticket's details to `System.out`.
 *     *   **`run()`:** This method contains the main program loop. It uses a `Scanner` to read user input. A `while` loop continues until the `running` flag is set to `false`. Inside the loop, a `switch` statement is used to handle the different user commands (`submit`, `process`, `list pending`, `list resolved`, `exit`). `System.out` is used for prompts and normal messages, while `System.err` is used for the `default` case (unknown command).
 *     *   **Class-wide Exception Handling:** The entire `while` loop in the `run()` method is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, ensuring that if any unexpected runtime error occurs anywhere within the main system operation loop, it will be caught, an error message printed to `System.err`, and the program can potentially exit gracefully (or at least print debugging information via `e.printStackTrace()`).
 *     *   The `finally` block in `run()` ensures that the `Scanner` resource is closed when the program exits, regardless of whether an exception occurred or the user exited normally.
 *     *   **`main(String[] args)`:** The entry point of the application, which simply creates a `HelpDeskSystem` instance and calls its `run()` method.
 * 
 * **Required Component Usage Summary:**
 * 
 * *   `Queue`: Used for `pendingTickets` (`LinkedList` implementation).
 * *   `ArrayList`: Used for `resolvedTickets` (`ArrayList` implementation of `List`).
 * *   `List` interface: `resolvedTickets` is declared as `List`.
 * *   `Scanner`: Used in `run()` to read console input.
 * *   `switch`: Used in `run()` to dispatch commands.
 * *   `System.err`: Used for various error messages (invalid command, empty queue, submission error, unexpected runtime errors).
 * *   `System.out`: Used for prompts, success messages, and listing tickets.
 * *   Class-wide `try-catch`: A `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method.
 * 
 * **Best Practices:**
 * 
 * *   Encapsulation is used in both classes.
 * *   Variable and method names are descriptive (`pendingTickets`, `processNextTicket`, `listResolvedTickets`).
 * *   Comments and Javadoc are included to explain the purpose of classes and methods.
 * *   Input validation is performed in the `Ticket` constructor.
 * *   Error handling is implemented for specific operational issues (empty queue) and general unexpected exceptions.
 * *   The code is structured logically into two classes with clear responsibilities.
 * 
 * This solution effectively demonstrates the use of all required Java components in a practical, cohesive, and well-structured program, suitable for evaluating advanced Java understanding.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a single Help Desk Ticket.
 */
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs

    private int ticketId;
    private String description;
    private String status; // "Pending" or "Resolved"

    /**
     * Constructs a new Ticket with a unique ID and description.
     * Status is initialized to "Pending".
     * @param description The description of the ticket issue.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Ticket(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        this.ticketId = nextId++; // Assign unique ID and increment counter
        this.description = description.trim();
        this.status = "Pending";
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket's status as "Resolved".
     */
    public void markResolved() {
        this.status = "Resolved";
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string detailing the ticket's ID, description, and status.
     */
    @Override
    public String toString() {
        return "Ticket{" +
               "id=" + ticketId +
               ", description='" + description + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Manages the collection of pending and resolved Help Desk Tickets.
 */
public class HelpDeskSystem {
    // Queue for tickets awaiting processing (FIFO)
    private Queue<Ticket> pendingTickets;
    // List for tickets that have been processed
    private List<Ticket> resolvedTickets;

    /**
     * Constructs a new HelpDeskSystem, initializing the pending queue and resolved list.
     */
    public HelpDeskSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.resolvedTickets = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Creates a new ticket with the given description and adds it to the pending queue.
     * Handles potential errors during ticket creation (e.g., invalid description).
     * @param description The description for the new ticket.
     */
    public void submitTicket(String description) {
        try {
            Ticket newTicket = new Ticket(description); // Ticket constructor handles description validation
            pendingTickets.offer(newTicket); // offer() is preferred over add() for queues as it doesn't throw exception on capacity constraint (though LinkedList has no capacity constraint)
            System.out.println("Ticket " + newTicket.getTicketId() + " submitted.");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Ticket constructor
            System.err.println("Error submitting ticket: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during submission
             System.err.println("An unexpected error occurred during ticket submission: " + e.getMessage());
        }
    }

    /**
     * Processes the next ticket from the pending queue.
     * Removes the ticket, marks it as resolved, and moves it to the resolved list.
     * Prints an error if the pending queue is empty.
     */
    public void processNextTicket() {
        // Check if the queue is empty before attempting to process
        if (pendingTickets.isEmpty()) {
            System.err.println("No pending tickets to process.");
            return;
        }

        // Use poll() which removes the head of the queue and returns it (or null if empty)
        // Although we checked isEmpty(), poll() is generally safer than remove() (which throws NoSuchElementException)
        Ticket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess != null) {
            try {
                ticketToProcess.markResolved();
                resolvedTickets.add(ticketToProcess);
                System.out.println("Ticket " + ticketToProcess.getTicketId() + " processed and resolved.");
            } catch (Exception e) {
                // Catch any unexpected errors during the processing/resolving step
                System.err.println("An unexpected error occurred while processing ticket " + ticketToProcess.getTicketId() + ": " + e.getMessage());
                // In a real system, you might need to decide whether to re-add the ticket to the queue
            }
        }
         // If ticketToProcess was null, it means poll() returned null despite isEmpty() check,
         // which shouldn't happen with LinkedList unless concurrent modification is involved,
         // but defensive coding is good.
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void listPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets currently in the resolved list.
     */
    public void listResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
        if (resolvedTickets.isEmpty()) {
            System.out.println("No tickets have been resolved yet.");
        } else {
            // Iterate through the list
            for (Ticket ticket : resolvedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main command-line interface loop for the Help Desk System.
     * Handles user input and dispatches commands using a switch statement.
     * Includes a class-wide try-catch block for unexpected errors.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Help Desk Ticket System");
        System.out.println("Commands: submit, process, list pending, list resolved, exit");

        // Class-wide exception handling wrapping the main operational loop
        try {
            while (running) {
                System.out.print("\nEnter command: ");
                String command = scanner.nextLine().trim().toLowerCase(); // Read command, trim whitespace, convert to lowercase

                switch (command) {
                    case "submit":
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine(); // Read the full line for description
                        submitTicket(description);
                        break;
                    case "process":
                        processNextTicket();
                        break;
                    case "list pending":
                        listPendingTickets();
                        break;
                    case "list resolved":
                        listResolvedTickets();
                        break;
                    case "exit":
                        System.out.println("Exiting system.");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle unknown commands
                        System.err.println("Unknown command. Please use submit, process, list pending, list resolved, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exception that occurred within the loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed when the program finishes
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Help Desk System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run(); // Start the main system loop
    }
}
