/*
 * Exam Question #654
 * Generated on: 2025-05-12 16:20:36
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Lab Resource Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing computing resources (nodes) in a research lab. Users submit tasks that require a specific number of nodes. Due to limited resources, tasks are placed in a queue and processed on a First-In, First-Out (FIFO) basis when resources become available. The system should allow users to submit new tasks, attempt to allocate resources to pending tasks, view the status of the lab (pending tasks, running tasks, available nodes), and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are waiting for resources (`pendingTasks`).
 *     *   Use a `java.util.List` (specifically, an `ArrayList` implementation) to store tasks that are currently running (`runningTasks`).
 *     *   Maintain a count of the total available nodes and the currently free nodes.
 * 
 * 2.  **Classes:**
 *     *   Create a `Task` class to represent a computing task. It should have private fields for a unique task ID, the number of nodes required, and perhaps a nominal duration (though simulation of duration is not required). Provide a constructor and public getter methods.
 *     *   Create a `LabScheduler` class that encapsulates the `pendingTasks` queue, `runningTasks` list, and resource counts. This class should contain the core logic for submitting tasks, allocating resources, and displaying status.
 * 
 * 3.  **Functionality (implemented in `LabScheduler`):**
 *     *   A constructor that initializes the total number of nodes available in the lab.
 *     *   `submitTask()`: Prompts the user for task details (required nodes, duration), creates a `Task` object, assigns a unique ID (e.g., sequential number), and adds it to the `pendingTasks` queue. Validates input (e.g., required nodes must be positive).
 *     *   `allocateResources()`: Attempts to allocate resources to the task at the head of the `pendingTasks` queue.
 *         *   If the queue is empty, print a message.
 *         *   If the task at the head of the queue requires `N` nodes and `availableNodes >= N`:
 *             *   Dequeue the task.
 *             *   Add the task to the `runningTasks` list.
 *             *   Decrease `availableNodes` by `N`.
 *             *   Print a success message indicating which task started.
 *         *   If `availableNodes < N`:
 *             *   Print a message indicating insufficient resources for the next task in the queue. The task remains in the queue.
 *     *   `viewStatus()`: Displays the total nodes, available nodes, the list of running tasks (with their details), and the list of pending tasks (with their details).
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement a command loop that presents a menu to the user:
 *         *   `1: Submit Task`
 *         *   `2: Allocate Resources`
 *         *   `3: View Status`
 *         *   `4: Exit`
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 5.  **Error Handling & Best Practices:**
 *     *   Use `System.out` for normal output (menu, status, success messages).
 *     *   Use `System.err` for error messages (invalid input, insufficient resources for next task, etc.).
 *     *   Implement class-wide exception handling using a `try-catch` block, particularly around user input operations with `Scanner` to catch potential `InputMismatchException` if the user enters non-numeric input when a number is expected. The catch block should report the error using `System.err` and perhaps continue the loop or exit gracefully.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain key parts of the code.
 *     *   Validate user input where necessary (e.g., positive numbers for nodes/duration).
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Lab Resource Scheduler
 * Total Nodes: [TotalNodes]
 * Available Nodes: [AvailableNodes]
 * 
 * Menu:
 * 1: Submit Task
 * 2: Allocate Resources
 * 3: View Status
 * 4: Exit
 * Enter choice: 1
 * Enter required nodes for task: 5
 * Enter nominal duration for task: 30
 * Task [TaskID] submitted.
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Attempting to allocate resources...
 * Successfully allocated resources for Task [TaskID]. Task is now running.
 * OR
 * Insufficient resources ([AvailableNodes] available) to start next task (Task [TaskID] requires [RequiredNodes]).
 * 
 * Menu:
 * ...
 * Enter choice: 3
 * --- Lab Status ---
 * Total Nodes: [TotalNodes]
 * Available Nodes: [AvailableNodes]
 * Running Tasks:
 * Task [TaskID] (Nodes: [RequiredNodes], Duration: [Duration])
 * ...
 * Pending Tasks:
 * Task [TaskID] (Nodes: [RequiredNodes], Duration: [Duration])
 * ...
 * --- End Status ---
 * 
 * Menu:
 * ...
 * Enter choice: 4
 * Exiting Lab Scheduler.
 * ```
 * 
 * Error messages should appear on `System.err`.
 * 
 * **Constraints:**
 * 
 * *   The system does not need to simulate time passing or tasks completing automatically. Allocation is a manual step.
 * *   Only the task at the head of the queue is considered for allocation at any given time.
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Task` and `LabScheduler` classes (or a single class containing both and the `main` method) that fulfills all requirements.
 *
 * EXPLANATION:
 * This solution implements a simplified Lab Resource Scheduler demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task request. It uses private fields (`taskId`, `requiredNodes`, `duration`) and public getter methods, adhering to encapsulation. A static counter (`nextTaskId`) ensures each task gets a unique ID. The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`LabScheduler` Class:**
 *     *   **Fields:**
 *         *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. This stores tasks waiting for resources in FIFO order, as required by the `Queue` interface.
 *         *   `runningTasks`: A `List<Task>` implemented using `ArrayList`. This stores tasks that have been allocated resources. Using the `List` interface variable name demonstrates polymorphism.
 *         *   `totalNodes`: Stores the total number of nodes available in the lab (fixed after initialization).
 *         *   `availableNodes`: Stores the current count of free nodes.
 *     *   **Constructor:** Initializes the resource counts and the data structures. It includes basic validation for the initial `totalNodes`.
 *     *   **`submitTask(int requiredNodes, int duration)`:**
 *         *   Takes user input (implicitly, as it's called from `main` after reading with `Scanner`).
 *         *   Performs input validation (`requiredNodes > 0`, `duration > 0`). If validation fails, an error message is printed to `System.err`, and the method returns.
 *         *   Creates a new `Task` object.
 *         *   Uses `pendingTasks.offer(newTask)` to add the task to the tail of the queue. `offer()` is generally preferred over `add()` for queues as it returns `false` on failure (though `LinkedList`'s `offer` won't fail in this context).
 *         *   Prints a success message to `System.out`.
 *     *   **`allocateResources()`:**
 *         *   Uses `pendingTasks.peek()` to look at the task at the head of the queue *without* removing it. This allows checking resource requirements before committing to the allocation.
 *         *   Checks if the queue is empty (`nextTask == null`).
 *         *   Compares the task's required nodes (`nodesNeeded`) with `availableNodes`.
 *         *   If resources are sufficient:
 *             *   `pendingTasks.poll()` is used to remove and return the task from the head of the queue. `poll()` is preferred over `remove()` for queues as it returns `null` if the queue is empty (though `peek` already handled the empty case here).
 *             *   The task is added to the `runningTasks` `ArrayList` using `runningTasks.add()`.
 *             *   `availableNodes` is decremented.
 *             *   A success message is printed to `System.out`.
 *         *   If resources are insufficient, an error message is printed to `System.err`. The task remains at the head of the queue.
 *     *   **`viewStatus()`:**
 *         *   Prints the current state of the lab (total/available nodes) to `System.out`.
 *         *   Iterates through the `runningTasks` `List` (using an enhanced for loop) and prints each running task's details to `System.out`.
 *         *   Iterates through the `pendingTasks` `Queue` (using an enhanced for loop). Note that iterating a queue does not remove elements, which is the desired behavior here to just display the pending tasks. Prints each pending task's details to `System.out`.
 * 
 * 3.  **`main` Method:**
 *     *   Contains the main application loop.
 *     *   Uses `Scanner` to read user input.
 *     *   Includes an initial loop to get the total number of nodes, wrapped in a `try-catch` to handle `InputMismatchException` if the user enters non-numeric input. It also catches the `IllegalArgumentException` from the `LabScheduler` constructor. `scanner.next()` is used in the catch block to consume the invalid input, preventing an infinite loop.
 *     *   The main command loop runs while `running` is `true`.
 *     *   A `switch` statement processes the user's integer choice, calling the appropriate `LabScheduler` methods.
 *     *   A `try-catch (InputMismatchException e)` block wraps the core of the loop where `scanner.nextInt()` is called. This provides class-wide exception handling for input errors. When caught, an error message is printed to `System.err`, and `scanner.next()` consumes the invalid input.
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing a message to `System.err`.
 *     *   `scanner.nextLine()` is used after reading integers with `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls if they were used.
 *     *   The `Scanner` is closed when the application exits.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `LabScheduler` are private with public methods for access.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingTasks`, `allocateResources`, `requiredNodes`).
 *     *   **Comments:** Javadoc-style comments explain classes and methods, and inline comments clarify logic.
 *     *   **Input Validation:** `submitTask` checks for positive nodes/duration. The initial node count is validated in the constructor.
 *     *   **Error Handling:** `System.err` is used for specific error conditions (invalid input, insufficient resources, queue empty). The `try-catch` block in `main` handles general input parsing errors.
 *     *   **Clean Code:** The code is structured into logical classes and methods, making it readable and maintainable.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario while adhering to best practices, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a computing task submitted by a user
class Task {
    private static int nextTaskId = 1; // Class variable for unique IDs

    private int taskId;
    private int requiredNodes;
    private int duration; // Nominal duration, not simulated

    /**
     * Constructs a new Task.
     * @param requiredNodes The number of computing nodes required.
     * @param duration The nominal duration of the task.
     */
    public Task(int requiredNodes, int duration) {
        this.taskId = nextTaskId++;
        this.requiredNodes = requiredNodes;
        this.duration = duration;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public int getRequiredNodes() {
        return requiredNodes;
    }

    public int getDuration() {
        return duration;
    }

    @Override
    public String toString() {
        return "Task " + taskId + " (Nodes: " + requiredNodes + ", Duration: " + duration + ")";
    }
}

// Manages the lab resources and task queue
public class LabScheduler {
    private Queue<Task> pendingTasks;
    private List<Task> runningTasks;
    private int totalNodes;
    private int availableNodes;

    /**
     * Constructs a LabScheduler with a specified total number of nodes.
     * @param totalNodes The total number of computing nodes available.
     */
    public LabScheduler(int totalNodes) {
        if (totalNodes <= 0) {
            throw new IllegalArgumentException("Total nodes must be positive.");
        }
        this.totalNodes = totalNodes;
        this.availableNodes = totalNodes;
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.runningTasks = new ArrayList<>();   // ArrayList implements List
    }

    /**
     * Submits a new task to the pending queue.
     * @param requiredNodes The nodes required by the task.
     * @param duration The nominal duration of the task.
     */
    public void submitTask(int requiredNodes, int duration) {
        // Input validation
        if (requiredNodes <= 0) {
            System.err.println("Error: Required nodes must be positive.");
            return;
        }
        if (duration <= 0) {
             System.err.println("Error: Duration must be positive.");
             return;
        }

        Task newTask = new Task(requiredNodes, duration);
        pendingTasks.offer(newTask); // Add to the end of the queue
        System.out.println("Task " + newTask.getTaskId() + " submitted.");
    }

    /**
     * Attempts to allocate resources to the next pending task.
     */
    public void allocateResources() {
        System.out.println("Attempting to allocate resources...");

        // Peek at the head of the queue without removing it
        Task nextTask = pendingTasks.peek();

        if (nextTask == null) {
            System.out.println("No tasks in the pending queue.");
            return;
        }

        int nodesNeeded = nextTask.getRequiredNodes();

        if (availableNodes >= nodesNeeded) {
            // Resources available, allocate the task
            Task allocatedTask = pendingTasks.poll(); // Remove from the head of the queue
            runningTasks.add(allocatedTask);          // Add to the running list
            availableNodes -= nodesNeeded;            // Decrease available nodes

            System.out.println("Successfully allocated resources for " + allocatedTask + ". Task is now running.");
        } else {
            // Insufficient resources
            System.err.println("Insufficient resources (" + availableNodes + " available) to start next task (" + nextTask + " requires " + nodesNeeded + ").");
        }
    }

    /**
     * Displays the current status of the lab scheduler.
     */
    public void viewStatus() {
        System.out.println("--- Lab Status ---");
        System.out.println("Total Nodes: " + totalNodes);
        System.out.println("Available Nodes: " + availableNodes);

        System.out.println("Running Tasks:");
        if (runningTasks.isEmpty()) {
            System.out.println("  None");
        } else {
            // Use List interface methods
            for (Task task : runningTasks) {
                System.out.println("  " + task);
            }
        }

        System.out.println("Pending Tasks:");
        if (pendingTasks.isEmpty()) {
            System.out.println("  None");
        } else {
            // Use Queue interface methods (e.g., iterating is possible)
            // Note: Iterating a Queue doesn't remove elements.
            for (Task task : pendingTasks) {
                 System.out.println("  " + task);
            }
        }
        System.out.println("--- End Status ---");
    }

    /**
     * Main method to run the Lab Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LabScheduler scheduler = null;
        boolean initialized = false;

        // Initialize the scheduler with total nodes
        while (!initialized) {
            System.out.print("Enter total number of nodes in the lab: ");
            try {
                int nodes = scanner.nextInt();
                scheduler = new LabScheduler(nodes);
                initialized = true;
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter an integer for total nodes.");
                scanner.next(); // Consume the invalid input
            } catch (IllegalArgumentException e) {
                System.err.println(e.getMessage());
            }
        }

        boolean running = true;
        while (running) {
            System.out.println("\nMenu:");
            System.out.println("1: Submit Task");
            System.out.println("2: Allocate Resources");
            System.out.println("3: View Status");
            System.out.println("4: Exit");
            System.out.print("Enter choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        System.out.print("Enter required nodes for task: ");
                        int reqNodes = scanner.nextInt();
                        System.out.print("Enter nominal duration for task: ");
                        int duration = scanner.nextInt();
                        scheduler.submitTask(reqNodes, duration);
                        break;
                    case 2:
                        scheduler.allocateResources();
                        break;
                    case 3:
                        scheduler.viewStatus();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting Lab Scheduler.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling for Scanner input errors
                System.err.println("Invalid input. Please enter a number for your choice or task details.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }
}
