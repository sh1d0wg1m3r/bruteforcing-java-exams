/*
 * Exam Question #467
 * Generated on: 2025-05-11 23:15:24
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Task Scheduler System
 * 
 * **Objective:** Implement a simple command-line based task scheduler that manages tasks in a processing queue and archives completed tasks. The system should allow users to add new tasks, process the next task in the queue, view pending tasks, view processed tasks, and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   Include a constructor, appropriate getter methods, and a meaningful `toString()` method.
 * 
 * 2.  **Scheduler Logic:** Create a class `TaskScheduler` that manages the task flow. It must contain:
 *     *   A `private Queue<Task>` to hold tasks waiting to be processed. Use a suitable implementation like `LinkedList`.
 *     *   A `private List<Task>` (implemented by `ArrayList`) to store tasks that have been processed.
 *     *   A `private int taskCounter` to generate unique task IDs.
 *     *   A `public void addTask(String description)` method that creates a new `Task` with an auto-generated ID and adds it to the pending queue. It should validate that the description is not null or empty.
 *     *   A `public void processNextTask()` method that removes the next task from the pending queue, simulates processing (e.g., prints a message), and adds it to the processed list. If the queue is empty, it should report an error.
 *     *   A `public List<Task> getPendingTasks()` method that returns a *copy* or an unmodifiable view of the pending tasks queue for viewing purposes.
 *     *   A `public List<Task> getProcessedTasks()` method that returns the list of processed tasks.
 *     *   Implement the main application loop within the `TaskScheduler` class (e.g., in a `run` method called from `main`) to handle user interaction.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Processed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display normal output (menu, task details, success messages) using `System.out`.
 *     *   Display error messages (e.g., invalid input, queue empty) using `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for task descriptions (cannot be empty).
 *     *   Handle potential errors during task processing (e.g., trying to process from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main application loop to catch unexpected errors and prevent the program from crashing abruptly. Specifically, handle `java.util.InputMismatchException` if the user enters non-integer input for the menu choice.
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Ensure the `Scanner` resource is properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform actions based on the input. Examples:
 * 
 * *   Adding a task: Prompts for description, confirms task added.
 * *   Processing task: Removes task from queue, prints processing message, adds to processed list. If queue empty, prints error to `System.err`.
 * *   Viewing pending/processed: Lists tasks with IDs and descriptions. If empty, prints a message.
 * *   Invalid input: Prints error to `System.err`, redisplays menu.
 * *   Unexpected error: Prints an error message to `System.err` via the class-wide catch block.
 * 
 * **Deliverable:** A single `.java` file containing the `Task` and `TaskScheduler` classes with a `main` method in `TaskScheduler` to run the application.
 * 
 * **Evaluation Criteria:** Correctness of implementation, adherence to all requirements (including the use of specified components), code structure, readability, error handling, and best practices.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Scheduler system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a task. It uses `private final` fields for encapsulation and provides public getter methods. The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskScheduler` Class:** This is the main class managing the application logic and user interaction.
 *     *   **Required Collections:**
 *         *   `private Queue<Task> pendingTasks = new LinkedList<>();`: A `java.util.Queue` is used to hold tasks waiting for processing, respecting the FIFO (First-In, First-Out) order. `LinkedList` is a common implementation used as a Queue.
 *         *   `private List<Task> processedTasks = new ArrayList<>();`: A `java.util.List` reference, implemented by `java.util.ArrayList`, stores tasks once they are completed. This demonstrates both the interface (`List`) and a concrete implementation (`ArrayList`).
 *     *   **`taskCounter`:** A simple integer counter is used to assign unique IDs to tasks sequentially.
 *     *   **`scanner`:** A `java.util.Scanner` is initialized to read input from `System.in`.
 *     *   **`addTask(String description)`:** This method demonstrates input validation. It checks if the description is null or empty and throws an `IllegalArgumentException` if it is. Otherwise, it increments the counter, creates a new `Task`, and uses `pendingTasks.offer()` to add it to the queue. `offer()` is generally preferred over `add()` for queues as it returns `false` if the queue is full (though `LinkedList` as a queue implementation doesn't have a fixed capacity, it's good practice).
 *     *   **`processNextTask()`:** This method uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, which is checked to print an error message using `System.err`. If a task is successfully retrieved, a processing message is printed, and the task is added to the `processedTasks` `ArrayList`.
 *     *   **`getPendingTasks()` and `getProcessedTasks()`:** These methods provide access to the task lists for viewing. `getPendingTasks()` returns a *new* `ArrayList` created from the queue contents (`new ArrayList<>(pendingTasks)`) to prevent external code from modifying the queue's structure directly when just trying to view its elements. `getProcessedTasks()` returns the internal list directly as it's a historical record.
 *     *   **`displayMenu()`:** A helper method to print the menu options using `System.out`.
 *     *   **`run()`:** This method contains the main application loop (`while(running)`).
 *         *   It displays the menu.
 *         *   It reads the user's integer choice using `scanner.nextInt()`.
 *         *   **Input Validation & Error Handling:** A `try-catch` block is used specifically around `scanner.nextInt()` to catch `InputMismatchException` if the user enters non-integer input. An error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop. `continue` skips to the next loop iteration.
 *         *   **`switch` Statement:** A `switch` statement is used to direct the program flow based on the validated user choice, calling the appropriate `TaskScheduler` methods.
 *         *   **System.out vs System.err:** Normal informational messages (menu, task added, task processed, task lists) are printed to `System.out`. Error messages (invalid input, queue empty, invalid menu choice, task description empty) are printed to `System.err`.
 *         *   **Class-Wide Exception Handling:** The entire `while` loop within `run()` is wrapped in a broad `try-catch(Exception e)` block. This fulfills the requirement for "class-wide exception handling" by catching any *other* unexpected runtime exceptions that might occur within the main program flow, printing an error to `System.err`, and preventing the application from crashing abruptly. A `finally` block ensures the `scanner` is closed before the method exits.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates a `TaskScheduler` instance and calls its `run()` method to start the interaction loop.
 * 
 * This solution effectively uses all required components, follows best practices for encapsulation, naming, and documentation, and includes robust input validation and error handling using `try-catch` blocks and `System.err`. The scenario is practical and the complexity is appropriate for demonstrating advanced Java concepts in a cohesive manner.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private final int taskId;
    private final String description;

    /**
     * Constructs a new Task.
     *
     * @param taskId      The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
    }

    /**
     * Gets the task ID.
     *
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     *
     * @return A string in the format "Task [ID: taskId, Description: description]".
     */
    @Override
    public String toString() {
        return "Task [ID: " + taskId + ", Description: \"" + description + "\"]";
    }
}

/**
 * Manages the task queue and processed task list.
 * Handles user interaction via a command-line interface.
 */
public class TaskScheduler {

    private Queue<Task> pendingTasks;
    private List<Task> processedTasks;
    private int taskCounter;
    private Scanner scanner;

    /**
     * Constructs a new TaskScheduler.
     * Initializes the pending and processed task collections and the task counter.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // Using LinkedList as a Queue implementation
        this.processedTasks = new ArrayList<>(); // Using ArrayList for processed tasks
        this.taskCounter = 0;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        taskCounter++;
        Task newTask = new Task(taskCounter, description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the processed list.
     */
    public void processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head of the queue, returns null if empty
        if (nextTask == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + nextTask);
            // Simulate work...
            processedTasks.add(nextTask);
            System.out.println("Task completed and moved to processed list.");
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Note: This returns a new ArrayList containing the elements
     * from the queue to avoid modifying the queue directly.
     *
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns the list of tasks that have been processed.
     *
     * @return A List of processed tasks.
     */
    public List<Task> getProcessedTasks() {
        return processedTasks; // Returning the list directly, as it's meant for viewing
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and menu selection.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Using a switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        try {
                            addTask(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        List<Task> pending = getPendingTasks();
                        System.out.println("\n--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No tasks in the pending queue.");
                        } else {
                            pending.forEach(System.out::println); // Using method reference
                        }
                        break;
                    case 4:
                        List<Task> processed = getProcessedTasks();
                        System.out.println("\n--- Processed Tasks ---");
                        if (processed.isEmpty()) {
                            System.out.println("No tasks have been processed yet.");
                        } else {
                            processed.forEach(System.out::println);
                        }
                        break;
                    case 5:
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the program exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Scheduler application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
