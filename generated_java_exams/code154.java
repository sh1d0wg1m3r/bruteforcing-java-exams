/*
 * Exam Question #154
 * Generated on: 2025-05-11 22:22:43
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple, console-based system to manage tasks that need to be processed. The system should allow users to add new tasks, process the next task in line, view pending tasks, and view completed tasks. Different task types might exist, requiring slightly different processing messages. The system must be robust against common input errors and clearly communicate its state and any issues to the user.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for a unique `id` (integer), `description` (String), and `type` (String, e.g., "Standard", "Urgent", "Inquiry"). Include a constructor and public getter methods for these fields. Override the `toString()` method for easy printing.
 * 
 * 2.  **System Core:** Create a class `TaskProcessingSystem` that manages the tasks.
 *     *   It must maintain a queue of pending tasks using `java.util.Queue`.
 *     *   It must maintain a list of completed tasks using `java.util.List` and implementing it with `java.util.ArrayList`.
 *     *   Use a `java.util.Scanner` to read user input from the console.
 * 
 * 3.  **Functionality:** The system should present a menu to the user and perform actions based on their choice using a `switch` statement:
 *     *   **1. Add New Task:**
 *         *   Prompt the user for the task description.
 *         *   Prompt the user for the task type (e.g., "Standard", "Urgent", "Inquiry").
 *         *   Generate a unique ID for the task (e.g., using a counter).
 *         *   Create a new `Task` object.
 *         *   Add the new task to the processing queue.
 *         *   Provide feedback to the user that the task was added.
 *         *   Perform basic input validation for task type (e.g., check if it's one of the expected types, though case-insensitivity or a simple check is sufficient for this exam).
 *     *   **2. Process Next Task:**
 *         *   Attempt to remove and process the task at the front of the queue.
 *         *   If the queue is empty, print an error message to `System.err`.
 *         *   If a task is successfully retrieved:
 *             *   Print a message to `System.out` indicating which task is being processed.
 *             *   Use a `switch` statement based on the task's `type` to print a type-specific processing message (e.g., "Processing Standard Task...", "Handling Urgent Request!", "Analyzing Inquiry...").
 *             *   Add the processed task to the list of completed tasks.
 *             *   Print a message to `System.out` indicating the task is completed.
 *     *   **3. View Pending Tasks:**
 *         *   Print the details of all tasks currently in the processing queue.
 *         *   If the queue is empty, print a message indicating that.
 *         *   *Crucially, viewing the queue should NOT remove tasks.*
 *     *   **4. View Completed Tasks:**
 *         *   Print the details of all tasks in the completed tasks list.
 *         *   If the list is empty, print a message indicating that.
 *     *   **5. Exit:**
 *         *   Terminate the program gracefully.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around operations that might fail (like reading input or processing an empty queue - although using `poll()` and checking for `null` is preferred for the empty queue case, still include general `try-catch` for unexpected issues).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, empty queue processing attempt, invalid input).
 *     *   Use `System.out` for all normal output (menu, confirmations, task details, processing messages).
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include basic comments where necessary to explain complex logic.
 *     *   Ensure the `Scanner` resource is properly closed upon exit.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively in the console, displaying a menu, accepting user input, and printing appropriate messages to `System.out` or `System.err` based on the user's actions and the system's state.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Fix database connection
 * Enter task type (Standard, Urgent, Inquiry): Urgent
 * Task ID 1 (Urgent): 'Fix database connection' added to the queue.
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter task type (Standard, Urgent, Inquiry): Standard
 * Task ID 2 (Standard): 'Write report' added to the queue.
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID 1 (Urgent): 'Fix database connection'
 * Task ID 2 (Standard): 'Write report'
 * --- End Pending Tasks ---
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 2
 * Processing Task ID 1 (Urgent): 'Fix database connection'...
 * Handling Urgent Request!
 * Task ID 1 completed.
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID 1 (Urgent): 'Fix database connection'
 * --- End Completed Tasks ---
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 2
 * Processing Task ID 2 (Standard): 'Write report'...
 * Processing Standard Task...
 * Task ID 2 completed.
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 2
 * Error: No tasks in the queue to process. (Printed to System.err)
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. (Printed to System.err)
 * 
 * --- Task Management System ---
 * ... (menu again)
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation based on requirements.
 * *   Proper usage of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, error handling).
 * *   Code structure and readability.
 *
 * EXPLANATION:
 * This solution implements a console-based Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the task's `id`, `description`, and `type` using private fields and provides public getter methods. The `toString()` method is overridden for convenient printing of task details. This fulfills the encapsulation and basic class requirement.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core of the application.
 *     *   **`Queue<Task> processingQueue;`**: A `Queue` is used here because tasks are added to the system and processed in the order they arrive (First-In, First-Out - FIFO). `LinkedList` is a common implementation of the `Queue` interface in `java.util`.
 *     *   **`List<Task> completedTasks;`**: A `List` is used to store completed tasks. Unlike the queue, the order of completed tasks might not be strictly FIFO for retrieval (though they are added in processing order), and `ArrayList` is a suitable, dynamic implementation for storing and iterating over these objects. The variable is declared as `List` to program to the interface, a common best practice.
 *     *   **`Scanner scanner;`**: Used to read user input from `System.in`.
 *     *   **`taskIdCounter;`**: A simple counter to generate unique IDs for each new task.
 * 
 * 3.  **Functionality (`run` method and helper methods):**
 *     *   **`run()`**: This method contains the main application loop (`while(!exit)`). It repeatedly prints the menu, reads user input, and uses a `switch` statement to dispatch the action to the appropriate helper method (`addTask`, `processNextTask`, etc.).
 *     *   **`printMenu()`**: A simple helper to display the options to the user.
 *     *   **`addTask()`**: Prompts for description and type. It includes a loop with input validation to ensure the user enters one of the expected task types. A new `Task` object is created with the next unique ID, and then added to the `processingQueue` using `offer()`. `offer()` is generally preferred over `add()` for capacity-constrained queues, although for `LinkedList` they behave similarly; it's good practice with the `Queue` interface.
 *     *   **`processNextTask()`**: This method demonstrates queue processing. It uses `processingQueue.poll()`. `poll()` is crucial here as it retrieves *and* removes the head of the queue, returning `null` if the queue is empty. This prevents errors compared to methods like `remove()` or `element()` which would throw an exception on an empty queue. If a task is retrieved, a `switch` statement is used on the `task.getType()` to print different processing messages, fulfilling the requirement for a `switch` based on task attributes. The processed task is then added to the `completedTasks` `ArrayList`.
 *     *   **`viewPendingTasks()`**: This method iterates through the `processingQueue` to display its contents. It uses a simple enhanced `for` loop, which iterates over the elements without removing them, as required.
 *     *   **`viewCompletedTasks()`**: This method iterates through the `completedTasks` `ArrayList` to display its contents.
 *     *   **`closeScanner()`**: A dedicated method to close the `Scanner` resource, preventing resource leaks.
 * 
 * 4.  **Error Handling:**
 *     *   **`try-catch` (Input):** A specific `try-catch (InputMismatchException e)` block is used around `scanner.nextInt()` in the `run()` method. This handles cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt the user again after clearing the invalid input.
 *     *   **`try-catch` (General):** A broader `try-catch (Exception e)` block wraps the main `while` loop in the `run()` method. This provides a class-wide safety net to catch any unexpected exceptions that might occur during the execution of the menu options, printing an error message to `System.err` before the program potentially terminates or attempts to continue.
 *     *   **`System.err`:** Used specifically for printing error messages, such as invalid menu choices, invalid task types, and the message when trying to process an empty queue.
 *     *   **`System.out`:** Used for all standard program output, including the menu, prompts, task details, confirmations, and processing messages.
 *     *   **Empty Queue/List Checks:** Explicit checks (`processingQueue.isEmpty()`, `completedTasks.isEmpty()`) are performed before attempting to view or process, providing user-friendly messages instead of errors. The use of `poll()` for processing also gracefully handles the empty queue case by returning `null`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** The `Task` class fields are `private`, accessible only via `public` getters. The `TaskProcessingSystem` manages its internal state (`queues`, `scanner`, `counter`) privately.
 *     *   **Meaningful Names:** Variables (`processingQueue`, `completedTasks`, `taskIdCounter`), classes (`Task`, `TaskProcessingSystem`), and methods (`addTask`, `processNextTask`, `viewPendingTasks`, `run`) have names clearly indicating their purpose.
 *     *   **Comments:** Basic comments explain the purpose of classes, key fields, and specific logic blocks (like input validation loops or `poll()` usage).
 *     *   **Input Validation:** Basic validation for task type is included.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block associated with the main `try` in `run()`, ensuring it's closed even if an unexpected exception occurs.
 * 
 * This solution effectively integrates all required components into a functional, interactive program that simulates a practical task management workflow, demonstrating an understanding of data structures, control flow, user input handling, and robust error management in Java.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system.
class Task {
    private int id;
    private String description;
    private String type; // Could be an enum in a more complex system, but String fits requirement

    public Task(int id, String description, String type) {
        this.id = id;
        this.description = description;
        this.type = type;
    }

    // Public getter methods
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return String.format("Task ID %d (%s): '%s'", id, type, description);
    }
}

// Main system class to manage tasks.
public class TaskProcessingSystem {

    // Use Queue for pending tasks (FIFO)
    private Queue<Task> processingQueue;
    // Use List/ArrayList for completed tasks
    private List<Task> completedTasks;
    // Scanner for user input
    private Scanner scanner;
    // Counter for unique task IDs
    private int taskIdCounter;

    // Constructor
    public TaskProcessingSystem() {
        // LinkedList implements Queue
        this.processingQueue = new LinkedList<>();
        // ArrayList implements List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.taskIdCounter = 1; // Start task IDs from 1
    }

    // Main loop to run the system
    public void run() {
        System.out.println("--- Task Management System ---");
        boolean exit = false;

        // Class-wide try-catch for unexpected exceptions during the main loop
        try {
            while (!exit) {
                printMenu();
                int choice = -1;

                // Specific try-catch for reading integer input
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement for menu control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        exit = true;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed when the system exits
            closeScanner();
        }
    }

    // Prints the main menu options
    private void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    // Adds a new task to the queue
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        String type = "";
        boolean validType = false;
        // Input validation loop for task type
        while (!validType) {
            System.out.print("Enter task type (Standard, Urgent, Inquiry): ");
            type = scanner.nextLine().trim(); // trim whitespace
            // Simple case-insensitive validation
            if (type.equalsIgnoreCase("Standard") || type.equalsIgnoreCase("Urgent") || type.equalsIgnoreCase("Inquiry")) {
                validType = true;
            } else {
                System.err.println("Error: Invalid task type. Please enter 'Standard', 'Urgent', or 'Inquiry'.");
            }
        }

        Task newTask = new Task(taskIdCounter++, description, type);
        // Add the task to the end of the queue
        processingQueue.offer(newTask); // offer is safer than add as it returns false if failed (rare for LinkedList)
        System.out.println(newTask + " added to the queue.");
    }

    // Processes the task at the front of the queue
    private void processNextTask() {
        // Use poll() to retrieve and remove the head of the queue, returns null if queue is empty
        Task taskToProcess = processingQueue.poll();

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            System.out.println("Processing " + taskToProcess + "...");

            // Switch statement based on task type for different processing messages
            switch (taskToProcess.getType().toLowerCase()) { // Use toLowerCase for case-insensitive check
                case "standard":
                    System.out.println("Processing Standard Task...");
                    break;
                case "urgent":
                    System.out.println("Handling Urgent Request!");
                    break;
                case "inquiry":
                    System.out.println("Analyzing Inquiry...");
                    break;
                default:
                    // Should not happen with input validation, but good fallback
                    System.out.println("Processing unknown task type...");
                    break;
            }

            // Add the processed task to the completed list
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " completed.");
        }
    }

    // Views tasks currently in the processing queue
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (processingQueue.isEmpty()) {
            System.out.println("No tasks currently in the queue.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : processingQueue) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Pending Tasks ---");
    }

    // Views tasks that have been completed
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the completed tasks list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("--- End Completed Tasks ---");
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
