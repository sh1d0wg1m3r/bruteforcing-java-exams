/*
 * Exam Question #655
 * Generated on: 2025-05-12 16:20:40
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Management System
 * 
 * **Objective:** Design and implement a simple console-based application to manage incoming orders in a warehouse. The system should process orders in a First-In, First-Out (FIFO) manner and keep a history of processed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending orders.
 *     *   Use a `java.util.ArrayList` to store processed orders.
 *     *   Utilize the `java.util.List` interface when declaring the variable that holds processed orders (demonstrating polymorphism).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and order details from the console.
 *     *   Implement a menu-driven interface with options to:
 *         *   Add a new order to the pending queue.
 *         *   Process the next pending order from the queue.
 *         *   View all pending orders currently in the queue.
 *         *   View all orders that have been processed.
 *         *   Exit the application.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, and lists of orders.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks. This should include:
 *         *   Handling potential `InputMismatchException` when reading numeric input.
 *         *   Handling operations attempted on an empty queue (e.g., processing when no orders are pending).
 *     *   Include a broad `try-catch` block in the main application loop to catch unexpected runtime errors, demonstrating "class-wide" (or at least main application flow) exception handling.
 * 6.  **Object-Oriented Design & Best Practices:**
 *     *   Create separate classes to represent an `Order` and the `WarehouseSystem` itself.
 *     *   Apply encapsulation: Declare class fields as `private` and provide `public` methods (getters, operational methods) to interact with them.
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Validate user input where necessary (e.g., ensuring quantity is positive).
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Order Details:** Each order should have at least:
 * *   A unique Order ID (you can generate this sequentially starting from 1).
 * *   Item details (String, e.g., "Widgets", "Gadgets").
 * *   Quantity (integer).
 * *   Status (String, e.g., "Pending", "Processed").
 * 
 * **Expected Behavior:**
 * 
 * *   When adding an order, the system prompts for item details and quantity, assigns a unique ID, sets status to "Pending", and adds it to the pending queue.
 * *   When processing an order, the system takes the oldest order from the pending queue, changes its status to "Processed", and moves it to the processed list. If the queue is empty, it should print an error message to `System.err`.
 * *   Viewing pending/processed orders should list their details. If a list is empty, print a message indicating that.
 * *   Invalid menu choices should result in an error message to `System.err`.
 * *   Non-integer input for choices or quantity should be caught, reported via `System.err`, and the user prompted again or the loop continued gracefully.
 * 
 * **Deliverables:**
 * 
 * Provide the complete Java source code for the application, including all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective implementation of `try-catch` for error handling and input validation.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Readability, comments, and meaningful names.
 * *   Correct implementation of the warehouse logic (FIFO processing, order states).
 * *   Graceful handling of edge cases (empty queue, invalid input).
 *
 * EXPLANATION:
 * This solution implements the Warehouse Order Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:** The code is organized into three classes:
 *     *   `Order`: Represents a single order with its details, quantity, and status. It uses private fields (`orderId`, `itemDetails`, `quantity`, `status`) and public getter/setter methods, demonstrating encapsulation. The `toString()` method provides a convenient way to print order details.
 *     *   `WarehouseSystem`: Manages the collection of orders. It holds a `Queue<Order>` (`pendingOrders`) for FIFO processing using `LinkedList` as the concrete implementation, and a `List<Order>` (`processedOrders`) for storing processed orders using `ArrayList`. Declaring `processedOrders` as `List` showcases polymorphism. It provides public methods (`addOrder`, `processNextOrder`, `viewPendingOrders`, `viewProcessedOrders`) to perform operations, abstracting the underlying data structure details.
 *     *   `WarehouseApp`: Contains the `main` method and handles the user interface logic. It creates instances of `Scanner` and `WarehouseSystem` and manages the main application loop.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: `pendingOrders` is a `Queue`, used with `offer()` to add orders and `poll()` to remove/retrieve the head.
 *     *   `ArrayList`: `processedOrders` is instantiated as an `ArrayList`.
 *     *   `List`: `processedOrders` is declared using the `List` interface type.
 *     *   `Scanner`: A `Scanner` instance is used in `WarehouseApp` to read user input from `System.in`. `scanner.nextInt()` and `scanner.nextLine()` are used.
 *     *   `Switch statement`: Used in the `runApplication` method to direct control based on the user's menu choice.
 *     *   `System.err`: Used for printing error messages, such as invalid menu choices, invalid quantity input, or attempting to process an empty queue.
 *     *   `System.out`: Used for displaying the menu, success messages, and listing order details.
 *     *   `try-catch`:
 *         *   A broad `try-catch(Exception e)` block wraps the `runApplication()` call in `main` to catch any unexpected exceptions during the main program flow, fulfilling the "class-wide" handling requirement in a practical sense.
 *         *   Specific `try-catch(InputMismatchException e)` blocks are used when reading integer input (menu choice and quantity) to handle non-numeric input gracefully.
 *         *   The `processNextOrder` method in `WarehouseSystem` uses `pendingOrders.poll()`, which returns `null` if the queue is empty. An `if (orderToProcess == null)` check handles this specific business logic error condition and reports it via `System.err`, avoiding an exception.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used in `Order` and `WarehouseSystem`.
 *     *   **Meaningful Names:** Class names (`Order`, `WarehouseSystem`, `WarehouseApp`), variable names (`pendingOrders`, `processedOrders`, `itemDetails`, `quantity`, `nextOrderId`), and method names (`addOrder`, `processNextOrder`, `viewPendingOrders`, `runApplication`, `displayMenu`) are descriptive.
 *     *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific logic.
 *     *   **Input Validation:** The `addNewOrderProcess` method explicitly checks if the entered quantity is positive and loops until valid input is received. `try-catch` handles the input *type* validation.
 *     *   **Error Handling:** As detailed above, multiple `try-catch` blocks and conditional checks (`isEmpty()`, `poll() == null`) are used for robust error handling.
 *     *   **Clean Code Structure:** The logic is divided into separate classes and methods, making the code modular and easier to understand. The main application loop is kept clean by delegating specific tasks (like adding an order input process) to helper methods.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block in the `main` method to release the system resource.
 * 
 * This solution effectively integrates the required components into a functional system that simulates a real-world warehouse scenario, demonstrating advanced understanding of Java data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an order in the warehouse system.
 */
class Order {
    private int orderId;
    private String itemDetails;
    private int quantity;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Order.
     *
     * @param orderId The unique ID for the order.
     * @param itemDetails Description of the items in the order.
     * @param quantity The number of items.
     */
    public Order(int orderId, String itemDetails, int quantity) {
        this.orderId = orderId;
        this.itemDetails = itemDetails;
        this.quantity = quantity;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public String getItemDetails() {
        return itemDetails;
    }

    public int getQuantity() {
        return quantity;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Order.
     *
     * @return A formatted string describing the order.
     */
    @Override
    public String toString() {
        return String.format("Order ID: %d, Item: %s, Quantity: %d, Status: %s",
                             orderId, itemDetails, quantity, status);
    }
}

/**
 * Manages the warehouse orders, including pending and processed orders.
 */
class WarehouseSystem {
    // Queue to hold orders waiting to be processed (FIFO)
    private Queue<Order> pendingOrders;

    // List to hold orders that have been processed
    private List<Order> processedOrders;

    // Counter for generating unique order IDs
    private int nextOrderId;

    /**
     * Constructs a new WarehouseSystem.
     * Initializes the pending order queue and processed order list.
     */
    public WarehouseSystem() {
        // Using LinkedList as an implementation of Queue
        this.pendingOrders = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.processedOrders = new ArrayList<>();
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Adds a new order to the pending queue.
     *
     * @param itemDetails Description of the items.
     * @param quantity The number of items.
     */
    public void addOrder(String itemDetails, int quantity) {
        Order newOrder = new Order(nextOrderId++, itemDetails, quantity);
        pendingOrders.offer(newOrder); // Use offer for adding to queue
        System.out.println("Order " + newOrder.getOrderId() + " added to pending queue.");
    }

    /**
     * Processes the next order in the pending queue (FIFO).
     * Moves the order from pending to processed state.
     */
    public void processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Order orderToProcess = pendingOrders.poll();

        if (orderToProcess == null) {
            System.err.println("No pending orders to process.");
        } else {
            orderToProcess.setStatus("Processed");
            processedOrders.add(orderToProcess);
            System.out.println("Successfully processed order: " + orderToProcess.getOrderId());
        }
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    public void viewPendingOrders() {
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            System.out.println("\n--- Pending Orders ---");
            // Iterating over the queue does not remove elements
            pendingOrders.forEach(System.out::println);
            System.out.println("----------------------");
        }
    }

    /**
     * Displays all orders that have been processed.
     */
    public void viewProcessedOrders() {
        if (processedOrders.isEmpty()) {
            System.out.println("No processed orders yet.");
        } else {
            System.out.println("\n--- Processed Orders ---");
            processedOrders.forEach(System.out::println);
            System.out.println("------------------------");
        }
    }
}

/**
 * Main application class for the Warehouse Order Management System.
 * Handles user interaction and orchestrates operations.
 */
public class WarehouseApp {

    // Use a static scanner for the application lifecycle
    private static Scanner scanner = new Scanner(System.in);
    private static WarehouseSystem warehouseSystem = new WarehouseSystem();

    public static void main(String[] args) {
        // Broad try-catch for potential unexpected runtime errors
        try {
            runApplication();
        } catch (Exception e) {
            // Use System.err for critical application errors
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            // Optional: e.printStackTrace(); // For debugging purposes
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application shutdown complete.");
        }
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     */
    private static void runApplication() {
        int choice = -1; // Initialize choice to a value that won't exit immediately

        while (choice != 5) {
            displayMenu();

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addNewOrderProcess(); // Delegate to helper method
                        break;
                    case 2:
                        warehouseSystem.processNextOrder(); // WarehouseSystem handles its output/errors
                        break;
                    case 3:
                        warehouseSystem.viewPendingOrders();
                        break;
                    case 4:
                        warehouseSystem.viewProcessedOrders();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse Order System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid input messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input specifically
                System.err.println("Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure the loop continues
            }
            // Other potential exceptions from operations might be caught by the broad catch in main,
            // or handled within WarehouseSystem methods if more specific handling is needed there.

            System.out.println(); // Add a blank line for better readability between operations
        }
    }

    /**
     * Handles the process of gathering input for adding a new order.
     */
    private static void addNewOrderProcess() {
        System.out.print("Enter item details: ");
        String details = scanner.nextLine();

        int quantity = -1;
        // Loop until valid positive quantity is entered
        while (quantity <= 0) {
            try {
                System.out.print("Enter quantity: ");
                quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (quantity <= 0) {
                    System.err.println("Quantity must be a positive number.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for quantity
                System.err.println("Invalid input. Please enter a number for quantity.");
                scanner.nextLine(); // Consume invalid input
                quantity = -1; // Reset quantity to keep the loop going
            }
        }

        warehouseSystem.addOrder(details, quantity);
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("--- Warehouse Order System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Pending Order");
        System.out.println("3. View All Pending Orders");
        System.out.println("4. View All Processed Orders");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }
}
