/*
 * Exam Question #558
 * Generated on: 2025-05-11 23:29:16
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Attendee Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple system to manage attendees for an exclusive event that has a limited capacity. Attendees can register, and if the event is full, they are placed on a waiting list. The system also allows checking in registered attendees as they arrive.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Event Capacity:** The event has a fixed maximum capacity (e.g., 5 attendees for testing).
 * 2.  **Data Structures:**
 *     *   Maintain a list of attendees who are currently registered and expected to check in. Use an `ArrayList` for this, but declare the variable using the `List` interface (`java.util.List`).
 *     *   Maintain a waiting list for attendees who registered after the event reached capacity. Use a `Queue` (e.g., `LinkedList` which implements `Queue`) for this, as attendees from the waiting list would ideally be admitted in the order they joined if spots open up (though admitting from waiting list is *not* required for this task, maintaining the queue order is).
 * 3.  **User Interface:** Provide a command-line interface using `java.util.Scanner`.
 * 4.  **Operations:** The system should support the following operations via a menu:
 *     *   `1. Register Attendee`: Prompt for an attendee name.
 *         *   If the event is not full, add the attendee to the registered list.
 *         *   If the event is full, add the attendee to the waiting list.
 *         *   Attendees with the same name should not be registered or added to the waiting list more than once (check both lists for duplicates).
 *         *   Report success or failure (duplicate, capacity reached).
 *     *   `2. Check-in Attendee`: Prompt for an attendee name.
 *         *   If the attendee is found in the *registered* list, remove them (simulating check-in).
 *         *   Attendees on the waiting list *cannot* be checked in directly.
 *         *   Report success or failure (checked in, not found in registered list).
 *     *   `3. View Status`: Display the current list of registered attendees and the current waiting list.
 *     *   `4. Exit`: Terminate the program.
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 6.  **Input Validation:**
 *     *   Ensure attendee names are not empty strings.
 *     *   Handle non-integer input for the menu choice gracefully.
 * 7.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, empty name, duplicate registration, attendee not found for check-in).
 *     *   Implement **class-wide** exception handling using a `try-catch` block that wraps the main operational loop of your application. This block should catch general `Exception` and print an error message to `System.err`.
 * 8.  **Output:** Use `System.out` for the menu, prompts, and successful operation messages.
 * 9.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadocs for methods/class, inline comments for complex logic).
 *     *   Maintain a clean code structure.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Event Attendee Manager Menu:
 * 1. Register Attendee
 * 2. Check-in Attendee
 * 3. View Status
 * 4. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully.
 * 
 * Event Attendee Manager Menu:
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Bob registered successfully.
 * 
 * ... (register 3 more attendees until full, e.g., Charlie, David, Eve)
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: Frank
 * Event is full. Frank added to waiting list.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 3
 * --- Registered Attendees (5/5) ---
 * Alice
 * Bob
 * Charlie
 * David
 * Eve
 * --- Waiting List (1) ---
 * Frank
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee name: Bob
 * Bob checked in successfully.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 3
 * --- Registered Attendees (4/5) ---
 * Alice
 * Charlie
 * David
 * Eve
 * --- Waiting List (1) ---
 * Frank
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee name: Frank
 * Error: Attendee 'Frank' not found in registered list.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Error: Attendee 'Alice' is already registered or on waiting list.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: exit (invalid input)
 * Error: Invalid input. Please enter a number.
 * 
 * Event Attendee Manager Menu:
 * ...
 * Enter your choice: 4
 * Exiting Event Attendee Manager.
 * ```
 * 
 * Your solution should be a single Java file containing the `main` method and all necessary logic within a class.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper implementation of registration and check-in logic, respecting capacity and waiting list.
 * *   Effective input validation and error handling using `System.err` and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Clear and correct output using `System.out`.
 *
 * EXPLANATION:
 * This solution implements the `Event Attendee Manager` system using the required Java components and best practices.
 * 
 * 1.  **Class Structure:** The core logic is contained within the `EventManager` class. This class holds the state of the event (registered attendees, waiting list, capacity) and provides methods for the available operations. This demonstrates encapsulation by keeping the data private and exposing functionality through public methods.
 * 
 * 2.  **Data Structures:**
 *     *   `registeredAttendees`: Declared as `private List<String>`, instantiated as `new ArrayList<>()`. This fulfills the requirement of using both `List` and `ArrayList`. `ArrayList` is suitable here because we need dynamic resizing, efficient access by index (though not used directly in this version, it's a common list operation), and efficient removal by value (used in `checkInAttendee`).
 *     *   `waitingList`: Declared as `private Queue<String>`, instantiated as `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing the FIFO (First-In, First-Out) behavior suitable for a waiting list where attendees would ideally be processed in the order they joined. The `add()` method of `Queue` is used for adding to the end, and iteration is used to display the list contents without removing elements.
 * 
 * 3.  **Scanner and Switch:** A `Scanner` object reads user input from the console. The main application loop in the `run()` method repeatedly displays a menu and uses a `switch` statement to execute the corresponding operation based on the user's integer input.
 * 
 * 4.  **Operations Logic:**
 *     *   **Register:** Takes a name, validates it's not empty, and checks if the name already exists in *either* the registered list or the waiting list using `contains()`. If the event is not at capacity (`registeredAttendees.size() < capacity`), the attendee is added to the `registeredAttendees` list. Otherwise, they are added to the `waitingList` queue using `add()`.
 *     *   **Check-in:** Takes a name, validates it, and attempts to remove the name from the `registeredAttendees` list using `remove()`. The `remove()` method conveniently returns `true` if an element was found and removed, and `false` otherwise. This return value is used to determine success or failure. A specific error message is provided if the attendee is found on the waiting list instead of the registered list.
 *     *   **View Status:** Iterates through both the `registeredAttendees` list and the `waitingList` queue to print their contents, along with the current counts and capacity for clarity. Iterating over the `Queue` is done directly (e.g., using a for-each loop) to view elements without removing them (which `poll()` or `remove()` would do).
 * 
 * 5.  **Input Validation:**
 *     *   Empty names are checked at the beginning of `registerAttendee` and `checkInAttendee` using `name.isEmpty()` or `name.trim().isEmpty()`.
 *     *   Non-integer input for the menu choice is handled by wrapping the `Integer.parseInt()` call within a `try-catch (NumberFormatException e)`.
 * 
 * 6.  **Error Handling:**
 *     *   `System.err.println()` is used for all error messages, including invalid input, duplicate registrations, check-in failures, and invalid menu choices.
 *     *   A **class-wide** `try-catch (Exception e)` block is placed around the core `while` loop in the `run()` method. This catches any unexpected runtime exceptions that might occur within the loop's execution, prints a generic error message to `System.err`, preventing the program from crashing abruptly and demonstrating a robust error handling layer. A separate `try-catch` is also included in `main` for potential errors during object initialization.
 * 
 * 7.  **Best Practices:**
 *     *   Fields (`registeredAttendees`, `waitingList`, `capacity`, `scanner`) are `private`.
 *     *   Methods (`displayMenu`, `registerAttendee`, `checkInAttendee`, `displayStatus`, `run`) are `public` or `private` as appropriate for their role (public for operations called from `main` or `run`, private for internal helper methods).
 *     *   Variable and method names are descriptive (e.g., `registeredAttendees`, `checkInAttendee`, `displayStatus`).
 *     *   Javadocs are included for the class and public methods, explaining their purpose. Inline comments clarify specific logic points (like checking both lists for duplicates).
 *     *   The code is structured logically with separate methods for each operation.
 * 
 * This solution effectively combines the required Java components to simulate a practical scenario while adhering to important programming principles and error handling strategies suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Manages attendees for an event with limited capacity and a waiting list.
 */
public class EventManager {

    private List<String> registeredAttendees;
    private Queue<String> waitingList;
    private final int capacity;
    private Scanner scanner;

    /**
     * Constructs an EventManager with a specified capacity.
     *
     * @param capacity The maximum number of attendees that can be registered.
     */
    public EventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>();
        this.waitingList = new LinkedList<>(); // LinkedList implements Queue
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nEvent Attendee Manager Menu:");
        System.out.println("1. Register Attendee");
        System.out.println("2. Check-in Attendee");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Registers a new attendee. Adds to registered list if capacity allows,
     * otherwise adds to the waiting list. Prevents duplicates.
     */
    public void registerAttendee() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        // Check for duplicates in both lists
        if (registeredAttendees.contains(name) || waitingList.contains(name)) {
            System.err.println("Error: Attendee '" + name + "' is already registered or on waiting list.");
            return;
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(name);
            System.out.println(name + " registered successfully.");
        } else {
            waitingList.add(name);
            System.out.println("Event is full. " + name + " added to waiting list.");
        }
    }

    /**
     * Checks in an attendee. Removes the attendee from the registered list.
     * Only registered attendees can be checked in.
     */
    public void checkInAttendee() {
        System.out.print("Enter attendee name to check-in: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        if (registeredAttendees.remove(name)) {
            System.out.println(name + " checked in successfully.");
        } else {
            // Check if they are on the waiting list to give a more specific error
            if (waitingList.contains(name)) {
                 System.err.println("Error: Attendee '" + name + "' is on the waiting list and cannot be checked in yet.");
            } else {
                 System.err.println("Error: Attendee '" + name + "' not found in registered list.");
            }
        }
    }

    /**
     * Displays the current list of registered attendees and the waiting list.
     */
    public void displayStatus() {
        System.out.println("\n--- Registered Attendees (" + registeredAttendees.size() + "/" + capacity + ") ---");
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            for (String attendee : registeredAttendees) {
                System.out.println(attendee);
            }
        }

        System.out.println("--- Waiting List (" + waitingList.size() + ") ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (String attendee : waitingList) {
                System.out.println(attendee);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = 0;
        while (choice != 4) {
            displayMenu();
            try {
                // Read input line and attempt to parse as integer
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine);

                switch (choice) {
                    case 1:
                        registerAttendee();
                        break;
                    case 2:
                        checkInAttendee();
                        break;
                    case 3:
                        displayStatus();
                        break;
                    case 4:
                        System.out.println("Exiting Event Attendee Manager.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (NumberFormatException e) {
                // Handle non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Class-wide exception handling for any unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Set event capacity (can be changed)
        int eventCapacity = 5;
        try {
             EventManager manager = new EventManager(eventCapacity);
             manager.run();
        } catch (IllegalArgumentException e) {
             System.err.println("Initialization Error: " + e.getMessage());
        } catch (Exception e) {
             // Catch any potential exceptions during manager creation or initial setup
             System.err.println("An unexpected error occurred during startup: " + e.getMessage());
        }
    }
}
