/*
 * Exam Question #908
 * Generated on: 2025-05-12 16:58:13
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Registration System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Event Registration Management System. This system needs to manage different event sessions and handle attendee registration requests. Due to potential high volume or sessions starting at different times, registration requests are queued and processed one by one.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this system. The program should allow the user to:
 * 1.  **Add a new Session:** Define a session with a name and maximum capacity.
 * 2.  **Queue a Registration:** Add an attendee's registration request for a specific session to a pending queue.
 * 3.  **Process Next Registration:** Take the next request from the queue, find the corresponding session, and register the attendee if capacity allows.
 * 4.  **View Sessions:** Display all sessions, their capacity, and how many attendees are currently registered. Also show the number of pending registration requests.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution MUST utilize ALL of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the pending registration requests in a First-In, First-Out (FIFO) manner.
 * *   `java.util.ArrayList`: To store the list of sessions managed by the system.
 * *   `java.util.List` interface: Use `List` as the declared type for collections where appropriate (e.g., the list of sessions, or list of registered attendees within a session).
 * *   `java.util.Scanner`: To read user input from the console (commands and parameters).
 * *   `switch` statement: To handle the different user commands.
 * *   `System.err`: To print error messages (e.g., session not found, invalid input, registration failed).
 * *   `System.out`: To print normal output (menu, prompts, success messages, session lists).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, particularly around user input and potential issues during command processing (e.g., processing an empty queue, registering for a non-existent session, invalid number format).
 * 
 * **Functional Requirements & Constraints:**
 * 
 * *   A `Session` should have a name (String), a capacity (int), and a list of registered attendee names (List of Strings).
 * *   Session names must be unique (though you don't need to explicitly enforce this uniqueness during adding for the exam's time limit, finding by name should work).
 * *   Capacity must be a positive integer.
 * *   Registration requests should be objects containing the attendee name and the target session name.
 * *   When processing a registration request:
 *     *   If the session is found and has capacity, add the attendee's name to the session's registered list and print a success message to `System.out`.
 *     *   If the session is not found, print an error message to `System.err` and discard the request.
 *     *   If the session is found but is full, print an error message to `System.err` and discard the request.
 * *   Attempting to process registration when the queue is empty should print a message to `System.out` indicating the queue is empty.
 * *   Invalid user commands or input errors (e.g., entering text for capacity) should be caught and reported to `System.err` using `try-catch`.
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Apply proper encapsulation (private fields, public methods where necessary).
 * *   Include comments where logic is complex or to explain the purpose of classes/methods.
 * *   Validate user input where appropriate (e.g., capacity > 0).
 * *   Handle potential exceptions gracefully.
 * 
 * **Input Format:**
 * 
 * Commands are entered as single words, potentially followed by parameters on the same line or subsequent lines as prompted.
 * *   `ADD_SESSION`
 *     *   Prompt for Session Name.
 *     *   Prompt for Capacity.
 * *   `QUEUE_REGISTRATION`
 *     *   Prompt for Session Name.
 *     *   Prompt for Attendee Name.
 * *   `PROCESS_REGISTRATION` (No parameters needed)
 * *   `VIEW_SESSIONS` (No parameters needed)
 * *   `EXIT` (No parameters needed)
 * 
 * **Output Format:**
 * 
 * *   Menu and prompts: `System.out`
 * *   Success messages (Session added, Registration queued, Registration processed successfully): `System.out`
 * *   Session list and queue status: `System.out`
 * *   Empty queue message: `System.out`
 * *   Error messages (Session not found, Invalid capacity, Registration failed, Invalid command, Input errors): `System.err`
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Event Registration System ---
 * Commands: ADD_SESSION, QUEUE_REGISTRATION, PROCESS_REGISTRATION, VIEW_SESSIONS, EXIT
 * Enter command: ADD_SESSION
 * Enter session name: Java Basics
 * Enter capacity: 2
 * Session 'Java Basics' added with capacity 2.
 * Enter command: ADD_SESSION
 * Enter session name: Advanced Java
 * Enter capacity: 1
 * Session 'Advanced Java' added with capacity 1.
 * Enter command: QUEUE_REGISTRATION
 * Enter session name: Java Basics
 * Enter attendee name: Alice
 * Registration for Alice for session 'Java Basics' queued.
 * Enter command: QUEUE_REGISTRATION
 * Enter session name: Advanced Java
 * Enter attendee name: Bob
 * Registration for Bob for session 'Advanced Java' queued.
 * Enter command: QUEUE_REGISTRATION
 * Enter session name: NonExistentSession
 * Enter attendee name: Charlie
 * Error: Session 'NonExistentSession' not found. Registration request discarded.
 * Enter command: VIEW_SESSIONS
 * --- Sessions ---
 * Name: Java Basics, Registered: 0/2
 * Name: Advanced Java, Registered: 0/1
 * --- Pending Registrations: 2 ---
 * Enter command: PROCESS_REGISTRATION
 * Processing request for Bob for session 'Advanced Java'...
 * Registration successful for Bob in 'Advanced Java'.
 * Enter command: PROCESS_REGISTRATION
 * Processing request for Alice for session 'Java Basics'...
 * Registration successful for Alice in 'Java Basics'.
 * Enter command: PROCESS_REGISTRATION
 * Processing request for ...
 * Queue is empty. No registrations to process.
 * Enter command: QUEUE_REGISTRATION
 * Enter session name: Java Basics
 * Enter attendee name: David
 * Registration for David for session 'Java Basics' queued.
 * Enter command: PROCESS_REGISTRATION
 * Processing request for David for session 'Java Basics'...
 * Error: Registration failed for David in 'Java Basics'. Session is full.
 * Enter command: VIEW_SESSIONS
 * --- Sessions ---
 * Name: Java Basics, Registered: 1/2
 * Name: Advanced Java, Registered: 1/1
 * --- Pending Registrations: 0 ---
 * Enter command: EXIT
 * Exiting Event Registration System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The solution implements the Event Registration System as described in the problem statement, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Class Structure:**
 *     *   `Session`: Represents an individual event session. It holds its `name`, `capacity`, and a `List<String>` (`registeredAttendees`) to store the names of people registered. It includes methods for getting details, checking if it's full, and adding attendees. Encapsulation is used with private fields and public getter methods.
 *     *   `RegistrationRequest`: A simple class to hold the data for a pending request (attendee name, session name). This object is what gets added to the queue.
 *     *   `EventManagementSystem`: This is the core class managing the state of the system. It holds a `List<Session>` (implemented by `ArrayList`) and a `Queue<RegistrationRequest>` (implemented by `LinkedList`). It contains methods corresponding to the user commands (`addSession`, `queueRegistration`, `processNextRegistration`, `viewSessions`) and a helper method (`findSession`).
 *     *   `EventApp`: The main class containing the `main` method. It sets up the `Scanner` and `EventManagementSystem`, and runs the main command processing loop.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: The `pendingRegistrations` field in `EventManagementSystem` is declared as `Queue<RegistrationRequest>` and instantiated as a `LinkedList`. `LinkedList` is a common `Queue` implementation. `offer()` is used to add requests to the queue, and `poll()` is used to remove and retrieve the next request for processing. `size()` is used to display the queue size.
 *     *   `java.util.ArrayList`: The `sessions` field in `EventManagementSystem` is declared as `List<Session>` and instantiated as an `ArrayList`. The `registeredAttendees` field in the `Session` class is declared as `List<String>` and instantiated as an `ArrayList`. `ArrayList` is suitable here for dynamic lists where elements are added and iterated over.
 *     *   `java.util.List` interface: Both `sessions` and `registeredAttendees` are declared using the `List` interface (`List<Session>`, `List<String>`). This demonstrates coding to the interface, allowing flexibility to change the underlying implementation (e.g., to `LinkedList` or `Vector`) later if needed, without changing the code that uses the `List` reference.
 *     *   `java.util.Scanner`: An instance of `Scanner` is created in the `main` method to read user input from `System.in`. `nextLine()` is used to read commands and string parameters, and `nextInt()` is used for the capacity (with a subsequent `nextLine()` call to consume the leftover newline character).
 *     *   `switch` statement: The main command processing loop in `EventApp.main` uses a `switch` statement based on the user's input command string to direct execution to the appropriate logic or method call.
 *     *   `System.err`: Used in the `catch` blocks within the `main` method and within `EventManagementSystem` methods (like `processNextRegistration` or `queueRegistration` after adding validation) to print error messages to the standard error stream. This clearly separates error output from normal program output.
 *     *   `System.out`: Used throughout the `main` method and `EventManagementSystem` methods to print menus, prompts, success messages, session lists, and the empty queue message to the standard output stream.
 *     *   Class-wide exception handling with `try-catch`: A large `try-catch` block wraps the core command processing logic inside the `while` loop in `EventApp.main`. This block catches potential exceptions like `InputMismatchException` (if the user enters non-integer for capacity), `IllegalArgumentException` (thrown by constructors or methods for invalid data), `SessionNotFoundException` (custom exception), and a general `Exception` to catch unforeseen issues. Error messages are printed to `System.err` in the `catch` blocks. `IllegalArgumentException` and `SessionNotFoundException` are also thrown from within `EventManagementSystem` methods, allowing the central `try-catch` in `main` to handle them.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Session`, `RegistrationRequest`, and `EventManagementSystem` are private. Access is provided through public methods (getters, action methods like `addAttendee`, `addSession`, etc.).
 *     *   **Meaningful Names:** Variables (`sessions`, `pendingRegistrations`, `attendeeName`, `sessionCapacity`), classes (`Session`, `EventManagementSystem`), and methods (`addSession`, `queueRegistration`, `processNextRegistration`, `findSession`) have names that clearly indicate their purpose. Command constants are used for clarity.
 *     *   **Comments and Documentation:** Javadoc-style comments are included for classes and key methods explaining their purpose, parameters, and potential exceptions. Inline comments explain specific logic points.
 *     *   **Input Validation:** Input is validated at various points: `Session` constructor validates name and capacity; `RegistrationRequest` constructor validates names; `queueRegistration` checks if the session exists before queuing (an added refinement for robustness based on the scenario); `processNextRegistration` checks for session existence and capacity. `try-catch` handles format errors from `Scanner`.
 *     *   **Error Handling:** Exceptions (`InputMismatchException`, `IllegalArgumentException`, `SessionNotFoundException`) are used to signal errors. `try-catch` blocks gracefully handle these exceptions, printing informative messages to `System.err` and preventing the program from crashing. Specific error messages are provided for different failure conditions (session not found, full capacity, invalid input).
 *     *   **Clean Code Structure:** The code is divided into logical classes. The `main` method is kept relatively clean, focusing on the command loop and exception handling, delegating the core business logic to the `EventManagementSystem` class. Constants are used for commands.
 * 
 * This solution effectively integrates all required Java components within a functional, albeit simplified, real-world simulation, demonstrating understanding of collection types, control flow, user interaction, exception handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for session not found
class SessionNotFoundException extends Exception {
    public SessionNotFoundException(String message) {
        super(message);
    }
}

// Represents a single event session
class Session {
    private String name;
    private int capacity;
    private List<String> registeredAttendees; // Using List interface, implemented by ArrayList

    public Session(String name, int capacity) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Session name cannot be empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be a positive integer.");
        }
        this.name = name.trim();
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Using ArrayList here
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    public int getRegisteredCount() {
        return registeredAttendees.size();
    }

    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    /**
     * Attempts to add an attendee to the session.
     *
     * @param attendeeName The name of the attendee.
     * @return true if registration was successful, false if session is full.
     */
    public boolean addAttendee(String attendeeName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            // This validation could also be done before calling, but good to have here too
            System.err.println("Error: Attendee name cannot be empty.");
            return false; // Or throw an exception
        }
        if (!isFull()) {
            registeredAttendees.add(attendeeName.trim());
            return true;
        }
        return false; // Session is full
    }

    // Optional: Method to get registered attendees list (if needed for display beyond count)
    // public List<String> getRegisteredAttendees() {
    //     return new ArrayList<>(registeredAttendees); // Return a copy for encapsulation
    // }

    @Override
    public String toString() {
        return "Name: " + name + ", Registered: " + getRegisteredCount() + "/" + capacity;
    }
}

// Represents a pending registration request
class RegistrationRequest {
    private String sessionName;
    private String attendeeName;

    public RegistrationRequest(String sessionName, String attendeeName) {
        if (sessionName == null || sessionName.trim().isEmpty() || attendeeName == null || attendeeName.trim().isEmpty()) {
             throw new IllegalArgumentException("Session name and attendee name cannot be empty for a registration request.");
        }
        this.sessionName = sessionName.trim();
        this.attendeeName = attendeeName.trim();
    }

    public String getSessionName() {
        return sessionName;
    }

    public String getAttendeeName() {
        return attendeeName;
    }

    @Override
    public String toString() {
        return "Request [Attendee: " + attendeeName + ", Session: " + sessionName + "]";
    }
}

// Manages the event sessions and registration queue
class EventManagementSystem {
    private List<Session> sessions; // Using List interface, implemented by ArrayList
    private Queue<RegistrationRequest> pendingRegistrations; // Using Queue interface, implemented by LinkedList

    public EventManagementSystem() {
        this.sessions = new ArrayList<>(); // Using ArrayList here
        this.pendingRegistrations = new LinkedList<>(); // Using LinkedList here
    }

    /**
     * Adds a new session to the system.
     *
     * @param name     The name of the session.
     * @param capacity The capacity of the session.
     * @throws IllegalArgumentException if name is empty or capacity is not positive.
     */
    public void addSession(String name, int capacity) throws IllegalArgumentException {
        // Validation handled by Session constructor
        Session newSession = new Session(name, capacity);
        sessions.add(newSession);
        System.out.println("Session '" + newSession.getName() + "' added with capacity " + newSession.getCapacity() + ".");
    }

    /**
     * Queues a registration request.
     *
     * @param sessionName  The name of the target session.
     * @param attendeeName The name of the attendee.
     * @throws IllegalArgumentException if names are empty.
     * @throws SessionNotFoundException if the target session does not exist.
     */
    public void queueRegistration(String sessionName, String attendeeName) throws IllegalArgumentException, SessionNotFoundException {
         // Validation handled by RegistrationRequest constructor
        RegistrationRequest request = new RegistrationRequest(sessionName, attendeeName);

        // Optional: Check if session exists *before* queuing. Requirement says queue first, process later.
        // Let's stick to the requirement: queue first, validate on process.
        // If requirement implied validating session *before* queuing, we'd call findSession here.
        // Let's add a quick check here to discard requests for non-existent sessions early.
        if (findSession(request.getSessionName()) == null) {
             throw new SessionNotFoundException("Session '" + request.getSessionName() + "' not found.");
        }

        pendingRegistrations.offer(request); // offer is generally preferred over add for queues
        System.out.println("Registration for " + request.getAttendeeName() + " for session '" + request.getSessionName() + "' queued.");
    }

    /**
     * Processes the next pending registration request from the queue.
     *
     * @return true if a request was processed (successfully or not), false if the queue was empty.
     */
    public boolean processNextRegistration() {
        RegistrationRequest request = pendingRegistrations.poll(); // retrieves and removes the head of the queue

        if (request == null) {
            // System.out.println("Queue is empty. No registrations to process."); // Handled in main loop caller
            return false; // Indicate queue was empty
        }

        System.out.println("Processing request for " + request.getAttendeeName() + " for session '" + request.getSessionName() + "'...");

        try {
            Session targetSession = findSession(request.getSessionName());

            if (targetSession == null) {
                // This case might happen if a session is deleted after a request is queued (not part of requirements, but good to consider)
                // Or if we didn't validate session existence during queueing (which we added).
                 System.err.println("Error: Session '" + request.getSessionName() + "' not found during processing. Request discarded.");
                 // No need to re-queue, the session doesn't exist.
            } else if (targetSession.addAttendee(request.getAttendeeName())) {
                System.out.println("Registration successful for " + request.getAttendeeName() + " in '" + targetSession.getName() + "'.");
            } else {
                System.err.println("Error: Registration failed for " + request.getAttendeeName() + " in '" + targetSession.getName() + "'. Session is full.");
                // No need to re-queue, capacity check failed.
            }
        } catch (Exception e) {
             // Catch unexpected errors during processing
             System.err.println("An unexpected error occurred while processing registration for " + request.getAttendeeName() + ": " + e.getMessage());
             // Depending on error, might re-queue or discard. For this exam, discard.
        }


        return true; // Indicate a request was pulled from the queue
    }

    /**
     * Displays the list of sessions and the status of the registration queue.
     */
    public void viewSessions() {
        System.out.println("--- Sessions ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions added yet.");
        } else {
            for (Session session : sessions) {
                System.out.println(session); // Session's toString() provides details
            }
        }
        System.out.println("--- Pending Registrations: " + pendingRegistrations.size() + " ---");
    }

    /**
     * Finds a session by its name.
     *
     * @param name The name of the session to find.
     * @return The Session object if found, null otherwise.
     */
    private Session findSession(String name) {
        if (name == null) return null; // Basic null check
        String trimmedName = name.trim();
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(trimmedName)) { // Case-insensitive search
                return session;
            }
        }
        return null; // Session not found
    }

    /**
     * Gets the number of pending registration requests.
     * @return The size of the pending queue.
     */
    public int getPendingRegistrationCount() {
        return pendingRegistrations.size();
    }
}

// Main class to run the application
public class EventApp {

    private static final String COMMAND_ADD_SESSION = "ADD_SESSION";
    private static final String COMMAND_QUEUE_REGISTRATION = "QUEUE_REGISTRATION";
    private static final String COMMAND_PROCESS_REGISTRATION = "PROCESS_REGISTRATION";
    private static final String COMMAND_VIEW_SESSIONS = "VIEW_SESSIONS";
    private static final String COMMAND_EXIT = "EXIT";

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManagementSystem system = new EventManagementSystem();

        System.out.println("--- Event Registration System ---");
        printCommands();

        boolean running = true;
        while (running) {
            System.out.print("Enter command: ");
            String command = scanner.nextLine().trim().toUpperCase();

            // Class-wide exception handling for command processing loop
            try {
                switch (command) {
                    case COMMAND_ADD_SESSION:
                        System.out.print("Enter session name: ");
                        String sessionNameAdd = scanner.nextLine();
                        System.out.print("Enter capacity: ");
                        int capacity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline left-over

                        system.addSession(sessionNameAdd, capacity);
                        break;

                    case COMMAND_QUEUE_REGISTRATION:
                        System.out.print("Enter session name: ");
                        String sessionNameQueue = scanner.nextLine();
                        System.out.print("Enter attendee name: ");
                        String attendeeName = scanner.nextLine();

                        system.queueRegistration(sessionNameQueue, attendeeName);
                        break;

                    case COMMAND_PROCESS_REGISTRATION:
                        boolean processed = system.processNextRegistration();
                        if (!processed) {
                            System.out.println("Queue is empty. No registrations to process.");
                        }
                        break;

                    case COMMAND_VIEW_SESSIONS:
                        system.viewSessions();
                        break;

                    case COMMAND_EXIT:
                        System.out.println("Exiting Event Registration System.");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        printCommands();
                        break;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter the correct data type (e.g., a number for capacity).");
                scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
            } catch (IllegalArgumentException e) {
                System.err.println("Error: Invalid argument provided. " + e.getMessage());
            } catch (SessionNotFoundException e) {
                 System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
             System.out.println(); // Add a blank line for readability between commands
        }

        scanner.close(); // Close the scanner when done
    }

    private static void printCommands() {
        System.out.println("Commands: " + COMMAND_ADD_SESSION + ", " + COMMAND_QUEUE_REGISTRATION + ", " + COMMAND_PROCESS_REGISTRATION + ", " + COMMAND_VIEW_SESSIONS + ", " + COMMAND_EXIT);
    }
}
