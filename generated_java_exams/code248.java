/*
 * Exam Question #248
 * Generated on: 2025-05-11 22:39:04
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Restaurant Order Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based system for managing orders in a small restaurant. The system needs to handle a fixed menu, allow customers to place orders, process orders in the sequence they were received, and display the current status.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures, input handling, control flow, and exception management.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain the restaurant's menu using a `List<String>`. Initialize this list with at least 5 sample menu items.
 *     *   Represent an order as a custom Java class named `Order`. Each `Order` object must contain a unique ID (e.g., a sequential number) and an `ArrayList<String>` to store the names of the items included in that specific order.
 *     *   Manage incoming orders using a `Queue<Order>`. Orders should be processed in a First-In, First-Out (FIFO) manner.
 * 
 * 2.  **Functionality:**
 *     *   **Display Menu:** Show the menu items with their corresponding numbers (1-based index).
 *     *   **Place Order:**
 *         *   Prompt the user to enter the numbers of the items they want to order, one item number at a time.
 *         *   Allow the user to type "done" when they have finished adding items to the order.
 *         *   Validate that the entered item number is a valid integer within the range of the menu.
 *         *   Create a new `Order` object, add the selected item names to its internal `ArrayList`, and add the completed order to the order `Queue`.
 *         *   Assign sequential unique IDs to orders starting from 1.
 *     *   **Serve Next Order:** Remove and display the details of the next order from the front of the `Queue`. If the queue is empty, display an appropriate message.
 *     *   **View Order Queue:** Display the details (Order ID and items) of all orders currently waiting in the `Queue`, without removing them. If the queue is empty, display an appropriate message.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a clear menu of available actions (e.g., "menu", "order", "serve", "queue", "exit").
 *     *   Use `System.out` for all standard output (prompts, menu display, order details, success messages).
 *     *   Use `System.err` for all error messages (invalid input, invalid menu item, empty queue for serving, etc.).
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands (menu, order, serve, queue, exit).
 *     *   Use appropriate loops for the main program loop and for adding items within the "Place Order" functionality.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, specifically `InputMismatchException` or `NumberFormatException` when reading or parsing integer input for menu item numbers.
 *     *   Handle cases like an empty queue when trying to serve.
 *     *   Handle invalid menu item numbers entered by the user.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Employ proper encapsulation (private fields, public methods) in the `Order` class and the main system class.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Structure the code logically with separate methods for different functionalities.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interactions:
 * 
 * ```
 * Restaurant Order System
 * Choose an action: menu, order, serve, queue, exit
 * > menu
 * --- Menu ---
 * 1. Pizza
 * 2. Burger
 * 3. Pasta
 * 4. Salad
 * 5. Drink
 * ------------
 * Choose an action: menu, order, serve, queue, exit
 * > order
 * Starting new order. Enter item numbers one by one. Type 'done' when finished.
 * Enter item number:
 * > 1
 * Added: Pizza
 * Enter item number:
 * > 3
 * Added: Pasta
 * Enter item number:
 * > 6
 * Error: Invalid item number. Please enter a number between 1 and 5.
 * Enter item number:
 * > two
 * Error: Invalid input. Please enter a number or 'done'.
 * Enter item number:
 * > done
 * Order 1 placed successfully with items: [Pizza, Pasta]
 * Choose an action: menu, order, serve, queue, exit
 * > queue
 * --- Current Order Queue ---
 * Order ID: 1, Items: [Pizza, Pasta]
 * ---------------------------
 * Choose an action: menu, order, serve, queue, exit
 * > serve
 * Serving Order ID: 1 with items: [Pizza, Pasta]
 * Choose an action: menu, order, serve, queue, exit
 * > serve
 * Error: The order queue is empty.
 * Choose an action: menu, order, serve, queue, exit
 * > queue
 * --- Current Order Queue ---
 * The order queue is empty.
 * ---------------------------
 * Choose an action: menu, order, serve, queue, exit
 * > exit
 * Exiting Restaurant Order System.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to the problem requirements and functionality.
 * *   Proper use of data structures and control flow.
 * *   Effective error handling and input validation.
 * *   Code quality, structure, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Processing System as described in the problem statement, utilizing all the required Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Order` class: Encapsulates the data for a single order (ID and list of items). It uses a `private List<String> items` field, initialized with an `ArrayList<String>`, demonstrating the use of both the interface and a concrete implementation. It provides public getter methods and a `toString` method for easy display.
 *     *   `RestaurantSystem` class: Contains the main logic. It holds the `menu` (a `List<String>`, implemented by `ArrayList`), the `orderQueue` (a `Queue<Order>`, implemented by `LinkedList`), the `nextOrderId` counter, and the `Scanner`. It has private methods for specific actions (`displayMenu`, `placeOrder`, `serveNextOrder`, `viewOrderQueue`) and a public `run` method that contains the main application loop.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue` (`java.util.Queue`): Used as the type for `orderQueue`. `LinkedList` is used as the concrete implementation because it supports the `Queue` interface and provides efficient FIFO operations. `offer()` is used to add orders, and `poll()` is used to retrieve and remove the next order. Iteration is done using an enhanced for loop, which implicitly uses an iterator, allowing viewing without removal.
 *     *   `ArrayList` (`java.util.ArrayList`): Used as the concrete implementation for the `menu` (declared as `List`) and within the `Order` class to store the list of items (`private List<String> items = new ArrayList<>()`).
 *     *   `List` interface (`java.util.List`): Used for declaring the type of the `menu` field (`private List<String> menu`) and the `items` field within the `Order` class (`private List<String> items`). This demonstrates programming to the interface, which is a best practice.
 *     *   `Scanner` (`java.util.Scanner`): An instance is created in the `RestaurantSystem` constructor and used in the `run` method to read user commands and in the `placeOrder` method to read item numbers or the "done" command.
 *     *   `switch` statement: Used in the `run` method to dispatch actions based on the user's command string.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid commands, invalid input formats, invalid menu item numbers, and attempting to serve from an empty queue.
 *     *   `System.out`: Used for all normal output, including prompts, the menu display, confirmation messages, and displaying order details.
 *     *   `try-catch` blocks:
 *         *   An inner `try-catch (NumberFormatException e)` block is used within the `placeOrder` method to specifically handle cases where the user enters non-integer input when an item number is expected.
 *         *   An outer `try-catch (Exception e)` block is placed around the main command processing loop within the `run` method. This provides a layer of class-wide exception handling to catch any unexpected runtime errors that might occur during the execution of a command, preventing the program from crashing. While more specific catches within methods are preferred for known issues (like `NumberFormatException`), this outer catch acts as a safety net.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Order` and `RestaurantSystem` are declared `private`. Public methods provide controlled access.
 *     *   **Meaningful Names:** Variables (`orderQueue`, `nextOrderId`, `itemNumber`, `servedOrder`), methods (`displayMenu`, `placeOrder`, `serveNextOrder`, `viewOrderQueue`), and classes (`Order`, `RestaurantSystem`) have names reflecting their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods. Inline comments explain specific logic where needed.
 *     *   **Input Validation:** The `placeOrder` method checks if the parsed item number is within the valid range of the menu size. It also handles the "done" command and ensures an order isn't placed if no valid items were added.
 *     *   **Error Handling:** Specific exceptions (`NumberFormatException`) are caught where input parsing occurs. Checks for empty queues are performed before attempting to serve. Error messages are informative and sent to `System.err`.
 *     *   **Clean Code Structure:** Logic is divided into well-defined methods, making the code modular and easier to understand. The main loop in `run` clearly shows the command-driven nature of the application.
 * 
 * This solution effectively integrates the required components into a functional system, demonstrating core Java programming skills suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single order placed by a customer.
 */
class Order {
    private int orderId;
    private List<String> items; // Use List interface, implemented by ArrayList

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for this order.
     */
    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // Use ArrayList for storing items
    }

    /**
     * Adds an item name to the order.
     * @param itemName The name of the item to add.
     */
    public void addItem(String itemName) {
        this.items.add(itemName);
    }

    /**
     * Gets the list of items in the order.
     * @return The list of item names.
     */
    public List<String> getItems() {
        return items; // Return the ArrayList via its List interface
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Provides a string representation of the order.
     * @return Formatted string with order ID and items.
     */
    @Override
    public String toString() {
        return "Order ID: " + orderId + ", Items: " + items;
    }
}

/**
 * The main class for the Restaurant Order Processing System.
 * Manages the menu, order queue, and user interaction.
 */
public class RestaurantSystem {

    private List<String> menu; // Use List interface
    private Queue<Order> orderQueue; // Use Queue interface
    private int nextOrderId;
    private Scanner scanner;

    /**
     * Constructs the RestaurantSystem, initializing menu and queue.
     */
    public RestaurantSystem() {
        // Initialize menu using ArrayList
        menu = new ArrayList<>();
        menu.add("Pizza");
        menu.add("Burger");
        menu.add("Pasta");
        menu.add("Salad");
        menu.add("Drink");

        // Initialize order queue using LinkedList for Queue implementation
        orderQueue = new LinkedList<>();
        nextOrderId = 1;
        scanner = new Scanner(System.in); // Initialize scanner here
    }

    /**
     * Displays the menu with item numbers.
     */
    private void displayMenu() {
        System.out.println("--- Menu ---");
        for (int i = 0; i < menu.size(); i++) {
            System.out.println((i + 1) + ". " + menu.get(i));
        }
        System.out.println("------------");
    }

    /**
     * Handles the process of placing a new order.
     */
    private void placeOrder() {
        System.out.println("Starting new order. Enter item numbers one by one. Type 'done' when finished.");

        Order currentOrder = new Order(nextOrderId);
        boolean addingItems = true;

        // Use try-catch around the item adding loop for broader handling
        try {
            while (addingItems) {
                System.out.println("Enter item number:");
                String input = scanner.nextLine().trim();

                if (input.equalsIgnoreCase("done")) {
                    addingItems = false;
                } else {
                    // Inner try-catch for parsing and validation of single item input
                    try {
                        int itemNumber = Integer.parseInt(input);
                        // Validate item number against menu size (1-based index)
                        if (itemNumber >= 1 && itemNumber <= menu.size()) {
                            String itemName = menu.get(itemNumber - 1);
                            currentOrder.addItem(itemName);
                            System.out.println("Added: " + itemName);
                        } else {
                            System.err.println("Error: Invalid item number. Please enter a number between 1 and " + menu.size() + ".");
                        }
                    } catch (NumberFormatException e) {
                        // Catch specific error for non-integer input
                        System.err.println("Error: Invalid input. Please enter a number or 'done'.");
                    }
                }
            }

            // After loop, check if any items were added before adding to queue
            if (!currentOrder.getItems().isEmpty()) {
                orderQueue.offer(currentOrder); // Add order to the queue
                System.out.println("Order " + nextOrderId + " placed successfully with items: " + currentOrder.getItems());
                nextOrderId++; // Increment for the next order
            } else {
                System.err.println("Error: No items added to the order. Order not placed.");
            }

        } catch (Exception e) {
             // Broader catch for unexpected errors during order placement
             System.err.println("An unexpected error occurred during order placement: " + e.getMessage());
             // Consider logging the full stack trace in a real application
             // e.printStackTrace();
        }
    }

    /**
     * Serves the next order from the queue.
     */
    private void serveNextOrder() {
        Order servedOrder = orderQueue.poll(); // Retrieve and remove the head of the queue

        if (servedOrder != null) {
            System.out.println("Serving " + servedOrder);
        } else {
            System.err.println("Error: The order queue is empty.");
        }
    }

    /**
     * Displays the orders currently waiting in the queue.
     */
    private void viewOrderQueue() {
        System.out.println("--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("The order queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) { // Enhanced for loop uses iterator
                System.out.println(order);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Runs the main interactive loop of the system.
     */
    public void run() {
        System.out.println("Restaurant Order System");
        boolean running = true;

        while (running) {
            System.out.println("Choose an action: menu, order, serve, queue, exit");
            System.out.print("> ");
            String command = scanner.nextLine().trim().toLowerCase(); // Read command

            // Use try-catch around the switch to catch exceptions propagated from actions
            try {
                switch (command) {
                    case "menu":
                        displayMenu();
                        break;
                    case "order":
                        placeOrder();
                        break;
                    case "serve":
                        serveNextOrder();
                        break;
                    case "queue":
                        viewOrderQueue();
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Restaurant Order System.");
                        break;
                    default:
                        System.err.println("Error: Unknown command. Please try again.");
                        break;
                }
            } catch (Exception e) {
                 // Catch any unhandled exception that might occur during a command execution
                 System.err.println("An unexpected error occurred while processing command '" + command + "': " + e.getMessage());
                 // In a real system, you might want more specific catches or logging
                 // e.printStackTrace();
            }
            System.out.println(); // Add a newline for better readability between commands
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
