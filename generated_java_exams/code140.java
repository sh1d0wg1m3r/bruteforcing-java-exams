/*
 * Exam Question #140
 * Generated on: 2025-05-11 22:20:36
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based Task Management System. This system will help a user manage a list of tasks that need to be completed. Tasks are added to a queue for processing in order. Once processed, they are moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (higher number = higher priority, though the queue processes by arrival time in this simple version).
 *     *   Include a constructor to initialize these fields and public getter methods for each field.
 * 
 * 2.  **Task Processor:** Create a class named `TaskProcessor` that manages the tasks. This class should have:
 *     *   Private fields to hold:
 *         *   A `Queue` of `Task` objects representing pending tasks.
 *         *   A `List` of `Task` objects representing completed tasks.
 *         *   An integer counter to generate unique task IDs.
 *     *   A constructor to initialize the data structures and the ID counter.
 *     *   Public methods for the following operations:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` with a unique ID and adds it to the pending task queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue and adds it to the completed task list. This method should handle the case where the pending queue is empty.
 *         *   `viewPendingTasks()`: Prints the details of all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Prints the details of all tasks currently in the completed task list.
 *     *   A `run()` method that implements the main application loop:
 *         *   Display a menu of options to the user (Add Task, Process Next, View Pending, View Completed, Exit).
 *         *   Read user input using `java.util.Scanner`.
 *         *   Use a `switch` statement to handle the user's menu choice.
 *         *   Call the appropriate `TaskProcessor` methods based on the choice.
 *         *   Implement robust error handling using `try-catch` blocks around the main loop or critical operations to catch potential runtime exceptions.
 *         *   Use `System.out` for normal output (menu, task lists, success messages).
 *         *   Use `System.err` for error messages (e.g., invalid input, attempting to process from an empty queue).
 * 
 * 3.  **Component Usage:** Ensure your solution explicitly uses and demonstrates the functionality of ALL the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList` (as the concrete implementation for the completed tasks `List`)
 *     *   `java.util.List` (as the type declaration for the completed tasks collection)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   Class-wide exception handling using `try-catch`
 * 
 * 4.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and basic documentation (e.g., method descriptions).
 *     *   Basic input validation (e.g., for menu choices).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and display results or error messages appropriately. Examples:
 * 
 * *   Adding a task should confirm the task was added.
 * *   Processing a task should indicate which task was processed or if the queue was empty.
 * *   Viewing lists should print task details or indicate if a list is empty.
 * *   Invalid menu input should result in an error message on `System.err`.
 * *   Attempting to process an empty queue should result in an error message on `System.err`.
 * 
 * **Constraint:** Focus on the core requirements and component usage. Keep the task details and priority logic simple (priority is stored but not used for processing order, as `Queue` processes by arrival).
 * 
 * **Time Estimate:** This task is designed to be challenging but solvable within 45-60 minutes by a student with advanced Java understanding.
 *
 * EXPLANATION:
 * This solution implements a simple Task Processing System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and `priority`.
 *     *   Fields are `private` for encapsulation.
 *     *   Provides a constructor and public getter methods (`getId`, `getDescription`, `getPriority`).
 *     *   Includes an overridden `toString()` method for easy printing of task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   **Data Structures:**
 *         *   `private Queue<Task> pendingTasks;`: Declared as `Queue`, instantiated as `LinkedList`. `LinkedList` implements `Queue`, providing FIFO (First-In, First-Out) behavior suitable for processing tasks in the order they are added.
 *         *   `private List<Task> completedTasks;`: Declared as `List`, instantiated as `ArrayList`. `ArrayList` is a dynamic array implementation of `List`, suitable for storing completed tasks where order might matter (though not strictly required by the problem, it's a common `List` implementation) and allows easy iteration.
 *         *   `private int nextTaskId;`: Used to generate unique IDs for new tasks, ensuring each task has a distinct identifier.
 *     *   **Constructor:** Initializes the `pendingTasks` queue (using `LinkedList`), the `completedTasks` list (using `ArrayList`), and sets `nextTaskId` to 1.
 *     *   **`addTask(String description, int priority)`:** Creates a new `Task` object using the `nextTaskId` and provided details, increments the ID counter, and adds the task to the `pendingTasks` queue using `offer()`. `offer()` is preferred over `add()` for queues as it handles capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained). Prints a confirmation message using `System.out`.
 *     *   **`processNextTask()`:** Attempts to remove the head of the `pendingTasks` queue using `poll()`. `poll()` returns the task or `null` if the queue is empty. If a task is retrieved (`processedTask != null`), it's added to the `completedTasks` list. If the queue was empty, it prints an error message to `System.err`. A `try-catch` block is included around the core logic to catch any unexpected exceptions during the process, demonstrating general error handling.
 *     *   **`viewPendingTasks()` and `viewCompletedTasks()`:** These methods iterate through the respective collections (`pendingTasks` and `completedTasks`) and print the details of each task using their `toString()` method. They check if the collection is empty and print a message if so. Output is directed to `System.out`.
 *     *   **`run()` Method:**
 *         *   Contains the main application loop (`while (choice != 0)`).
 *         *   Uses `Scanner` to read user input from the console.
 *         *   Displays the menu using `System.out`.
 *         *   Includes basic input validation to ensure the user enters a number for the menu choice. If not, it prints an error to `System.err` and consumes the invalid input.
 *         *   Uses a `switch` statement to dispatch based on the valid menu choice.
 *         *   Calls the appropriate task management methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`).
 *         *   Includes specific input validation within the `addTask` case to handle potential `InputMismatchException` when reading the priority integer, printing an error to `System.err`. It also checks for empty description.
 *         *   **Class-wide Exception Handling:** A `try-catch (Exception e)` block wraps the entire `while` loop. This provides a top-level handler for any unexpected runtime exceptions that might occur within the application's main execution flow, preventing the program from crashing abruptly and printing an error message to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   **`main()` Method:** The entry point of the program, which creates a `TaskProcessor` instance and calls its `run()` method to start the application.
 * 
 * This solution effectively utilizes all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, adheres to best practices like encapsulation and meaningful names, and includes basic error handling and input validation, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Specific exception for queue operations

// Represents a single task
class Task {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Public getter methods
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Priority=" + priority + "]";
    }
}

// Manages tasks using a queue for pending and a list for completed tasks
public class TaskProcessor {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessor, initializing task collections.
     */
    public TaskProcessor() {
        // LinkedList implements Queue and is suitable for this use case
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending task queue.
     * @param description The description of the new task.
     * @param priority The priority of the new task.
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // Use offer for adding to queue
        System.out.println("Added task: " + newTask.getDescription() + " (ID: " + newTask.getId() + ")");
    }

    /**
     * Processes the next task in the queue, moving it to the completed list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        try {
            // Use poll() which returns null if queue is empty, or remove() which throws NoSuchElementException
            // Let's use poll() for a cleaner check, but wrap in try-catch for NoSuchElementException
            // in case remove() was used or another queue implementation behaves differently.
            // Or specifically catch NoSuchElementException if using remove().
            // Let's use poll() and check for null, and demonstrate try-catch for other potential issues.
            Task processedTask = pendingTasks.poll(); // Retrieves and removes the head of this queue

            if (processedTask != null) {
                completedTasks.add(processedTask);
                System.out.println("Processed task: " + processedTask.getDescription() + " (ID: " + processedTask.getId() + ")");
            } else {
                // Use System.err for an operational error message
                System.err.println("Error: No pending tasks to process.");
            }
        } catch (Exception e) {
            // General catch for any unexpected errors during processing
            System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        }
    }

    /**
     * Prints details of all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate over the queue without removing elements
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------\n");
    }

    /**
     * Prints details of all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate over the list
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        System.out.println("--- Simple Task Processor ---");

        // Class-wide exception handling using try-catch around the main loop
        try {
            while (choice != 0) {
                printMenu();

                // Input validation for menu choice
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (integer): ");
                        int priority = 0;
                        try {
                             priority = scanner.nextInt();
                             scanner.nextLine(); // Consume newline
                             if (description == null || description.trim().isEmpty()) {
                                 System.err.println("Task description cannot be empty.");
                             } else {
                                 addTask(description.trim(), priority);
                             }
                        } catch (java.util.InputMismatchException e) {
                             System.err.println("Invalid priority input. Please enter an integer.");
                             scanner.nextLine(); // Consume the invalid input line
                        }
                        break;
                    case 2: // Process Next Task
                        processNextTask();
                        break;
                    case 3: // View Pending Tasks
                        viewPendingTasks();
                        break;
                    case 4: // View Completed Tasks
                        viewCompletedTasks();
                        break;
                    case 0: // Exit
                        System.out.println("Exiting Task Processor. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid menu option
                        System.err.println("Invalid choice. Please enter a number from the menu.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception during the main loop execution
            System.err.println("\nAn unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging the fatal error
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Helper method to print the menu
    private void printMenu() {
        System.out.println("\nChoose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
