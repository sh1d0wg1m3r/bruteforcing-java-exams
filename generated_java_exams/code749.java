/*
 * Exam Question #749
 * Generated on: 2025-05-12 16:35:18
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Kitchen Order System
 * 
 * **Objective:** Implement a simplified restaurant kitchen order management system that handles receiving, processing, and viewing orders. This task requires you to apply core Java concepts including collections, input/output, control flow, object-oriented principles, and exception handling.
 * 
 * **Scenario:** Orders are placed at the front desk and sent to the kitchen. The kitchen processes orders in the order they were received. Staff can view pending orders waiting to be processed and completed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Order Representation:** Create a class named `Order` to represent a single customer order.
 *     *   It must have private fields for `orderId` (an integer), `items` (a `List` of `String` representing the food items), and `status` (a `String`, e.g., "Pending", "Completed").
 *     *   Provide a constructor to initialize an order with an ID and a list of items. The initial status should be "Pending".
 *     *   Include public getter methods for all fields.
 *     *   Include a public method `markCompleted()` that changes the order's status to "Completed".
 *     *   Override the `toString()` method to provide a readable representation of the order (ID, items, status).
 * 
 * 2.  **System Management:** Create a class named `RestaurantOrderSystem` that manages the orders.
 *     *   Use a `Queue<Order>` to store orders that are pending processing in the kitchen (FIFO - First-In, First-Out).
 *     *   Use an `ArrayList<Order>` (which implements the `List` interface) to store orders that have been completed.
 *     *   Implement a main loop that presents a menu of options to the user:
 *         1.  Add New Order
 *         2.  Process Next Pending Order
 *         3.  View Pending Orders
 *         4.  View Completed Orders
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read the user's menu choice and order details.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 3.  **Functionality Details:**
 *     *   **Add New Order:** Prompt the user to enter a comma-separated list of items for the order. Generate a unique `orderId` for each new order (e.g., starting from 1 and incrementing). Create an `Order` object and add it to the pending orders `Queue`.
 *     *   **Process Next Pending Order:** Take the next order from the front of the pending `Queue`. If an order exists, mark it as completed using the `markCompleted()` method and move it to the completed orders `List`. If no orders are pending, inform the user.
 *     *   **View Pending Orders:** Display all orders currently in the pending `Queue` along with their details. Do *not* remove orders from the queue when viewing.
 *     *   **View Completed Orders:** Display all orders currently in the completed orders `List` along with their details.
 * 
 * 4.  **Input/Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, order details, and success messages.
 *     *   Use `System.err` to report error conditions (e.g., invalid menu choice, no pending orders to process).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks around the main processing loop to gracefully handle potential issues, particularly `InputMismatchException` if the user enters non-numeric input for the menu choice, and other unexpected errors. Ensure the `Scanner` is properly managed (e.g., closed).
 *     *   Include basic input validation where appropriate (e.g., checking if the items list is empty, although the primary focus is on demonstrating the required components and error handling structure).
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation in the `Order` class.
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 *     *   Ensure code is well-formatted and readable.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, performing actions, and providing feedback or error messages. Example interaction might look like:
 * 
 * ```
 * --- Restaurant Kitchen System ---
 * 1. Add New Order
 * 2. Process Next Pending Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter order items (comma-separated): Burger, Fries, Coke
 * Order 1 added to pending queue.
 * 
 * --- Restaurant Kitchen System ---
 * 1. Add New Order
 * ...
 * Enter your choice: 3
 * --- Pending Orders ---
 * Order ID: 1, Items: [Burger, Fries, Coke], Status: Pending
 * ----------------------
 * 
 * --- Restaurant Kitchen System ---
 * ...
 * Enter your choice: 2
 * Order 1 processed and moved to completed.
 * 
 * --- Restaurant Kitchen System ---
 * ...
 * Enter your choice: 4
 * --- Completed Orders ---
 * Order ID: 1, Items: [Burger, Fries, Coke], Status: Completed
 * ------------------------
 * 
 * --- Restaurant Kitchen System ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Restaurant Kitchen System ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please try again.
 * 
 * --- Restaurant Kitchen System ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * System shutdown complete.
 * ```
 * 
 * **Evaluation Criteria:**
 * *   Correct implementation of the `Order` class with encapsulation.
 * *   Proper use of `Queue` for pending orders and `List`/`ArrayList` for completed orders.
 * *   Effective use of `Scanner` for user input.
 * *   Correct implementation of the menu and `switch` statement.
 * *   Appropriate use of `System.out` and `System.err`.
 * *   Robust exception handling using `try-catch`, specifically addressing `InputMismatchException` and general errors, covering the main operational flow.
 * *   Adherence to best practices (naming, comments, structure).
 * *   Successful execution of all menu options.
 *
 * EXPLANATION:
 * This solution provides a complete implementation of the Restaurant Kitchen Order System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Order` Class:**
 *     *   Encapsulates order data (`orderId`, `items`, `status`) using private fields.
 *     *   Provides public getters for controlled access.
 *     *   Includes a `markCompleted()` method to change the status, adhering to encapsulation.
 *     *   Uses `ArrayList` internally for `items` and creates copies in the constructor and getter to prevent external modification of the internal list state.
 *     *   Overrides `toString()` for easy display.
 * 
 * 2.  **`RestaurantOrderSystem` Class:**
 *     *   Uses a `LinkedList` (which implements `Queue`) for `pendingOrders` to naturally handle the First-In, First-Out processing requirement of a kitchen queue. `offer()` is used to add to the tail, and `poll()` is used to remove from the head.
 *     *   Uses an `ArrayList` (which implements `List`) for `completedOrders`, as simple storage and iteration are needed for completed items.
 *     *   `nextOrderId` provides a simple mechanism for generating unique IDs.
 *     *   The `runSystem()` method contains the main application logic within a `try-with-resources` block for the `Scanner`, ensuring it's closed automatically.
 * 
 * 3.  **Functionality:**
 *     *   `displayMenu()` uses `System.out` to show options.
 *     *   `addOrder()` reads a comma-separated string using `scanner.nextLine()`, splits it, trims whitespace from items, creates an `Order` object, and adds it to the `pendingOrders` queue using `offer()`. Includes a basic check for empty input.
 *     *   `processNextPendingOrder()` uses `pendingOrders.poll()` to get and remove the next order. It checks if the result is `null` (queue was empty) and uses `System.err` if so. Otherwise, it marks the order completed and adds it to `completedOrders`.
 *     *   `viewPendingOrders()` iterates through the `pendingOrders` queue. To avoid removing elements while viewing, it creates a temporary `ArrayList` from the queue. This is a common pattern to safely iterate or process queue elements without altering the queue's state during the iteration. `System.out` is used for display.
 *     *   `viewCompletedOrders()` iterates through the `completedOrders` list using a standard enhanced for loop and `System.out` for display.
 * 
 * 4.  **Input/Output and Error Handling:**
 *     *   `System.out` is used for all normal output (menu, prompts, confirmations, order details).
 *     *   `System.err` is used for error messages (invalid choice, no pending orders, input errors).
 *     *   A large `try-catch(Exception e)` block wraps the main `while(running)` loop in `runSystem()`. This provides class-wide exception handling for any unexpected errors that might occur during the system's execution, printing an error message and the stack trace using `System.err`.
 *     *   An inner `try-catch(InputMismatchException e)` block is used specifically when reading the integer menu choice (`scanner.nextInt()`). This catches non-numeric input, prints an error using `System.err`, consumes the invalid input line (`scanner.nextLine()`) to prevent an infinite loop, and uses `continue` to restart the loop iteration, prompting the user again.
 *     *   The `finally` block within the main `try-catch` ensures that the "System shutdown complete" message is printed regardless of whether the loop exited normally or due to an exception. The `Scanner` is closed by the outer `try-with-resources`.
 *     *   The `switch` statement directs the flow based on the validated user input. The `default` case handles invalid numeric choices using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful class, method, and variable names are used (e.g., `pendingOrders`, `processNextPendingOrder`).
 *     *   Comments explain the purpose of classes, methods, and important code sections.
 *     *   Code structure is clean with separate methods for different actions.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, demonstrating intermediate to advanced Java programming skills including collections usage, object-oriented design, input handling, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Arrays;

// Represents a single customer order
class Order {
    private int orderId;
    private List<String> items;
    private String status; // "Pending" or "Completed"

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for the order.
     * @param items The list of items in the order.
     */
    public Order(int orderId, List<String> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a copy to ensure encapsulation
        this.status = "Pending";
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public List<String> getItems() {
        return new ArrayList<>(items); // Return a copy to prevent external modification
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the order as completed.
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return String.format("Order ID: %d, Items: %s, Status: %s", orderId, items, status);
    }
}

// Manages the restaurant kitchen order system
public class RestaurantOrderSystem {

    private Queue<Order> pendingOrders;
    private List<Order> completedOrders;
    private int nextOrderId;

    /**
     * Constructs a new RestaurantOrderSystem.
     */
    public RestaurantOrderSystem() {
        // Use LinkedList as a Queue implementation
        this.pendingOrders = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedOrders = new ArrayList<>();
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Restaurant Kitchen System ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Pending Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new order to the pending queue based on user input.
     * @param scanner The Scanner object for reading input.
     */
    private void addOrder(Scanner scanner) {
        System.out.println("Enter order items (comma-separated):");
        String itemsInput = scanner.nextLine().trim(); // Read the whole line

        if (itemsInput.isEmpty()) {
            System.err.println("Error: Items list cannot be empty.");
            return;
        }

        // Split input string by comma and trim whitespace from each item
        List<String> items = new ArrayList<>(Arrays.asList(itemsInput.split(",")));
        items.replaceAll(String::trim); // Trim whitespace from each item

        Order newOrder = new Order(nextOrderId++, items);
        pendingOrders.offer(newOrder); // Add to the end of the queue
        System.out.println("Order " + newOrder.getOrderId() + " added to pending queue.");
    }

    /**
     * Processes the next order from the pending queue (FIFO).
     * Moves the processed order to the completed list.
     */
    private void processNextPendingOrder() {
        Order orderToProcess = pendingOrders.poll(); // Retrieve and remove the head of the queue

        if (orderToProcess != null) {
            orderToProcess.markCompleted();
            completedOrders.add(orderToProcess); // Add to the completed list
            System.out.println("Order " + orderToProcess.getOrderId() + " processed and moved to completed.");
        } else {
            System.err.println("No pending orders to process.");
        }
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            // Creating a temporary list is a safe way to iterate over Queue elements
            List<Order> pendingListForView = new ArrayList<>(pendingOrders);
            for (Order order : pendingListForView) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all orders currently in the completed list.
     */
    private void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main system loop, handling user interaction and exceptions.
     */
    public void runSystem() {
        // Use try-with-resources for the Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;
            // Class-wide exception handling for the main operational loop
            try {
                while (running) {
                    displayMenu();
                    int choice = -1; // Initialize choice outside the try block

                    // Inner try-catch for reading integer choice to handle InputMismatchException
                    try {
                        choice = scanner.nextInt();
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip the rest of the loop iteration
                    } finally {
                         scanner.nextLine(); // Consume the rest of the line after reading the integer
                    }


                    // Use switch for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addOrder(scanner);
                            break;
                        case 2:
                            processNextPendingOrder();
                            break;
                        case 3:
                            viewPendingOrders();
                            break;
                        case 4:
                            viewCompletedOrders();
                            break;
                        case 5:
                            running = false; // Set flag to exit the loop
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please try again.");
                    }
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions during system operation
                System.err.println("An unexpected error occurred during system operation: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            } finally {
                 // This block will execute when the try block is exited (normally or via exception)
                 // but the Scanner is closed by the outer try-with-resources
                 System.out.println("System shutdown complete.");
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    // Main method to start the application
    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.runSystem();
    }
}
