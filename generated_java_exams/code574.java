/*
 * Exam Question #574
 * Generated on: 2025-05-11 23:31:23
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Emergency Response Dispatch System
 * 
 * **Objective:** Design and implement a simplified Emergency Response Dispatch System using core Java data structures and control flow mechanisms. This task requires you to demonstrate your understanding of queues, lists, user input handling, exception management, and basic object-oriented principles.
 * 
 * **Scenario:**
 * You are building a system to manage incoming emergency calls and dispatch available response units. The system needs to keep track of calls waiting for dispatch and the status of available units.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store incoming emergency calls that are waiting to be dispatched (FIFO - First-In, First-Out).
 *     *   Use an `ArrayList` to store a collection of dispatch units.
 *     *   Declare variables holding the list of units using the `List` interface type.
 * 
 * 2.  **Classes:**
 *     *   Create a class `EmergencyCall` with properties like `id`, `description`, and `status` (e.g., WAITING, DISPATCHED).
 *     *   Create a class `DispatchUnit` with properties like `id` and `status` (e.g., AVAILABLE, BUSY).
 *     *   Create a class `DispatchSystem` that manages the `Queue` of calls and the `List` of units. This class should contain the core logic for adding calls, dispatching units, and marking units available.
 *     *   Create a main application class (e.g., `EmergencyDispatchApp`) that handles user interaction via a menu.
 * 
 * 3.  **Functionality (via `EmergencyDispatchApp` menu):**
 *     *   **1. Add New Emergency Call:** Prompt the user for a description of the emergency. Create a new `EmergencyCall` object, assign a unique ID, set its status to WAITING, and add it to the incoming calls queue.
 *     *   **2. Dispatch Unit to Next Call:**
 *         *   Check if there are any calls in the queue. If not, print a message using `System.out`.
 *         *   Check if there are any AVAILABLE dispatch units. If not, print a message using `System.out`.
 *         *   If both are available, take the next call from the front of the queue (`poll()` operation).
 *         *   Find the first AVAILABLE unit in the list.
 *         *   Change the call's status to DISPATCHED.
 *         *   Change the unit's status to BUSY.
 *         *   Print a confirmation message using `System.out` indicating which unit was dispatched to which call.
 *     *   **3. Mark Unit Available:**
 *         *   Prompt the user for the ID of the unit to mark available.
 *         *   Find the unit in the list by its ID.
 *         *   If the unit is found and its status is BUSY, change its status to AVAILABLE and print a confirmation using `System.out`.
 *         *   If the unit is not found, print an error message using `System.err`.
 *         *   If the unit is found but already AVAILABLE, print a message using `System.out`.
 *     *   **4. Display System Status:** Print the current status:
 *         *   Number of calls waiting in the queue.
 *         *   Details of each call waiting in the queue (ID, description).
 *         *   Status of each dispatch unit (ID, status).
 *     *   **5. Exit:** Terminate the application.
 * 
 * 4.  **User Input:** Use `java.util.Scanner` to read user input for menu choices, call descriptions, and unit IDs.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options. Use a loop to keep the menu running until the user chooses to exit.
 * 
 * 6.  **Error Handling:**
 *     *   Implement input validation for menu choices (e.g., ensure input is an integer within the valid range). Use `try-catch` blocks to handle potential `NumberFormatException` when reading integer input.
 *     *   Use `System.err.println()` to output error messages (e.g., invalid input, unit not found).
 *     *   Use `System.out.println()` for all normal output (menu, prompts, confirmations, status).
 *     *   Include a class-wide `try-catch` block in the main application class to catch any unexpected exceptions during the execution loop and print an error message to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Use private fields and public methods for encapsulation in your classes.
 *     *   Choose meaningful names for variables, methods, and classes.
 *     *   Add comments and Javadoc where appropriate to explain your code.
 *     *   Handle edge cases (e.g., empty queue, no available units, invalid unit ID).
 * 
 * **Initial State:**
 * *   The system should start with an empty incoming calls queue.
 * *   The system should start with a predefined set of 3-5 `DispatchUnit` objects, all initially `AVAILABLE`.
 * 
 * **Expected Output:**
 * The program should display a menu, accept user input, perform actions based on the input, and print relevant status or error messages to the console (`System.out` or `System.err`).
 * 
 * **Evaluation:** Your solution will be evaluated based on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper implementation of object-oriented principles (encapsulation, class design).
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust input validation and exception handling (`try-catch`).
 * *   Correct implementation of the required functionality and logic.
 * *   Code clarity, readability, and adherence to best practices.
 * 
 * ---
 * **Note:** You are expected to provide the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * This solution implements the Emergency Response Dispatch System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `incomingCalls` is declared as `Queue<EmergencyCall>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing the necessary FIFO behavior (`offer` to add, `poll` to remove from the head).
 *     *   `dispatchUnits` is declared as `List<DispatchUnit>` and initialized with `new ArrayList<>()`. This follows the best practice of programming to the interface (`List`) rather than the concrete implementation (`ArrayList`). `ArrayList` is suitable here for storing and accessing units by index or iterating.
 * 
 * 2.  **Classes and Encapsulation:**
 *     *   `EmergencyCall` and `DispatchUnit` are simple POJO-like classes representing the core entities. They have private fields (`id`, `description`, `status`) and public getter/setter methods, adhering to encapsulation principles. Enums (`CallStatus`, `UnitStatus`) are used for clarity and type safety of status values.
 *     *   `DispatchSystem` encapsulates the system's state (`incomingCalls`, `dispatchUnits`) and the logic for managing calls and units (`addCall`, `dispatchNextCall`, `markUnitAvailable`, `displaySystemStatus`). This separates the business logic from the user interface.
 *     *   `EmergencyDispatchApp` is the main class responsible for setting up the system, handling user input via `Scanner`, displaying the menu, and controlling the application flow using a `switch` statement within a loop.
 * 
 * 3.  **Functionality:**
 *     *   The `DispatchSystem` methods implement the core logic:
 *         *   `addCall`: Creates a new `EmergencyCall` with a unique ID and adds it to the `incomingCalls` queue using `offer()`.
 *         *   `dispatchNextCall`: Checks if the queue is empty and if any units are available. If both conditions are met, it retrieves (and removes) the next call using `poll()`, finds the first available unit by iterating through the `dispatchUnits` list, and updates their statuses.
 *         *   `markUnitAvailable`: Iterates through the `dispatchUnits` list to find the unit by ID. It validates if the unit exists and is currently `BUSY` before changing its status to `AVAILABLE`. Error messages are printed to `System.err` if the unit is not found.
 *         *   `displaySystemStatus`: Iterates through the `incomingCalls` queue and the `dispatchUnits` list to print their current states. It uses the `size()` method for the queue and iterates through both collections to display details.
 * 
 * 4.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     *   A `Scanner` object is used in `EmergencyDispatchApp` to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user enters the exit option.
 *     *   A `switch` statement processes the user's menu choice, calling the appropriate `DispatchSystem` method or performing the exit action.
 * 
 * 5.  **Error Handling (`System.err`, `System.out`, `try-catch`):**
 *     *   `System.err.println()` is used specifically for printing error messages, such as invalid unit ID, missing call description, or invalid numeric input.
 *     *   `System.out.println()` is used for all normal output, including the menu, prompts, confirmations, and system status display.
 *     *   Input validation is performed for menu choices and unit IDs using `try-catch(InputMismatchException)` blocks to handle non-integer input gracefully, preventing program crashes and infinite loops caused by the `Scanner`.
 *     *   A class-wide `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method of `EmergencyDispatchApp`. This demonstrates catching any unexpected runtime exception that might occur within the main application logic and printing its stack trace to `System.err`, providing a robust outer layer of error handling. A `finally` block ensures the `Scanner` is closed.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names (`incomingCalls`, `dispatchNextCall`, `markUnitAvailable`, `EmergencyCall`, `UnitStatus`).
 *     *   Comments and Javadoc explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation and specific error messages improve usability.
 *     *   The code is structured into logical classes, separating concerns.
 *     *   Initial units are created in the `DispatchSystem` constructor.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating core programming concepts, object-oriented design, and error handling techniques suitable for an advanced exam question.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Call Status
enum CallStatus {
    WAITING, DISPATCHED
}

// Enum for Unit Status
enum UnitStatus {
    AVAILABLE, BUSY
}

/**
 * Represents an emergency call.
 */
class EmergencyCall {
    private int id;
    private String description;
    private CallStatus status;

    /**
     * Constructs a new EmergencyCall.
     * @param id The unique ID for the call.
     * @param description A brief description of the emergency.
     */
    public EmergencyCall(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = CallStatus.WAITING; // New calls are always WAITING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public CallStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(CallStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Call [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Represents a dispatch unit.
 */
class DispatchUnit {
    private int id;
    private UnitStatus status;

    /**
     * Constructs a new DispatchUnit.
     * @param id The unique ID for the unit.
     */
    public DispatchUnit(int id) {
        this.id = id;
        this.status = UnitStatus.AVAILABLE; // Units start as AVAILABLE
    }

    // Getters
    public int getId() {
        return id;
    }

    public UnitStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(UnitStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Unit [ID=" + id + ", Status=" + status + "]";
    }
}

/**
 * Manages the emergency dispatch operations.
 */
class DispatchSystem {
    // Use Queue for FIFO incoming calls
    private Queue<EmergencyCall> incomingCalls;
    // Use List interface, implemented by ArrayList, for dispatch units
    private List<DispatchUnit> dispatchUnits;
    private int nextCallId = 1; // Counter for unique call IDs

    /**
     * Constructs a DispatchSystem with initial units.
     * @param numberOfUnits The number of dispatch units to create initially.
     */
    public DispatchSystem(int numberOfUnits) {
        incomingCalls = new LinkedList<>(); // LinkedList implements Queue
        dispatchUnits = new ArrayList<>(); // ArrayList implements List

        // Initialize dispatch units
        for (int i = 1; i <= numberOfUnits; i++) {
            dispatchUnits.add(new DispatchUnit(i));
        }
        System.out.println("Dispatch System initialized with " + numberOfUnits + " units.");
    }

    /**
     * Adds a new emergency call to the queue.
     * @param description The description of the emergency.
     */
    public void addCall(String description) {
        EmergencyCall newCall = new EmergencyCall(nextCallId++, description);
        incomingCalls.offer(newCall); // offer() is preferred over add() for capacity-constrained queues, but fine here.
        System.out.println("New call added: " + newCall.toString());
    }

    /**
     * Attempts to dispatch an available unit to the next waiting call.
     * @return true if a call was dispatched, false otherwise.
     */
    public boolean dispatchNextCall() {
        // Check if there are calls waiting
        if (incomingCalls.isEmpty()) {
            System.out.println("No calls waiting for dispatch.");
            return false;
        }

        // Find an available unit
        DispatchUnit availableUnit = null;
        for (DispatchUnit unit : dispatchUnits) {
            if (unit.getStatus() == UnitStatus.AVAILABLE) {
                availableUnit = unit;
                break; // Found the first available unit
            }
        }

        // Check if an available unit was found
        if (availableUnit == null) {
            System.out.println("No dispatch units currently available.");
            return false;
        }

        // Dispatch the call
        EmergencyCall callToDispatch = incomingCalls.poll(); // Get and remove the head of the queue

        if (callToDispatch != null) { // Should not be null based on isEmpty() check, but good practice
            callToDispatch.setStatus(CallStatus.DISPATCHED);
            availableUnit.setStatus(UnitStatus.BUSY);
            System.out.println("Dispatched " + availableUnit.toString() + " to " + callToDispatch.toString());
            // Note: Dispatched calls are removed from the queue in this simple model.
            // In a real system, they might move to a 'dispatched' list.
            return true;
        }
        return false; // Should not reach here if isEmpty() check passes
    }

    /**
     * Marks a specific unit as available if it was busy.
     * @param unitId The ID of the unit to mark available.
     * @return true if the unit was successfully marked available, false otherwise (not found, or already available).
     */
    public boolean markUnitAvailable(int unitId) {
        DispatchUnit targetUnit = null;
        for (DispatchUnit unit : dispatchUnits) {
            if (unit.getId() == unitId) {
                targetUnit = unit;
                break;
            }
        }

        if (targetUnit == null) {
            System.err.println("Error: Unit with ID " + unitId + " not found.");
            return false;
        }

        if (targetUnit.getStatus() == UnitStatus.BUSY) {
            targetUnit.setStatus(UnitStatus.AVAILABLE);
            System.out.println("Unit " + unitId + " is now AVAILABLE.");
            return true;
        } else {
            System.out.println("Unit " + unitId + " is already AVAILABLE.");
            return false;
        }
    }

    /**
     * Displays the current status of the system.
     */
    public void displaySystemStatus() {
        System.out.println("\n--- System Status ---");

        System.out.println("Calls Waiting (" + incomingCalls.size() + "):");
        if (incomingCalls.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate without removing elements using a for-each loop or stream
             incomingCalls.forEach(call -> System.out.println("  " + call));
            // Alternatively, using a standard for-each loop:
            // for (EmergencyCall call : incomingCalls) {
            //     System.out.println("  " + call);
            // }
        }

        System.out.println("\nDispatch Unit Status:");
        if (dispatchUnits.isEmpty()) {
             System.out.println("  (No units configured)");
        } else {
             dispatchUnits.forEach(unit -> System.out.println("  " + unit));
            // Alternatively:
            // for (DispatchUnit unit : dispatchUnits) {
            //     System.out.println("  " + unit);
            // }
        }
        System.out.println("---------------------\n");
    }
}

/**
 * Main application class for the Emergency Response Dispatch System.
 * Handles user interaction and menu.
 */
public class EmergencyDispatchApp {

    private DispatchSystem system;
    private Scanner scanner;

    /**
     * Constructs the application.
     */
    public EmergencyDispatchApp() {
        // Initialize system with 5 units
        system = new DispatchSystem(5);
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch block wrapping the main application loop
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character

                    switch (choice) {
                        case 1:
                            System.out.print("Enter emergency description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Description cannot be empty.");
                            } else {
                                system.addCall(description.trim());
                            }
                            break;
                        case 2:
                            system.dispatchNextCall();
                            break;
                        case 3:
                            System.out.print("Enter Unit ID to mark available: ");
                            try {
                                int unitId = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                system.markUnitAvailable(unitId);
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input. Please enter a number for Unit ID.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;
                        case 4:
                            system.displaySystemStatus();
                            break;
                        case 5:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            System.out.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number for the menu choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop and re-prompt
                }
                System.out.println(); // Add a newline for spacing
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }

    /**
     * Prints the main menu options.
     */
    private void printMenu() {
        System.out.println("--- Emergency Dispatch Menu ---");
        System.out.println("1. Add New Emergency Call");
        System.out.println("2. Dispatch Unit to Next Call");
        System.out.println("3. Mark Unit Available");
        System.out.println("4. Display System Status");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EmergencyDispatchApp app = new EmergencyDispatchApp();
        app.run();
    }
}
