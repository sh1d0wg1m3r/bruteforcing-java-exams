/*
 * Exam Question #1067
 * Generated on: 2025-05-12 17:20:15
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified customer support ticket management system. The system should allow support agents to add new incoming tickets, process the oldest pending ticket, and view lists of both pending and processed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of **pending tickets** that must be processed in the order they were received (First-In, First-Out).
 *     *   Maintain a collection of **processed tickets** as a historical record.
 * 2.  **Functionality:**
 *     *   **Add Ticket:** Allow the user to enter a description for a new ticket. The system should automatically assign a unique ID and add it to the pending queue.
 *     *   **Process Next Ticket:** Take the oldest ticket from the pending queue, mark it as processed, and move it to the processed list. Handle the case where there are no pending tickets.
 *     *   **View Pending Tickets:** Display all tickets currently in the pending queue.
 *     *   **View Processed Tickets:** Display all tickets that have been processed.
 *     *   **Exit:** Terminate the program.
 * 3.  **User Interface:**
 *     *   Present a menu of options to the user.
 *     *   Use `java.util.Scanner` to read user input (menu choices and ticket descriptions).
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Error Handling:**
 *     *   Implement input validation for menu choices (e.g., ensure it's a number within the valid range).
 *     *   Handle the scenario where the user attempts to process a ticket when the pending queue is empty, printing an informative message to `System.err`.
 *     *   Use `System.err` for all error messages.
 *     *   Use `System.out` for all normal output (menu, prompts, successful operations, ticket lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially around user input or unexpected issues.
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (including class-wide handling)
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments for clarity.
 *     *   Ensure resources like `Scanner` are properly managed (e.g., using try-with-resources).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or error messages. Ticket output should clearly show the ID, Status, and Description.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Support System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * ---------------------------
 * 
 * Enter your choice: 1
 * Enter ticket description: Internet connection issue
 * 
 * Ticket added: Ticket [ID=1, Status=PENDING, Description='Internet connection issue']
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Software crash on startup
 * 
 * Ticket added: Ticket [ID=2, Status=PENDING, Description='Software crash on startup']
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket [ID=1, Status=PENDING, Description='Internet connection issue']
 * Ticket [ID=2, Status=PENDING, Description='Software crash on startup']
 * -----------------------
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Ticket processed: Ticket [ID=1, Status=PROCESSED, Description='Internet connection issue']
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket [ID=2, Status=PENDING, Description='Software crash on startup']
 * -----------------------
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Processed Tickets ---
 * Ticket [ID=1, Status=PROCESSED, Description='Internet connection issue']
 * -------------------------
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Ticket processed: Ticket [ID=2, Status=PROCESSED, Description='Software crash on startup']
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tickets to process.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Support System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a basic Support Ticket Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single support ticket.
 *     *   Uses `private` fields (`id`, `description`, `status`) for encapsulation.
 *     *   A `static int nextId` is used to automatically generate unique IDs for each ticket instance, simulating a real-world ID generation mechanism.
 *     *   Provides `public` getter methods to access ticket information.
 *     *   Includes a `setStatus` method, demonstrating controlled modification of the object's state.
 *     *   Overrides `toString()` for easy printing of ticket details.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   Acts as the main controller for the system.
 *     *   **`Queue<Ticket> pendingTickets`**: This field uses the `Queue` interface, implemented by `LinkedList`. It stores tickets that are waiting to be processed. The `Queue` guarantees FIFO (First-In, First-Out) order, which is essential for processing the oldest tickets first. Methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used for Queue operations.
 *     *   **`List<Ticket> processedTickets`**: This field uses the `List` interface, implemented by `ArrayList`. It stores tickets after they have been processed. An `ArrayList` is suitable here as it provides a dynamic, ordered collection for historical records, allowing easy iteration and storage.
 *     *   **`Scanner scanner`**: An instance of `Scanner` is used to read user input from the console (`System.in`). It's managed within the class and passed to the constructor, or in this case, created and managed via try-with-resources in `main`.
 *     *   **`addTicket()`**: Prompts the user for a description, creates a new `Ticket` object, validates the input (checks for empty description), and adds it to the `pendingTickets` queue using `offer()`.
 *     *   **`processNextTicket()`**: Retrieves the next ticket from the `pendingTickets` queue using `poll()`. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful error handling without throwing an exception. If a ticket is found, its status is updated, and it's added to the `processedTickets` list. An error message is printed to `System.err` if the queue is empty.
 *     *   **`viewPendingTickets()` and `viewProcessedTickets()`**: These methods iterate through the respective collections (`pendingTickets` and `processedTickets`) and print the details of each ticket using the `Ticket` class's `toString()` method. They check if the collections are empty before iterating. Iterating over the `Queue` (like done here with a for-each loop) does not remove elements, which is the desired behavior for viewing.
 *     *   **`displayMenu()`**: A private helper method to print the user menu to `System.out`.
 *     *   **`run()`**: This is the main application loop.
 *         *   It uses a `while(running)` loop to keep the system active until the user chooses to exit.
 *         *   A **class-wide `try-catch(Exception e)`** block wraps the main `while` loop. This provides a safety net to catch any unexpected exceptions that might occur during the program's execution, preventing the program from crashing abruptly and printing the error details to `System.err`.
 *         *   Inside the loop, it displays the menu and reads the user's choice using the `Scanner`.
 *         *   **Input Validation and Error Handling:** It attempts to parse the input string to an integer within a nested `try-catch(NumberFormatException e)`. If parsing fails, an error is printed to `System.err`, and `continue` is used to restart the loop, prompting the user again.
 *         *   A **`switch` statement** is used to cleanly handle the user's valid integer choices (1-5), calling the corresponding methods.
 *         *   The `default` case of the `switch` handles integer inputs that are outside the valid menu range (1-5), printing an error to `System.err`.
 *     *   **`main(String[] args)`**: The entry point of the application.
 *         *   It uses a **`try-with-resources` block** to create and manage the `Scanner`. This ensures that the `Scanner` is automatically closed when the block is exited, regardless of whether an exception occurred or not.
 *         *   It creates an instance of `SupportSystem` and calls its `run()` method to start the main application loop.
 *         *   A `catch` block is included here as well, primarily to handle potential issues during the initialization phase (like Scanner creation), although the `try-with-resources` handles the closing aspect.
 * 
 * This solution effectively integrates all the required Java components to build a functional, albeit simple, system while adhering to good programming practices like encapsulation, input validation, and robust error handling. The use of `Queue` for pending items and `List` for historical data correctly reflects their typical use cases.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single customer support ticket.
 */
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs
    private final int id; // Ticket ID
    private final String description; // Description of the issue
    private String status; // Current status (e.g., PENDING, PROCESSED)

    // Constants for status
    public static final String STATUS_PENDING = "PENDING";
    public static final String STATUS_PROCESSED = "PROCESSED";

    /**
     * Constructs a new Ticket with a description.
     * Automatically assigns a unique ID and sets status to PENDING.
     * @param description The description of the ticket issue.
     */
    public Ticket(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = STATUS_PENDING; // New tickets are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status ---
    /**
     * Sets the status of the ticket.
     * Only allows setting to PROCESSED in this simplified model.
     * @param status The new status.
     */
    public void setStatus(String status) {
        // Basic validation: only allow setting to PROCESSED
        if (STATUS_PROCESSED.equals(status)) {
            this.status = status;
        } else {
            // In a real system, more robust status transitions would be needed.
            // For this exam, we'll just print a warning for invalid attempts.
            System.err.println("Warning: Attempted to set invalid ticket status '" + status + "' for Ticket ID " + this.id);
        }
    }

    /**
     * Returns a string representation of the Ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the collection of pending and processed support tickets.
 * Handles user interaction via a menu.
 */
public class SupportSystem {

    // --- Data Structures ---
    // Queue for pending tickets (FIFO processing)
    private Queue<Ticket> pendingTickets;
    // List for processed tickets (historical record)
    private List<Ticket> processedTickets;

    // --- Input Scanner ---
    private Scanner scanner;

    /**
     * Constructs a new SupportSystem.
     * Initializes the data structures and takes a Scanner for input.
     * @param scanner The Scanner object to use for reading user input.
     */
    public SupportSystem(Scanner scanner) {
        // Using LinkedList as an implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.processedTickets = new ArrayList<>();
        this.scanner = scanner;
    }

    // --- Core System Operations ---

    /**
     * Adds a new ticket based on user input description.
     */
    public void addTicket() {
        System.out.println("Enter ticket description:");
        // Read the full line for description
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit method if description is invalid
        }

        Ticket newTicket = new Ticket(description.trim()); // Create new ticket
        pendingTickets.offer(newTicket); // Add to the end of the pending queue (offer is preferred over add in queues)
        System.out.println("Ticket added: " + newTicket);
    }

    /**
     * Processes the next ticket from the pending queue.
     * Moves the processed ticket to the processed list.
     */
    public void processNextTicket() {
        // Retrieve and remove the head of the queue (FIFO)
        Ticket ticketToProcess = pendingTickets.poll(); // poll() returns null if queue is empty

        if (ticketToProcess == null) {
            // Handle the case where the queue is empty
            System.err.println("Error: No pending tickets to process.");
            return; // Exit method if queue is empty
        }

        // Update the ticket status
        ticketToProcess.setStatus(Ticket.STATUS_PROCESSED);
        // Add the processed ticket to the historical list
        processedTickets.add(ticketToProcess);

        System.out.println("Ticket processed: " + ticketToProcess);
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Displays all tickets that have been moved to the processed list.
     */
    public void viewProcessedTickets() {
        System.out.println("\n--- Processed Tickets ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No processed tickets.");
        } else {
            // Iterate through the list
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------\n");
    }

    // --- Menu and Main Loop ---

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
        System.out.println("---------------------------\n");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and dispatching actions.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();
                String choiceStr = scanner.nextLine(); // Read the user's menu choice as a string

                int choice = -1; // Default invalid choice

                // Input validation: Check if input is a valid integer
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // If parsing fails, print an error and continue the loop
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip the switch statement and show the menu again
                }

                // Use a switch statement to handle valid choices
                switch (choice) {
                    case 1:
                        addTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewProcessedTickets();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Support System. Goodbye!");
                        break;
                    default:
                        // Handle choices that are numbers but not in the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur during execution
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } finally {
            // The Scanner resource management is handled by the try-with-resources in the main method.
            // No explicit scanner.close() needed here if main uses try-with-resources.
        }
    }

    /**
     * Main method to start the Support System application.
     * Uses try-with-resources to ensure the Scanner is closed.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is automatically closed
        try (Scanner systemScanner = new Scanner(System.in)) {
            SupportSystem system = new SupportSystem(systemScanner);
            system.run(); // Start the main system loop
        } catch (Exception e) {
            // Catch exceptions that might occur during Scanner creation or initial setup
            System.err.println("System initialization failed: " + e.getMessage());
            e.printStackTrace(System.err);
        }
    }
}
