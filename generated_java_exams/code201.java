/*
 * Exam Question #201
 * Generated on: 2025-05-11 22:30:51
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Clinic Patient Management System
 * 
 * **Objective:** Implement a simplified Clinic Patient Management System that handles patient check-in and processing using various Java data structures and control flow mechanisms.
 * 
 * **Scenario:** Patients arrive at a specialized clinic and first need to check in. They are added to a check-in queue in the order they arrive (First-In, First-Out). A receptionist processes patients from this queue one by one. Once processed, the patient is moved to a list of "active" patients, indicating they are now waiting to be seen by a doctor or are undergoing preliminary checks. The system should allow adding patients, processing the next patient, viewing the check-in queue, and viewing the list of active patients.
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Representation:** Create a `Patient` class with private fields for `id` (String), `name` (String), and `reasonForVisit` (String). Include a constructor and public getter methods for these fields. Override the `toString()` method to provide a clear string representation of a `Patient` object.
 * 2.  **Clinic System Class:** Create a `ClinicSystem` class that manages the patient flow.
 *     *   It must have a private field `checkInQueue` of type `java.util.Queue<Patient>`. Use a concrete implementation like `java.util.LinkedList`.
 *     *   It must have a private field `activePatients` of type `java.util.List<Patient>`. Use a concrete implementation like `java.util.ArrayList`.
 *     *   It must have a private field `scanner` of type `java.util.Scanner` for user input.
 * 3.  **Functionality:** The `ClinicSystem` class must provide the following public methods, accessible via a menu-driven interface:
 *     *   `addPatientToQueue()`: Prompts the user for patient details (ID, Name, Reason), creates a `Patient` object, and adds it to the `checkInQueue`. Implement basic input validation (e.g., ensure ID and Name are not empty).
 *     *   `processNextPatient()`: Removes the patient at the front of the `checkInQueue` and adds them to the `activePatients` list. If the queue is empty, display an error message.
 *     *   `viewCheckInQueue()`: Displays the details of all patients currently in the `checkInQueue` without removing them.
 *     *   `viewActivePatients()`: Displays the details of all patients currently in the `activePatients` list.
 *     *   `displayMenu()`: Prints the main menu options to `System.out`.
 *     *   `run()`: Contains the main application loop. Displays the menu, reads user input, and calls the appropriate method based on the input using a `switch` statement. The loop should continue until the user chooses to exit.
 * 4.  **Required Java Components:** Your solution *must* explicitly use *all* of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for normal output, menu, confirmations, list displays)
 *     *   Class-wide or method-level `try-catch` blocks for exception handling (e.g., handling invalid input in the menu choice).
 * 5.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments (including Javadoc for classes/methods).
 *     *   Input validation (as mentioned in `addPatientToQueue`).
 *     *   Proper error handling using `try-catch` and `System.err`.
 *     *   Clean code structure (separate `Patient` and `ClinicSystem` classes).
 * 6.  **Execution:** The program should start by creating a `ClinicSystem` instance and calling its `run()` method.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 1
 * Enter Patient ID: P001
 * Enter Patient Name: Alice
 * Enter Reason for Visit: Fever
 * Patient P001 added to check-in queue.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 1
 * Enter Patient ID: P002
 * Enter Patient Name: Bob
 * Enter Reason for Visit: Checkup
 * Patient P002 added to check-in queue.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 3
 * --- Check-in Queue ---
 * Patient ID: P001, Name: Alice, Reason: Fever
 * Patient ID: P002, Name: Bob, Reason: Checkup
 * -----------------------
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 2
 * Processing patient from check-in queue...
 * Patient P001 processed and moved to active patients.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 3
 * --- Check-in Queue ---
 * Patient ID: P002, Name: Bob, Reason: Checkup
 * -----------------------
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 4
 * --- Active Patients ---
 * Patient ID: P001, Name: Alice, Reason: Fever
 * -----------------------
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 2
 * Processing patient from check-in queue...
 * Patient P002 processed and moved to active patients.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 2
 * Processing patient from check-in queue...
 * Error: The check-in queue is empty. No patients to process.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Clinic Management Menu ---
 * 1. Add Patient to Check-in Queue
 * 2. Process Next Patient
 * 3. View Check-in Queue
 * 4. View Active Patients
 * 5. Exit
 * Enter your choice: 5
 * Exiting Clinic Management System.
 * ```
 * 
 * **Note:** Focus on demonstrating the required Java components and best practices. Complex features like persistence, multiple clinics, or detailed patient history are not required.
 *
 * EXPLANATION:
 * The provided solution implements the `Clinic Patient Management System` as described in the problem statement, demonstrating the required advanced Java concepts and best practices.
 * 
 * 1.  **`Patient` Class:** This simple class serves as a data model for a patient. It uses private fields (`id`, `name`, `reasonForVisit`) and public getter methods, adhering to the principle of encapsulation. The `toString()` method is overridden for easy printing of patient details.
 * 
 * 2.  **`ClinicSystem` Class:** This is the core class managing the system's logic.
 *     *   **Data Structures:**
 *         *   `private Queue<Patient> checkInQueue;`: Declared using the `Queue` interface and initialized with a `LinkedList`. This correctly models the First-In, First-Out (FIFO) nature of a check-in queue.
 *         *   `private List<Patient> activePatients;`: Declared using the `List` interface and initialized with an `ArrayList`. This structure allows storing patients who have been processed from the queue and provides dynamic resizing. Using the `List` interface for the declaration is a best practice (programming to the interface).
 *     *   **`Scanner`:** `private Scanner scanner;` is used to read user input from the console (`System.in`). It's initialized in the constructor and closed in a `finally` block in the `run` method to release system resources.
 *     *   **Constructor:** Initializes the `checkInQueue` (as `LinkedList`), `activePatients` (as `ArrayList`), and `scanner`.
 * 
 * 3.  **Functionality Methods:**
 *     *   `addPatientToQueue()`: Prompts the user for patient details. It uses `scanner.nextLine()` to read input. Basic input validation is performed using `.trim().isEmpty()` checks, and error messages for empty required fields are printed to `System.err`. A new `Patient` object is created and added to the `checkInQueue` using `offer()`, which is a safe way to add to a queue (though `add()` would also work here).
 *     *   `processNextPatient()`: This method demonstrates the core queue operation. It uses `checkInQueue.poll()` to retrieve and remove the patient at the head of the queue. `poll()` is preferred over `remove()` because it returns `null` if the queue is empty, allowing for graceful error handling without throwing an exception. If a patient is retrieved, they are added to the `activePatients` list using `add()`. If the queue was empty, an error message is printed to `System.err`.
 *     *   `viewCheckInQueue()`: Iterates through the `checkInQueue` using a for-each loop (which utilizes the queue's iterator) and prints each patient's details using their `toString()` method. It checks if the queue is empty and prints a message accordingly. Output goes to `System.out`.
 *     *   `viewActivePatients()`: Iterates through the `activePatients` `List` using a for-each loop and prints each patient's details. It checks if the list is empty and prints a message accordingly. Output goes to `System.out`.
 *     *   `displayMenu()`: Simply prints the menu options to `System.out`.
 * 
 * 4.  **`run()` Method and Control Flow:**
 *     *   This method contains the main application loop (`while (choice != 5)`).
 *     *   Inside the loop, `displayMenu()` is called, and user input is read using `scanner.nextLine()`.
 *     *   **Exception Handling (`try-catch`):** A `try-catch` block is used around the input processing and the `switch` statement. It specifically catches `NumberFormatException` if the user enters non-integer input when prompted for a choice. Error messages are printed to `System.err`. This demonstrates class-level or method-level exception handling for robust input processing. A `finally` block ensures the `scanner` is closed when the `run` method finishes (either normally or due to an unhandled exception).
 *     *   **`switch` Statement:** The parsed integer `choice` is used in a `switch` statement to direct the program flow to the corresponding method (`addPatientToQueue`, `processNextPatient`, etc.). A `default` case handles invalid integer inputs, printing an error to `System.err`.
 * 
 * 5.  **Main Method:** The `main` method is the entry point. It creates an instance of `ClinicSystem` and calls its `run()` method to start the application.
 * 
 * **Summary of Required Component Usage:**
 * 
 * *   `Queue`: Used for `checkInQueue` (implemented by `LinkedList`).
 * *   `ArrayList`: Used as the concrete implementation for the `activePatients` `List`.
 * *   `List`: Used as the interface type for declaring `activePatients`.
 * *   `Scanner`: Used in the `ClinicSystem` class to read user input from `System.in`.
 * *   `switch`: Used in the `run()` method to handle menu choices.
 * *   `System.err`: Used for printing all error messages (invalid input, empty queue, validation errors).
 * *   `System.out`: Used for printing the menu, confirmations, and contents of the queues/lists.
 * *   `try-catch`: Used in the `run()` method to handle potential `NumberFormatException` during input parsing and generally protect the main loop.
 * 
 * The solution adheres to best practices by using encapsulation, meaningful names, comments (including Javadoc), input validation, and clear error handling, making it a challenging yet well-structured problem demonstrating advanced Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // Although poll() is safer than remove()

/**
 * Represents a patient in the clinic system.
 */
class Patient {
    private String id;
    private String name;
    private String reasonForVisit;

    /**
     * Constructs a new Patient object.
     *
     * @param id The unique identifier for the patient.
     * @param name The name of the patient.
     * @param reasonForVisit The reason for the patient's visit.
     */
    public Patient(String id, String name, String reasonForVisit) {
        this.id = id;
        this.name = name;
        this.reasonForVisit = reasonForVisit;
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getReasonForVisit() {
        return reasonForVisit;
    }

    /**
     * Provides a string representation of the Patient.
     * @return A formatted string with patient details.
     */
    @Override
    public String toString() {
        return String.format("Patient ID: %s, Name: %s, Reason: %s", id, name, reasonForVisit);
    }
}

/**
 * Manages the patient flow in the clinic system.
 * Handles check-in queue and active patient list.
 */
public class ClinicSystem {
    // Required: Queue for check-in
    private Queue<Patient> checkInQueue;
    // Required: List (using ArrayList) for active patients
    private List<Patient> activePatients;
    // Required: Scanner for user input
    private Scanner scanner;

    /**
     * Constructs a new ClinicSystem, initializing data structures and scanner.
     */
    public ClinicSystem() {
        // Initialize required data structures
        this.checkInQueue = new LinkedList<>(); // LinkedList implements Queue
        this.activePatients = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Clinic Management Menu ---");
        System.out.println("1. Add Patient to Check-in Queue");
        System.out.println("2. Process Next Patient");
        System.out.println("3. View Check-in Queue");
        System.out.println("4. View Active Patients");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the check-in queue based on user input.
     * Includes basic input validation.
     */
    private void addPatientToQueue() {
        System.out.println("--- Add New Patient ---");
        String id;
        String name;
        String reason;

        // Input validation loop for ID
        do {
            System.out.print("Enter Patient ID: ");
            id = scanner.nextLine().trim();
            if (id.isEmpty()) {
                System.err.println("Error: Patient ID cannot be empty.");
            }
        } while (id.isEmpty());

        // Input validation loop for Name
        do {
            System.out.print("Enter Patient Name: ");
            name = scanner.nextLine().trim();
            if (name.isEmpty()) {
                System.err.println("Error: Patient Name cannot be empty.");
            }
        } while (name.isEmpty());

        System.out.print("Enter Reason for Visit: ");
        reason = scanner.nextLine().trim(); // Reason can be empty

        Patient newPatient = new Patient(id, name, reason);

        // Add to the queue
        if (checkInQueue.offer(newPatient)) { // offer() is safer than add() as it doesn't throw exception if queue is full (though LinkedList won't be full)
            System.out.println("Patient " + id + " added to check-in queue.");
        } else {
             // This case is unlikely with LinkedList, but good practice for general Queue
             System.err.println("Error: Could not add patient to queue.");
        }
    }

    /**
     * Processes the next patient in the check-in queue, moving them to the active list.
     * Handles the case where the queue is empty.
     */
    private void processNextPatient() {
        System.out.println("Processing patient from check-in queue...");
        // Use poll() which returns null if queue is empty, safer than remove()
        Patient nextPatient = checkInQueue.poll();

        if (nextPatient != null) {
            activePatients.add(nextPatient); // Add to the active list
            System.out.println("Patient " + nextPatient.getId() + " processed and moved to active patients.");
        } else {
            // Required: Use System.err for error message
            System.err.println("Error: The check-in queue is empty. No patients to process.");
        }
    }

    /**
     * Displays the contents of the check-in queue without removing elements.
     */
    private void viewCheckInQueue() {
        System.out.println("--- Check-in Queue ---");
        if (checkInQueue.isEmpty()) {
            System.out.println("The check-in queue is empty.");
        } else {
            // Iterate through the queue. peek() or iterator can be used.
            // Iterating is better to show all elements clearly.
            // Using for-each loop on the queue is fine as it uses the iterator
            for (Patient patient : checkInQueue) {
                System.out.println(patient); // Uses Patient's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the contents of the active patients list.
     */
    private void viewActivePatients() {
        System.out.println("--- Active Patients ---");
        if (activePatients.isEmpty()) {
            System.out.println("The active patients list is empty.");
        } else {
            // Iterate through the list
            for (Patient patient : activePatients) {
                System.out.println(patient); // Uses Patient's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes exception handling for input.
     */
    public void run() {
        int choice = 0;
        // Required: Class-wide or method-level try-catch
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    // Read the entire line to handle potential non-integer input gracefully
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input); // Attempt to parse to integer

                    // Required: Use switch statement for flow control
                    switch (choice) {
                        case 1:
                            addPatientToQueue();
                            break;
                        case 2:
                            processNextPatient();
                            break;
                        case 3:
                            viewCheckInQueue();
                            break;
                        case 4:
                            viewActivePatients();
                            break;
                        case 5:
                            System.out.println("Exiting Clinic Management System.");
                            break;
                        default:
                            // Required: Use System.err for error message
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Required: Use System.err for error message
                    System.err.println("Error: Invalid input. Please enter a number.");
                }
                // No need for specific NoSuchElementException catch here because poll() returns null
                // and other operations (add, offer) on LinkedList/ArrayList don't typically throw it
                // for normal usage unless resource limits are hit, which is not expected in this context.
            }
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Clinic System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ClinicSystem system = new ClinicSystem();
        system.run();
    }
}
