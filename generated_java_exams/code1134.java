/*
 * Exam Question #1134
 * Generated on: 2025-05-12 17:29:42
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Ticket Management System
 * 
 * **Scenario:** You are tasked with building a simple command-line application to manage support tickets for a technical service department. The system should allow users to submit new tickets, process the oldest pending ticket, view all pending tickets, and see available service types.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following criteria:
 * 
 * 1.  **Core Functionality:**
 *     *   Present a menu to the user with options to:
 *         *   Submit a new support ticket.
 *         *   Process the next ticket in the queue (First-In, First-Out).
 *         *   View all currently pending tickets.
 *         *   View a list of available service types.
 *         *   Exit the application.
 *     *   Tickets should have a unique ID, a description, and a service type.
 *     *   Maintain a list of predefined valid service types.
 * 
 * 2.  **Java Components:** Your solution **must** use all of the following Java components from the `java.util` package or standard Java language features:
 *     *   `java.util.Queue`: To store and manage the pending support tickets in a FIFO manner.
 *     *   `java.util.ArrayList`: To implement the list of available service types.
 *     *   `java.util.List`: Declare the collection of service types using the `List` interface.
 *     *   `java.util.Scanner`: To read all user input from the console.
 *     *   `switch` statement: To control the flow of the main menu based on user choice.
 *     *   `System.err`: To print all error messages (e.g., invalid input, empty queue, invalid service type).
 *     *   `System.out`: To print all normal output (menu, prompts, success messages, ticket details, lists).
 *     *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, particularly for user input, to prevent the program from crashing on invalid data.
 * 
 * 3.  **Best Practices:**
 *     *   Apply proper encapsulation by making class fields private and providing public methods where necessary.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments or basic documentation to explain key parts of the code.
 *     *   Implement input validation (e.g., check if the entered service type is valid, handle non-integer menu input).
 *     *   Ensure proper error handling using the required `System.err` for error output.
 *     *   Structure your code cleanly with separate methods for different functionalities.
 * 
 * **Expected Output:**
 * 
 * The program should start by displaying a menu. Based on user input, it should perform the corresponding action.
 * - Submitting a ticket should prompt for description and type, validate the type, and confirm submission.
 * - Processing a ticket should remove and display the oldest one, or show an error if none are pending.
 * - Viewing tickets should list all pending tickets in order, or state that none are pending.
 * - Viewing service types should display the predefined list.
 * - Invalid menu choices or invalid service types should result in an error message printed to `System.err`.
 * - Non-integer input for the menu choice should be caught and reported as an error to `System.err`, allowing the program to continue.
 * - Normal operation messages and data displays should use `System.out`.
 * 
 * Your solution should be a single Java file containing all necessary classes (an inner static class for `Ticket` is acceptable).
 *
 * EXPLANATION:
 * This solution implements a basic Technical Support Ticket Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Ticket Class:** A simple `Ticket` class is defined to encapsulate the data for each support ticket (ID, description, service type). It includes a constructor and getter methods, adhering to encapsulation principles. The `toString()` method provides a convenient way to display ticket information.
 * 
 * 2.  **SupportTicketSystem Class:** This is the main class containing the application logic.
 *     *   **Fields:**
 *         *   `ticketQueue`: Declared as `Queue<Ticket>`, it is initialized using `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for managing tickets in the order they are received.
 *         *   `serviceTypes`: Declared as `List<String>` and initialized with `new ArrayList<>()`. This demonstrates the use of the `List` interface with an `ArrayList` implementation to store the predefined, fixed list of valid service types.
 *         *   `scanner`: An instance of `Scanner` connected to `System.in` is used to read all user input from the console.
 *         *   `nextTicketId`: An integer counter to generate unique IDs for new tickets.
 *     *   **Constructor:** Initializes the `ticketQueue`, `serviceTypes` list (by calling `initializeServiceTypes`), `scanner`, and `nextTicketId`.
 *     *   **`initializeServiceTypes()`:** A private helper method to populate the `serviceTypes` list with initial values.
 *     *   **`displayMenu()`:** Prints the interactive menu options to `System.out`.
 *     *   **`submitTicket()`:** Prompts the user for ticket details using `Scanner`. It validates the entered service type against the `serviceTypes` list using the `contains()` method. If valid, a new `Ticket` object is created, added to the `ticketQueue` using `offer()`, and a success message is printed to `System.out`. If the service type is invalid, an error message is printed to `System.err`.
 *     *   **`processNextTicket()`:** Checks if the `ticketQueue` is empty. If not, it removes the oldest ticket from the queue using `poll()` (which retrieves and removes the head of the queue) and prints its details to `System.out`. If the queue is empty, an error message is printed to `System.err`.
 *     *   **`viewPendingTickets()`:** Checks if the `ticketQueue` is empty. If not, it iterates through the queue (using a for-each loop, which uses the queue's iterator) and prints each pending ticket's details to `System.out`. It does not remove elements from the queue. If empty, it prints a message to `System.out`.
 *     *   **`viewServiceTypes()`:** Simply prints the contents of the `serviceTypes` list to `System.out`.
 *     *   **`run()`:** This method contains the main application loop. It repeatedly displays the menu, reads user input, and processes the choice.
 *         *   It uses a `while` loop that continues until the user enters '5' (Exit).
 *         *   **Exception Handling:** A `try-catch` block wraps the `scanner.nextInt()` call and the `switch` statement. This is the core "class-wide" exception handling requested.
 *             *   It specifically catches `InputMismatchException` which occurs if the user enters non-integer input when an integer is expected. Upon catching this, it prints an error to `System.err`, and `scanner.next()` is called to consume the invalid input token, preventing an infinite loop. The `choice` variable is reset to ensure the loop continues and the menu is redisplayed.
 *             *   A general `catch (Exception e)` is included to catch any other unexpected runtime errors, printing a generic error message and the exception details to `System.err`.
 *         *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the valid integer `choice` read from the user, calling the appropriate method (`submitTicket`, `processNextTicket`, etc.). The `default` case handles valid integer inputs that do not correspond to a menu option, printing an error to `System.err`.
 *         *   The `Scanner` is closed when the loop terminates (application exits).
 *     *   **`main()`:** The entry point of the application. It creates an instance of `SupportTicketSystem` and calls its `run()` method to start the system.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, while adhering to best practices like encapsulation, meaningful names, and input validation with appropriate error reporting.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a support ticket in the system.
 */
class Ticket {
    private int id;
    private String description;
    private String serviceType;

    /**
     * Constructs a new Ticket.
     * @param id The unique identifier for the ticket.
     * @param description A brief description of the issue.
     * @param serviceType The category of the issue (e.g., Software, Hardware).
     */
    public Ticket(int id, String description, String serviceType) {
        this.id = id;
        this.description = description;
        this.serviceType = serviceType;
    }

    // Getters for the ticket properties
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getServiceType() {
        return serviceType;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return A formatted string showing ticket details.
     */
    @Override
    public String toString() {
        return "Ticket ID: " + id + ", Type: " + serviceType + ", Description: \"" + description + "\"";
    }
}

/**
 * Manages support tickets using a queue system.
 */
public class SupportTicketSystem {

    // Required: Queue to hold pending tickets (FIFO)
    private Queue<Ticket> ticketQueue;

    // Required: List interface, implemented by ArrayList, for service types
    private List<String> serviceTypes;

    // Required: Scanner for reading user input
    private Scanner scanner;

    // Counter for generating unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new SupportTicketSystem.
     * Initializes collections, scanner, and service types.
     */
    public SupportTicketSystem() {
        // Use LinkedList as a Queue implementation
        ticketQueue = new LinkedList<>(); // Required: Queue implementation

        // Use ArrayList as a List implementation
        serviceTypes = new ArrayList<>(); // Required: ArrayList implementation

        scanner = new Scanner(System.in);
        nextTicketId = 1;

        initializeServiceTypes();
    }

    /**
     * Populates the list of available service types.
     */
    private void initializeServiceTypes() {
        serviceTypes.add("Software Issue");
        serviceTypes.add("Hardware Problem");
        serviceTypes.add("Network Error");
        serviceTypes.add("Account Management");
        serviceTypes.add("Other");
    }

    /**
     * Displays the main menu options to the user.
     * Required: Uses System.out
     */
    private void displayMenu() {
        System.out.println("\n--- Technical Support System Menu ---"); // Required: System.out
        System.out.println("1. Submit New Ticket"); // Required: System.out
        System.out.println("2. Process Next Ticket"); // Required: System.out
        System.out.println("3. View All Pending Tickets"); // Required: System.out
        System.out.println("4. View Available Service Types"); // Required: System.out
        System.out.println("5. Exit"); // Required: System.out
        System.out.print("Enter your choice: "); // Required: System.out
    }

    /**
     * Handles submitting a new ticket based on user input.
     * Prompts for description and service type, validates type, adds to queue.
     * Required: Uses System.out, System.err, List, Queue, Scanner
     */
    private void submitTicket() {
        System.out.println("\n--- Submit New Ticket ---"); // Required: System.out

        // Consume the leftover newline character from previous nextInt() if any
        scanner.nextLine();

        System.out.print("Enter ticket description: "); // Required: System.out
        String description = scanner.nextLine();

        System.out.println("Available Service Types: " + serviceTypes); // Required: System.out
        System.out.print("Enter service type: "); // Required: System.out
        String serviceType = scanner.nextLine();

        // Input validation: Check if the entered service type is valid
        if (!serviceTypes.contains(serviceType)) { // Required: Uses List (via serviceTypes)
            System.err.println("Error: Invalid service type. Ticket not submitted."); // Required: System.err
            return;
        }

        Ticket newTicket = new Ticket(nextTicketId++, description, serviceType);
        ticketQueue.offer(newTicket); // Add the new ticket to the queue (Required: Uses Queue)
        System.out.println("Ticket submitted successfully: " + newTicket); // Required: System.out
    }

    /**
     * Processes (removes and displays) the next ticket in the queue.
     * Required: Uses System.out, System.err, Queue
     */
    private void processNextTicket() {
        System.out.println("\n--- Process Next Ticket ---"); // Required: System.out
        if (ticketQueue.isEmpty()) {
            System.err.println("Error: No pending tickets to process."); // Required: System.err
        } else {
            Ticket ticketToProcess = ticketQueue.poll(); // Remove the head of the queue (Required: Uses Queue)
            System.out.println("Processing ticket: " + ticketToProcess); // Required: System.out
            // In a real system, further processing logic would go here
        }
    }

    /**
     * Displays all tickets currently waiting in the queue.
     * Required: Uses System.out, Queue
     */
    private void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---"); // Required: System.out
        if (ticketQueue.isEmpty()) {
            System.out.println("No tickets are currently pending."); // Required: System.out
        } else {
            System.out.println("Currently " + ticketQueue.size() + " ticket(s) pending:"); // Required: System.out
            // Iterate through the queue without removing elements
            int index = 1;
            for (Ticket ticket : ticketQueue) { // Iterating over the Queue (Required: Uses Queue)
                System.out.println(index++ + ". " + ticket); // Required: System.out
            }
        }
    }

    /**
     * Displays the list of available service types.
     * Required: Uses System.out, List
     */
    private void viewServiceTypes() {
         System.out.println("\n--- Available Service Types ---"); // Required: System.out
         System.out.println(serviceTypes); // Required: Uses List (via serviceTypes), System.out
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     * Includes class-wide exception handling for input.
     * Required: Uses Scanner, switch, try-catch, System.out, System.err
     */
    public void run() {
        int choice = -1; // Initialize with a value that won't match a menu option

        // Main application loop
        while (choice != 5) {
            displayMenu();

            // Required: Class-wide exception handling with try-catch
            try {
                // Read user's menu choice
                choice = scanner.nextInt(); // Potential InputMismatchException

                // Required: Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        submitTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                         viewServiceTypes();
                         break;
                    case 5:
                        System.out.println("Exiting Technical Support System. Goodbye!"); // Required: System.out
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Required: System.err
                }
            } catch (InputMismatchException e) { // Catch non-integer input specifically
                System.err.println("Error: Invalid input. Please enter a number."); // Required: System.err
                scanner.next(); // Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to ensure the loop continues and re-prompts
            } catch (Exception e) { // Catch any other unexpected runtime exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage()); // Required: System.err
                 // e.printStackTrace(); // Uncomment for detailed debugging if needed
                 // Decide how to handle unexpected errors - here we print and continue
            }
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     */
    public static void main(String[] args) {
        SupportTicketSystem system = new SupportTicketSystem();
        system.run();
    }
}
