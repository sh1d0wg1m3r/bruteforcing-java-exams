/*
 * Exam Question #472
 * Generated on: 2025-05-11 23:16:12
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Delivery System Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line simulation for a package delivery system. The system needs to manage packages waiting for delivery, assign them to drivers, and track their delivery status.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features and constraints:
 * 
 * 1.  **Package Management:**
 *     *   Packages have a unique integer ID (greater than 0) and a destination (String).
 *     *   Packages initially enter a waiting queue.
 *     *   Packages can be assigned to drivers. Once assigned, they are removed from the waiting queue.
 *     *   Packages can be marked as delivered.
 * 
 * 2.  **Driver Management:**
 *     *   Drivers have a unique integer ID (greater than 0) and a name (String).
 *     *   Drivers are assigned a list of package IDs they are responsible for delivering (their "route").
 * 
 * 3.  **System Operations:**
 *     *   The system should maintain a queue of package IDs waiting for assignment and a list of all registered drivers, each with their assigned route.
 *     *   The system should also keep track of all packages ever added to know their status (PENDING, ASSIGNED, DELIVERED).
 * 
 * 4.  **User Interface:**
 *     *   The program must accept commands from the user via `java.util.Scanner`.
 *     *   Commands should be processed using a `switch` statement.
 *     *   Supported commands:
 *         *   `ADD_PACKAGE <packageId> <destination>`: Adds a new package to the pending queue. Validate ID uniqueness and positive value.
 *         *   `ADD_DRIVER <driverId> <driverName>`: Adds a new driver. Validate ID uniqueness and positive value.
 *         *   `ASSIGN_ROUTE <driverId> <packageId1> <packageId2> ...`: Assigns a list of package IDs to a driver's route. Each package ID must exist, be currently in the pending queue, and be removed from the queue upon successful assignment. If any package ID is invalid or not pending, print an error for that specific ID and skip it, but continue processing the rest of the list.
 *         *   `PROCESS_DELIVERY <driverId> <packageId>`: Marks a specific package as delivered. The package must exist, be currently assigned to the specified driver's route, and be removed from the driver's route upon successful delivery.
 *         *   `VIEW_STATUS`: Displays the current state of the system:
 *             *   List all packages in the pending queue.
 *             *   List all drivers and their assigned package IDs.
 *             *   List the status of all packages ever added (ID, Destination, Status).
 *         *   `EXIT`: Terminates the program.
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` to print error messages for invalid commands, invalid input formats, non-existent IDs (driver or package), packages not found in the pending queue when assigning, packages not found on a driver's route when processing delivery, duplicate IDs, etc.
 *     *   Use `System.out` for prompts, successful operation confirmations, and status displays.
 *     *   Implement class-wide exception handling using a `try-catch` block in the `main` method to catch unexpected errors during the program execution.
 * 
 * 6.  **Required Java Components:** Your solution *must* explicitly use:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as an interface type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` block (at the class level in `main`)
 * 
 * 7.  **Best Practices:**
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Validate user input thoroughly.
 * 
 * **Expected Output Format:**
 * 
 * *   Command prompts: `Enter command: `
 * *   Successful operations: Clear confirmation messages (e.g., `Package <ID> added.`, `Driver <ID> added.`, `Route assigned to Driver <ID>.`, `Package <ID> delivered by Driver <ID>.`).
 * *   Error messages: Printed to `System.err` with a clear description of the error.
 * *   `VIEW_STATUS` output: Clearly formatted lists for pending queue, drivers/routes, and all package statuses.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command: ADD_PACKAGE 101 NewYork
 * Package 101 added.
 * Enter command: ADD_PACKAGE 102 London
 * Package 102 added.
 * Enter command: ADD_DRIVER 10 John_Doe
 * Driver 10 added.
 * Enter command: VIEW_STATUS
 * --- System Status ---
 * Pending Packages (IDs): [101, 102]
 * Drivers:
 *   ID: 10, Name: John_Doe, Route: []
 * All Packages:
 *   ID: 101, Destination: NewYork, Status: PENDING
 *   ID: 102, Destination: London, Status: PENDING
 * --- End Status ---
 * Enter command: ASSIGN_ROUTE 10 101 999 102
 * Error: Package ID 999 not found or not pending. Skipping.
 * Route assigned to Driver 10.
 * Enter command: VIEW_STATUS
 * --- System Status ---
 * Pending Packages (IDs): []
 * Drivers:
 *   ID: 10, Name: John_Doe, Route: [101, 102]
 * All Packages:
 *   ID: 101, Destination: NewYork, Status: ASSIGNED
 *   ID: 102, Destination: London, Status: ASSIGNED
 * --- End Status ---
 * Enter command: PROCESS_DELIVERY 10 101
 * Package 101 delivered by Driver 10.
 * Enter command: PROCESS_DELIVERY 10 103
 * Error: Package ID 103 not found on Driver 10's route.
 * Enter command: VIEW_STATUS
 * --- System Status ---
 * Pending Packages (IDs): []
 * Drivers:
 *   ID: 10, Name: John_Doe, Route: [102]
 * All Packages:
 *   ID: 101, Destination: NewYork, Status: DELIVERED
 *   ID: 102, Destination: London, Status: ASSIGNED
 * --- End Status ---
 * Enter command: EXIT
 * Exiting Delivery System.
 * ```
 * 
 * Your code should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the `DeliverySystem` simulation using the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Package` class: Represents a package with `id`, `destination`, and `status` (an enum `PackageStatus`). It includes a constructor, getters, a status setter, `toString()`, and overrides `equals()` and `hashCode()` based on the unique ID. Encapsulation is achieved by making fields private and providing public methods for access/modification.
 *     *   `Driver` class: Represents a driver with `id`, `name`, and a `route` which is a `List<Integer>` storing the IDs of assigned packages. It uses `ArrayList` to implement the `List` interface. It provides methods to add/remove package IDs from the route and check if an ID is on the route. Encapsulation is followed.
 *     *   `DeliverySystem` class: This is the main class managing the system state.
 *         *   `Map<Integer, Package> allPackages`: A `HashMap` is used to store all packages created, keyed by their ID. This allows for quick O(1) lookup of any package by ID, regardless of its current status or location (queue or driver).
 *         *   `Queue<Integer> pendingPackageIds`: A `LinkedList` is used to implement the `Queue` interface. It stores the IDs of packages that are currently waiting to be assigned to a driver. Using `Integer` IDs here simplifies queue management compared to storing `Package` objects, as we can quickly check existence and remove by ID.
 *         *   `List<Driver> drivers`: An `ArrayList` is used to implement the `List` interface, storing all registered `Driver` objects.
 *         *   Methods like `addPackage`, `addDriver`, `assignRoute`, `processDelivery`, and `viewStatus` encapsulate the system's logic. Helper methods like `findDriverById` improve code organization.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: `pendingPackageIds` is declared as `Queue<Integer>` and instantiated as `LinkedList`. Methods like `offer()` (add) and `remove()` (remove specific ID) are used.
 *     *   `ArrayList`: Used to instantiate the `drivers` list (`List<Driver> drivers = new ArrayList<>();`) and the `route` list within the `Driver` class (`List<Integer> route = new ArrayList<>();`). Also used temporarily for the list of package IDs in the `ASSIGN_ROUTE` command processing.
 *     *   `List`: Used as the interface type for `drivers` and `Driver.route`.
 *     *   `Scanner`: Used in the `main` method to read user input from `System.in`.
 *     *   `switch` statement: Used in the `main` method to handle different command strings entered by the user.
 *     *   `System.err`: Used extensively throughout the code to print error messages for invalid operations, bad input, or non-existent entities.
 *     *   `System.out`: Used for command prompts, successful operation messages, and the formatted output of the `VIEW_STATUS` command.
 *     *   `try-catch`:
 *         *   A large `try-catch(Exception e)` block wraps the main command processing loop in the `main` method. This serves as the class-wide exception handler, catching any unexpected runtime errors and printing a generic error message to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *         *   Specific `try-catch` blocks are used around `Integer.parseInt()` calls when processing user input to handle `NumberFormatException` for invalid ID formats.
 *         *   `IllegalArgumentException` is caught during `Package` and `Driver` construction if the ID is invalid (<= 0).
 * 
 * 3.  **Command Processing and Logic:**
 *     *   The `main` method contains the main loop that reads commands.
 *     *   Input lines are split into parts. The first part determines the command.
 *     *   The `switch` statement dispatches execution based on the command.
 *     *   Each case performs input validation (number of arguments, format using `try-catch` for `parseInt`), checks business logic constraints (e.g., package exists and is pending for assignment, package is on driver's route for delivery), calls the appropriate `DeliverySystem` method, and prints success or error messages (`System.out` or `System.err`).
 *     *   `ADD_PACKAGE`: Creates a `Package`, stores it in `allPackages`, and adds its ID to `pendingPackageIds`. Checks for duplicate/invalid IDs.
 *     *   `ADD_DRIVER`: Creates a `Driver`, adds it to `drivers`. Checks for duplicate/invalid IDs.
 *     *   `ASSIGN_ROUTE`: Finds the driver. Iterates through the provided package IDs. For each ID, it checks if it exists in `allPackages` and is in `pendingPackageIds`. If valid, it removes the ID from `pendingPackageIds`, updates the package status in `allPackages` to `ASSIGNED`, and adds the ID to the driver's route list. Errors for invalid package IDs in the list are reported but don't stop the assignment of valid ones.
 *     *   `PROCESS_DELIVERY`: Finds the driver. Finds the package in `allPackages`. Checks if the package ID is on the driver's route and if the package status is `ASSIGNED`. If valid, removes the ID from the driver's route and updates the package status in `allPackages` to `DELIVERED`.
 *     *   `VIEW_STATUS`: Iterates through `pendingPackageIds`, `drivers`, and `allPackages` to print their current state in a formatted manner. It uses streams and a comparator to sort the `allPackages` output by ID for consistency.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Command format validation (checking `parts.length`) is done before attempting to parse arguments.
 *     *   `NumberFormatException` is handled when parsing integer IDs from user input.
 *     *   Business logic errors (e.g., duplicate ID, driver/package not found, package not in correct state for operation) are checked within the `DeliverySystem` methods or command processing logic, and specific error messages are printed to `System.err`.
 *     *   Positive ID validation is done in constructors and `add` methods.
 * 
 * This solution effectively demonstrates the use of the required components in a practical scenario, incorporating essential programming concepts like object-oriented design, data structures, control flow, input/output, and error handling.
 */

import java.util.*;

// Enum to represent package status
enum PackageStatus {
    PENDING, ASSIGNED, DELIVERED
}

// Represents a package in the system
class Package {
    private int id;
    private String destination;
    private PackageStatus status;

    /**
     * Constructs a new Package.
     *
     * @param id The unique ID of the package.
     * @param destination The destination address.
     */
    public Package(int id, String destination) {
        if (id <= 0) {
            throw new IllegalArgumentException("Package ID must be positive.");
        }
        this.id = id;
        this.destination = destination;
        this.status = PackageStatus.PENDING; // Initially pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDestination() {
        return destination;
    }

    public PackageStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Destination: " + destination + ", Status: " + status;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Package aPackage = (Package) o;
        return id == aPackage.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// Represents a driver in the system
class Driver {
    private int id;
    private String name;
    // List of package IDs assigned to this driver
    private List<Integer> route; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new Driver.
     *
     * @param id The unique ID of the driver.
     * @param name The name of the driver.
     */
    public Driver(int id, String name) {
        if (id <= 0) {
            throw new IllegalArgumentException("Driver ID must be positive.");
        }
        this.id = id;
        this.name = name;
        this.route = new ArrayList<>(); // Using ArrayList
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public List<Integer> getRoute() {
        return route;
    }

    /**
     * Adds a package ID to the driver's route.
     * @param packageId The ID of the package to add.
     */
    public void addPackageToRoute(int packageId) {
        if (!route.contains(packageId)) {
            route.add(packageId);
        }
    }

    /**
     * Removes a package ID from the driver's route.
     * @param packageId The ID of the package to remove.
     * @return true if the package was found and removed, false otherwise.
     */
    public boolean removePackageFromRoute(int packageId) {
        return route.remove(Integer.valueOf(packageId)); // Use Integer.valueOf for object removal
    }

    /**
     * Checks if a package ID is on the driver's route.
     * @param packageId The ID to check.
     * @return true if the package ID is on the route, false otherwise.
     */
    public boolean isOnRoute(int packageId) {
        return route.contains(packageId);
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Route: " + route;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Driver driver = (Driver) o;
        return id == driver.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// Manages the overall delivery system state and operations
public class DeliverySystem {
    // Stores all packages ever created, for quick lookup by ID
    private Map<Integer, Package> allPackages;
    // Queue of package IDs waiting to be assigned to a driver
    private Queue<Integer> pendingPackageIds; // Using Queue interface
    // List of all registered drivers
    private List<Driver> drivers; // Using List interface, implemented by ArrayList

    /**
     * Constructs the DeliverySystem.
     */
    public DeliverySystem() {
        allPackages = new HashMap<>();
        pendingPackageIds = new LinkedList<>(); // LinkedList implements Queue
        drivers = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new package to the system and the pending queue.
     *
     * @param packageId The ID of the package.
     * @param destination The destination.
     * @return true if added successfully, false if ID already exists or is invalid.
     */
    public boolean addPackage(int packageId, String destination) {
        if (packageId <= 0) {
            System.err.println("Error: Package ID must be positive.");
            return false;
        }
        if (allPackages.containsKey(packageId)) {
            System.err.println("Error: Package with ID " + packageId + " already exists.");
            return false;
        }
        try {
            Package newPackage = new Package(packageId, destination);
            allPackages.put(packageId, newPackage);
            pendingPackageIds.offer(packageId); // Add to pending queue
            return true;
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating package: " + e.getMessage());
             return false;
        }
    }

    /**
     * Adds a new driver to the system.
     *
     * @param driverId The ID of the driver.
     * @param driverName The name of the driver.
     * @return true if added successfully, false if ID already exists or is invalid.
     */
    public boolean addDriver(int driverId, String driverName) {
         if (driverId <= 0) {
            System.err.println("Error: Driver ID must be positive.");
            return false;
        }
        for (Driver driver : drivers) {
            if (driver.getId() == driverId) {
                System.err.println("Error: Driver with ID " + driverId + " already exists.");
                return false;
            }
        }
         try {
            Driver newDriver = new Driver(driverId, driverName);
            drivers.add(newDriver);
            return true;
         } catch (IllegalArgumentException e) {
             System.err.println("Error creating driver: " + e.getMessage());
             return false;
         }
    }

    /**
     * Assigns a list of package IDs to a driver's route.
     * Removes successfully assigned packages from the pending queue.
     *
     * @param driverId The ID of the driver.
     * @param packageIds The list of package IDs to assign.
     * @return true if the driver was found (even if some packages failed assignment), false if driver not found.
     */
    public boolean assignRoute(int driverId, List<Integer> packageIds) {
        Driver driver = findDriverById(driverId);
        if (driver == null) {
            System.err.println("Error: Driver with ID " + driverId + " not found.");
            return false;
        }

        List<Integer> assignedIds = new ArrayList<>();
        for (int packageId : packageIds) {
            Package pkg = allPackages.get(packageId);
            // Check if package exists and is currently pending
            if (pkg != null && pkg.getStatus() == PackageStatus.PENDING && pendingPackageIds.contains(packageId)) {
                // Remove from pending queue
                pendingPackageIds.remove(packageId);
                // Update package status
                pkg.setStatus(PackageStatus.ASSIGNED);
                // Add to driver's route
                driver.addPackageToRoute(packageId);
                assignedIds.add(packageId);
            } else {
                // Package not found, not pending, or already assigned/delivered
                System.err.println("Error: Package ID " + packageId + " not found or not pending. Skipping.");
            }
        }

        if (!assignedIds.isEmpty()) {
             System.out.println("Assigned packages " + assignedIds + " to Driver " + driverId + ".");
        } else {
             System.out.println("No valid pending packages assigned to Driver " + driverId + " from the provided list.");
        }
        return true; // Driver was found, even if no packages were assigned
    }

    /**
     * Processes a delivery for a specific package by a driver.
     * Removes the package ID from the driver's route and updates package status.
     *
     * @param driverId The ID of the driver.
     * @param packageId The ID of the package delivered.
     * @return true if delivered successfully, false otherwise.
     */
    public boolean processDelivery(int driverId, int packageId) {
        Driver driver = findDriverById(driverId);
        if (driver == null) {
            System.err.println("Error: Driver with ID " + driverId + " not found.");
            return false;
        }

        Package pkg = allPackages.get(packageId);
        if (pkg == null) {
            System.err.println("Error: Package with ID " + packageId + " not found in the system.");
            return false;
        }

        // Check if the package is on the driver's route and is currently assigned
        if (driver.isOnRoute(packageId) && pkg.getStatus() == PackageStatus.ASSIGNED) {
            driver.removePackageFromRoute(packageId);
            pkg.setStatus(PackageStatus.DELIVERED);
            System.out.println("Package " + packageId + " delivered by Driver " + driverId + ".");
            return true;
        } else {
             if (pkg.getStatus() != PackageStatus.ASSIGNED) {
                 System.err.println("Error: Package ID " + packageId + " is not currently assigned (Status: " + pkg.getStatus() + ").");
             } else {
                 System.err.println("Error: Package ID " + packageId + " not found on Driver " + driverId + "'s route.");
             }
            return false;
        }
    }

    /**
     * Displays the current status of the system: pending queue, drivers/routes, and all package statuses.
     */
    public void viewStatus() {
        System.out.println("--- System Status ---");

        // Pending Packages
        System.out.println("Pending Packages (IDs): " + pendingPackageIds);

        // Drivers and Routes
        System.out.println("Drivers:");
        if (drivers.isEmpty()) {
            System.out.println("  No drivers registered.");
        } else {
            for (Driver driver : drivers) {
                System.out.println("  " + driver);
            }
        }

        // All Package Statuses
        System.out.println("All Packages:");
        if (allPackages.isEmpty()) {
            System.out.println("  No packages added yet.");
        } else {
            // Sort packages by ID for consistent output
            allPackages.values().stream()
                       .sorted(Comparator.comparingInt(Package::getId))
                       .forEach(pkg -> System.out.println("  " + pkg));
        }
        System.out.println("--- End Status ---");
    }

    /**
     * Finds a driver by their ID.
     * @param driverId The ID to search for.
     * @return The Driver object if found, null otherwise.
     */
    private Driver findDriverById(int driverId) {
        for (Driver driver : drivers) {
            if (driver.getId() == driverId) {
                return driver;
            }
        }
        return null;
    }


    // Main method to run the simulation
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DeliverySystem system = new DeliverySystem();
        boolean running = true;

        // Class-wide exception handling for unexpected errors
        try {
            while (running) {
                System.out.print("Enter command: ");
                String line = scanner.nextLine().trim();
                if (line.isEmpty()) {
                    continue; // Skip empty lines
                }

                String[] parts = line.split("\\s+"); // Split by one or more spaces
                String command = parts[0].toUpperCase();

                switch (command) {
                    case "ADD_PACKAGE":
                        if (parts.length == 3) {
                            try {
                                int packageId = Integer.parseInt(parts[1]);
                                String destination = parts[2];
                                if (system.addPackage(packageId, destination)) {
                                    System.out.println("Package " + packageId + " added.");
                                }
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid package ID format.");
                            }
                        } else {
                            System.err.println("Error: ADD_PACKAGE requires <packageId> <destination>");
                        }
                        break;

                    case "ADD_DRIVER":
                        if (parts.length == 3) {
                            try {
                                int driverId = Integer.parseInt(parts[1]);
                                String driverName = parts[2];
                                if (system.addDriver(driverId, driverName)) {
                                    System.out.println("Driver " + driverId + " added.");
                                }
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid driver ID format.");
                            }
                        } else {
                            System.err.println("Error: ADD_DRIVER requires <driverId> <driverName>");
                        }
                        break;

                    case "ASSIGN_ROUTE":
                        if (parts.length >= 3) {
                            try {
                                int driverId = Integer.parseInt(parts[1]);
                                List<Integer> packageIds = new ArrayList<>(); // Using ArrayList for the list of IDs
                                for (int i = 2; i < parts.length; i++) {
                                    try {
                                        packageIds.add(Integer.parseInt(parts[i]));
                                    } catch (NumberFormatException e) {
                                        System.err.println("Error: Invalid package ID format in route list: " + parts[i] + ". Skipping.");
                                    }
                                }
                                if (!packageIds.isEmpty()) {
                                    system.assignRoute(driverId, packageIds);
                                } else {
                                    System.err.println("Error: ASSIGN_ROUTE requires at least one package ID.");
                                }
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid driver ID format.");
                            }
                        } else {
                            System.err.println("Error: ASSIGN_ROUTE requires <driverId> <packageId1> <packageId2> ...");
                        }
                        break;

                    case "PROCESS_DELIVERY":
                        if (parts.length == 3) {
                            try {
                                int driverId = Integer.parseInt(parts[1]);
                                int packageId = Integer.parseInt(parts[2]);
                                system.processDelivery(driverId, packageId);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid ID format for driver or package.");
                            }
                        } else {
                            System.err.println("Error: PROCESS_DELIVERY requires <driverId> <packageId>");
                        }
                        break;

                    case "VIEW_STATUS":
                        if (parts.length == 1) {
                            system.viewStatus();
                        } else {
                            System.err.println("Error: VIEW_STATUS does not take arguments.");
                        }
                        break;

                    case "EXIT":
                        if (parts.length == 1) {
                            running = false;
                            System.out.println("Exiting Delivery System.");
                        } else {
                             System.err.println("Error: EXIT does not take arguments.");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions at the top level
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }
}
