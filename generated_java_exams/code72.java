/*
 * Exam Question #72
 * Generated on: 2025-05-11 22:08:51
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Package Delivery Service Routing Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a package delivery service's routing system. The system needs to manage packages awaiting processing and track packages that have been processed and are ready for shipping.
 * 
 * The core functionality should allow users to:
 * 1.  Add a new package to a queue of packages awaiting processing.
 * 2.  Process the next package from the queue, marking it as ready for shipping and moving it to a list of processed packages.
 * 3.  View all packages currently in the pending processing queue.
 * 4.  View all packages that have been processed and are ready for shipping.
 * 5.  Exit the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical constraints:
 * 
 * 1.  Use a `java.util.Queue` to manage packages that are pending processing.
 * 2.  Use a `java.util.ArrayList` to store packages that have been processed and are ready for shipping.
 * 3.  Declare variables that hold the processed packages using the `java.util.List` interface type.
 * 4.  Use `java.util.Scanner` to read user input for menu choices and package details.
 * 5.  Employ a `switch` statement to handle the main menu options provided by the user.
 * 6.  Use `System.err` exclusively for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 7.  Use `System.out` for all normal output (menu display, prompts, successful operation messages, package listings).
 * 8.  Implement class-wide exception handling using `try-catch` blocks to gracefully manage potential runtime issues, particularly around input handling.
 * 
 * **Design and Best Practices:**
 * 
 * *   Create a `Package` class with private fields for `trackingNumber` (String), `destination` (String), and `status` (use an `enum` like `PackageStatus: PENDING, PROCESSED`). Include a constructor and public getter methods.
 * *   Create a main `DeliveryServiceSimulator` class that encapsulates the `Queue` and `List`. It should contain the main application logic and methods for each operation (add, process, view pending, view processed).
 * *   Use meaningful variable, method, and class names.
 * *   Include appropriate comments to explain complex logic or class purpose.
 * *   Implement basic input validation (e.g., ensuring tracking number and destination are not empty when adding a package).
 * *   Handle the case where the user attempts to process a package from an empty queue.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the corresponding action, display relevant information using `System.out`, or display error messages using `System.err` for invalid operations or input.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter tracking number: TN123
 * Enter destination: New York
 * Package TN123 added to the pending queue.
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter tracking number: TN456
 * Enter destination: Los Angeles
 * Package TN456 added to the pending queue.
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Packages ---
 * Tracking: TN123, Destination: New York, Status: PENDING
 * Tracking: TN456, Destination: Los Angeles, Status: PENDING
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 2
 * Processing package: TN123
 * Package TN123 marked as PROCESSED and moved to processed list.
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Packages ---
 * Tracking: TN456, Destination: Los Angeles, Status: PENDING
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 4
 * --- Processed Packages ---
 * Tracking: TN123, Destination: New York, Status: PROCESSED
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 2
 * Error: No packages are currently pending processing.
 * 
 * --- Package Delivery Simulator Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Pending Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 5
 * Exiting simulator.
 * ```
 * 
 * Your solution should provide the complete Java code for this simulator.
 *
 * EXPLANATION:
 * The solution implements a `DeliveryServiceSimulator` class that manages packages using a queue and a list, fulfilling all the requirements of the problem.
 * 
 * 1.  **`Package` Class:** This class encapsulates the data for a single package (`trackingNumber`, `destination`, `status`). It uses an `enum` (`PackageStatus`) for the status, promoting type safety and readability. The constructor includes basic input validation to ensure tracking number and destination are not empty, throwing an `IllegalArgumentException` if they are. Getter methods provide controlled access to the private fields.
 * 
 * 2.  **`DeliveryServiceSimulator` Class:** This is the main class containing the simulation logic.
 *     *   **Required Data Structures:**
 *         *   `private Queue<Package> pendingPackages = new LinkedList<>();`: A `Queue` (implemented using `LinkedList`) is used to hold packages waiting to be processed. The Queue's FIFO (First-In, First-Out) nature naturally fits the "process next" requirement.
 *         *   `private List<Package> processedPackages = new ArrayList<>();`: A `List` interface variable, instantiated with an `ArrayList`, stores packages once they have been processed. Using the `List` interface allows flexibility if a different List implementation were needed later.
 *     *   **`Scanner`:** `private Scanner scanner = new Scanner(System.in);` is initialized to read input from the console.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addNewPackage()`:** Reads tracking number and destination from the user using `scanner.nextLine()`. It attempts to create a new `Package` object. If the `Package` constructor throws an `IllegalArgumentException` due to empty input, the `catch` block catches it and prints the error message to `System.err`. Otherwise, the new package is added to the `pendingPackages` queue using `offer()`. Success messages are printed to `System.out`.
 *     *   **`processNextPackage()`:** Checks if the `pendingPackages` queue is empty. If so, an error message is printed to `System.err`. If not, `pendingPackages.poll()` retrieves and removes the package at the head of the queue. The package's status is updated to `PROCESSED`, and it is added to the `processedPackages` list. Success messages are printed to `System.out`.
 *     *   **`viewPendingPackages()`:** Prints a header to `System.out`. It checks if the `pendingPackages` queue is empty and prints a message if so. Otherwise, it iterates through the queue (using `forEach`) and prints each package's details to `System.out` without removing them from the queue.
 *     *   **`viewProcessedPackages()`:** Similar to `viewPendingPackages`, but iterates through the `processedPackages` list and prints details to `System.out`.
 *     *   **`run()`:** This method contains the main application loop.
 *         *   It continuously displays the menu and reads the user's choice using `scanner.nextInt()`.
 *         *   A `try-catch` block wraps the input reading and the `switch` statement.
 *         *   The `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *         *   A generic `catch (Exception e)` is included as a class-wide handler for any other unexpected exceptions, printing a general error message and the stack trace to `System.err`.
 *         *   A `switch` statement controls the flow based on the user's valid integer choice, calling the appropriate methods (`addNewPackage`, `processNextPackage`, etc.).
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *         *   Choosing option 5 sets the `running` flag to `false`, ending the loop and exiting the simulator.
 *         *   `scanner.close()` is called after the loop terminates to release system resources.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates an instance of `DeliveryServiceSimulator` and calls its `run()` method.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design, encapsulation, input validation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a package
enum PackageStatus {
    PENDING,
    PROCESSED
}

// Represents a single package in the delivery system
class Package {
    private String trackingNumber;
    private String destination;
    private PackageStatus status;

    // Constructor
    public Package(String trackingNumber, String destination) {
        if (trackingNumber == null || trackingNumber.trim().isEmpty() ||
            destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Tracking number and destination cannot be null or empty.");
        }
        this.trackingNumber = trackingNumber.trim();
        this.destination = destination.trim();
        this.status = PackageStatus.PENDING; // New packages are always pending
    }

    // Getters
    public String getTrackingNumber() {
        return trackingNumber;
    }

    public String getDestination() {
        return destination;
    }

    public PackageStatus getStatus() {
        return status;
    }

    // Method to update status (used during processing)
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Tracking: " + trackingNumber + ", Destination: " + destination + ", Status: " + status;
    }
}

// Main class for the Delivery Service Simulator
public class DeliveryServiceSimulator {

    // Queue for packages awaiting processing
    private Queue<Package> pendingPackages;

    // List for packages that have been processed
    private List<Package> processedPackages;

    // Scanner for user input
    private Scanner scanner;

    // Constructor
    public DeliveryServiceSimulator() {
        this.pendingPackages = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedPackages = new ArrayList<>(); // ArrayList for processed packages
        this.scanner = new Scanner(System.in);
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Package Delivery Simulator Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Pending Packages");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new package to the pending queue
    private void addNewPackage() {
        System.out.print("Enter tracking number: ");
        String trackingNumber = scanner.nextLine();

        System.out.print("Enter destination: ");
        String destination = scanner.nextLine();

        try {
            Package newPackage = new Package(trackingNumber, destination);
            pendingPackages.offer(newPackage); // offer is generally preferred over add for queues
            System.out.println("Package " + trackingNumber + " added to the pending queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    // Processes the next package from the pending queue
    private void processNextPackage() {
        if (pendingPackages.isEmpty()) {
            System.err.println("Error: No packages are currently pending processing.");
            return;
        }

        Package packageToProcess = pendingPackages.poll(); // poll retrieves and removes the head
        if (packageToProcess != null) {
            System.out.println("Processing package: " + packageToProcess.getTrackingNumber());
            packageToProcess.setStatus(PackageStatus.PROCESSED);
            processedPackages.add(packageToProcess);
            System.out.println("Package " + packageToProcess.getTrackingNumber() + " marked as " + packageToProcess.getStatus() + " and moved to processed list.");
        }
    }

    // Views all packages currently in the pending queue
    private void viewPendingPackages() {
        System.out.println("\n--- Pending Packages ---");
        if (pendingPackages.isEmpty()) {
            System.out.println("No packages pending processing.");
        } else {
            // Iterate through the queue without removing elements
            pendingPackages.forEach(System.out::println);
        }
    }

    // Views all packages that have been processed
    private void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Iterate through the list
            processedPackages.forEach(System.out::println);
        }
    }

    // Runs the main simulation loop
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                switch (choice) {
                    case 1:
                        addNewPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewPendingPackages();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
        }
        scanner.close(); // Close the scanner when done
    }

    // Main method to start the simulator
    public static void main(String[] args) {
        DeliveryServiceSimulator simulator = new DeliveryServiceSimulator();
        simulator.run();
    }
}
