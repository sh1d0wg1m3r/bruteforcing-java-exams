/*
 * Exam Question #342
 * Generated on: 2025-05-11 22:57:50
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Bug Tracking and Resolution System
 * 
 * **Objective:**
 * 
 * Design and implement a console-based system for tracking and resolving software bugs. The system should allow users to report new bugs, resolve the oldest pending bug, and view lists of both pending and resolved bugs.
 * 
 * **Requirements:**
 * 
 * 1.  **Bug Representation:** Create a class `Bug` to represent a single bug report. It should have:
 *     *   A unique integer ID.
 *     *   A String description.
 *     *   A String status (e.g., "Pending", "Resolved").
 *     *   Appropriate private fields and public getter methods.
 *     *   A suitable constructor.
 *     *   An overridden `toString()` method for easy printing.
 * 
 * 2.  **Bug Tracking System:** Create a class `BugTrackingSystem` to manage the bugs. It must contain:
 *     *   A `Queue<Bug>` to store bugs that are pending resolution (FIFO order). Use a suitable implementation like `java.util.LinkedList` which implements `Queue`.
 *     *   A `List<Bug>` to store bugs that have been resolved. Use `java.util.ArrayList` as the implementation. Declare the field using the `List` interface type.
 *     *   A private integer counter for generating unique bug IDs.
 *     *   Public methods for the following operations:
 *         *   `reportBug(String description)`: Creates a new `Bug` object with a unique ID, sets its status to "Pending", and adds it to the pending queue.
 *         *   `resolveNextBug()`: Removes the oldest bug from the pending queue, changes its status to "Resolved", and adds it to the resolved list. If the queue is empty, it should indicate that there are no bugs to resolve.
 *         *   `getPendingBugs()`: Returns a `List<Bug>` containing all bugs currently in the pending queue (without removing them). The order should reflect the queue order.
 *         *   `getResolvedBugs()`: Returns the `List<Bug>` of resolved bugs.
 * 
 * 3.  **Console Interaction:** Create a `Main` class with a `main` method to handle user interaction.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Report New Bug
 *         2.  Resolve Next Pending Bug
 *         3.  View Pending Bugs
 *         4.  View Resolved Bugs
 *         5.  Exit
 *     *   Use a `switch` statement to process the user's menu selection.
 *     *   Implement a loop that continues until the user chooses to exit.
 *     *   For "Report New Bug", prompt the user for the bug description. Validate that the description is not empty.
 *     *   For "Resolve Next Pending Bug", call the corresponding method in `BugTrackingSystem`.
 *     *   For "View Pending Bugs" and "View Resolved Bugs", retrieve the lists from `BugTrackingSystem` and print the details of each bug using `System.out`. If a list is empty, print an appropriate message.
 *     *   Handle invalid menu input (non-integer or out-of-range integer) gracefully.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.err` to print error messages, such as:
 *         *   Invalid menu input.
 *         *   Empty bug description when reporting a bug.
 *         *   Attempting to resolve a bug when the pending queue is empty.
 *     *   Use `System.out` for all normal output, including the menu, prompts, bug details, and success messages.
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main user interaction loop in the `main` method. This block should catch general `Exception` and print an unexpected error message using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts of the code.
 *     *   Follow Java coding conventions.
 *     *   Ensure proper encapsulation in the `Bug` and `BugTrackingSystem` classes.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors appropriately. Examples:
 * 
 * ```
 * Bug Tracking System Menu:
 * 1. Report New Bug
 * 2. Resolve Next Pending Bug
 * 3. View Pending Bugs
 * 4. View Resolved Bugs
 * 5. Exit
 * Enter your choice: 1
 * Enter bug description: Application crashes on login
 * Bug reported successfully with ID 1.
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Bugs ---
 * Bug ID: 1, Description: Application crashes on login, Status: Pending
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: 2
 * Bug ID 1 resolved successfully.
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: 4
 * --- Resolved Bugs ---
 * Bug ID: 1, Description: Application crashes on login, Status: Resolved
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: 2
 * System.err: No pending bugs to resolve.
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: abc
 * System.err: Invalid input. Please enter a number between 1 and 5.
 * 
 * Bug Tracking System Menu:
 * ...
 * Enter your choice: 1
 * Enter bug description:
 * System.err: Bug description cannot be empty.
 * ```
 * 
 * This task requires integrating several core Java collection types and control structures within a practical application context, demonstrating understanding of object-oriented principles, error handling, and basic I/O.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Bug Tracking System, fulfilling all the requirements of the exam task and demonstrating the requested Java concepts.
 * 
 * 1.  **`Bug` Class:** This class is a simple Plain Old Java Object (POJO) representing a bug. It uses `private` fields (`id`, `description`, `status`) and `public` getter methods (`getId`, `getDescription`, `getStatus`), demonstrating **encapsulation**. The `setStatus` method allows the system to change the bug's status. The `toString()` method provides a convenient way to display bug information.
 * 
 * 2.  **`BugTrackingSystem` Class:** This class manages the collections of bugs.
 *     *   `pendingBugsQueue`: Declared as `Queue<Bug>` and initialized with `new LinkedList<>()`. The `Queue` interface guarantees FIFO behavior, which is appropriate for processing the oldest pending bug first. `LinkedList` is a common implementation of `Queue`.
 *     *   `resolvedBugsList`: Declared as `List<Bug>` and initialized with `new ArrayList<>()`. The `List` interface represents an ordered collection, suitable for storing resolved bugs. `ArrayList` is a common, dynamic array-based implementation. Using the `List` interface type promotes flexibility.
 *     *   `nextBugId`: A `private` integer counter to ensure each bug gets a unique ID, demonstrating the use of a state variable within the system.
 *     *   `reportBug(String description)`: Creates a new `Bug` and adds it to the `pendingBugsQueue` using `offer()`. `offer()` is generally preferred over `add()` for queues as it returns `false` if the element cannot be added (e.g., if the queue has a capacity limit), though `LinkedList` does not have a capacity limit.
 *     *   `resolveNextBug()`: Uses `pendingBugsQueue.poll()`. `poll()` retrieves and removes the head of the queue, returning `null` if the queue is empty. This is perfect for processing the "next" item. If a bug is retrieved, its status is updated, and it's added to the `resolvedBugsList`. If `poll()` returns `null`, an error message is printed using `System.err`.
 *     *   `getPendingBugs()`: Returns a *new* `ArrayList` constructed from the `pendingBugsQueue`. This provides a snapshot of the pending bugs in their current order without exposing the internal `Queue` object or allowing external modification of the queue itself. Iterating over a `Queue` typically respects the queue's order.
 *     *   `getResolvedBugs()`: Returns the `resolvedBugsList`.
 * 
 * 3.  **`Main` Class:**
 *     *   **`Scanner`:** An instance of `Scanner` reads input from `System.in`. `scanner.nextInt()` reads the integer choice, and `scanner.nextLine()` is used to consume the leftover newline character after reading the integer, preventing issues in subsequent `scanner.nextLine()` calls for the bug description.
 *     *   **`switch` Statement:** The `switch` statement is used to control the program flow based on the user's integer choice, clearly separating the logic for each menu option. The `default` case handles choices outside the expected range.
 *     *   **`System.out` and `System.err`:** `System.out.println` is used for printing the menu, prompts, bug details, and success messages. `System.err.println` is specifically used for printing error messages, such as invalid input, empty description, or attempting to resolve from an empty queue, making errors visually distinct.
 *     *   **Input Validation:** The code checks if the entered bug description is empty using `description.isEmpty()` after trimming whitespace. It also handles non-integer input for the menu choice using a `try-catch` block around `scanner.nextInt()`.
 *     *   **Class-wide Exception Handling (`try-catch`):** A `try-catch(Exception e)` block wraps the entire `while` loop in the `main` method. This serves as a top-level catch-all for any unexpected runtime exceptions that might occur within the program's main execution flow, preventing the program from crashing abruptly and instead printing a general error message using `System.err`. Specific input errors (`InputMismatchException`) are caught and handled *inside* the loop for more granular error messages without exiting the loop.
 *     *   **Looping:** A `while` loop keeps the program running until the user enters `5` to exit.
 * 
 * 4.  **Best Practices:**
 *     *   **Meaningful Names:** Classes, methods, and variables have descriptive names (e.g., `pendingBugsQueue`, `resolveNextBug`, `description`).
 *     *   **Encapsulation:** Data fields in `Bug` and the collections in `BugTrackingSystem` are `private`, accessed or modified via public methods.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods. Inline comments explain specific logic points.
 *     *   **Input Handling:** Careful use of `scanner.nextLine()` after `scanner.nextInt()` prevents common input bugs. Trimming whitespace from the description is also good practice.
 * 
 * This solution effectively combines the required Java components into a functional system, demonstrating fundamental object-oriented design, data structure usage, control flow, and robust error handling suitable for an advanced beginner or intermediate Java exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single bug in the system
class Bug {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Resolved"

    // Constructor
    public Bug(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // New bugs start as Pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used by the system to update status)
    public void setStatus(String status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Bug ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the collection of bugs
class BugTrackingSystem {
    // Queue for bugs waiting to be resolved (FIFO)
    private Queue<Bug> pendingBugsQueue;
    // List for bugs that have been resolved
    private List<Bug> resolvedBugsList;
    // Counter for generating unique bug IDs
    private int nextBugId;

    // Constructor
    public BugTrackingSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingBugsQueue = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.resolvedBugsList = new ArrayList<>();
        this.nextBugId = 1; // Start bug IDs from 1
    }

    /**
     * Reports a new bug and adds it to the pending queue.
     * @param description The description of the bug.
     */
    public void reportBug(String description) {
        Bug newBug = new Bug(nextBugId++, description);
        pendingBugsQueue.offer(newBug); // offer is preferred over add for queues
        System.out.println("Bug reported successfully with ID " + newBug.getId() + ".");
    }

    /**
     * Resolves the next bug in the pending queue.
     * Moves the bug from the pending queue to the resolved list.
     * Returns the resolved bug, or null if the queue is empty.
     */
    public Bug resolveNextBug() {
        Bug bugToResolve = pendingBugsQueue.poll(); // poll retrieves and removes, returns null if empty
        if (bugToResolve != null) {
            bugToResolve.setStatus("Resolved");
            resolvedBugsList.add(bugToResolve);
            System.out.println("Bug ID " + bugToResolve.getId() + " resolved successfully.");
        } else {
            // Use System.err for operational errors like this
            System.err.println("No pending bugs to resolve.");
        }
        return bugToResolve;
    }

    /**
     * Returns a list of all pending bugs.
     * @return A List containing pending bugs in queue order.
     */
    public List<Bug> getPendingBugs() {
        // Create a new list from the queue elements to avoid modifying the original queue
        // Iterating over a Queue gives elements in order
        List<Bug> pending = new ArrayList<>(pendingBugsQueue);
        return pending;
    }

    /**
     * Returns a list of all resolved bugs.
     * @return The List containing resolved bugs.
     */
    public List<Bug> getResolvedBugs() {
        return resolvedBugsList;
    }
}

// Main class for console interaction
public class Main {

    public static void main(String[] args) {
        // Class-wide exception handling wrapping the main logic
        try {
            BugTrackingSystem bugSystem = new BugTrackingSystem();
            Scanner scanner = new Scanner(System.in);
            int choice = -1;

            while (choice != 5) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter bug description: ");
                            String description = scanner.nextLine().trim(); // Trim whitespace
                            if (description.isEmpty()) {
                                // Use System.err for validation errors
                                System.err.println("Bug description cannot be empty.");
                            } else {
                                bugSystem.reportBug(description);
                            }
                            break;
                        case 2:
                            bugSystem.resolveNextBug(); // Handles empty queue internally
                            break;
                        case 3:
                            List<Bug> pending = bugSystem.getPendingBugs();
                            System.out.println("--- Pending Bugs ---");
                            if (pending.isEmpty()) {
                                System.out.println("No pending bugs.");
                            } else {
                                // Using List interface for iteration
                                for (Bug bug : pending) {
                                    System.out.println(bug); // Uses Bug's toString()
                                }
                            }
                            System.out.println("--------------------");
                            break;
                        case 4:
                            List<Bug> resolved = bugSystem.getResolvedBugs();
                            System.out.println("--- Resolved Bugs ---");
                            if (resolved.isEmpty()) {
                                System.out.println("No resolved bugs.");
                            } else {
                                // Using List interface for iteration
                                for (Bug bug : resolved) {
                                    System.out.println(bug); // Uses Bug's toString()
                                }
                            }
                            System.out.println("---------------------");
                            break;
                        case 5:
                            System.out.println("Exiting Bug Tracking System. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid input errors
                            System.err.println("Invalid input. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line
                    choice = -1; // Reset choice to prevent exiting or unintended behavior
                }
                System.out.println(); // Add a blank line for readability
            }

            scanner.close(); // Close the scanner when done

        } catch (Exception e) {
            // Class-wide catch for any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging details
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Bug Tracking System Menu:");
        System.out.println("1. Report New Bug");
        System.out.println("2. Resolve Next Pending Bug");
        System.out.println("3. View Pending Bugs");
        System.out.println("4. View Resolved Bugs");
        System.out.println("5. Exit");
    }
}
