/*
 * Exam Question #127
 * Generated on: 2025-05-11 22:18:37
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Scenario:** You are tasked with building a simplified console-based Task Management System for a small team. The system needs to track tasks, manage tasks waiting for assignment/processing using a queue, and allow basic operations like adding, viewing, processing, and completing tasks via a command-line interface.
 * 
 * **Task:** Implement a Java program that simulates this task management system according to the requirements below.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a class named `Task` to represent individual tasks. It should have the following `private` fields:
 *     *   `id`: An integer representing a unique task identifier.
 *     *   `name`: A String for the task's name.
 *     *   `description`: A String for the task's description.
 *     *   `assignee`: A String indicating who the task is assigned to (can be null initially).
 *     *   `status`: An `enum` named `Status` within the `Task` class with values `PENDING`, `IN_PROGRESS`, and `COMPLETED`.
 *     *   Include a constructor, public getter methods for all fields, and public setter methods for `assignee` and `status`. The `setStatus` method should include basic validation (e.g., preventing status changes if already `COMPLETED`, or requiring `IN_PROGRESS` before `COMPLETED`).
 *     *   Override the `toString()` method to provide a concise string representation of the task.
 * 
 * 2.  **TaskManager Class:** Create a class named `TaskManager` responsible for managing the collections of tasks.
 *     *   It must internally use a `private java.util.ArrayList<Task>` to store *all* tasks created in the system.
 *     *   It must internally use a `private java.util.Queue<Task>` (specifically, a `java.util.LinkedList` implementation) to manage tasks that are currently in the `PENDING` status and waiting to be processed.
 *     *   Include a mechanism to generate unique task IDs (e.g., a counter).
 *     *   Implement the following public methods:
 *         *   `void addTask(String name, String description)`: Creates a new `Task` with `PENDING` status and a unique ID, adds it to both the `ArrayList` and the `Queue`.
 *         *   `java.util.List<Task> getAllTasks()`: Returns a `List` containing all tasks stored in the system.
 *         *   `java.util.List<Task> getPendingTasks()`: Returns a `List` containing tasks currently present in the pending queue (without removing them from the queue).
 *         *   `Task processNextPendingTask(String assignee)`: Removes the next task from the pending queue (`poll()`), updates its status to `IN_PROGRESS`, sets the assignee, and returns the processed task. This method should throw a `java.util.NoSuchElementException` if the queue is empty.
 *         *   `void completeTask(int taskId)`: Finds a task by its ID in the list of all tasks and updates its status to `COMPLETED`. This method should throw an `java.lang.IllegalArgumentException` if the task ID is not found or if the task's current status prevents it from being completed (rely on the `Task.setStatus` validation).
 * 
 * 3.  **Main Class:** Create a class named `Main` with the `main` method to run the application.
 *     *   The `main` method should create instances of `TaskManager` and `java.util.Scanner` for user input.
 *     *   Implement a console menu loop that continuously presents the user with the following options:
 *         *   1. Add New Task
 *         *   2. View All Tasks
 *         *   3. View Pending Tasks (from Queue)
 *         *   4. Process Next Pending Task (prompts for assignee)
 *         *   5. Mark Task as Completed (prompts for task ID)
 *         *   6. Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use the `Scanner` object to read the user's choice and necessary task details (name, description, ID, assignee).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the main application loop to gracefully handle potential errors, such as:
 *         *   Invalid menu choice input (non-integer).
 *         *   Invalid task ID input (non-integer).
 *         *   Attempting to process a task when the pending queue is empty.
 *         *   Attempting to complete a task that doesn't exist or is in an invalid state.
 *         *   Any other unexpected exceptions.
 *     *   Use `java.lang.System.err` to print all error messages.
 *     *   Use `java.lang.System.out` for the menu, prompts, and successful output (task listings, confirmation messages).
 * 
 * 4.  **Required Components:** Your solution MUST use ALL of the following Java components: `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `java.lang.System.err`, `java.lang.System.out`, and class-wide `try-catch` blocks.
 * 
 * 5.  **Best Practices:** Adhere to Java best practices, including proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments and documentation (briefly explaining classes and methods), input validation (where applicable), and clean code structure.
 * 
 * **Expected Output:**
 * The program should run interactively, displaying a menu, prompting for input based on the selected option, and printing results or error messages. Error messages should go to standard error (`System.err`), while normal output goes to standard output (`System.out`). The program should continue running until the user selects the Exit option.
 *
 * EXPLANATION:
 * The solution implements a simplified Task Management System using three classes: `Task`, `TaskManager`, and `Main`. It demonstrates the practical application of various core Java concepts and collections.
 * 
 * 1.  **`Task` Class:** This class represents the data structure for a task. It includes fields for ID, name, description, assignee, and status using an `enum`. Encapsulation is maintained with private fields and public getters/setters. The `setStatus` method includes basic validation logic, throwing an `IllegalArgumentException` for invalid state transitions. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class acts as the central manager for tasks.
 *     *   It uses a `java.util.ArrayList<Task>` named `allTasks` to store a record of every task created. This fulfills the `ArrayList` requirement.
 *     *   It uses a `java.util.Queue<Task>` named `pendingTasksQueue`, implemented specifically using `java.util.LinkedList` as required. This queue manages tasks that are in the `PENDING` state, processed in First-In, First-Out (FIFO) order. The `addTask` method adds new tasks to both collections, and `processNextPendingTask` uses `queue.poll()` to remove and retrieve the next pending task, demonstrating queue behavior.
 *     *   The `getAllTasks()` and `getPendingTasks()` methods return `java.util.List<Task>`, fulfilling the `List` interface requirement for method return types. `getPendingTasks()` iterates over the queue to create a list view without modifying the queue itself.
 *     *   Methods like `processNextPendingTask` and `completeTask` include logic to interact with the collections and update task states, throwing specific exceptions (`NoSuchElementException` for an empty queue, `IllegalArgumentException` for invalid task operations) to signal failure conditions.
 * 
 * 3.  **`Main` Class:** This is the entry point of the application, handling user interaction and orchestrating calls to the `TaskManager`.
 *     *   A `java.util.Scanner` is used to read input from the console (`System.in`), fulfilling the `Scanner` requirement.
 *     *   The main application logic runs inside a `while` loop that continues until the user chooses to exit.
 *     *   A `switch` statement is used to direct the program flow based on the user's menu choice, fulfilling the `switch` requirement.
 *     *   **Class-wide Exception Handling:** A large `try-catch` block wraps the core logic within the `while` loop. This block demonstrates "class-wide" handling by catching exceptions that might occur during input reading (`NumberFormatException`) or calls to `TaskManager` methods (`NoSuchElementException`, `IllegalArgumentException`). This centralizes error handling for the main execution flow.
 *     *   **Output Streams:** `java.lang.System.out` is used for displaying the menu, prompts, and successful operation messages (like task listings or confirmation), fulfilling the `System.out` requirement. `java.lang.System.err` is used exclusively within the `catch` blocks and for invalid menu choices to print error messages, fulfilling the `System.err` requirement.
 * 
 * **Best Practices:**
 * - **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 * - **Meaningful Names:** Classes, variables, methods, and the `enum` have descriptive names (`Task`, `pendingTasksQueue`, `processNextPendingTask`, `Status`).
 * - **Comments and Documentation:** Javadoc-style comments explain the purpose of classes and key methods, and inline comments clarify complex logic.
 * - **Input Validation:** Input reading uses `Scanner.nextLine()` followed by `Integer.parseInt` to correctly handle integer input after reading strings. The `try-catch` specifically handles `NumberFormatException`. `Task` constructor validates the name, and `Task.setStatus` validates state transitions.
 * - **Proper Error Handling:** Specific exceptions are caught, providing clearer error messages via `System.err`. A general `Exception` catch is included as a fallback.
 * - **Clean Code Structure:** The logic is separated into distinct classes with clear responsibilities (`Task` for data, `TaskManager` for business logic/collections, `Main` for UI/input/error handling loop).
 * 
 * This solution effectively integrates all required Java components into a practical scenario, demonstrating an understanding of data structures, object-oriented design, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException;
import java.lang.IllegalArgumentException;
import java.util.Objects; // For Task.equals/hashCode

// Task.java
class Task {

    public enum Status {
        PENDING, IN_PROGRESS, COMPLETED
    }

    private int id;
    private String name;
    private String description;
    private String assignee;
    private Status status;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param name The name of the task.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the task name is null or empty.
     */
    public Task(int id, String name, String description) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Task name cannot be empty.");
        }
        this.id = id;
        this.name = name.trim();
        this.description = description != null ? description.trim() : "";
        this.assignee = null; // Assignee is set later
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getId() { return id; }
    public String getName() { return name; }
    public String getDescription() { return description; }
    public String getAssignee() { return assignee; }
    public Status getStatus() { return status; }

    // --- Setters ---
    /**
     * Sets the assignee for the task.
     * @param assignee The name of the person assigned.
     */
    public void setAssignee(String assignee) {
        this.assignee = assignee != null ? assignee.trim() : null;
    }

    /**
     * Updates the task status with basic validation.
     * Allows transitions: PENDING -> IN_PROGRESS, IN_PROGRESS -> COMPLETED.
     * Prevents changes if already COMPLETED and PENDING -> COMPLETED direct transition.
     * @param status The new status to set.
     * @throws IllegalArgumentException if the status transition is invalid.
     */
    public void setStatus(Status status) {
        if (status == null) {
            throw new IllegalArgumentException("Status cannot be null.");
        }
        // Basic state transition validation
        if (this.status == Status.COMPLETED) {
             throw new IllegalArgumentException("Task " + id + " is already completed. Status cannot be changed.");
        }
        if (this.status == Status.PENDING && status == Status.COMPLETED) {
             throw new IllegalArgumentException("Task " + id + " must be IN_PROGRESS before being completed.");
        }
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Name='" + name + "', Status=" + status +
               (assignee != null ? ", Assignee='" + assignee + "'" : "") + "]";
    }

    // --- Override equals and hashCode based on ID ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// TaskManager.java
class TaskManager {

    // Stores all tasks created in the system
    private List<Task> allTasks;

    // Stores tasks currently in PENDING status, waiting to be processed (FIFO order)
    private Queue<Task> pendingTasksQueue;

    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        // Requirement: Use ArrayList for allTasks
        this.allTasks = new ArrayList<>();
        // Requirement: Use LinkedList as a Queue implementation for pendingTasksQueue
        this.pendingTasksQueue = new LinkedList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * The task is added to both the list of all tasks and the pending queue.
     * @param name The name of the task.
     * @param description The description of the task.
     * @throws IllegalArgumentException if task name is invalid (delegated to Task constructor).
     */
    public void addTask(String name, String description) {
        // Task constructor handles name validation
        Task newTask = new Task(nextTaskId++, name, description);

        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasksQueue.offer(newTask); // Add to the pending queue (offer is safer than add)

        System.out.println("Task added: " + newTask.getName() + " (ID: " + newTask.getId() + ")");
    }

    /**
     * Returns a list of all tasks in the system.
     * @return A List of Task objects.
     */
    public List<Task> getAllTasks() {
        // Requirement: Return a List (ArrayList is implementing List)
        return allTasks;
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Does not remove tasks from the queue. The list reflects the queue order.
     * @return A List of Task objects currently in the pending queue.
     */
    public List<Task> getPendingTasks() {
        // Requirement: Return a List
        List<Task> pendingList = new ArrayList<>();
        // Iterate over the queue to create a list without removing elements
        for (Task task : pendingTasksQueue) {
            pendingList.add(task);
        }
        return pendingList;
    }

    /**
     * Processes the next task from the pending queue (FIFO).
     * Removes the task from the queue, updates its status to IN_PROGRESS, and sets the assignee.
     * @param assignee The person assigned to the task.
     * @return The Task object that was processed.
     * @throws NoSuchElementException if the pending queue is empty.
     */
    public Task processNextPendingTask(String assignee) {
        // Requirement: Use Queue (poll method)
        Task nextTask = pendingTasksQueue.poll();

        if (nextTask == null) {
            // Requirement: Throw NoSuchElementException if queue is empty
            throw new NoSuchElementException("No tasks are currently pending in the queue.");
        }

        // Update the status and assignee. The Task object reference is the same in allTasks list.
        nextTask.setStatus(Task.Status.IN_PROGRESS);
        nextTask.setAssignee(assignee);

        return nextTask;
    }

    /**
     * Marks a task as completed.
     * Finds the task by ID in the list of all tasks and updates its status.
     * @param taskId The ID of the task to complete.
     * @throws IllegalArgumentException if the task is not found or cannot be completed (due to status).
     */
    public void completeTask(int taskId) {
        Task taskToComplete = findTaskById(taskId);

        if (taskToComplete == null) {
            // Requirement: Throw IllegalArgumentException if task not found
            throw new IllegalArgumentException("Task with ID " + taskId + " not found.");
        }

        // Attempt to set status to COMPLETED. Task class handles transition validation.
        // Requirement: Exception handling flows from Task -> TaskManager -> Main
        taskToComplete.setStatus(Task.Status.COMPLETED);
        System.out.println("Task ID " + taskId + " marked as COMPLETED.");

        // Note: Task is not removed from allTasks. It was removed from pendingTasksQueue
        // when it transitioned from PENDING to IN_PROGRESS (by processNextPendingTask).
    }

    /**
     * Helper method to find a task by its ID in the list of all tasks.
     * @param taskId The ID to search for.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }
}

// Main.java
public class Main {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Requirement: Use System.out for normal output
        System.out.println("--- Simplified Task Management System ---");

        // Requirement: Implement class-wide exception handling using try-catch
        while (running) {
            printMenu();

            try {
                // Requirement: Use System.out for prompts
                System.out.print("Enter choice: ");
                // Read full line to avoid issues with nextInt() and newlines
                String choiceString = scanner.nextLine();
                // Requirement: Handle NumberFormatException for invalid input
                int choice = Integer.parseInt(choiceString);

                // Requirement: Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task name: ");
                        String name = scanner.nextLine();
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(name, description);
                        break;

                    case 2: // View All Tasks
                        System.out.println("\n--- All Tasks ---");
                        // Requirement: Use List interface
                        List<Task> allTasks = taskManager.getAllTasks();
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks available.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task); // Uses Task.toString()
                            }
                        }
                        System.out.println("-----------------");
                        break;

                    case 3: // View Pending Tasks (from Queue)
                        System.out.println("\n--- Pending Tasks (Queue Order) ---");
                        // Requirement: Use List interface
                        List<Task> pendingTasks = taskManager.getPendingTasks();
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks are currently pending.");
                        } else {
                            // The list reflects the queue order
                            for (Task task : pendingTasks) {
                                System.out.println(task); // Should show PENDING status
                            }
                        }
                        System.out.println("-----------------------------------");
                        break;

                    case 4: // Process Next Pending Task
                        System.out.print("Enter assignee name for the task: ");
                        String assignee = scanner.nextLine();
                        // This method can throw NoSuchElementException
                        Task processedTask = taskManager.processNextPendingTask(assignee);
                        System.out.println("Successfully processed task: " + processedTask.getName() + " (ID: " + processedTask.getId() + ")");
                        System.out.println("Status updated to IN_PROGRESS, assigned to " + processedTask.getAssignee());
                        break;

                    case 5: // Mark Task as Completed
                        System.out.print("Enter ID of task to mark as completed: ");
                        String taskIdString = scanner.nextLine();
                         // Requirement: Handle NumberFormatException for invalid ID input
                        int taskIdToComplete = Integer.parseInt(taskIdString);
                        // This method can throw IllegalArgumentException
                        taskManager.completeTask(taskIdToComplete);
                        // Success message is printed inside completeTask
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }

            } catch (NumberFormatException e) {
                // Requirement: Use System.err for error messages
                System.err.println("Invalid input format. Please enter a valid number.");
            } catch (NoSuchElementException e) {
                 // Requirement: Use System.err for error messages
                System.err.println("Operation failed: " + e.getMessage());
            } catch (IllegalArgumentException e) {
                 // Requirement: Use System.err for error messages
                System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                 // Requirement: Use System.err for error messages
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(System.err); // Useful for debugging in exam
            }
            // Add a blank line for readability between operations
            System.out.println();
        }

        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Pending Tasks (from Queue)");
        System.out.println("4. Process Next Pending Task");
        System.out.println("5. Mark Task as Completed");
        System.out.println("6. Exit");
    }
}
