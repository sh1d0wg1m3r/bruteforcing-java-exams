/*
 * Exam Question #784
 * Generated on: 2025-05-12 16:40:16
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application for managing a queue of tasks. The system should allow users to add new tasks, process the next task in the queue, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with a private field `description` (String) and a private field `isCompleted` (boolean). Provide a constructor to initialize the description and set `isCompleted` to `false`. Include public getter methods for both fields.
 * 2.  **Task Management System:** Create a class `TaskManagementSystem`.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks).
 *     *   It must use a `java.util.List<Task>` (implemented by `java.util.ArrayList`) to store tasks that have been processed (completed tasks).
 *     *   Provide the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object and adds it to the pending task queue.
 *         *   `processNextTask()`: Retrieves the next task from the pending queue, marks it as completed, and moves it to the completed tasks list. If the pending queue is empty, report an error.
 *         *   `getPendingTasks()`: Returns a `List<Task>` containing the tasks currently in the pending queue (you can return a copy or an unmodifiable list to maintain encapsulation, but for simplicity in this exam, returning the queue converted to a List is acceptable).
 *         *   `getCompletedTasks()`: Returns the `List<Task>` of completed tasks.
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of a separate class (e.g., `TaskApp`).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Support the following commands:
 *         *   `add <task description>`: Adds a new task with the given description.
 *         *   `process`: Processes the next task in the queue.
 *         *   `list pending`: Displays all tasks currently in the pending queue.
 *         *   `list completed`: Displays all tasks in the completed list.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to handle the different commands.
 * 4.  **Input Validation & Error Handling:**
 *     *   Validate the input for the `add` command to ensure a description is provided.
 *     *   Use `System.err` to print error messages (e.g., invalid command, no description for add, no tasks to process).
 *     *   Use `System.out` for all normal output (prompts, success messages, task listings).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks around the main command processing loop to catch unexpected errors and prevent the program from crashing abruptly. Also, handle specific anticipated errors (like trying to process an empty queue) within the `TaskManagementSystem` methods or by checking return values/state before calling.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation in the `Task` and `TaskManagementSystem` classes.
 * 
 * **Expected Output Format:**
 * 
 * *   Prompts: Clearly indicate when the system is ready for input (e.g., `Enter command: `).
 * *   Success messages: Confirm actions (e.g., `Task added successfully.`, `Task processed: ...`).
 * *   Error messages: Use `System.err` (e.g., `Error: No tasks to process.`, `Error: Invalid command.`, `Error: Task description cannot be empty.`).
 * *   Listings: Format clearly, showing task description and status (e.g., `Pending Tasks:`, `- Task 1 description`, `Completed Tasks:`, `- Task 2 description [Completed]`).
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command: add Buy groceries
 * Task added successfully.
 * Enter command: add Pay bills
 * Task added successfully.
 * Enter command: list pending
 * Pending Tasks:
 * - Buy groceries
 * - Pay bills
 * Enter command: process
 * Task processed: Buy groceries
 * Enter command: process
 * Task processed: Pay bills
 * Enter command: process
 * Error: No tasks to process.
 * Enter command: list completed
 * Completed Tasks:
 * - Buy groceries [Completed]
 * - Pay bills [Completed]
 * Enter command: list pending
 * Pending Tasks:
 * Enter command: exit
 * Exiting Task Management System.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Your solution must compile and run using standard Java SE.
 * *   You must use *all* the Java components listed in the requirements.
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   `Task` is a simple class encapsulating a task's `description` and `isCompleted` status.
 *     *   It follows encapsulation principles with private fields and public getter methods.
 *     *   The constructor includes basic validation for the description.
 *     *   A `markCompleted` method changes the task's state.
 *     *   `toString()` is overridden for easy printing of completed tasks.
 * 
 * 2.  **TaskManagementSystem Class:**
 *     *   This class manages the collections of tasks.
 *     *   `pendingTasks` is declared as a `Queue<Task>` and initialized with `LinkedList`. `LinkedList` is a common implementation of `Queue` that supports FIFO (First-In, First-Out) behavior, suitable for processing tasks in the order they are added.
 *     *   `completedTasks` is declared as a `List<Task>` and initialized with `ArrayList`. `ArrayList` provides a dynamic array for storing completed tasks, allowing easy iteration and access.
 *     *   `addTask`: Creates a `Task` object and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. If `poll()` returns `null`, it means the queue was empty, and an error message is printed to `System.err`. Otherwise, the task is marked completed and added to the `completedTasks` list.
 *     *   `getPendingTasks`: Returns a *new* `ArrayList` created from the `pendingTasks` queue. This is a good practice to prevent external code from directly manipulating the internal queue structure, although for this exam returning the direct list conversion is accepted.
 *     *   `getCompletedTasks`: Returns the `completedTasks` `ArrayList`.
 * 
 * 3.  **TaskApp Class (Main Application):**
 *     *   The `main` method orchestrates the application flow.
 *     *   `Scanner` is used to read input from `System.in`.
 *     *   A `TaskManagementSystem` object is instantiated.
 *     *   A `while` loop keeps the application running until the `running` flag is set to `false` by the "exit" command.
 *     *   The user input line is read, trimmed, and split into command and arguments.
 *     *   A `switch` statement evaluates the command part of the input string (`add`, `process`, `list`, `exit`).
 *     *   **Input Validation:** For the "add" command, it checks if a description was provided after the command.
 *     *   **Error Handling:**
 *         *   `System.err` is used for specific error messages like "No tasks to process," "Invalid command," or missing descriptions.
 *         *   A broad `try-catch (Exception e)` block wraps the entire `while` loop. This demonstrates **class-wide exception handling**, ensuring that if any unexpected runtime error occurs within the loop (e.g., a `NullPointerException` that wasn't explicitly handled, or an issue with `Scanner`), the program catches it, prints an error message using `System.err`, prints the stack trace for debugging, and then exits gracefully (via the `finally` block closing the scanner). Specific anticipated errors (like empty queue) are handled by checking the return value of `poll()` within `processNextTask`.
 *     *   **Output:** `System.out` is used for prompts, success messages, and listing tasks.
 *     *   The `list` command uses a nested `if-else if` structure to handle "pending" and "completed" list types. It iterates over the `List` returned by `getPendingTasks()` and `getCompletedTasks()` to print the task details.
 *     *   A `finally` block ensures the `Scanner` is closed when the `try` block is exited (either normally or due to an exception).
 * 
 * This solution effectively combines `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a structured, encapsulated application that simulates a practical task management scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.TimeUnit; // Just for potential future use or slight delay simulation if needed, not strictly required by prompt but good practice

/**
 * Represents a single task with a description and completion status.
 */
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     *
     * @return True if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    @Override
    public String toString() {
        return description + (isCompleted ? " [Completed]" : "");
    }
}

/**
 * Manages a collection of pending and completed tasks.
 */
class TaskManagementSystem {
    // Use LinkedList as the implementation for Queue
    private Queue<Task> pendingTasks;
    // Use ArrayList as the implementation for List
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes the pending and completed task collections.
     */
    public TaskManagementSystem() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task to add.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        Task newTask = new Task(description); // Task constructor handles description validation
        pendingTasks.offer(newTask); // offer is generally preferred over add for capacity-constrained queues
        System.out.println("Task added successfully.");
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list upon successful processing.
     *
     * @return The processed task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess != null) {
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task processed: " + taskToProcess.getDescription());
            return taskToProcess;
        } else {
            // Use System.err for error messages as required
            System.err.println("Error: No tasks to process.");
            return null;
        }
    }

    /**
     * Gets a list of all pending tasks.
     *
     * @return A List containing the pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing tasks from the queue
        // This avoids exposing the internal queue structure directly
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     *
     * @return A List containing the completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Return the actual list of completed tasks
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and command processing.
 */
public class TaskApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManagementSystem taskSystem = new TaskManagementSystem();
        boolean running = true;

        System.out.println("Task Management System");
        System.out.println("Commands: add <description>, process, list pending, list completed, exit");

        // Class-wide exception handling using try-catch around the main loop
        try {
            while (running) {
                System.out.print("Enter command: ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Skip empty input
                }

                // Split command and arguments
                String[] parts = inputLine.split(" ", 2);
                String command = parts[0].toLowerCase(); // Case-insensitive command

                // Use a switch statement for command handling
                switch (command) {
                    case "add":
                        if (parts.length < 2 || parts[1].trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty for 'add' command.");
                        } else {
                            String description = parts[1].trim();
                            try {
                                taskSystem.addTask(description);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding task: " + e.getMessage());
                            }
                        }
                        break;

                    case "process":
                        taskSystem.processNextTask(); // Method itself prints success/error
                        break;

                    case "list":
                        if (parts.length < 2) {
                             System.err.println("Error: 'list' command requires 'pending' or 'completed'.");
                        } else {
                            String listType = parts[1].toLowerCase();
                            if ("pending".equals(listType)) {
                                List<Task> pending = taskSystem.getPendingTasks();
                                System.out.println("Pending Tasks:");
                                if (pending.isEmpty()) {
                                    System.out.println("(None)");
                                } else {
                                    for (int i = 0; i < pending.size(); i++) {
                                        // Accessing elements from List returned by getPendingTasks()
                                        System.out.println("- " + pending.get(i).getDescription());
                                    }
                                }
                            } else if ("completed".equals(listType)) {
                                List<Task> completed = taskSystem.getCompletedTasks();
                                System.out.println("Completed Tasks:");
                                if (completed.isEmpty()) {
                                     System.out.println("(None)");
                                } else {
                                    for (Task task : completed) {
                                        // Iterating over List<Task> completedTasks
                                        System.out.println("- " + task); // Task.toString() handles [Completed]
                                    }
                                }
                            } else {
                                System.err.println("Error: Invalid list type. Use 'pending' or 'completed'.");
                            }
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default:
                        System.err.println("Error: Invalid command.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }
}
