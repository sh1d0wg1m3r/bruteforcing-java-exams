/*
 * Exam Question #74
 * Generated on: 2025-05-11 22:09:18
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a task processing system. The system should allow users to add new tasks, process the next available task, and view lists of pending and completed tasks. Tasks have a unique ID, a description, and a priority level.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with private fields for `id` (String), `description` (String), `priority` (enum `Priority`), and `isCompleted` (boolean). Include a constructor and public getter methods for these fields. Add a method `markComplete()` that sets `isCompleted` to `true`. Override the `toString()` method for easy printing of task details.
 * 2.  **Priority Levels:** Create an enum named `Priority` with values `HIGH`, `MEDIUM`, and `LOW`.
 * 3.  **Task Management:** Create a class named `TaskManager` responsible for managing tasks.
 *     *   It must use a `Queue<Task>` (implemented by `java.util.LinkedList`) to store tasks that are pending processing.
 *     *   It must use a `List<Task>` (declared as `java.util.List` and implemented by `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Implement a method `addTask(Task task)` that adds a task to the pending queue.
 *     *   Implement a method `processNextTask()` that removes the next task from the pending queue, marks it as complete using the `markComplete()` method, and adds it to the completed tasks list. If the pending queue is empty, it should report an error using `System.err`.
 *     *   Implement a method `getPendingTasks()` that returns a new `ArrayList` containing all tasks currently in the pending queue (to avoid external modification of the internal queue).
 *     *   Implement a method `getCompletedTasks()` that returns a new `ArrayList` containing all tasks in the completed tasks list.
 * 4.  **Command-Line Interface:** Create a main class (e.g., `TaskSystem`) with a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   The interface should support the following commands: `ADD`, `PROCESS`, `VIEW_PENDING`, `VIEW_COMPLETED`, and `EXIT`.
 *     *   Use a `switch` statement to handle the different commands entered by the user.
 *     *   Use `System.out` for prompts, successful operation messages, and listing tasks.
 *     *   Use `System.err` for reporting invalid commands, input errors, and operational errors (like trying to process a task when the queue is empty).
 * 5.  **Input Handling and Validation:**
 *     *   Use `Scanner` to read user input for commands and task details.
 *     *   Implement input validation when adding a task: ensure ID, description are provided, and the priority is one of the valid `Priority` enum values (case-insensitive input for priority should be handled). Report validation errors using `System.err`.
 * 6.  **Exception Handling:** Implement class-wide exception handling by wrapping the main command processing loop in the `main` method within a `try-catch` block to catch unexpected errors during execution. Also, handle specific input-related exceptions (like `IllegalArgumentException` when parsing priority) where appropriate, reporting them via `System.err`.
 * 7.  **Best Practices:** Adhere to Java best practices, including proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments, and clean code structure.
 * 
 * **Execution Flow Example:**
 * 
 * ```
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): ADD
 * Enter Task ID: T001
 * Enter Description: Implement feature X
 * Enter Priority (HIGH, MEDIUM, LOW): HIGH
 * Task T001 added to pending queue.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): ADD
 * Enter Task ID: T002
 * Enter Description: Write documentation
 * Enter Priority (HIGH, MEDIUM, LOW): low
 * Task T002 added to pending queue.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): VIEW_PENDING
 * --- Pending Tasks ---
 * [T001] Implement feature X (Priority: HIGH, Completed: false)
 * [T002] Write documentation (Priority: LOW, Completed: false)
 * ---------------------
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): PROCESS
 * Processing task: [T001] Implement feature X (Priority: HIGH, Completed: false)
 * Task T001 processed and moved to completed.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): VIEW_PENDING
 * --- Pending Tasks ---
 * [T002] Write documentation (Priority: LOW, Completed: false)
 * ---------------------
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): VIEW_COMPLETED
 * --- Completed Tasks ---
 * [T001] Implement feature X (Priority: HIGH, Completed: true)
 * -----------------------
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): PROCESS
 * Processing task: [T002] Write documentation (Priority: LOW, Completed: false)
 * Task T002 processed and moved to completed.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): PROCESS
 * Error: No tasks in the pending queue to process.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): VIEW_PENDING
 * --- Pending Tasks ---
 * (No pending tasks)
 * ---------------------
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): VIEW_COMPLETED
 * --- Completed Tasks ---
 * [T001] Implement feature X (Priority: HIGH, Completed: true)
 * [T002] Write documentation (Priority: LOW, Completed: true)
 * -----------------------
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): INVALID_COMMAND
 * Error: Invalid command. Please use ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, or EXIT.
 * 
 * Enter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT): EXIT
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should implement the classes and logic described above, demonstrating correct usage of all required Java components and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a `Task Processing System` that fulfills all the requirements of the exam question, demonstrating the practical use of the specified Java components and best practices.
 * 
 * 1.  **`Task` Class and `Priority` Enum:**
 *     *   The `Task` class encapsulates task data (`id`, `description`, `priority`, `isCompleted`) using private fields and public getters, adhering to encapsulation principles.
 *     *   The `Priority` enum provides a type-safe way to represent priority levels (`HIGH`, `MEDIUM`, `LOW`).
 *     *   The `Task` constructor includes basic validation for non-empty strings and non-null priority, throwing `IllegalArgumentException` on failure.
 *     *   `markComplete()` is a simple method to update the task's status.
 *     *   `toString()` is overridden for clear output formatting.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the core logic of the system.
 *     *   Uses `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList`. `LinkedList` is a common implementation for `Queue` as it supports efficient adding to the end and removing from the beginning. `offer()` is used for adding to the queue, and `poll()` is used for removing from the head, which are standard `Queue` operations.
 *     *   Uses `java.util.List<Task>` (`completedTasks`) declared as the interface type `List` but implemented by `java.util.ArrayList`. This demonstrates polymorphism (coding to the interface). `ArrayList` is suitable for storing completed tasks as we primarily need to add to it and iterate through it.
 *     *   `addTask()` simply adds a task to the pending queue.
 *     *   `processNextTask()` demonstrates queue processing: it attempts to `poll()` a task. If `poll()` returns `null` (queue is empty), it reports an error to `System.err`. Otherwise, it marks the task complete and adds it to the completed list.
 *     *   `getPendingTasks()` and `getCompletedTasks()` return *new* `ArrayList` instances containing the current elements. This is a good practice to prevent external code from modifying the internal state (the queue or list) directly.
 * 
 * 3.  **`TaskSystem` (Main Class):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes a `Scanner` for input and a `TaskManager`.
 *     *   The main application loop runs until the user enters `EXIT`.
 *     *   A `switch` statement is used to direct control based on the user's command, demonstrating flow control.
 *     *   Each case in the `switch` handles a specific command, interacting with the `TaskManager`.
 *     *   `System.out` is used for user prompts and successful output.
 *     *   `System.err` is used for reporting invalid commands (in the `default` case of the `switch`) and operational errors (like trying to process an empty queue, handled within `TaskManager` and reported there).
 * 
 * 4.  **Input Handling and Validation:**
 *     *   `Scanner.nextLine()` is used consistently to read whole lines, avoiding common pitfalls with mixing `nextLine()` and `next()`.
 *     *   Input for priority is read as a string and converted to the `Priority` enum using `Priority.valueOf()`. This is wrapped in a `try-catch (IllegalArgumentException)` to handle cases where the user enters an invalid priority string.
 *     *   Basic validation for non-empty ID and description is included in the `Task` constructor.
 *     *   Error messages for input validation are printed to `System.err`.
 * 
 * 5.  **Exception Handling:**
 *     *   A `try-catch(Exception e)` block wraps the entire `while` loop in `main`. This provides a top-level safety net, catching any unexpected exceptions that might occur during the execution of commands and preventing the program from crashing abruptly. It prints an error message and the stack trace to `System.err`.
 *     *   Specific `try-catch` blocks are used within the `ADD` case to handle expected exceptions like `IllegalArgumentException` that can arise from invalid user input (e.g., invalid priority string, empty ID/description caught by the `Task` constructor). These are caught, reported to `System.err` with a user-friendly message, and allow the program to continue.
 *     *   A `finally` block is used to ensure the `Scanner` resource is closed properly, regardless of whether an exception occurred.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful class, method, and variable names (`Task`, `TaskManager`, `pendingTasks`, `processNextTask`, `getCompletedTasks`, `priorityStr`).
 *     *   Private fields and public methods enforce encapsulation.
 *     *   Basic Javadoc-style comments explain the purpose of classes, constructors, and key methods.
 *     *   Code is structured logically into separate classes based on responsibility.
 *     *   Consistent use of `System.out` and `System.err` for different types of output.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating robust input handling, error management, and adherence to fundamental object-oriented principles and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum for task priority levels
enum Priority {
    HIGH, MEDIUM, LOW
}

// Represents a single task in the system
class Task {
    private String id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     *
     * @param id          The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority    The priority level of the task.
     */
    public Task(String id, String description, Priority priority) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        if (priority == null) {
            throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.id = id.trim();
        this.description = description.trim();
        this.priority = priority;
        this.isCompleted = false; // Tasks start as not completed
    }

    // --- Getters ---
    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markComplete() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the Task object.
     *
     * @return A formatted string including task details.
     */
    @Override
    public String toString() {
        return String.format("[%s] %s (Priority: %s, Completed: %b)",
                             id, description, priority, isCompleted);
    }
}

// Manages the collection of pending and completed tasks
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing task queues and lists.
     */
    public TaskManager() {
        // Use LinkedList as the implementation for the Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as the implementation for the List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param task The Task object to add.
     */
    public void addTask(Task task) {
        // Basic validation already in Task constructor,
        // but could add check for duplicate IDs here if required.
        this.pendingTasks.offer(task); // offer is preferred over add for queues
        System.out.println("Task " + task.getId() + " added to pending queue.");
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task, marks it complete, and moves it to the completed list.
     * Reports an error via System.err if the queue is empty.
     */
    public void processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask);
            nextTask.markComplete();
            completedTasks.add(nextTask);
            System.out.println("Task " + nextTask.getId() + " processed and moved to completed.");
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
        }
    }

    /**
     * Gets a list of all pending tasks.
     *
     * @return A new ArrayList containing tasks from the pending queue.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     *
     * @return A new ArrayList containing tasks from the completed list.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(completedTasks);
    }
}

// Main class containing the command-line interface
public class TaskSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("--- Task Processing System ---");

        // Class-wide exception handling around the main command loop
        try {
            while (running) {
                System.out.println("\nEnter command (ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, EXIT):");
                String command = scanner.nextLine().trim().toUpperCase(); // Read command and normalize

                // Use switch statement for flow control based on command
                switch (command) {
                    case "ADD":
                        try {
                            System.out.print("Enter Task ID: ");
                            String id = scanner.nextLine().trim();
                            System.out.print("Enter Description: ");
                            String description = scanner.nextLine().trim();
                            System.out.print("Enter Priority (HIGH, MEDIUM, LOW): ");
                            String priorityStr = scanner.nextLine().trim();

                            // Input validation and parsing for Priority
                            Priority priority = Priority.valueOf(priorityStr.toUpperCase());

                            // Create and add task
                            Task newTask = new Task(id, description, priority);
                            taskManager.addTask(newTask);

                        } catch (IllegalArgumentException e) {
                            // Catch exceptions from Task constructor or Priority.valueOf
                            System.err.println("Input Error: " + e.getMessage());
                            System.err.println("Please ensure ID, Description are not empty and Priority is HIGH, MEDIUM, or LOW.");
                        } catch (Exception e) {
                             // Catch any other unexpected errors during ADD command
                             System.err.println("An unexpected error occurred during task addition: " + e.getMessage());
                        }
                        break;

                    case "PROCESS":
                        taskManager.processNextTask();
                        break;

                    case "VIEW_PENDING":
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = taskManager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("(No pending tasks)");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case "VIEW_COMPLETED":
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = taskManager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("(No completed tasks)");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("-----------------------");
                        break;

                    case "EXIT":
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;

                    default:
                        // Handle invalid commands using System.err
                        System.err.println("Error: Invalid command. Please use ADD, PROCESS, VIEW_PENDING, VIEW_COMPLETED, or EXIT.");
                        break;
                }
            }
        } catch (Exception e) {
            // Top-level catch for any unhandled exceptions during the program execution
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }
}
