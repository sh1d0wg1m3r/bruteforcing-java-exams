/*
 * Exam Question #425
 * Generated on: 2025-05-11 23:09:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Event Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Management System that handles attendee registration and entry processing for various event types. The system needs to manage registered attendees and process attendees arriving at the event entrance, applying different rules based on the event type.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   The system must manage multiple events. Each event has a name and a type (e.g., Concert, Workshop, Conference).
 *     *   Attendees can register for a specific event.
 *     *   Attendees arrive at the event entrance and form a queue.
 *     *   The system processes attendees from the front of the arrival queue based on the event's type.
 *     *   The system should provide a status update for an event (registered count, queue size).
 *     *   The system should be interactive, using a menu-driven interface via console input.
 * 
 * 2.  **Event Types and Processing Rules:**
 *     *   **CONCERT:** Attendees are processed strictly first-come, first-served from the arrival queue. Registration is not checked during entry processing (though registration data might be used elsewhere in a full system, for this task, only the queue matters for entry).
 *     *   **WORKSHOP:** Attendees are processed from the arrival queue. An attendee *must* be found in the registered attendees list for that event to be allowed entry. If not registered, they are rejected.
 *     *   **CONFERENCE:** Attendees are processed from the arrival queue. An attendee *must* be found in the registered attendees list for that event to be allowed entry. If not registered, they are rejected. (Similar to Workshop for this task's scope, demonstrating registration check).
 * 
 * 3.  **Technical Constraints & Required Components:**
 *     *   You **must** use `java.util.Queue` to represent the queue of arriving attendees at an event.
 *     *   You **must** use `java.util.ArrayList` to store the list of registered attendees for an event.
 *     *   You **must** declare the registered attendees list using the `java.util.List` interface type.
 *     *   You **must** use `java.util.Scanner` to read user input from the console.
 *     *   You **must** use a `switch` statement for flow control (e.g., handling menu options, processing based on event type).
 *     *   You **must** use `System.err` exclusively for printing error messages (invalid input, attendee not registered, event not found, etc.).
 *     *   You **must** use `System.out` for all other output (menu, prompts, success messages, status updates).
 *     *   You **must** implement class-wide exception handling using `try-catch` blocks to gracefully handle errors like invalid input or operations on non-existent events. Consider creating a custom exception for "Event Not Found".
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform input validation where necessary (e.g., menu choice, event existence).
 *     *   Ensure proper error handling using the required `System.err` and `try-catch`.
 *     *   Maintain a clean code structure.
 * 
 * **Task Breakdown:**
 * 
 * 1.  Create necessary classes: `Attendee`, `EventType` (enum), `Event`, `EventManager`, and a main application class (e.g., `EventSystemApp`).
 * 2.  Implement the logic within these classes according to the requirements.
 * 3.  Create the main application loop with a menu using `Scanner` and `switch`.
 * 4.  Implement the exception handling mechanism.
 * 5.  Ensure all required components are used correctly and effectively.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Event Management System ---
 * 1. Add Event
 * 2. Register Attendee
 * 3. Attendee Arrives
 * 4. Process Next Arriving Attendee
 * 5. View Event Status
 * 6. Exit
 * Enter choice: 1
 * Enter event name: Java Workshop
 * Select event type (CONCERT, WORKSHOP, CONFERENCE): WORKSHOP
 * Event 'Java Workshop' (WORKSHOP) added.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 2
 * Enter event name to register for: Java Workshop
 * Enter attendee name: Alice
 * Attendee 'Alice' registered for 'Java Workshop'.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 3
 * Enter event name attendee is arriving at: Java Workshop
 * Enter arriving attendee name: Alice
 * Attendee 'Alice' added to arrival queue for 'Java Workshop'.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 4
 * Enter event name to process attendee for: Java Workshop
 * Processing attendee for 'Java Workshop'...
 * Attendee 'Alice' entered 'Java Workshop'.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 3
 * Enter event name attendee is arriving at: Java Workshop
 * Enter arriving attendee name: Bob
 * Attendee 'Bob' added to arrival queue for 'Java Workshop'.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 4
 * Enter event name to process attendee for: Java Workshop
 * Processing attendee for 'Java Workshop'...
 * ERROR: Attendee 'Bob' is not registered for 'Java Workshop'. Entry denied.
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 5
 * Enter event name to view status: Java Workshop
 * Event Status: 'Java Workshop' (WORKSHOP)
 * Registered Attendees: 1
 * Arrival Queue Size: 0
 * 
 * --- Event Management System ---
 * ...
 * Enter choice: 6
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation according to the rules.
 * *   Proper usage of ALL required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Robustness of input validation and exception handling (`try-catch`, `System.err`).
 * *   Cleanliness and structure of the code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * The provided solution implements a simplified Event Management System adhering to all specified requirements and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** Used in the `Event` class (`arrivingAttendees`) to model the line of attendees waiting to enter the event. Attendees are added using `offer()` and removed from the front using `poll()`, demonstrating typical queue operations (FIFO - First-In, First-Out).
 * 2.  **`java.util.ArrayList`:** Used in the `Event` class (`registeredAttendees`) to store the list of attendees who have registered for the event. This allows for dynamic resizing and easy checking if an attendee is registered using `contains()`.
 * 3.  **`java.util.List`:** The `registeredAttendees` field in the `Event` class is declared using the `List` interface type (`private List<Attendee> registeredAttendees;`), while being instantiated as an `ArrayList` (`new ArrayList<>();`). This demonstrates the principle of programming to interfaces, promoting flexibility.
 * 4.  **`java.util.Scanner`:** Used in the `main` method of `EventSystemApp` to read user input from `System.in`, enabling the interactive menu-driven interface.
 * 5.  **`switch` statement:**
 *     *   Used in the `main` method (`EventSystemApp`) to control the main application flow based on the user's menu choice.
 *     *   Used in the `processNextArrivingAttendee` method (`Event`) to apply different entry processing logic based on the `EventType` (CONCERT, WORKSHOP, CONFERENCE).
 * 6.  **`System.err`:** Used specifically for printing error messages, such as invalid menu choices, `NumberFormatException`, `EventNotFoundException`, and the message when an attendee is not registered for a Workshop or Conference. This distinguishes error output from normal program output.
 * 7.  **`System.out`:** Used for all standard output, including the menu display, prompts for input, confirmation messages (event added, attendee registered/arrived), successful entry messages, and event status information.
 * 8.  **Class-wide Exception Handling (`try-catch`)**:
 *     *   A `try-catch` block wraps the main `while` loop in `EventSystemApp` to catch potential unexpected exceptions during program execution.
 *     *   `try-catch` blocks are used around calls to `EventManager` methods (like `registerAttendee`, `attendeeArrives`, etc.) within the `switch` statement to catch the custom `EventNotFoundException`.
 *     *   A `try-catch` block is used around `Integer.parseInt(scanner.nextLine())` to handle `NumberFormatException` if the user enters non-numeric input for the menu choice.
 *     *   A custom exception `EventNotFoundException` is defined and used to signal when an operation is attempted on an event that does not exist, promoting clearer error handling than using generic exceptions.
 * 9.  **Best Practices:**
 *     *   **Encapsulation:** Class fields (`name`, `type`, `registeredAttendees`, `arrivingAttendees`, `events`) are declared as `private`, and access/modification is controlled through public methods (`getName`, `registerAttendee`, `addEvent`, etc.).
 *     *   **Meaningful Names:** Class names (`Attendee`, `Event`, `EventManager`), enum (`EventType`), variables (`eventName`, `registeredAttendees`, `arrivingAttendees`), and methods (`addEvent`, `registerAttendee`, `processNextArrivingAttendee`) have descriptive names indicating their purpose.
 *     *   **Comments and Documentation:** Basic comments explain the purpose of classes, methods, and key logic sections. Javadoc-style comments are included for the custom exception and main classes.
 *     *   **Input Validation:** The code checks if the menu input is a valid integer and within the range of options. It also attempts to validate the `EventType` input using `EventType.valueOf()`. The `EventManager` checks for duplicate event names.
 *     *   **Error Handling:** Errors are handled using `try-catch`, `System.err` for output, and a custom exception type. Invalid operations (like processing an attendee for a non-existent event or an unregistered attendee for a Workshop/Conference) are caught and reported.
 *     *   **Clean Code Structure:** The code is organized into separate classes with distinct responsibilities (`Attendee` for data, `EventType` for constants, `Event` for event state and logic, `EventManager` for managing multiple events, `EventSystemApp` for the application entry point and UI). The `main` method is kept relatively clean by delegating complex logic to the `EventManager`. The `Scanner` is closed in a `finally` block upon program exit.
 * 
 * The solution effectively combines these Java features to create a functional and well-structured application that meets the complex requirements of the task.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList; // Common implementation for Queue
import java.util.Queue;
import java.util.Scanner;
import java.util.HashMap; // To store events by name
import java.util.Map;

// Custom exception for when an event is not found
class EventNotFoundException extends Exception {
    public EventNotFoundException(String message) {
        super(message);
    }
}

// Represents an attendee
class Attendee {
    private String name;

    public Attendee(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    // Simple equals based on name for checking registration
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return name != null ? name.equalsIgnoreCase(attendee.name) : attendee.name == null;
    }

    @Override
    public int hashCode() {
        return name != null ? name.toLowerCase().hashCode() : 0;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Defines the types of events
enum EventType {
    CONCERT,
    WORKSHOP,
    CONFERENCE
}

// Represents an event with its attendees
class Event {
    private String name;
    private EventType type;
    private List<Attendee> registeredAttendees; // Required: List interface type, ArrayList implementation
    private Queue<Attendee> arrivingAttendees; // Required: Queue interface type

    public Event(String name, EventType type) {
        this.name = name;
        this.type = type;
        this.registeredAttendees = new ArrayList<>(); // Required: ArrayList instantiation
        this.arrivingAttendees = new LinkedList<>(); // Required: Queue implementation
    }

    public String getName() {
        return name;
    }

    public EventType getType() {
        return type;
    }

    public void registerAttendee(Attendee attendee) {
        if (!registeredAttendees.contains(attendee)) {
            registeredAttendees.add(attendee);
            System.out.println("Attendee '" + attendee.getName() + "' registered for '" + this.name + "'.");
        } else {
            System.out.println("Attendee '" + attendee.getName() + "' is already registered for '" + this.name + "'.");
        }
    }

    public void addArrivingAttendee(Attendee attendee) {
        arrivingAttendees.offer(attendee); // offer is preferred over add for queues (returns false instead of throwing exception)
        System.out.println("Attendee '" + attendee.getName() + "' added to arrival queue for '" + this.name + "'.");
    }

    public Attendee processNextArrivingAttendee() {
        Attendee attendee = arrivingAttendees.poll(); // poll is preferred over remove (returns null instead of throwing exception)
        if (attendee == null) {
            System.out.println("No attendees in the arrival queue for '" + this.name + "'.");
            return null;
        }

        System.out.println("Processing attendee '" + attendee.getName() + "' for '" + this.name + "'...");

        // Required: Switch statement based on event type
        switch (this.type) {
            case CONCERT:
                // Concerts: First-come, first-served. No registration check needed for entry.
                System.out.println("Attendee '" + attendee.getName() + "' entered '" + this.name + "'. (Concert)");
                break;
            case WORKSHOP:
            case CONFERENCE:
                // Workshops/Conferences: Must be registered to enter.
                if (registeredAttendees.contains(attendee)) {
                    System.out.println("Attendee '" + attendee.getName() + "' entered '" + this.name + "'. (" + this.type + ")");
                } else {
                    // Required: System.err for error message
                    System.err.println("ERROR: Attendee '" + attendee.getName() + "' is not registered for '" + this.name + "'. Entry denied. (" + this.type + ")");
                    // Attendee is discarded from the queue
                }
                break;
            default:
                // Should not happen with enum, but good practice
                System.err.println("ERROR: Unknown event type '" + this.type + "' for event '" + this.name + "'. Cannot process attendee.");
                break;
        }
        return attendee; // Return processed attendee (or null if queue was empty)
    }

    public void displayStatus() {
        System.out.println("Event Status: '" + name + "' (" + type + ")");
        System.out.println("Registered Attendees: " + registeredAttendees.size());
        System.out.println("Arrival Queue Size: " + arrivingAttendees.size());
        // Optional: print queue/registered attendees details
        // System.out.println("Queue: " + arrivingAttendees);
        // System.out.println("Registered: " + registeredAttendees);
    }
}

// Manages all events
class EventManager {
    // Using a Map for easy lookup of events by name
    private Map<String, Event> events;

    public EventManager() {
        this.events = new HashMap<>();
    }

    public void addEvent(String name, EventType type) {
        if (events.containsKey(name.toLowerCase())) {
            System.err.println("ERROR: Event with name '" + name + "' already exists.");
        } else {
            Event newEvent = new Event(name, type);
            events.put(name.toLowerCase(), newEvent); // Store lowercase name for case-insensitive lookup
            System.out.println("Event '" + name + "' (" + type + ") added.");
        }
    }

    // Helper method to find an event, throws custom exception if not found
    private Event getEvent(String name) throws EventNotFoundException {
        Event event = events.get(name.toLowerCase());
        if (event == null) {
            throw new EventNotFoundException("Event '" + name + "' not found.");
        }
        return event;
    }

    public void registerAttendee(String eventName, String attendeeName) throws EventNotFoundException {
        Event event = getEvent(eventName);
        Attendee attendee = new Attendee(attendeeName);
        event.registerAttendee(attendee);
    }

    public void attendeeArrives(String eventName, String attendeeName) throws EventNotFoundException {
        Event event = getEvent(eventName);
        Attendee attendee = new Attendee(attendeeName);
        event.addArrivingAttendee(attendee);
    }

    public void processNextArrivingAttendee(String eventName) throws EventNotFoundException {
        Event event = getEvent(eventName);
        event.processNextArrivingAttendee();
    }

    public void viewEventStatus(String eventName) throws EventNotFoundException {
        Event event = getEvent(eventName);
        event.displayStatus();
    }

    public void listAllEvents() {
        if (events.isEmpty()) {
            System.out.println("No events currently managed.");
            return;
        }
        System.out.println("--- Available Events ---");
        for (Event event : events.values()) {
            System.out.println("- " + event.getName() + " (" + event.getType() + ")");
        }
        System.out.println("------------------------");
    }
}

// Main application class
public class EventSystemApp {

    public static void main(String[] args) {
        EventManager eventManager = new EventManager();
        Scanner scanner = new Scanner(System.in); // Required: Scanner for user input

        System.out.println("--- Event Management System ---");

        // Required: Class-wide exception handling (wrapping the main loop)
        try {
            while (true) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    // Input validation for menu choice
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("ERROR: Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Required: Switch statement for menu control
                switch (choice) {
                    case 1: // Add Event
                        System.out.print("Enter event name: ");
                        String eventName = scanner.nextLine();
                        System.out.print("Select event type (CONCERT, WORKSHOP, CONFERENCE): ");
                        String typeString = scanner.nextLine().toUpperCase();
                        try {
                            EventType eventType = EventType.valueOf(typeString);
                            eventManager.addEvent(eventName, eventType);
                        } catch (IllegalArgumentException e) {
                            System.err.println("ERROR: Invalid event type '" + typeString + "'. Please use CONCERT, WORKSHOP, or CONFERENCE.");
                        }
                        break;

                    case 2: // Register Attendee
                        System.out.print("Enter event name to register for: ");
                        String regEventName = scanner.nextLine();
                        System.out.print("Enter attendee name: ");
                        String regAttendeeName = scanner.nextLine();
                        try {
                            eventManager.registerAttendee(regEventName, regAttendeeName);
                        } catch (EventNotFoundException e) {
                            System.err.println("ERROR: " + e.getMessage()); // Required: System.err
                        }
                        break;

                    case 3: // Attendee Arrives
                        System.out.print("Enter event name attendee is arriving at: ");
                        String arriveEventName = scanner.nextLine();
                        System.out.print("Enter arriving attendee name: ");
                        String arriveAttendeeName = scanner.nextLine();
                        try {
                            eventManager.attendeeArrives(arriveEventName, arriveAttendeeName);
                        } catch (EventNotFoundException e) {
                            System.err.println("ERROR: " + e.getMessage()); // Required: System.err
                        }
                        break;

                    case 4: // Process Next Arriving Attendee
                        System.out.print("Enter event name to process attendee for: ");
                        String processEventName = scanner.nextLine();
                        try {
                            eventManager.processNextArrivingAttendee(processEventName);
                        } catch (EventNotFoundException e) {
                            System.err.println("ERROR: " + e.getMessage()); // Required: System.err
                        }
                        break;

                    case 5: // View Event Status
                        System.out.print("Enter event name to view status: ");
                        String statusEventName = scanner.nextLine();
                        try {
                            eventManager.viewEventStatus(statusEventName);
                        } catch (EventNotFoundException e) {
                            System.err.println("ERROR: " + e.getMessage()); // Required: System.err
                        }
                        break;

                    case 6: // List All Events
                        eventManager.listAllEvents();
                        break;

                    case 7: // Exit
                        System.out.println("Exiting system.");
                        return; // Exit the program

                    default:
                        System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 7."); // Required: System.err
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Close the scanner resource
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shut down.");
        }
    }

    private static void printMenu() {
        System.out.println("--- Event Management System Menu ---");
        System.out.println("1. Add Event");
        System.out.println("2. Register Attendee");
        System.out.println("3. Attendee Arrives");
        System.out.println("4. Process Next Arriving Attendee");
        System.out.println("5. View Event Status");
        System.out.println("6. List All Events");
        System.out.println("7. Exit");
        System.out.println("------------------------------------");
    }
}
