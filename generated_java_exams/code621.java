/*
 * Exam Question #621
 * Generated on: 2025-05-12 16:15:58
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory and Order Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to simulate a basic warehouse inventory and order processing system. The system should manage a list of inventory items and process customer orders using a queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Inventory Management:** Maintain a list of `InventoryItem` objects. Each `InventoryItem` should have a `name` (String) and a `quantity` (int).
 * 2.  **Order Processing:** Maintain a queue of `Order` objects. Each `Order` should have an `itemName` (String) and a `quantity` (int). Orders are processed in a First-In, First-Out (FIFO) manner.
 * 3.  **User Interface:** Provide a command-line interface allowing the user to perform the following actions:
 *     *   `1`: Add/Update Inventory Item - User provides item name and quantity. If the item exists, update its quantity (add the new quantity to the existing one). If it doesn't exist, add it as a new item.
 *     *   `2`: View Inventory - Display all items currently in inventory with their names and quantities.
 *     *   `3`: Place Order - User provides item name and quantity. Create an `Order` object and add it to the end of the order queue.
 *     *   `4`: Process Next Order - Take the next order from the front of the queue. Attempt to fulfill the order by checking inventory.
 *         *   If the item exists in inventory and there is sufficient quantity, decrease the inventory quantity and print a success message to `System.out`.
 *         *   If the item does not exist or there is insufficient quantity, print an error message to `System.err` and the order is not fulfilled (it's removed from the queue).
 *     *   `5`: View Order Queue - Display all orders currently waiting in the queue.
 *     *   `6`: Exit - Terminate the application.
 * 4.  **Data Structures:**
 *     *   Use `java.util.ArrayList` to store the inventory items. Declare the inventory list using the `java.util.List` interface type.
 *     *   Use `java.util.Queue` (specifically, a concrete implementation like `LinkedList` or `ArrayDeque`) to store the incoming orders.
 * 5.  **User Input:** Use `java.util.Scanner` to read user input from the console.
 * 6.  **Control Flow:** Use a `switch` statement to handle the main menu selections.
 * 7.  **Output:** Use `System.out` for normal application output (menu, inventory list, successful order processing). Use `System.err` for error messages (e.g., invalid input, insufficient stock, order queue empty).
 * 8.  **Error Handling:**
 *     *   Implement input validation using `try-catch` blocks, especially when expecting numeric input. Handle `InputMismatchException` or similar.
 *     *   Handle potential issues during order processing (e.g., empty queue, item not found, insufficient stock).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch any unexpected runtime errors.
 * 9.  **Best Practices:**
 *     *   Use proper encapsulation for `InventoryItem` and `Order` classes (private fields, public getters/setters where necessary, or constructor).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain logic.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and produce output based on the chosen option. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add/Update Inventory
 * 2. View Inventory
 * 3. Place Order
 * 4. Process Next Order
 * 5. View Order Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter item name: Laptop
 * Enter quantity: 10
 * Added/Updated inventory: Laptop, Quantity: 10
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 3
 * Enter item name for order: Laptop
 * Enter quantity for order: 3
 * Order placed for Laptop (Quantity: 3)
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 4
 * Processing order: Laptop (Quantity: 3)
 * Order fulfilled for Laptop (Quantity: 3). Remaining stock: 7
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 4
 * Order queue is empty.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Warehouse System.
 * ```
 * 
 * **Note:** Structure your code within a single class named `WarehouseSystem` for simplicity in this exam context. You can use static methods or make the main logic non-static within `main`. Using non-static methods and creating an instance in `main` is generally better practice for managing state (inventoryList, orderQueue).
 *
 * EXPLANATION:
 * This solution implements the `WarehouseSystem` as requested, demonstrating the use of all specified Java components in a practical scenario.
 * 
 * 1.  **Class Structure:** The code is contained within a single `WarehouseSystem` class. Inner static classes `InventoryItem` and `Order` are used to encapsulate the data for inventory items and orders, respectively. This keeps related data and behavior together. Private fields and public methods (`getters`, `addQuantity`, `decreaseQuantity`) ensure proper encapsulation.
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`, `LinkedList`):**
 *     *   `List<InventoryItem> inventoryList = new ArrayList<>();`: We use the `List` interface type for the `inventoryList`, which is a good practice as it allows flexibility to change the underlying implementation later if needed. `ArrayList` is chosen as the concrete implementation for dynamic resizing and efficient random access (though not heavily used here).
 *     *   `Queue<Order> orderQueue = new LinkedList<>();`: The `Queue` interface is used for `orderQueue`. `LinkedList` is a common implementation that provides efficient FIFO operations (`offer` to add to the end, `poll` to remove from the front).
 * 3.  **User Input (`Scanner`):** A `Scanner` object reads input from `System.in`. It's initialized in the constructor and closed in a `finally` block within `main` to ensure resources are released.
 * 4.  **Control Flow (`switch`):** The `run()` method contains the main application loop. A `switch` statement is used to direct execution based on the user's numeric choice from the menu.
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard output, such as displaying the menu, inventory list, order queue, and successful operation messages.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid user input, insufficient stock during order processing, or an empty order queue. This directs error output to the standard error stream, which can be handled separately by the operating system or development environment.
 * 6.  **Error Handling (`try-catch`, `InputMismatchException`):**
 *     *   **Input Validation:** Within the `run()` method and methods like `addOrUpdateInventory` and `placeOrder`, `try-catch` blocks are used to handle potential `InputMismatchException` when the user enters non-numeric input where a number is expected. The code also checks `scanner.hasNextInt()` before calling `scanner.nextInt()` as a robust way to prevent the exception and handle invalid input gracefully.
 *     *   **Business Logic Errors:** Checks are performed for conditions like negative quantity input, empty item names, empty order queue (`orderQueue.poll()` returning `null`), insufficient stock, or items not found during order processing. Error messages for these conditions are printed to `System.err`.
 *     *   **Class-wide Exception Handling:** The `main` method wraps the call to `system.run()` in a `try-catch(Exception e)` block. This serves as a catch-all for any unexpected exceptions that might propagate up from the application logic, preventing the program from crashing abruptly and providing a final error message and stack trace to `System.err`. A `finally` block ensures the scanner is closed.
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** `InventoryItem` and `Order` classes have private fields and public methods to control access.
 *     *   **Meaningful Names:** Variable names (`inventoryList`, `orderQueue`, `itemName`, `orderQuantity`) and method names (`addOrUpdateInventory`, `processNextOrder`, `viewOrderQueue`) clearly indicate their purpose.
 *     *   **Comments:** Comments are included to explain the purpose of classes, methods, and specific logic sections (like using `poll()` or iterating the queue without removing elements).
 *     *   **Clean Structure:** The code is organized into methods corresponding to menu options, making the `run()` method clean and easy to follow. Helper methods like `displayMenu` improve readability. Input consumption (`scanner.nextLine()`) after reading numbers is correctly handled to prevent issues with subsequent `nextLine()` calls.
 * 
 * This solution effectively combines the required Java features to build a functional, albeit simple, system that demonstrates core programming concepts, data structure usage, and essential error handling techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

public class WarehouseSystem {

    // --- Inner Classes for Data Structures ---
    private static class InventoryItem {
        private String name;
        private int quantity;

        public InventoryItem(String name, int quantity) {
            this.name = name;
            this.quantity = quantity;
        }

        public String getName() {
            return name;
        }

        public int getQuantity() {
            return quantity;
        }

        public void addQuantity(int quantity) {
            if (quantity > 0) {
                this.quantity += quantity;
            }
        }

        public boolean decreaseQuantity(int quantity) {
            if (quantity > 0 && this.quantity >= quantity) {
                this.quantity -= quantity;
                return true;
            }
            return false;
        }

        @Override
        public String toString() {
            return name + " (Quantity: " + quantity + ")";
        }
    }

    private static class Order {
        private String itemName;
        private int quantity;

        public Order(String itemName, int quantity) {
            this.itemName = itemName;
            this.quantity = quantity;
        }

        public String getItemName() {
            return itemName;
        }

        public int getQuantity() {
            return quantity;
        }

        @Override
        public String toString() {
            return itemName + " (Quantity: " + quantity + ")";
        }
    }

    // --- Warehouse System State ---
    private List<InventoryItem> inventoryList;
    private Queue<Order> orderQueue;
    private Scanner scanner;

    // --- Constructor ---
    public WarehouseSystem() {
        // Use List interface type, instantiate with ArrayList
        inventoryList = new ArrayList<>();
        // Use Queue interface type, instantiate with LinkedList (common implementation)
        orderQueue = new LinkedList<>();
        scanner = new Scanner(System.in);
    }

    // --- Main Application Logic ---
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        // Class-wide try-catch block for the main application loop
        try {
            system.run();
        } catch (Exception e) {
            // Catch any unexpected errors during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed even if an error occurs
            system.closeScanner();
        }
    }

    public void run() {
        int choice = -1;
        while (choice != 6) {
            displayMenu();
            System.out.print("Enter your choice: ");

            try {
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } else {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number between 1 and 6.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addOrUpdateInventory();
                        break;
                    case 2:
                        viewInventory();
                        break;
                    case 3:
                        placeOrder();
                        break;
                    case 4:
                        processNextOrder();
                        break;
                    case 5:
                        viewOrderQueue();
                        break;
                    case 6:
                        System.out.println("Exiting Warehouse System.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // This catch is technically redundant due to hasNextInt check,
                // but good practice to show handling specific input errors.
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other exceptions that might occur within a menu option
                System.err.println("An error occurred during operation: " + e.getMessage());
                e.printStackTrace(System.err);
            }
            System.out.println(); // Add a newline for better readability between operations
        }
    }

    private void displayMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add/Update Inventory");
        System.out.println("2. View Inventory");
        System.out.println("3. Place Order");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Order Queue");
        System.out.println("6. Exit");
    }

    private void addOrUpdateInventory() {
        System.out.print("Enter item name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Item name cannot be empty.");
            return;
        }

        int quantity = -1;
        System.out.print("Enter quantity: ");
        try {
            quantity = scanner.nextInt();
            scanner.nextLine(); // Consume the newline
            if (quantity < 0) {
                 System.err.println("Quantity cannot be negative.");
                 return;
            }
        } catch (InputMismatchException e) {
            System.err.println("Invalid quantity input. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
            return;
        }

        boolean found = false;
        for (InventoryItem item : inventoryList) {
            if (item.getName().equalsIgnoreCase(name)) {
                item.addQuantity(quantity); // Update existing item
                System.out.println("Updated inventory: " + item);
                found = true;
                break;
            }
        }

        if (!found) {
            InventoryItem newItem = new InventoryItem(name, quantity);
            inventoryList.add(newItem); // Add new item
            System.out.println("Added new item to inventory: " + newItem);
        }
    }

    private void viewInventory() {
        if (inventoryList.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            System.out.println("--- Current Inventory ---");
            for (int i = 0; i < inventoryList.size(); i++) {
                System.out.println((i + 1) + ". " + inventoryList.get(i));
            }
        }
    }

    private void placeOrder() {
        System.out.print("Enter item name for order: ");
        String itemName = scanner.nextLine().trim();
         if (itemName.isEmpty()) {
            System.err.println("Item name cannot be empty.");
            return;
        }

        int quantity = -1;
        System.out.print("Enter quantity for order: ");
        try {
            quantity = scanner.nextInt();
            scanner.nextLine(); // Consume the newline
            if (quantity <= 0) {
                 System.err.println("Order quantity must be positive.");
                 return;
            }
        } catch (InputMismatchException e) {
            System.err.println("Invalid quantity input. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
            return;
        }

        Order newOrder = new Order(itemName, quantity);
        orderQueue.offer(newOrder); // Add order to the end of the queue
        System.out.println("Order placed: " + newOrder);
    }

    private void processNextOrder() {
        // Use poll() to get and remove the head of the queue, returns null if empty
        Order orderToProcess = orderQueue.poll();

        if (orderToProcess == null) {
            System.err.println("Order queue is empty. Nothing to process.");
            return;
        }

        System.out.println("Processing order: " + orderToProcess);

        String itemName = orderToProcess.getItemName();
        int orderQuantity = orderToProcess.getQuantity();
        boolean fulfilled = false;

        // Find the item in inventory
        for (InventoryItem item : inventoryList) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                // Attempt to decrease quantity
                if (item.decreaseQuantity(orderQuantity)) {
                    System.out.println("Order fulfilled for " + orderToProcess.getItemName() +
                                       " (Quantity: " + orderQuantity + "). Remaining stock: " + item.getQuantity());
                    fulfilled = true;
                } else {
                    // Insufficient stock
                    System.err.println("Failed to fulfill order for " + orderToProcess.getItemName() +
                                       ": Insufficient stock. Needed " + orderQuantity + ", have " + item.getQuantity() + ".");
                }
                break; // Found item, stop searching inventory
            }
        }

        // If loop finishes and not fulfilled, item wasn't found
        if (!fulfilled) {
             // Check again if it failed due to insufficient stock (already printed err)
             // or because item wasn't found at all.
             boolean itemExists = false;
             for(InventoryItem item : inventoryList) {
                 if(item.getName().equalsIgnoreCase(itemName)) {
                     itemExists = true;
                     break;
                 }
             }
             if (!itemExists) {
                System.err.println("Failed to fulfill order for " + orderToProcess.getItemName() +
                                   ": Item not found in inventory.");
             }
        }
    }

    private void viewOrderQueue() {
        if (orderQueue.isEmpty()) {
            System.out.println("Order queue is empty.");
        } else {
            System.out.println("--- Current Order Queue (FIFO) ---");
            // Iterate through the queue without removing elements
            int i = 1;
            for (Order order : orderQueue) {
                System.out.println(i++ + ". " + order);
            }
        }
    }

    // Method to close the scanner
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }
}
