/*
 * Exam Question #533
 * Generated on: 2025-05-11 23:25:40
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:** Design and implement a simple command-line application to manage a queue of print jobs. This task requires you to demonstrate your understanding of core Java data structures, control flow, input/output, exception handling, and object-oriented principles.
 * 
 * **Scenario:** You are building a simulation of a basic print server. Users can submit print jobs, which are placed in a queue. An administrator can process the next job in the queue, view the list of pending jobs, or view the list of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Create a `PrintJob` class:**
 *     *   Represent a single print job with the following private fields:
 *         *   `jobId` (int): A unique identifier for the job.
 *         *   `userName` (String): The name of the user who submitted the job.
 *         *   `fileName` (String): The name of the file to be printed.
 *         *   `status` (String): The current status of the job (e.g., "PENDING", "PROCESSING", "COMPLETED").
 *     *   Include a constructor to initialize a new job with user name, file name, and set its initial status to "PENDING". The `jobId` should be assigned uniquely by the system managing the jobs.
 *     *   Provide public getter methods for all fields.
 *     *   Include a public method `markAsCompleted()` to change the job's status to "COMPLETED".
 *     *   Override the `toString()` method to provide a concise string representation of the job (e.g., `[ID: 1, User: alice, File: report.pdf, Status: PENDING]`).
 * 
 * 2.  **Create a `PrintJobManager` class:**
 *     *   Manage the collection of print jobs.
 *     *   Use a `java.util.Queue` to store jobs that are pending processing. Choose an appropriate implementation (e.g., `ArrayDeque` or `LinkedList`).
 *     *   Use a `java.util.List` (specifically, a `java.util.ArrayList`) to store jobs that have been completed.
 *     *   Maintain a private counter for the next available job ID to ensure uniqueness.
 *     *   Implement the following public methods:
 *         *   `submitJob(String userName, String fileName)`: Creates a new `PrintJob`, assigns it the next available ID, and adds it to the pending jobs queue. Print a confirmation message to `System.out`.
 *         *   `processNextJob()`: Removes the job at the head of the pending queue. If a job is successfully retrieved, update its status to "COMPLETED" and add it to the completed jobs list. Print a confirmation message to `System.out`. If the queue is empty, print an error message to `System.err`.
 *         *   `viewPendingJobs()`: Print the contents of the pending jobs queue to `System.out`. If the queue is empty, print a message indicating so.
 *         *   `viewCompletedJobs()`: Print the contents of the completed jobs list to `System.out`. If the list is empty, print a message indicating so.
 * 
 * 3.  **Create a main application class (e.g., `PrintJobSystem`) with a `main` method:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a text-based menu system with the following options:
 *         1.  Submit New Print Job
 *         2.  Process Next Job
 *         3.  View Pending Jobs Queue
 *         4.  View Completed Jobs List
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Call the appropriate methods of the `PrintJobManager` instance based on the user's choice.
 *     *   Implement input validation for the menu choice. If the user enters non-numeric input or a number outside the valid range (1-5), display an error message using `System.err` and prompt again.
 *     *   Wrap the main application loop or core input processing logic in a class-wide `try-catch` block to handle potential unexpected exceptions during runtime (e.g., issues with Scanner, though specific catches for input errors are also recommended). Print the error message to `System.err`.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, empty queue).
 * 
 * 4.  **Adhere to Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc documentation for classes and methods.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Structure your code logically into separate classes and methods.
 * 
 * **Expected Output:**
 * The application should display a menu, accept user input, and perform the requested actions, printing status and job information to `System.out` or error messages to `System.err` as required.
 * 
 * ```
 * --- Print Job Management System ---
 * 1. Submit New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs Queue
 * 4. View Completed Jobs List
 * 5. Exit
 * Enter your choice: <user input>
 * ... (system output based on choice)
 * ```
 * 
 * Submitting a job:
 * ```
 * Enter User Name: <user name>
 * Enter File Name: <file name>
 * Print job submitted successfully.
 * ```
 * 
 * Processing a job:
 * ```
 * Processing next job...
 * Job [ID: X, User: ..., File: ..., Status: COMPLETED] processed.
 * ```
 * If queue is empty:
 * ```
 * Error: No pending jobs to process.
 * ```
 * 
 * Viewing queues/lists:
 * ```
 * --- Pending Jobs ---
 * [ID: ..., User: ..., File: ..., Status: PENDING]
 * [ID: ..., User: ..., File: ..., Status: PENDING]
 * ...
 * --- End Pending Jobs ---
 * ```
 * If pending queue is empty:
 * ```
 * --- Pending Jobs ---
 * No pending jobs.
 * --- End Pending Jobs ---
 * ```
 * 
 * ```
 * --- Completed Jobs ---
 * [ID: ..., User: ..., File: ..., Status: COMPLETED]
 * [ID: ..., User: ..., File: ..., Status: COMPLETED]
 * ...
 * --- End Completed Jobs ---
 * ```
 * If completed list is empty:
 * ```
 * --- Completed Jobs ---
 * No completed jobs.
 * --- End Completed Jobs ---
 * ```
 * 
 * Exit:
 * ```
 * Exiting Print Job System. Goodbye!
 * ```
 * 
 * Invalid input:
 * ```
 * Error: Invalid input. Please enter a number.
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * ```
 *
 * EXPLANATION:
 * This solution implements a basic Print Job Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * **PrintJob Class:**
 * *   Acts as a simple Plain Old Java Object (POJO) representing a print job.
 * *   Uses private fields (`jobId`, `userName`, `fileName`, `status`) to enforce encapsulation.
 * *   Provides public getter methods to access the data.
 * *   Includes a `markAsCompleted()` method to change the internal state, showcasing object behavior.
 * *   Overrides `toString()` for easy printing and debugging.
 * 
 * **PrintJobManager Class:**
 * *   Manages the core logic and data structures.
 * *   Uses a `java.util.Queue<PrintJob>` (`LinkedList` implementation chosen as required) to store `pendingJobs`. The Queue's FIFO (First-In, First-Out) nature is perfect for processing jobs in the order they were submitted. `offer()` is used for adding and `poll()` for removing, which are standard Queue operations.
 * *   Uses a `java.util.List<PrintJob>` (`ArrayList` implementation chosen as required) to store `completedJobs`. An `ArrayList` provides a dynamic, ordered collection suitable for keeping track of finished tasks.
 * *   Maintains a `nextJobId` counter to assign unique IDs to new jobs, demonstrating simple state management within the manager.
 * *   Includes methods (`submitJob`, `processNextJob`, `viewPendingJobs`, `viewCompletedJobs`) that encapsulate specific actions within the system. These methods interact with the data structures. `processNextJob` includes error handling for the case where the queue is empty, printing to `System.err`.
 * 
 * **PrintJobSystem Class (Main Application):**
 * *   Contains the `main` method, the entry point of the application.
 * *   Uses `java.util.Scanner` to read input from `System.in`.
 * *   Implements a menu-driven interface using `System.out` for prompts and output.
 * *   Employs a `switch` statement to direct execution based on the user's menu choice, providing clear flow control.
 * *   Includes robust input validation for the menu choice using a `while` loop and a `try-catch` block specifically for `InputMismatchException`. This catches non-integer input and prompts the user again. `System.err` is used for these validation errors.
 * *   A class-wide `try-catch` block is wrapped around the main `run()` method's loop. This fulfills the requirement for class-wide exception handling, catching any unexpected `Exception` that might occur during the program's execution and printing details to `System.err`. A `finally` block ensures the `Scanner` is closed.
 * *   Helper methods (`displayMenu`, `submitJob`, `processJob`, `viewPending`, `viewCompleted`) break down the main logic into smaller, manageable units, improving code readability and maintainability. Note the careful handling of `scanner.nextLine()` after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 * 
 * **Overall:**
 * The solution demonstrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) integrated into a functional application. It follows object-oriented principles with separate classes for data (`PrintJob`) and logic (`PrintJobManager`, `PrintJobSystem`). Best practices like encapsulation, meaningful names, comments, input validation, and error handling are applied throughout the code. The use of `Queue` for pending items and `List` for completed items appropriately reflects their typical use cases in managing sequential tasks and historical records.
 */

import java.util.ArrayList;
import java.util.LinkedList; // Using LinkedList as a Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for input type issues

/**
 * Represents a single print job in the system.
 */
class PrintJob {
    private int jobId;
    private String userName;
    private String fileName;
    private String status; // e.g., "PENDING", "PROCESSING", "COMPLETED"

    /**
     * Constructs a new PrintJob.
     *
     * @param jobId The unique ID for the job.
     * @param userName The name of the user submitting the job.
     * @param fileName The name of the file to print.
     */
    public PrintJob(int jobId, String userName, String fileName) {
        this.jobId = jobId;
        this.userName = userName;
        this.fileName = fileName;
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getUserName() {
        return userName;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the job's status as "COMPLETED".
     */
    public void markAsCompleted() {
        this.status = "COMPLETED";
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string representing the job.
     */
    @Override
    public String toString() {
        return String.format("[ID: %d, User: %s, File: %s, Status: %s]",
                             jobId, userName, fileName, status);
    }
}

/**
 * Manages the collection of print jobs, including pending and completed jobs.
 */
class PrintJobManager {
    // Use ArrayDeque as a Queue implementation for efficiency
    private Queue<PrintJob> pendingJobs;
    // Use ArrayList for completed jobs as order doesn't matter as much and random access is possible (though not used here)
    private List<PrintJob> completedJobs;
    private int nextJobId; // Counter for assigning unique job IDs

    /**
     * Constructs a new PrintJobManager.
     */
    public PrintJobManager() {
        // Use LinkedList as specified, although ArrayDeque is often preferred for Queue
        this.pendingJobs = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Submits a new print job to the pending queue.
     *
     * @param userName The name of the user.
     * @param fileName The name of the file.
     */
    public void submitJob(String userName, String fileName) {
        PrintJob newJob = new PrintJob(nextJobId++, userName, fileName);
        pendingJobs.offer(newJob); // offer() is preferred over add() in queues as it doesn't throw exception on capacity limits (though LinkedList doesn't have capacity limits)
        System.out.println("Print job submitted successfully.");
    }

    /**
     * Processes the next job from the pending queue.
     * Removes the job, marks it as completed, and moves it to the completed list.
     */
    public void processNextJob() {
        System.out.println("Processing next job...");
        PrintJob jobToProcess = pendingJobs.poll(); // poll() retrieves and removes the head, returns null if queue is empty

        if (jobToProcess != null) {
            jobToProcess.markAsCompleted();
            completedJobs.add(jobToProcess);
            System.out.println("Job " + jobToProcess.toString() + " processed.");
        } else {
            System.err.println("Error: No pending jobs to process.");
        }
    }

    /**
     * Displays the list of pending jobs currently in the queue.
     */
    public void viewPendingJobs() {
        System.out.println("--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            // Iterating through the queue without removing elements
            for (PrintJob job : pendingJobs) {
                System.out.println(job);
            }
        }
        System.out.println("--- End Pending Jobs ---");
    }

    /**
     * Displays the list of completed jobs.
     */
    public void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No completed jobs.");
        } else {
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("--- End Completed Jobs ---");
    }
}

/**
 * Main application class for the Print Job Management System.
 * Handles user interaction and controls the PrintJobManager.
 */
public class PrintJobSystem {

    private PrintJobManager manager;
    private Scanner scanner;

    /**
     * Constructs a new PrintJobSystem, initializing manager and scanner.
     */
    public PrintJobSystem() {
        manager = new PrintJobManager();
        // Using System.in for console input
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block as required
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Initialize choice

                // Input validation loop for menu choice
                while (true) {
                    try {
                        System.out.print("Enter your choice: ");
                        choice = scanner.nextInt();
                        // Consume the rest of the line after reading the integer
                        scanner.nextLine();
                        // Check if choice is within the valid range
                        if (choice >= 1 && choice <= 5) {
                            break; // Valid input, exit the inner loop
                        } else {
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        }
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number.");
                        // Consume the invalid input to prevent infinite loop
                        scanner.next();
                        // Consume the rest of the line as next() doesn't consume the newline
                        scanner.nextLine();
                    }
                }

                // Use switch statement for flow control based on valid choice
                switch (choice) {
                    case 1:
                        submitJob();
                        break;
                    case 2:
                        processJob();
                        break;
                    case 3:
                        viewPending();
                        break;
                    case 4:
                        viewCompleted();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Print Job System. Goodbye!");
                        break;
                    // Default case is handled by the input validation loop above
                }
                System.out.println(); // Add a newline for spacing after each action
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging unexpected errors
             e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
             System.out.println("Scanner closed."); // Confirmation for debugging
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("--- Print Job Management System ---");
        System.out.println("1. Submit New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs Queue");
        System.out.println("4. View Completed Jobs List");
        System.out.println("5. Exit");
    }

    /**
     * Prompts the user for job details and submits a new job via the manager.
     */
    private void submitJob() {
        System.out.print("Enter User Name: ");
        String userName = scanner.nextLine(); // Read the entire line for user name
        System.out.print("Enter File Name: ");
        String fileName = scanner.nextLine(); // Read the entire line for file name

        manager.submitJob(userName, fileName);
    }

    /**
     * Triggers the processing of the next pending job via the manager.
     */
    private void processJob() {
        manager.processNextJob();
    }

    /**
     * Displays the pending jobs queue via the manager.
     */
    private void viewPending() {
        manager.viewPendingJobs();
    }

    /**
     * Displays the completed jobs list via the manager.
     */
    private void viewCompleted() {
        manager.viewCompletedJobs();
    }

    /**
     * The entry point of the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobSystem system = new PrintJobSystem();
        system.run();
    }
}
