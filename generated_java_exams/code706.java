/*
 * Exam Question #706
 * Generated on: 2025-05-12 16:28:28
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Processing System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line based system to manage and process tasks. The system should allow users to add tasks to a queue, process the next available task, view the list of pending tasks, view the history of successfully completed tasks, and view tasks that failed processing.
 * 
 * **Requirements:**
 * 
 * Implement a Java class `TaskProcessorSystem` that fulfills the following requirements:
 * 
 * 1.  **Task Storage:**
 *     *   Maintain a queue of tasks waiting to be processed. Use `java.util.Queue`.
 *     *   Maintain a list of tasks that have been successfully completed. Use `java.util.ArrayList` and expose it via the `java.util.List` interface.
 *     *   Maintain a list of tasks that failed processing. Use `java.util.ArrayList` and expose it via the `java.util.List` interface. Tasks should fail processing if their description contains the case-insensitive word "fail".
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and task descriptions from standard input (`System.in`).
 *     *   Implement a command-line interface with the following options:
 *         *   `add`: Add a new task to the queue. Prompts the user for the task description.
 *         *   `process`: Process the next task from the queue.
 *         *   `pending`: Display all tasks currently in the queue.
 *         *   `completed`: Display all tasks that were successfully completed.
 *         *   `failed`: Display all tasks that failed processing.
 *         *   `exit`: Terminate the program.
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 3.  **Processing Logic:**
 *     *   When processing a task:
 *         *   If the queue is empty, print a message indicating no tasks are pending.
 *         *   If the queue is not empty, retrieve (and remove) the next task.
 *         *   Simulate processing: If the task description contains "fail" (case-insensitive), consider it failed. Otherwise, consider it successful.
 *         *   Print a message indicating success or failure for the processed task.
 *         *   Add the task to the appropriate `completedTasks` or `failedTasks` list.
 * 
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, issues during processing simulation).
 *     *   Use `System.out` for all normal output (prompts, successful operations, displaying lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues during user input or processing. The main command loop should be wrapped in a `try-catch`.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc).
 *     *   Validate user input where necessary (e.g., don't add empty task descriptions).
 *     *   Ensure resources like `Scanner` are managed appropriately (e.g., closed).
 * 
 * **Execution:**
 * 
 * The program should start, display a menu or prompt, and continuously accept commands until the user enters `exit`.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Task Processing System Menu:
 * add - Add new task
 * process - Process next task
 * pending - View pending tasks
 * completed - View completed tasks
 * failed - View failed tasks
 * exit - Exit system
 * Enter command:
 * ```
 * *(User enters command)*
 * *(System responds based on command)*
 * ... (repeats until exit)
 * 
 * **Example Interaction:**
 * 
 * ```
 * Task Processing System Menu:
 * ... (menu displayed)
 * Enter command: add
 * Enter task description: Clean the room
 * Task added: Clean the room
 * Enter command: add
 * Enter task description: Write exam question (fail)
 * Task added: Write exam question (fail)
 * Enter command: pending
 * Pending Tasks:
 * 1. Clean the room
 * 2. Write exam question (fail)
 * Enter command: process
 * Processing task: Clean the room
 * Task completed: Clean the room
 * Enter command: process
 * Processing task: Write exam question (fail)
 * Error: Task failed: Write exam question (fail)
 * Enter command: completed
 * Completed Tasks:
 * 1. Clean the room
 * Enter command: failed
 * Failed Tasks:
 * 1. Write exam question (fail)
 * Enter command: exit
 * Exiting Task Processing System.
 * ```
 * 
 * Implement the `TaskProcessorSystem` class with a `main` method to run the system.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskProcessorSystem` class that simulates a basic task management workflow, fulfilling all the specified requirements.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The system logic is encapsulated within the `TaskProcessorSystem` class.
 *     *   The data structures (`taskQueue`, `completedTasks`, `failedTasks`) and the `scanner` are declared as private fields, adhering to encapsulation principles.
 *     *   Public methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `viewFailedTasks`, `run`) provide the interface for interacting with the system.
 * 
 * 2.  **Data Structures:**
 *     *   `taskQueue`: A `java.util.Queue` (implemented using `LinkedList`) is used to store pending tasks. The `offer()` method is used to add tasks (preferred over `add` in queue contexts as it handles capacity constraints gracefully, though not critical here), and `poll()` is used to retrieve and remove the next task. This correctly models a FIFO (First-In, First-Out) task queue.
 *     *   `completedTasks`: An `java.util.ArrayList` is used to store tasks that have been successfully processed. It is declared and managed as a `java.util.List`, demonstrating the use of the interface.
 *     *   `failedTasks`: Another `java.util.ArrayList` is used for tasks that failed processing, also declared and managed as a `java.util.List`.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `java.util.Scanner`: An instance of `Scanner` reads commands and task descriptions from `System.in`.
 *     *   `run()` method: Contains the main loop that drives the system. It repeatedly displays a menu, prompts for input, and processes the command.
 *     *   `switch` statement: Inside the `run()` method, a `switch` statement is used to dispatch the appropriate method calls based on the user's input command string (`"add"`, `"process"`, etc.). This provides clear and efficient flow control for handling multiple discrete commands.
 * 
 * 4.  **Processing Logic:**
 *     *   `addTask(String taskDescription)`: Adds the task to the `taskQueue` using `offer()`. Includes basic input validation to prevent adding empty tasks.
 *     *   `processNextTask()`: Uses `poll()` to get the next task. It checks if the result is `null` to determine if the queue was empty. It then simulates processing by checking if the task description contains "fail" (case-insensitive) using `toLowerCase().contains()`. Based on this simulation, the task is added to either `completedTasks` or `failedTasks`.
 * 
 * 5.  **Output and Error Handling:**
 *     *   `System.out`: Used for standard messages like prompts, task added confirmations, task completed messages, and displaying the contents of the lists.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid commands, empty task descriptions, or simulated task failures. This is standard practice for separating normal output from error output.
 *     *   `try-catch`: A comprehensive `try-catch` block wraps the main `while` loop in the `run()` method. This provides class-wide exception handling for the core operational flow. It catches `InputMismatchException` (although `nextLine()` is used, which is less prone to this than `nextInt()`, it's good practice to show handling potential input issues) and a general `Exception` to catch any other unexpected runtime errors during the command loop. The `finally` block ensures the `Scanner` resource is closed when the `run()` method finishes, regardless of whether an exception occurred or the loop terminated normally. Specific error messages and stack trace printing to `System.err` are included.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names like `taskQueue`, `completedTasks`, `processNextTask`, `viewPendingTasks` make the code readable.
 *     *   Basic Javadoc comments explain the purpose of the class and key methods.
 *     *   Input validation is performed for task descriptions in `addTask`.
 *     *   Error handling is implemented using `try-catch` and appropriate output streams (`System.out`, `System.err`).
 *     *   The code is structured logically with separate methods for different functionalities.
 *     *   The use of `List` interface types for `completedTasks` and `failedTasks` variables demonstrates programming to interfaces.
 * 
 * This solution effectively integrates all the required Java components into a practical, albeit simplified, real-world scenario, demonstrating an understanding of collections, control flow, user interaction, and robust error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A simple system for managing and processing tasks using a queue.
 * Demonstrates usage of Queue, ArrayList, List, Scanner, switch,
 * System.err, System.out, and exception handling.
 */
public class TaskProcessorSystem {

    // Using LinkedList as a Queue implementation
    private Queue<String> taskQueue;
    // Using ArrayList for completed tasks, accessed via List interface
    private List<String> completedTasks;
    // Using ArrayList for failed tasks, accessed via List interface
    private List<String> failedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessorSystem.
     * Initializes the task queue, completed and failed task lists, and the scanner.
     */
    public TaskProcessorSystem() {
        this.taskQueue = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task description to the pending task queue.
     * Validates that the task description is not null or empty.
     *
     * @param taskDescription The description of the task to add.
     */
    public void addTask(String taskDescription) {
        if (taskDescription == null || taskDescription.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        taskQueue.offer(taskDescription.trim()); // offer is generally preferred over add for queues
        System.out.println("Task added: " + taskDescription.trim());
    }

    /**
     * Processes the next task from the queue.
     * Simulates processing and moves the task to either the completed or failed list.
     */
    public void processNextTask() {
        String task = taskQueue.poll(); // Retrieves and removes the head of the queue

        if (task == null) {
            System.out.println("No tasks pending.");
            return;
        }

        System.out.println("Processing task: " + task);

        // Simulate task processing - fail if description contains "fail"
        if (task.toLowerCase().contains("fail")) {
            System.err.println("Error: Task failed: " + task);
            failedTasks.add(task);
        } else {
            System.out.println("Task completed: " + task);
            completedTasks.add(task);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("Pending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("(None)");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (String task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that have been successfully completed.
     */
    public void viewCompletedTasks() {
        System.out.println("Completed Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("(None)");
        } else {
            int index = 1;
            for (String task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks that failed processing.
     */
    public void viewFailedTasks() {
        System.out.println("Failed Tasks:");
        if (failedTasks.isEmpty()) {
            System.out.println("(None)");
        } else {
            int index = 1;
            for (String task : failedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the available commands to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Processing System Menu:");
        System.out.println("add - Add new task");
        System.out.println("process - Process next task");
        System.out.println("pending - View pending tasks");
        System.out.println("completed - View completed tasks");
        System.out.println("failed - View failed tasks");
        System.out.println("exit - Exit system");
    }

    /**
     * Runs the main command loop for the task processing system.
     * Handles user input and dispatches commands.
     * Includes exception handling for the main loop.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter command: ");

                // Ensure there is a next line to read before reading
                if (!scanner.hasNextLine()) {
                     running = false; // Exit if no more input is available (e.g., redirected input)
                     break;
                }

                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        if (scanner.hasNextLine()) {
                            String description = scanner.nextLine();
                            addTask(description);
                        } else {
                             System.err.println("Error: Could not read task description.");
                        }
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "pending":
                        viewPendingTasks();
                        break;
                    case "completed":
                        viewCompletedTasks();
                        break;
                    case "failed":
                        viewFailedTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Unknown command. Please try again.");
                }
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input type. Please enter a valid command.");
            // Consume the invalid input to prevent infinite loop
            if (scanner.hasNextLine()) {
                 scanner.nextLine();
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the program exits or loop terminates
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirm closure
            }
        }
    }

    /**
     * Main method to start the Task Processing System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorSystem system = new TaskProcessorSystem();
        system.run();
    }
}
