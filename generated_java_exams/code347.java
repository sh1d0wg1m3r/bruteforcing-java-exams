/*
 * Exam Question #347
 * Generated on: 2025-05-11 22:58:24
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processor Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a task processing system. This system manages a queue of tasks waiting to be processed, moves tasks through a processing stage (which can sometimes fail), and archives them into lists of completed and failed tasks. The system interacts with a user via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this task processing system. Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a task. Each task should have:
 *     *   An integer `id` (unique, auto-generated or input by user).
 *     *   A String `description`.
 *     *   An integer `priority` (higher number indicates higher priority).
 *     *   A String `status` (e.g., "Pending", "Processing", "Completed", "Failed").
 *     *   Implement appropriate constructors, getters, and a meaningful `toString()` method.
 *     *   Implement a method `simulateProcessing()` within the `Task` class (or a related class) that simulates the processing of the task. This method should *potentially* throw a custom exception `ProcessingException` based on some criteria (e.g., if the task ID is even, or if the description contains a specific keyword like "FAIL").
 * 
 * 2.  **Task Processor:** Create a class named `TaskProcessor` that manages the task flow. It must contain:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   An `ArrayList<Task>` to store successfully completed tasks.
 *     *   A `List<Task>` (using the `List` interface type, instantiated as an `ArrayList`) to store failed tasks.
 *     *   Methods to:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` and adds it to the waiting queue. Generate a simple unique ID (e.g., incrementing counter).
 *         *   `processNextTask()`: Takes the next task from the queue, attempts to process it by calling its `simulateProcessing()` method. If processing is successful, move the task to the completed list and update its status. If `simulateProcessing()` throws `ProcessingException`, move the task to the failed list and update its status. Handle the exception using `try-catch`.
 *         *   `viewStatus()`: Prints the current number of tasks in the queue, completed list, and failed list.
 *         *   `viewCompletedTasks()`: Prints details of all completed tasks.
 *         *   `viewFailedTasks()`: Prints details of all failed tasks.
 * 
 * 3.  **User Interface:** Implement a `main` method (likely in the `TaskProcessor` class or a separate `Main` class) that provides a command-line interface using `Scanner`. The interface should present a menu with options:
 *     *   Add Task
 *     *   Process Next Task
 *     *   View Status
 *     *   View Completed Tasks
 *     *   View Failed Tasks
 *     *   Exit
 *     *   Use a `switch` statement to handle user commands.
 * 
 * 4.  **Exception Handling:**
 *     *   Create a custom checked exception `ProcessingException`.
 *     *   Use `try-catch` blocks for handling `ProcessingException` when processing tasks.
 *     *   Implement class-wide exception handling in the main interaction loop (e.g., in the `main` method or the `TaskProcessor.run()` method) to catch potential exceptions like `InputMismatchException` from `Scanner` or other unexpected runtime errors, preventing the program from crashing and providing informative messages.
 * 
 * 5.  **Input/Output:**
 *     *   Use `Scanner` for all user input.
 *     *   Use `System.out` for menu display, prompts, successful operations, and status/task listings.
 *     *   Use `System.err` for invalid input messages and error messages related to task processing failures or unexpected exceptions caught by the main `try-catch`.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (Javadoc and inline) explaining complex logic.
 *     *   Implement basic input validation (e.g., ensuring priority is positive).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user commands, perform the requested actions, and provide feedback using `System.out` and `System.err` as specified.
 * 
 * *   Adding a task should confirm the task was added.
 * *   Processing a task should indicate success or failure, including the reason if it failed (from the exception).
 * *   Viewing status should show counts.
 * *   Viewing tasks should list their details.
 * *   Invalid input should result in an error message on `System.err`.
 * *   Processing failures should be reported on `System.err`.
 * *   Other unexpected errors should be caught and reported on `System.err`.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Task Processor simulation as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * 1.  **`ProcessingException`:** A custom checked exception is defined to specifically signal failures during task processing simulation. This provides a clear and specific type of error that the `TaskProcessor` can catch and handle differently from other potential errors.
 * 
 * 2.  **`Task` Class:**
 *     *   Represents the data structure for a task with private fields (`id`, `description`, `priority`, `status`) ensuring encapsulation.
 *     *   Public getters provide controlled access to the task's state.
 *     *   A static `nextId` is used for simple unique ID generation.
 *     *   The `simulateProcessing()` method contains the core logic for potential failure, throwing `ProcessingException` based on the defined criteria (even ID or "FAIL" in description). This method simulates an external process that might succeed or fail.
 *     *   `toString()` provides a convenient way to print task details.
 * 
 * 3.  **`TaskProcessor` Class:**
 *     *   Uses a `Queue<Task>` (`LinkedList` implementation) for tasks waiting, correctly modeling a first-in, first-out (FIFO) processing order. `offer()` is used for adding and `poll()` for removing from the queue, which are standard Queue operations.
 *     *   Uses an `ArrayList<Task>` for `completedTasks`, providing dynamic resizing and efficient storage of successful tasks.
 *     *   Uses a `List<Task>` reference type for `failedTasks`, instantiated as an `ArrayList`. This demonstrates programming to the interface (`List`) rather than the concrete implementation (`ArrayList`), a key best practice.
 *     *   `addTask()` creates a new `Task` and adds it to the `taskQueue`, including basic validation for priority.
 *     *   `processNextTask()` is the core processing logic. It uses `taskQueue.poll()` to get the next task. It calls `currentTask.simulateProcessing()` within a `try-catch` block.
 *         *   If `simulateProcessing()` succeeds, the task status is updated to "Completed" and it's added to `completedTasks`.
 *         *   If `ProcessingException` is caught, the task status is set to "Failed", and it's added to `failedTasks`. An informative error message is printed to `System.err`.
 *         *   A general `catch (Exception e)` is included to handle any *other* unexpected errors during simulation, marking the task as failed and printing the error and stack trace to `System.err`.
 *     *   `viewStatus()`, `viewCompletedTasks()`, and `viewFailedTasks()` methods provide the required reporting functionalities, iterating through the respective collections and printing task details to `System.out`.
 * 
 * 4.  **User Interface (`run()` method):**
 *     *   The `run()` method in `TaskProcessor` contains the main application loop.
 *     *   It uses `Scanner` to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement handles the different menu options, calling the appropriate `TaskProcessor` methods.
 *     *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch (Exception e)` block. This serves as a top-level handler for any unhandled exceptions that might occur within the loop (e.g., an unexpected `NullPointerException` or logic error not specifically caught elsewhere). If such an error occurs, the program catches it, prints a critical error message and stack trace to `System.err`, and then the `finally` block executes, closing the `Scanner`.
 *     *   **Input Validation & Handling:** A nested `try-catch` is used specifically around `scanner.nextInt()` calls to catch `InputMismatchException` if the user enters non-integer input where a number is expected. An error message is printed to `System.err`, and the invalid input is consumed from the scanner, preventing an infinite loop.
 *     *   `System.out` is used for the menu, prompts, and successful output.
 *     *   `System.err` is used for invalid input messages and error messages from processing failures or the main error handler.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Method and variable names are descriptive (`taskQueue`, `processNextTask`, `viewCompletedTasks`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections (like the simulation failure criteria).
 *     *   Basic input validation for priority is included.
 *     *   The code is structured into logical classes with clear responsibilities.
 *     *   Programming to the `List` interface for `failedTasks` is demonstrated.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, showcasing exception handling, collection usage, input/output, and object-oriented principles.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom Exception for Task Processing Failures
class ProcessingException extends Exception {
    public ProcessingException(String message) {
        super(message);
    }
}

// Represents a single Task
class Task {
    private int id;
    private String description;
    private int priority;
    private String status; // e.g., "Pending", "Completed", "Failed"

    private static int nextId = 1; // For generating unique IDs

    public Task(String description, int priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.status = "Pending";
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // Setters (used internally by TaskProcessor)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Simulates processing of the task.
     * Throws ProcessingException if the task meets failure criteria.
     * Failure criteria: Task ID is even OR description contains "FAIL".
     *
     * @throws ProcessingException if processing fails.
     */
    public void simulateProcessing() throws ProcessingException {
        // Simulate work...
        System.out.println("  Processing Task ID: " + id + "...");

        // Simulate failure condition
        if (this.id % 2 == 0) {
            throw new ProcessingException("Task ID is even - simulated failure.");
        }
        if (this.description.toUpperCase().contains("FAIL")) {
             throw new ProcessingException("Description contains 'FAIL' - simulated failure.");
        }

        // If no exception is thrown, processing is successful
        System.out.println("  Task ID: " + id + " processed successfully.");
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Priority=" + priority + ", Status='" + status + "']";
    }
}

// Manages the task queue and completed/failed tasks
class TaskProcessor {
    private Queue<Task> taskQueue;
    private ArrayList<Task> completedTasks;
    private List<Task> failedTasks; // Using List interface

    public TaskProcessor() {
        taskQueue = new LinkedList<>(); // LinkedList implements Queue
        completedTasks = new ArrayList<>();
        failedTasks = new ArrayList<>(); // Instantiating as ArrayList
    }

    /**
     * Adds a new task to the waiting queue.
     *
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        if (priority <= 0) {
            System.err.println("Error: Priority must be a positive number.");
            return;
        }
        Task newTask = new Task(description, priority);
        taskQueue.offer(newTask); // offer is preferred over add for queues
        System.out.println("Added task to queue: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * Handles success and failure scenarios using try-catch.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks in the queue to process.");
            return;
        }

        Task currentTask = taskQueue.poll(); // Get and remove the head of the queue
        currentTask.setStatus("Processing");
        System.out.println("Attempting to process: " + currentTask);

        try {
            currentTask.simulateProcessing();
            // If simulateProcessing succeeds (no exception)
            currentTask.setStatus("Completed");
            completedTasks.add(currentTask);
            System.out.println("Task ID " + currentTask.getId() + " successfully completed.");
        } catch (ProcessingException e) {
            // If simulateProcessing throws ProcessingException
            currentTask.setStatus("Failed");
            failedTasks.add(currentTask);
            System.err.println("Task ID " + currentTask.getId() + " failed processing: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected exceptions during processing simulation
             currentTask.setStatus("Failed"); // Or maybe "Error" status
             failedTasks.add(currentTask);
             System.err.println("Task ID " + currentTask.getId() + " encountered an unexpected error during processing: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace to error stream
        }
    }

    /**
     * Prints the current status of the task queues/lists.
     */
    public void viewStatus() {
        System.out.println("\n--- Task System Status ---");
        System.out.println("Tasks in Queue: " + taskQueue.size());
        System.out.println("Completed Tasks: " + completedTasks.size());
        System.out.println("Failed Tasks: " + failedTasks.size());
        System.out.println("--------------------------");
    }

    /**
     * Prints details of all completed tasks.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Prints details of all failed tasks.
     */
    public void viewFailedTasks() {
        System.out.println("\n--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("No tasks have failed yet.");
        } else {
            // Iterate over the List<Task>
            for (Task task : failedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Runs the main user interaction loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                // Catch InputMismatchException for non-integer input
                int choice;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (positive integer): ");
                        int priority;
                        try {
                             priority = scanner.nextInt();
                             scanner.nextLine(); // Consume newline
                             addTask(description, priority);
                        } catch (InputMismatchException e) {
                             System.err.println("Invalid priority. Please enter a number.");
                             scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 2: // Process Next Task
                        processNextTask();
                        break;
                    case 3: // View Status
                        viewStatus();
                        break;
                    case 4: // View Completed Tasks
                        viewCompletedTasks();
                        break;
                    case 5: // View Failed Tasks
                        viewFailedTasks();
                        break;
                    case 6: // Exit
                        System.out.println("Exiting Task Processor. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected critical error occurred!");
            e.printStackTrace(System.err);
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    private void printMenu() {
        System.out.println("\n--- Task Processor Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Status");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
        System.out.println("---------------------------");
    }

    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
