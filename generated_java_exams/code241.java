/*
 * Exam Question #241
 * Generated on: 2025-05-11 22:37:47
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified console-based Hospital Appointment Management System. The system should allow managing patients, doctors, receiving appointment requests, processing them, and viewing the status of appointments.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, exception handling, and object-oriented principles.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Add new patients to the system.
 *     *   Add new doctors to the system (include specialization).
 *     *   Allow patients to request appointments. These requests should be placed in a waiting queue.
 *     *   Process the next appointment request from the queue. This involves taking a request, finding a suitable doctor (you can use a simple matching logic, e.g., find any doctor), creating a scheduled appointment, and moving it to a list of scheduled appointments.
 *     *   View the list of pending appointment requests (the queue).
 *     *   View the list of scheduled appointments.
 *     *   View the list of registered patients.
 *     *   View the list of registered doctors.
 *     *   Exit the application.
 * 
 * 2.  **Required Java Components:** Your solution *must* explicitly use ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (use `List` as the type for variables where appropriate)
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for handling menu options.
 *     *   `System.err` for printing error messages (e.g., invalid input, patient/doctor not found, unable to schedule).
 *     *   `System.out` for printing the menu, prompts, success messages, and displaying lists/queue contents.
 *     *   Class-wide exception handling using `try-catch` blocks. This should include specific handling for anticipated errors (like invalid input format) and a general catch block for unexpected runtime exceptions within the main application loop.
 * 
 * 3.  **Object-Oriented Design:**
 *     *   Create classes for `Patient`, `Doctor`, `AppointmentRequest`, and `Appointment`.
 *     *   Use proper encapsulation (private fields, public getters/setters where necessary, or constructors).
 *     *   The main application logic should reside in a separate class (e.g., `HospitalScheduler`).
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include basic input validation (e.g., checking for empty names, ensuring referenced patients/doctors exist).
 *     *   Provide clear console output for user interaction.
 *     *   Include comments explaining complex parts of the code.
 * 
 * **Input Format:**
 * 
 * The system should present a menu. User input will consist of integers for menu choices and strings/integers for data entry (names, specializations, etc.) as prompted by the system.
 * 
 * **Expected Output:**
 * 
 * *   A clear menu displayed upon starting and after each operation (except exit).
 * *   Prompts for required input based on the chosen menu option.
 * *   Success messages for operations like adding a patient/doctor, requesting an appointment, processing a request.
 * *   Error messages printed to `System.err` when an operation fails (e.g., patient not found for request, no doctors available to process request, invalid menu choice).
 * *   Formatted output when viewing lists/queue contents.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Hospital Management Menu ---
 * 1. Add Patient
 * 2. Add Doctor
 * 3. Request Appointment
 * 4. Process Next Request
 * 5. View Pending Requests
 * 6. View Scheduled Appointments
 * 7. View Patients
 * 8. View Doctors
 * 9. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * 
 * Patient 'Alice' added successfully.
 * 
 * --- Hospital Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter patient name: Alice
 * Enter requested specialization (e.g., Cardiology): General
 * 
 * Appointment request for Alice (General) added to queue.
 * 
 * --- Hospital Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * Processing next request...
 * Request for Alice (General) processed. Scheduled with Doctor [Doctor Name].
 * 
 * --- Hospital Management Menu ---
 * ...
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Successful integration and usage of ALL specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented principles and best practices (encapsulation, naming, validation, comments).
 * *   Proper error handling and input validation.
 * *   Code clarity and structure.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * The provided solution implements a simplified Hospital Appointment Management System, fulfilling all the requirements of the exam question.
 * 
 * **Core Structure:**
 * 
 * The system is built around the `HospitalScheduler` class, which manages the main data collections and application logic. Separate classes (`Patient`, `Doctor`, `AppointmentRequest`, `Appointment`) represent the entities within the system, promoting object-oriented design and encapsulation.
 * 
 * **Required Component Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `appointmentRequests` field in `HospitalScheduler` is declared as `Queue<AppointmentRequest>` and initialized with a `LinkedList` (`new LinkedList<>()`), which is a common implementation of the `Queue` interface. Requests are added using `offer()` in `requestAppointment()` and removed using `poll()` in `processNextRequest()`. `viewPendingRequests()` iterates over the queue to display its contents without removing elements.
 * 2.  **`java.util.ArrayList`**: `ArrayList` is used to store collections of `Patient` objects (`patients`), `Doctor` objects (`doctors`), and `Appointment` objects (`scheduledAppointments`). These are initialized using `new ArrayList<>()`.
 * 3.  **`java.util.List` interface**: The fields `patients`, `doctors`, and `scheduledAppointments` are declared using the `List` interface type (`List<Patient>`, `List<Doctor>`, `List<Appointment>`). This demonstrates programming to an interface, a good practice that allows flexibility in choosing the underlying implementation (like `ArrayList`) without affecting code that uses the interface.
 * 4.  **`java.util.Scanner`**: A `Scanner` instance (`scanner`) is created in the `HospitalScheduler` constructor to read user input from `System.in` within the `run()` method and other input-taking methods (`addPatient`, `addDoctor`, `requestAppointment`).
 * 5.  **`switch` statement**: The main application loop in the `run()` method uses a `switch` statement to handle the user's menu choice, directing execution to the corresponding private methods (`addPatient`, `addDoctor`, etc.).
 * 6.  **`System.err`**: `System.err.println()` is used specifically for printing error messages. This includes messages for invalid menu choices, non-integer input (`InputMismatchException`), validation errors (`IllegalArgumentException`), patients/doctors not found, and situations where a request cannot be processed (e.g., no doctors available).
 * 7.  **`System.out`**: `System.out.println()` is used for all standard output: displaying the menu, prompts for input, success messages after operations, and listing the contents of patients, doctors, pending requests, and scheduled appointments.
 * 8.  **`try-catch` blocks**: Exception handling is implemented at multiple levels:
 *     *   Specific `try-catch (InputMismatchException e)` is used within the `run()` loop to catch errors when the user enters non-integer input for the menu choice.
 *     *   `try-catch (IllegalArgumentException e)` blocks are used around operations that might throw validation errors (e.g., creating `Patient`, `Doctor`, `AppointmentRequest`, `Appointment` objects with invalid data, or checking for duplicates).
 *     *   A `try-catch (Exception e)` block is wrapped around the main `while` loop inside `run()`. This serves as a class-wide handler for any unexpected runtime exceptions that might occur during the execution of a menu option, preventing the program from crashing abruptly and printing an error message to `System.err`.
 *     *   A `finally` block is used to ensure the `Scanner` is closed when the application exits or encounters a critical error.
 * 
 * **Object-Oriented Design and Best Practices:**
 * 
 * *   **Encapsulation:** The entity classes (`Patient`, `Doctor`, `AppointmentRequest`, `Appointment`) have private fields and public constructors and getter methods. The `HospitalScheduler` class keeps its data collections private and exposes functionality through public methods (`run`) and private helper methods.
 * *   **Meaningful Names:** Classes, variables, and methods have descriptive names reflecting their purpose (e.g., `HospitalScheduler`, `appointmentRequests`, `processNextRequest`, `findPatientByName`).
 * *   **Input Validation:** Basic validation is performed, such as checking for empty names when adding patients/doctors and ensuring a patient exists before creating a request. `IllegalArgumentException` is used to signal invalid data during object creation.
 * *   **Error Handling:** As detailed above, `try-catch` and `System.err` are used effectively to manage errors and provide feedback to the user without crashing the application.
 * *   **Code Structure:** The code is organized into logical classes, and the `HospitalScheduler` class separates the main application loop (`run`) from the specific operation methods (`addPatient`, `processNextRequest`, etc.), improving readability and maintainability. Helper methods (`findPatientByName`, `findAnyDoctor`) encapsulate reusable logic.
 * 
 * The solution successfully integrates all required components into a functional, albeit simplified, system that simulates a real-world scenario while demonstrating key Java programming concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Basic Patient class
class Patient {
    private String name;

    public Patient(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be empty.");
        }
        this.name = name.trim();
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [Name: " + name + "]";
    }
}

// Basic Doctor class
class Doctor {
    private String name;
    private String specialization;

    public Doctor(String name, String specialization) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Doctor name cannot be empty.");
        }
        if (specialization == null || specialization.trim().isEmpty()) {
            throw new IllegalArgumentException("Doctor specialization cannot be empty.");
        }
        this.name = name.trim();
        this.specialization = specialization.trim();
    }

    public String getName() {
        return name;
    }

    public String getSpecialization() {
        return specialization;
    }

    @Override
    public String toString() {
        return "Doctor [Name: " + name + ", Specialization: " + specialization + "]";
    }
}

// Represents a pending appointment request
class AppointmentRequest {
    private Patient patient;
    private String requestedSpecialization;

    public AppointmentRequest(Patient patient, String requestedSpecialization) {
        if (patient == null) {
            throw new IllegalArgumentException("Patient cannot be null for appointment request.");
        }
        if (requestedSpecialization == null || requestedSpecialization.trim().isEmpty()) {
             throw new IllegalArgumentException("Requested specialization cannot be empty.");
        }
        this.patient = patient;
        this.requestedSpecialization = requestedSpecialization.trim();
    }

    public Patient getPatient() {
        return patient;
    }

    public String getRequestedSpecialization() {
        return requestedSpecialization;
    }

    @Override
    public String toString() {
        return "Request [Patient: " + patient.getName() + ", Specialization: " + requestedSpecialization + "]";
    }
}

// Represents a scheduled appointment
class Appointment {
    private Patient patient;
    private Doctor doctor;
    // In a real system, this would include date/time. Simplified for the exam.

    public Appointment(Patient patient, Doctor doctor) {
        if (patient == null || doctor == null) {
             throw new IllegalArgumentException("Patient and Doctor cannot be null for a scheduled appointment.");
        }
        this.patient = patient;
        this.doctor = doctor;
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    @Override
    public String toString() {
        return "Appointment [Patient: " + patient.getName() + ", Doctor: " + doctor.getName() + " (" + doctor.getSpecialization() + ")]";
    }
}

// Main class managing the hospital scheduling logic
public class HospitalScheduler {

    // Use List interface type for collections stored in ArrayLists
    private List<Patient> patients;
    private List<Doctor> doctors;
    // Use Queue for pending appointment requests
    private Queue<AppointmentRequest> appointmentRequests;
    // Use List interface type for scheduled appointments stored in ArrayList
    private List<Appointment> scheduledAppointments;

    private Scanner scanner;

    public HospitalScheduler() {
        // Initialize collections using ArrayList and LinkedList (for Queue)
        this.patients = new ArrayList<>();
        this.doctors = new ArrayList<>();
        this.appointmentRequests = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.scheduledAppointments = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Method to run the main application loop
    public void run() {
        int choice = -1;

        // Class-wide exception handling for the main loop
        try {
            while (choice != 9) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu control
                    switch (choice) {
                        case 1:
                            addPatient();
                            break;
                        case 2:
                            addDoctor();
                            break;
                        case 3:
                            requestAppointment();
                            break;
                        case 4:
                            processNextRequest();
                            break;
                        case 5:
                            viewPendingRequests();
                            break;
                        case 6:
                            viewScheduledAppointments();
                            break;
                        case 7:
                            viewPatients();
                            break;
                        case 8:
                            viewDoctors();
                            break;
                        case 9:
                            System.out.println("Exiting Hospital Management System. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 9.");
                    }
                } catch (InputMismatchException e) {
                    // Specific exception handling for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (IllegalArgumentException e) {
                     // Handle validation errors from object constructors/methods
                    System.err.println("Operation failed: " + e.getMessage());
                } catch (Exception e) {
                    // General catch for unexpected errors within the loop iteration
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     // Optional: e.printStackTrace(); // For debugging
                }
                System.out.println(); // Add a newline for better readability between menu cycles
            }
        } catch (Exception e) {
            // Class-wide catch block for any unhandled exceptions bubbling up
            System.err.println("A critical error occurred: " + e.getMessage());
            // Optional: e.printStackTrace();
        } finally {
             // Ensure scanner is closed even if exceptions occur
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private void printMenu() {
        System.out.println("--- Hospital Management Menu ---");
        System.out.println("1. Add Patient");
        System.out.println("2. Add Doctor");
        System.out.println("3. Request Appointment");
        System.out.println("4. Process Next Request");
        System.out.println("5. View Pending Requests");
        System.out.println("6. View Scheduled Appointments");
        System.out.println("7. View Patients");
        System.out.println("8. View Doctors");
        System.out.println("9. Exit");
    }

    private void addPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        try {
            // Basic validation and object creation
            Patient newPatient = new Patient(name);
            // Check for duplicate names (simple uniqueness check for exam)
            if (findPatientByName(name) != null) {
                 System.err.println("Patient with name '" + name + "' already exists.");
                 return;
            }
            patients.add(newPatient); // Add to ArrayList
            System.out.println("Patient '" + name + "' added successfully.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error adding patient: " + e.getMessage());
        }
    }

    private void addDoctor() {
        System.out.print("Enter doctor name: ");
        String name = scanner.nextLine();
        System.out.print("Enter doctor specialization: ");
        String specialization = scanner.nextLine();
        try {
             // Basic validation and object creation
            Doctor newDoctor = new Doctor(name, specialization);
             // Check for duplicate names (simple uniqueness check for exam)
            if (findDoctorByName(name) != null) {
                 System.err.println("Doctor with name '" + name + "' already exists.");
                 return;
            }
            doctors.add(newDoctor); // Add to ArrayList
            System.out.println("Doctor '" + name + "' (" + specialization + ") added successfully.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error adding doctor: " + e.getMessage());
        }
    }

    private void requestAppointment() {
        System.out.print("Enter patient name requesting appointment: ");
        String patientName = scanner.nextLine();
        Patient patient = findPatientByName(patientName); // Find patient in the list

        if (patient == null) {
            // Use System.err for errors like patient not found
            System.err.println("Patient '" + patientName + "' not found. Please add the patient first.");
            return;
        }

        System.out.print("Enter requested specialization (e.g., Cardiology): ");
        String specialization = scanner.nextLine();

        try {
            // Create AppointmentRequest and add to the Queue
            AppointmentRequest request = new AppointmentRequest(patient, specialization);
            appointmentRequests.offer(request); // offer() is preferred over add() for capacity-constrained queues, though not strictly necessary here. Adds to the tail.
            System.out.println("Appointment request for " + patient.getName() + " (" + specialization + ") added to queue.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating request: " + e.getMessage());
        }
    }

    private void processNextRequest() {
        // Poll the next request from the Queue
        AppointmentRequest nextRequest = appointmentRequests.poll(); // Retrieves and removes the head of the queue

        if (nextRequest == null) {
            System.out.println("No pending appointment requests in the queue.");
            return;
        }

        System.out.println("Processing request for: " + nextRequest.getPatient().getName() + " (Specialization: " + nextRequest.getRequestedSpecialization() + ")");

        // Simple doctor assignment logic: Find any doctor.
        // In a real system, this would match specialization, availability, etc.
        Doctor assignedDoctor = findAnyDoctor(); // Find a doctor from the list

        if (assignedDoctor == null) {
            // Use System.err if no doctor is available
            System.err.println("No doctors available to process the request. Request remains unprocessed.");
            // Optionally re-queue, or handle differently. For this exam, we just report failure.
            // appointmentRequests.offer(nextRequest); // Could re-add if needed
            return;
        }

        try {
            // Create a scheduled Appointment and add to the List
            Appointment newAppointment = new Appointment(nextRequest.getPatient(), assignedDoctor);
            scheduledAppointments.add(newAppointment); // Add to ArrayList
            System.out.println("Request processed successfully. Scheduled with " + assignedDoctor.getName() + " (" + assignedDoctor.getSpecialization() + ").");
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating scheduled appointment: " + e.getMessage());
        }
    }

    private void viewPendingRequests() {
        System.out.println("--- Pending Appointment Requests ---");
        if (appointmentRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the Queue without removing elements (using enhanced for loop or iterator)
            // The Queue interface allows iteration, though its primary methods are offer, poll, peek, etc.
            int index = 1;
            for (AppointmentRequest request : appointmentRequests) {
                System.out.println(index++ + ". " + request);
            }
        }
        System.out.println("------------------------------------");
    }

    private void viewScheduledAppointments() {
        System.out.println("--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            // Iterate through the List
            for (int i = 0; i < scheduledAppointments.size(); i++) {
                System.out.println((i + 1) + ". " + scheduledAppointments.get(i));
            }
        }
        System.out.println("------------------------------");
    }

     private void viewPatients() {
        System.out.println("--- Registered Patients ---");
        if (patients.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            // Iterate through the List
            for (int i = 0; i < patients.size(); i++) {
                System.out.println((i + 1) + ". " + patients.get(i));
            }
        }
        System.out.println("---------------------------");
    }

    private void viewDoctors() {
        System.out.println("--- Registered Doctors ---");
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered yet.");
        } else {
            // Iterate through the List
            for (int i = 0; i < doctors.size(); i++) {
                System.out.println((i + 1) + ". " + doctors.get(i));
            }
        }
        System.out.println("--------------------------");
    }


    // Helper method to find a patient by name in the list
    private Patient findPatientByName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return null; // Cannot search for empty name
        }
        String searchName = name.trim();
        for (Patient patient : patients) { // Iterate through the ArrayList
            if (patient.getName().equalsIgnoreCase(searchName)) {
                return patient;
            }
        }
        return null; // Not found
    }

     // Helper method to find a doctor by name in the list
    private Doctor findDoctorByName(String name) {
        if (name == null || name.trim().isEmpty()) {
            return null; // Cannot search for empty name
        }
        String searchName = name.trim();
        for (Doctor doctor : doctors) { // Iterate through the ArrayList
            if (doctor.getName().equalsIgnoreCase(searchName)) {
                return doctor;
            }
        }
        return null; // Not found
    }

    // Helper method to find any doctor available
    private Doctor findAnyDoctor() {
        // For simplicity, just return the first doctor found, or null if list is empty.
        // A real system would have complex logic (availability, specialization matching).
        if (doctors.isEmpty()) {
            return null;
        }
        return doctors.get(0); // Get from ArrayList
    }

    public static void main(String[] args) {
        HospitalScheduler app = new HospitalScheduler();
        app.run();
    }
}
