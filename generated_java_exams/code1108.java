/*
 * Exam Question #1108
 * Generated on: 2025-05-12 17:25:55
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processor
 * 
 * **Task:** Develop a command-line application named `TaskProcessor` that simulates a simple task management system. The application should allow users to add tasks to a pending list, complete the next task in a First-In, First-Out (FIFO) manner, and view both pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Class Structure:** Create a public class named `TaskProcessor`.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<String>` to store tasks that are pending completion. Tasks should be added to the end and removed from the beginning.
 *     *   Use a `java.util.ArrayList<String>`, declared using the `java.util.List<String>` interface type, to store tasks that have been completed.
 * 3.  **User Input:** Use `java.util.Scanner` to read user commands and task descriptions from standard input (`System.in`).
 * 4.  **Menu and Control Flow:**
 *     *   Implement a loop that continuously displays a menu of options to the user until they choose to exit.
 *     *   The menu options should be:
 *         *   1. Add New Task: Prompts the user for a task description and adds it to the pending tasks queue.
 *         *   2. Complete Next Task: Removes the task at the front of the pending queue and adds it to the completed tasks list. If the pending queue is empty, display an appropriate error message.
 *         *   3. View Pending Tasks: Displays all tasks currently in the pending queue in order.
 *         *   4. View Completed Tasks: Displays all tasks in the completed tasks list.
 *         *   5. Exit: Terminates the application.
 *     *   Use a `switch` statement to process the user's menu choice.
 * 5.  **Output:**
 *     *   Display the menu, task lists, and success messages using `System.out`.
 *     *   Display all error messages (e.g., invalid menu choice, attempting to complete task when none are pending, invalid input) using `System.err`.
 * 6.  **Exception Handling:** Implement class-wide exception handling using a `try-catch` block around the main application loop to catch and report any unexpected runtime errors gracefully using `System.err`. Ensure the scanner resource is closed in a `finally` block or equivalent mechanism upon exit or error.
 * 7.  **Best Practices:**
 *     *   Use private fields for the data structures and scanner, and public/private methods as appropriate (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include brief comments where necessary to explain non-obvious logic.
 *     *   Implement basic input validation (e.g., handle non-numeric menu input, check for empty task description).
 *     *   Ensure the application handles cases where pending or completed lists are empty when viewed or processed.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, presenting a menu, accepting numeric input for choices, and string input for task descriptions. Normal output should appear on standard output, and error messages on standard error. The application should terminate cleanly when the 'Exit' option is chosen or if a critical error occurs.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Go to the bank
 * Task added: "Go to the bank"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Pick up dry cleaning
 * Task added: "Pick up dry cleaning"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Go to the bank
 * 2. Pick up dry cleaning
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: "Go to the bank"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Pick up dry cleaning
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Go to the bank
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Completed task: "Pick up dry cleaning"
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * System.err: No pending tasks to complete.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Go to the bank
 * 2. Pick up dry cleaning
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 9
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: exit
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processor...
 * Task Processor shut down.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (including the use of specified Java components and best practices), code structure, and error handling.
 *
 * EXPLANATION:
 * This solution implements the `TaskProcessor` class as required, demonstrating the use of various core Java concepts and collections.
 * 
 * 1.  **Class Structure and Encapsulation:** The code defines a `TaskProcessor` class with private fields (`pendingTasks`, `completedTasks`, `scanner`, `running`) to encapsulate the application's state. Public and private methods are used appropriately to control access and organize logic.
 * 2.  **Data Structures:**
 *     *   `pendingTasks` is declared as a `Queue<String>` and initialized with a `LinkedList`. This correctly uses a Queue implementation to manage tasks in a FIFO order, suitable for processing tasks sequentially as they are added. The `add()` method is used to enqueue tasks, and `poll()` is used to dequeue and remove the next task.
 *     *   `completedTasks` is declared as a `List<String>` and initialized with an `ArrayList`. This demonstrates the use of the `List` interface type while using a common concrete implementation (`ArrayList`) to store completed tasks, which can be easily iterated over.
 * 3.  **User Input:** A `Scanner` object is used to read user input from `System.in` for both menu choices and task descriptions. The `nextLine()` method is used consistently to avoid common pitfalls with mixed `nextInt()` and `nextLine()` calls.
 * 4.  **Menu and Control Flow:**
 *     *   The `run()` method contains a `while(running)` loop that continues until the `running` flag is set to `false` (when the user chooses option 5).
 *     *   Inside the loop, `displayMenu()` shows the options, `getUserChoice()` reads and validates the input, and `processChoice()` dispatches the action.
 *     *   A `switch` statement in `processChoice()` elegantly handles the different integer choices provided by the user, calling the corresponding private methods.
 * 5.  **Output:**
 *     *   `System.out.println()` is used for displaying the menu, confirmation messages, and task lists, fulfilling the requirement for normal output.
 *     *   `System.err.println()` is used for displaying error messages, such as invalid input, attempting to complete a task when the queue is empty, or reporting exceptions, meeting the requirement for error output.
 * 6.  **Exception Handling:**
 *     *   A `try-catch` block wraps the main `while` loop in the `run()` method. This provides class-wide exception handling.
 *     *   It specifically catches `NoSuchElementException`, which can occur if the input stream is unexpectedly closed, and a general `Exception` to catch any other unforeseen runtime errors.
 *     *   Error messages and stack traces (`e.printStackTrace(System.err)`) are directed to `System.err`.
 *     *   A `finally` block ensures that the `scanner` resource is closed regardless of whether the loop completes normally or an exception occurs, preventing resource leaks.
 * 7.  **Best Practices:**
 *     *   Private fields and public/private methods ensure proper encapsulation.
 *     *   Method names like `addTask`, `completeNextTask`, `viewPendingTasks`, `getUserChoice`, and variable names like `pendingTasks`, `completedTasks`, `choice`, `taskDescription` are descriptive.
 *     *   Comments explain the purpose of methods and the use of collections.
 *     *   Input validation is included in `getUserChoice()` (handling non-numeric input with `NumberFormatException`) and `addTask()` (checking for empty task descriptions).
 *     *   The `completeNextTask()`, `viewPendingTasks()`, and `viewCompletedTasks()` methods explicitly check if the collections are empty before attempting operations or displaying lists, preventing errors and providing user-friendly messages.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating a solid understanding of collections, control flow, input/output, error handling, and object-oriented programming principles.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Specific exception for Scanner issues

/**
 * A simple command-line Task Processor application.
 * Manages pending tasks in a Queue and completed tasks in a List.
 */
public class TaskProcessor {

    // Use Queue for pending tasks (FIFO)
    private Queue<String> pendingTasks;
    // Use List (ArrayList) for completed tasks
    private List<String> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;
    // Flag to control the main application loop
    private boolean running;

    /**
     * Constructs a new TaskProcessor, initializing data structures and scanner.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts the main task processing loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide exception handling block wrapping the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();
                processChoice(choice);
            }
        } catch (NoSuchElementException e) {
            // Handle critical error if input stream is closed unexpectedly
            System.err.println("Error: Input stream closed unexpectedly. System shutting down.");
            e.printStackTrace(System.err); // Print stack trace to error stream
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner closed."); // Optional: for debugging resource closure
            }
            System.out.println("Task Processor shut down.");
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-numeric input errors.
     * @return The valid integer choice entered by the user.
     * @throws NoSuchElementException if the input stream is exhausted.
     */
    private int getUserChoice() {
        while (true) { // Loop until valid input is received
            try {
                // Read the entire line to consume the newline character
                String inputLine = scanner.nextLine();
                // Attempt to parse the input as an integer
                return Integer.parseInt(inputLine);
            } catch (NumberFormatException e) {
                // Handle cases where input is not a valid integer
                System.err.println("Invalid input. Please enter a number.");
                // Loop continues to prompt for valid input
            } catch (NoSuchElementException e) {
                 // If the input stream is closed, re-throw to be caught by the main try-catch
                 throw e;
            }
        }
    }

    /**
     * Processes the user's valid menu choice using a switch statement.
     * @param choice The integer choice entered by the user.
     */
    private void processChoice(int choice) {
        switch (choice) {
            case 1:
                addTask();
                break;
            case 2:
                completeNextTask();
                break;
            case 3:
                viewPendingTasks();
                break;
            case 4:
                viewCompletedTasks();
                break;
            case 5:
                // Set running flag to false to exit the main loop
                running = false;
                System.out.println("Exiting Task Processor...");
                break;
            default:
                // Handle invalid integer choices
                System.err.println("Invalid choice. Please enter a number between 1 and 5.");
        }
    }

    /**
     * Prompts the user for a task description and adds it to the pending queue.
     * Includes basic validation for the task description.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Read the entire line for the task description
        String taskDescription = scanner.nextLine();

        // Validate task description (cannot be null or empty/whitespace)
        if (taskDescription == null || taskDescription.trim().isEmpty()) {
             System.err.println("Task description cannot be empty.");
             return; // Exit method if validation fails
        }

        // Add the trimmed task description to the pending queue
        pendingTasks.add(taskDescription.trim());
        System.out.println("Task added: \"" + taskDescription.trim() + "\"");
    }

    /**
     * Completes the next task from the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void completeNextTask() {
        // Check if the pending queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to complete.");
        } else {
            // Remove the head of the queue (FIFO)
            String completedTask = pendingTasks.poll();
            // Add the completed task to the list
            completedTasks.add(completedTask);
            System.out.println("Completed task: \"" + completedTask + "\"");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Does not remove tasks from the queue.
     * Handles the case where the pending queue is empty.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (String task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     * Handles the case where the completed list is empty.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            int index = 1;
            for (String task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * The main method to start the Task Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run(); // Start the application loop
    }
}
