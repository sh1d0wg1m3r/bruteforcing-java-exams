/*
 * Exam Question #964
 * Generated on: 2025-05-12 17:05:55
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple but robust Task Management System. This system should allow users to add new tasks, complete the next pending task, and view lists of both pending and completed tasks.
 * 
 * The system should prioritize tasks using a queue-like structure for pending items, processing them in the order they were added. Once a task is completed, it should be moved to a separate list of completed tasks.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with appropriate fields (e.g., task ID, description, status) and methods (e.g., to mark as completed, getters).
 * 2.  **System Core:** Create a `TaskManagementSystem` class that manages the collections of tasks.
 *     *   It must use a `Queue<Task>` to store pending tasks.
 *     *   It must use a `List<Task>` (specifically implemented as an `ArrayList<Task>`) to store completed tasks.
 * 3.  **Functionality:** Implement the following operations via a command-line menu:
 *     *   **Add New Task:** Prompt the user for a task description and add it to the pending tasks queue. Assign a unique, incrementing ID automatically.
 *     *   **Complete Next Task:** Remove the task at the front of the pending tasks queue, mark its status as "Completed", and add it to the completed tasks list. If no tasks are pending, report an error.
 *     *   **List Pending Tasks:** Display all tasks currently in the pending tasks queue.
 *     *   **List Completed Tasks:** Display all tasks currently in the completed tasks list.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interaction:** Use `java.util.Scanner` to read user input for menu choices and task descriptions.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to complete a task when none are pending).
 * 7.  **Error Handling:** Implement comprehensive exception handling using `try-catch` blocks.
 *     *   Handle potential input errors when reading user choices (e.g., non-integer input).
 *     *   Handle the case where the user tries to complete a task when the pending queue is empty.
 *     *   Include general exception handling for robustness.
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include comments and documentation where necessary.
 *     *   Validate user input where applicable (e.g., ensuring menu choice is valid).
 * 
 * **Expected Output Structure (Example Flow):**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: [ID: 1] Buy groceries [Status: Pending]
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Task added: [ID: 2] Pay bills [Status: Pending]
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 1] Buy groceries [Status: Pending]
 * [ID: 2] Pay bills [Status: Pending]
 * ---------------------
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 2
 * Task completed: [ID: 1] Buy groceries [Status: Completed]
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 2] Pay bills [Status: Pending]
 * ---------------------
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [ID: 1] Buy groceries [Status: Completed]
 * -----------------------
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 2
 * Task completed: [ID: 2] Pay bills [Status: Completed]
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 2
 * System.err: No tasks pending to complete.
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 99
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: exit
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Task Management System ---
 * ... (menu displayed again)
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should provide a complete Java program that compiles and runs, demonstrating all the required features.
 *
 * EXPLANATION:
 * The solution provides a complete Java program implementing the Advanced Task Management System as described.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task: `taskId`, `description`, and `status`. It follows encapsulation principles with private fields and public getter methods. The `markAsCompleted()` method provides a controlled way to change the status. The `toString()` method is overridden for convenient printing of task details.
 * 
 * 2.  **`TaskManagementSystem` Class:**
 *     *   This is the core class managing the task collections.
 *     *   It uses a `Queue<Task>` named `pendingTasks`, implemented specifically using `java.util.LinkedList`. `LinkedList` is a common and efficient implementation for the `Queue` interface, suitable for FIFO operations (adding to the end, removing from the front).
 *     *   It uses a `List<Task>` named `completedTasks`, implemented specifically using `java.util.ArrayList`. `ArrayList` is suitable here because completed tasks are simply stored and listed, not typically removed or processed in a specific order based on their addition time.
 *     *   `nextTaskId` is a simple counter to ensure unique IDs for tasks.
 *     *   **`addTask(String description)`:** Creates a new `Task` object with the next available ID and adds it to the `pendingTasks` queue using the `offer()` method. `offer()` is preferred over `add()` in queues as it is designed to handle capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained, it's good practice).
 *     *   **`completeNextTask()`:** Uses `poll()` to retrieve and remove the element at the head of the `pendingTasks` queue. `poll()` returns `null` if the queue is empty, which is checked to report an error using `System.err` if no tasks are pending. If a task is retrieved, its status is updated using `markAsCompleted()`, and it's added to the `completedTasks` list.
 *     *   **`listPendingTasks()` and `listCompletedTasks()`:** These methods iterate through the respective collections (`pendingTasks` and `completedTasks`) and print each task's details using its `toString()` method. They check if the collections are empty and print a message accordingly.
 *     *   **`displayMenu()`:** A helper method to print the interactive menu to `System.out`.
 *     *   **`run()`:** This method contains the main application loop. It repeatedly displays the menu, reads user input using `Scanner`, and uses a `switch` statement to perform the requested action by calling the appropriate methods.
 * 
 * 3.  **User Input and Control Flow:**
 *     *   `java.util.Scanner` is used to read input from `System.in`. The `try-with-resources` block ensures the `Scanner` is properly closed.
 *     *   A `while` loop keeps the system running until the user chooses to exit.
 *     *   A `switch` statement directs the program flow based on the integer input received for the menu choice.
 * 
 * 4.  **Error Handling (`try-catch` and `System.err`):**
 *     *   A `try-catch(InputMismatchException e)` block is used specifically around `scanner.nextInt()` to catch cases where the user enters non-integer input. An error message is printed to `System.err`, and `scanner.next()` is called to consume the invalid input, preventing an infinite loop.
 *     *   The `completeNextTask()` method explicitly checks if `pendingTasks.poll()` returns `null` and prints an error to `System.err` if it does, handling the "no tasks pending" scenario.
 *     *   A general `catch(Exception e)` block is included within the main loop's `try` block to catch any other unexpected runtime exceptions during the processing of a command. This provides a layer of robustness.
 *     *   A top-level `try-catch` in the `main` method catches any potential exceptions that might escape the `run()` method or occur during system initialization.
 *     *   `System.err` is consistently used for all error reporting as required. `System.out` is used for normal informational messages and output.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Achieved in the `Task` class and the `TaskManagementSystem` class by making fields private.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingTasks`, `completeNextTask`, `listCompletedTasks`).
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** Basic validation is done for the task description (not empty) and menu choice (handled by the `switch` default and `InputMismatchException`).
 *     *   **Clean Code:** The code is structured into logical classes and methods, making it readable and maintainable.
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, menu-driven application, adhering to best practices for robustness and code quality.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Represents a single task
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Pending"; // New tasks are always pending initially
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters/Modifiers ---
    /**
     * Marks the task status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    // --- Overrides ---
    @Override
    public String toString() {
        return "[ID: " + taskId + "] " + description + " [Status: " + status + "]";
    }
}

// Manages the collection of tasks
class TaskManagementSystem {
    // Queue for tasks that are waiting to be done (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes the pending and completed task collections.
     */
    public TaskManagementSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Completes the next task in the pending queue.
     * Removes it from the queue, marks it as completed, and adds it to the completed list.
     * Reports an error if no tasks are pending.
     */
    public void completeNextTask() {
        // Use poll() which returns null if the queue is empty, safer than remove()
        Task taskToComplete = pendingTasks.poll();

        if (taskToComplete != null) {
            taskToComplete.markAsCompleted();
            completedTasks.add(taskToComplete);
            System.out.println("Task completed: " + taskToComplete);
        } else {
            // Report error using System.err as required
            System.err.println("No tasks pending to complete.");
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and operations.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;
            while (running) {
                displayMenu();

                try {
                    int choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            if (description != null && !description.trim().isEmpty()) {
                                addTask(description.trim());
                            } else {
                                System.err.println("Task description cannot be empty.");
                            }
                            break;
                        case 2:
                            completeNextTask();
                            break;
                        case 3:
                            listPendingTasks();
                            break;
                        case 4:
                            listCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Management System.");
                            running = false;
                            break;
                        default:
                            // Report invalid choice using System.err
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input using System.err
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.next();
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optionally print stack trace for debugging
                }
            }
        } catch (Exception e) {
            // Catch potential exceptions during Scanner initialization or closing
            System.err.println("An error occurred while setting up the scanner: " + e.getMessage());
            // e.printStackTrace(System.err);
        }
    }
}

// Main class to start the application
public class Main {
    public static void main(String[] args) {
        // Top-level try-catch for any unhandled exceptions
        try {
            TaskManagementSystem system = new TaskManagementSystem();
            system.run();
        } catch (Exception e) {
            System.err.println("A fatal error occurred during system execution: " + e.getMessage());
            // e.printStackTrace(System.err);
        }
    }
}
