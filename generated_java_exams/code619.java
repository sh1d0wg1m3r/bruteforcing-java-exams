/*
 * Exam Question #619
 * Generated on: 2025-05-12 16:15:45
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Event Session Management
 * 
 * **Scenario:**
 * 
 * You are tasked with building a system to manage attendees for a popular session at a conference. This session has a fixed capacity. Attendees must check in to attend. If the session is full, attendees are added to a waiting list. If an attendee leaves the session, the first person on the waiting list is automatically admitted.
 * 
 * **Task:**
 * 
 * Implement a Java console application that simulates this session management system.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.List` (specifically, a `java.util.ArrayList`) to store attendees currently inside the session.
 *     *   Use a `java.util.Queue` (specifically, a `java.util.LinkedList` which implements `Queue`) to manage the waiting list.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and input from the console (`System.in`).
 *     *   The program should first prompt the user to enter the session capacity before starting operations.
 *     *   After setting capacity, it should present a menu with the following options:
 *         *   1. Check-in Attendee
 *         *   2. Attendee Leave
 *         *   3. View Session Status
 *         *   4. Exit
 * 3.  **Functionality:**
 *     *   **Check-in:** Prompt for Attendee ID (String) and Name (String).
 *         *   If the session has available capacity (`currentAttendees.size() < sessionCapacity`), add the attendee to the `currentAttendees` list and print a success message using `System.out`.
 *         *   If the session is full, add the attendee to the `waitingList` queue and print a message indicating they are on the waiting list and their position in the queue using `System.out`.
 *         *   Implement basic validation to prevent checking in an attendee if their ID is already present in either the current session or the waiting list. Print an error using `System.err` if this occurs.
 *     *   **Leave:** Prompt for Attendee ID.
 *         *   Search for the attendee in the `currentAttendees` list.
 *         *   If found, remove the attendee from the list and print a success message using `System.out`.
 *         *   After an attendee leaves and is removed from the session, check if the `waitingList` is not empty. If it's not empty, remove the first attendee from the `waitingList` (using the appropriate Queue method) and add them to the `currentAttendees` list. Print a message using `System.out` indicating who moved from the waiting list to the session.
 *         *   If the attendee ID is not found in the `currentAttendees` list, print an error message using `System.err`.
 *     *   **View Status:** Print the session capacity, the current number of attendees in the session, and list all attendees currently in the session (ID and Name). Print the number of attendees in the waiting list and list all attendees in the waiting list in their current queue order (ID and Name). Use `System.out` for all status output.
 *     *   **Exit:** Terminate the program gracefully.
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Use a loop to keep the program running and accepting commands until the user chooses to exit.
 * 5.  **Error Handling:**
 *     *   Use `System.err` for all error messages (e.g., invalid menu choice, attendee not found, invalid input data, duplicate check-in).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. A single `try-catch (Exception e)` block wrapping the main command processing loop in your `main` method is sufficient to demonstrate this requirement, catching any unexpected runtime issues. Handle potential `NumberFormatException` during capacity input.
 * 6.  **Best Practices:**
 *     *   Create a separate class `Attendee` with private fields (`id`, `name`) and public getter methods. Override the `equals()` and `hashCode()` methods in `Attendee` based on the `id` field, as this is crucial for correctly searching and removing attendees in collections.
 *     *   Create a `SessionManager` class to encapsulate the session state (`sessionCapacity`, `currentAttendees`, `waitingList`) and the operations (`checkIn`, `leave`, `viewStatus`). The `main` method should reside in this class or a separate main class that uses `SessionManager`.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain the purpose of classes, methods, and complex logic.
 *     *   Perform basic input validation (e.g., check if entered IDs or Names are empty).
 * 
 * **Expected Output Structure:**
 * 
 * The output should follow the structure shown in the example provided in the task description, clearly indicating prompts, normal output, and error output (using `System.err`).
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This Java program implements a simple Event Session Management system using several core Java concepts and data structures as required.
 * 
 * **Overall Structure:**
 * 
 * The solution is divided into two main classes:
 * 1.  `Attendee`: A simple class to represent an attendee with an ID and a name. It includes overridden `equals()` and `hashCode()` methods based on the attendee's unique ID, which is crucial for correctly identifying and managing `Attendee` objects within collections like `ArrayList` and `Queue`. The `toString()` method provides a convenient way to print attendee information.
 * 2.  `SessionManager`: This class encapsulates the state and logic of the session. It holds the session `sessionCapacity`, the `currentAttendees` in a `List`, and the `waitingList` in a `Queue`. It provides public methods (`checkIn`, `leave`, `viewStatus`) to perform operations and contains the `main` method to run the application.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `waitingList` is declared as `Queue<Attendee>` and initialized with a `java.util.LinkedList`. `LinkedList` is a common implementation of the `Queue` interface. The `offer()` method is used to add attendees to the tail of the queue (when the session is full), and the `poll()` method is used to remove and retrieve the attendee at the head of the queue (when a spot becomes available).
 * 2.  **`java.util.ArrayList`:** The `currentAttendees` list is initialized as an `ArrayList<Attendee>`. `ArrayList` is used because we need to efficiently add and remove elements (especially removal by object reference, which relies on the `equals()` method) and iterate through the list to display current attendees or find a specific attendee by ID.
 * 3.  **`java.util.List` interface:** The `currentAttendees` field is declared using the `List` interface (`List<Attendee> currentAttendees = new ArrayList<>();`). This demonstrates programming to the interface, which is a good practice for flexibility. The `findAttendeeById` helper method also accepts a `List<Attendee>`, making it reusable for searching in any list-like collection of Attendees (although currently used only for `currentAttendees` and a temporary list from `waitingList`).
 * 4.  **`java.util.Scanner`:** A `Scanner` object is created in the `main` method to read user input from the console (`System.in`), including the session capacity and menu choices/attendee details within the main loop.
 * 5.  **`switch` statement:** A `switch` statement in the `main` method is used to process the user's choice from the menu, directing the program flow to the appropriate `SessionManager` method (`checkIn`, `leave`, `viewStatus`) or the exit logic.
 * 6.  **`System.err`:** `System.err.println()` is used specifically for printing error messages, such as invalid input during capacity setup, invalid menu choices, errors during check-in (e.g., duplicate ID, invalid data), and errors during the leave operation (e.g., attendee not found in the session). This distinguishes error output from standard program output.
 * 7.  **`System.out`:** `System.out.println()` is used for all normal program output, including prompts, success messages (check-in successful, attendee left, attendee moved from waiting list), and the session status display.
 * 8.  **Class-wide Exception Handling (`try-catch`):** A `try-catch (Exception e)` block is wrapped around the main `while(running)` loop in the `main` method. This provides a form of "class-wide" handling by catching any unexpected runtime exceptions that might occur during the processing of user commands within that loop. More specific `try-catch` blocks are used for predictable issues like `NumberFormatException` when reading the initial capacity. The `SessionManager` constructor throws an `IllegalArgumentException` for invalid capacity, which is caught in the `main` method's setup phase.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Both `Attendee` and `SessionManager` classes use private fields (`id`, `name`, `currentAttendees`, `waitingList`, `sessionCapacity`) and provide public methods (`getters`, `checkIn`, `leave`, `viewStatus`) to access or modify their state, adhering to encapsulation principles.
 * *   **Meaningful Names:** Variables and methods are named clearly (e.g., `sessionCapacity`, `currentAttendees`, `waitingList`, `checkIn`, `findAttendeeById`) to indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are used for classes and methods, explaining their roles and parameters. Inline comments clarify specific logic points (e.g., why `equals`/`hashCode` are needed, how `offer`/`poll` work).
 * *   **Input Validation:** Basic validation is performed for user input, such as checking for empty strings for attendee ID/Name and ensuring the session capacity is a positive integer. Error messages are printed using `System.err` when validation fails.
 * *   **Error Handling:** Errors are handled through a combination of input validation, checking conditions (e.g., if session is full, if attendee is found), using `System.err` for user-friendly error messages, and using `try-catch` for exceptions.
 * *   **Clean Code Structure:** The code is organized logically into separate classes with distinct responsibilities. The `main` method focuses on user interaction and delegates the core session logic to the `SessionManager` instance. The `findAttendeeById` is a good example of extracting reusable helper logic. Overriding `equals` and `hashCode` in `Attendee` is crucial for correct collection behavior and demonstrates attention to detail.
 * 
 * This solution effectively demonstrates the required Java concepts and best practices within a practical, albeit simplified, real-world scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Useful for safe iteration/removal, though not strictly required with equals/hashCode

// Class representing an Attendee
class Attendee {
    private String id;
    private String name;

    /**
     * Constructs an Attendee object.
     * @param id The unique identifier for the attendee.
     * @param name The name of the attendee.
     */
    public Attendee(String id, String name) {
        this.id = id;
        this.name = name;
    }

    // Public getter for the attendee ID
    public String getId() {
        return id;
    }

    // Public getter for the attendee name
    public String getName() {
        return name;
    }

    /**
     * Overrides equals to compare attendees based on their unique ID.
     * This is essential for methods like List.remove() or List.contains().
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id.equals(attendee.id);
    }

    /**
     * Overrides hashCode to be consistent with equals, based on the attendee ID.
     */
    @Override
    public int hashCode() {
        return id.hashCode();
    }

    /**
     * Provides a string representation of the Attendee.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

// Class managing the session logic
public class SessionManager {
    private List<Attendee> currentAttendees; // List to hold attendees currently in the session
    private Queue<Attendee> waitingList;   // Queue to hold attendees waiting for a spot
    private int sessionCapacity;          // Maximum number of attendees allowed

    /**
     * Constructs a SessionManager with a specified capacity.
     * @param capacity The maximum number of attendees allowed in the session.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public SessionManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Session capacity must be positive.");
        }
        this.sessionCapacity = capacity;
        this.currentAttendees = new ArrayList<>(); // ArrayList chosen for efficient access/iteration
        this.waitingList = new LinkedList<>(); // LinkedList chosen as it implements Queue efficiently
    }

    /**
     * Attempts to check in an attendee into the session or adds them to the waiting list.
     * @param attendee The attendee to check in.
     */
    public void checkIn(Attendee attendee) {
        // Input validation: Check if attendee object or its data is null/empty
        if (attendee == null || attendee.getId() == null || attendee.getId().trim().isEmpty() || attendee.getName() == null || attendee.getName().trim().isEmpty()) {
             System.err.println("Error: Invalid attendee data provided for check-in (ID and Name cannot be empty).");
             return;
        }

        // Prevent duplicate check-ins
        if (findAttendeeById(attendee.getId(), currentAttendees) != null) {
            System.err.println("Error: Attendee with ID " + attendee.getId() + " is already in the session.");
            return;
        }
        // To search in Queue, we can create a temporary list or iterate. Creating a list is simpler here.
         if (findAttendeeById(attendee.getId(), new ArrayList<>(waitingList)) != null) {
             System.err.println("Error: Attendee with ID " + attendee.getId() + " is already in the waiting list.");
             return;
         }


        if (currentAttendees.size() < sessionCapacity) {
            currentAttendees.add(attendee); // Add to the ArrayList
            System.out.println("Attendee " + attendee.getName() + " (" + attendee.getId() + ") checked into the session.");
        } else {
            waitingList.offer(attendee); // Add to the tail of the Queue
            System.out.println("Session is full. Attendee " + attendee.getName() + " (" + attendee.getId() + ") added to the waiting list (Position: " + waitingList.size() + ").");
        }
    }

    /**
     * Handles an attendee leaving the session and potentially moves someone from the waiting list.
     * @param attendeeId The ID of the attendee leaving.
     */
    public void leave(String attendeeId) {
         // Input validation
        if (attendeeId == null || attendeeId.trim().isEmpty()) {
            System.err.println("Error: Attendee ID cannot be empty for leave operation.");
            return;
        }

        // Find the attendee in the current session list
        Attendee attendeeToRemove = findAttendeeById(attendeeId, currentAttendees);

        if (attendeeToRemove != null) {
            // Remove from the ArrayList. This works correctly because Attendee.equals() is overridden.
            boolean removed = currentAttendees.remove(attendeeToRemove);
            if(removed) {
                System.out.println("Attendee " + attendeeToRemove.getName() + " (" + attendeeId + ") has left the session.");

                // Check waiting list for the next person
                if (!waitingList.isEmpty()) {
                    Attendee nextAttendee = waitingList.poll(); // Get and remove the head of the Queue
                    currentAttendees.add(nextAttendee); // Add to the ArrayList
                    System.out.println("Attendee " + nextAttendee.getName() + " (" + nextAttendee.getId() + ") has moved from the waiting list into the session.");
                }
            } else {
                 // Should not happen if findAttendeeById worked, but included for robustness
                 System.err.println("Internal Error: Could not remove attendee " + attendeeId + " from session list.");
            }

        } else {
            System.err.println("Error: Attendee with ID " + attendeeId + " not found in the current session.");
            // Optionally, check waiting list and inform user if they are there
        }
    }

    /**
     * Displays the current status of the session and waiting list.
     */
    public void viewStatus() {
        System.out.println("\n--- Session Status ---");
        System.out.println("Capacity: " + sessionCapacity);
        System.out.println("Current Attendees: " + currentAttendees.size() + "/" + sessionCapacity);

        System.out.println("Attendees in Session:");
        if (currentAttendees.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate through the List
            for (Attendee attendee : currentAttendees) {
                System.out.println("  - " + attendee);
            }
        }

        System.out.println("Waiting List (" + waitingList.size() + " attendees):");
        if (waitingList.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate through the Queue without removing elements to show order
            int position = 1;
            for (Attendee attendee : waitingList) {
                System.out.println("  " + position++ + ". " + attendee);
            }
        }
        System.out.println("----------------------\n");
    }

    /**
     * Helper method to find an attendee by ID in a given list.
     * @param id The ID to search for.
     * @param list The list of attendees to search within.
     * @return The Attendee object if found, otherwise null.
     */
    private Attendee findAttendeeById(String id, List<Attendee> list) {
        if (id == null || id.trim().isEmpty() || list == null) {
            return null;
        }
        // Iterate through the list to find the attendee by ID
        for (Attendee attendee : list) {
            if (attendee.getId().equals(id)) {
                return attendee;
            }
        }
        return null; // Attendee not found
    }


    /**
     * Main method to run the session management application.
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SessionManager manager = null;
        int capacity = 0;

        // --- Setup Phase: Get Session Capacity ---
        boolean capacitySet = false;
        while(!capacitySet) {
            System.out.print("Enter session capacity: ");
            try {
                // Attempt to read and parse capacity
                capacity = Integer.parseInt(scanner.nextLine());
                manager = new SessionManager(capacity); // Initialize manager with capacity
                capacitySet = true; // Capacity successfully set
                System.out.println("Session manager initialized with capacity " + capacity + ".");
            } catch (NumberFormatException e) {
                // Handle non-integer input for capacity
                System.err.println("Invalid input. Please enter a valid integer for capacity.");
            } catch (IllegalArgumentException e) {
                 // Handle invalid capacity (<= 0) caught by SessionManager constructor
                 System.err.println("Error: " + e.getMessage());
            }
        }


        // --- Operation Phase: Process User Commands ---
        boolean running = true;
        while (running) {
            System.out.println("\nChoose an action:");
            System.out.println("1. Check-in Attendee");
            System.out.println("2. Attendee Leave");
            System.out.println("3. View Session Status");
            System.out.println("4. Exit");
            System.out.print("Enter choice: ");

            // Class-wide exception handling for the main command processing loop
            try {
                String choice = scanner.nextLine(); // Read user's menu choice

                // Use switch statement for command dispatch
                switch (choice) {
                    case "1":
                        System.out.print("Enter Attendee ID: ");
                        String id = scanner.nextLine();
                        System.out.print("Enter Attendee Name: ");
                        String name = scanner.nextLine();
                        manager.checkIn(new Attendee(id, name)); // Call check-in method
                        break;
                    case "2":
                        System.out.print("Enter Attendee ID to leave: ");
                        String leaveId = scanner.nextLine();
                        manager.leave(leaveId); // Call leave method
                        break;
                    case "3":
                        manager.viewStatus(); // Call view status method
                        break;
                    case "4":
                        System.out.println("Exiting Session Manager. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during command processing
                System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }

        scanner.close(); // Close the scanner resource
    }
}
