/*
 * Exam Question #733
 * Generated on: 2025-05-12 16:32:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple, console-based task management system for a small team. The system needs to handle incoming tasks, assign them to available workers, and provide status updates. It should be robust enough to handle various user inputs and potential errors.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this task management system. Your solution must demonstrate a strong understanding of core Java data structures and control flow mechanisms. Specifically, your implementation **must** use the following Java components:
 * 
 * 1.  `java.util.Queue`: To store tasks that are waiting to be assigned (pending tasks).
 * 2.  `java.util.ArrayList`: To manage a dynamic list of available worker IDs.
 * 3.  `java.util.List`: Declare the variable holding the worker IDs using the `List` interface type.
 * 4.  `java.util.Scanner`: To read user commands and input data from the console.
 * 5.  `switch` statement: To process different user commands.
 * 6.  `System.err`: To display error messages (e.g., invalid input, queue empty, no workers).
 * 7.  `System.out`: To display normal output (menus, task lists, success messages).
 * 8.  Class-wide exception handling using `try-catch` blocks: Implement a mechanism to catch potential exceptions during the main execution loop or critical operations and provide informative error messages.
 * 
 * **System Functionality:**
 * 
 * The system should support the following operations via a command-line interface:
 * 
 * *   `add task <description>`: Adds a new task with the given description to the queue of pending tasks. Assigns a unique integer ID starting from 1.
 * *   `list pending`: Displays all tasks currently in the pending queue.
 * *   `add worker <id>`: Adds a worker with the specified integer ID to the list of available workers. Worker IDs must be positive integers.
 * *   `list workers`: Displays all currently available worker IDs.
 * *   `assign`: Takes the next task from the pending queue and assigns it to the first available worker from the list. If successful, display the task ID, description, and assigned worker ID. Remove the task from the pending queue. If the queue is empty or no workers are available, display an appropriate error using `System.err`.
 * *   `list all`: Displays all tasks that have been added to the system (both pending and assigned). For assigned tasks, show the assigned worker ID.
 * *   `exit`: Terminates the program.
 * 
 * **Data Structures:**
 * 
 * *   You should have a class representing a `Task` with fields for ID, description, status (e.g., PENDING, ASSIGNED), and assigned worker ID (if assigned).
 * *   The main system class should manage the `Queue` of pending tasks and the `List` of available worker IDs. It should also maintain a separate list or collection of *all* tasks ever created to support the `list all` command.
 * 
 * **Input Validation and Error Handling:**
 * 
 * *   Validate user commands and input arguments.
 * *   If a command is invalid or arguments are missing/incorrect, display an error message using `System.err`.
 * *   Handle cases where `assign` is called but the pending queue is empty or the worker list is empty.
 * *   Use `try-catch` blocks to handle potential runtime errors, such as non-integer input where an integer is expected.
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Apply proper encapsulation (private fields, public methods).
 * *   Include comments where necessary to explain complex logic.
 * *   Structure your code into appropriate classes.
 * 
 * **Expected Output:**
 * 
 * *   A clear menu or prompt for user input.
 * *   Formatted output for listing tasks and workers.
 * *   Informative success messages.
 * *   Clear error messages using `System.err` when issues occur.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Task Management System
 * Enter command (add task <desc>, list pending, add worker <id>, list workers, assign, list all, exit):
 * > add task Develop feature X
 * Task 1 added: Develop feature X
 * > add task Write documentation
 * Task 2 added: Write documentation
 * > list pending
 * Pending Tasks:
 * ID: 1, Description: Develop feature X
 * ID: 2, Description: Write documentation
 * > add worker 101
 * Worker 101 added.
 * > add worker 102
 * Worker 102 added.
 * > list workers
 * Available Workers: [101, 102]
 * > assign
 * Task 1 'Develop feature X' assigned to worker 101.
 * > list pending
 * Pending Tasks:
 * ID: 2, Description: Write documentation
 * > list all
 * All Tasks:
 * ID: 1, Description: Develop feature X, Status: ASSIGNED, Worker: 101
 * ID: 2, Description: Write documentation, Status: PENDING
 * > assign
 * Task 2 'Write documentation' assigned to worker 102.
 * > list all
 * All Tasks:
 * ID: 1, Description: Develop feature X, Status: ASSIGNED, Worker: 101
 * ID: 2, Description: Write documentation, Status: ASSIGNED, Worker: 102
 * > assign
 * System.err: Cannot assign task: Pending queue is empty.
 * > list workers
 * Available Workers: [101, 102]
 * > exit
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts.
 * 
 * **Core Structure:**
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states of a task (`PENDING`, `ASSIGNED`), improving code readability and maintainability compared to using raw strings or integers.
 * 2.  **`Task` Class:** Represents a single task with encapsulated data (`id`, `description`, `status`, `assignedWorkerId`). It includes a constructor, getters, a method to update status upon assignment (`assignTo`), and an overridden `toString()` method for easy printing.
 * 3.  **`TaskManager` Class:** This is the central class managing the system's state and operations.
 *     *   It holds the core data structures:
 *         *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. Tasks are added to the queue when created and removed when assigned.
 *         *   `availableWorkers`: A `List<Integer>` implemented using `ArrayList`. This list stores the IDs of workers available to take tasks. Using the `List` interface type for the variable adheres to the requirement and promotes good practice (programming to interfaces).
 *         *   `allTasks`: An `ArrayList<Task>` to keep a record of every task created, regardless of its current status or whether it's still in the pending queue. This is needed for the `list all` command.
 *     *   It contains methods for each system operation (`addTask`, `listPendingTasks`, `addWorker`, `listWorkers`, `assignTask`, `listAllTasks`).
 *     *   It manages the `nextTaskId` counter.
 * 4.  **`AdvancedTaskSystem` Class:** Contains the `main` method, which is the entry point of the program.
 *     *   It creates a `Scanner` for user input and a `TaskManager` instance.
 *     *   It runs a `while` loop to continuously accept and process user commands.
 *     *   The main command processing logic is within a `try-catch` block to handle potential exceptions during the entire user interaction loop, fulfilling the "class-wide exception handling" requirement by wrapping the core operational part of the `main` method.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`Queue` (`pendingTasks`):** Tasks are added using `offer()` and removed using `poll()` during the `assignTask` operation, following the FIFO (First-In, First-Out) nature of a queue. `LinkedList` is used as a concrete implementation of `Queue`.
 * *   **`ArrayList` (`availableWorkers`, `allTasks`):** `availableWorkers` is an `ArrayList` storing integer worker IDs. `add()` is used to add workers. `allTasks` is an `ArrayList` storing all `Task` objects, allowing iteration for the `list all` command.
 * *   **`List` interface:** The `availableWorkers` variable is declared as `List<Integer>`, demonstrating programming to the interface rather than the specific implementation (`ArrayList`).
 * *   **`Scanner`:** Used in the `main` method to read entire lines of input from `System.in`.
 * *   **`switch` statement:** Used in the `main` method to dispatch commands based on user input (`add`, `list`, `assign`, `exit`) and subcommands (`task`, `worker`, `pending`, `workers`, `all`).
 * *   **`System.err`:** Used for displaying error messages related to invalid commands, missing arguments, incorrect input types (caught by `NumberFormatException`), or operational failures (e.g., queue empty, no workers).
 * *   **`System.out`:** Used for displaying the command prompt, success messages, and formatted lists of tasks and workers.
 * *   **`try-catch`:** A `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This provides a top-level exception handler for any unhandled runtime exceptions that might occur during command processing, preventing the program from crashing unexpectedly and providing a generic error message. A more specific `try-catch (NumberFormatException e)` is also used within the `add worker` case to handle non-integer input gracefully.
 * 
 * **Best Practices and Error Handling:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`, accessed via `public` methods.
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`), variable names (`pendingTasks`, `availableWorkers`, `nextTaskId`), and method names (`addTask`, `assignTask`) are descriptive.
 * *   **Input Validation:** Checks are performed for empty task descriptions, non-positive worker IDs, empty queues, and empty worker lists before attempting operations. Command parsing checks for missing arguments.
 * *   **Error Messages:** Error messages are printed to `System.err` and are specific to the type of error encountered.
 * *   **Code Structure:** The code is organized into logical classes (`Task`, `TaskManager`) and the main execution class (`AdvancedTaskSystem`).
 * *   **Comments:** Basic comments explain the purpose of classes, methods, and key logic sections.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating competence in data structures, control flow, input handling, and basic error management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent task status
enum TaskStatus {
    PENDING,
    ASSIGNED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;
    private Integer assignedWorkerId; // Use Integer to allow null when not assigned

    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING;
        this.assignedWorkerId = null;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public Integer getAssignedWorkerId() {
        return assignedWorkerId;
    }

    // Method to assign the task
    public void assignTo(int workerId) {
        this.status = TaskStatus.ASSIGNED;
        this.assignedWorkerId = workerId;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("ID: ").append(id).append(", Description: ").append(description)
          .append(", Status: ").append(status);
        if (status == TaskStatus.ASSIGNED) {
            sb.append(", Worker: ").append(assignedWorkerId);
        }
        return sb.toString();
    }
}

// Manages tasks and workers
class TaskManager {
    // Queue for tasks waiting to be assigned
    private Queue<Task> pendingTasks;
    // List for available worker IDs
    private List<Integer> availableWorkers;
    // List to keep track of all tasks created
    private List<Task> allTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.availableWorkers = new ArrayList<>(); // ArrayList implements List
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // Add to the end of the queue
        allTasks.add(newTask); // Add to the list of all tasks
        System.out.println("Task " + newTask.getId() + " added: " + newTask.getDescription());
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("Pending Tasks: (None)");
            return;
        }
        System.out.println("Pending Tasks:");
        // Iterate through the queue without removing elements
        for (Task task : pendingTasks) {
            System.out.println(task);
        }
    }

    /**
     * Adds a worker ID to the list of available workers.
     * @param workerId The ID of the worker.
     */
    public void addWorker(int workerId) {
        if (workerId <= 0) {
            System.err.println("Error: Worker ID must be a positive integer.");
            return;
        }
        if (availableWorkers.contains(workerId)) {
             System.err.println("Error: Worker ID " + workerId + " is already available.");
             return;
        }
        availableWorkers.add(workerId);
        System.out.println("Worker " + workerId + " added.");
    }

    /**
     * Lists all available worker IDs.
     */
    public void listWorkers() {
        if (availableWorkers.isEmpty()) {
             System.out.println("Available Workers: (None)");
        } else {
             System.out.println("Available Workers: " + availableWorkers);
        }
    }

    /**
     * Assigns the next pending task to the first available worker.
     */
    public void assignTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Cannot assign task: Pending queue is empty.");
            return;
        }
        if (availableWorkers.isEmpty()) {
            System.err.println("Cannot assign task: No workers available.");
            return;
        }

        // Get the next task from the queue (and remove it)
        Task taskToAssign = pendingTasks.poll();
        // Get the first available worker ID (and remove it, or just use it)
        // Let's simplify for exam: just use the worker ID, don't remove worker
        int workerId = availableWorkers.get(0); // Get first worker ID

        taskToAssign.assignTo(workerId); // Update task status and assigned worker

        System.out.println("Task " + taskToAssign.getId() + " '" + taskToAssign.getDescription() + "' assigned to worker " + workerId + ".");
        // Note: In a real system, the worker might become busy and removed from availableWorkers,
        // or the task might move to a different collection (e.g., assignedTasks).
        // For this problem, we just update the task status and keep workers available.
    }

    /**
     * Lists all tasks ever added to the system, regardless of status.
     */
    public void listAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("All Tasks: (None)");
            return;
        }
        System.out.println("All Tasks:");
        for (Task task : allTasks) {
            System.out.println(task);
        }
    }
}

public class AdvancedTaskSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("Task Management System");
        System.out.println("Enter command (add task <desc>, list pending, add worker <id>, list workers, assign, list all, exit):");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Skip empty input
                }

                // Split command and arguments
                String[] parts = inputLine.split(" ", 3); // Limit split to 3 parts: command, subcommand, rest

                String command = parts[0].toLowerCase();
                String subCommand = parts.length > 1 ? parts[1].toLowerCase() : "";
                String argument = parts.length > 2 ? parts[2] : ""; // The rest as argument

                switch (command) {
                    case "add":
                        switch (subCommand) {
                            case "task":
                                if (argument.isEmpty()) {
                                    System.err.println("Error: 'add task' requires a description.");
                                } else {
                                    taskManager.addTask(argument);
                                }
                                break;
                            case "worker":
                                try {
                                    if (argument.isEmpty()) {
                                         System.err.println("Error: 'add worker' requires a worker ID.");
                                    } else {
                                        int workerId = Integer.parseInt(argument);
                                        taskManager.addWorker(workerId);
                                    }
                                } catch (NumberFormatException e) {
                                    System.err.println("Error: Invalid worker ID format. Please provide an integer.");
                                }
                                break;
                            default:
                                System.err.println("Error: Unknown 'add' subcommand: " + subCommand);
                                break;
                        }
                        break;

                    case "list":
                        switch (subCommand) {
                            case "pending":
                                taskManager.listPendingTasks();
                                break;
                            case "workers":
                                taskManager.listWorkers();
                                break;
                            case "all":
                                taskManager.listAllTasks();
                                break;
                            default:
                                System.err.println("Error: Unknown 'list' subcommand: " + subCommand);
                                break;
                        }
                        break;

                    case "assign":
                        if (!subCommand.isEmpty()) {
                             System.err.println("Error: 'assign' command does not take arguments.");
                        } else {
                            taskManager.assignTask();
                        }
                        break;

                    case "exit":
                        if (!subCommand.isEmpty()) {
                             System.err.println("Error: 'exit' command does not take arguments.");
                        } else {
                            running = false;
                            System.out.println("Exiting system.");
                        }
                        break;

                    default:
                        System.err.println("Error: Unknown command: " + command);
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Optional: print stack trace for debugging
        } finally {
            scanner.close(); // Ensure scanner is closed
            System.out.println("Scanner closed.");
        }
    }
}
