/*
 * Exam Question #851
 * Generated on: 2025-05-12 16:50:31
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Package Sorting Hub Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a package sorting hub. Packages arrive and are placed in a queue awaiting processing. An operator interacts with the system to add new packages, process the next package in line, or view the current status of the hub. The hub operates with a predefined set of destination routes.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this sorting hub. Your program should provide a command-line interface for the operator to perform actions.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a queue of `Package` objects waiting to be processed.
 *     *   Maintain a list of valid destination routes.
 * 2.  **Classes:**
 *     *   Create a `Package` class with private fields for `packageId` (String) and `destinationRoute` (String). Include a constructor and public getter methods.
 *     *   Create a `SortingHub` class that manages the queue and the list of routes. This class should contain the main application logic and the `main` method.
 * 3.  **Functionality (in `SortingHub`):**
 *     *   Initialize the `SortingHub` with a predefined list of valid destination routes (e.g., "Route A", "Route B", "Route C").
 *     *   Provide a menu-driven interface for the operator with the following options:
 *         *   `add`: Prompt the operator for a package ID and a destination route. Create a `Package` object and add it to the waiting queue.
 *         *   `process`: Take the next package from the front of the queue, simulate processing it (e.g., print its details), and remove it from the queue.
 *         *   `view queue`: Display the details (ID and destination) of all packages currently in the waiting queue, in order.
 *         *   `view routes`: Display the list of valid destination routes.
 *         *   `exit`: Terminate the program.
 * 4.  **Input Handling & Validation:**
 *     *   Use `java.util.Scanner` to read operator commands and package details.
 *     *   Validate operator commands using a `switch` statement.
 *     *   Validate package input:
 *         *   Package ID and destination route should not be empty.
 *         *   The entered destination route must be one of the valid routes in the predefined list.
 *     *   If input is invalid, use `System.err` to report the specific error and do not proceed with the action (e.g., do not add an invalid package).
 * 5.  **Error Handling:**
 *     *   If the operator attempts to `process` a package when the queue is empty, print an appropriate error message using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command processing loop in the `SortingHub` class to catch any unexpected runtime exceptions and print a general error message to `System.err` before the program exits or continues (your choice, but catching and reporting is key).
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, confirmations of successful operations (e.g., package added, package processed), queue contents, and the list of routes.
 *     *   Use `System.err` for all error messages (input validation failures, empty queue processing attempt, unexpected exceptions).
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Examples:**
 * 
 * *   **Adding a valid package:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     1. add package
 *     2. process next package
 *     3. view queue
 *     4. view routes
 *     5. exit
 *     Enter command: add
 *     Enter package ID: P101
 *     Enter destination route: Route A
 *     Package P101 added to the queue for Route A.
 *     ```
 * *   **Adding a package with an invalid route:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     ...
 *     Enter command: add
 *     Enter package ID: P102
 *     Enter destination route: Route Z
 *     Error: Invalid destination route 'Route Z'. Available routes: [Route A, Route B, Route C].
 *     ```
 * *   **Processing a package:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     ...
 *     Enter command: process
 *     Processing package P101 for Route A.
 *     Package P101 processed and sent to Route A.
 *     ```
 * *   **Processing with an empty queue:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     ...
 *     Enter command: process
 *     Error: The package queue is currently empty.
 *     ```
 * *   **Viewing the queue:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     ...
 *     Enter command: view queue
 *     --- Current Package Queue ---
 *     Package ID: P103, Destination: Route B
 *     Package ID: P104, Destination: Route C
 *     --- End of Queue ---
 *     ```
 * *   **Viewing routes:**
 *     ```
 *     --- Sorting Hub Menu ---
 *     ...
 *     Enter command: view routes
 *     --- Available Routes ---
 *     Route A
 *     Route B
 *     Route C
 *     --- End of Routes ---
 *     ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`.
 * *   Implementation of all required functionality.
 * *   Correct input validation and error handling as specified.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clean and readable code.
 *
 * EXPLANATION:
 * This solution implements a `SortingHub` simulation that meets all the specified requirements, demonstrating the use of various Java concepts.
 * 
 * 1.  **`Package` Class:** This simple class encapsulates the data for a package (`packageId` and `destinationRoute`) using private fields and public getters, adhering to the principle of encapsulation. The `toString()` method provides a convenient way to display package information.
 * 
 * 2.  **`SortingHub` Class:** This is the main class orchestrating the simulation.
 *     *   **Data Structures:**
 *         *   `packageQueue`: A `Queue<Package>` is used to hold packages waiting for processing. `java.util.LinkedList` is chosen as a concrete implementation of the `Queue` interface because it provides efficient additions to the tail and removals from the head, which are typical queue operations.
 *         *   `availableRoutes`: A `List<String>` is used to store the valid destination routes. `java.util.ArrayList` is used as the concrete implementation, initialized with a few predefined routes using `Arrays.asList()`.
 *     *   **`Scanner`:** An instance of `java.util.Scanner` is used to read input from `System.in`. It's initialized once in the constructor and closed in the `finally` block of the `run` method to release system resources.
 *     *   **`displayMenu()`:** A helper method to print the available commands to `System.out`.
 *     *   **`addPackage()`:**
 *         *   Prompts the user for package details using `System.out`.
 *         *   Reads input using `scanner.nextLine()`.
 *         *   Performs input validation: checks for empty strings for ID and route, and verifies if the entered route exists in the `availableRoutes` list using `availableRoutes.contains()`.
 *         *   Validation errors are reported using `System.err`, and the method returns early if validation fails.
 *         *   If input is valid, a new `Package` object is created and added to the `packageQueue` using `packageQueue.offer()`.
 *         *   Success confirmation is printed to `System.out`.
 *     *   **`processNextPackage()`:**
 *         *   Attempts to remove and retrieve the head of the queue using `packageQueue.poll()`. `poll()` is suitable here as it returns `null` if the queue is empty, avoiding an exception.
 *         *   Checks if `packageToProcess` is `null`. If so, it means the queue was empty, and an error message is printed to `System.err`.
 *         *   If a package was retrieved, its details are printed to `System.out`, simulating processing.
 *     *   **`viewQueue()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the queue is empty. If so, prints a message to `System.out`.
 *         *   If not empty, it iterates through the `packageQueue` using a `for-each` loop. This loop iterates over the elements without removing them, which is the desired behavior for viewing. Each package's `toString()` method is implicitly called when printing. Output goes to `System.out`.
 *     *   **`viewRoutes()`:**
 *         *   Prints a header to `System.out`.
 *         *   Iterates through the `availableRoutes` list using a `for-each` loop and prints each route to `System.out`.
 *     *   **`run()`:**
 *         *   This method contains the main application loop (`while(running)`).
 *         *   It repeatedly displays the menu, reads the operator's command, and uses a `switch` statement to execute the corresponding action (`addPackage`, `processNextPackage`, `viewQueue`, `viewRoutes`, or exit).
 *         *   The `switch` statement handles both the number and the command word (case-insensitive due to `.toLowerCase()`).
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching unexpected exceptions that might occur during the program's execution cycle (though explicit exceptions are handled within methods like `addPackage` and `processNextPackage`, this outer block serves as a safety net for unforeseen issues). Any caught exception details are printed to `System.err`, including the stack trace for debugging, before the program potentially continues or exits depending on the nature of the error.
 *         *   **`finally` Block:** A `finally` block is used to ensure `scanner.close()` is called, releasing the system resource acquired by the `Scanner`, regardless of whether the loop completed normally or an exception occurred.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `SortingHub` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating good object-oriented design, input validation, and error handling practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Arrays;

/**
 * Represents a package with an ID and a destination route.
 */
class Package {
    private String packageId;
    private String destinationRoute;

    /**
     * Constructs a new Package.
     *
     * @param packageId        The unique identifier for the package.
     * @param destinationRoute The intended destination route for the package.
     */
    public Package(String packageId, String destinationRoute) {
        this.packageId = packageId;
        this.destinationRoute = destinationRoute;
    }

    /**
     * Gets the package ID.
     *
     * @return The package ID.
     */
    public String getPackageId() {
        return packageId;
    }

    /**
     * Gets the destination route.
     *
     * @return The destination route.
     */
    public String getDestinationRoute() {
        return destinationRoute;
    }

    /**
     * Returns a string representation of the package.
     *
     * @return String representation including ID and destination.
     */
    @Override
    public String toString() {
        return "Package ID: " + packageId + ", Destination: " + destinationRoute;
    }
}

/**
 * Simulates a package sorting hub managing a queue of packages
 * and a list of available routes.
 */
public class SortingHub {
    private Queue<Package> packageQueue;
    private List<String> availableRoutes;
    private Scanner scanner;

    /**
     * Constructs a SortingHub with predefined routes.
     */
    public SortingHub() {
        // Use LinkedList as a Queue implementation
        packageQueue = new LinkedList<>();

        // Use ArrayList to store available routes
        availableRoutes = new ArrayList<>(Arrays.asList("Route A", "Route B", "Route C", "Route D"));

        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the operator.
     */
    private void displayMenu() {
        System.out.println("\n--- Sorting Hub Menu ---");
        System.out.println("1. add package");
        System.out.println("2. process next package");
        System.out.println("3. view queue");
        System.out.println("4. view routes");
        System.out.println("5. exit");
        System.out.print("Enter command: ");
    }

    /**
     * Adds a new package to the queue based on operator input.
     * Performs input validation.
     */
    private void addPackage() {
        System.out.print("Enter package ID: ");
        String id = scanner.nextLine().trim();

        System.out.print("Enter destination route: ");
        String route = scanner.nextLine().trim();

        // Input Validation
        if (id.isEmpty()) {
            System.err.println("Error: Package ID cannot be empty.");
            return; // Stop adding
        }
        if (route.isEmpty()) {
            System.err.println("Error: Destination route cannot be empty.");
            return; // Stop adding
        }
        if (!availableRoutes.contains(route)) {
            System.err.println("Error: Invalid destination route '" + route + "'. Available routes: " + availableRoutes);
            return; // Stop adding
        }

        // Create and add package to the queue
        Package newPackage = new Package(id, route);
        packageQueue.offer(newPackage); // offer is preferred over add for capacity-constrained queues, but works fine here
        System.out.println("Package " + id + " added to the queue for " + route + ".");
    }

    /**
     * Processes (removes and reports) the next package from the queue.
     * Handles the case of an empty queue.
     */
    private void processNextPackage() {
        Package packageToProcess = packageQueue.poll(); // poll retrieves and removes, returns null if empty

        if (packageToProcess == null) {
            System.err.println("Error: The package queue is currently empty.");
        } else {
            System.out.println("Processing package " + packageToProcess.getPackageId() + " for " + packageToProcess.getDestinationRoute() + ".");
            // Simulate further processing here if needed
            System.out.println("Package " + packageToProcess.getPackageId() + " processed and sent to " + packageToProcess.getDestinationRoute() + ".");
        }
    }

    /**
     * Displays the contents of the package queue.
     */
    private void viewQueue() {
        System.out.println("--- Current Package Queue ---");
        if (packageQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : packageQueue) {
                System.out.println(pkg);
            }
        }
        System.out.println("--- End of Queue ---");
    }

    /**
     * Displays the list of available destination routes.
     */
    private void viewRoutes() {
        System.out.println("--- Available Routes ---");
        if (availableRoutes.isEmpty()) {
            System.out.println("No routes defined.");
        } else {
            for (String route : availableRoutes) {
                System.out.println(route);
            }
        }
        System.out.println("--- End of Routes ---");
    }

    /**
     * Runs the main simulation loop, handling operator commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        String command;
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                command = scanner.nextLine().trim().toLowerCase(); // Read command and convert to lowercase

                switch (command) {
                    case "1": // Fall-through
                    case "add":
                        addPackage();
                        break;
                    case "2": // Fall-through
                    case "process":
                        processNextPackage();
                        break;
                    case "3": // Fall-through
                    case "view queue":
                        viewQueue();
                        break;
                    case "4": // Fall-through
                    case "view routes":
                        viewRoutes();
                        break;
                    case "5": // Fall-through
                    case "exit":
                        System.out.println("Exiting Sorting Hub simulation. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Unknown command '" + command + "'. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the execution loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed regardless of exceptions
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * The main method to start the Sorting Hub simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SortingHub hub = new SortingHub();
        hub.run();
    }
}
