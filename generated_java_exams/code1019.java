/*
 * Exam Question #1019
 * Generated on: 2025-05-12 17:13:40
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Venue Management System
 * 
 * **Objective:** Design and implement a console-based Java application to simulate a simple venue management system. The system tracks attendees for an event with a fixed capacity, managing entry and a waiting list.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Class:**
 *     *   Create a class `Attendee` with private fields: `name` (String) and `id` (int).
 *     *   Include a constructor `Attendee(String name, int id)`.
 *     *   Provide public getter methods for `name` and `id`.
 *     *   Override `equals()` and `hashCode()` methods based *solely* on the `id` field. This ensures attendees are uniquely identified by their ID in collections.
 *     *   Override the `toString()` method for easy printing of attendee information.
 * 
 * 2.  **VenueManager Class:**
 *     *   Create a class `VenueManager` with private fields: `capacity` (int), `waitingList` (a `Queue<Attendee>`), and `attendeesInside` (a `List<Attendee>`).
 *     *   The constructor `VenueManager(int capacity)` should initialize `capacity` and the collections. It must throw an `IllegalArgumentException` if the capacity is not positive.
 *     *   Implement `public boolean isVenueFull()`: Returns `true` if the number of attendees inside equals or exceeds the capacity.
 *     *   Implement `public void registerAttendee(Attendee attendee)`:
 *         *   Check if an attendee with the same ID is already present in *either* the `waitingList` or `attendeesInside`. If so, print an error message to `System.err` and return.
 *         *   If the venue is full (`isVenueFull()` is true), add the attendee to the `waitingList` using the appropriate `Queue` method. Print a success message to `System.out`.
 *         *   If the venue is not full, add the attendee to the `attendeesInside` list using the appropriate `List` method. Print a success message to `System.out`.
 *     *   Implement `public void processEntry()`:
 *         *   If the `waitingList` is empty, print an error message to `System.err` and return.
 *         *   If the venue is full (`isVenueFull()` is true), print an error message to `System.err` indicating entry cannot be processed yet and return.
 *         *   Otherwise, remove the next attendee from the front of the `waitingList` and add them to the `attendeesInside` list. Print a success message to `System.out`.
 *     *   Implement `public void displayWaitingList()`: Iterate through the `waitingList` and print each attendee's details to `System.out`. Print a message indicating if the list is empty.
 *     *   Implement `public void displayAttendeesInside()`: Iterate through the `attendeesInside` list and print each attendee's details to `System.out`. Print a message indicating if the list is empty.
 * 
 * 3.  **VenueManagementSystem (Main Class):**
 *     *   Create a class `VenueManagementSystem` containing the `main` method.
 *     *   Use a `Scanner` object to read input from `System.in`.
 *     *   Prompt the user to enter the venue capacity at the beginning of the program. Use a `try-catch` block to handle non-integer input and validate that the capacity is a positive number. Use `System.err` for validation errors.
 *     *   Create an instance of `VenueManager` with the validated capacity. Catch the `IllegalArgumentException` from the constructor and print an error to `System.err` if it occurs, then exit.
 *     *   Implement a menu-driven interface using a `while` loop and a `switch` statement. The menu options should be:
 *         1.  Register Attendee
 *         2.  Process Entry from Waiting List
 *         3.  Display Waiting List
 *         4.  Display Attendees Inside Venue
 *         5.  Exit
 *     *   For option 1 (Register Attendee), prompt the user for the attendee's name (String) and ID (int). Use `try-catch` to handle non-integer input for the ID and validate that the ID is positive. Use `System.err` for validation errors. Create an `Attendee` object and call `venueManager.registerAttendee()`.
 *     *   For options 2, 3, and 4, call the corresponding `VenueManager` methods.
 *     *   For option 5, exit the loop and the program.
 *     *   For invalid menu choices, print an error message to `System.err`.
 *     *   Implement class-wide exception handling: Wrap the main menu loop (or the core logic within `main`) in a `try-catch(Exception e)` block to catch any unexpected runtime errors. Print a general error message and the stack trace to `System.err`. Handle specific input errors (`InputMismatchException`) locally where input is read.
 *     *   Ensure the `Scanner` resource is properly closed when the program finishes.
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, list displays).
 *     *   Use `System.err` for all error messages (input validation, venue full, waiting list empty, attendee already registered, invalid menu choice, unexpected errors).
 * 
 * **Required Java Components:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling with `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation.
 * *   Input validation.
 * *   Proper error handling.
 * *   Clean code structure (using multiple classes).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, guiding the user through operations with clear prompts and messages. Errors should be distinctly printed to the error stream. The output should demonstrate attendees being added inside or to the waiting list based on capacity, processing entries from the queue, and displaying the current state of both lists.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Venue Management System ---
 * Enter venue capacity: 2
 * Venue created with capacity: 2
 * 
 * --- Menu ---
 * 1. Register Attendee
 * ...
 * Enter your choice: 1
 * Enter Attendee Name: Alice
 * Enter Attendee ID (positive number): 101
 * Attendee Alice (ID: 101) entered the venue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter Attendee Name: Bob
 * Enter Attendee ID (positive number): 102
 * Attendee Bob (ID: 102) entered the venue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter Attendee Name: Charlie
 * Enter Attendee ID (positive number): 103
 * Venue full. Attendee Charlie (ID: 103) added to waiting list.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter Attendee Name: David
 * Enter Attendee ID (positive number): 101
 * Error: Attendee with ID 101 is already registered.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Waiting List ---
 * Attendee [ID=103, Name=Charlie]
 * --------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Processed entry: Attendee Charlie (ID: 103) moved from waiting list to inside venue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Attendees Inside Venue ---
 * Attendee [ID=101, Name=Alice]
 * Attendee [ID=102, Name=Bob]
 * Attendee [ID=103, Name=Charlie]
 * ----------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Venue Management System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Attendee` Class:**
 *     *   Represents an attendee with `name` and `id` as private fields, adhering to encapsulation.
 *     *   Getters provide controlled access to the data.
 *     *   `equals()` and `hashCode()` are correctly overridden based on the `id`. This is crucial because collections like `ArrayList` and `LinkedList` (used for `List` and `Queue`) rely on these methods to determine if an object is already present (`contains()` method) or for internal hashing if used in hash-based collections (though not strictly required for this problem's collections, it's good practice when overriding `equals`).
 *     *   `toString()` provides a readable representation for printing.
 * 
 * 2.  **`VenueManager` Class:**
 *     *   Manages the state of the venue: `capacity`, `waitingList` (implemented as a `LinkedList` which implements `Queue`), and `attendeesInside` (implemented as an `ArrayList` which implements `List`). Using `Queue` and `List` interfaces for the field types promotes flexibility.
 *     *   The constructor validates the capacity, throwing `IllegalArgumentException` if invalid.
 *     *   `isVenueFull()` checks the size of the `attendeesInside` list against the `capacity`.
 *     *   `registerAttendee()` uses `List.contains()` and `Queue.contains()` to check for duplicates (relying on the `equals()` method in `Attendee`). It then conditionally adds the attendee to `attendeesInside` or `waitingList` based on venue capacity, using `List.add()` and `Queue.offer()`. Messages are printed to `System.out` or `System.err` accordingly.
 *     *   `processEntry()` checks if processing is possible (waiting list not empty, venue not full). It uses `Queue.poll()` to retrieve and remove the head of the waiting list (FIFO behavior) and then adds the attendee to the `attendeesInside` list. Messages are printed to `System.out` or `System.err`.
 *     *   `displayWaitingList()` and `displayAttendeesInside()` iterate through the respective collections using enhanced for loops and print attendee details to `System.out`.
 * 
 * 3.  **`VenueManagementSystem` Class (Main):**
 *     *   The `main` method serves as the application entry point and controller.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   Input validation for capacity and attendee ID is performed using `try-catch(InputMismatchException)` blocks to handle non-integer input. Error messages for invalid input or values (non-positive) are printed to `System.err`. `scanner.next()` or `scanner.nextLine()` is used to consume invalid input and prevent infinite loops.
 *     *   The core application logic (the menu loop) is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime errors that might occur within the loop and printing a general error message and stack trace to `System.err`. A specific `catch(IllegalArgumentException)` is included to handle the potential exception from the `VenueManager` constructor during setup.
 *     *   A `while` loop runs the menu until the user chooses to exit.
 *     *   A `switch` statement processes the user's menu choice, calling the appropriate methods in the `VenueManager` or the local `registerAttendee` helper method.
 *     *   `System.out` is used for menu display, prompts, and successful operation messages.
 *     *   `System.err` is used for all error conditions (invalid input, operational errors like venue full/waiting list empty, invalid menu choice, unexpected system errors).
 *     *   The `scanner.close()` is placed in a `finally` block to ensure the resource is released regardless of whether the program finishes normally or exits due to an exception.
 *     *   Helper methods `printMenu()` and `registerAttendee()` improve code organization and readability.
 * 
 * This solution effectively utilizes `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks in a practical scenario while adhering to good programming practices like encapsulation, meaningful naming, and error handling.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents an attendee with a unique ID and name
class Attendee {
    private String name;
    private int id;

    /**
     * Constructs an Attendee object.
     * @param name The name of the attendee.
     * @param id The unique ID of the attendee.
     */
    public Attendee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    /**
     * Gets the attendee's name.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the attendee's ID.
     * @return The ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Provides a string representation of the Attendee.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Attendee [ID=" + id + ", Name=" + name + "]";
    }

    /**
     * Checks equality based on Attendee ID.
     * @param o The object to compare with.
     * @return true if objects are equal (same ID), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id == attendee.id; // Equality based on unique ID
    }

    /**
     * Generates a hash code based on Attendee ID.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Integer.hashCode(id); // Hash code based on unique ID
    }
}

// Manages the venue, including capacity, attendees inside, and waiting list.
class VenueManager {
    private int capacity;
    private Queue<Attendee> waitingList;
    private List<Attendee> attendeesInside;

    /**
     * Constructs a VenueManager with a specified capacity.
     * @param capacity The maximum number of attendees allowed inside.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public VenueManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Venue capacity must be positive.");
        }
        this.capacity = capacity;
        this.waitingList = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.attendeesInside = new ArrayList<>();
    }

    /**
     * Checks if the venue has reached its maximum capacity.
     * @return true if the venue is full, false otherwise.
     */
    public boolean isVenueFull() {
        return attendeesInside.size() >= capacity;
    }

    /**
     * Registers an attendee. Adds them inside if space is available, otherwise to the waiting list.
     * @param attendee The attendee to register.
     */
    public void registerAttendee(Attendee attendee) {
        // Check if attendee is already registered (either inside or waiting)
        if (attendeesInside.contains(attendee) || waitingList.contains(attendee)) {
            System.err.println("Error: Attendee with ID " + attendee.getId() + " is already registered.");
            return;
        }

        if (isVenueFull()) {
            // Add to waiting list (FIFO)
            if (waitingList.offer(attendee)) { // offer is safe for capacity-constrained queues, but LinkedList is unbounded
                System.out.println("Venue full. Attendee " + attendee.getName() + " (ID: " + attendee.getId() + ") added to waiting list.");
            } else {
                 // This case is unlikely with LinkedList but good practice for Queue interface
                 System.err.println("Error: Could not add attendee " + attendee.getName() + " to waiting list.");
            }
        } else {
            // Add directly inside
            attendeesInside.add(attendee);
            System.out.println("Attendee " + attendee.getName() + " (ID: " + attendee.getId() + ") entered the venue.");
        }
    }

    /**
     * Processes the next attendee from the waiting list for entry into the venue.
     */
    public void processEntry() {
        if (waitingList.isEmpty()) {
            System.err.println("Error: Waiting list is empty. No one to process.");
            return;
        }

        if (isVenueFull()) {
            System.err.println("Error: Venue is full. Cannot process entry from waiting list yet.");
            return;
        }

        // Get and remove the head of the queue (FIFO)
        Attendee nextAttendee = waitingList.poll();
        if (nextAttendee != null) {
             attendeesInside.add(nextAttendee); // Add to inside list
             System.out.println("Processed entry: Attendee " + nextAttendee.getName() + " (ID: " + nextAttendee.getId() + ") moved from waiting list to inside venue.");
        } else {
            // Should not happen if waitingList was not empty
            System.err.println("Error: Failed to retrieve attendee from waiting list.");
        }
    }

    /**
     * Displays all attendees currently in the waiting list.
     */
    public void displayWaitingList() {
        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate over the Queue elements
            for (Attendee attendee : waitingList) {
                System.out.println(attendee);
            }
        }
        System.out.println("--------------------\n");
    }

    /**
     * Displays all attendees currently inside the venue.
     */
    public void displayAttendeesInside() {
        System.out.println("\n--- Attendees Inside Venue ---");
        if (attendeesInside.isEmpty()) {
            System.out.println("Venue is empty.");
        } else {
            // Iterate over the List elements
            for (Attendee attendee : attendeesInside) {
                System.out.println(attendee);
            }
        }
        System.out.println("----------------------------\n");
    }
}

// Main class for the Venue Management System application.
public class VenueManagementSystem {

    private static Scanner scanner = new Scanner(System.in);
    private static VenueManager venueManager;

    /**
     * Main method to run the Venue Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        System.out.println("--- Venue Management System ---");

        // Get venue capacity from user with validation
        int capacity = -1;
        while (capacity <= 0) {
            System.out.print("Enter venue capacity: ");
            try {
                capacity = scanner.nextInt();
                if (capacity <= 0) {
                    System.err.println("Error: Capacity must be a positive number.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for capacity.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            }
        }
        scanner.nextLine(); // Consume the leftover newline character after reading the integer

        try {
            // Initialize VenueManager
            venueManager = new VenueManager(capacity);
            System.out.println("Venue created with capacity: " + capacity);

            // Main application loop wrapped in try-catch for class-wide handling
            boolean running = true;
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline after reading integer
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop body and show menu again
                }

                // Process user choice using switch statement
                switch (choice) {
                    case 1:
                        registerAttendee();
                        break;
                    case 2:
                        venueManager.processEntry();
                        break;
                    case 3:
                        venueManager.displayWaitingList();
                        break;
                    case 4:
                        venueManager.displayAttendeesInside();
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please try again.");
                }
            }
        } catch (IllegalArgumentException e) {
            // Catch specific exception from VenueManager constructor
            System.err.println("System startup failed: " + e.getMessage());
        } catch (Exception e) {
            // General catch-all for any unexpected runtime errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } finally {
            // Ensure scanner is closed regardless of how the program exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Process Entry from Waiting List");
        System.out.println("3. Display Waiting List");
        System.out.println("4. Display Attendees Inside Venue");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Handles the process of registering a new attendee based on user input.
     */
    private static void registerAttendee() {
        System.out.print("Enter Attendee Name: ");
        String name = scanner.nextLine();

        int id = -1;
        while (id <= 0) {
            System.out.print("Enter Attendee ID (positive number): ");
            try {
                id = scanner.nextInt();
                if (id <= 0) {
                    System.err.println("Error: ID must be a positive number.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for ID.");
                scanner.next(); // Consume invalid input
            }
        }
        scanner.nextLine(); // Consume newline after reading integer ID

        Attendee newAttendee = new Attendee(name, id);
        venueManager.registerAttendee(newAttendee);
    }
}
