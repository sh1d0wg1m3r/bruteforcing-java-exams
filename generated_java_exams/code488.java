/*
 * Exam Question #488
 * Generated on: 2025-05-11 23:18:41
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Delivery Hub Management
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified management system for a package delivery hub. The system should simulate the process of receiving packages, placing them in a queue for sorting, and then assigning them to specific delivery routes.
 * 
 * The system must be interactive, using a menu-driven interface via the console.
 * 
 * **Entities:**
 * 
 * 1.  **Package:** Represents a package with a unique integer `packageId`. It will also store the `destinationRouteId` once assigned.
 * 2.  **Route:** Represents a delivery route with a unique integer `routeId`. Each route maintains a collection of `Package` objects assigned to it.
 * 
 * **Functionality:**
 * 
 * Implement a `DeliveryHub` class that manages the system. This class should provide the following operations via a main menu:
 * 
 * 1.  **Add Package to Queue:** Prompt the user for a package ID and add a new `Package` object to a processing queue.
 * 2.  **Process Package from Queue:** Take the package at the front of the processing queue. Prompt the user for a destination route ID. Find the specified route and add the package to its list of assigned packages. If the queue is empty or the route is not found, display an error message.
 * 3.  **View Processing Queue:** Display the IDs of all packages currently in the processing queue, in order.
 * 4.  **View Packages on Route:** Prompt the user for a route ID and display the IDs of all packages currently assigned to that route. If the route is not found, display an error message.
 * 5.  **List All Routes:** Display the IDs of all available routes.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following requirements:
 * 
 * *   Use `java.util.Queue` to represent the processing queue (e.g., using `LinkedList` as the implementation).
 * *   Use `java.util.ArrayList` as the concrete implementation for storing the list of `Route` objects and the list of `Package` objects within each `Route`.
 * *   Declare collections using the `java.util.List` interface where appropriate (e.g., the list of routes, the list of packages in a route).
 * *   Use `java.util.Scanner` to handle all user input (menu choice, package ID, route ID).
 * *   Implement the main menu navigation using a `switch` statement.
 * *   Use `System.err` to output all error messages (e.g., invalid menu choice, invalid input type, empty queue, route not found).
 * *   Use `System.out` for all normal output (menu, prompts, success messages, list displays).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, such as invalid input format (`NumberFormatException` or `InputMismatchException`) or any other unexpected exceptions during the main operational loop.
 * *   Follow Java best practices:
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation explaining key parts of the code.
 *     *   Implement basic input validation (checking for empty queue, existing routes, handling non-numeric input).
 *     *   Ensure proper error handling flow.
 *     *   Structure the code into logical classes (`Package`, `Route`, `DeliveryHub`, `Main`).
 * *   Initialize the `DeliveryHub` with at least three predefined routes (e.g., Route IDs 101, 102, 103). The processing queue should start empty.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, print relevant information or errors, and loop until the user chooses to exit. Error messages should go to standard error, and normal output to standard output.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Delivery Hub Menu ---
 * 1. Add Package to Queue
 * ...
 * Enter your choice: 1
 * Enter Package ID to add: 1001
 * Package 1001 added to processing queue.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 3
 * --- Processing Queue Contents ---
 * Package [ID=1001, Route=Unassigned]
 * ---------------------------------
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 2
 * Processing Package ID: 1001
 * Enter Destination Route ID for Package 1001: 102
 * Package 1001 assigned to Route 102.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 4
 * Enter Route ID to view packages: 102
 * --- Packages on Route 102 ---
 * Package [ID=1001, Route=102]
 * ------------------------------------
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 2
 * Error: Processing queue is empty. Cannot process package.
 * ```
 * 
 * Your solution should provide the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Package Delivery Hub Management System as requested. It demonstrates the use of several core Java concepts and data structures in a practical scenario.
 * 
 * 1.  **Class Structure:** The system is organized into three main classes:
 *     *   `Package`: A simple Plain Old Java Object (POJO) representing a package with an ID and a field to store its assigned route ID. Encapsulation is used with private fields and public getter/setter methods.
 *     *   `Route`: A POJO representing a delivery route. It has a route ID and an `ArrayList` to hold the `Package` objects assigned to it. It uses the `List` interface for declaring the package collection.
 *     *   `DeliveryHub`: This is the main class that orchestrates the system. It holds the central data structures (`Queue` for processing, `List` for routes) and contains the methods for the various operations (add, process, view). It also manages user interaction via `Scanner`.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue`: The `processingQueue` is declared as a `Queue<Package>` and implemented using `java.util.LinkedList`. The `offer()` method is used to add packages (standard queue practice), and `poll()` is used to retrieve and remove packages from the front.
 *     *   `java.util.List` and `java.util.ArrayList`: The collection of `Route` objects (`routes`) is declared as `List<Route>` and implemented using `ArrayList`. Similarly, within the `Route` class, the collection of packages (`packages`) is declared as `List<Package>` and implemented using `ArrayList`. This demonstrates programming to the interface (`List`) while using a concrete implementation (`ArrayList`).
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     *   A `java.util.Scanner` object is used in the `DeliveryHub` class to read user input from the console for menu choices, package IDs, and route IDs.
 *     *   A `switch` statement in the `run()` method is used to direct the program flow based on the user's menu selection, calling the appropriate private methods (`addPackage`, `processPackage`, etc.).
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, successful operation messages, and the contents of the queues and routes.
 *     *   `System.err.println()` is specifically used for outputting error messages, such as invalid menu choices, cases where the queue is empty, or when a specified route ID is not found. This directs error output to the standard error stream, which is a best practice.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A single `try-catch` block is wrapped around the main `while` loop in the `run()` method. This provides "class-wide" handling for exceptions that might occur during the execution of the main application loop, particularly during user input reading or method calls.
 *     *   It specifically catches `InputMismatchException`, which is commonly thrown by `Scanner` when trying to read a specific type (like `int`) but the input doesn't match that type. The `scanner.nextLine()` call within the catch block is crucial to consume the invalid input and prevent an infinite loop.
 *     *   A general `catch (Exception e)` block is included to catch any other unexpected runtime exceptions, providing a basic level of robustness and preventing the program from crashing abruptly.
 *     *   A `finally` block is used to ensure the `Scanner` object is closed, releasing the underlying system resource.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Package` and `Route` are `private`, accessed via `public` methods.
 *     *   **Meaningful Names:** Variable names (`processingQueue`, `destinationRouteId`), method names (`addPackage`, `findRouteById`), and class names are descriptive.
 *     *   **Comments:** Basic comments are included to explain the purpose of classes, methods, and key logic sections.
 *     *   **Input Validation & Error Handling:** Checks are performed before attempting operations (e.g., `processingQueue.isEmpty()`). Invalid integer input is handled via `try-catch`. Non-existent routes are checked for and reported via `System.err`.
 *     *   **Clean Structure:** The code is divided into logical units (classes and methods), making it more readable and maintainable. Helper methods like `findRouteById` encapsulate specific logic.
 * 
 * This solution effectively integrates all the required Java components into a functional, albeit simplified, application, demonstrating an understanding of data structures, control flow, user interaction, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-integer input

// Represents a package in the system
class Package {
    private int packageId;
    private int destinationRouteId; // Assigned during processing, -1 if unassigned

    /**
     * Constructs a new Package with a given ID.
     * Destination route is initially unassigned (-1).
     * @param packageId The unique identifier for the package.
     */
    public Package(int packageId) {
        this.packageId = packageId;
        this.destinationRouteId = -1; // -1 signifies unassigned
    }

    /**
     * Gets the package ID.
     * @return The package ID.
     */
    public int getPackageId() {
        return packageId;
    }

    /**
     * Gets the assigned destination route ID.
     * @return The destination route ID, or -1 if unassigned.
     */
    public int getDestinationRouteId() {
        return destinationRouteId;
    }

    /**
     * Sets the destination route ID for the package.
     * @param destinationRouteId The ID of the route this package is assigned to.
     */
    public void setDestinationRouteId(int destinationRouteId) {
        this.destinationRouteId = destinationRouteId;
    }

    /**
     * Provides a string representation of the Package.
     * @return A string describing the package ID and its assignment status.
     */
    @Override
    public String toString() {
        return "Package [ID=" + packageId + ", Route=" + (destinationRouteId == -1 ? "Unassigned" : destinationRouteId) + "]";
    }
}

// Represents a delivery route
class Route {
    private int routeId;
    private List<Package> packages; // List interface for packages on this route

    /**
     * Constructs a new Route with a given ID.
     * Initializes an empty list for packages.
     * @param routeId The unique identifier for the route.
     */
    public Route(int routeId) {
        this.routeId = routeId;
        this.packages = new ArrayList<>(); // ArrayList implementation
    }

    /**
     * Gets the route ID.
     * @return The route ID.
     */
    public int getRouteId() {
        return routeId;
    }

    /**
     * Gets the list of packages assigned to this route.
     * @return The list of packages.
     */
    public List<Package> getPackages() {
        return packages;
    }

    /**
     * Adds a package to this route's list.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        this.packages.add(pkg);
    }

     /**
     * Provides a string representation of the Route.
     * @return A string describing the route ID and the number of packages assigned.
     */
    @Override
    public String toString() {
        return "Route [ID=" + routeId + ", Packages=" + packages.size() + "]";
    }
}

// Manages the package processing and routing operations
class DeliveryHub {
    private Queue<Package> processingQueue; // Queue interface for packages awaiting processing
    private List<Route> routes; // List interface for available routes
    private Scanner scanner;

    /**
     * Constructs the DeliveryHub.
     * Initializes the processing queue, routes list, and scanner.
     * Adds initial predefined routes.
     */
    public DeliveryHub() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.routes = new ArrayList<>(); // ArrayList implementation for routes
        this.scanner = new Scanner(System.in);

        // Add some initial routes as required
        routes.add(new Route(101));
        routes.add(new Route(102));
        routes.add(new Route(103));
        System.out.println("Delivery Hub initialized with routes: 101, 102, 103.");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Delivery Hub Menu ---");
        System.out.println("1. Add Package to Queue");
        System.out.println("2. Process Package from Queue");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Packages on Route");
        System.out.println("5. List All Routes");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles adding a new package to the processing queue.
     * Prompts user for package ID.
     */
    private void addPackage() {
        System.out.print("Enter Package ID to add: ");
        int packageId = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()

        Package newPackage = new Package(packageId);
        processingQueue.offer(newPackage); // offer() is safer than add() for capacity-constrained queues, though LinkedList is not capacity constrained. It's standard Queue practice.
        System.out.println("Package " + packageId + " added to processing queue.");
    }

    /**
     * Handles processing a package from the front of the queue.
     * Assigns it to a user-specified route.
     */
    private void processPackage() {
        // Input validation: Check if queue is empty
        if (processingQueue.isEmpty()) {
            System.err.println("Error: Processing queue is empty. Cannot process package.");
            return;
        }

        // Retrieve and remove the package from the front of the queue
        Package packageToProcess = processingQueue.poll(); // poll() returns null if queue is empty, but we already checked

        System.out.println("Processing Package ID: " + packageToProcess.getPackageId());

        System.out.print("Enter Destination Route ID for Package " + packageToProcess.getPackageId() + ": ");
        int destinationRouteId = scanner.nextInt();
        scanner.nextLine(); // Consume the newline

        // Find the target route
        Route targetRoute = findRouteById(destinationRouteId);

        // Error handling: Check if route was found
        if (targetRoute == null) {
            System.err.println("Error: Route ID " + destinationRouteId + " not found. Package " + packageToProcess.getPackageId() + " remains unprocessed.");
            // In a real system, you might re-queue, log, or put in an error state.
            // For simplicity here, we just report the error. The package is gone from the processing queue.
            // If we wanted it back, we'd use offer() here: processingQueue.offer(packageToProcess);
        } else {
            packageToProcess.setDestinationRouteId(destinationRouteId);
            targetRoute.addPackage(packageToProcess);
            System.out.println("Package " + packageToProcess.getPackageId() + " assigned to Route " + destinationRouteId + ".");
        }
    }

    /**
     * Helper method to find a Route object by its ID.
     * @param routeId The ID of the route to find.
     * @return The Route object if found, otherwise null.
     */
    private Route findRouteById(int routeId) {
        for (Route route : routes) {
            if (route.getRouteId() == routeId) {
                return route;
            }
        }
        return null; // Route not found
    }

    /**
     * Displays the contents of the processing queue without removing elements.
     */
    private void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue Contents ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue elements (e.g., using a for-each loop or iterator)
            // Iterating doesn't remove elements from a Queue
            for (Package pkg : processingQueue) {
                System.out.println(pkg);
            }
        }
        System.out.println("---------------------------------");
    }

    /**
     * Displays packages assigned to a specific route.
     * Prompts user for route ID.
     */
    private void viewRoutePackages() {
        System.out.print("Enter Route ID to view packages: ");
        int routeId = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        Route targetRoute = findRouteById(routeId);

        // Error handling: Check if route was found
        if (targetRoute == null) {
            System.err.println("Error: Route ID " + routeId + " not found.");
        } else {
            System.out.println("\n--- Packages on Route " + routeId + " ---");
            List<Package> packagesOnRoute = targetRoute.getPackages(); // Get the List using the interface
            if (packagesOnRoute.isEmpty()) {
                System.out.println("No packages assigned to this route yet.");
            } else {
                for (Package pkg : packagesOnRoute) {
                    System.out.println(pkg);
                }
            }
            System.out.println("------------------------------------");
        }
    }

    /**
     * Lists all available route IDs and the number of packages assigned to each.
     */
    private void listRoutes() {
        System.out.println("\n--- Available Routes ---");
        if (routes.isEmpty()) {
             System.out.println("No routes available.");
        } else {
            // Iterate through the List of routes
            for (Route route : routes) {
                System.out.println(route); // Route's toString method is used here
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main interactive loop for the Delivery Hub system.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        // Use a single try-catch block around the main loop to handle
        // exceptions occurring during user interaction (Scanner) or operations.
        try {
            while (choice != 6) {
                displayMenu();

                // Read user choice - potential InputMismatchException here
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline

                // Use switch for menu navigation
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processPackage();
                        break;
                    case 3:
                        viewProcessingQueue();
                        break;
                    case 4:
                        viewRoutePackages();
                        break;
                    case 5:
                        listRoutes();
                        break;
                    case 6:
                        System.out.println("Exiting Delivery Hub. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (InputMismatchException e) {
            // Catch specific exception for non-integer input from Scanner
            System.err.println("Error: Invalid input. Please enter a number for the menu choice or IDs.");
            scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
            // The loop will continue, prompting the user again.
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging in exam context if needed
        } finally {
             // Ensure the scanner resource is closed when the program exits the try/catch block
             if (scanner != null) {
                 scanner.close();
             }
        }
    }
}

// Main class to start the application
public class Main {
    public static void main(String[] args) {
        DeliveryHub hub = new DeliveryHub();
        hub.run();
    }
}
